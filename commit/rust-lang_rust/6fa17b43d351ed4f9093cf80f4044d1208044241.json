{"sha": "6fa17b43d351ed4f9093cf80f4044d1208044241", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYTE3YjQzZDM1MWVkNGY5MDkzY2Y4MGY0MDQ0ZDEyMDgwNDQyNDE=", "commit": {"author": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-06-25T21:48:36Z"}, "committer": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-07-24T00:03:04Z"}, "message": "Rewrite the improper_ctypes lint.\n\nMakes the lint a bit more accurate, and improves the quality of the diagnostic\nmessages by explicitly returning an error message.\n\nThe new lint is also a little more aggressive: specifically, it now\nrejects tuples, and it recurses into function pointers.", "tree": {"sha": "7b83ba2d846643e167815d8990a458764adebc48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b83ba2d846643e167815d8990a458764adebc48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fa17b43d351ed4f9093cf80f4044d1208044241", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa17b43d351ed4f9093cf80f4044d1208044241", "html_url": "https://github.com/rust-lang/rust/commit/6fa17b43d351ed4f9093cf80f4044d1208044241", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fa17b43d351ed4f9093cf80f4044d1208044241/comments", "author": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d", "html_url": "https://github.com/rust-lang/rust/commit/d4d4206e5604b86fc4a9b28a8b51d99121cc3a5d"}], "stats": {"total": 522, "additions": 345, "deletions": 177}, "files": [{"sha": "64e707f6264e6cae2bdf35ea569ea228e0fd8962", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 124, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -3967,7 +3967,6 @@ def_type_content_sets! {\n         None                                = 0b0000_0000__0000_0000__0000,\n \n         // Things that are interior to the value (first nibble):\n-        InteriorUnsized                     = 0b0000_0000__0000_0000__0001,\n         InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n         InteriorParam                       = 0b0000_0000__0000_0000__0100,\n         // InteriorAll                         = 0b00000000__00000000__1111,\n@@ -3977,18 +3976,9 @@ def_type_content_sets! {\n         OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n         OwnsAll                             = 0b0000_0000__1111_1111__0000,\n \n-        // Things that are reachable by the value in any way (fourth nibble):\n-        ReachesBorrowed                     = 0b0000_0010__0000_0000__0000,\n-        ReachesMutable                      = 0b0000_1000__0000_0000__0000,\n-        ReachesFfiUnsafe                    = 0b0010_0000__0000_0000__0000,\n-        ReachesAll                          = 0b0011_1111__0000_0000__0000,\n-\n         // Things that mean drop glue is necessary\n         NeedsDrop                           = 0b0000_0000__0000_0111__0000,\n \n-        // Things that prevent values from being considered sized\n-        Nonsized                            = 0b0000_0000__0000_0000__0001,\n-\n         // All bits\n         All                                 = 0b1111_1111__1111_1111__1111\n     }\n@@ -4007,10 +3997,6 @@ impl TypeContents {\n         self.intersects(TC::OwnsOwned)\n     }\n \n-    pub fn is_sized(&self, _: &ctxt) -> bool {\n-        !self.intersects(TC::Nonsized)\n-    }\n-\n     pub fn interior_param(&self) -> bool {\n         self.intersects(TC::InteriorParam)\n     }\n@@ -4019,29 +4005,13 @@ impl TypeContents {\n         self.intersects(TC::InteriorUnsafe)\n     }\n \n-    pub fn interior_unsized(&self) -> bool {\n-        self.intersects(TC::InteriorUnsized)\n-    }\n-\n     pub fn needs_drop(&self, _: &ctxt) -> bool {\n         self.intersects(TC::NeedsDrop)\n     }\n \n     /// Includes only those bits that still apply when indirected through a `Box` pointer\n     pub fn owned_pointer(&self) -> TypeContents {\n-        TC::OwnsOwned | (\n-            *self & (TC::OwnsAll | TC::ReachesAll))\n-    }\n-\n-    /// Includes only those bits that still apply when indirected through a reference (`&`)\n-    pub fn reference(&self, bits: TypeContents) -> TypeContents {\n-        bits | (\n-            *self & TC::ReachesAll)\n-    }\n-\n-    /// Includes only those bits that still apply when indirected through a raw pointer (`*`)\n-    pub fn unsafe_pointer(&self) -> TypeContents {\n-        *self & TC::ReachesAll\n+        TC::OwnsOwned | (*self & TC::OwnsAll)\n     }\n \n     pub fn union<T, F>(v: &[T], mut f: F) -> TypeContents where\n@@ -4129,7 +4099,7 @@ impl<'tcx> TyS<'tcx> {\n             let result = match ty.sty {\n                 // usize and isize are ffi-unsafe\n                 TyUint(ast::TyUs) | TyInt(ast::TyIs) => {\n-                    TC::ReachesFfiUnsafe\n+                    TC::None\n                 }\n \n                 // Scalar and unique types are sendable, and durable\n@@ -4140,40 +4110,35 @@ impl<'tcx> TyS<'tcx> {\n                 }\n \n                 TyBox(typ) => {\n-                    TC::ReachesFfiUnsafe | tc_ty(cx, typ, cache).owned_pointer()\n+                    tc_ty(cx, typ, cache).owned_pointer()\n                 }\n \n-                TyTrait(box TraitTy { ref bounds, .. }) => {\n-                    object_contents(bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n+                TyTrait(_) => {\n+                    TC::All - TC::InteriorParam\n                 }\n \n-                TyRawPtr(ref mt) => {\n-                    tc_ty(cx, mt.ty, cache).unsafe_pointer()\n+                TyRawPtr(_) => {\n+                    TC::None\n                 }\n \n-                TyRef(r, ref mt) => {\n-                    tc_ty(cx, mt.ty, cache).reference(borrowed_contents(*r, mt.mutbl)) |\n-                        TC::ReachesFfiUnsafe\n+                TyRef(_, _) => {\n+                    TC::None\n                 }\n \n                 TyArray(ty, _) => {\n                     tc_ty(cx, ty, cache)\n                 }\n \n                 TySlice(ty) => {\n-                    tc_ty(cx, ty, cache) | TC::Nonsized\n+                    tc_ty(cx, ty, cache)\n                 }\n-                TyStr => TC::Nonsized,\n+                TyStr => TC::None,\n \n                 TyStruct(did, substs) => {\n                     let flds = cx.struct_fields(did, substs);\n                     let mut res =\n                         TypeContents::union(&flds[..],\n-                                            |f| tc_mt(cx, f.mt, cache));\n-\n-                    if !cx.lookup_repr_hints(did).contains(&attr::ReprExtern) {\n-                        res = res | TC::ReachesFfiUnsafe;\n-                    }\n+                                            |f| tc_ty(cx, f.mt.ty, cache));\n \n                     if cx.has_dtor(did) {\n                         res = res | TC::OwnsDtor;\n@@ -4182,7 +4147,6 @@ impl<'tcx> TyS<'tcx> {\n                 }\n \n                 TyClosure(did, substs) => {\n-                    // FIXME(#14449): `borrowed_contents` below assumes `&mut` closure.\n                     let param_env = cx.empty_parameter_environment();\n                     let infcx = infer::new_infer_ctxt(cx, &cx.tables, Some(param_env), false);\n                     let upvars = infcx.closure_upvars(did, substs).unwrap();\n@@ -4208,44 +4172,6 @@ impl<'tcx> TyS<'tcx> {\n                         res = res | TC::OwnsDtor;\n                     }\n \n-                    if !variants.is_empty() {\n-                        let repr_hints = cx.lookup_repr_hints(did);\n-                        if repr_hints.len() > 1 {\n-                            // this is an error later on, but this type isn't safe\n-                            res = res | TC::ReachesFfiUnsafe;\n-                        }\n-\n-                        match repr_hints.get(0) {\n-                            Some(h) => if !h.is_ffi_safe() {\n-                                res = res | TC::ReachesFfiUnsafe;\n-                            },\n-                            // ReprAny\n-                            None => {\n-                                res = res | TC::ReachesFfiUnsafe;\n-\n-                                // We allow ReprAny enums if they are eligible for\n-                                // the nullable pointer optimization and the\n-                                // contained type is an `extern fn`\n-\n-                                if variants.len() == 2 {\n-                                    let mut data_idx = 0;\n-\n-                                    if variants[0].args.is_empty() {\n-                                        data_idx = 1;\n-                                    }\n-\n-                                    if variants[data_idx].args.len() == 1 {\n-                                        match variants[data_idx].args[0].sty {\n-                                            TyBareFn(..) => { res = res - TC::ReachesFfiUnsafe; }\n-                                            _ => { }\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-\n                     apply_lang_items(cx, did, res)\n                 }\n \n@@ -4264,14 +4190,6 @@ impl<'tcx> TyS<'tcx> {\n             result\n         }\n \n-        fn tc_mt<'tcx>(cx: &ctxt<'tcx>,\n-                       mt: TypeAndMut<'tcx>,\n-                       cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n-        {\n-            let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n-            mc | tc_ty(cx, mt.ty, cache)\n-        }\n-\n         fn apply_lang_items(cx: &ctxt, did: ast::DefId, tc: TypeContents)\n                             -> TypeContents {\n             if Some(did) == cx.lang_items.unsafe_cell_type() {\n@@ -4280,32 +4198,6 @@ impl<'tcx> TyS<'tcx> {\n                 tc\n             }\n         }\n-\n-        /// Type contents due to containing a reference with\n-        /// the region `region` and borrow kind `bk`.\n-        fn borrowed_contents(region: ty::Region,\n-                             mutbl: ast::Mutability)\n-                             -> TypeContents {\n-            let b = match mutbl {\n-                ast::MutMutable => TC::ReachesMutable,\n-                ast::MutImmutable => TC::None,\n-            };\n-            b | (TC::ReachesBorrowed).when(region != ty::ReStatic)\n-        }\n-\n-        fn object_contents(bounds: &ExistentialBounds) -> TypeContents {\n-            // These are the type contents of the (opaque) interior. We\n-            // make no assumptions (other than that it cannot have an\n-            // in-scope type parameter within, which makes no sense).\n-            let mut tc = TC::All - TC::InteriorParam;\n-            for bound in &bounds.builtin_bounds {\n-                tc = tc - match bound {\n-                    BoundSync | BoundSend | BoundCopy => TC::None,\n-                    BoundSized => TC::Nonsized,\n-                };\n-            }\n-            return tc;\n-        }\n     }\n \n     fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n@@ -4399,10 +4291,6 @@ impl<'tcx> TyS<'tcx> {\n         result\n     }\n \n-    pub fn is_ffi_safe(&'tcx self, cx: &ctxt<'tcx>) -> bool {\n-        !self.type_contents(cx).intersects(TC::ReachesFfiUnsafe)\n-    }\n-\n     // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n     pub fn is_instantiable(&'tcx self, cx: &ctxt<'tcx>) -> bool {\n         fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,"}, {"sha": "6289d50588104bbffa0baf63dd9379b38862e535", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 272, "deletions": 29, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -32,23 +32,21 @@\n #![allow(deprecated)]\n \n use metadata::{csearch, decoder};\n+use middle::{cfg, def, infer, pat_util, stability, traits};\n use middle::def::*;\n-use middle::infer;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n-use middle::traits;\n-use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n-use middle::cfg;\n use rustc::ast_map;\n-use util::nodemap::{FnvHashMap, NodeSet};\n+use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n use std::collections::{HashSet, BitSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n+use std::rc::Rc;\n \n use syntax::{abi, ast};\n use syntax::ast_util::{self, is_shift_binop, local_def};\n@@ -405,43 +403,288 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n }\n \n+enum FfiResult {\n+    FfiSafe,\n+    FfiUnsafe(&'static str),\n+    FfiBadStruct(ast::DefId, &'static str),\n+    FfiBadEnum(ast::DefId, &'static str)\n+}\n+\n+/// Check if this enum can be safely exported based on the\n+/// \"nullable pointer optimization\". Currently restricted\n+/// to function pointers and references, but could be\n+/// expanded to cover NonZero raw pointers and newtypes.\n+/// FIXME: This duplicates code in trans.\n+fn is_repr_nullable_ptr<'tcx>(variants: &Vec<Rc<ty::VariantInfo<'tcx>>>) -> bool {\n+    if variants.len() == 2 {\n+        let mut data_idx = 0;\n+\n+        if variants[0].args.is_empty() {\n+            data_idx = 1;\n+        } else if !variants[1].args.is_empty() {\n+            return false;\n+        }\n+\n+        if variants[data_idx].args.len() == 1 {\n+            match variants[data_idx].args[0].sty {\n+                ty::TyBareFn(None, _) => { return true; }\n+                ty::TyRef(..) => { return true; }\n+                _ => { }\n+            }\n+        }\n+    }\n+    false\n+}\n+\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n-    fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow().get(&id).unwrap().full_def() {\n-            def::DefPrimTy(ast::TyInt(ast::TyIs)) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                  \"found rust type `isize` in foreign module, while \\\n-                                   libc::c_int or libc::c_long should be used\");\n+    /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n+    /// representation which can be exported to C code).\n+    fn check_type_for_ffi(&self,\n+                          cache: &mut FnvHashSet<Ty<'tcx>>,\n+                          ty: Ty<'tcx>)\n+                          -> FfiResult {\n+        use self::FfiResult::*;\n+        let cx = &self.cx.tcx;\n+\n+        // Protect against infinite recursion, for example\n+        // `struct S(*mut S);`.\n+        // FIXME: A recursion limit is necessary as well, for irregular\n+        // recusive types.\n+        if !cache.insert(ty) {\n+            return FfiSafe;\n+        }\n+\n+        match ty.sty {\n+            ty::TyStruct(did, substs) => {\n+                if !cx.lookup_repr_hints(did).contains(&attr::ReprExtern) {\n+                    return FfiUnsafe(\n+                        \"found struct without foreign-function-safe \\\n+                         representation annotation in foreign module, \\\n+                         consider adding a #[repr(C)] attribute to \\\n+                         the type\");\n+                }\n+\n+                // We can't completely trust repr(C) markings; make sure the\n+                // fields are actually safe.\n+                let fields = cx.struct_fields(did, substs);\n+\n+                if fields.is_empty() {\n+                    return FfiUnsafe(\n+                        \"found zero-size struct in foreign module, consider \\\n+                         adding a member to this struct\");\n+                }\n+\n+                for field in fields {\n+                    let field_ty = infer::normalize_associated_type(cx, &field.mt.ty);\n+                    let r = self.check_type_for_ffi(cache, field_ty);\n+                    match r {\n+                        FfiSafe => {}\n+                        FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n+                        FfiUnsafe(s) => { return FfiBadStruct(did, s); }\n+                    }\n+                }\n+                FfiSafe\n             }\n-            def::DefPrimTy(ast::TyUint(ast::TyUs)) => {\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                  \"found rust type `usize` in foreign module, while \\\n-                                   libc::c_uint or libc::c_ulong should be used\");\n+            ty::TyEnum(did, substs) => {\n+                let variants = cx.substd_enum_variants(did, substs);\n+                if variants.is_empty() {\n+                    // Empty enums are okay... although sort of useless.\n+                    return FfiSafe\n+                }\n+\n+                // Check for a repr() attribute to specify the size of the\n+                // discriminant.\n+                let repr_hints = cx.lookup_repr_hints(did);\n+                match &**repr_hints {\n+                    [] => {\n+                        // Special-case types like `Option<extern fn()>`.\n+                        if !is_repr_nullable_ptr(&variants) {\n+                            return FfiUnsafe(\n+                                \"found enum without foreign-function-safe \\\n+                                 representation annotation in foreign module, \\\n+                                 consider adding a #[repr(...)] attribute to \\\n+                                 the type\")\n+                        }\n+                    }\n+                    [ref hint] => {\n+                        if !hint.is_ffi_safe() {\n+                            // FIXME: This shouldn't be reachable: we should check\n+                            // this earlier.\n+                            return FfiUnsafe(\n+                                \"enum has unexpected #[repr(...)] attribute\")\n+                        }\n+\n+                        // Enum with an explicitly sized discriminant; either\n+                        // a C-style enum or a discriminated union.\n+\n+                        // The layout of enum variants is implicitly repr(C).\n+                        // FIXME: Is that correct?\n+                    }\n+                    _ => {\n+                        // FIXME: This shouldn't be reachable: we should check\n+                        // this earlier.\n+                        return FfiUnsafe(\n+                            \"enum has too many #[repr(...)] attributes\");\n+                    }\n+                }\n+\n+                // Check the contained variants.\n+                for variant in variants {\n+                    for arg in &variant.args {\n+                        let arg = infer::normalize_associated_type(cx, arg);\n+                        let r = self.check_type_for_ffi(cache, arg);\n+                        match r {\n+                            FfiSafe => {}\n+                            FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n+                            FfiUnsafe(s) => { return FfiBadEnum(did, s); }\n+                        }\n+                    }\n+                }\n+                FfiSafe\n+            }\n+\n+            ty::TyInt(ast::TyIs) => {\n+                FfiUnsafe(\"found Rust type `isize` in foreign module, while \\\n+                          `libc::c_int` or `libc::c_long` should be used\")\n+            }\n+            ty::TyUint(ast::TyUs) => {\n+                FfiUnsafe(\"found Rust type `usize` in foreign module, while \\\n+                          `libc::c_uint` or `libc::c_ulong` should be used\")\n+            }\n+            ty::TyChar => {\n+                FfiUnsafe(\"found Rust type `char` in foreign module, while \\\n+                           `u32` or `libc::wchar_t` should be used\")\n+            }\n+\n+            // Primitive types with a stable representation.\n+            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) |\n+            ty::TyFloat(..) => FfiSafe,\n+\n+            ty::TyBox(..) => {\n+                FfiUnsafe(\"found Rust type Box<_> in foreign module, \\\n+                           consider using a raw pointer instead\")\n+            }\n+\n+            ty::TySlice(_) => {\n+                FfiUnsafe(\"found Rust slice type in foreign module, \\\n+                           consider using a raw pointer instead\")\n+            }\n+\n+            ty::TyTrait(..) => {\n+                FfiUnsafe(\"found Rust trait type in foreign module, \\\n+                           consider using a raw pointer instead\")\n+            }\n+\n+            ty::TyStr => {\n+                FfiUnsafe(\"found Rust type `str` in foreign module; \\\n+                           consider using a `*const libc::c_char`\")\n             }\n-            def::DefTy(..) => {\n-                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n-                    Some(&t) => t,\n-                    None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n-                };\n \n-                if !tty.is_ffi_safe(self.cx.tcx) {\n-                    self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                      \"found type without foreign-function-safe \\\n-                                       representation annotation in foreign module, consider \\\n-                                       adding a #[repr(...)] attribute to the type\");\n+            ty::TyTuple(_) => {\n+                FfiUnsafe(\"found Rust tuple type in foreign module; \\\n+                           consider using a struct instead`\")\n+            }\n+\n+            ty::TyRawPtr(ref m) | ty::TyRef(_, ref m) => {\n+                self.check_type_for_ffi(cache, m.ty)\n+            }\n+\n+            ty::TyArray(ty, _) => {\n+                self.check_type_for_ffi(cache, ty)\n+            }\n+\n+            ty::TyBareFn(None, bare_fn) => {\n+                match bare_fn.abi {\n+                    abi::Rust |\n+                    abi::RustIntrinsic |\n+                    abi::RustCall => {\n+                        return FfiUnsafe(\n+                            \"found function pointer with Rust calling \\\n+                             convention in foreign module; consider using an \\\n+                             `extern` function pointer\")\n+                    }\n+                    _ => {}\n                 }\n+\n+                let sig = cx.erase_late_bound_regions(&bare_fn.sig);\n+                match sig.output {\n+                    ty::FnDiverging => {}\n+                    ty::FnConverging(output) => {\n+                        if !output.is_nil() {\n+                            let r = self.check_type_for_ffi(cache, output);\n+                            match r {\n+                                FfiSafe => {}\n+                                _ => { return r; }\n+                            }\n+                        }\n+                    }\n+                }\n+                for arg in sig.inputs {\n+                    let r = self.check_type_for_ffi(cache, arg);\n+                    match r {\n+                        FfiSafe => {}\n+                        _ => { return r; }\n+                    }\n+                }\n+                FfiSafe\n+            }\n+\n+            ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n+            ty::TyClosure(..) | ty::TyProjection(..) |\n+            ty::TyBareFn(Some(_), _) => {\n+                panic!(\"Unexpected type in foreign function\")\n+            }\n+        }\n+    }\n+\n+    fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n+        let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n+            Some(&t) => t,\n+            None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n+        };\n+        let tty = infer::normalize_associated_type(self.cx.tcx, &tty);\n+\n+        match ImproperCTypesVisitor::check_type_for_ffi(self, &mut FnvHashSet(), tty) {\n+            FfiResult::FfiSafe => {}\n+            FfiResult::FfiUnsafe(s) => {\n+                self.cx.span_lint(IMPROPER_CTYPES, sp, s);\n+            }\n+            FfiResult::FfiBadStruct(_, s) => {\n+                // FIXME: This diagnostic is difficult to read, and doesn't\n+                // point at the relevant field.\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n+                    &format!(\"found non-foreign-function-safe member in \\\n+                              struct marked #[repr(C)]: {}\", s));\n+            }\n+            FfiResult::FfiBadEnum(_, s) => {\n+                // FIXME: This diagnostic is difficult to read, and doesn't\n+                // point at the relevant variant.\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n+                    &format!(\"found non-foreign-function-safe member in \\\n+                              enum: {}\", s));\n             }\n-            _ => ()\n         }\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n-        if let ast::TyPath(..) = ty.node {\n-            self.check_def(ty.span, ty.id);\n+        match ty.node {\n+            ast::TyPath(..) |\n+            ast::TyBareFn(..) => self.check_def(ty.span, ty.id),\n+            ast::TyVec(..) => {\n+                self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n+                    \"found Rust slice type in foreign module, consider \\\n+                     using a raw pointer instead\");\n+            }\n+            ast::TyFixedLengthVec(ref ty, _) => self.visit_ty(ty),\n+            ast::TyTup(..) => {\n+                self.cx.span_lint(IMPROPER_CTYPES, ty.span,\n+                    \"found Rust tuple type in foreign module; \\\n+                     consider using a struct instead`\")\n+            }\n+            _ => visit::walk_ty(self, ty)\n         }\n-        visit::walk_ty(self, ty);\n     }\n }\n "}, {"sha": "8d6dfb929873064aad959f9c7275ea910d01efb8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -38,6 +38,7 @@\n #![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(str_char)]\n "}, {"sha": "9ee046915daca66a4a526b90df3cc8d64998e46f", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -685,7 +685,7 @@ extern {\n     pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n     pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n     pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n-                                  -> *const ();\n+                                  -> *const c_void;\n     pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n     /* Operations on other types */"}, {"sha": "21078641c1f536ccd7c917a1c926e30633d2220e", "filename": "src/librustc_trans/back/msvc/registry.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -13,6 +13,7 @@ use std::ffi::{OsString, OsStr};\n use std::os::windows::prelude::*;\n use std::ops::RangeFrom;\n use libc::{DWORD, LPCWSTR, LONG, LPDWORD, LPBYTE, ERROR_SUCCESS};\n+use libc::c_void;\n \n const HKEY_LOCAL_MACHINE: HKEY = 0x80000002 as HKEY;\n const KEY_WOW64_32KEY: REGSAM = 0x0200;\n@@ -32,7 +33,7 @@ pub type HKEY = *mut __HKEY__;\n pub type PHKEY = *mut HKEY;\n pub type REGSAM = DWORD;\n pub type LPWSTR = *mut u16;\n-pub type PFILETIME = *mut ();\n+pub type PFILETIME = *mut c_void;\n \n #[link(name = \"advapi32\")]\n extern \"system\" {"}, {"sha": "59fc8df6107310367ceeb26cc8cb34be05d7e291", "filename": "src/libstd/rt/unwind/gcc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -251,12 +251,11 @@ pub mod eabi {\n     use rt::libunwind as uw;\n     use libc::{c_void, c_int};\n \n-    #[repr(C)]\n-    pub struct EXCEPTION_RECORD;\n-    #[repr(C)]\n-    pub struct CONTEXT;\n-    #[repr(C)]\n-    pub struct DISPATCHER_CONTEXT;\n+    // Fake definitions; these are actually complicated structs,\n+    // but we don't use the contents here.\n+    pub type EXCEPTION_RECORD = c_void;\n+    pub type CONTEXT = c_void;\n+    pub type DISPATCHER_CONTEXT = c_void;\n \n     #[repr(C)]\n     #[derive(Copy, Clone)]"}, {"sha": "491b53c4ed95ca06ea2c41f1e4398d599cd46f03", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -82,6 +82,7 @@ pub unsafe fn make_handler() -> Handler {\n     Handler { _data: 0 as *mut libc::c_void }\n }\n \n+#[repr(C)]\n pub struct EXCEPTION_RECORD {\n     pub ExceptionCode: DWORD,\n     pub ExceptionFlags: DWORD,\n@@ -91,6 +92,7 @@ pub struct EXCEPTION_RECORD {\n     pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n }\n \n+#[repr(C)]\n pub struct EXCEPTION_POINTERS {\n     pub ExceptionRecord: *mut EXCEPTION_RECORD,\n     pub ContextRecord: LPVOID"}, {"sha": "11b375dcce2f4c20a3581019cd20d898785bd716", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -335,13 +335,13 @@ mod imp {\n             #[linkage = \"extern_weak\"]\n             static __dso_handle: *mut u8;\n             #[linkage = \"extern_weak\"]\n-            static __cxa_thread_atexit_impl: *const ();\n+            static __cxa_thread_atexit_impl: *const libc::c_void;\n         }\n         if !__cxa_thread_atexit_impl.is_null() {\n             type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n                                       arg: *mut u8,\n                                       dso_handle: *mut u8) -> libc::c_int;\n-            mem::transmute::<*const (), F>(__cxa_thread_atexit_impl)\n+            mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n             (dtor, t, &__dso_handle as *const _ as *mut _);\n             return\n         }"}, {"sha": "56261c34a030850e1fe3938347797c2e01ca2838", "filename": "src/test/compile-fail/issue-14309.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14309.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -37,7 +37,7 @@ struct D {\n }\n \n extern \"C\" {\n-    fn foo(x: A); //~ ERROR found type without foreign-function-safe\n+    fn foo(x: A); //~ ERROR found struct without foreign-function-safe\n     fn bar(x: B); //~ ERROR foreign-function-safe\n     fn baz(x: C);\n     fn qux(x: A2); //~ ERROR foreign-function-safe"}, {"sha": "b5aa3568122ad49108a03ec12f87ce6bc3fb9175", "filename": "src/test/compile-fail/issue-16250.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Fissue-16250.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Fissue-16250.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16250.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -11,7 +11,7 @@\n #![deny(warnings)]\n \n extern {\n-    pub fn foo(x: (isize)); //~ ERROR found rust type `isize` in foreign module\n+    pub fn foo(x: (isize)); //~ ERROR found Rust type `isize` in foreign module\n }\n \n fn main() {"}, {"sha": "e35dadbea9d4d16429de2519f318e91524d8c080", "filename": "src/test/compile-fail/lint-ctypes-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -18,9 +18,9 @@ enum T { E, F, G }\n \n extern {\n    fn zf(x: Z);\n-   fn uf(x: U); //~ ERROR found type without foreign-function-safe\n-   fn bf(x: B); //~ ERROR found type without foreign-function-safe\n-   fn tf(x: T); //~ ERROR found type without foreign-function-safe\n+   fn uf(x: U); //~ ERROR found enum without foreign-function-safe\n+   fn bf(x: B); //~ ERROR found enum without foreign-function-safe\n+   fn tf(x: T); //~ ERROR found enum without foreign-function-safe\n }\n \n pub fn main() { }"}, {"sha": "614f8e6fde81a966cd2244471a062024e07b3922", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -13,14 +13,45 @@\n \n extern crate libc;\n \n+trait Mirror { type It; }\n+impl<T> Mirror for T { type It = Self; }\n+#[repr(C)]\n+pub struct StructWithProjection(*mut <StructWithProjection as Mirror>::It);\n+#[repr(C)]\n+pub struct StructWithProjectionAndLifetime<'a>(\n+    &'a mut <StructWithProjectionAndLifetime<'a> as Mirror>::It\n+);\n+pub type I32Pair = (i32, i32);\n+#[repr(C)]\n+pub struct ZeroSize;\n+pub type RustFn = fn();\n+pub type RustBadRet = extern fn() -> Box<u32>;\n+\n extern {\n-    pub fn bare_type1(size: isize); //~ ERROR: found rust type\n-    pub fn bare_type2(size: usize); //~ ERROR: found rust type\n-    pub fn ptr_type1(size: *const isize); //~ ERROR: found rust type\n-    pub fn ptr_type2(size: *const usize); //~ ERROR: found rust type\n+    pub fn bare_type1(size: isize); //~ ERROR: found Rust type\n+    pub fn bare_type2(size: usize); //~ ERROR: found Rust type\n+    pub fn ptr_type1(size: *const isize); //~ ERROR: found Rust type\n+    pub fn ptr_type2(size: *const usize); //~ ERROR: found Rust type\n+    pub fn slice_type(p: &[u32]); //~ ERROR: found Rust slice type\n+    pub fn str_type(p: &str); //~ ERROR: found Rust type\n+    pub fn box_type(p: Box<u32>); //~ ERROR found Rust type\n+    pub fn char_type(p: char); //~ ERROR found Rust type\n+    pub fn trait_type(p: &Clone); //~ ERROR found Rust trait type\n+    pub fn tuple_type(p: (i32, i32)); //~ ERROR found Rust tuple type\n+    pub fn tuple_type2(p: I32Pair); //~ ERROR found Rust tuple type\n+    pub fn zero_size(p: ZeroSize); //~ ERROR found zero-size struct\n+    pub fn fn_type(p: RustFn); //~ ERROR found function pointer with Rust\n+    pub fn fn_type2(p: fn()); //~ ERROR found function pointer with Rust\n+    pub fn fn_contained(p: RustBadRet); //~ ERROR: found Rust type\n \n     pub fn good1(size: *const libc::c_int);\n     pub fn good2(size: *const libc::c_uint);\n+    pub fn good3(fptr: Option<extern fn()>);\n+    pub fn good4(aptr: &[u8; 4 as usize]);\n+    pub fn good5(s: StructWithProjection);\n+    pub fn good6(s: StructWithProjectionAndLifetime);\n+    pub fn good7(fptr: extern fn() -> ());\n+    pub fn good8(fptr: extern fn() -> !);\n }\n \n fn main() {"}, {"sha": "b77f25a0a344f6151c4daab2c1c0231de9079811", "filename": "src/test/compile-fail/warn-foreign-int-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -13,9 +13,9 @@\n \n mod xx {\n     extern {\n-        pub fn strlen(str: *const u8) -> usize; //~ ERROR found rust type `usize`\n-        pub fn foo(x: isize, y: usize); //~ ERROR found rust type `isize`\n-        //~^ ERROR found rust type `usize`\n+        pub fn strlen(str: *const u8) -> usize; //~ ERROR found Rust type `usize`\n+        pub fn foo(x: isize, y: usize); //~ ERROR found Rust type `isize`\n+        //~^ ERROR found Rust type `usize`\n     }\n }\n "}, {"sha": "771fce31023e13f6a2fd5d115e5dbe6556f13514", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa17b43d351ed4f9093cf80f4044d1208044241/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=6fa17b43d351ed4f9093cf80f4044d1208044241", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n #![feature(rustc_private)]\n+#![feature(libc)]\n \n+extern crate libc;\n extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_lint;\n@@ -29,6 +31,7 @@ use rustc::session::config::{self, basic_options, build_configuration, Input, Op\n use rustc::session::build_session;\n use rustc_driver::driver;\n use rustc_resolve::MakeGlobMap;\n+use libc::c_void;\n \n use syntax::diagnostics::registry::Registry;\n \n@@ -111,7 +114,7 @@ impl ExecutionEngine {\n     }\n \n     /// Returns a raw pointer to the named function.\n-    pub fn get_function(&mut self, name: &str) -> Option<*const ()> {\n+    pub fn get_function(&mut self, name: &str) -> Option<*const c_void> {\n         let s = CString::new(name.as_bytes()).unwrap();\n \n         for &m in &self.modules {\n@@ -128,7 +131,7 @@ impl ExecutionEngine {\n     }\n \n     /// Returns a raw pointer to the named global item.\n-    pub fn get_global(&mut self, name: &str) -> Option<*const ()> {\n+    pub fn get_global(&mut self, name: &str) -> Option<*const c_void> {\n         let s = CString::new(name.as_bytes()).unwrap();\n \n         for &m in &self.modules {"}]}