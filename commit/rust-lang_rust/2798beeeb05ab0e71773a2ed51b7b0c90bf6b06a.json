{"sha": "2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OThiZWVlYjA1YWIwZTcxNzczYTJlZDUxYjdiMGM5MGJmNmIwNmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-27T13:41:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-27T13:41:55Z"}, "message": "Merge #2428\n\n2428: Remove TypableDef r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "55f1a6eddc328b20e3a4f71036d59a9573bfaa9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55f1a6eddc328b20e3a4f71036d59a9573bfaa9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd3n0jCRBK7hj4Ov3rIwAAdHIIADrcjoDpQrky/Sc6Dd4OUXgl\nOWMBS6GGpKEa6k5qtprMcFof1/Okd2k20c2zYCbw48n6Z+Pj5Vk4wmxBsg+/uERD\nFBVzxkaTtFGnnDmGzXMFYPAfMCMrg4BIGupp8JjtPueXIobyua13c307tYRkkgbz\nbBmTQDa2bdbN6AhkHMlPH/EiFoEonKzhdoaSDdPZ7extkC8Ge9pPytk+jnYKwzzv\nhVZ9eIMQHNd871H3bg4PmoUTxYSsAiM/FoWZyP+fzZ6iEUzusOuBgg36hR+Svr8W\n+TVV4Un6Vj7MFgU4ANoX1S3efspOMRHN8qmCJXZk4xa/oLpXVRtEUafhQF8g6B4=\n=NMex\n-----END PGP SIGNATURE-----\n", "payload": "tree 55f1a6eddc328b20e3a4f71036d59a9573bfaa9c\nparent 35f57f35ec484422f06772ebe109c8fd28966ec5\nparent 12501fcdd02fec9d43dfd810d65e927ddebb1b56\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574862115 +0000\ncommitter GitHub <noreply@github.com> 1574862115 +0000\n\nMerge #2428\n\n2428: Remove TypableDef r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "html_url": "https://github.com/rust-lang/rust/commit/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35f57f35ec484422f06772ebe109c8fd28966ec5", "url": "https://api.github.com/repos/rust-lang/rust/commits/35f57f35ec484422f06772ebe109c8fd28966ec5", "html_url": "https://github.com/rust-lang/rust/commit/35f57f35ec484422f06772ebe109c8fd28966ec5"}, {"sha": "12501fcdd02fec9d43dfd810d65e927ddebb1b56", "url": "https://api.github.com/repos/rust-lang/rust/commits/12501fcdd02fec9d43dfd810d65e927ddebb1b56", "html_url": "https://github.com/rust-lang/rust/commit/12501fcdd02fec9d43dfd810d65e927ddebb1b56"}], "stats": {"total": 350, "additions": 131, "deletions": 219}, "files": [{"sha": "52ad4e5d16ac4e1a8723c3606fcfee6966f830de", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -534,14 +534,6 @@ impl VariantDef {\n         }\n     }\n \n-    pub(crate) fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        match self {\n-            VariantDef::Struct(it) => it.field(db, name),\n-            VariantDef::Union(it) => it.field(db, name),\n-            VariantDef::EnumVariant(it) => it.field(db, name),\n-        }\n-    }\n-\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         match self {\n             VariantDef::Struct(it) => it.module(db),\n@@ -618,7 +610,7 @@ impl Function {\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.into())\n+        db.infer(self.id.into())\n     }\n \n     /// The containing impl block, if this is a method.\n@@ -647,7 +639,7 @@ impl Function {\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n         let infer = self.infer(db);\n-        infer.add_diagnostics(db, self, sink);\n+        infer.add_diagnostics(db, self.id, sink);\n         let mut validator = ExprValidator::new(self, infer, sink);\n         validator.validate_body(db);\n     }\n@@ -672,7 +664,7 @@ impl Const {\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.into())\n+        db.infer(self.id.into())\n     }\n \n     /// The containing impl block, if this is a type alias.\n@@ -715,7 +707,7 @@ impl Static {\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.into())\n+        db.infer(self.id.into())\n     }\n }\n \n@@ -908,9 +900,9 @@ impl Local {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Type {\n-        let infer = db.infer(self.parent);\n-        let ty = infer[self.pat_id].clone();\n         let def = DefWithBodyId::from(self.parent);\n+        let infer = db.infer(def);\n+        let ty = infer[self.pat_id].clone();\n         let resolver = def.resolver(db);\n         let krate = def.module(db).krate;\n         let environment = TraitEnvironment::lower(db, &resolver);"}, {"sha": "e192c8f47009b0a1d78c72c9c42934f36b112b82", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -2,18 +2,15 @@\n \n use std::sync::Arc;\n \n-use hir_def::{GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId};\n+use hir_def::{DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId};\n use ra_arena::map::ArenaMap;\n use ra_db::{salsa, CrateId};\n \n-use crate::{\n-    ty::{\n-        method_resolution::CrateImplBlocks,\n-        traits::{AssocTyValue, Impl},\n-        CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n-        ValueTyDefId,\n-    },\n-    DefWithBody,\n+use crate::ty::{\n+    method_resolution::CrateImplBlocks,\n+    traits::{AssocTyValue, Impl},\n+    CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n+    ValueTyDefId,\n };\n \n pub use hir_def::db::{\n@@ -32,7 +29,7 @@ pub use hir_expand::db::{\n #[salsa::requires(salsa::Database)]\n pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::infer_query)]\n-    fn infer(&self, def: DefWithBody) -> Arc<InferenceResult>;\n+    fn infer(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n \n     #[salsa::invoke(crate::ty::ty_query)]\n     fn ty(&self, def: TyDefId) -> Ty;"}, {"sha": "e96a18d12ac0087745aa177b04866e583e2bc55b", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -4,13 +4,13 @@\n //! are splitting the hir.\n \n use hir_def::{\n-    AdtId, AssocItemId, AttrDefId, ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n-    GenericDefId, ModuleDefId, StaticId, StructFieldId, StructId, TypeAliasId, UnionId, VariantId,\n+    AdtId, AssocItemId, AttrDefId, DefWithBodyId, EnumVariantId, GenericDefId, ModuleDefId,\n+    StructFieldId, VariantId,\n };\n \n use crate::{\n-    ty::TypableDef, Adt, AssocItem, AttrDef, Const, Crate, DefWithBody, EnumVariant, Function,\n-    GenericDef, ModuleDef, Static, StructField, TypeAlias, VariantDef,\n+    Adt, AssocItem, AttrDef, Crate, DefWithBody, EnumVariant, GenericDef, ModuleDef, StructField,\n+    VariantDef,\n };\n \n impl From<ra_db::CrateId> for Crate {\n@@ -137,58 +137,6 @@ impl From<GenericDef> for GenericDefId {\n     }\n }\n \n-impl From<AdtId> for TypableDef {\n-    fn from(id: AdtId) -> Self {\n-        Adt::from(id).into()\n-    }\n-}\n-\n-impl From<StructId> for TypableDef {\n-    fn from(id: StructId) -> Self {\n-        AdtId::StructId(id).into()\n-    }\n-}\n-\n-impl From<UnionId> for TypableDef {\n-    fn from(id: UnionId) -> Self {\n-        AdtId::UnionId(id).into()\n-    }\n-}\n-\n-impl From<EnumId> for TypableDef {\n-    fn from(id: EnumId) -> Self {\n-        AdtId::EnumId(id).into()\n-    }\n-}\n-\n-impl From<EnumVariantId> for TypableDef {\n-    fn from(id: EnumVariantId) -> Self {\n-        EnumVariant::from(id).into()\n-    }\n-}\n-\n-impl From<TypeAliasId> for TypableDef {\n-    fn from(id: TypeAliasId) -> Self {\n-        TypeAlias::from(id).into()\n-    }\n-}\n-\n-impl From<FunctionId> for TypableDef {\n-    fn from(id: FunctionId) -> Self {\n-        Function::from(id).into()\n-    }\n-}\n-impl From<ConstId> for TypableDef {\n-    fn from(id: ConstId) -> Self {\n-        Const::from(id).into()\n-    }\n-}\n-impl From<StaticId> for TypableDef {\n-    fn from(id: StaticId) -> Self {\n-        Static::from(id).into()\n-    }\n-}\n-\n impl From<Adt> for GenericDefId {\n     fn from(id: Adt) -> Self {\n         match id {"}, {"sha": "05f5bca57595f2babaa278ddbbd21de5af388dea", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -168,7 +168,7 @@ impl SourceAnalyzer {\n                 resolver,\n                 body_owner: Some(def),\n                 body_source_map: Some(source_map),\n-                infer: Some(db.infer(def)),\n+                infer: Some(db.infer(def.into())),\n                 scopes: Some(scopes),\n                 file_id: node.file_id,\n             }\n@@ -214,27 +214,27 @@ impl SourceAnalyzer {\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n         let expr_id = self.expr_id(&call.clone().into())?;\n-        self.infer.as_ref()?.method_resolution(expr_id)\n+        self.infer.as_ref()?.method_resolution(expr_id).map(Function::from)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n         let expr_id = self.expr_id(&field.clone().into())?;\n-        self.infer.as_ref()?.field_resolution(expr_id)\n+        self.infer.as_ref()?.field_resolution(expr_id).map(|it| it.into())\n     }\n \n     pub fn resolve_record_field(&self, field: &ast::RecordField) -> Option<crate::StructField> {\n         let expr_id = self.expr_id(&field.expr()?)?;\n-        self.infer.as_ref()?.record_field_resolution(expr_id)\n+        self.infer.as_ref()?.record_field_resolution(expr_id).map(|it| it.into())\n     }\n \n     pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<crate::VariantDef> {\n         let expr_id = self.expr_id(&record_lit.clone().into())?;\n-        self.infer.as_ref()?.variant_resolution_for_expr(expr_id)\n+        self.infer.as_ref()?.variant_resolution_for_expr(expr_id).map(|it| it.into())\n     }\n \n     pub fn resolve_record_pattern(&self, record_pat: &ast::RecordPat) -> Option<crate::VariantDef> {\n         let pat_id = self.pat_id(&record_pat.clone().into())?;\n-        self.infer.as_ref()?.variant_resolution_for_pat(pat_id)\n+        self.infer.as_ref()?.variant_resolution_for_pat(pat_id).map(|it| it.into())\n     }\n \n     pub fn resolve_macro_call(\n@@ -297,13 +297,13 @@ impl SourceAnalyzer {\n         if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n             let expr_id = self.expr_id(&path_expr.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n-                return Some(PathResolution::AssocItem(assoc));\n+                return Some(PathResolution::AssocItem(assoc.into()));\n             }\n         }\n         if let Some(path_pat) = path.syntax().parent().and_then(ast::PathPat::cast) {\n             let pat_id = self.pat_id(&path_pat.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n-                return Some(PathResolution::AssocItem(assoc));\n+                return Some(PathResolution::AssocItem(assoc.into()));\n             }\n         }\n         // This must be a normal source file rather than macro file."}, {"sha": "e4ba8afa61d81d359147e6483b07116fc9e24baf", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -38,7 +38,7 @@ pub use lower::CallableDef;\n pub(crate) use lower::{\n     callable_item_sig, field_types_query, generic_defaults_query,\n     generic_predicates_for_param_query, generic_predicates_query, ty_query, value_ty_query,\n-    TyDefId, TypableDef, ValueTyDefId,\n+    TyDefId, ValueTyDefId,\n };\n pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n "}, {"sha": "59e4e5f36b30bd76e71a8653b78d246c57b1dc42", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -22,29 +22,26 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n use hir_def::{\n+    body::Body,\n     data::{ConstData, FunctionData},\n-    path::known,\n+    expr::{BindingAnnotation, ExprId, PatId},\n+    path::{known, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AssocItemId, DefWithBodyId,\n+    AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TypeAliasId, VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use test_utils::tested_by;\n \n use super::{\n+    primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n     ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n     TypeWalk, Uncertain,\n };\n-use crate::{\n-    code_model::TypeAlias,\n-    db::HirDatabase,\n-    expr::{BindingAnnotation, Body, ExprId, PatId},\n-    ty::infer::diagnostics::InferenceDiagnostic,\n-    AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, VariantDef,\n-};\n+use crate::{db::HirDatabase, ty::infer::diagnostics::InferenceDiagnostic};\n \n macro_rules! ty_app {\n     ($ctor:pat, $param:pat) => {\n@@ -62,15 +59,15 @@ mod pat;\n mod coerce;\n \n /// The entry point of type inference.\n-pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n+pub fn infer_query(db: &impl HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n     let _p = profile(\"infer_query\");\n-    let resolver = DefWithBodyId::from(def).resolver(db);\n+    let resolver = def.resolver(db);\n     let mut ctx = InferenceContext::new(db, def, resolver);\n \n-    match &def {\n-        DefWithBody::Const(c) => ctx.collect_const(&db.const_data(c.id)),\n-        DefWithBody::Function(f) => ctx.collect_fn(&db.function_data(f.id)),\n-        DefWithBody::Static(s) => ctx.collect_const(&db.static_data(s.id)),\n+    match def {\n+        DefWithBodyId::ConstId(c) => ctx.collect_const(&db.const_data(c)),\n+        DefWithBodyId::FunctionId(f) => ctx.collect_fn(&db.function_data(f)),\n+        DefWithBodyId::StaticId(s) => ctx.collect_const(&db.static_data(s)),\n     }\n \n     ctx.infer_body();\n@@ -121,41 +118,41 @@ pub struct TypeMismatch {\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n     /// For each method call expr, records the function it resolves to.\n-    method_resolutions: FxHashMap<ExprId, Function>,\n+    method_resolutions: FxHashMap<ExprId, FunctionId>,\n     /// For each field access expr, records the field it resolves to.\n-    field_resolutions: FxHashMap<ExprId, StructField>,\n+    field_resolutions: FxHashMap<ExprId, StructFieldId>,\n     /// For each field in record literal, records the field it resolves to.\n-    record_field_resolutions: FxHashMap<ExprId, StructField>,\n+    record_field_resolutions: FxHashMap<ExprId, StructFieldId>,\n     /// For each struct literal, records the variant it resolves to.\n-    variant_resolutions: FxHashMap<ExprOrPatId, VariantDef>,\n+    variant_resolutions: FxHashMap<ExprOrPatId, VariantId>,\n     /// For each associated item record what it resolves to\n-    assoc_resolutions: FxHashMap<ExprOrPatId, AssocItem>,\n+    assoc_resolutions: FxHashMap<ExprOrPatId, AssocItemId>,\n     diagnostics: Vec<InferenceDiagnostic>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n     pub(super) type_mismatches: ArenaMap<ExprId, TypeMismatch>,\n }\n \n impl InferenceResult {\n-    pub fn method_resolution(&self, expr: ExprId) -> Option<Function> {\n+    pub fn method_resolution(&self, expr: ExprId) -> Option<FunctionId> {\n         self.method_resolutions.get(&expr).copied()\n     }\n-    pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+    pub fn field_resolution(&self, expr: ExprId) -> Option<StructFieldId> {\n         self.field_resolutions.get(&expr).copied()\n     }\n-    pub fn record_field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+    pub fn record_field_resolution(&self, expr: ExprId) -> Option<StructFieldId> {\n         self.record_field_resolutions.get(&expr).copied()\n     }\n-    pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantDef> {\n+    pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantId> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }\n-    pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantDef> {\n+    pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantId> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }\n-    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<AssocItem> {\n+    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<AssocItemId> {\n         self.assoc_resolutions.get(&id.into()).copied()\n     }\n-    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<AssocItem> {\n+    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<AssocItemId> {\n         self.assoc_resolutions.get(&id.into()).copied()\n     }\n     pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch> {\n@@ -164,7 +161,7 @@ impl InferenceResult {\n     pub(crate) fn add_diagnostics(\n         &self,\n         db: &impl HirDatabase,\n-        owner: Function,\n+        owner: FunctionId,\n         sink: &mut DiagnosticSink,\n     ) {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, owner, sink))\n@@ -191,7 +188,7 @@ impl Index<PatId> for InferenceResult {\n #[derive(Clone, Debug)]\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n-    owner: DefWithBody,\n+    owner: DefWithBodyId,\n     body: Arc<Body>,\n     resolver: Resolver,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n@@ -209,7 +206,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(db: &'a D, owner: DefWithBody, resolver: Resolver) -> Self {\n+    fn new(db: &'a D, owner: DefWithBodyId, resolver: Resolver) -> Self {\n         InferenceContext {\n             result: InferenceResult::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -243,15 +240,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.result.type_of_expr.insert(expr, ty);\n     }\n \n-    fn write_method_resolution(&mut self, expr: ExprId, func: Function) {\n+    fn write_method_resolution(&mut self, expr: ExprId, func: FunctionId) {\n         self.result.method_resolutions.insert(expr, func);\n     }\n \n-    fn write_field_resolution(&mut self, expr: ExprId, field: StructField) {\n+    fn write_field_resolution(&mut self, expr: ExprId, field: StructFieldId) {\n         self.result.field_resolutions.insert(expr, field);\n     }\n \n-    fn write_variant_resolution(&mut self, id: ExprOrPatId, variant: VariantDef) {\n+    fn write_variant_resolution(&mut self, id: ExprOrPatId, variant: VariantId) {\n         self.result.variant_resolutions.insert(id, variant);\n     }\n \n@@ -514,7 +511,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n+    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantId>) {\n         let path = match path {\n             Some(path) => path,\n             None => return (Ty::Unknown, None),\n@@ -527,13 +524,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(VariantDef::Struct(strukt.into())))\n+                (ty, Some(strukt.into()))\n             }\n             Some(TypeNs::EnumVariantId(var)) => {\n                 let substs = Ty::substs_from_path(self.db, resolver, path, var.into());\n                 let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(VariantDef::EnumVariant(var.into())))\n+                (ty, Some(var.into()))\n             }\n             Some(_) | None => (Ty::Unknown, None),\n         }\n@@ -557,22 +554,22 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.infer_expr(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n     }\n \n-    fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n+    fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n         let path = known::std_iter_into_iterator();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE).map(TypeAlias::from)\n+        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE)\n     }\n \n-    fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n+    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n         let path = known::std_ops_try();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE).map(TypeAlias::from)\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE)\n     }\n \n-    fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n+    fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n         let path = known::std_future_future();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE).map(TypeAlias::from)\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n@@ -696,9 +693,10 @@ impl Expectation {\n }\n \n mod diagnostics {\n+    use hir_def::{expr::ExprId, FunctionId, HasSource, Lookup};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n-    use crate::{db::HirDatabase, diagnostics::NoSuchField, expr::ExprId, Function, HasSource};\n+    use crate::{db::HirDatabase, diagnostics::NoSuchField};\n \n     #[derive(Debug, PartialEq, Eq, Clone)]\n     pub(super) enum InferenceDiagnostic {\n@@ -709,13 +707,14 @@ mod diagnostics {\n         pub(super) fn add_to(\n             &self,\n             db: &impl HirDatabase,\n-            owner: Function,\n+            owner: FunctionId,\n             sink: &mut DiagnosticSink,\n         ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n-                    let file = owner.source(db).file_id;\n-                    let field = owner.body_source_map(db).field_syntax(*expr, *field);\n+                    let file = owner.lookup(db).source(db).file_id;\n+                    let (_, source_map) = db.body_with_source_map(owner.into());\n+                    let field = source_map.field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file, field })\n                 }\n             }"}, {"sha": "f9ededa23547def4684ef72ecd920708463eb496", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -16,9 +16,9 @@ use hir_expand::name::{self, Name};\n use crate::{\n     db::HirDatabase,\n     ty::{\n-        autoderef, method_resolution, op, traits::InEnvironment, CallableDef, InferTy, IntTy,\n-        Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n-        TypeWalk, Uncertain,\n+        autoderef, method_resolution, op, traits::InEnvironment, utils::variant_data, CallableDef,\n+        InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n+        TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n     },\n };\n \n@@ -100,7 +100,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: pat_ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: into_iter_item_alias.id,\n+                                associated_ty: into_iter_item_alias,\n                                 parameters: Substs::single(iterable_ty),\n                             },\n                         };\n@@ -218,22 +218,26 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n                 let field_types =\n                     def_id.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n+                let variant_data = def_id.map(|it| variant_data(self.db, it));\n                 for (field_idx, field) in fields.iter().enumerate() {\n-                    let field_def = def_id.and_then(|it| match it.field(self.db, &field.name) {\n-                        Some(field) => Some(field),\n-                        None => {\n-                            self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n-                                expr: tgt_expr,\n-                                field: field_idx,\n-                            });\n-                            None\n-                        }\n-                    });\n+                    let field_def =\n+                        variant_data.as_ref().and_then(|it| match it.field(&field.name) {\n+                            Some(local_id) => {\n+                                Some(StructFieldId { parent: def_id.unwrap(), local_id })\n+                            }\n+                            None => {\n+                                self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n+                                    expr: tgt_expr,\n+                                    field: field_idx,\n+                                });\n+                                None\n+                            }\n+                        });\n                     if let Some(field_def) = field_def {\n                         self.result.record_field_resolutions.insert(field.expr, field_def);\n                     }\n                     let field_ty = field_def\n-                        .map_or(Ty::Unknown, |it| field_types[it.id].clone())\n+                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone())\n                         .subst(&substs);\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n@@ -262,7 +266,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             self.db.struct_data(s).variant_data.field(name).map(|local_id| {\n                                 let field = StructFieldId { parent: s.into(), local_id }.into();\n                                 self.write_field_resolution(tgt_expr, field);\n-                                self.db.field_types(s.into())[field.id]\n+                                self.db.field_types(s.into())[field.local_id]\n                                     .clone()\n                                     .subst(&a_ty.parameters)\n                             })\n@@ -285,7 +289,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: future_future_output_alias.id,\n+                                associated_ty: future_future_output_alias,\n                                 parameters: Substs::single(inner_ty),\n                             },\n                         };\n@@ -304,7 +308,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: ops_try_ok_alias.id,\n+                                associated_ty: ops_try_ok_alias,\n                                 parameters: Substs::single(inner_ty),\n                             },\n                         };\n@@ -557,7 +561,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (ty, self.db.value_ty(func.id.into()), Some(self.db.generic_params(func.id.into())))\n+                (ty, self.db.value_ty(func.into()), Some(self.db.generic_params(func.into())))\n             }\n             None => (receiver_ty, Ty::Unknown, None),\n         };"}, {"sha": "a147746077f4a0b8ab79dc44d661ec77baeb49f6", "filename": "crates/ra_hir/src/ty/infer/pat.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -14,7 +14,7 @@ use test_utils::tested_by;\n use super::{BindingMode, InferenceContext};\n use crate::{\n     db::HirDatabase,\n-    ty::{Substs, Ty, TypeCtor, TypeWalk},\n+    ty::{utils::variant_data, Substs, Ty, TypeCtor, TypeWalk},\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -26,16 +26,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         default_bm: BindingMode,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n-\n+        let var_data = def.map(|it| variant_data(self.db, it));\n         self.unify(&ty, expected);\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n \n         let field_tys = def.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n+\n         for (i, &subpat) in subpats.iter().enumerate() {\n-            let expected_ty = def\n-                .and_then(|d| d.field(self.db, &Name::new_tuple_field(i)))\n-                .map_or(Ty::Unknown, |field| field_tys[field.id].clone())\n+            let expected_ty = var_data\n+                .as_ref()\n+                .and_then(|d| d.field(&Name::new_tuple_field(i)))\n+                .map_or(Ty::Unknown, |field| field_tys[field].clone())\n                 .subst(&substs);\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n@@ -53,6 +55,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         id: PatId,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n+        let var_data = def.map(|it| variant_data(self.db, it));\n         if let Some(variant) = def {\n             self.write_variant_resolution(id.into(), variant);\n         }\n@@ -63,10 +66,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         let field_tys = def.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n         for subpat in subpats {\n-            let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n-            let expected_ty = matching_field\n-                .map_or(Ty::Unknown, |field| field_tys[field.id].clone())\n-                .subst(&substs);\n+            let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n+            let expected_ty =\n+                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone()).subst(&substs);\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }"}, {"sha": "5dce2f34230877edd401087bd7448465d62ef619", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 8, "deletions": 47, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -11,7 +11,7 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::BuiltinType,\n     generics::WherePredicate,\n-    path::{GenericArg, PathSegment},\n+    path::{GenericArg, Path, PathSegment},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, AstItemDef, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n@@ -28,11 +28,10 @@ use crate::{\n     db::HirDatabase,\n     ty::{\n         primitive::{FloatTy, IntTy},\n-        utils::{all_super_traits, associated_type_by_name_including_super_traits},\n+        utils::{all_super_traits, associated_type_by_name_including_super_traits, variant_data},\n     },\n     util::make_mut_slice,\n-    Adt, Const, Enum, EnumVariant, Function, ImplBlock, ModuleDef, Path, Static, Struct, Trait,\n-    TypeAlias, Union,\n+    ImplBlock, Trait,\n };\n \n impl Ty {\n@@ -514,13 +513,11 @@ pub(crate) fn field_types_query(\n     db: &impl HirDatabase,\n     variant_id: VariantId,\n ) -> Arc<ArenaMap<LocalStructFieldId, Ty>> {\n-    let (resolver, var_data) = match variant_id {\n-        VariantId::StructId(it) => (it.resolver(db), db.struct_data(it).variant_data.clone()),\n-        VariantId::UnionId(it) => (it.resolver(db), db.union_data(it).variant_data.clone()),\n-        VariantId::EnumVariantId(it) => (\n-            it.parent.resolver(db),\n-            db.enum_data(it.parent).variants[it.local_id].variant_data.clone(),\n-        ),\n+    let var_data = variant_data(db, variant_id);\n+    let resolver = match variant_id {\n+        VariantId::StructId(it) => it.resolver(db),\n+        VariantId::UnionId(it) => it.resolver(db),\n+        VariantId::EnumVariantId(it) => it.parent.resolver(db),\n     };\n     let mut res = ArenaMap::default();\n     for (field_id, field_data) in var_data.fields().iter() {\n@@ -695,42 +692,6 @@ fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n     inner.subst(&substs)\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum TypableDef {\n-    Function(Function),\n-    Adt(Adt),\n-    EnumVariant(EnumVariant),\n-    TypeAlias(TypeAlias),\n-    Const(Const),\n-    Static(Static),\n-    BuiltinType(BuiltinType),\n-}\n-impl_froms!(\n-    TypableDef: Function,\n-    Adt(Struct, Enum, Union),\n-    EnumVariant,\n-    TypeAlias,\n-    Const,\n-    Static,\n-    BuiltinType\n-);\n-\n-impl From<ModuleDef> for Option<TypableDef> {\n-    fn from(def: ModuleDef) -> Option<TypableDef> {\n-        let res = match def {\n-            ModuleDef::Function(f) => f.into(),\n-            ModuleDef::Adt(adt) => adt.into(),\n-            ModuleDef::EnumVariant(v) => v.into(),\n-            ModuleDef::TypeAlias(t) => t.into(),\n-            ModuleDef::Const(v) => v.into(),\n-            ModuleDef::Static(v) => v.into(),\n-            ModuleDef::BuiltinType(t) => t.into(),\n-            ModuleDef::Module(_) | ModuleDef::Trait(_) => return None,\n-        };\n-        Some(res)\n-    }\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum CallableDef {\n     FunctionId(FunctionId),"}, {"sha": "5cc2498552c01329d63fce1c2bd6be7d0ba2284d", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n use arrayvec::ArrayVec;\n use hir_def::{\n     lang_item::LangItemTarget, resolver::HasResolver, resolver::Resolver, type_ref::Mutability,\n-    AssocItemId, AstItemDef, HasModule, ImplId, TraitId,\n+    AssocItemId, AstItemDef, FunctionId, HasModule, ImplId, TraitId,\n };\n use hir_expand::name::Name;\n use ra_db::CrateId;\n@@ -18,7 +18,6 @@ use crate::{\n     db::HirDatabase,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{utils::all_super_traits, Ty, TypeCtor},\n-    Function,\n };\n \n use super::{autoderef, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -154,10 +153,10 @@ pub(crate) fn lookup_method(\n     db: &impl HirDatabase,\n     name: &Name,\n     resolver: &Resolver,\n-) -> Option<(Ty, Function)> {\n+) -> Option<(Ty, FunctionId)> {\n     iterate_method_candidates(ty, db, resolver, Some(name), LookupMode::MethodCall, |ty, f| match f\n     {\n-        AssocItemId::FunctionId(f) => Some((ty.clone(), f.into())),\n+        AssocItemId::FunctionId(f) => Some((ty.clone(), f)),\n         _ => None,\n     })\n }"}, {"sha": "cc6e244f448c5a098a247cdb84d93f1eb57db123", "filename": "crates/ra_hir/src/ty/op.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -1,10 +1,8 @@\n //! FIXME: write short doc here\n+use hir_def::expr::{BinaryOp, CmpOp};\n \n use super::{InferTy, Ty, TypeCtor};\n-use crate::{\n-    expr::{BinaryOp, CmpOp},\n-    ty::ApplicationTy,\n-};\n+use crate::ty::ApplicationTy;\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n     match op {"}, {"sha": "f82e6ac9b1cca01b922b9379e7b98fe703005a7c", "filename": "crates/ra_hir/src/ty/utils.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs?ref=2798beeeb05ab0e71773a2ed51b7b0c90bf6b06a", "patch": "@@ -1,11 +1,13 @@\n //! Helper functions for working with def, which don't need to be a separate\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n+use std::sync::Arc;\n \n use hir_def::{\n+    adt::VariantData,\n     db::DefDatabase,\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n-    TraitId, TypeAliasId,\n+    TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{self, Name};\n \n@@ -61,3 +63,13 @@ pub(super) fn associated_type_by_name_including_super_traits(\n         .into_iter()\n         .find_map(|t| db.trait_data(t).associated_type_by_name(name))\n }\n+\n+pub(super) fn variant_data(db: &impl DefDatabase, var: VariantId) -> Arc<VariantData> {\n+    match var {\n+        VariantId::StructId(it) => db.struct_data(it).variant_data.clone(),\n+        VariantId::UnionId(it) => db.union_data(it).variant_data.clone(),\n+        VariantId::EnumVariantId(it) => {\n+            db.enum_data(it.parent).variants[it.local_id].variant_data.clone()\n+        }\n+    }\n+}"}]}