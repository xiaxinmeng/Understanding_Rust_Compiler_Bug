{"sha": "862703e05e275d77b0b594bb5d1a26a6340933f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MjcwM2UwNWUyNzVkNzdiMGI1OTRiYjVkMWEyNmE2MzQwOTMzZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-18T14:34:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-18T14:34:52Z"}, "message": "Auto merge of #51414 - oli-obk:impl_trait_type_def, r=pnkfelix\n\nAdd existential type definitions\n\nNote: this does not allow creating named existential types, it just desugars `impl Trait` to a less (but still very) hacky version of actual `existential type` items.\n\nr? @nikomatsakis", "tree": {"sha": "c380ad82bb1a38ba3c986bc92721d30da0f7a802", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c380ad82bb1a38ba3c986bc92721d30da0f7a802"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/862703e05e275d77b0b594bb5d1a26a6340933f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/862703e05e275d77b0b594bb5d1a26a6340933f2", "html_url": "https://github.com/rust-lang/rust/commit/862703e05e275d77b0b594bb5d1a26a6340933f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/862703e05e275d77b0b594bb5d1a26a6340933f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c45ae9ea3a9a073d7791de7ffc4f6762120602f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c45ae9ea3a9a073d7791de7ffc4f6762120602f5", "html_url": "https://github.com/rust-lang/rust/commit/c45ae9ea3a9a073d7791de7ffc4f6762120602f5"}, {"sha": "adec1f94ce395a474a3847872f24b21dc84b0012", "url": "https://api.github.com/repos/rust-lang/rust/commits/adec1f94ce395a474a3847872f24b21dc84b0012", "html_url": "https://github.com/rust-lang/rust/commit/adec1f94ce395a474a3847872f24b21dc84b0012"}], "stats": {"total": 934, "additions": 646, "deletions": 288}, "files": [{"sha": "7c10292061f75dd885ce69674f48c1b51b3cf3c3", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -37,6 +37,7 @@ pub enum Def {\n     Enum(DefId),\n     Variant(DefId),\n     Trait(DefId),\n+    Existential(DefId),\n     TyAlias(DefId),\n     TyForeign(DefId),\n     TraitAlias(DefId),\n@@ -234,6 +235,7 @@ impl Def {\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n             Def::AssociatedConst(id) | Def::Macro(id, ..) |\n+            Def::Existential(id) |\n             Def::GlobalAsm(id) | Def::TyForeign(id) => {\n                 id\n             }\n@@ -260,6 +262,7 @@ impl Def {\n             Def::VariantCtor(.., CtorKind::Const) => \"unit variant\",\n             Def::VariantCtor(.., CtorKind::Fictive) => \"struct variant\",\n             Def::Enum(..) => \"enum\",\n+            Def::Existential(..) => \"existential type\",\n             Def::TyAlias(..) => \"type alias\",\n             Def::TraitAlias(..) => \"trait alias\",\n             Def::AssociatedTy(..) => \"associated type\","}, {"sha": "12ccb329e06ff2cd541b0ae6b3c6c325f4cde16f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -502,6 +502,14 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n+        ItemExistential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n+            visitor.visit_id(item.id);\n+            walk_generics(visitor, generics);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            if let Some(impl_trait_fn) = impl_trait_fn {\n+                visitor.visit_def_mention(Def::Fn(impl_trait_fn))\n+            }\n+        }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n             // visit_enum_def() takes care of visiting the Item's NodeId\n@@ -596,10 +604,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyImplTraitExistential(ref existty, ref lifetimes) => {\n-            let ExistTy { ref generics, ref bounds } = *existty;\n-            walk_generics(visitor, generics);\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+        TyImplTraitExistential(item_id, def_id, ref lifetimes) => {\n+            visitor.visit_def_mention(Def::Existential(def_id));\n+            visitor.visit_nested_item(item_id);\n             walk_list!(visitor, visit_lifetime, lifetimes);\n         }\n         TyTypeof(ref expression) => {"}, {"sha": "dd12edb73027a39e72cb727e362207c0cb128754", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 108, "deletions": 22, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -182,7 +182,9 @@ enum ImplTraitContext {\n     /// Treat `impl Trait` as shorthand for a new universal existential parameter.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n     /// equivalent to a fresh existential parameter like `abstract type T; fn foo() -> T`.\n-    Existential,\n+    ///\n+    /// We store a DefId here so we can look up necessary information later\n+    Existential(DefId),\n \n     /// `impl Trait` is not accepted in this position.\n     Disallowed,\n@@ -238,6 +240,7 @@ enum ParamMode {\n     Optional,\n }\n \n+#[derive(Debug)]\n struct LoweredNodeId {\n     node_id: NodeId,\n     hir_id: hir::HirId,\n@@ -488,16 +491,16 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn with_hir_id_owner<F>(&mut self, owner: NodeId, f: F)\n+    fn with_hir_id_owner<F, T>(&mut self, owner: NodeId, f: F) -> T\n     where\n-        F: FnOnce(&mut Self),\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let counter = self.item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n             .unwrap();\n         let def_index = self.resolver.definitions().opt_def_index(owner).unwrap();\n         self.current_hir_id_owner.push((def_index, counter));\n-        f(self);\n+        let ret = f(self);\n         let (new_def_index, new_counter) = self.current_hir_id_owner.pop().unwrap();\n \n         debug_assert!(def_index == new_def_index);\n@@ -507,6 +510,7 @@ impl<'a> LoweringContext<'a> {\n             .insert(owner, new_counter)\n             .unwrap();\n         debug_assert!(prev == HIR_ID_COUNTER_LOCKED);\n+        ret\n     }\n \n     /// This method allocates a new HirId for the given NodeId and stores it in\n@@ -530,7 +534,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_node_id_with_owner(&mut self, ast_node_id: NodeId, owner: NodeId) -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n-            let local_id_counter = this.item_local_id_counters.get_mut(&owner).unwrap();\n+            let local_id_counter = this\n+                .item_local_id_counters\n+                .get_mut(&owner)\n+                .expect(\"called lower_node_id_with_owner before allocate_hir_id_counter\");\n             let local_id = *local_id_counter;\n \n             // We want to be sure not to modify the counter in the map while it\n@@ -539,7 +546,12 @@ impl<'a> LoweringContext<'a> {\n             debug_assert!(local_id != HIR_ID_COUNTER_LOCKED);\n \n             *local_id_counter += 1;\n-            let def_index = this.resolver.definitions().opt_def_index(owner).unwrap();\n+            let def_index = this\n+                .resolver\n+                .definitions()\n+                .opt_def_index(owner)\n+                .expect(\"You forgot to call `create_def_with_parent` or are lowering node ids \\\n+                         that do not belong to the current owner\");\n \n             hir::HirId {\n                 owner: def_index,\n@@ -1120,26 +1132,93 @@ impl<'a> LoweringContext<'a> {\n             TyKind::ImplTrait(ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::Existential => {\n-                        let def_index = self.resolver.definitions().opt_def_index(t.id).unwrap();\n-                        let hir_bounds = self.lower_bounds(bounds, itctx);\n-                        let (lifetimes, lifetime_defs) =\n-                            self.lifetimes_from_impl_trait_bounds(def_index, &hir_bounds);\n+                    ImplTraitContext::Existential(fn_def_id) => {\n+\n+                        // We need to manually repeat the code of `next_id` because the lowering\n+                        // needs to happen while the owner_id is pointing to the item itself,\n+                        // because items are their own owners\n+                        let exist_ty_node_id = self.sess.next_node_id();\n+\n+                        // Make sure we know that some funky desugaring has been going on here.\n+                        // This is a first: there is code in other places like for loop\n+                        // desugaring that explicitly states that we don't want to track that.\n+                        // Not tracking it makes lints in rustc and clippy very fragile as\n+                        // frequently opened issues show.\n+                        let exist_ty_span = self.allow_internal_unstable(\n+                            CompilerDesugaringKind::ExistentialReturnType,\n+                            t.span,\n+                        );\n \n-                        hir::TyImplTraitExistential(\n-                            hir::ExistTy {\n+                        // Pull a new definition from the ether\n+                        let exist_ty_def_index = self\n+                            .resolver\n+                            .definitions()\n+                            .create_def_with_parent(\n+                            fn_def_id.index,\n+                            exist_ty_node_id,\n+                            DefPathData::ExistentialImplTrait,\n+                            DefIndexAddressSpace::High,\n+                            Mark::root(),\n+                            exist_ty_span,\n+                        );\n+\n+                        // the `t` is just for printing debug messages\n+                        self.allocate_hir_id_counter(exist_ty_node_id, t);\n+\n+                        let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n+                            lctx.lower_bounds(bounds, itctx)\n+                        });\n+\n+                        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n+                            exist_ty_node_id,\n+                            exist_ty_def_index,\n+                            &hir_bounds,\n+                        );\n+\n+                        self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n+                            let exist_ty_item_kind = hir::ItemExistential(hir::ExistTy {\n                                 generics: hir::Generics {\n                                     params: lifetime_defs,\n                                     where_clause: hir::WhereClause {\n-                                        id: self.next_id().node_id,\n+                                        id: lctx.next_id().node_id,\n                                         predicates: Vec::new().into(),\n                                     },\n                                     span,\n                                 },\n                                 bounds: hir_bounds,\n-                            },\n-                            lifetimes,\n-                        )\n+                                impl_trait_fn: Some(fn_def_id),\n+                            });\n+                            let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n+                            // Generate an `existential type Foo: Trait;` declaration\n+                            trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n+                            // Set the name to `impl Bound1 + Bound2`\n+                            let exist_ty_name = Symbol::intern(&pprust::ty_to_string(t));\n+\n+                            trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n+                            let exist_ty_item = hir::Item {\n+                                id: exist_ty_id.node_id,\n+                                hir_id: exist_ty_id.hir_id,\n+                                name: exist_ty_name,\n+                                attrs: Default::default(),\n+                                node: exist_ty_item_kind,\n+                                vis: hir::Visibility::Inherited,\n+                                span: exist_ty_span,\n+                            };\n+\n+                            // Insert the item into the global list. This usually happens\n+                            // automatically for all AST items. But this existential type item\n+                            // does not actually exist in the AST.\n+                            lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n+\n+                            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n+                            hir::TyImplTraitExistential(\n+                                hir::ItemId {\n+                                    id: exist_ty_id.node_id\n+                                },\n+                                DefId::local(exist_ty_def_index),\n+                                lifetimes,\n+                            )\n+                        })\n                     }\n                     ImplTraitContext::Universal(def_id) => {\n                         let def_node_id = self.next_id().node_id;\n@@ -1148,7 +1227,7 @@ impl<'a> LoweringContext<'a> {\n                         let def_index = self.resolver.definitions().create_def_with_parent(\n                             def_id.index,\n                             def_node_id,\n-                            DefPathData::ImplTrait,\n+                            DefPathData::UniversalImplTrait,\n                             DefIndexAddressSpace::High,\n                             Mark::root(),\n                             span,\n@@ -1203,6 +1282,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lifetimes_from_impl_trait_bounds(\n         &mut self,\n+        exist_ty_id: NodeId,\n         parent_index: DefIndex,\n         bounds: &hir::TyParamBounds,\n     ) -> (HirVec<hir::Lifetime>, HirVec<hir::GenericParam>) {\n@@ -1212,6 +1292,7 @@ impl<'a> LoweringContext<'a> {\n         struct ImplTraitLifetimeCollector<'r, 'a: 'r> {\n             context: &'r mut LoweringContext<'a>,\n             parent: DefIndex,\n+            exist_ty_id: NodeId,\n             collect_elided_lifetimes: bool,\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             already_defined_lifetimes: HashSet<hir::LifetimeName>,\n@@ -1306,7 +1387,11 @@ impl<'a> LoweringContext<'a> {\n                         name,\n                     });\n \n-                    let def_node_id = self.context.next_id().node_id;\n+                    // We need to manually create the ids here, because the\n+                    // definitions will go into the explicit `existential type`\n+                    // declaration and thus need to have their owner set to that item\n+                    let def_node_id = self.context.sess.next_node_id();\n+                    let _ = self.context.lower_node_id_with_owner(def_node_id, self.exist_ty_id);\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n@@ -1318,7 +1403,7 @@ impl<'a> LoweringContext<'a> {\n                     let def_lifetime = hir::Lifetime {\n                         id: def_node_id,\n                         span: lifetime.span,\n-                        name: name,\n+                        name,\n                     };\n                     self.output_lifetime_params\n                         .push(hir::GenericParam::Lifetime(hir::LifetimeDef {\n@@ -1334,6 +1419,7 @@ impl<'a> LoweringContext<'a> {\n         let mut lifetime_collector = ImplTraitLifetimeCollector {\n             context: self,\n             parent: parent_index,\n+            exist_ty_id,\n             collect_elided_lifetimes: true,\n             currently_bound_lifetimes: Vec::new(),\n             already_defined_lifetimes: HashSet::new(),\n@@ -1772,8 +1858,8 @@ impl<'a> LoweringContext<'a> {\n                 .collect(),\n             output: match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match fn_def_id {\n-                    Some(_) if impl_trait_return_allow => {\n-                        hir::Return(self.lower_ty(ty, ImplTraitContext::Existential))\n+                    Some(def_id) if impl_trait_return_allow => {\n+                        hir::Return(self.lower_ty(ty, ImplTraitContext::Existential(def_id)))\n                     }\n                     _ => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n                 },"}, {"sha": "48d959b4f8e4199552ebef77831731fbc39830f0", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -88,7 +88,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         debug!(\"visit_item: {:?}\", i);\n \n         // Pick the def data. This need not be unique, but the more\n-        // information we encapsulate into\n+        // information we encapsulate into, the better\n         let def_data = match i.node {\n             ItemKind::Impl(..) => DefPathData::Impl,\n             ItemKind::Trait(..) => DefPathData::Trait(i.ident.name.as_interned_str()),\n@@ -256,9 +256,6 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.node {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id),\n-            TyKind::ImplTrait(..) => {\n-                self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE, ty.span);\n-            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty);"}, {"sha": "99023a168674179cf37721c05f9362cbea53307f", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -210,30 +210,9 @@ impl DefKey {\n         } = self.disambiguated_data;\n \n         ::std::mem::discriminant(data).hash(&mut hasher);\n-        match *data {\n-            DefPathData::TypeNs(name) |\n-            DefPathData::Trait(name) |\n-            DefPathData::AssocTypeInTrait(name) |\n-            DefPathData::AssocTypeInImpl(name) |\n-            DefPathData::ValueNs(name) |\n-            DefPathData::Module(name) |\n-            DefPathData::MacroDef(name) |\n-            DefPathData::TypeParam(name) |\n-            DefPathData::LifetimeDef(name) |\n-            DefPathData::EnumVariant(name) |\n-            DefPathData::Field(name) |\n-            DefPathData::GlobalMetaData(name) => {\n-                name.hash(&mut hasher);\n-            }\n-\n-            DefPathData::Impl |\n-            DefPathData::CrateRoot |\n-            DefPathData::Misc |\n-            DefPathData::ClosureExpr |\n-            DefPathData::StructCtor |\n-            DefPathData::AnonConst |\n-            DefPathData::ImplTrait => {}\n-        };\n+        if let Some(name) = data.get_opt_name() {\n+            name.hash(&mut hasher);\n+        }\n \n         disambiguator.hash(&mut hasher);\n \n@@ -390,8 +369,10 @@ pub enum DefPathData {\n     StructCtor,\n     /// A constant expression (see {ast,hir}::AnonConst).\n     AnonConst,\n-    /// An `impl Trait` type node.\n-    ImplTrait,\n+    /// An `impl Trait` type node in argument position.\n+    UniversalImplTrait,\n+    /// An `impl Trait` type node in return position.\n+    ExistentialImplTrait,\n \n     /// GlobalMetaData identifies a piece of crate metadata that is global to\n     /// a whole crate (as opposed to just one item). GlobalMetaData components\n@@ -655,7 +636,8 @@ impl DefPathData {\n             ClosureExpr |\n             StructCtor |\n             AnonConst |\n-            ImplTrait => None\n+            ExistentialImplTrait |\n+            UniversalImplTrait => None\n         }\n     }\n \n@@ -685,7 +667,8 @@ impl DefPathData {\n             ClosureExpr => \"{{closure}}\",\n             StructCtor => \"{{constructor}}\",\n             AnonConst => \"{{constant}}\",\n-            ImplTrait => \"{{impl-Trait}}\",\n+            ExistentialImplTrait => \"{{exist-impl-Trait}}\",\n+            UniversalImplTrait => \"{{univ-impl-Trait}}\",\n         };\n \n         Symbol::intern(s).as_interned_str()"}, {"sha": "b90bca84ed602ebeda7487631af2b4ea247673ea", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                       .keys()\n                       .map(|local_id| local_id.as_usize())\n                       .max()\n-                      .unwrap();\n+                      .expect(\"owning item has no entry\");\n \n         if max != self.hir_ids_seen.len() - 1 {\n             // Collect the missing ItemLocalIds\n@@ -113,6 +113,8 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                     local_id: ItemLocalId(local_id as u32),\n                 };\n \n+                trace!(\"missing hir id {:#?}\", hir_id);\n+\n                 // We are already in ICE mode here, so doing a linear search\n                 // should be fine.\n                 let (node_id, _) = self.hir_map\n@@ -121,7 +123,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                                        .iter()\n                                        .enumerate()\n                                        .find(|&(_, &entry)| hir_id == entry)\n-                                       .unwrap();\n+                                       .expect(\"no node_to_hir_id entry\");\n                 let node_id = NodeId::new(node_id);\n                 missing_items.push(format!(\"[local_id: {}, node:{}]\",\n                                            local_id,\n@@ -146,7 +148,7 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n     }\n \n     fn visit_id(&mut self, node_id: NodeId) {\n-        let owner = self.owner_def_index.unwrap();\n+        let owner = self.owner_def_index.expect(\"no owner_def_index\");\n         let stable_id = self.hir_map.definitions().node_to_hir_id[node_id];\n \n         if stable_id == hir::DUMMY_HIR_ID {"}, {"sha": "9df55e52061634962c67b5e5dcd338cf497f1fea", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -398,6 +398,7 @@ impl<'hir> Map<'hir> {\n                     ItemFn(..) => Some(Def::Fn(def_id())),\n                     ItemMod(..) => Some(Def::Mod(def_id())),\n                     ItemGlobalAsm(..) => Some(Def::GlobalAsm(def_id())),\n+                    ItemExistential(..) => Some(Def::Existential(def_id())),\n                     ItemTy(..) => Some(Def::TyAlias(def_id())),\n                     ItemEnum(..) => Some(Def::Enum(def_id())),\n                     ItemStruct(..) => Some(Def::Struct(def_id())),\n@@ -767,7 +768,7 @@ impl<'hir> Map<'hir> {\n \n     /// Retrieve the NodeId for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n-    /// in the AST which is recorded by the map and is an item, either an item\n+    /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n@@ -1250,6 +1251,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 ItemForeignMod(..) => \"foreign mod\",\n                 ItemGlobalAsm(..) => \"global asm\",\n                 ItemTy(..) => \"ty\",\n+                ItemExistential(..) => \"existential\",\n                 ItemEnum(..) => \"enum\",\n                 ItemStruct(..) => \"struct\",\n                 ItemUnion(..) => \"union\","}, {"sha": "833090c3ee092342a836cad6eafdc9a059a9fd83", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -1693,6 +1693,7 @@ pub struct BareFnTy {\n pub struct ExistTy {\n     pub generics: Generics,\n     pub bounds: TyParamBounds,\n+    pub impl_trait_fn: Option<DefId>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1723,15 +1724,15 @@ pub enum Ty_ {\n     /// An existentially quantified (there exists a type satisfying) `impl\n     /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n     ///\n-    /// The `ExistTy` structure emulates an\n-    /// `abstract type Foo<'a, 'b>: MyTrait<'a, 'b>;`.\n+    /// The `Item` is the generated\n+    /// `existential type Foo<'a, 'b>: MyTrait<'a, 'b>;`.\n     ///\n     /// The `HirVec<Lifetime>` is the list of lifetimes applied as parameters\n     /// to the `abstract type`, e.g. the `'c` and `'d` in `-> Foo<'c, 'd>`.\n     /// This list is only a list of lifetimes and not type parameters\n     /// because all in-scope type parameters are captured by `impl Trait`,\n     /// so they are resolved directly through the parent `Generics`.\n-    TyImplTraitExistential(ExistTy, HirVec<Lifetime>),\n+    TyImplTraitExistential(ItemId, DefId, HirVec<Lifetime>),\n     /// Unused for now\n     TyTypeof(AnonConst),\n     /// TyInfer means the type should be inferred instead of it having been\n@@ -2091,6 +2092,8 @@ pub enum Item_ {\n     ItemGlobalAsm(P<GlobalAsm>),\n     /// A type alias, e.g. `type Foo = Bar<u8>`\n     ItemTy(P<Ty>, Generics),\n+    /// A type alias, e.g. `type Foo = Bar<u8>`\n+    ItemExistential(ExistTy),\n     /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n     ItemEnum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n@@ -2124,6 +2127,7 @@ impl Item_ {\n             ItemForeignMod(..) => \"foreign module\",\n             ItemGlobalAsm(..) => \"global asm\",\n             ItemTy(..) => \"type alias\",\n+            ItemExistential(..) => \"existential type\",\n             ItemEnum(..) => \"enum\",\n             ItemStruct(..) => \"struct\",\n             ItemUnion(..) => \"union\","}, {"sha": "1beef3f715e22098c8a50c33f131f590846a434a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -58,13 +58,19 @@ pub trait PpAnn {\n     fn post(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> {\n         Ok(())\n     }\n+    fn try_fetch_item(&self, _: ast::NodeId) -> Option<&hir::Item> {\n+        None\n+    }\n }\n \n pub struct NoAnn;\n impl PpAnn for NoAnn {}\n pub const NO_ANN: &'static dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate {\n+    fn try_fetch_item(&self, item: ast::NodeId) -> Option<&hir::Item> {\n+        Some(self.item(item))\n+    }\n     fn nested(&self, state: &mut State, nested: Nested) -> io::Result<()> {\n         match nested {\n             Nested::Item(id) => state.print_item(self.item(id.id)),\n@@ -413,8 +419,14 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime)?;\n                 }\n             }\n-            hir::TyImplTraitExistential(ref existty, ref _lifetimes) => {\n-                self.print_bounds(\"impl\", &existty.bounds[..])?;\n+            hir::TyImplTraitExistential(hir_id, _def_id, ref _lifetimes) => {\n+                match self.ann.try_fetch_item(hir_id.id).map(|it| &it.node) {\n+                    None => self.word_space(\"impl {{Trait}}\")?,\n+                    Some(&hir::ItemExistential(ref exist_ty)) => {\n+                        self.print_bounds(\"impl\", &exist_ty.bounds)?;\n+                    },\n+                    other => bug!(\"impl Trait pointed to {:#?}\", other),\n+                }\n             }\n             hir::TyArray(ref ty, ref length) => {\n                 self.s.word(\"[\")?;\n@@ -636,6 +648,31 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n+            hir::ItemExistential(ref exist) => {\n+                self.ibox(indent_unit)?;\n+                self.ibox(0)?;\n+                self.word_nbsp(&visibility_qualified(&item.vis, \"existential type\"))?;\n+                self.print_name(item.name)?;\n+                self.print_generic_params(&exist.generics.params)?;\n+                self.end()?; // end the inner ibox\n+\n+                self.print_where_clause(&exist.generics.where_clause)?;\n+                self.s.space()?;\n+                self.word_space(\":\")?;\n+                let mut real_bounds = Vec::with_capacity(exist.bounds.len());\n+                for b in exist.bounds.iter() {\n+                    if let TraitTyParamBound(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                        self.s.space()?;\n+                        self.word_space(\"for ?\")?;\n+                        self.print_trait_ref(&ptr.trait_ref)?;\n+                    } else {\n+                        real_bounds.push(b.clone());\n+                    }\n+                }\n+                self.print_bounds(\":\", &real_bounds[..])?;\n+                self.s.word(\";\")?;\n+                self.end()?; // end the outer ibox\n+            }\n             hir::ItemEnum(ref enum_definition, ref params) => {\n                 self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n             }"}, {"sha": "ed259b2854511bd8c34eb994b0cc6a39ce990a4a", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -310,6 +310,7 @@ impl_stable_hash_for!(struct hir::BareFnTy {\n \n impl_stable_hash_for!(struct hir::ExistTy {\n     generics,\n+    impl_trait_fn,\n     bounds\n });\n \n@@ -323,7 +324,7 @@ impl_stable_hash_for!(enum hir::Ty_ {\n     TyTup(ts),\n     TyPath(qpath),\n     TyTraitObject(trait_refs, lifetime),\n-    TyImplTraitExistential(existty, lifetimes),\n+    TyImplTraitExistential(existty, def_id, lifetimes),\n     TyTypeof(body_id),\n     TyErr,\n     TyInfer\n@@ -889,6 +890,7 @@ impl_stable_hash_for!(enum hir::Item_ {\n     ItemForeignMod(foreign_mod),\n     ItemGlobalAsm(global_asm),\n     ItemTy(ty, generics),\n+    ItemExistential(exist),\n     ItemEnum(enum_def, generics),\n     ItemStruct(variant_data, generics),\n     ItemUnion(variant_data, generics),\n@@ -1046,6 +1048,7 @@ impl_stable_hash_for!(enum hir::def::Def {\n     Struct(def_id),\n     Union(def_id),\n     Enum(def_id),\n+    Existential(def_id),\n     Variant(def_id),\n     Trait(def_id),\n     TyAlias(def_id),"}, {"sha": "7b14831cf95c0d2c1e4920e165b1a6a074746735", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -411,6 +411,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n     DotFill,\n     QuestionMark,\n+    ExistentialReturnType,\n     Catch\n });\n "}, {"sha": "f068a54ce44479f27a49ce8a1e49d9416f1da2e1", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n+use hir;\n use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n@@ -689,8 +690,16 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     // }\n                     // ```\n                     if let Some(anon_node_id) = tcx.hir.as_local_node_id(def_id) {\n-                        let anon_parent_node_id = tcx.hir.get_parent(anon_node_id);\n-                        let anon_parent_def_id = tcx.hir.local_def_id(anon_parent_node_id);\n+                        let anon_parent_def_id = match tcx.hir.expect_item(anon_node_id).node {\n+                            hir::ItemExistential(hir::ExistTy {\n+                                impl_trait_fn: Some(parent),\n+                                ..\n+                            }) => parent,\n+                            _ => {\n+                                let anon_parent_node_id = tcx.hir.get_parent(anon_node_id);\n+                                tcx.hir.local_def_id(anon_parent_node_id)\n+                            },\n+                        };\n                         if self.parent_def_id == anon_parent_def_id {\n                             return self.fold_anon_ty(ty, def_id, substs);\n                         }"}, {"sha": "40cf78edaecaebef9dd958c2f3bba0083c9bb510", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -267,6 +267,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n                     hir::ItemExternCrate(_) | hir::ItemUse(..) |\n+                    hir::ItemExistential(..) |\n                     hir::ItemTy(..) | hir::ItemStatic(..) |\n                     hir::ItemMod(..) | hir::ItemForeignMod(..) |\n                     hir::ItemImpl(..) | hir::ItemTrait(..) | hir::ItemTraitAlias(..) |"}, {"sha": "13fe9a6eef39510783507660499fcc7f6d06a235", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -499,7 +499,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n+            hir::ItemExistential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n+                // currently existential type declarations are just generated from impl Trait\n+                // items. doing anything on this node is irrelevant, as we currently don't need\n+                // it.\n+            }\n             hir::ItemTy(_, ref generics)\n+            | hir::ItemExistential(hir::ExistTy { impl_trait_fn: None, ref generics, .. })\n             | hir::ItemEnum(_, ref generics)\n             | hir::ItemStruct(_, ref generics)\n             | hir::ItemUnion(_, ref generics)\n@@ -613,7 +619,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n-            hir::TyImplTraitExistential(ref exist_ty, ref lifetimes) => {\n+            hir::TyImplTraitExistential(item_id, _, ref lifetimes) => {\n                 // Resolve the lifetimes that are applied to the existential type.\n                 // These are resolved in the current scope.\n                 // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n@@ -655,10 +661,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let hir::ExistTy {\n-                    ref generics,\n-                    ref bounds,\n-                } = *exist_ty;\n+                let (generics, bounds) = match self.tcx.hir.expect_item(item_id.id).node {\n+                    hir::ItemExistential(hir::ExistTy{ ref generics, ref bounds, .. }) => (\n+                        generics,\n+                        bounds,\n+                    ),\n+                    ref i => bug!(\"impl Trait pointed to non-existential type?? {:#?}\", i),\n+                };\n \n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s."}, {"sha": "d0ae0bdac8c095327f5d6b621f4115bdeb1e528e", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -123,6 +123,11 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                         let generic_ty = self.tcx().type_of(def_id);\n                         let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                         self.anon_depth += 1;\n+                        if concrete_ty == ty {\n+                            println!(\"generic_ty: {:#?}\", generic_ty);\n+                            println!(\"substs {:#?}\", substs);\n+                        }\n+                        assert_ne!(concrete_ty, ty, \"infinite recursion\");\n                         let folded_ty = self.fold_ty(concrete_ty);\n                         self.anon_depth -= 1;\n                         folded_ty"}, {"sha": "6cbf4fad02cb9e6a9fe97f0a2234bca6373537a7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -427,6 +427,10 @@ pub struct TypeckTables<'tcx> {\n     /// its where clauses and parameter types. These are then\n     /// read-again by borrowck.\n     pub free_region_map: FreeRegionMap<'tcx>,\n+\n+    /// All the existential types that are restricted to concrete types\n+    /// by this function\n+    pub concrete_existential_types: FxHashMap<DefId, Ty<'tcx>>,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -449,6 +453,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             used_trait_imports: Lrc::new(DefIdSet()),\n             tainted_by_errors: false,\n             free_region_map: FreeRegionMap::new(),\n+            concrete_existential_types: FxHashMap(),\n         }\n     }\n \n@@ -746,6 +751,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref free_region_map,\n+            ref concrete_existential_types,\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -786,6 +792,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             free_region_map.hash_stable(hcx, hasher);\n+            concrete_existential_types.hash_stable(hcx, hasher);\n         })\n     }\n }"}, {"sha": "d858ba7acf7863bf1da169566d194b99404db518", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -221,7 +221,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::AnonConst |\n             data @ DefPathData::MacroDef(..) |\n             data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::ImplTrait |\n+            data @ DefPathData::ExistentialImplTrait |\n+            data @ DefPathData::UniversalImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n                 self.push_item_path(buffer, parent_def_id);"}, {"sha": "229e5606afa96022ff0bb7aff99ea94d60069dcd", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -2857,6 +2857,12 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        def_id: DefId)\n                        -> ParamEnv<'tcx> {\n+\n+    // The param_env of an existential type is its parent's param_env\n+    if let Some(Def::Existential(_)) = tcx.describe_def(def_id) {\n+        let parent = tcx.parent_def_id(def_id).expect(\"impl trait item w/o a parent\");\n+        return param_env(tcx, parent);\n+    }\n     // Compute the bounds on Self and the type parameters.\n \n     let bounds = tcx.predicates_of(def_id).instantiate_identity(tcx);"}, {"sha": "e9a9c4567bb3c6f9d7db145f1cd2482c31e4d83b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -291,7 +291,8 @@ impl PrintContext {\n                     DefPathData::Field(_) |\n                     DefPathData::StructCtor |\n                     DefPathData::AnonConst |\n-                    DefPathData::ImplTrait |\n+                    DefPathData::ExistentialImplTrait |\n+                    DefPathData::UniversalImplTrait |\n                     DefPathData::GlobalMetaData(_) => {\n                         // if we're making a symbol for something, there ought\n                         // to be a value or type-def or something in there"}, {"sha": "5679cb4b61028831b93a2518a37a7c8d1bea166e", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -256,6 +256,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n                 hir::ItemFn(..) |\n                 hir::ItemForeignMod(..) |\n                 hir::ItemGlobalAsm(..) |\n+                hir::ItemExistential(..) |\n                 hir::ItemTy(..) => None,\n \n                 hir::ItemEnum(..) |"}, {"sha": "9e4f695d28fd482b776398388bf47eec2eab2328", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -419,6 +419,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::ForeignFn(_) => Def::Fn(did),\n             EntryKind::Method(_) => Def::Method(did),\n             EntryKind::Type => Def::TyAlias(did),\n+            EntryKind::Existential => Def::Existential(did),\n             EntryKind::AssociatedType(_) => Def::AssociatedTy(did),\n             EntryKind::Mod(_) => Def::Mod(did),\n             EntryKind::Variant(_) => Def::Variant(did),"}, {"sha": "33d4df1c3a5dc2b37984615144fc81cd22ba15fa", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -1060,6 +1060,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemGlobalAsm(..) => EntryKind::GlobalAsm,\n             hir::ItemTy(..) => EntryKind::Type,\n+            hir::ItemExistential(..) => EntryKind::Existential,\n             hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n@@ -1187,6 +1188,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemConst(..) |\n                 hir::ItemFn(..) |\n                 hir::ItemTy(..) |\n+                hir::ItemExistential(..) |\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n@@ -1210,6 +1212,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemImpl(..) |\n+                hir::ItemExistential(..) |\n                 hir::ItemTrait(..) => Some(self.encode_generics(def_id)),\n                 _ => None,\n             },\n@@ -1222,6 +1225,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemImpl(..) |\n+                hir::ItemExistential(..) |\n                 hir::ItemTrait(..) => Some(self.encode_predicates(def_id)),\n                 _ => None,\n             },\n@@ -1301,28 +1305,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_anon_ty(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_anon_ty({:?})\", def_id);\n-        let tcx = self.tcx;\n-        Entry {\n-            kind: EntryKind::Type,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-\n-            mir: None,\n-        }\n-    }\n-\n     fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1672,10 +1654,6 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n-            hir::TyImplTraitExistential(..) => {\n-                let def_id = self.tcx.hir.local_def_id(ty.id);\n-                self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n-            }\n             hir::TyArray(_, ref length) => {\n                 let def_id = self.tcx.hir.local_def_id(length.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n@@ -1710,6 +1688,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             hir::ItemExternCrate(..) |\n             hir::ItemUse(..) |\n             hir::ItemTy(..) |\n+            hir::ItemExistential(..) |\n             hir::ItemTraitAlias(..) => {\n                 // no sub-item recording needed in these cases\n             }"}, {"sha": "21d6d15457aa0252a4ac51f14e6f61af78e3b913", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -304,6 +304,7 @@ pub enum EntryKind<'tcx> {\n     ForeignType,\n     GlobalAsm,\n     Type,\n+    Existential,\n     Enum(ReprOptions),\n     Field,\n     Variant(Lazy<VariantData<'tcx>>),\n@@ -336,6 +337,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n             EntryKind::GlobalAsm        |\n             EntryKind::ForeignType      |\n             EntryKind::Field |\n+            EntryKind::Existential |\n             EntryKind::Type => {\n                 // Nothing else to hash here.\n             }"}, {"sha": "1fb12172838072e0d0204c34883af594fa44fab6", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -944,6 +944,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemTy(..)          |\n             hir::ItemTrait(..)       |\n             hir::ItemTraitAlias(..)  |\n+            hir::ItemExistential(..) |\n             hir::ItemMod(..)         => {\n                 // Nothing to do, just keep recursing...\n             }"}, {"sha": "291092015b57f06c208538d7d52b66c22985680b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -160,6 +160,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemGlobalAsm(..) | hir::ItemFn(..) | hir::ItemMod(..) |\n             hir::ItemStatic(..) | hir::ItemStruct(..) |\n             hir::ItemTrait(..) | hir::ItemTraitAlias(..) |\n+            hir::ItemExistential(..) |\n             hir::ItemTy(..) | hir::ItemUnion(..) | hir::ItemUse(..) => {\n                 if item.vis == hir::Public { self.prev_level } else { None }\n             }\n@@ -212,6 +213,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n+            hir::ItemExistential(..) |\n             hir::ItemUse(..) | hir::ItemStatic(..) | hir::ItemConst(..) |\n             hir::ItemGlobalAsm(..) | hir::ItemTy(..) | hir::ItemMod(..) | hir::ItemTraitAlias(..) |\n             hir::ItemFn(..) | hir::ItemExternCrate(..) => {}\n@@ -227,6 +229,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemUse(..) => {}\n             // The interface is empty\n             hir::ItemGlobalAsm(..) => {}\n+            // Checked by visit_ty\n+            hir::ItemExistential(..) => {}\n             // Visit everything\n             hir::ItemConst(..) | hir::ItemStatic(..) |\n             hir::ItemFn(..) | hir::ItemTy(..) => {\n@@ -388,10 +392,10 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTraitExistential(..) = ty.node {\n-            if self.get(ty.id).is_some() {\n-                // Reach the (potentially private) type and the API being exposed.\n-                self.reach(ty.id).ty().predicates();\n+        if let hir::TyImplTraitExistential(item_id, _, _) = ty.node {\n+            if self.get(item_id.id).is_some() {\n+                // Reach the (potentially private) type and the API being exposed\n+                self.reach(item_id.id).ty().predicates();\n             }\n         }\n \n@@ -436,6 +440,10 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n \n     fn ty(&mut self) -> &mut Self {\n         let ty = self.ev.tcx.type_of(self.item_def_id);\n+        self.walk_ty(ty)\n+    }\n+\n+    fn walk_ty(&mut self, ty: Ty<'tcx>) -> &mut Self {\n         ty.visit_with(self);\n         if let ty::TyFnDef(def_id, _) = ty.sty {\n             if def_id == self.item_def_id {\n@@ -1546,6 +1554,8 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             hir::ItemUse(..) => {}\n             // No subitems\n             hir::ItemGlobalAsm(..) => {}\n+            // Checked in visit_ty\n+            hir::ItemExistential(..) => {}\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n             hir::ItemTy(..) => {\n@@ -1644,13 +1654,14 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTraitExistential(..) = ty.node {\n+        if let hir::TyImplTraitExistential(ref exist_item, _, _) = ty.node {\n             // Check the traits being exposed, as they're separate,\n             // e.g. `impl Iterator<Item=T>` has two predicates,\n             // `X: Iterator` and `<X as Iterator>::Item == T`,\n             // where `X` is the `impl Iterator<Item=T>` itself,\n             // stored in `predicates_of`, not in the `Ty` itself.\n-            self.check(ty.id, self.inner_visibility).predicates();\n+\n+            self.check(exist_item.id, self.inner_visibility).predicates();\n         }\n \n         intravisit::walk_ty(self, ty);"}, {"sha": "a2b2096ccaa47aa01cf39bfa5587ea91556cfce3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -205,6 +205,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                 Def::AssociatedTy(..) | Def::PrimTy(..) | Def::Fn(..) | Def::Const(..) |\n                 Def::Static(..) | Def::StructCtor(..) | Def::VariantCtor(..) | Def::Method(..) |\n                 Def::AssociatedConst(..) | Def::Local(..) | Def::Upvar(..) | Def::Label(..) |\n+                Def::Existential(..) |\n                 Def::Macro(..) | Def::GlobalAsm(..) | Def::Err =>\n                     bug!(\"TypeParametersFromOuterFunction should only be used with Def::SelfTy or \\\n                          Def::TyParam\")"}, {"sha": "f9510970e43d44edb2a753b8dbfd6f785c56a586", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -749,6 +749,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::TraitAlias(def_id) |\n             HirDef::AssociatedTy(def_id) |\n             HirDef::Trait(def_id) |\n+            HirDef::Existential(def_id) |\n             HirDef::TyParam(def_id) => {\n                 let span = self.span_from_span(sub_span);\n                 Some(Ref {"}, {"sha": "18911b47ed1d08434ac9ba141d56d92bacef8980", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -1118,8 +1118,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyImplTraitExistential(_, ref lifetimes) => {\n-                let def_id = tcx.hir.local_def_id(ast_ty.id);\n+            hir::TyImplTraitExistential(_, def_id, ref lifetimes) => {\n                 self.impl_trait_ty_to_ty(def_id, lifetimes)\n             }\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n@@ -1171,9 +1170,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         result_ty\n     }\n \n-    pub fn impl_trait_ty_to_ty(&self, def_id: DefId, lifetimes: &[hir::Lifetime]) -> Ty<'tcx> {\n+    pub fn impl_trait_ty_to_ty(\n+        &self,\n+        def_id: DefId,\n+        lifetimes: &[hir::Lifetime],\n+    ) -> Ty<'tcx> {\n         debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n         let tcx = self.tcx();\n+\n         let generics = tcx.generics_of(def_id);\n \n         debug!(\"impl_trait_ty_to_ty: generics={:?}\", generics);\n@@ -1198,7 +1202,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         });\n         debug!(\"impl_trait_ty_to_ty: final substs = {:?}\", substs);\n \n-        tcx.mk_anon(def_id, substs)\n+        let ty = tcx.mk_anon(def_id, substs);\n+        debug!(\"impl_trait_ty_to_ty: {}\", ty);\n+        ty\n     }\n \n     pub fn ty_of_arg(&self,"}, {"sha": "d68fc67073e9d73691f21e8864730316e91efd37", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -1013,7 +1013,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     debug!(\"check_fn(sig={:?}, fn_id={}, param_env={:?})\", fn_sig, fn_id, param_env);\n \n     // Create the function context.  This is either derived from scratch or,\n-    // in the case of function expressions, based on the outer context.\n+    // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n "}, {"sha": "f7d1e40794580612dbbf3d35fc7686d3223fcecf", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_anon_types();\n+        wbcx.visit_anon_types(body.value.span);\n         wbcx.visit_cast_types();\n         wbcx.visit_free_region_map();\n         wbcx.visit_user_provided_tys();\n@@ -385,18 +385,28 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_anon_types(&mut self) {\n-        let gcx = self.tcx().global_tcx();\n+    fn visit_anon_types(&mut self, span: Span) {\n         for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n-            let node_id = gcx.hir.as_local_node_id(def_id).unwrap();\n+            let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n             let instantiated_ty = self.resolve(&anon_defn.concrete_ty, &node_id);\n             let definition_ty = self.fcx.infer_anon_definition_from_instantiation(\n                 def_id,\n                 anon_defn,\n                 instantiated_ty,\n             );\n-            let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n-            self.tables.node_types_mut().insert(hir_id, definition_ty);\n+            let old = self.tables.concrete_existential_types.insert(def_id, definition_ty);\n+            if let Some(old) = old {\n+                if old != definition_ty {\n+                    span_bug!(\n+                        span,\n+                        \"visit_anon_types tried to write \\\n+                        different types for the same existential type: {:?}, {:?}, {:?}\",\n+                        def_id,\n+                        definition_ty,\n+                        old,\n+                    );\n+                }\n+            }\n         }\n     }\n "}, {"sha": "fe55ca66379957229771e24ebf9d3ece2c1056a4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 33, "deletions": 53, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -131,15 +131,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTraitExistential(..) = ty.node {\n-            let def_id = self.tcx.hir.local_def_id(ty.id);\n-            self.tcx.generics_of(def_id);\n-            self.tcx.predicates_of(def_id);\n-        }\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         convert_trait_item(self.tcx, trait_item.id);\n         intravisit::walk_trait_item(self, trait_item);\n@@ -420,6 +411,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n                 convert_variant_ctor(tcx, struct_def.id());\n             }\n         },\n+        hir::ItemExistential(..) |\n         hir::ItemTy(..) | hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n@@ -803,18 +795,12 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n             Some(tcx.closure_base_def_id(def_id))\n         }\n-        NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(..), .. }) => {\n-            let mut parent_id = node_id;\n-            loop {\n-                match tcx.hir.get(parent_id) {\n-                    NodeItem(_) | NodeImplItem(_) | NodeTraitItem(_) => break,\n-                    _ => {\n-                        parent_id = tcx.hir.get_parent_node(parent_id);\n-                    }\n-                }\n+        NodeItem(item) => {\n+            match item.node {\n+                ItemExistential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n+                _ => None,\n             }\n-            Some(tcx.hir.local_def_id(parent_id))\n-        }\n+        },\n         _ => None\n     };\n \n@@ -835,6 +821,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ItemTy(_, ref generics) |\n                 ItemEnum(_, ref generics) |\n                 ItemStruct(_, ref generics) |\n+                ItemExistential(hir::ExistTy { ref generics, .. }) |\n                 ItemUnion(_, ref generics) => {\n                     allow_defaults = true;\n                     generics\n@@ -875,8 +862,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(ref exist_ty, _), .. }) => {\n-            &exist_ty.generics\n+        NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(..), .. }) => {\n+            bug!(\"impl Trait is desugared to existential type items\");\n         }\n \n         _ => &no_generics,\n@@ -1056,6 +1043,12 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n+                // this is only reachable once we have named existential types\n+                ItemExistential(hir::ExistTy { impl_trait_fn: None, .. }) => unimplemented!(),\n+                // existential types desugared from impl Trait\n+                ItemExistential(hir::ExistTy { impl_trait_fn: Some(owner), .. }) => {\n+                    tcx.typeck_tables_of(owner).concrete_existential_types[&def_id]\n+                },\n                 ItemTrait(..) | ItemTraitAlias(..) |\n                 ItemMod(..) |\n                 ItemForeignMod(..) |\n@@ -1130,12 +1123,6 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             icx.to_ty(ty)\n         }\n \n-        NodeTy(&hir::Ty { node: TyImplTraitExistential(..), .. }) => {\n-            let owner = tcx.hir.get_parent_did(node_id);\n-            let hir_id = tcx.hir.node_to_hir_id(node_id);\n-            tcx.typeck_tables_of(owner).node_id_to_type(hir_id)\n-        }\n-\n         x => {\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n         }\n@@ -1353,6 +1340,24 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     }, items));\n                     generics\n                 }\n+                ItemExistential(ref exist_ty) => {\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n+                    let anon_ty = tcx.mk_anon(def_id, substs);\n+\n+                    // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n+                    let bounds = compute_bounds(&icx,\n+                                                anon_ty,\n+                                                &exist_ty.bounds,\n+                                                SizedByDefault::Yes,\n+                                                tcx.def_span(def_id));\n+\n+                    let predicates = bounds.predicates(tcx, anon_ty);\n+\n+                    return ty::GenericPredicates {\n+                        parent: None,\n+                        predicates: predicates\n+                    };\n+                }\n \n                 _ => &no_generics,\n             }\n@@ -1366,31 +1371,6 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        NodeTy(&Ty { node: TyImplTraitExistential(ref exist_ty, _), span, .. }) => {\n-            let substs = Substs::identity_for_item(tcx, def_id);\n-            let anon_ty = tcx.mk_anon(def_id, substs);\n-\n-            debug!(\"explicit_predicates_of: anon_ty={:?}\", anon_ty);\n-\n-            // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n-            let bounds = compute_bounds(&icx,\n-                                        anon_ty,\n-                                        &exist_ty.bounds,\n-                                        SizedByDefault::Yes,\n-                                        span);\n-\n-            debug!(\"explicit_predicates_of: bounds={:?}\", bounds);\n-\n-            let predicates = bounds.predicates(tcx, anon_ty);\n-\n-            debug!(\"explicit_predicates_of: predicates={:?}\", predicates);\n-\n-            return ty::GenericPredicates {\n-                parent: None,\n-                predicates: predicates\n-            };\n-        }\n-\n         _ => &no_generics,\n     };\n "}, {"sha": "852a4479199df6f5f75741b421e6037aaaad771b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -2939,7 +2939,14 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyImplTraitExistential(ref exist_ty, ref _lts) => ImplTrait(exist_ty.bounds.clean(cx)),\n+            TyImplTraitExistential(hir_id, _, _) => {\n+                match cx.tcx.hir.expect_item(hir_id.id).node {\n+                    hir::ItemExistential(ref exist_ty) => {\n+                        ImplTrait(exist_ty.bounds.clean(cx))\n+                    },\n+                    ref other => panic!(\"impl Trait pointed to {:#?}\", other),\n+                }\n+            },\n             TyInfer | TyErr => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }"}, {"sha": "10b1a2e1e0b67a0c413364ff8f4ea06e762f62bf", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -564,6 +564,9 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     om.impls.push(i);\n                 }\n             },\n+            hir::ItemExistential(_) => {\n+                // FIXME(oli-obk): actually generate docs for real existential items\n+            }\n         }\n     }\n "}, {"sha": "6dd910fba8218ab482e8a789d9a9ab8e93bfafc8", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -489,6 +489,10 @@ pub enum CompilerDesugaringKind {\n     DotFill,\n     QuestionMark,\n     Catch,\n+    /// Desugaring of an `impl Trait` in return type position\n+    /// to an `existential type Foo: Trait;` + replacing the\n+    /// `impl Trait` with `Foo`.\n+    ExistentialReturnType,\n }\n \n impl CompilerDesugaringKind {\n@@ -498,6 +502,7 @@ impl CompilerDesugaringKind {\n             DotFill => \"...\",\n             QuestionMark => \"?\",\n             Catch => \"do catch\",\n+            ExistentialReturnType => \"existental type\",\n         };\n         Symbol::intern(s)\n     }"}, {"sha": "03860ae2122a81953efc7e1f1b202550bc6634f2", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -284,7 +284,7 @@ pub fn change_return_impl_trait() -> impl Clone {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody\")]\n+#[rustc_clean(cfg = \"cfail2\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn change_return_impl_trait() -> impl Copy {\n     0u32"}, {"sha": "6e2944e8400e32f4f9f9a5c10dd729fda2c4ea1c", "filename": "src/test/run-pass/impl-trait/auxiliary/xcrate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -23,3 +23,7 @@ pub fn return_closure_accessing_internal_fn() -> impl Fn() -> u32 {\n         some_internal_fn() + 1\n     }\n }\n+\n+pub fn return_internal_fn() -> impl Fn() -> u32 {\n+    some_internal_fn\n+}"}, {"sha": "cc931a68edd049eca4e5e334870732f69b6f0c0f", "filename": "src/test/run-pass/impl-trait/bounds_regression.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fbounds_regression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fbounds_regression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fbounds_regression.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait FakeGenerator {\n+    type Yield;\n+    type Return;\n+}\n+\n+pub trait FakeFuture {\n+    type Output;\n+}\n+\n+pub fn future_from_generator<\n+    T: FakeGenerator<Yield = ()>\n+>(x: T) -> impl FakeFuture<Output = T::Return> {\n+    GenFuture(x)\n+}\n+\n+struct GenFuture<T: FakeGenerator<Yield = ()>>(T);\n+\n+impl<T: FakeGenerator<Yield = ()>> FakeFuture for GenFuture<T> {\n+    type Output = T::Return;\n+}\n+\n+fn main() {}"}, {"sha": "fce31256db4921879c531834c0046bd772538fba", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -14,8 +14,6 @@\n #![feature(fn_traits,\n            step_trait,\n            unboxed_closures,\n-           copy_closures,\n-           clone_closures\n )]\n \n //! Derived from: <https://raw.githubusercontent.com/quickfur/dcal/master/dcal.d>."}, {"sha": "4e9d786dda05874eab16c77ca1a7c6942f1c2adf", "filename": "src/test/run-pass/impl-trait/existential-minimal.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexistential-minimal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexistential-minimal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexistential-minimal.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {}\n+\n+fn foo() -> impl std::fmt::Debug { \"cake\" }"}, {"sha": "73e6c1c0d1d68df67ffb4aa02dd51ca9da6557a6", "filename": "src/test/run-pass/impl-trait/nesting.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fnesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fnesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fnesting.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<T>(t: T) -> impl Into<[T; { const FOO: usize = 1; FOO }]> {\n+    [t]\n+}\n+\n+fn bar() -> impl Into<[u8; { const FOO: usize = 1; FOO }]> {\n+    [99]\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", foo(42).into());\n+    println!(\"{:?}\", bar().into());\n+}"}, {"sha": "8d4086cc880478eb61f86b16e3d6b116ce98bbf7", "filename": "src/test/run-pass/impl-trait/xcrate_simple.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate_simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate_simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate_simple.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate.rs\n+\n+extern crate xcrate;\n+\n+fn main() {\n+    xcrate::return_internal_fn()();\n+}"}, {"sha": "abb3682a4987a3533b8b70b8d75c53e381f6b54b", "filename": "src/test/ui/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -13,35 +13,19 @@\n use std::cell::Cell;\n use std::rc::Rc;\n \n-// Fast path, main can see the concrete type returned.\n-fn before() -> impl Fn(i32) {\n-    let p = Rc::new(Cell::new(0));\n-    move |x| p.set(x)\n-}\n-\n fn send<T: Send>(_: T) {}\n \n fn main() {\n-    send(before());\n-    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n-\n-    send(after());\n-    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n-}\n-\n-// Deferred path, main has to wait until typeck finishes,\n-// to check if the return type of after is Send.\n-fn after() -> impl Fn(i32) {\n-    let p = Rc::new(Cell::new(0));\n-    move |x| p.set(x)\n }\n \n // Cycles should work as the deferred obligations are\n // independently resolved and only require the concrete\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n     //~^ ERROR cycle detected\n+    //~| ERROR cycle detected\n     send(cycle2().clone());\n+    //~^ ERROR Send` is not satisfied\n \n     Rc::new(Cell::new(5))\n }"}, {"sha": "4537c96c4ab3b8319984f8f5d09d1c97604c38a5", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -1,58 +1,65 @@\n-error[E0277]: the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied in `impl std::ops::Fn<(i32,)>`\n-  --> $DIR/auto-trait-leak.rs:25:5\n+error[E0391]: cycle detected when processing `cycle1::{{exist-impl-Trait}}`\n+  --> $DIR/auto-trait-leak.rs:24:16\n    |\n-LL |     send(before());\n-   |     ^^^^ `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+LL | fn cycle1() -> impl Clone {\n+   |                ^^^^^^^^^^\n    |\n-   = help: within `impl std::ops::Fn<(i32,)>`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n-   = note: required because it appears within the type `[closure@$DIR/auto-trait-leak.rs:19:5: 19:22 p:std::rc::Rc<std::cell::Cell<i32>>]`\n-   = note: required because it appears within the type `impl std::ops::Fn<(i32,)>`\n-note: required by `send`\n-  --> $DIR/auto-trait-leak.rs:22:1\n+note: ...which requires processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:24:1\n    |\n-LL | fn send<T: Send>(_: T) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0277]: the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied in `impl std::ops::Fn<(i32,)>`\n-  --> $DIR/auto-trait-leak.rs:28:5\n-   |\n-LL |     send(after());\n-   |     ^^^^ `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n+note: ...which requires processing `cycle2::{{exist-impl-Trait}}`...\n+  --> $DIR/auto-trait-leak.rs:33:16\n    |\n-   = help: within `impl std::ops::Fn<(i32,)>`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n-   = note: required because it appears within the type `[closure@$DIR/auto-trait-leak.rs:36:5: 36:22 p:std::rc::Rc<std::cell::Cell<i32>>]`\n-   = note: required because it appears within the type `impl std::ops::Fn<(i32,)>`\n-note: required by `send`\n-  --> $DIR/auto-trait-leak.rs:22:1\n+LL | fn cycle2() -> impl Clone {\n+   |                ^^^^^^^^^^\n+note: ...which requires processing `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:33:1\n    |\n-LL | fn send<T: Send>(_: T) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n+   = note: ...which again requires processing `cycle1::{{exist-impl-Trait}}`, completing the cycle\n \n-error[E0391]: cycle detected when processing `cycle1`\n-  --> $DIR/auto-trait-leak.rs:42:1\n+error[E0391]: cycle detected when processing `cycle1::{{exist-impl-Trait}}`\n+  --> $DIR/auto-trait-leak.rs:24:16\n    |\n LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                ^^^^^^^^^^\n    |\n+note: ...which requires processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:24:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle2::{{impl-Trait}}`...\n-  --> $DIR/auto-trait-leak.rs:49:16\n+note: ...which requires processing `cycle2::{{exist-impl-Trait}}`...\n+  --> $DIR/auto-trait-leak.rs:33:16\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:49:1\n+  --> $DIR/auto-trait-leak.rs:33:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle1::{{impl-Trait}}`...\n-  --> $DIR/auto-trait-leak.rs:42:16\n+   = note: ...which again requires processing `cycle1::{{exist-impl-Trait}}`, completing the cycle\n+\n+error[E0277]: the trait bound `std::rc::Rc<std::string::String>: std::marker::Send` is not satisfied in `impl std::clone::Clone`\n+  --> $DIR/auto-trait-leak.rs:27:5\n    |\n-LL | fn cycle1() -> impl Clone {\n-   |                ^^^^^^^^^^\n-   = note: ...which again requires processing `cycle1`, completing the cycle\n-note: cycle used when type-checking all item bodies\n+LL |     send(cycle2().clone());\n+   |     ^^^^ `std::rc::Rc<std::string::String>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::clone::Clone`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::string::String>`\n+   = note: required because it appears within the type `impl std::clone::Clone`\n+note: required by `send`\n+  --> $DIR/auto-trait-leak.rs:16:1\n+   |\n+LL | fn send<T: Send>(_: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "16310e67f1bb9c26f1f68d89302fb666886f0925", "filename": "src/test/ui/impl-trait/auto-trait-leak2.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+use std::cell::Cell;\n+use std::rc::Rc;\n+\n+// Fast path, main can see the concrete type returned.\n+fn before() -> impl Fn(i32) {\n+    let p = Rc::new(Cell::new(0));\n+    move |x| p.set(x)\n+}\n+\n+fn send<T: Send>(_: T) {}\n+\n+fn main() {\n+    send(before());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n+\n+    send(after());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n+}\n+\n+// Deferred path, main has to wait until typeck finishes,\n+// to check if the return type of after is Send.\n+fn after() -> impl Fn(i32) {\n+    let p = Rc::new(Cell::new(0));\n+    move |x| p.set(x)\n+}\n+"}, {"sha": "59623aed3d2b73fdb5b7c7854cc2f6c1d5653aaf", "filename": "src/test/ui/impl-trait/auto-trait-leak2.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.stderr?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied in `impl std::ops::Fn<(i32,)>`\n+  --> $DIR/auto-trait-leak2.rs:25:5\n+   |\n+LL |     send(before());\n+   |     ^^^^ `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::ops::Fn<(i32,)>`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n+   = note: required because it appears within the type `[closure@$DIR/auto-trait-leak2.rs:19:5: 19:22 p:std::rc::Rc<std::cell::Cell<i32>>]`\n+   = note: required because it appears within the type `impl std::ops::Fn<(i32,)>`\n+note: required by `send`\n+  --> $DIR/auto-trait-leak2.rs:22:1\n+   |\n+LL | fn send<T: Send>(_: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied in `impl std::ops::Fn<(i32,)>`\n+  --> $DIR/auto-trait-leak2.rs:28:5\n+   |\n+LL |     send(after());\n+   |     ^^^^ `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::ops::Fn<(i32,)>`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n+   = note: required because it appears within the type `[closure@$DIR/auto-trait-leak2.rs:36:5: 36:22 p:std::rc::Rc<std::cell::Cell<i32>>]`\n+   = note: required because it appears within the type `impl std::ops::Fn<(i32,)>`\n+note: required by `send`\n+  --> $DIR/auto-trait-leak2.rs:22:1\n+   |\n+LL | fn send<T: Send>(_: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "71fccc022b71bcc2bb029e009283869044ff371b", "filename": "src/test/ui/impl-trait/equality.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -50,23 +50,4 @@ impl Leak for i32 {\n }\n \n fn main() {\n-    let _: u32 = hide(0_u32);\n-    //~^ ERROR mismatched types\n-    //~| expected type `u32`\n-    //~| found type `impl Foo`\n-    //~| expected u32, found anonymized type\n-\n-    let _: i32 = Leak::leak(hide(0_i32));\n-    //~^ ERROR mismatched types\n-    //~| expected type `i32`\n-    //~| found type `<impl Foo as Leak>::T`\n-    //~| expected i32, found associated type\n-\n-    let mut x = (hide(0_u32), hide(0_i32));\n-    x = (x.1,\n-    //~^ ERROR mismatched types\n-    //~| expected u32, found i32\n-         x.0);\n-    //~^ ERROR mismatched types\n-    //~| expected i32, found u32\n }"}, {"sha": "e277d4e28cb2ba6a974341d92e032e59c996ceb7", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -15,43 +15,7 @@ LL |         n + sum_to(n - 1)\n    |\n    = help: the trait `std::ops::Add<impl Foo>` is not implemented for `u32`\n \n-error[E0308]: mismatched types\n-  --> $DIR/equality.rs:53:18\n-   |\n-LL |     let _: u32 = hide(0_u32);\n-   |                  ^^^^^^^^^^^ expected u32, found anonymized type\n-   |\n-   = note: expected type `u32`\n-              found type `impl Foo`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/equality.rs:59:18\n-   |\n-LL |     let _: i32 = Leak::leak(hide(0_i32));\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected i32, found associated type\n-   |\n-   = note: expected type `i32`\n-              found type `<impl Foo as Leak>::T`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/equality.rs:66:10\n-   |\n-LL |     x = (x.1,\n-   |          ^^^ expected u32, found i32\n-   |\n-   = note: expected type `impl Foo` (u32)\n-              found type `impl Foo` (i32)\n-\n-error[E0308]: mismatched types\n-  --> $DIR/equality.rs:69:10\n-   |\n-LL |          x.0);\n-   |          ^^^ expected i32, found u32\n-   |\n-   = note: expected type `impl Foo` (i32)\n-              found type `impl Foo` (u32)\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors occurred: E0277, E0308.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "ec3dc15d8464e82519c391c5a8bb7b821745818b", "filename": "src/test/ui/impl-trait/equality2.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+trait Foo: Copy + ToString {}\n+\n+impl<T: Copy + ToString> Foo for T {}\n+\n+fn hide<T: Foo>(x: T) -> impl Foo {\n+    x\n+}\n+\n+trait Leak: Sized {\n+    type T;\n+    fn leak(self) -> Self::T;\n+}\n+impl<T> Leak for T {\n+    default type T = ();\n+    default fn leak(self) -> Self::T { panic!() }\n+}\n+impl Leak for i32 {\n+    type T = i32;\n+    fn leak(self) -> i32 { self }\n+}\n+\n+fn main() {\n+    let _: u32 = hide(0_u32);\n+    //~^ ERROR mismatched types\n+    //~| expected type `u32`\n+    //~| found type `impl Foo`\n+    //~| expected u32, found anonymized type\n+\n+    let _: i32 = Leak::leak(hide(0_i32));\n+    //~^ ERROR mismatched types\n+    //~| expected type `i32`\n+    //~| found type `<impl Foo as Leak>::T`\n+    //~| expected i32, found associated type\n+\n+    let mut x = (hide(0_u32), hide(0_i32));\n+    x = (x.1,\n+    //~^ ERROR mismatched types\n+    //~| expected u32, found i32\n+         x.0);\n+    //~^ ERROR mismatched types\n+    //~| expected i32, found u32\n+}"}, {"sha": "e4ff2f68247834e92e5baee1f264959590c9de8e", "filename": "src/test/ui/impl-trait/equality2.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -0,0 +1,39 @@\n+error[E0308]: mismatched types\n+  --> $DIR/equality2.rs:35:18\n+   |\n+LL |     let _: u32 = hide(0_u32);\n+   |                  ^^^^^^^^^^^ expected u32, found anonymized type\n+   |\n+   = note: expected type `u32`\n+              found type `impl Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/equality2.rs:41:18\n+   |\n+LL |     let _: i32 = Leak::leak(hide(0_i32));\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected i32, found associated type\n+   |\n+   = note: expected type `i32`\n+              found type `<impl Foo as Leak>::T`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/equality2.rs:48:10\n+   |\n+LL |     x = (x.1,\n+   |          ^^^ expected u32, found i32\n+   |\n+   = note: expected type `impl Foo` (u32)\n+              found type `impl Foo` (i32)\n+\n+error[E0308]: mismatched types\n+  --> $DIR/equality2.rs:51:10\n+   |\n+LL |          x.0);\n+   |          ^^^ expected i32, found u32\n+   |\n+   = note: expected type `impl Foo` (i32)\n+              found type `impl Foo` (u32)\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}