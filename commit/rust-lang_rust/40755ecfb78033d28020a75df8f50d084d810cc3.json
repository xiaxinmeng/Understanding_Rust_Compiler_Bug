{"sha": "40755ecfb78033d28020a75df8f50d084d810cc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNzU1ZWNmYjc4MDMzZDI4MDIwYTc1ZGY4ZjUwZDA4NGQ4MTBjYzM=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-07-11T13:03:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-11T13:03:14Z"}, "message": "Merge pull request #236 from oli-obk/pointers\n\nUse a wrapper type to differentiate between `PrimVal` and pointers", "tree": {"sha": "e14814232d75759bcbc037ce201b2f19f8db017f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e14814232d75759bcbc037ce201b2f19f8db017f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40755ecfb78033d28020a75df8f50d084d810cc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40755ecfb78033d28020a75df8f50d084d810cc3", "html_url": "https://github.com/rust-lang/rust/commit/40755ecfb78033d28020a75df8f50d084d810cc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40755ecfb78033d28020a75df8f50d084d810cc3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "151102345624f6453dfe2474009d202792160afb", "url": "https://api.github.com/repos/rust-lang/rust/commits/151102345624f6453dfe2474009d202792160afb", "html_url": "https://github.com/rust-lang/rust/commit/151102345624f6453dfe2474009d202792160afb"}, {"sha": "eba199a437116570d10f902b4176d4a01662cbd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/eba199a437116570d10f902b4176d4a01662cbd9", "html_url": "https://github.com/rust-lang/rust/commit/eba199a437116570d10f902b4176d4a01662cbd9"}], "stats": {"total": 530, "additions": 297, "deletions": 233}, "files": [{"sha": "801ea5c7da48f6b3348bd6e257d22db5a0c9921a", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -2,22 +2,22 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::Pointer;\n+use memory::MemoryPointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n #[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n     FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n-    UnterminatedCString(Pointer),\n+    UnterminatedCString(MemoryPointer),\n     DanglingPointerDeref,\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n-        ptr: Pointer,\n+        ptr: MemoryPointer,\n         access: bool,\n         allocation_size: u64,\n     },"}, {"sha": "e5b473a70e3bdce70ff5c022aa750a601c2ce85a", "filename": "src/eval_context.rs", "status": "modified", "additions": 69, "deletions": 54, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -17,9 +17,9 @@ use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n-use memory::{Memory, Pointer, TlsKey};\n+use memory::{Memory, MemoryPointer, TlsKey};\n use operator;\n-use value::{PrimVal, PrimValKind, Value};\n+use value::{PrimVal, PrimValKind, Value, Pointer};\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -44,7 +44,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n \n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, Pointer>,\n+    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n }\n \n /// A stack frame.\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n         let substs = self.substs();\n         self.alloc_ptr_with_substs(ty, substs)\n     }\n@@ -151,7 +151,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         ty: Ty<'tcx>,\n         substs: &'tcx Substs<'tcx>\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, MemoryPointer> {\n         let size = self.type_size_with_substs(ty, substs)?.expect(\"cannot alloc memory for unsized type\");\n         let align = self.type_align_with_substs(ty, substs)?;\n         self.memory.allocate(size, align)\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             set\n         }\n \n-        // Subtract 1 because `local_decls` includes the ReturnPointer, but we don't store a local\n+        // Subtract 1 because `local_decls` includes the ReturnMemoryPointer, but we don't store a local\n         // `Value` for that.\n         let annotated_locals = collect_storage_annotations(mir);\n         let num_locals = mir.local_decls.len() - 1;\n@@ -395,7 +395,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n                     let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                     let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                    self.write_primval(dest, ptr, ty)?;\n+                    self.write_ptr(dest, ptr, ty)?;\n                 }\n             }\n         }\n@@ -444,7 +444,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n-            ptr: PrimVal::Ptr(dest_ptr),\n+            ptr: dest_ptr.into(),\n             extra: LvalueExtra::DowncastVariant(variant_idx),\n         };\n \n@@ -580,7 +580,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     let operand_ty = self.operand_ty(operand);\n                                     assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                                self.write_null(dest, dest_ty)?;\n                             }\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -662,7 +662,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n-                let dest = PrimVal::Ptr(self.force_allocation(dest)?.to_ptr()?);\n+                let dest = Pointer::from(self.force_allocation(dest)?.to_ptr()?);\n \n                 for i in 0..length {\n                     let elem_dest = dest.offset(i * elem_size, self.memory.layout)?;\n@@ -686,9 +686,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = self.lvalue_ty(lvalue);\n \n                 let val = match extra {\n-                    LvalueExtra::None => Value::ByVal(ptr),\n-                    LvalueExtra::Length(len) => Value::ByValPair(ptr, PrimVal::from_u128(len as u128)),\n-                    LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::Ptr(vtable)),\n+                    LvalueExtra::None => ptr.to_value(),\n+                    LvalueExtra::Length(len) => ptr.to_value_with_len(len),\n+                    LvalueExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 };\n@@ -928,14 +928,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn wrapping_pointer_offset(&self, ptr: PrimVal, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn wrapping_pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n         ptr.wrapping_signed_offset(offset, self.memory.layout)\n     }\n \n-    pub(super) fn pointer_offset(&self, ptr: PrimVal, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n         // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n         // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n         // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n-            if let PrimVal::Ptr(ptr) = ptr {\n+            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n                 self.memory.check_bounds(ptr, false)?;\n             } else if ptr.is_null()? {\n                 // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n \n-    fn copy(&mut self, src: PrimVal, dest: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         let size = self.type_size(ty)?.expect(\"cannot copy from an unsized type\");\n         let align = self.type_align(ty)?;\n         self.memory.copy(src, dest, size, align, false)?;\n@@ -1026,8 +1026,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n-                        self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(PrimVal::Ptr(ptr))); // it stays live\n-                        self.write_value_to_ptr(val, PrimVal::Ptr(ptr), ty)?;\n+                        self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(ptr.into())); // it stays live\n+                        self.write_value_to_ptr(val, ptr.into(), ty)?;\n                         Lvalue::from_ptr(ptr)\n                     }\n                 }\n@@ -1040,14 +1040,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n                         self.memory.mark_static(ptr.alloc_id);\n-                        self.write_value_to_ptr(global_val.value, PrimVal::Ptr(ptr), global_val.ty)?;\n+                        self.write_value_to_ptr(global_val.value, ptr.into(), global_val.ty)?;\n                         // see comment on `initialized` field\n                         if global_val.initialized {\n                             self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n                         }\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n-                            value: Value::ByRef(PrimVal::Ptr(ptr)),\n+                            value: Value::ByRef(ptr.into()),\n                             .. global_val\n                         };\n                         Lvalue::from_ptr(ptr)\n@@ -1079,6 +1079,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n+    pub(super) fn write_null(\n+        &mut self,\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n+    }\n+\n+    pub(super) fn write_ptr(\n+        &mut self,\n+        dest: Lvalue<'tcx>,\n+        val: Pointer,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        self.write_value(val.to_value(), dest, dest_ty)\n+    }\n+\n     pub(super) fn write_primval(\n         &mut self,\n         dest: Lvalue<'tcx>,\n@@ -1164,9 +1181,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             if let Ok(Some(src_val)) = self.try_read_value(src_ptr, dest_ty) {\n                 write_dest(self, src_val)?;\n             } else {\n-                let dest_ptr = self.alloc_ptr(dest_ty)?;\n-                self.copy(src_ptr, PrimVal::Ptr(dest_ptr), dest_ty)?;\n-                write_dest(self, Value::ByRef(PrimVal::Ptr(dest_ptr)))?;\n+                let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n+                self.copy(src_ptr, dest_ptr, dest_ty)?;\n+                write_dest(self, Value::ByRef(dest_ptr))?;\n             }\n \n         } else {\n@@ -1180,7 +1197,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n-        dest: PrimVal,\n+        dest: Pointer,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n@@ -1197,7 +1214,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         a: PrimVal,\n         b: PrimVal,\n-        ptr: Pointer,\n+        ptr: MemoryPointer,\n         mut ty: Ty<'tcx>\n     ) -> EvalResult<'tcx> {\n         while self.get_field_count(ty)? == 1 {\n@@ -1210,8 +1227,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(PrimVal::Ptr(ptr.offset(field_0, self.memory.layout)?), a, field_0_size)?;\n-        self.memory.write_primval(PrimVal::Ptr(ptr.offset(field_1, self.memory.layout)?), b, field_1_size)?;\n+        self.memory.write_primval(ptr.offset(field_0, self.memory.layout)?.into(), a, field_0_size)?;\n+        self.memory.write_primval(ptr.offset(field_1, self.memory.layout)?.into(), b, field_1_size)?;\n         Ok(())\n     }\n \n@@ -1314,32 +1331,31 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn read_value(&mut self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, ty)? {\n             Ok(val)\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", ty);\n         }\n     }\n \n-    pub(crate) fn read_ptr(&self, ptr: Pointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(crate) fn read_ptr(&self, ptr: MemoryPointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         let p = self.memory.read_ptr(ptr)?;\n         if self.type_is_sized(pointee_ty) {\n-            Ok(Value::ByVal(p))\n+            Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(self.memory.pointer_size(), self.memory.layout)?;\n-            let extra = match self.tcx.struct_tail(pointee_ty).sty {\n-                ty::TyDynamic(..) => self.memory.read_ptr(extra)?,\n+            match self.tcx.struct_tail(pointee_ty).sty {\n+                ty::TyDynamic(..) => Ok(p.to_value_with_vtable(self.memory.read_ptr(extra)?.to_ptr()?)),\n                 ty::TySlice(..) |\n-                ty::TyStr => PrimVal::from_u128(self.memory.read_usize(extra)? as u128),\n+                ty::TyStr => Ok(p.to_value_with_len(self.memory.read_usize(extra)?)),\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n-            };\n-            Ok(Value::ByValPair(p, extra))\n+            }\n         }\n     }\n \n-    fn try_read_value(&mut self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    fn try_read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n         let val = match ty.sty {\n@@ -1365,7 +1381,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // if we transmute a ptr to an isize, reading it back into a primval shouldn't panic\n                 // Due to read_ptr ignoring the sign, we need to jump around some hoops\n                 match self.memory.read_int(ptr.to_ptr()?, size) {\n-                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr.to_ptr()?)?,\n+                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n                     other => PrimVal::from_i128(other?),\n                 }\n             }\n@@ -1382,7 +1398,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 if size == self.memory.pointer_size() {\n                     // if we transmute a ptr to an usize, reading it back into a primval shouldn't panic\n-                    self.memory.read_ptr(ptr.to_ptr()?)?\n+                    self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval()\n                 } else {\n                     PrimVal::from_u128(self.memory.read_uint(ptr.to_ptr()?, size)?)\n                 }\n@@ -1391,7 +1407,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr.to_ptr()?)?),\n             ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr.to_ptr()?)?),\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr.to_ptr()?)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n             ty::TyRef(_, ref tam) |\n             ty::TyRawPtr(ref tam) => return self.read_ptr(ptr.to_ptr()?, tam.ty).map(Some),\n \n@@ -1449,8 +1465,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                 let ptr = src.read_ptr(&self.memory)?;\n-                let len = PrimVal::from_u128(length as u128);\n-                self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)\n+                // u64 cast is from usize to u64, which is always good\n+                self.write_value(ptr.to_value_with_len(length as u64), dest, dest_ty)\n             }\n             (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n                 // For now, upcasts are limited to changes in marker\n@@ -1463,8 +1479,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n                 let ptr = src.read_ptr(&self.memory)?;\n-                let extra = PrimVal::Ptr(vtable);\n-                self.write_value(Value::ByValPair(ptr, extra), dest, dest_ty)\n+                self.write_value(ptr.to_value_with_vtable(vtable), dest, dest_ty)\n             },\n \n             _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n@@ -1524,7 +1539,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let src_f_ptr = src_ptr.offset(src_field_offset, self.memory.layout)?;\n                     let dst_f_ptr = dest.offset(dst_field_offset, self.memory.layout)?;\n                     if src_fty == dst_fty {\n-                        self.copy(src_f_ptr, PrimVal::Ptr(dst_f_ptr), src_fty)?;\n+                        self.copy(src_f_ptr, dst_f_ptr.into(), src_fty)?;\n                     } else {\n                         self.unsize_into(Value::ByRef(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n                     }\n@@ -1553,13 +1568,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Err(err) => {\n                     panic!(\"Failed to access local: {:?}\", err);\n                 }\n-                Ok(Value::ByRef(PrimVal::Ptr(ptr))) => {\n-                    write!(msg, \" by ref:\").unwrap();\n-                    allocs.push(ptr.alloc_id);\n-                }\n-                Ok(Value::ByRef(ptr)) => {\n-                    write!(msg, \" integral by ref: {:?}\", ptr).unwrap();\n-                }\n+                Ok(Value::ByRef(ptr)) => match ptr.into_inner_primval() {\n+                    PrimVal::Ptr(ptr) => {\n+                        write!(msg, \" by ref:\").unwrap();\n+                        allocs.push(ptr.alloc_id);\n+                    },\n+                    ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n+                },\n                 Ok(Value::ByVal(val)) => {\n                     write!(msg, \" {:?}\", val).unwrap();\n                     if let PrimVal::Ptr(ptr) = val { allocs.push(ptr.alloc_id); }\n@@ -1696,12 +1711,12 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             // Second argument (argc): 0\n             let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n             let ty = ecx.tcx.types.isize;\n-            ecx.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, ty)?;\n+            ecx.write_null(dest, ty)?;\n \n             // Third argument (argv): 0\n             let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n             let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n-            ecx.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, ty)?;\n+            ecx.write_null(dest, ty)?;\n         } else {\n             ecx.push_stack_frame(\n                 main_instance,"}, {"sha": "bbb271a6b6a79a782e70a6b983662651d3907c61", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -48,7 +48,7 @@ pub use lvalue::{\n pub use memory::{\n     AllocId,\n     Memory,\n-    Pointer,\n+    MemoryPointer,\n };\n \n pub use value::{"}, {"sha": "f2581379ea1743f0a1ab22160e35e1f5b1ceb37f", "filename": "src/lvalue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -5,8 +5,8 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext};\n-use memory::Pointer;\n-use value::{PrimVal, Value};\n+use memory::MemoryPointer;\n+use value::{PrimVal, Value, Pointer};\n \n #[derive(Copy, Clone, Debug)]\n pub enum Lvalue<'tcx> {\n@@ -15,7 +15,7 @@ pub enum Lvalue<'tcx> {\n         /// An lvalue may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: PrimVal,\n+        ptr: Pointer,\n         extra: LvalueExtra,\n     },\n \n@@ -34,7 +34,7 @@ pub enum Lvalue<'tcx> {\n pub enum LvalueExtra {\n     None,\n     Length(u64),\n-    Vtable(Pointer),\n+    Vtable(MemoryPointer),\n     DowncastVariant(usize),\n }\n \n@@ -64,26 +64,26 @@ pub struct Global<'tcx> {\n impl<'tcx> Lvalue<'tcx> {\n     /// Produces an Lvalue that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Self::from_primval_ptr(PrimVal::Undef)\n+        Self::from_primval_ptr(PrimVal::Undef.into())\n     }\n \n-    pub(crate) fn from_primval_ptr(ptr: PrimVal) -> Self {\n+    pub(crate) fn from_primval_ptr(ptr: Pointer) -> Self {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n     }\n \n-    pub(crate) fn from_ptr(ptr: Pointer) -> Self {\n-        Self::from_primval_ptr(PrimVal::Ptr(ptr))\n+    pub(crate) fn from_ptr(ptr: MemoryPointer) -> Self {\n+        Self::from_primval_ptr(ptr.into())\n     }\n \n-    pub(super) fn to_ptr_and_extra(self) -> (PrimVal, LvalueExtra) {\n+    pub(super) fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n         match self {\n             Lvalue::Ptr { ptr, extra } => (ptr, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    pub(super) fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         let (ptr, extra) = self.to_ptr_and_extra();\n         assert_eq!(extra, LvalueExtra::None);\n         ptr.to_ptr()\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(base_ptr, PrimVal::Ptr(tab)))?;\n+                let (_, align) = self.size_and_align_of_dst(base_ty, base_ptr.to_value_with_vtable(tab))?;\n                 offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n             }\n             _ => offset.bytes(),"}, {"sha": "caf7f3a65161498821e8b6b1e1409ae36553e636", "filename": "src/memory.rs", "status": "modified", "additions": 70, "deletions": 68, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -6,7 +6,7 @@ use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n use error::{EvalError, EvalResult};\n-use value::{PrimVal, self};\n+use value::{PrimVal, self, Pointer};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n@@ -50,44 +50,44 @@ pub enum StaticKind {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub struct Pointer {\n+pub struct MemoryPointer {\n     pub alloc_id: AllocId,\n     pub offset: u64,\n }\n \n-impl Pointer {\n+impl MemoryPointer {\n     pub fn new(alloc_id: AllocId, offset: u64) -> Self {\n-        Pointer { alloc_id, offset }\n+        MemoryPointer { alloc_id, offset }\n     }\n \n     pub fn wrapping_signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> Self {\n-        Pointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n+        MemoryPointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n     }\n \n     pub fn overflowing_signed_offset<'tcx>(self, i: i128, layout: &TargetDataLayout) -> (Self, bool) {\n         let (res, over) = value::overflowing_signed_offset(self.offset, i, layout);\n-        (Pointer::new(self.alloc_id, res), over)\n+        (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n     pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n+        Ok(MemoryPointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n     }\n \n     pub fn overflowing_offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> (Self, bool) {\n         let (res, over) = value::overflowing_offset(self.offset, i, layout);\n-        (Pointer::new(self.alloc_id, res), over)\n+        (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n     pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n+        Ok(MemoryPointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n     }\n }\n \n pub type TlsKey = usize;\n \n #[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n-    data: PrimVal, // Will eventually become a map from thread IDs to `PrimVal`s, if we ever support more than one thread.\n+    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -171,21 +171,21 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.alloc_map.iter()\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> Pointer {\n+    pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> MemoryPointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&instance) {\n-            return Pointer::new(alloc_id, 0);\n+            return MemoryPointer::new(alloc_id, 0);\n         }\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n         self.functions.insert(id, instance);\n         self.function_alloc_cache.insert(instance, id);\n-        Pointer::new(id, 0)\n+        MemoryPointer::new(id, 0)\n     }\n \n-    pub fn allocate_cached(&mut self, bytes: &[u8]) -> EvalResult<'tcx, Pointer> {\n+    pub fn allocate_cached(&mut self, bytes: &[u8]) -> EvalResult<'tcx, MemoryPointer> {\n         if let Some(&alloc_id) = self.literal_alloc_cache.get(bytes) {\n-            return Ok(Pointer::new(alloc_id, 0));\n+            return Ok(MemoryPointer::new(alloc_id, 0));\n         }\n \n         let ptr = self.allocate(bytes.len() as u64, 1)?;\n@@ -195,7 +195,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(ptr)\n     }\n \n-    pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n+    pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, MemoryPointer> {\n         assert_ne!(align, 0);\n         assert!(align.is_power_of_two());\n \n@@ -218,12 +218,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n-        Ok(Pointer::new(id, 0))\n+        Ok(MemoryPointer::new(id, 0))\n     }\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, Pointer> {\n+    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, MemoryPointer> {\n         use std::cmp::min;\n \n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n@@ -236,14 +236,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n         let new_ptr = self.allocate(new_size, new_align)?;\n-        self.copy(PrimVal::Ptr(ptr), PrimVal::Ptr(new_ptr), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n+        self.copy(ptr.into(), new_ptr.into(), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n         self.deallocate(ptr, Some((old_size, old_align)))?;\n \n         Ok(new_ptr)\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n-    pub fn deallocate(&mut self, ptr: Pointer, size_and_align: Option<(u64, u64)>) -> EvalResult<'tcx> {\n+    pub fn deallocate(&mut self, ptr: MemoryPointer, size_and_align: Option<(u64, u64)>) -> EvalResult<'tcx> {\n         if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::DeallocateNonBasePtr);\n@@ -278,8 +278,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.layout.endian\n     }\n \n-    pub fn check_align(&self, ptr: PrimVal, align: u64, len: u64) -> EvalResult<'tcx> {\n-        let offset = match ptr {\n+    pub fn check_align(&self, ptr: Pointer, align: u64, len: u64) -> EvalResult<'tcx> {\n+        let offset = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n                 // check whether the memory was marked as packed\n@@ -329,7 +329,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n+    pub(crate) fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset > allocation_size {\n@@ -338,7 +338,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub(crate) fn mark_packed(&mut self, ptr: Pointer, len: u64) {\n+    pub(crate) fn mark_packed(&mut self, ptr: MemoryPointer, len: u64) {\n         self.packed.insert(Entry {\n             alloc_id: ptr.alloc_id,\n             packed_start: ptr.offset,\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.next_thread_local;\n         self.next_thread_local += 1;\n-        self.thread_local.insert(new_key, TlsEntry { data: PrimVal::Bytes(0), dtor });\n+        self.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n         return new_key;\n     }\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, PrimVal> {\n+    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n         return match self.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: PrimVal) -> EvalResult<'tcx> {\n+    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n         return match self.thread_local.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// with associated destructors, implementations may stop calling destructors,\n     /// or they may continue calling destructors until no non-NULL values with\n     /// associated destructors exist, even though this might result in an infinite loop.\n-    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, PrimVal, TlsKey)>> {\n+    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n         use std::collections::Bound::*;\n         let start = match key {\n             Some(key) => Excluded(key),\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             if !data.is_null()? {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n-                    *data = PrimVal::Bytes(0);\n+                    *data = Pointer::null();\n                     return Ok(ret);\n                 }\n             }\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: Pointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         if ptr.offset != 0 {\n             return Err(EvalError::InvalidFunctionPointer);\n         }\n@@ -571,11 +571,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Byte accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    fn get_bytes_unchecked(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes_unchecked(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n-        self.check_align(PrimVal::Ptr(ptr), align, size)?;\n+        // FIXME: check alignment for zst memory accesses?\n+        self.check_align(ptr.into(), align, size)?;\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -584,11 +585,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(&alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_unchecked_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n-        self.check_align(PrimVal::Ptr(ptr), align, size)?;\n+        // FIXME: check alignment for zst memory accesses?\n+        self.check_align(ptr.into(), align, size)?;\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -597,7 +599,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(&mut alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size, 0);\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n@@ -606,10 +608,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.get_bytes_unchecked(ptr, size, align)\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size, 0);\n         self.clear_relocations(ptr, size)?;\n-        self.mark_definedness(PrimVal::Ptr(ptr), size, true)?;\n+        self.mark_definedness(ptr.into(), size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size, align)\n     }\n }\n@@ -661,7 +663,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn copy(&mut self, src: PrimVal, dest: PrimVal, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n         if size == 0 {\n             // TODO: Should we check for alignment here? (Also see write_bytes intrinsic)\n             return Ok(());\n@@ -697,7 +699,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_c_str(&self, ptr: Pointer) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_c_str(&self, ptr: MemoryPointer) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n         let offset = ptr.offset as usize;\n@@ -713,7 +715,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_bytes(&self, ptr: PrimVal, size: u64) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n@@ -729,7 +731,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: PrimVal, val: u8, count: u64) -> EvalResult<'tcx> {\n+    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n         if count == 0 {\n             return Ok(());\n         }\n@@ -738,10 +740,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_ptr(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Pointer> {\n         let size = self.pointer_size();\n         if self.check_defined(ptr, size).is_err() {\n-            return Ok(PrimVal::Undef);\n+            return Ok(PrimVal::Undef.into());\n         }\n         let endianess = self.endianess();\n         let bytes = self.get_bytes_unchecked(ptr, size, size)?;\n@@ -750,20 +752,20 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let offset = offset as u64;\n         let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n-            Some(&alloc_id) => Ok(PrimVal::Ptr(Pointer::new(alloc_id, offset))),\n-            None => Ok(PrimVal::Bytes(offset as u128)),\n+            Some(&alloc_id) => Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, offset)).into()),\n+            None => Ok(PrimVal::Bytes(offset as u128).into()),\n         }\n     }\n \n-    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx> {\n+    pub fn write_ptr(&mut self, dest: MemoryPointer, ptr: MemoryPointer) -> EvalResult<'tcx> {\n         self.write_usize(dest, ptr.offset as u64)?;\n         self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n         Ok(())\n     }\n \n     pub fn write_primval(\n         &mut self,\n-        dest: PrimVal,\n+        dest: Pointer,\n         val: PrimVal,\n         size: u64,\n     ) -> EvalResult<'tcx> {\n@@ -791,7 +793,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {\n+    pub fn read_bool(&self, ptr: MemoryPointer) -> EvalResult<'tcx, bool> {\n         let bytes = self.get_bytes(ptr, 1, self.layout.i1_align.abi())?;\n         match bytes[0] {\n             0 => Ok(false),\n@@ -800,7 +802,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx> {\n+    pub fn write_bool(&mut self, ptr: MemoryPointer, b: bool) -> EvalResult<'tcx> {\n         let align = self.layout.i1_align.abi();\n         self.get_bytes_mut(ptr, 1, align)\n             .map(|bytes| bytes[0] = b as u8)\n@@ -817,88 +819,88 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_int(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, i128> {\n+    pub fn read_int(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, i128> {\n         let align = self.int_align(size)?;\n         self.get_bytes(ptr, size, align).map(|b| read_target_int(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_int(&mut self, ptr: Pointer, n: i128, size: u64) -> EvalResult<'tcx> {\n+    pub fn write_int(&mut self, ptr: MemoryPointer, n: i128, size: u64) -> EvalResult<'tcx> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_int(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_uint(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, u128> {\n+    pub fn read_uint(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, u128> {\n         let align = self.int_align(size)?;\n         self.get_bytes(ptr, size, align).map(|b| read_target_uint(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_uint(&mut self, ptr: Pointer, n: u128, size: u64) -> EvalResult<'tcx> {\n+    pub fn write_uint(&mut self, ptr: MemoryPointer, n: u128, size: u64) -> EvalResult<'tcx> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_uint(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_isize(&self, ptr: Pointer) -> EvalResult<'tcx, i64> {\n+    pub fn read_isize(&self, ptr: MemoryPointer) -> EvalResult<'tcx, i64> {\n         self.read_int(ptr, self.pointer_size()).map(|i| i as i64)\n     }\n \n-    pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<'tcx> {\n+    pub fn write_isize(&mut self, ptr: MemoryPointer, n: i64) -> EvalResult<'tcx> {\n         let size = self.pointer_size();\n         self.write_int(ptr, n as i128, size)\n     }\n \n-    pub fn read_usize(&self, ptr: Pointer) -> EvalResult<'tcx, u64> {\n+    pub fn read_usize(&self, ptr: MemoryPointer) -> EvalResult<'tcx, u64> {\n         self.read_uint(ptr, self.pointer_size()).map(|i| i as u64)\n     }\n \n-    pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<'tcx> {\n+    pub fn write_usize(&mut self, ptr: MemoryPointer, n: u64) -> EvalResult<'tcx> {\n         let size = self.pointer_size();\n         self.write_uint(ptr, n as u128, size)\n     }\n \n-    pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx> {\n+    pub fn write_f32(&mut self, ptr: MemoryPointer, f: f32) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n         let align = self.layout.f32_align.abi();\n         let b = self.get_bytes_mut(ptr, 4, align)?;\n         write_target_f32(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n-    pub fn write_f64(&mut self, ptr: Pointer, f: f64) -> EvalResult<'tcx> {\n+    pub fn write_f64(&mut self, ptr: MemoryPointer, f: f64) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n         let align = self.layout.f64_align.abi();\n         let b = self.get_bytes_mut(ptr, 8, align)?;\n         write_target_f64(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_f32(&self, ptr: Pointer) -> EvalResult<'tcx, f32> {\n+    pub fn read_f32(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f32> {\n         self.get_bytes(ptr, 4, self.layout.f32_align.abi())\n             .map(|b| read_target_f32(self.endianess(), b).unwrap())\n     }\n \n-    pub fn read_f64(&self, ptr: Pointer) -> EvalResult<'tcx, f64> {\n+    pub fn read_f64(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f64> {\n         self.get_bytes(ptr, 8, self.layout.f64_align.abi())\n             .map(|b| read_target_f64(self.endianess(), b).unwrap())\n     }\n }\n \n /// Relocations\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    fn relocations(&self, ptr: Pointer, size: u64)\n+    fn relocations(&self, ptr: MemoryPointer, size: u64)\n         -> EvalResult<'tcx, btree_map::Range<u64, AllocId>>\n     {\n         let start = ptr.offset.saturating_sub(self.pointer_size() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(start..end))\n     }\n \n-    fn clear_relocations(&mut self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn clear_relocations(&mut self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         // Find all relocations overlapping the given range.\n         let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n         if keys.is_empty() { return Ok(()); }\n@@ -922,7 +924,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn check_relocation_edges(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n         let overlapping_end = self.relocations(ptr.offset(size, self.layout)?, 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n@@ -931,7 +933,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn copy_relocations(&mut self, src: MemoryPointer, dest: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         let relocations: Vec<_> = self.relocations(src, size)?\n             .map(|(&offset, &alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n@@ -946,7 +948,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Undefined bytes\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     // FIXME(solson): This is a very naive, slow version.\n-    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn copy_undef_mask(&mut self, src: MemoryPointer, dest: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size as usize as u64, size);\n         let mut v = Vec::with_capacity(size as usize);\n@@ -960,7 +962,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn check_defined(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n             return Err(EvalError::ReadUndefBytes);\n@@ -970,7 +972,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: PrimVal,\n+        ptr: Pointer,\n         size: u64,\n         new_state: bool\n     ) -> EvalResult<'tcx> {"}, {"sha": "47bd66641b1e8752d94beda2c69d7f4aca7b01e7", "filename": "src/operator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n-use memory::Pointer;\n+use memory::MemoryPointer;\n use lvalue::Lvalue;\n use value::{\n     PrimVal,\n@@ -158,8 +158,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             match bin_op {\n                 Offset if left_kind == Ptr && right_kind == usize => {\n                     let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                    let ptr = self.pointer_offset(left, pointee_ty, right.to_bytes()? as i64)?;\n-                    return Ok((ptr, false));\n+                    let ptr = self.pointer_offset(left.into(), pointee_ty, right.to_bytes()? as i64)?;\n+                    return Ok((ptr.into_inner_primval(), false));\n                 },\n                 // These work on anything\n                 Eq if left_kind == right_kind => {\n@@ -297,13 +297,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer,\n+        left: MemoryPointer,\n         right: i128,\n         signed: bool,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        fn map_to_primval((res, over) : (Pointer, bool)) -> (PrimVal, bool) {\n+        fn map_to_primval((res, over) : (MemoryPointer, bool)) -> (PrimVal, bool) {\n             (PrimVal::Ptr(res), over)\n         }\n \n@@ -321,7 +321,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let right = right as u64;\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (PrimVal::Ptr(Pointer::new(left.alloc_id, left.offset & right)), false)\n+                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n                     (PrimVal::from_u128((left.offset & right) as u128), false)"}, {"sha": "77d0f962c9645466a53503d8d881de3b97c563d7", "filename": "src/step.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -99,9 +99,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     Layout::RawNullablePointer { nndiscr, .. } => {\n-                        use value::PrimVal;\n                         if variant_index as u64 != nndiscr {\n-                            self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                            self.write_null(dest, dest_ty)?;\n                         }\n                     }\n "}, {"sha": "f69f99f3d28c46369d9aecc0ac67cae0413ed81d", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -12,9 +12,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         let val = match self.force_allocation(lval)? {\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => Value::ByValPair(ptr, PrimVal::Ptr(vtable)),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => Value::ByValPair(ptr, PrimVal::Bytes(len as u128)),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => Value::ByVal(ptr),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => ptr.to_value_with_vtable(vtable),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => ptr.to_value_with_len(len),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span)"}, {"sha": "94c1bac459d6e55765ec9b4ffa00108faf2d2751", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{self, Ty};\n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n use lvalue::{Lvalue, LvalueExtra};\n-use value::{PrimVal, PrimValKind, Value};\n+use value::{PrimVal, PrimValKind, Value, Pointer};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n@@ -46,7 +46,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n-                self.write_primval(dest, result_ptr, dest_ty)?;\n+                self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n \n             \"assume\" => {\n@@ -257,8 +257,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n                             Err(_) => {\n                                 let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n-                                this.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n-                                Value::ByRef(PrimVal::Ptr(ptr))\n+                                let ptr = Pointer::from(PrimVal::Ptr(ptr));\n+                                this.memory.write_repeat(ptr, 0, size)?;\n+                                Value::ByRef(ptr)\n                             }\n                         },\n                         Value::ByVal(_) => Value::ByVal(PrimVal::Bytes(0)),\n@@ -307,7 +308,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n-                self.write_primval(dest, result_ptr, dest_ty)?;\n+                self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n \n             \"overflowing_sub\" => {\n@@ -397,7 +398,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.type_size(dest_ty)?.expect(\"transmute() type must be sized\");\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n                 self.memory.mark_packed(ptr, size);\n-                self.write_value_to_ptr(arg_vals[0], PrimVal::Ptr(ptr), src_ty)?;\n+                self.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)?;\n             }\n \n             \"unchecked_shl\" => {"}, {"sha": "9602e5798a7bc439d74eb20e2d2f7c38242e14d5", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -9,9 +9,8 @@ use syntax::abi::Abi;\n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{Pointer, TlsKey};\n-use value::PrimVal;\n-use value::Value;\n+use memory::{MemoryPointer, TlsKey};\n+use value::{PrimVal, Value};\n use rustc_data_structures::indexed_vec::Idx;\n \n mod drop;\n@@ -461,7 +460,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(false)\n     }\n \n-    pub fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n+    pub fn read_discriminant_value(&self, adt_ptr: MemoryPointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;\n         trace!(\"read_discriminant_value {:#?}\", adt_layout);\n@@ -500,7 +499,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(discr_val)\n     }\n \n-    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u128, discr_size: u64) -> EvalResult<'tcx, u128> {\n+    fn read_nonnull_discriminant_value(&self, ptr: MemoryPointer, nndiscr: u128, discr_size: u64) -> EvalResult<'tcx, u128> {\n         trace!(\"read_nonnull_discriminant_value: {:?}, {}, {}\", ptr, nndiscr, discr_size);\n         let not_null = match self.memory.read_uint(ptr, discr_size) {\n             Ok(0) => false,\n@@ -569,7 +568,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = self.memory.allocate(size, align)?;\n-                self.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n+                self.memory.write_repeat(ptr.into(), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_dealloc\" => {\n@@ -652,7 +651,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"malloc\" => {\n                 let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n                 if size == 0 {\n-                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                    self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.memory.pointer_size();\n                     let ptr = self.memory.allocate(size, align)?;\n@@ -690,7 +689,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let f = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let data = args[1].read_ptr(&self.memory)?;\n                 let f_instance = self.memory.get_fn(f)?;\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                self.write_null(dest, dest_ty)?;\n \n                 // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n                 // and of course eval_main.\n@@ -705,10 +704,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n                 let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                self.write_primval(arg_dest, data, u8_ptr_ty)?;\n+                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n \n                 // We ourselves return 0\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                self.write_null(dest, dest_ty)?;\n \n                 // Don't fall through\n                 return Ok(());\n@@ -744,9 +743,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(num - idx as u64 - 1, self.memory.layout)?;\n-                    self.write_primval(dest, new_ptr, dest_ty)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n-                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                    self.write_null(dest, dest_ty)?;\n                 }\n             }\n \n@@ -756,9 +755,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(idx as u64, self.memory.layout)?;\n-                    self.write_primval(dest, new_ptr, dest_ty)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n-                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                    self.write_null(dest, dest_ty)?;\n                 }\n             }\n \n@@ -789,7 +788,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     if let Some(var) = old {\n                         self.memory.deallocate(var, None)?;\n                     }\n-                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                    self.write_null(dest, dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n                 }\n@@ -816,7 +815,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n                         self.memory.deallocate(var, None)?;\n                     }\n-                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                    self.write_null(dest, dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n                 }\n@@ -865,15 +864,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"mmap\" => {\n                 // This is a horrible hack, but well... the guard page mechanism calls mmap and expects a particular return value, so we give it that value\n                 let addr = args[0].read_ptr(&self.memory)?;\n-                self.write_primval(dest, addr, dest_ty)?;\n+                self.write_ptr(dest, addr, dest_ty)?;\n             }\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n                 let key_ptr = args[0].read_ptr(&self.memory)?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].read_ptr(&self.memory)? {\n+                let dtor = match args[1].read_ptr(&self.memory)?.into_inner_primval() {\n                     PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n                     PrimVal::Bytes(0) => None,\n                     PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n@@ -897,20 +896,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n \n                 // Return success (0)\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                self.write_null(dest, dest_ty)?;\n             }\n             \"pthread_key_delete\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n                 self.memory.delete_tls_key(key)?;\n                 // Return success (0)\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                self.write_null(dest, dest_ty)?;\n             }\n             \"pthread_getspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n                 let ptr = self.memory.load_tls(key)?;\n-                self.write_primval(dest, ptr, dest_ty)?;\n+                self.write_ptr(dest, ptr, dest_ty)?;\n             }\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n@@ -919,13 +918,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.store_tls(key, new_ptr)?;\n                 \n                 // Return success (0)\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                self.write_null(dest, dest_ty)?;\n             }\n \n             // Stub out all the other pthread calls to just return 0\n             link_name if link_name.starts_with(\"pthread_\") => {\n                 warn!(\"ignoring C ABI call: {}\", link_name);\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                self.write_null(dest, dest_ty)?;\n             },\n \n             _ => {"}, {"sha": "bfb923510bbb368f96ec185f92e919bf0a4bf359", "filename": "src/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -1,7 +1,7 @@\n use rustc::traits::{self, Reveal};\n \n use eval_context::EvalContext;\n-use memory::Pointer;\n+use memory::MemoryPointer;\n use value::{Value, PrimVal};\n \n use rustc::hir::def_id::DefId;\n@@ -43,7 +43,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// The `trait_ref` encodes the erased self type. Hence if we are\n     /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n     /// `trait_ref` would map `T:Trait`.\n-    pub fn get_vtable(&mut self, ty: Ty<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub fn get_vtable(&mut self, ty: Ty<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n         let size = self.type_size(trait_ref.self_ty())?.expect(\"can't create a vtable for an unsized type\");\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(vtable)\n     }\n \n-    pub fn read_drop_type_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n+    pub fn read_drop_type_from_vtable(&self, vtable: MemoryPointer) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         // we don't care about the pointee type, we just want a pointer\n         match self.read_ptr(vtable, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_size_and_align_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, (u64, u64)> {\n+    pub fn read_size_and_align_from_vtable(&self, vtable: MemoryPointer) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n         let size = self.memory.read_usize(vtable.offset(pointer_size, self.memory.layout)?)?;\n         let align = self.memory.read_usize(vtable.offset(pointer_size * 2, self.memory.layout)?)?;"}, {"sha": "4bda56a2877f999a1f0737507da611320328a081", "filename": "src/value.rs", "status": "modified", "additions": 100, "deletions": 52, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40755ecfb78033d28020a75df8f50d084d810cc3/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=40755ecfb78033d28020a75df8f50d084d810cc3", "patch": "@@ -5,7 +5,7 @@ use std::mem::transmute;\n use rustc::ty::layout::TargetDataLayout;\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer};\n+use memory::{Memory, MemoryPointer};\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n     unsafe { transmute::<u32, f32>(bytes as u32) }\n@@ -33,11 +33,100 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef(PrimVal),\n+    ByRef(Pointer),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n \n+/// A wrapper type around `PrimVal` that cannot be turned back into a `PrimVal` accidentally.\n+/// This type clears up a few APIs where having a `PrimVal` argument for something that is\n+/// potentially an integer pointer or a pointer to an allocation was unclear.\n+///\n+/// I (@oli-obk) believe it is less easy to mix up generic primvals and primvals that are just\n+/// the representation of pointers. Also all the sites that convert between primvals and pointers\n+/// are explicit now (and rare!)\n+#[derive(Clone, Copy, Debug)]\n+pub struct Pointer {\n+    primval: PrimVal,\n+}\n+\n+impl<'tcx> Pointer {\n+    pub fn null() -> Self {\n+        PrimVal::Bytes(0).into()\n+    }\n+    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n+        self.primval.to_ptr()\n+    }\n+    pub fn into_inner_primval(self) -> PrimVal {\n+        self.primval\n+    }\n+\n+    pub(crate) fn signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        match self.primval {\n+            PrimVal::Bytes(b) => {\n+                assert_eq!(b as u64 as u128, b);\n+                Ok(Pointer::from(PrimVal::Bytes(signed_offset(b as u64, i, layout)? as u128)))\n+            },\n+            PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n+    }\n+\n+    pub(crate) fn offset(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        match self.primval {\n+            PrimVal::Bytes(b) => {\n+                assert_eq!(b as u64 as u128, b);\n+                Ok(Pointer::from(PrimVal::Bytes(offset(b as u64, i, layout)? as u128)))\n+            },\n+            PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n+    }\n+\n+    pub(crate) fn wrapping_signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        match self.primval {\n+            PrimVal::Bytes(b) => {\n+                assert_eq!(b as u64 as u128, b);\n+                Ok(Pointer::from(PrimVal::Bytes(wrapping_signed_offset(b as u64, i, layout) as u128)))\n+            },\n+            PrimVal::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n+    }\n+\n+    pub fn is_null(self) -> EvalResult<'tcx, bool> {\n+        match self.primval {\n+            PrimVal::Bytes(b) => Ok(b == 0),\n+            PrimVal::Ptr(_) => Ok(false),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n+    }\n+\n+    pub fn to_value_with_len(self, len: u64) -> Value {\n+        Value::ByValPair(self.primval, PrimVal::from_u128(len as u128))\n+    }\n+\n+    pub fn to_value_with_vtable(self, vtable: MemoryPointer) -> Value {\n+        Value::ByValPair(self.primval, PrimVal::Ptr(vtable))\n+    }\n+\n+    pub fn to_value(self) -> Value {\n+        Value::ByVal(self.primval)\n+    }\n+}\n+\n+impl ::std::convert::From<PrimVal> for Pointer {\n+    fn from(primval: PrimVal) -> Self {\n+        Pointer { primval }\n+    }\n+}\n+\n+impl ::std::convert::From<MemoryPointer> for Pointer {\n+    fn from(ptr: MemoryPointer) -> Self {\n+        PrimVal::Ptr(ptr).into()\n+    }\n+}\n+\n /// A `PrimVal` represents an immediate, primitive value existing outside of a\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n@@ -49,8 +138,8 @@ pub enum PrimVal {\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `PrimVal` is only large enough to contain one, so we just represent the\n-    /// relocation and its associated offset together as a `Pointer` here.\n-    Ptr(Pointer),\n+    /// relocation and its associated offset together as a `MemoryPointer` here.\n+    Ptr(MemoryPointer),\n \n     /// An undefined `PrimVal`, for representing values that aren't safe to examine, but are safe\n     /// to copy around, just like undefined bytes in an `Allocation`.\n@@ -69,18 +158,18 @@ pub enum PrimValKind {\n }\n \n impl<'a, 'tcx: 'a> Value {\n-    pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr.to_ptr()?),\n-            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr),\n+            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n         }\n     }\n \n     pub(super) fn expect_ptr_vtable_pair(\n         &self,\n         mem: &Memory<'a, 'tcx>\n-    ) -> EvalResult<'tcx, (PrimVal, Pointer)> {\n+    ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n@@ -89,13 +178,13 @@ impl<'a, 'tcx: 'a> Value {\n                 Ok((ptr, vtable.to_ptr()?))\n             }\n \n-            ByValPair(ptr, vtable) => Ok((ptr, vtable.to_ptr()?)),\n+            ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n \n             _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n         }\n     }\n \n-    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (PrimVal, u64)> {\n+    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n@@ -106,7 +195,7 @@ impl<'a, 'tcx: 'a> Value {\n             ByValPair(ptr, val) => {\n                 let len = val.to_u128()?;\n                 assert_eq!(len as u64 as u128, len);\n-                Ok((ptr, len as u64))\n+                Ok((ptr.into(), len as u64))\n             },\n             ByVal(_) => unimplemented!(),\n         }\n@@ -146,7 +235,7 @@ impl<'tcx> PrimVal {\n         }\n     }\n \n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         match self {\n             PrimVal::Bytes(_) => Err(EvalError::ReadBytesAsPointer),\n             PrimVal::Ptr(p) => Ok(p),\n@@ -219,47 +308,6 @@ impl<'tcx> PrimVal {\n             _ => Err(EvalError::InvalidBool),\n         }\n     }\n-\n-    pub fn is_null(self) -> EvalResult<'tcx, bool> {\n-        match self {\n-            PrimVal::Bytes(b) => Ok(b == 0),\n-            PrimVal::Ptr(_) => Ok(false),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n-        }\n-    }\n-\n-    pub fn signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        match self {\n-            PrimVal::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(PrimVal::Bytes(signed_offset(b as u64, i, layout)? as u128))\n-            },\n-            PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(PrimVal::Ptr),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n-        }\n-    }\n-\n-    pub fn offset(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        match self {\n-            PrimVal::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(PrimVal::Bytes(offset(b as u64, i, layout)? as u128))\n-            },\n-            PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(PrimVal::Ptr),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n-        }\n-    }\n-\n-    pub fn wrapping_signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        match self {\n-            PrimVal::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(PrimVal::Bytes(wrapping_signed_offset(b as u64, i, layout) as u128))\n-            },\n-            PrimVal::Ptr(ptr) => Ok(PrimVal::Ptr(ptr.wrapping_signed_offset(i, layout))),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n-        }\n-    }\n }\n \n // Overflow checking only works properly on the range from -u64 to +u64."}]}