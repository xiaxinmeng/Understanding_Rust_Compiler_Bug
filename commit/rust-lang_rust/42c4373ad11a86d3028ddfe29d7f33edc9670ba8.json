{"sha": "42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "node_id": "C_kwDOAAsO6NoAKDQyYzQzNzNhZDExYTg2ZDMwMjhkZGZlMjlkN2YzM2VkYzk2NzBiYTg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-02T22:55:37Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-12T23:05:55Z"}, "message": "Make note_source_of_type_mismatch_constraint simpler", "tree": {"sha": "001a0137735c986ff17ee6acedde19a4e5724f1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/001a0137735c986ff17ee6acedde19a4e5724f1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "html_url": "https://github.com/rust-lang/rust/commit/42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4087deaccd8bceb458c9610d29744d5f3504c5c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4087deaccd8bceb458c9610d29744d5f3504c5c0", "html_url": "https://github.com/rust-lang/rust/commit/4087deaccd8bceb458c9610d29744d5f3504c5c0"}], "stats": {"total": 335, "additions": 94, "deletions": 241}, "files": [{"sha": "0c4f73e0db0eb8978cee18a11e9f1d1d2683e680", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 81, "deletions": 195, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -1,6 +1,5 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -13,15 +12,13 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::fold::{BottomUpFolder, TypeFolder};\n-use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n-use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitableExt};\n+use rustc_middle::ty::fold::BottomUpFolder;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n@@ -62,9 +59,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_into(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected)\n             || self.suggest_null_ptr_for_literal_zero_given_to_ptr_arg(err, expr, expected)\n-            || self.note_result_coercion(err, expr, expected, expr_ty);\n+            || self.suggest_coercing_result_via_try_operator(err, expr, expected, expr_ty);\n+\n         if !suggested {\n-            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected, expr.span);\n+            self.note_source_of_type_mismatch_constraint(err, expr, expected);\n         }\n     }\n \n@@ -218,37 +216,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n-    pub fn point_at_expr_source_of_inferred_type(\n+    /// Notes the point at which a variable is constrained to some type incompatible\n+    /// with `expected_ty`.\n+    pub fn note_source_of_type_mismatch_constraint(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        found: Ty<'tcx>,\n-        expected: Ty<'tcx>,\n-        mismatch_span: Span,\n+        expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        let map = self.tcx.hir();\n+        let hir = self.tcx.hir();\n \n         let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n         let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n-        let hir::def::Res::Local(hir_id) = p.res else { return false; };\n-        let Some(hir::Node::Pat(pat)) = map.find(hir_id) else { return false; };\n-        let Some(hir::Node::Local(hir::Local {\n-            ty: None,\n-            init: Some(init),\n-            ..\n-        })) = map.find_parent(pat.hir_id) else { return false; };\n-        let Some(ty) = self.node_ty_opt(init.hir_id) else { return false; };\n-        if ty.is_closure() || init.span.overlaps(expr.span) || pat.span.from_expansion() {\n-            return false;\n-        }\n+        let hir::def::Res::Local(local_hir_id) = p.res else { return false; };\n+        let hir::Node::Pat(pat) = hir.get(local_hir_id) else { return false; };\n+        let (init_ty_hir_id, init) = match hir.get_parent(pat.hir_id) {\n+            hir::Node::Local(hir::Local { ty: Some(ty), init, .. }) => (ty.hir_id, *init),\n+            hir::Node::Local(hir::Local { init: Some(init), .. }) => (init.hir_id, Some(*init)),\n+            _ => return false,\n+        };\n+        let Some(init_ty) = self.node_ty_opt(init_ty_hir_id) else { return false; };\n \n         // Locate all the usages of the relevant binding.\n-        struct FindExprs<'hir> {\n+        struct FindExprs<'tcx> {\n             hir_id: hir::HirId,\n-            uses: Vec<&'hir hir::Expr<'hir>>,\n+            uses: Vec<&'tcx hir::Expr<'tcx>>,\n         }\n-        impl<'v> Visitor<'v> for FindExprs<'v> {\n-            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        impl<'tcx> Visitor<'tcx> for FindExprs<'tcx> {\n+            fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n                 if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = ex.kind\n                     && let hir::def::Res::Local(hir_id) = path.res\n                     && hir_id == self.hir_id\n@@ -259,180 +254,71 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let mut expr_finder = FindExprs { hir_id, uses: vec![] };\n-        let id = map.get_parent_item(hir_id);\n-        let hir_id: hir::HirId = id.into();\n-\n-        let Some(node) = map.find(hir_id) else { return false; };\n-        let Some(body_id) = node.body_id() else { return false; };\n-        let body = map.body(body_id);\n+        let mut expr_finder = FindExprs { hir_id: local_hir_id, uses: init.into_iter().collect() };\n+        let body =\n+            hir.body(hir.maybe_body_owned_by(self.body_id).expect(\"expected item to have body\"));\n         expr_finder.visit_expr(body.value);\n-        // Hack to make equality checks on types with inference variables and regions useful.\n-        let mut eraser = BottomUpFolder {\n-            tcx: self.tcx,\n-            lt_op: |_| self.tcx.lifetimes.re_erased,\n-            ct_op: |c| c,\n-            ty_op: |t| match *t.kind() {\n-                ty::Infer(ty::TyVar(_)) => self.tcx.mk_ty_var(ty::TyVid::from_u32(0)),\n-                ty::Infer(ty::IntVar(_)) => self.tcx.mk_int_var(ty::IntVid { index: 0 }),\n-                ty::Infer(ty::FloatVar(_)) => self.tcx.mk_float_var(ty::FloatVid { index: 0 }),\n-                _ => t,\n-            },\n-        };\n-        let mut prev = eraser.fold_ty(ty);\n-        let mut prev_span: Option<Span> = None;\n-\n-        for binding in expr_finder.uses {\n-            // In every expression where the binding is referenced, we will look at that\n-            // expression's type and see if it is where the incorrect found type was fully\n-            // \"materialized\" and point at it. We will also try to provide a suggestion there.\n-            if let Some(hir::Node::Expr(expr)\n-            | hir::Node::Stmt(hir::Stmt {\n-                kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n-                ..\n-            })) = &map.find_parent(binding.hir_id)\n-                && let hir::ExprKind::MethodCall(segment, rcvr, args, _span) = expr.kind\n-                && rcvr.hir_id == binding.hir_id\n-                && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n-            {\n-                // We special case methods, because they can influence inference through the\n-                // call's arguments and we can provide a more explicit span.\n-                let sig = self.tcx.fn_sig(def_id).subst_identity();\n-                let def_self_ty = sig.input(0).skip_binder();\n-                let param_tys = sig.inputs().skip_binder().iter().skip(1);\n-                // If there's an arity mismatch, pointing out the call as the source of an inference\n-                // can be misleading, so we skip it.\n-                if param_tys.len() != args.len() {\n-                    continue;\n-                }\n-                let rcvr_ty = self.node_ty(rcvr.hir_id);\n-                // Get the evaluated type *after* calling the method call, so that the influence\n-                // of the arguments can be reflected in the receiver type. The receiver\n-                // expression has the type *before* this analysis is done.\n-                let ty = match self.lookup_probe_for_diagnostic(\n-                    segment.ident,\n-                    rcvr_ty,\n-                    expr,\n-                    probe::ProbeScope::TraitsInScope,\n-                    None,\n-                ) {\n-                    Ok(pick) => eraser.fold_ty(pick.self_ty),\n-                    Err(_) => rcvr_ty,\n-                };\n-                // Remove one layer of references to account for `&mut self` and\n-                // `&self`, so that we can compare it against the binding.\n-                let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n-                    (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n-                    _ => (ty, def_self_ty),\n-                };\n-                let mut param_args = FxHashMap::default();\n-                let mut param_expected = FxHashMap::default();\n-                let mut param_found = FxHashMap::default();\n-                if self.can_eq(self.param_env, ty, found) {\n-                    // We only point at the first place where the found type was inferred.\n-                    for (param_ty, arg) in param_tys.zip(args) {\n-                        if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n-                            // We found an argument that references a type parameter in `Self`,\n-                            // so we assume that this is the argument that caused the found\n-                            // type, which we know already because of `can_eq` above was first\n-                            // inferred in this method call.\n-                            let arg_ty = self.node_ty(arg.hir_id);\n-                            if !arg.span.overlaps(mismatch_span) {\n-                                err.span_label(\n-                                    arg.span,\n-                                    &format!(\n-                                        \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n-                                        inferred as `{ty}`\",\n-                                    ),\n-                                );\n-                            }\n-                            param_args.insert(param_ty, (arg, arg_ty));\n-                        }\n-                    }\n-                }\n \n-                // Here we find, for a type param `T`, the type that `T` is in the current\n-                // method call *and* in the original expected type. That way, we can see if we\n-                // can give any structured suggestion for the function argument.\n-                let mut c = CollectAllMismatches {\n-                    infcx: &self.infcx,\n-                    param_env: self.param_env,\n-                    errors: vec![],\n-                };\n-                let _ = c.relate(def_self_ty, ty);\n-                for error in c.errors {\n-                    if let TypeError::Sorts(error) = error {\n-                        param_found.insert(error.expected, error.found);\n+        let fudge_equals_found_ty = |use_ty: Ty<'tcx>| {\n+            use rustc_infer::infer::type_variable::*;\n+            use rustc_middle::infer::unify_key::*;\n+            let use_ty = use_ty.fold_with(&mut BottomUpFolder {\n+                tcx: self.tcx,\n+                ty_op: |ty| {\n+                    if let ty::Infer(infer) = ty.kind() {\n+                        match infer {\n+                            ty::InferTy::TyVar(_) => self.next_ty_var(TypeVariableOrigin {\n+                                kind: TypeVariableOriginKind::MiscVariable,\n+                                span: DUMMY_SP,\n+                            }),\n+                            ty::InferTy::IntVar(_) => self.next_int_var(),\n+                            ty::InferTy::FloatVar(_) => self.next_float_var(),\n+                            _ => bug!(),\n+                        }\n+                    } else {\n+                        ty\n                     }\n-                }\n-                c.errors = vec![];\n-                let _ = c.relate(def_self_ty, expected);\n-                for error in c.errors {\n-                    if let TypeError::Sorts(error) = error {\n-                        param_expected.insert(error.expected, error.found);\n+                },\n+                lt_op: |_| self.tcx.lifetimes.re_erased,\n+                ct_op: |ct| {\n+                    if let ty::ConstKind::Infer(_) = ct.kind() {\n+                        self.next_const_var(\n+                            ct.ty(),\n+                            ConstVariableOrigin {\n+                                kind: ConstVariableOriginKind::MiscVariable,\n+                                span: DUMMY_SP,\n+                            },\n+                        )\n+                    } else {\n+                        ct\n                     }\n-                }\n-                for (param, (arg, arg_ty)) in param_args.iter() {\n-                    let Some(expected) = param_expected.get(param) else { continue; };\n-                    let Some(found) = param_found.get(param) else { continue; };\n-                    if !self.can_eq(self.param_env, *arg_ty, *found) { continue; }\n-                    self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n-                }\n+                },\n+            });\n+            self.can_eq(self.param_env, expected_ty, use_ty)\n+        };\n \n-                let ty = eraser.fold_ty(ty);\n-                if ty.references_error() {\n-                    break;\n-                }\n-                if ty != prev\n-                    && param_args.is_empty()\n-                    && self.can_eq(self.param_env, ty, found)\n-                {\n-                    // We only point at the first place where the found type was inferred.\n-                    if !segment.ident.span.overlaps(mismatch_span) {\n-                    err.span_label(\n-                        segment.ident.span,\n-                        with_forced_trimmed_paths!(format!(\n-                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                        )),\n-                    );}\n-                    break;\n-                } else if !param_args.is_empty() {\n-                    break;\n-                }\n-                prev = ty;\n-            } else {\n-                let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n-                if ty.references_error() {\n-                    break;\n-                }\n-                if ty != prev\n-                    && let Some(span) = prev_span\n-                    && self.can_eq(self.param_env, ty, found)\n-                {\n-                    // We only point at the first place where the found type was inferred.\n-                    // We use the *previous* span because if the type is known *here* it means\n-                    // it was *evaluated earlier*. We don't do this for method calls because we\n-                    // evaluate the method's self type eagerly, but not in any other case.\n-                    if !span.overlaps(mismatch_span) {\n-                        err.span_label(\n-                            span,\n-                            with_forced_trimmed_paths!(format!(\n-                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                            )),\n-                        );\n-                    }\n-                    break;\n-                }\n-                prev = ty;\n+        if !fudge_equals_found_ty(init_ty) {\n+            return false;\n+        }\n+\n+        for window in expr_finder.uses.windows(2) {\n+            let [binding, next_usage] = *window else { continue; };\n+            let Some(next_use_ty) = self.node_ty_opt(next_usage.hir_id) else { continue; };\n+            if !fudge_equals_found_ty(next_use_ty) {\n+                err.span_label(\n+                    binding.span,\n+                    format!(\"here the type of `{ident}` is inferred to be `{next_use_ty}`\"),\n+                );\n+                return true;\n             }\n-            if binding.hir_id == expr.hir_id {\n-                // Do not look at expressions that come after the expression we were originally\n-                // evaluating and had a type error.\n+\n+            if next_usage.hir_id == expr.hir_id {\n                 break;\n             }\n-            prev_span = Some(binding.span);\n         }\n-        true\n+\n+        // We must've not found something that constrained the expr.\n+        false\n     }\n \n     fn annotate_expected_due_to_let_ty(\n@@ -708,7 +594,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    pub(crate) fn note_result_coercion(\n+    pub(crate) fn suggest_coercing_result_via_try_operator(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,"}, {"sha": "d98e0d9096f530e20e6cc783561333e54c929e58", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -807,24 +807,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 full_call_span,\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n-            if let (Some(callee_ty), hir::ExprKind::MethodCall(_, rcvr, _, _)) =\n-                (callee_ty, &call_expr.kind)\n-            {\n-                // Type that would have accepted this argument if it hadn't been inferred earlier.\n-                // FIXME: We leave an inference variable for now, but it'd be nice to get a more\n-                // specific type to increase the accuracy of the diagnostic.\n-                let expected = self.infcx.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::MiscVariable,\n-                    span: full_call_span,\n-                });\n-                self.point_at_expr_source_of_inferred_type(\n-                    &mut err,\n-                    rcvr,\n-                    expected,\n-                    callee_ty,\n-                    provided_arg_span,\n-                );\n-            }\n+\n+            // TODO: We would like to point out when the rcvr was constrained\n+            // such that the arg mismatch occurs.\n+\n             // Call out where the function is defined\n             self.label_fn_like(\n                 &mut err,"}, {"sha": "9f4558adab150708696dc1aba163bd6cdbacca3d", "filename": "tests/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -67,9 +67,6 @@ LL |             x == 5\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:18\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x = x && x == x {\n    |        ------    ^ expected `bool`, found `usize`\n    |        |\n@@ -78,9 +75,6 @@ LL |     if x == x && x = x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:22\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x = x && x == x {\n    |                      ^ expected `bool`, found `usize`\n \n@@ -98,9 +92,6 @@ LL |     if x == x && x == x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:51:28\n    |\n-LL |     if y = (Foo { foo: x }) {\n-   |                        - here the type of `x` is inferred to be `usize`\n-...\n LL |     if x == x && x == x && x = x {\n    |        ----------------    ^ expected `bool`, found `usize`\n    |        |"}, {"sha": "9c93063e04ae2f79a40ec38412a9a91807838a07", "filename": "tests/ui/type/type-check/point-at-inference-3.fixed", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -2,7 +2,6 @@\n fn main() {\n     let mut v = Vec::new();\n     v.push(0i32);\n-    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n     v.push(0);\n     v.push(1i32); //~ ERROR mismatched types\n     //~^ NOTE expected `i32`, found `u32`"}, {"sha": "8bb1487420baa6f4044812a5c465c9cad8db033f", "filename": "tests/ui/type/type-check/point-at-inference-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -2,7 +2,6 @@\n fn main() {\n     let mut v = Vec::new();\n     v.push(0i32);\n-    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n     v.push(0);\n     v.push(1u32); //~ ERROR mismatched types\n     //~^ NOTE expected `i32`, found `u32`"}, {"sha": "32663bd632e12fc8dcb93ce50cf746ece8cde324", "filename": "tests/ui/type/type-check/point-at-inference-3.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -1,9 +1,6 @@\n error[E0308]: mismatched types\n-  --> $DIR/point-at-inference-3.rs:7:12\n+  --> $DIR/point-at-inference-3.rs:6:12\n    |\n-LL |     v.push(0i32);\n-   |            ---- this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n-...\n LL |     v.push(1u32);\n    |       ---- ^^^^ expected `i32`, found `u32`\n    |       |"}, {"sha": "7c25b91fd89e9fcea7299d39e78ef16fa0b344d2", "filename": "tests/ui/type/type-check/point-at-inference-4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -11,6 +11,7 @@ fn main() {\n     let s = S(None);\n     s.infer(0i32);\n     //~^ ERROR this method takes 2 arguments but 1 argument was supplied\n+    //~| NOTE here the type of `s` is inferred to be `S<i32, _>`\n     //~| NOTE an argument is missing\n     //~| HELP provide the argument\n     let t: S<u32, _> = s;"}, {"sha": "6181af70c8ed4b03b1b805165805d54156a8d02d", "filename": "tests/ui/type/type-check/point-at-inference-4.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -15,8 +15,11 @@ LL |     s.infer(0i32, /* b */);\n    |            ~~~~~~~~~~~~~~~\n \n error[E0308]: mismatched types\n-  --> $DIR/point-at-inference-4.rs:16:24\n+  --> $DIR/point-at-inference-4.rs:17:24\n    |\n+LL |     s.infer(0i32);\n+   |     - here the type of `s` is inferred to be `S<i32, _>`\n+...\n LL |     let t: S<u32, _> = s;\n    |            ---------   ^ expected `S<u32, _>`, found `S<i32, _>`\n    |            |"}, {"sha": "6419e42e70d12512c8bab82eac5d40f5f6a79e7a", "filename": "tests/ui/type/type-check/point-at-inference.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     let mut foo = vec![];\n     baz(&foo);\n     for i in &v {\n-        foo.push(*i);\n+        foo.push(i);\n     }\n     baz(&foo);\n     bar(foo); //~ ERROR E0308"}, {"sha": "89c4cd1c37632bb20423a9f8d41fc98f9f804b03", "filename": "tests/ui/type/type-check/point-at-inference.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/point-at-inference.rs:12:9\n    |\n LL |         foo.push(i);\n-   |                  - this is of type `&{integer}`, which causes `foo` to be inferred as `Vec<&{integer}>`\n+   |         --- here the type of `foo` is inferred to be `Vec<&{integer}>`\n ...\n LL |     bar(foo);\n    |     --- ^^^ expected `Vec<i32>`, found `Vec<&{integer}>`\n@@ -16,10 +16,6 @@ note: function defined here\n    |\n LL | fn bar(_: Vec<i32>) {}\n    |    ^^^ -----------\n-help: consider dereferencing the borrow\n-   |\n-LL |         foo.push(*i);\n-   |                  +\n \n error: aborting due to previous error\n "}, {"sha": "72533ab1fa37f8a7384283e0201a0ef92d68c67d", "filename": "tests/ui/typeck/bad-type-in-vec-contains.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -7,7 +7,6 @@ LL |     primes.contains(3);\n    |            |        expected `&_`, found integer\n    |            |        help: consider borrowing here: `&3`\n    |            arguments to this method are incorrect\n-   |            here the type of `primes` is inferred to be `[_]`\n    |\n    = note: expected reference `&_`\n                    found type `{integer}`"}, {"sha": "1d5337260fa0ab289f33a6b575385c8f5d914cf2", "filename": "tests/ui/typeck/bad-type-in-vec-push.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -1,8 +1,6 @@\n error[E0308]: mismatched types\n   --> $DIR/bad-type-in-vec-push.rs:11:17\n    |\n-LL |     vector.sort();\n-   |     ------ here the type of `vector` is inferred to be `Vec<_>`\n LL |     result.push(vector);\n    |            ---- ^^^^^^ expected integer, found `Vec<_>`\n    |            |"}, {"sha": "39c727bd278bcedd282bc9394e3c1809fde20db9", "filename": "tests/ui/typeck/issue-107775.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42c4373ad11a86d3028ddfe29d7f33edc9670ba8/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107775.stderr?ref=42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "patch": "@@ -2,9 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-107775.rs:35:16\n    |\n LL |         map.insert(1, Struct::do_something);\n-   |                    -  -------------------- this is of type `fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}`, which causes `map` to be inferred as `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n-   |                    |\n-   |                    this is of type `{integer}`, which causes `map` to be inferred as `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n+   |         --- here the type of `map` is inferred to be `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n LL |         Self { map }\n    |                ^^^ expected `HashMap<u16, fn(u8) -> Pin<...>>`, found `HashMap<{integer}, ...>`\n    |"}]}