{"sha": "cb81712d10f4af3a55dd2368d9714daa425fcf22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiODE3MTJkMTBmNGFmM2E1NWRkMjM2OGQ5NzE0ZGFhNDI1ZmNmMjI=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-18T23:45:14Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-19T05:03:29Z"}, "message": "Make `fn_queries` helpers module-private", "tree": {"sha": "035f906ea1121521b91af3130e17e3b3ca7831ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/035f906ea1121521b91af3130e17e3b3ca7831ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb81712d10f4af3a55dd2368d9714daa425fcf22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb81712d10f4af3a55dd2368d9714daa425fcf22", "html_url": "https://github.com/rust-lang/rust/commit/cb81712d10f4af3a55dd2368d9714daa425fcf22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb81712d10f4af3a55dd2368d9714daa425fcf22/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "160e6304e8e7971d38787e8ca81f154e31f5b772", "url": "https://api.github.com/repos/rust-lang/rust/commits/160e6304e8e7971d38787e8ca81f154e31f5b772", "html_url": "https://github.com/rust-lang/rust/commit/160e6304e8e7971d38787e8ca81f154e31f5b772"}], "stats": {"total": 149, "additions": 74, "deletions": 75}, "files": [{"sha": "27efcd508414af0e557eae07e995f42dd73ba53c", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/cb81712d10f4af3a55dd2368d9714daa425fcf22/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb81712d10f4af3a55dd2368d9714daa425fcf22/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=cb81712d10f4af3a55dd2368d9714daa425fcf22", "patch": "@@ -82,94 +82,93 @@ pub fn is_min_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-pub fn provide(providers: &mut Providers<'_>) {\n-    /// Const evaluability whitelist is here to check evaluability at the\n-    /// top level beforehand.\n-    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n-        if tcx.is_closure(def_id) {\n-            return None;\n-        }\n-\n-        match tcx.fn_sig(def_id).abi() {\n-            Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n-                Some(tcx.lookup_const_stability(def_id).is_some())\n-            }\n-            _ => None,\n-        }\n+pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n+    let parent_id = tcx.hir().get_parent_did(hir_id);\n+    if !parent_id.is_top_level_module() {\n+        is_const_impl_raw(tcx, LocalDefId::from_def_id(parent_id))\n+    } else {\n+        false\n     }\n+}\n \n-    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n-    /// said intrinsic is on the whitelist for being const callable.\n-    fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        let hir_id = tcx\n-            .hir()\n-            .as_local_hir_id(def_id)\n-            .expect(\"Non-local call to local provider is_const_fn\");\n-\n-        let node = tcx.hir().get(hir_id);\n+/// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n+/// said intrinsic is on the whitelist for being const callable.\n+fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let hir_id =\n+        tcx.hir().as_local_hir_id(def_id).expect(\"Non-local call to local provider is_const_fn\");\n \n-        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n-            whitelisted\n-        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n-            if fn_like.constness() == hir::Constness::Const {\n-                return true;\n-            }\n+    let node = tcx.hir().get(hir_id);\n \n-            // If the function itself is not annotated with `const`, it may still be a `const fn`\n-            // if it resides in a const trait impl.\n-            let parent_id = tcx.hir().get_parent_did(hir_id);\n-            if def_id != parent_id && !parent_id.is_top_level_module() {\n-                is_const_impl_raw(tcx, LocalDefId::from_def_id(parent_id))\n-            } else {\n-                false\n-            }\n-        } else if let hir::Node::Ctor(_) = node {\n-            true\n-        } else {\n-            false\n+    if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n+        whitelisted\n+    } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n+        if fn_like.constness() == hir::Constness::Const {\n+            return true;\n         }\n+\n+        // If the function itself is not annotated with `const`, it may still be a `const fn`\n+        // if it resides in a const trait impl.\n+        is_parent_const_impl_raw(tcx, hir_id)\n+    } else if let hir::Node::Ctor(_) = node {\n+        true\n+    } else {\n+        false\n     }\n+}\n \n-    /// Checks whether the given item is an `impl` that has a `const` modifier.\n-    fn is_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        let node = tcx.hir().get(hir_id);\n-        matches!(\n-            node,\n-            hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Impl { constness: hir::Constness::Const, .. },\n-                ..\n-            })\n-        )\n+/// Const evaluability whitelist is here to check evaluability at the\n+/// top level beforehand.\n+fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n+    if tcx.is_closure(def_id) {\n+        return None;\n     }\n \n-    fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        is_const_fn(tcx, def_id)\n-            && match tcx.lookup_const_stability(def_id) {\n-                Some(stab) => {\n-                    if cfg!(debug_assertions) && stab.promotable {\n-                        let sig = tcx.fn_sig(def_id);\n-                        assert_eq!(\n-                            sig.unsafety(),\n-                            hir::Unsafety::Normal,\n-                            \"don't mark const unsafe fns as promotable\",\n-                            // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n-                        );\n-                    }\n-                    stab.promotable\n+    match tcx.fn_sig(def_id).abi() {\n+        Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n+            Some(tcx.lookup_const_stability(def_id).is_some())\n+        }\n+        _ => None,\n+    }\n+}\n+\n+/// Checks whether the given item is an `impl` that has a `const` modifier.\n+fn is_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(hir_id);\n+    matches!(\n+        node,\n+        hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Impl { constness: hir::Constness::Const, .. },\n+            ..\n+        })\n+    )\n+}\n+\n+fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    is_const_fn(tcx, def_id)\n+        && match tcx.lookup_const_stability(def_id) {\n+            Some(stab) => {\n+                if cfg!(debug_assertions) && stab.promotable {\n+                    let sig = tcx.fn_sig(def_id);\n+                    assert_eq!(\n+                        sig.unsafety(),\n+                        hir::Unsafety::Normal,\n+                        \"don't mark const unsafe fns as promotable\",\n+                        // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n+                    );\n                 }\n-                None => false,\n+                stab.promotable\n             }\n-    }\n+            None => false,\n+        }\n+}\n \n-    fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        is_const_fn(tcx, def_id)\n-            && tcx\n-                .lookup_const_stability(def_id)\n-                .map(|stab| stab.allow_const_fn_ptr)\n-                .unwrap_or(false)\n-    }\n+fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    is_const_fn(tcx, def_id)\n+        && tcx.lookup_const_stability(def_id).map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)\n+}\n \n+pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         is_const_fn_raw,\n         is_const_impl_raw: |tcx, def_id| is_const_impl_raw(tcx, LocalDefId::from_def_id(def_id)),"}]}