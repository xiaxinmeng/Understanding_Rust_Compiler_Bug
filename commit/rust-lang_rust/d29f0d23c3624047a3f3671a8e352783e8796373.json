{"sha": "d29f0d23c3624047a3f3671a8e352783e8796373", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyOWYwZDIzYzM2MjQwNDdhM2YzNjcxYThlMzUyNzgzZTg3OTYzNzM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-12T16:55:16Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-13T11:54:34Z"}, "message": "Move token tree related lexer state to a separate struct\n\nWe only used a bunch of fields when tokenizing into a token tree,\nso let's move them out of the base lexer", "tree": {"sha": "4a0986dfc123c68cb141e185d6265a659ec349f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a0986dfc123c68cb141e185d6265a659ec349f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d29f0d23c3624047a3f3671a8e352783e8796373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d29f0d23c3624047a3f3671a8e352783e8796373", "html_url": "https://github.com/rust-lang/rust/commit/d29f0d23c3624047a3f3671a8e352783e8796373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d29f0d23c3624047a3f3671a8e352783e8796373/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efa3c27f0ff21960b9309f8036dbf3e7416b9e52", "url": "https://api.github.com/repos/rust-lang/rust/commits/efa3c27f0ff21960b9309f8036dbf3e7416b9e52", "html_url": "https://github.com/rust-lang/rust/commit/efa3c27f0ff21960b9309f8036dbf3e7416b9e52"}], "stats": {"total": 119, "additions": 71, "deletions": 48}, "files": [{"sha": "60494a6a2bdc720970ae161484b2999e14334769", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d29f0d23c3624047a3f3671a8e352783e8796373/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d29f0d23c3624047a3f3671a8e352783e8796373/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d29f0d23c3624047a3f3671a8e352783e8796373", "patch": "@@ -66,15 +66,7 @@ pub struct StringReader<'a> {\n     span: Span,\n     /// The raw source span which *does not* take `override_span` into account\n     span_src_raw: Span,\n-    /// Stack of open delimiters and their spans. Used for error message.\n-    open_braces: Vec<(token::DelimToken, Span)>,\n-    crate unmatched_braces: Vec<UnmatchedBrace>,\n-    /// The type and spans for all braces\n-    ///\n-    /// Used only for error recovery when arriving to EOF with mismatched braces.\n-    matching_delim_spans: Vec<(token::DelimToken, Span, Span)>,\n-    crate override_span: Option<Span>,\n-    last_unclosed_found_span: Option<Span>,\n+    override_span: Option<Span>,\n }\n \n impl<'a> StringReader<'a> {\n@@ -254,11 +246,7 @@ impl<'a> StringReader<'a> {\n             token: token::Eof,\n             span: syntax_pos::DUMMY_SP,\n             span_src_raw: syntax_pos::DUMMY_SP,\n-            open_braces: Vec::new(),\n-            unmatched_braces: Vec::new(),\n-            matching_delim_spans: Vec::new(),\n             override_span,\n-            last_unclosed_found_span: None,\n         }\n     }\n "}, {"sha": "a6e176c02a09b65b2213d8f49397812e1383dbca", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 65, "deletions": 31, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d29f0d23c3624047a3f3671a8e352783e8796373/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d29f0d23c3624047a3f3671a8e352783e8796373/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=d29f0d23c3624047a3f3671a8e352783e8796373", "patch": "@@ -1,14 +1,42 @@\n+use syntax_pos::Span;\n+\n use crate::print::pprust::token_to_string;\n use crate::parse::lexer::{StringReader, UnmatchedBrace};\n use crate::parse::{token, PResult};\n use crate::tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree, TreeAndJoint};\n \n impl<'a> StringReader<'a> {\n+    crate fn into_token_trees(self) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n+        let mut tt_reader = TokenTreesReader {\n+            string_reader: self,\n+            open_braces: Vec::new(),\n+            unmatched_braces: Vec::new(),\n+            matching_delim_spans: Vec::new(),\n+            last_unclosed_found_span: None,\n+        };\n+        let res = tt_reader.parse_all_token_trees();\n+        (res, tt_reader.unmatched_braces)\n+    }\n+}\n+\n+struct TokenTreesReader<'a> {\n+    string_reader: StringReader<'a>,\n+    /// Stack of open delimiters and their spans. Used for error message.\n+    open_braces: Vec<(token::DelimToken, Span)>,\n+    unmatched_braces: Vec<UnmatchedBrace>,\n+    /// The type and spans for all braces\n+    ///\n+    /// Used only for error recovery when arriving to EOF with mismatched braces.\n+    matching_delim_spans: Vec<(token::DelimToken, Span, Span)>,\n+    last_unclosed_found_span: Option<Span>,\n+}\n+\n+impl<'a> TokenTreesReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s, up to an `Eof`.\n-    crate fn parse_all_token_trees(&mut self) -> PResult<'a, TokenStream> {\n+    fn parse_all_token_trees(&mut self) -> PResult<'a, TokenStream> {\n         let mut tts = Vec::new();\n \n-        while self.token != token::Eof {\n+        while self.string_reader.token != token::Eof {\n             tts.push(self.parse_token_tree()?);\n         }\n \n@@ -19,7 +47,7 @@ impl<'a> StringReader<'a> {\n     fn parse_token_trees_until_close_delim(&mut self) -> TokenStream {\n         let mut tts = vec![];\n         loop {\n-            if let token::CloseDelim(..) = self.token {\n+            if let token::CloseDelim(..) = self.string_reader.token {\n                 return TokenStream::new(tts);\n             }\n \n@@ -34,25 +62,25 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn parse_token_tree(&mut self) -> PResult<'a, TreeAndJoint> {\n-        let sm = self.sess.source_map();\n-        match self.token {\n+        let sm = self.string_reader.sess.source_map();\n+        match self.string_reader.token {\n             token::Eof => {\n                 let msg = \"this file contains an un-closed delimiter\";\n-                let mut err = self.sess.span_diagnostic.struct_span_err(self.span, msg);\n+                let mut err = self.string_reader.sess.span_diagnostic\n+                    .struct_span_err(self.span(), msg);\n                 for &(_, sp) in &self.open_braces {\n                     err.span_label(sp, \"un-closed delimiter\");\n                 }\n \n                 if let Some((delim, _)) = self.open_braces.last() {\n                     if let Some((_, open_sp, close_sp)) = self.matching_delim_spans.iter()\n                         .filter(|(d, open_sp, close_sp)| {\n-\n-                        if let Some(close_padding) = sm.span_to_margin(*close_sp) {\n-                            if let Some(open_padding) = sm.span_to_margin(*open_sp) {\n-                                return delim == d && close_padding != open_padding;\n+                            if let Some(close_padding) = sm.span_to_margin(*close_sp) {\n+                                if let Some(open_padding) = sm.span_to_margin(*open_sp) {\n+                                    return delim == d && close_padding != open_padding;\n+                                }\n                             }\n-                        }\n-                        false\n+                            false\n                         }).next()  // these are in reverse order as they get inserted on close, but\n                     {              // we want the last open/first close\n                         err.span_label(\n@@ -69,21 +97,21 @@ impl<'a> StringReader<'a> {\n             },\n             token::OpenDelim(delim) => {\n                 // The span for beginning of the delimited section\n-                let pre_span = self.span;\n+                let pre_span = self.span();\n \n                 // Parse the open delimiter.\n-                self.open_braces.push((delim, self.span));\n-                self.real_token();\n+                self.open_braces.push((delim, self.span()));\n+                self.string_reader.real_token();\n \n                 // Parse the token trees within the delimiters.\n                 // We stop at any delimiter so we can try to recover if the user\n                 // uses an incorrect delimiter.\n                 let tts = self.parse_token_trees_until_close_delim();\n \n                 // Expand to cover the entire delimited token tree\n-                let delim_span = DelimSpan::from_pair(pre_span, self.span);\n+                let delim_span = DelimSpan::from_pair(pre_span, self.span());\n \n-                match self.token {\n+                match self.string_reader.token {\n                     // Correct delimiter.\n                     token::CloseDelim(d) if d == delim => {\n                         let (open_brace, open_brace_span) = self.open_braces.pop().unwrap();\n@@ -93,26 +121,26 @@ impl<'a> StringReader<'a> {\n                             self.matching_delim_spans.clear();\n                         } else {\n                             self.matching_delim_spans.push(\n-                                (open_brace, open_brace_span, self.span),\n+                                (open_brace, open_brace_span, self.span()),\n                             );\n                         }\n                         // Parse the close delimiter.\n-                        self.real_token();\n+                        self.string_reader.real_token();\n                     }\n                     // Incorrect delimiter.\n                     token::CloseDelim(other) => {\n                         let mut unclosed_delimiter = None;\n                         let mut candidate = None;\n-                        if self.last_unclosed_found_span != Some(self.span) {\n+                        if self.last_unclosed_found_span != Some(self.span()) {\n                             // do not complain about the same unclosed delimiter multiple times\n-                            self.last_unclosed_found_span = Some(self.span);\n+                            self.last_unclosed_found_span = Some(self.span());\n                             // This is a conservative error: only report the last unclosed\n                             // delimiter. The previous unclosed delimiters could actually be\n                             // closed! The parser just hasn't gotten to them yet.\n                             if let Some(&(_, sp)) = self.open_braces.last() {\n                                 unclosed_delimiter = Some(sp);\n                             };\n-                            if let Some(current_padding) = sm.span_to_margin(self.span) {\n+                            if let Some(current_padding) = sm.span_to_margin(self.span()) {\n                                 for (brace, brace_span) in &self.open_braces {\n                                     if let Some(padding) = sm.span_to_margin(*brace_span) {\n                                         // high likelihood of these two corresponding\n@@ -126,7 +154,7 @@ impl<'a> StringReader<'a> {\n                             self.unmatched_braces.push(UnmatchedBrace {\n                                 expected_delim: tok,\n                                 found_delim: other,\n-                                found_span: self.span,\n+                                found_span: self.span(),\n                                 unclosed_span: unclosed_delimiter,\n                                 candidate_span: candidate,\n                             });\n@@ -142,7 +170,7 @@ impl<'a> StringReader<'a> {\n                         //     bar(baz(\n                         // }  // Incorrect delimiter but matches the earlier `{`\n                         if !self.open_braces.iter().any(|&(b, _)| b == other) {\n-                            self.real_token();\n+                            self.string_reader.real_token();\n                         }\n                     }\n                     token::Eof => {\n@@ -162,22 +190,28 @@ impl<'a> StringReader<'a> {\n             token::CloseDelim(_) => {\n                 // An unexpected closing delimiter (i.e., there is no\n                 // matching opening delimiter).\n-                let token_str = token_to_string(&self.token);\n+                let token_str = token_to_string(&self.string_reader.token);\n                 let msg = format!(\"unexpected close delimiter: `{}`\", token_str);\n-                let mut err = self.sess.span_diagnostic.struct_span_err(self.span, &msg);\n-                err.span_label(self.span, \"unexpected close delimiter\");\n+                let mut err = self.string_reader.sess.span_diagnostic\n+                    .struct_span_err(self.span(), &msg);\n+                err.span_label(self.span(), \"unexpected close delimiter\");\n                 Err(err)\n             },\n             _ => {\n-                let tt = TokenTree::Token(self.span, self.token.clone());\n+                let tt = TokenTree::Token(self.span(), self.string_reader.token.clone());\n                 // Note that testing for joint-ness here is done via the raw\n                 // source span as the joint-ness is a property of the raw source\n                 // rather than wanting to take `override_span` into account.\n-                let raw = self.span_src_raw;\n-                self.real_token();\n-                let is_joint = raw.hi() == self.span_src_raw.lo() && token::is_op(&self.token);\n+                let raw = self.string_reader.span_src_raw;\n+                self.string_reader.real_token();\n+                let is_joint = raw.hi() == self.string_reader.span_src_raw.lo()\n+                    && token::is_op(&self.string_reader.token);\n                 Ok((tt, if is_joint { Joint } else { NonJoint }))\n             }\n         }\n     }\n+\n+    fn span(&self) -> Span {\n+        self.string_reader.span\n+    }\n }"}, {"sha": "1ddafb969c4b3e00ade0f139987b726ca833c1a7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d29f0d23c3624047a3f3671a8e352783e8796373/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d29f0d23c3624047a3f3671a8e352783e8796373/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d29f0d23c3624047a3f3671a8e352783e8796373", "patch": "@@ -295,22 +295,23 @@ pub fn source_file_to_stream(\n }\n \n /// Given a source file, produces a sequence of token trees. Returns any buffered errors from\n-/// parsing the token tream.\n+/// parsing the token stream.\n pub fn maybe_file_to_stream(\n     sess: &ParseSess,\n     source_file: Lrc<SourceFile>,\n     override_span: Option<Span>,\n ) -> Result<(TokenStream, Vec<lexer::UnmatchedBrace>), Vec<Diagnostic>> {\n     let mut srdr = lexer::StringReader::new_or_buffered_errs(sess, source_file, override_span)?;\n     srdr.real_token();\n+    let (token_trees, unmatched_braces) = srdr.into_token_trees();\n \n-    match srdr.parse_all_token_trees() {\n-        Ok(stream) => Ok((stream, srdr.unmatched_braces)),\n+    match token_trees {\n+        Ok(stream) => Ok((stream, unmatched_braces)),\n         Err(err) => {\n             let mut buffer = Vec::with_capacity(1);\n             err.buffer(&mut buffer);\n             // Not using `emit_unclosed_delims` to use `db.buffer`\n-            for unmatched in srdr.unmatched_braces {\n+            for unmatched in unmatched_braces {\n                 let mut db = sess.span_diagnostic.struct_span_err(unmatched.found_span, &format!(\n                     \"incorrect close delimiter: `{}`\",\n                     token_to_string(&token::Token::CloseDelim(unmatched.found_delim)),"}]}