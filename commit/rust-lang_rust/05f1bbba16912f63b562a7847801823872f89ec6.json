{"sha": "05f1bbba16912f63b562a7847801823872f89ec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZjFiYmJhMTY5MTJmNjNiNTYyYTc4NDc4MDE4MjM4NzJmODllYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-25T19:26:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-25T19:26:16Z"}, "message": "auto merge of #8723 : anasazi/rust/temporary-unkillable-io, r=brson\n\nAlso added a home_for_io_with_sched variant to consolidate some cases.\r\n\r\nThis is a temporary step to resolving #8674.", "tree": {"sha": "bafcb39f0a7be2ece506ba9cb3cc20be8804a197", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bafcb39f0a7be2ece506ba9cb3cc20be8804a197"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05f1bbba16912f63b562a7847801823872f89ec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05f1bbba16912f63b562a7847801823872f89ec6", "html_url": "https://github.com/rust-lang/rust/commit/05f1bbba16912f63b562a7847801823872f89ec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05f1bbba16912f63b562a7847801823872f89ec6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a649e6b8b3e42bb8fa8fa806d783ecd9b543784", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a649e6b8b3e42bb8fa8fa806d783ecd9b543784", "html_url": "https://github.com/rust-lang/rust/commit/6a649e6b8b3e42bb8fa8fa806d783ecd9b543784"}, {"sha": "66365b63782e7b6950e6a213397cc75eef75a2c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/66365b63782e7b6950e6a213397cc75eef75a2c7", "html_url": "https://github.com/rust-lang/rust/commit/66365b63782e7b6950e6a213397cc75eef75a2c7"}], "stats": {"total": 289, "additions": 165, "deletions": 124}, "files": [{"sha": "6e79a78e061516360c582dacec753b962599de0f", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 165, "deletions": 124, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/05f1bbba16912f63b562a7847801823872f89ec6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f1bbba16912f63b562a7847801823872f89ec6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=05f1bbba16912f63b562a7847801823872f89ec6", "patch": "@@ -35,6 +35,7 @@ use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n           S_IRUSR, S_IWUSR};\n use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n             CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite};\n+use task;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -55,30 +56,68 @@ trait HomingIO {\n         // go home\n         let old_home = Cell::new_empty();\n         let old_home_ptr = &old_home;\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            // get the old home first\n-            do task.wake().map_move |mut task| {\n-                old_home_ptr.put_back(task.take_unwrap_home());\n-                self.home().send(PinnedTask(task));\n-            };\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                // get the old home first\n+                do task.wake().map_move |mut task| {\n+                    old_home_ptr.put_back(task.take_unwrap_home());\n+                    self.home().send(PinnedTask(task));\n+                };\n+            }\n         }\n \n         // do IO\n         let a = io(self);\n \n         // unhome home\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |scheduler, task| {\n-            do task.wake().map_move |mut task| {\n-                task.give_home(old_home.take());\n-                scheduler.make_handle().send(TaskFromFriend(task));\n-            };\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+                do task.wake().map_move |mut task| {\n+                    task.give_home(old_home.take());\n+                    scheduler.make_handle().send(TaskFromFriend(task));\n+                };\n+            }\n         }\n \n         // return the result of the IO\n         a\n     }\n+\n+    fn home_for_io_with_sched<A>(&mut self, io_sched: &fn(&mut Self, ~Scheduler) -> A) -> A {\n+        use rt::sched::{PinnedTask, TaskFromFriend};\n+\n+        do task::unkillable { // FIXME(#8674)\n+            // go home\n+            let old_home = Cell::new_empty();\n+            let old_home_ptr = &old_home;\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                // get the old home first\n+                do task.wake().map_move |mut task| {\n+                    old_home_ptr.put_back(task.take_unwrap_home());\n+                    self.home().send(PinnedTask(task));\n+                };\n+            }\n+\n+            // do IO\n+            let scheduler = Local::take::<Scheduler>();\n+            let a = io_sched(self, scheduler);\n+\n+            // unhome home\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+                do task.wake().map_move |mut task| {\n+                    task.give_home(old_home.take());\n+                    scheduler.make_handle().send(TaskFromFriend(task));\n+                };\n+            }\n+\n+            // return the result of the IO\n+            a\n+        }\n+    }\n }\n \n // get a handle for the current scheduler\n@@ -376,35 +415,37 @@ impl IoFactory for UvIoFactory {\n         let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n         // Block this task and take ownership, switch to scheduler context\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-\n-            let mut tcp = TcpWatcher::new(self.uv_loop());\n-            let task_cell = Cell::new(task);\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n \n-            // Wait for a connection\n-            do tcp.connect(addr) |stream, status| {\n-                match status {\n-                    None => {\n-                        let tcp = NativeHandle::from_native_handle(stream.native_handle());\n-                        let home = get_handle_to_current_scheduler!();\n-                        let res = Ok(~UvTcpStream { watcher: tcp, home: home });\n+                let mut tcp = TcpWatcher::new(self.uv_loop());\n+                let task_cell = Cell::new(task);\n \n-                        // Store the stream in the task's stack\n-                        unsafe { (*result_cell_ptr).put_back(res); }\n+                // Wait for a connection\n+                do tcp.connect(addr) |stream, status| {\n+                    match status {\n+                        None => {\n+                            let tcp = NativeHandle::from_native_handle(stream.native_handle());\n+                            let home = get_handle_to_current_scheduler!();\n+                            let res = Ok(~UvTcpStream { watcher: tcp, home: home });\n \n-                        // Context switch\n-                        let scheduler = Local::take::<Scheduler>();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                    Some(_) => {\n-                        let task_cell = Cell::new(task_cell.take());\n-                        do stream.close {\n-                            let res = Err(uv_error_to_io_error(status.unwrap()));\n+                            // Store the stream in the task's stack\n                             unsafe { (*result_cell_ptr).put_back(res); }\n+\n+                            // Context switch\n                             let scheduler = Local::take::<Scheduler>();\n                             scheduler.resume_blocked_task_immediately(task_cell.take());\n                         }\n+                        Some(_) => {\n+                            let task_cell = Cell::new(task_cell.take());\n+                            do stream.close {\n+                                let res = Err(uv_error_to_io_error(status.unwrap()));\n+                                unsafe { (*result_cell_ptr).put_back(res); }\n+                                let scheduler = Local::take::<Scheduler>();\n+                                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -422,15 +463,17 @@ impl IoFactory for UvIoFactory {\n                 Ok(~UvTcpListener::new(watcher, home))\n             }\n             Err(uverr) => {\n-                let scheduler = Local::take::<Scheduler>();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    let task_cell = Cell::new(task);\n-                    do watcher.as_stream().close {\n-                        let scheduler = Local::take::<Scheduler>();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                do task::unkillable { // FIXME(#8674)\n+                    let scheduler = Local::take::<Scheduler>();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        let task_cell = Cell::new(task);\n+                        do watcher.as_stream().close {\n+                            let scheduler = Local::take::<Scheduler>();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n                     }\n+                    Err(uv_error_to_io_error(uverr))\n                 }\n-                Err(uv_error_to_io_error(uverr))\n             }\n         }\n     }\n@@ -443,15 +486,17 @@ impl IoFactory for UvIoFactory {\n                 Ok(~UvUdpSocket { watcher: watcher, home: home })\n             }\n             Err(uverr) => {\n-                let scheduler = Local::take::<Scheduler>();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    let task_cell = Cell::new(task);\n-                    do watcher.close {\n-                        let scheduler = Local::take::<Scheduler>();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                do task::unkillable { // FIXME(#8674)\n+                    let scheduler = Local::take::<Scheduler>();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        let task_cell = Cell::new(task);\n+                        do watcher.close {\n+                            let scheduler = Local::take::<Scheduler>();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n                     }\n+                    Err(uv_error_to_io_error(uverr))\n                 }\n-                Err(uv_error_to_io_error(uverr))\n             }\n         }\n     }\n@@ -493,30 +538,32 @@ impl IoFactory for UvIoFactory {\n         let result_cell_ptr: *Cell<Result<~RtioFileStream,\n                                            IoError>> = &result_cell;\n         let path_cell = Cell::new(path);\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let path = path_cell.take();\n-            do file::FsRequest::open(self.uv_loop(), path, flags as int, create_mode as int)\n-                  |req,err| {\n-                if err.is_none() {\n-                    let loop_ = Loop {handle: req.get_loop().native_handle()};\n-                    let home = get_handle_to_current_scheduler!();\n-                    let fd = file::FileDescriptor(req.get_result());\n-                    let fs = ~UvFileStream::new(\n-                        loop_, fd, true, home) as ~RtioFileStream;\n-                    let res = Ok(fs);\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler = Local::take::<Scheduler>();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                } else {\n-                    let res = Err(uv_error_to_io_error(err.unwrap()));\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler = Local::take::<Scheduler>();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let path = path_cell.take();\n+                do file::FsRequest::open(self.uv_loop(), path, flags as int, create_mode as int)\n+                      |req,err| {\n+                    if err.is_none() {\n+                        let loop_ = Loop {handle: req.get_loop().native_handle()};\n+                        let home = get_handle_to_current_scheduler!();\n+                        let fd = file::FileDescriptor(req.get_result());\n+                        let fs = ~UvFileStream::new(\n+                            loop_, fd, true, home) as ~RtioFileStream;\n+                        let res = Ok(fs);\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    } else {\n+                        let res = Err(uv_error_to_io_error(err.unwrap()));\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                };\n             };\n-        };\n+        }\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n@@ -525,20 +572,22 @@ impl IoFactory for UvIoFactory {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let path_cell = Cell::new(path);\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let path = path_cell.take();\n-            do file::FsRequest::unlink(self.uv_loop(), path) |_, err| {\n-                let res = match err {\n-                    None => Ok(()),\n-                    Some(err) => Err(uv_error_to_io_error(err))\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let path = path_cell.take();\n+                do file::FsRequest::unlink(self.uv_loop(), path) |_, err| {\n+                    let res = match err {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n             };\n-        };\n+        }\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n@@ -572,8 +621,7 @@ impl Drop for UvTcpListener {\n     fn drop(&self) {\n         // XXX need mutable finalizer\n         let self_ = unsafe { transmute::<&UvTcpListener, &mut UvTcpListener>(self) };\n-        do self_.home_for_io |self_| {\n-            let scheduler = Local::take::<Scheduler>();\n+        do self_.home_for_io_with_sched |self_, scheduler| {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher().as_stream().close {\n@@ -665,8 +713,7 @@ impl Drop for UvTcpStream {\n     fn drop(&self) {\n         // XXX need mutable finalizer\n         let this = unsafe { transmute::<&UvTcpStream, &mut UvTcpStream>(self) };\n-        do this.home_for_io |self_| {\n-            let scheduler = Local::take::<Scheduler>();\n+        do this.home_for_io_with_sched |self_, scheduler| {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.as_stream().close {\n@@ -688,11 +735,10 @@ impl RtioSocket for UvTcpStream {\n \n impl RtioTcpStream for UvTcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        do self.home_for_io |self_| {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n             let result_cell = Cell::new_empty();\n             let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n-            let scheduler = Local::take::<Scheduler>();\n             let buf_ptr: *&mut [u8] = &buf;\n             do scheduler.deschedule_running_task_and_then |_sched, task| {\n                 let task_cell = Cell::new(task);\n@@ -730,10 +776,9 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n             let result_cell = Cell::new_empty();\n             let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-            let scheduler = Local::take::<Scheduler>();\n             let buf_ptr: *&[u8] = &buf;\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n@@ -827,11 +872,10 @@ impl Drop for UvUdpSocket {\n     fn drop(&self) {\n         // XXX need mutable finalizer\n         let this = unsafe { transmute::<&UvUdpSocket, &mut UvUdpSocket>(self) };\n-        do this.home_for_io |_| {\n-            let scheduler = Local::take::<Scheduler>();\n+        do this.home_for_io_with_sched |self_, scheduler| {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n-                do this.watcher.close {\n+                do self_.watcher.close {\n                     let scheduler = Local::take::<Scheduler>();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n@@ -850,11 +894,10 @@ impl RtioSocket for UvUdpSocket {\n \n impl RtioUdpSocket for UvUdpSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n-        do self.home_for_io |self_| {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n             let result_cell = Cell::new_empty();\n             let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n \n-            let scheduler = Local::take::<Scheduler>();\n             let buf_ptr: *&mut [u8] = &buf;\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n@@ -885,10 +928,9 @@ impl RtioUdpSocket for UvUdpSocket {\n     }\n \n     fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n             let result_cell = Cell::new_empty();\n             let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-            let scheduler = Local::take::<Scheduler>();\n             let buf_ptr: *&[u8] = &buf;\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n@@ -1047,9 +1089,8 @@ impl UvTimer {\n impl Drop for UvTimer {\n     fn drop(&self) {\n         let self_ = unsafe { transmute::<&UvTimer, &mut UvTimer>(self) };\n-        do self_.home_for_io |self_| {\n+        do self_.home_for_io_with_sched |self_, scheduler| {\n             rtdebug!(\"closing UvTimer\");\n-            let scheduler = Local::take::<Scheduler>();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.close {\n@@ -1063,8 +1104,7 @@ impl Drop for UvTimer {\n \n impl RtioTimer for UvTimer {\n     fn sleep(&mut self, msecs: u64) {\n-        do self.home_for_io |self_| {\n-            let scheduler = Local::take::<Scheduler>();\n+        do self.home_for_io_with_sched |self_, scheduler| {\n             do scheduler.deschedule_running_task_and_then |_sched, task| {\n                 rtdebug!(\"sleep: entered scheduler context\");\n                 let task_cell = Cell::new(task);\n@@ -1104,8 +1144,7 @@ impl UvFileStream {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n         let buf_ptr: *&mut [u8] = &buf;\n-        do self.home_for_io |self_| {\n-            let scheduler = Local::take::<Scheduler>();\n+        do self.home_for_io_with_sched |self_, scheduler| {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n                 let task_cell = Cell::new(task);\n@@ -1126,8 +1165,7 @@ impl UvFileStream {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let buf_ptr: *&[u8] = &buf;\n-        do self.home_for_io |self_| {\n-            let scheduler = Local::take::<Scheduler>();\n+        do self.home_for_io_with_sched |self_, scheduler| {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n                 let task_cell = Cell::new(task);\n@@ -1166,8 +1204,7 @@ impl Drop for UvFileStream {\n     fn drop(&self) {\n         let self_ = unsafe { transmute::<&UvFileStream, &mut UvFileStream>(self) };\n         if self.close_on_drop {\n-            do self_.home_for_io |self_| {\n-                let scheduler = Local::take::<Scheduler>();\n+            do self_.home_for_io_with_sched |self_, scheduler| {\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     let task_cell = Cell::new(task);\n                     do self_.fd.close(&self.loop_) |_,_| {\n@@ -1273,14 +1310,16 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n             assert!(maybe_socket.is_ok());\n \n             // block self on sched1\n-            let scheduler = Local::take::<Scheduler>();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                // unblock task\n-                do task.wake().map_move |task| {\n-                  // send self to sched2\n-                  tasksFriendHandle.take().send(TaskFromFriend(task));\n-                };\n-                // sched1 should now sleep since it has nothing else to do\n+            do task::unkillable { // FIXME(#8674)\n+                let scheduler = Local::take::<Scheduler>();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    // unblock task\n+                    do task.wake().map_move |task| {\n+                      // send self to sched2\n+                      tasksFriendHandle.take().send(TaskFromFriend(task));\n+                    };\n+                    // sched1 should now sleep since it has nothing else to do\n+                }\n             }\n             // sched2 will wake up and get the task\n             // as we do nothing else, the function ends and the socket goes out of scope\n@@ -1548,13 +1587,15 @@ fn test_read_and_block() {\n                 }\n                 reads += 1;\n \n-                let scheduler = Local::take::<Scheduler>();\n-                // Yield to the other task in hopes that it\n-                // will trigger a read callback while we are\n-                // not ready for it\n-                do scheduler.deschedule_running_task_and_then |sched, task| {\n-                    let task = Cell::new(task);\n-                    sched.enqueue_blocked_task(task.take());\n+                do task::unkillable { // FIXME(#8674)\n+                    let scheduler = Local::take::<Scheduler>();\n+                    // Yield to the other task in hopes that it\n+                    // will trigger a read callback while we are\n+                    // not ready for it\n+                    do scheduler.deschedule_running_task_and_then |sched, task| {\n+                        let task = Cell::new(task);\n+                        sched.enqueue_blocked_task(task.take());\n+                    }\n                 }\n             }\n "}]}