{"sha": "6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMTNjM2M5ODM5ZDE2OWI4MTlmZGMyZThiOTk2MGY5ZjYzNWYwZTM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-27T19:11:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-27T19:11:38Z"}, "message": "Merge pull request #64 from oli-obk/bugfixes\n\nBugfixes", "tree": {"sha": "1be389378845cff371638971c2994ddc906462a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1be389378845cff371638971c2994ddc906462a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "html_url": "https://github.com/rust-lang/rust/commit/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10ab168db92a6ac4460dbe588a78feb16200c5b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/10ab168db92a6ac4460dbe588a78feb16200c5b3", "html_url": "https://github.com/rust-lang/rust/commit/10ab168db92a6ac4460dbe588a78feb16200c5b3"}, {"sha": "f1f62051454eb5eef047cf7c02b17d018548513c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f62051454eb5eef047cf7c02b17d018548513c", "html_url": "https://github.com/rust-lang/rust/commit/f1f62051454eb5eef047cf7c02b17d018548513c"}], "stats": {"total": 315, "additions": 208, "deletions": 107}, "files": [{"sha": "a465ad62b9d422c2bfb20191b5334c5648d10c3b", "filename": "src/error.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -9,6 +9,7 @@ use syntax::codemap::Span;\n #[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n     FunctionPointerTyMismatch(&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>),\n+    NoMirFor(String),\n     DanglingPointerDeref,\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n@@ -82,6 +83,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"array index out of bounds\",\n             EvalError::Math(..) =>\n                 \"mathematical operation failed\",\n+            EvalError::NoMirFor(..) =>\n+                \"mir not found\",\n             EvalError::InvalidChar(..) =>\n                 \"tried to interpret an invalid 32-bit value as a char\",\n             EvalError::OutOfMemory{..} =>\n@@ -113,6 +116,7 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"memory access of {}..{} outside bounds of allocation {} which has size {}\",\n                        ptr.offset, ptr.offset + size, ptr.alloc_id, allocation_size)\n             },\n+            EvalError::NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             EvalError::FunctionPointerTyMismatch(expected, got) =>\n                 write!(f, \"tried to call a function of type {:?} through a function pointer of type {:?}\", expected, got),\n             EvalError::ArrayIndexOutOfBounds(span, len, index) =>"}, {"sha": "e6c4c4eb022f7a50af0a000812c9172245f4e503", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 109, "deletions": 61, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -267,25 +267,33 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }\n \n-    pub fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n+    pub fn load_mir(&self, def_id: DefId) -> EvalResult<'tcx, CachedMir<'a, 'tcx>> {\n+        trace!(\"load mir {:?}\", def_id);\n         if def_id.is_local() {\n-            CachedMir::Ref(self.mir_map.map.get(&def_id).unwrap())\n+            Ok(CachedMir::Ref(self.mir_map.map.get(&def_id).unwrap()))\n         } else {\n             let mut mir_cache = self.mir_cache.borrow_mut();\n             if let Some(mir) = mir_cache.get(&def_id) {\n-                return CachedMir::Owned(mir.clone());\n+                return Ok(CachedMir::Owned(mir.clone()));\n             }\n \n             let cs = &self.tcx.sess.cstore;\n-            let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap_or_else(|| {\n-                panic!(\"no mir for `{}`\", self.tcx.item_path_str(def_id));\n-            });\n-            let cached = Rc::new(mir);\n-            mir_cache.insert(def_id, cached.clone());\n-            CachedMir::Owned(cached)\n+            match cs.maybe_get_item_mir(self.tcx, def_id) {\n+                Some(mir) => {\n+                    let cached = Rc::new(mir);\n+                    mir_cache.insert(def_id, cached.clone());\n+                    Ok(CachedMir::Owned(cached))\n+                },\n+                None => Err(EvalError::NoMirFor(self.tcx.item_path_str(def_id))),\n+            }\n         }\n     }\n \n+    pub fn monomorphize_field_ty(&self, f: ty::FieldDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        let substituted = &f.ty(self.tcx, substs);\n+        self.tcx.normalize_associated_type(&substituted)\n+    }\n+\n     pub fn monomorphize(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         let substituted = ty.subst(self.tcx, substs);\n         self.tcx.normalize_associated_type(&substituted)\n@@ -519,7 +527,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     .chain(nonnull.offset_after_field.iter().map(|s| s.bytes()));\n                                 try!(self.assign_fields(dest, offsets, operands));\n                             } else {\n-                                assert_eq!(operands.len(), 0);\n+                                for operand in operands {\n+                                    let operand_ty = self.operand_ty(operand);\n+                                    assert_eq!(self.type_size(operand_ty), 0);\n+                                }\n                                 let offset = self.nonnull_offset(dest_ty, nndiscr, discrfield)?;\n                                 let dest = dest.offset(offset.bytes() as isize);\n                                 try!(self.memory.write_isize(dest, 0));\n@@ -596,56 +607,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n-            Cast(kind, ref operand, dest_ty) => {\n+            Cast(kind, ref operand, cast_ty) => {\n+                debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest_ty);\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n                         let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n-                        let dest_ty = self.monomorphize(dest_ty, self.substs());\n-                        // FIXME: cases where dest_ty is not a fat pointer. e.g. Arc<Struct> -> Arc<Trait>\n-                        assert!(self.type_is_fat_ptr(dest_ty));\n-                        let src_pointee_ty = pointee_type(src_ty).unwrap();\n-                        let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n-\n-                        // A<Struct> -> A<Trait> conversion\n-                        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(src_pointee_ty, dest_pointee_ty);\n-\n-                        match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n-                            (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                                let ptr = src.read_ptr(&self.memory)?;\n-                                self.memory.write_ptr(dest, ptr)?;\n-                                let ptr_size = self.memory.pointer_size() as isize;\n-                                let dest_extra = dest.offset(ptr_size);\n-                                self.memory.write_usize(dest_extra, length as u64)?;\n-                            }\n-                            (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n-                                // For now, upcasts are limited to changes in marker\n-                                // traits, and hence never actually require an actual\n-                                // change to the vtable.\n-                                self.write_value(src, dest, dest_ty)?;\n-                            },\n-                            (_, &ty::TyTrait(ref data)) => {\n-                                let trait_ref = data.principal.with_self_ty(self.tcx, src_pointee_ty);\n-                                let trait_ref = self.tcx.erase_regions(&trait_ref);\n-                                let vtable = self.get_vtable(trait_ref)?;\n-                                let ptr = src.read_ptr(&self.memory)?;\n-\n-                                self.memory.write_ptr(dest, ptr)?;\n-                                let ptr_size = self.memory.pointer_size() as isize;\n-                                let dest_extra = dest.offset(ptr_size);\n-                                self.memory.write_ptr(dest_extra, vtable)?;\n-                            },\n-\n-                            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n-                        }\n+                        self.unsize_into(src, src_ty, dest, dest_ty)?;\n                     }\n \n                     Misc => {\n                         let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n-                        // FIXME: dest_ty should already be monomorphized\n-                        let dest_ty = self.monomorphize(dest_ty, self.substs());\n                         if self.type_is_fat_ptr(src_ty) {\n                             trace!(\"misc cast: {:?}\", src);\n                             let ptr_size = self.memory.pointer_size();\n@@ -760,9 +734,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n-            Univariant { .. } => {\n-                assert_eq!(field_index, 0);\n-                Ok(Size::from_bytes(0))\n+            Univariant { ref variant, .. } => {\n+                Ok(variant.field_offset(field_index))\n             }\n             FatPointer { .. } => {\n                 let bytes = layout::FAT_PTR_ADDR * self.memory.pointer_size();\n@@ -1106,16 +1079,91 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn substs(&self) -> &'tcx Substs<'tcx> {\n         self.frame().substs\n     }\n-}\n \n-fn pointee_type(ptr_ty: ty::Ty) -> Option<ty::Ty> {\n-    match ptr_ty.sty {\n-        ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-        ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-        ty::TyBox(ty) => {\n-            Some(ty)\n+    fn unsize_into(\n+        &mut self,\n+        src: Value,\n+        src_ty: Ty<'tcx>,\n+        dest: Pointer,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, ()> {\n+        match (&src_ty.sty, &dest_ty.sty) {\n+            (&ty::TyBox(sty), &ty::TyBox(dty)) |\n+            (&ty::TyRef(_, ty::TypeAndMut { ty: sty, .. }), &ty::TyRef(_, ty::TypeAndMut { ty: dty, .. })) |\n+            (&ty::TyRef(_, ty::TypeAndMut { ty: sty, .. }), &ty::TyRawPtr(ty::TypeAndMut { ty: dty, .. })) |\n+            (&ty::TyRawPtr(ty::TypeAndMut { ty: sty, .. }), &ty::TyRawPtr(ty::TypeAndMut { ty: dty, .. })) => {\n+                // A<Struct> -> A<Trait> conversion\n+                let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n+\n+                match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n+                    (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n+                        let ptr = src.read_ptr(&self.memory)?;\n+                        self.memory.write_ptr(dest, ptr)?;\n+                        let ptr_size = self.memory.pointer_size() as isize;\n+                        let dest_extra = dest.offset(ptr_size);\n+                        self.memory.write_usize(dest_extra, length as u64)?;\n+                    }\n+                    (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n+                        // For now, upcasts are limited to changes in marker\n+                        // traits, and hence never actually require an actual\n+                        // change to the vtable.\n+                        self.write_value(src, dest, dest_ty)?;\n+                    },\n+                    (_, &ty::TyTrait(ref data)) => {\n+                        let trait_ref = data.principal.with_self_ty(self.tcx, src_pointee_ty);\n+                        let trait_ref = self.tcx.erase_regions(&trait_ref);\n+                        let vtable = self.get_vtable(trait_ref)?;\n+                        let ptr = src.read_ptr(&self.memory)?;\n+\n+                        self.memory.write_ptr(dest, ptr)?;\n+                        let ptr_size = self.memory.pointer_size() as isize;\n+                        let dest_extra = dest.offset(ptr_size);\n+                        self.memory.write_ptr(dest_extra, vtable)?;\n+                    },\n+\n+                    _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n+                }\n+            }\n+            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n+                // unsizing of generic struct with pointer fields\n+                // Example: `Arc<T>` -> `Arc<Trait>`\n+                // here we need to increase the size of every &T thin ptr field to a fat ptr\n+\n+                assert_eq!(def_a, def_b);\n+\n+                let src_fields = def_a.variants[0].fields.iter();\n+                let dst_fields = def_b.variants[0].fields.iter();\n+\n+                //let src = adt::MaybeSizedValue::sized(src);\n+                //let dst = adt::MaybeSizedValue::sized(dst);\n+                let src_ptr = match src {\n+                    Value::ByRef(ptr) => ptr,\n+                    _ => panic!(\"expected pointer, got {:?}\", src),\n+                };\n+\n+                let iter = src_fields.zip(dst_fields).enumerate();\n+                for (i, (src_f, dst_f)) in iter {\n+                    let src_fty = self.monomorphize_field_ty(src_f, substs_a);\n+                    let dst_fty = self.monomorphize_field_ty(dst_f, substs_b);\n+                    if self.type_size(dst_fty) == 0 {\n+                        continue;\n+                    }\n+                    let src_field_offset = self.get_field_offset(src_ty, i)?.bytes() as isize;\n+                    let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes() as isize;\n+                    let src_f_ptr = src_ptr.offset(src_field_offset);\n+                    let dst_f_ptr = dest.offset(dst_field_offset);\n+                    if src_fty == dst_fty {\n+                        self.move_(src_f_ptr, dst_f_ptr, src_fty)?;\n+                    } else {\n+                        self.unsize_into(Value::ByRef(src_f_ptr), src_fty, dst_f_ptr, dst_fty)?;\n+                    }\n+                }\n+            }\n+            _ => bug!(\"unsize_into: invalid conversion: {:?} -> {:?}\",\n+                      src_ty,\n+                      dest_ty),\n         }\n-        _ => None,\n+        Ok(())\n     }\n }\n "}, {"sha": "fe386ea5fb606de9af129ef8de5579f6e46c546e", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -125,8 +125,8 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         if self.ecx.statics.contains_key(&cid) {\n             return;\n         }\n-        let mir = self.ecx.load_mir(def_id);\n         self.try(|this| {\n+            let mir = this.ecx.load_mir(def_id)?;\n             let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n             this.ecx.statics.insert(cid.clone(), ptr);\n             let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n@@ -200,18 +200,25 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n         if let mir::Lvalue::Static(def_id) = *lvalue {\n             let substs = subst::Substs::empty(self.ecx.tcx);\n             let span = self.span;\n-            let node_item = self.ecx.tcx.map.get_if_local(def_id).expect(\"static not found\");\n-            if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n-                if let hir::ItemStatic(_, m, _) = *node {\n-                    self.global_item(def_id, substs, span, m == hir::MutImmutable);\n-                    return;\n+            if let Some(node_item) = self.ecx.tcx.map.get_if_local(def_id) {\n+                if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n+                    if let hir::ItemStatic(_, m, _) = *node {\n+                        self.global_item(def_id, substs, span, m == hir::MutImmutable);\n+                        return;\n+                    } else {\n+                        bug!(\"static def id doesn't point to static\");\n+                    }\n                 } else {\n-                    bug!(\"static def id doesn't point to static\");\n+                    bug!(\"static def id doesn't point to item\");\n                 }\n             } else {\n-                bug!(\"static def id doesn't point to item\");\n+                let def = self.ecx.tcx.sess.cstore.describe_def(def_id).expect(\"static not found\");\n+                if let hir::def::Def::Static(_, mutable) = def {\n+                    self.global_item(def_id, substs, span, !mutable);\n+                } else {\n+                    bug!(\"static found but isn't a static: {:?}\", def);\n+                }\n             }\n-            self.global_item(def_id, substs, span, false);\n         }\n     }\n }"}, {"sha": "cd024d4c007dc253110157c840e10be6e195c721", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -1,5 +1,4 @@\n use rustc::hir::def_id::DefId;\n-use rustc::middle::const_val::ConstVal;\n use rustc::mir::repr as mir;\n use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n@@ -45,26 +44,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n                 let discr_ty = self.lvalue_ty(discr);\n-                let discr_size = self\n-                    .type_layout(discr_ty)\n-                    .size(&self.tcx.data_layout)\n-                    .bytes() as usize;\n-                let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n-                if let ty::TyChar = discr_ty.sty {\n-                    if ::std::char::from_u32(discr_val as u32).is_none() {\n-                        return Err(EvalError::InvalidChar(discr_val as u64));\n-                    }\n-                }\n+                let discr_val = self.read_value(discr_ptr, discr_ty)?;\n+                let discr_prim = self.value_to_primval(discr_val, discr_ty)?;\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, const_val) in values.iter().enumerate() {\n-                    let val = match const_val {\n-                        &ConstVal::Integral(i) => i.to_u64_unchecked(),\n-                        _ => bug!(\"TerminatorKind::SwitchInt branch constant was not an integer\"),\n-                    };\n-                    if discr_val == val {\n+                    let val = self.const_to_value(const_val)?;\n+                    let prim = self.value_to_primval(val, discr_ty)?;\n+                    if discr_prim == prim {\n                         target_block = targets[index];\n                         break;\n                     }\n@@ -195,7 +184,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         (def_id, substs)\n                     };\n \n-                let mir = self.load_mir(resolved_def_id);\n+                let mir = self.load_mir(resolved_def_id)?;\n                 let (return_ptr, return_to_block) = match destination {\n                     Some((ptr, block)) => (Some(ptr), StackPopCleanup::Goto(block)),\n                     None => (None, StackPopCleanup::None),"}, {"sha": "54001bbc71226a5729d2dc05abb3eb9d821c8d97", "filename": "src/interpreter/vtable.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -112,35 +112,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         self.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n-        let trait_item_def_ids = self.tcx.trait_item_def_ids(trait_id);\n+        let trait_item_def_ids = self.tcx.impl_or_trait_items(trait_id);\n         trait_item_def_ids\n             .iter()\n \n             // Filter out non-method items.\n-            .filter_map(|item_def_id| {\n-                match *item_def_id {\n-                    ty::MethodTraitItemId(def_id) => Some(def_id),\n-                    _ => None,\n-                }\n-            })\n-\n-            // Now produce pointers for each remaining method. If the\n-            // method could never be called from this object, just supply\n-            // null.\n-            .map(|trait_method_def_id| {\n+            .filter_map(|&trait_method_def_id| {\n+                let trait_method_type = match self.tcx.impl_or_trait_item(trait_method_def_id) {\n+                    ty::MethodTraitItem(trait_method_type) => trait_method_type,\n+                    _ => return None,\n+                };\n                 debug!(\"get_vtable_methods: trait_method_def_id={:?}\",\n                        trait_method_def_id);\n \n-                let trait_method_type = match self.tcx.impl_or_trait_item(trait_method_def_id) {\n-                    ty::MethodTraitItem(m) => m,\n-                    _ => bug!(\"should be a method, not other assoc item\"),\n-                };\n                 let name = trait_method_type.name;\n \n                 // Some methods cannot be called on an object; skip those.\n                 if !self.tcx.is_vtable_safe_method(trait_id, &trait_method_type) {\n                     debug!(\"get_vtable_methods: not vtable safe\");\n-                    return None;\n+                    return Some(None);\n                 }\n \n                 debug!(\"get_vtable_methods: trait_method_type={:?}\",\n@@ -167,11 +157,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let predicates = mth.method.predicates.predicates.subst(self.tcx, mth.substs);\n                     if !self.normalize_and_test_predicates(predicates) {\n                         debug!(\"get_vtable_methods: predicates do not hold\");\n-                        return None;\n+                        return Some(None);\n                     }\n                 }\n \n-                Some(mth)\n+                Some(Some(mth))\n             })\n             .collect()\n     }"}, {"sha": "001dec5b4274736b83fd7f6070253b87b0315ea1", "filename": "tests/compile-fail/rc.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Fcompile-fail%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Fcompile-fail%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frc.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -0,0 +1,15 @@\n+//error-pattern: no mir for `std::result::unwrap_failed::__STATIC_FMTSTR`\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+fn rc_refcell() -> i32 {\n+    let r = Rc::new(RefCell::new(42));\n+    *r.borrow_mut() += 10;\n+    let x = *r.borrow();\n+    x\n+}\n+\n+fn main() {\n+    rc_refcell();\n+}"}, {"sha": "e5058df95ea5d37514d5a613b65e8c37fd3f67ba", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -105,7 +105,6 @@ fn compile_test() {\n                         writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n                         writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n                         writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n-                        panic!(\"failed to run test\");\n                     }\n                 }\n                 Err(e) => {\n@@ -116,5 +115,6 @@ fn compile_test() {\n         }\n         let stderr = std::io::stderr();\n         writeln!(stderr.lock(), \"{} success, {} mir not found, {} crate not found, {} failed\", success, mir_not_found, crate_not_found, failed).unwrap();\n+        assert_eq!(failed, 0, \"some tests failed\");\n     });\n }"}, {"sha": "edbf2b81ce941e2ae140848723c64f36ae8b9462", "filename": "tests/run-pass/issue-33387.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Frun-pass%2Fissue-33387.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Frun-pass%2Fissue-33387.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-33387.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::Arc;\n+\n+trait Foo {}\n+\n+impl Foo for [u8; 2] {}\n+\n+fn main() {\n+    let _: Arc<Foo + Send> = Arc::new([3, 4]);\n+}"}, {"sha": "568a1a1c881827779d837912424f78d57abb7acc", "filename": "tests/run-pass/match_slice.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Frun-pass%2Fmatch_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Frun-pass%2Fmatch_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmatch_slice.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let x = \"hello\";\n+    match x {\n+        \"foo\" => {},\n+        \"bar\" => {},\n+        _ => {},\n+    }\n+}"}, {"sha": "7ba68e6b239c0f3fcf0efdf80f123b5c5bddb1c4", "filename": "tests/run-pass/rust-lang-org.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Frun-pass%2Frust-lang-org.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e13c3c9839d169b819fdc2e8b9960f9f635f0e3/tests%2Frun-pass%2Frust-lang-org.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frust-lang-org.rs?ref=6e13c3c9839d169b819fdc2e8b9960f9f635f0e3", "patch": "@@ -0,0 +1,21 @@\n+// This code is editable and runnable!\n+fn main() {\n+    // A simple integer calculator:\n+    // `+` or `-` means add or subtract by 1\n+    // `*` or `/` means multiply or divide by 2\n+\n+    let program = \"+ + * - /\";\n+    let mut accumulator = 0;\n+\n+    for token in program.chars() {\n+        match token {\n+            '+' => accumulator += 1,\n+            '-' => accumulator -= 1,\n+            '*' => accumulator *= 2,\n+            '/' => accumulator /= 2,\n+            _ => { /* ignore everything else */ }\n+        }\n+    }\n+\n+    assert_eq!(accumulator, 1);\n+}"}]}