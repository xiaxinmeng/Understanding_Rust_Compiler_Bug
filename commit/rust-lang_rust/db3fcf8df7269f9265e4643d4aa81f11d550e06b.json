{"sha": "db3fcf8df7269f9265e4643d4aa81f11d550e06b", "node_id": "C_kwDOAAsO6NoAKGRiM2ZjZjhkZjcyNjlmOTI2NWU0NjQzZDRhYTgxZjExZDU1MGUwNmI", "commit": {"author": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-03-07T10:12:35Z"}, "committer": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-03-07T10:12:35Z"}, "message": "add basic code to check nop match blocks\nmodify `manual_map_option` uitest because one test case has confliction.", "tree": {"sha": "fca23dc1a28037f7e4aeaf5b571a82e8e79c55d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fca23dc1a28037f7e4aeaf5b571a82e8e79c55d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db3fcf8df7269f9265e4643d4aa81f11d550e06b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db3fcf8df7269f9265e4643d4aa81f11d550e06b", "html_url": "https://github.com/rust-lang/rust/commit/db3fcf8df7269f9265e4643d4aa81f11d550e06b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db3fcf8df7269f9265e4643d4aa81f11d550e06b/comments", "author": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30fb8229e13dadbe9f9968108dd46ebb8d43e56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/30fb8229e13dadbe9f9968108dd46ebb8d43e56e", "html_url": "https://github.com/rust-lang/rust/commit/30fb8229e13dadbe9f9968108dd46ebb8d43e56e"}], "stats": {"total": 311, "additions": 238, "deletions": 73}, "files": [{"sha": "7c29df0dfb42f8f0b492d636be3aef5f9c41c614", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db3fcf8df7269f9265e4643d4aa81f11d550e06b/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db3fcf8df7269f9265e4643d4aa81f11d550e06b/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=db3fcf8df7269f9265e4643d4aa81f11d550e06b", "patch": "@@ -16,12 +16,12 @@ mod match_same_arms;\n mod match_single_binding;\n mod match_wild_enum;\n mod match_wild_err_arm;\n+mod nop_match;\n mod overlapping_arms;\n mod redundant_pattern_match;\n mod rest_pat_in_fully_bound_struct;\n mod single_match;\n mod wild_in_or_pats;\n-mod nop_match;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -569,7 +569,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for unnecessary `match` or match-like `if let` returns for `Option` and `Result` \n+    /// Checks for unnecessary `match` or match-like `if let` returns for `Option` and `Result`\n     /// when function signatures are the same.\n     ///\n     /// ### Why is this bad?\n@@ -583,7 +583,7 @@ declare_clippy_lint! {\n     ///         Err(err) => Err(err),\n     ///     }\n     /// }\n-    /// \n+    ///\n     /// fn bar() -> Option<i32> {\n     ///     if let Some(val) = option {\n     ///         Some(val)\n@@ -594,12 +594,12 @@ declare_clippy_lint! {\n     /// ```\n     ///\n     /// Could be replaced as\n-    /// \n+    ///\n     /// ```rust,ignore\n     /// fn foo() -> Result<(), i32> {\n     ///     result\n     /// }\n-    /// \n+    ///\n     /// fn bar() -> Option<i32> {\n     ///     option\n     /// }"}, {"sha": "a0fff490cfa577cad168e85eba0dc04be27932d3", "filename": "clippy_lints/src/matches/nop_match.rs", "status": "modified", "additions": 90, "deletions": 8, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/db3fcf8df7269f9265e4643d4aa81f11d550e06b/clippy_lints%2Fsrc%2Fmatches%2Fnop_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db3fcf8df7269f9265e4643d4aa81f11d550e06b/clippy_lints%2Fsrc%2Fmatches%2Fnop_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fnop_match.rs?ref=db3fcf8df7269f9265e4643d4aa81f11d550e06b", "patch": "@@ -1,9 +1,11 @@\n #![allow(unused_variables)]\n+use super::NOP_MATCH;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use rustc_lint::LateContext;\n-use rustc_hir::{Arm, Expr};\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{eq_expr_value, get_parent_expr};\n use rustc_errors::Applicability;\n-use super::NOP_MATCH;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, PathSegment, QPath};\n+use rustc_lint::LateContext;\n \n pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n     if false {\n@@ -20,15 +22,95 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n }\n \n pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    if false {\n+    // This is for avoiding collision with `match_single_binding`.\n+    if arms.len() < 2 {\n+        return;\n+    }\n+\n+    for arm in arms {\n+        if let PatKind::Wild = arm.pat.kind {\n+            let ret_expr = strip_return(arm.body);\n+            if !eq_expr_value(cx, ex, ret_expr) {\n+                return;\n+            }\n+        } else if !pat_same_as_expr(arm.pat, arm.body) {\n+            return;\n+        }\n+    }\n+\n+    if let Some(match_expr) = get_parent_expr(cx, ex) {\n+        let mut applicability = Applicability::MachineApplicable;\n         span_lint_and_sugg(\n             cx,\n             NOP_MATCH,\n-            ex.span,\n+            match_expr.span,\n             \"this match expression is unnecessary\",\n             \"replace it with\",\n-            \"\".to_string(),\n-            Applicability::MachineApplicable,\n+            snippet_with_applicability(cx, ex.span, \"..\", &mut applicability).to_string(),\n+            applicability,\n         );\n     }\n-}\n\\ No newline at end of file\n+}\n+\n+fn strip_return<'hir>(expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    if let ExprKind::Ret(Some(ret)) = expr.kind {\n+        ret\n+    } else {\n+        expr\n+    }\n+}\n+\n+fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n+    let expr = strip_return(expr);\n+    match (&pat.kind, &expr.kind) {\n+        (\n+            PatKind::TupleStruct(QPath::Resolved(_, path), [first_pat, ..], _),\n+            ExprKind::Call(call_expr, [first_param, ..]),\n+        ) => {\n+            if let ExprKind::Path(QPath::Resolved(_, call_path)) = call_expr.kind {\n+                if is_identical_segments(path.segments, call_path.segments)\n+                    && has_same_non_ref_symbol(first_pat, first_param)\n+                {\n+                    return true;\n+                }\n+            }\n+        },\n+        (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {\n+            return is_identical_segments(p_path.segments, e_path.segments);\n+        },\n+        (PatKind::Lit(pat_lit_expr), ExprKind::Lit(expr_spanned)) => {\n+            if let ExprKind::Lit(pat_spanned) = &pat_lit_expr.kind {\n+                return pat_spanned.node == expr_spanned.node;\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    false\n+}\n+\n+fn is_identical_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegment<'_>]) -> bool {\n+    if left_segs.len() != right_segs.len() {\n+        return false;\n+    }\n+    for i in 0..left_segs.len() {\n+        if left_segs[i].ident.name != right_segs[i].ident.name {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn has_same_non_ref_symbol(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let PatKind::Binding(annot, _, pat_ident, _) = pat.kind;\n+        if !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind;\n+        if let Some(first_seg) = path.segments.first();\n+        then {\n+            return pat_ident.name == first_seg.ident.name;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "6f71b5d3d32445d057b0dbdfa3fae9047b635776", "filename": "tests/ui/manual_map_option.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=db3fcf8df7269f9265e4643d4aa81f11d550e06b", "patch": "@@ -148,6 +148,7 @@ fn main() {\n \n     // #7077\n     let s = &String::new();\n+    #[allow(clippy::nop_match)]\n     let _: Option<&str> = match Some(s) {\n         Some(s) => Some(s),\n         None => None,"}, {"sha": "f1b79f127a0a44566943daac6776c69db33fd5e0", "filename": "tests/ui/manual_map_option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=db3fcf8df7269f9265e4643d4aa81f11d550e06b", "patch": "@@ -214,6 +214,7 @@ fn main() {\n \n     // #7077\n     let s = &String::new();\n+    #[allow(clippy::nop_match)]\n     let _: Option<&str> = match Some(s) {\n         Some(s) => Some(s),\n         None => None,"}, {"sha": "eff03a464ce993a5934a21bbe072a90730578d8a", "filename": "tests/ui/nop_match.fixed", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fnop_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fnop_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnop_match.fixed?ref=db3fcf8df7269f9265e4643d4aa81f11d550e06b", "patch": "@@ -4,26 +4,47 @@\n #![allow(clippy::question_mark)]\n #![allow(dead_code)]\n \n-fn option_match() -> Option<i32> {\n-    match Some(1) {\n-        Some(a) => Some(a),\n-        None => None\n+fn func_ret_err<T>(err: T) -> Result<(), T> {\n+    Err(err)\n+}\n+\n+enum SampleEnum {\n+    A,\n+    B,\n+    C,\n+}\n+\n+fn useless_prim_type_match(x: i32) -> i32 {\n+    x\n+}\n+\n+fn useless_custom_type_match(se: SampleEnum) -> SampleEnum {\n+    se\n+}\n+\n+// Don't trigger\n+fn mingled_custom_type(se: SampleEnum) -> SampleEnum {\n+    match se {\n+        SampleEnum::A => SampleEnum::B,\n+        SampleEnum::B => SampleEnum::C,\n+        SampleEnum::C => SampleEnum::A,\n     }\n }\n \n+fn option_match() -> Option<i32> {\n+    Some(1)\n+}\n+\n fn result_match() -> Result<i32, i32> {\n-    match Ok(1) {\n-        Ok(a) => Ok(a),\n-        Err(err) => Err(err)\n-    }\n+    Ok(1)\n+}\n+\n+fn result_match_func_call() {\n+    let _ = func_ret_err(0_i32);\n }\n \n fn option_check() -> Option<i32> {\n-    if let Some(a) = Some(1) {\n-        Some(a)\n-    } else {\n-        None\n-    }\n+    if let Some(a) = Some(1) { Some(a) } else { None }\n }\n \n fn option_check_no_else() -> Option<i32> {\n@@ -33,10 +54,6 @@ fn option_check_no_else() -> Option<i32> {\n     None\n }\n \n-fn func_ret_err<T>(err: T) -> Result<(), T> {\n-    Err(err)\n-}\n-\n fn result_check_no_else() -> Result<(), i32> {\n     if let Err(e) = func_ret_err(0_i32) {\n         return Err(e);\n@@ -54,30 +71,18 @@ fn result_check_a() -> Result<(), i32> {\n \n // Don't trigger\n fn result_check_b() -> Result<(), i32> {\n-    if let Err(e) = Ok(1) {\n-        Err(e)\n-    } else {\n-        Ok(())\n-    }\n+    if let Err(e) = Ok(1) { Err(e) } else { Ok(()) }\n }\n \n fn result_check_c() -> Result<(), i32> {\n     let example = Ok(());\n-    if let Err(e) = example {\n-        Err(e)\n-    } else {\n-        example\n-    }\n+    if let Err(e) = example { Err(e) } else { example }\n }\n \n // Don't trigger\n fn result_check_d() -> Result<(), i32> {\n     let example = Ok(1);\n-    if let Err(e) = example {\n-        Err(e)\n-    } else {\n-        Ok(())\n-    }\n+    if let Err(e) = example { Err(e) } else { Ok(()) }\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "4c4b47ce9c57aa0ea7bed24a7f9072b733d4df72", "filename": "tests/ui/nop_match.rs", "status": "modified", "additions": 50, "deletions": 27, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fnop_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fnop_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnop_match.rs?ref=db3fcf8df7269f9265e4643d4aa81f11d550e06b", "patch": "@@ -4,26 +4,65 @@\n #![allow(clippy::question_mark)]\n #![allow(dead_code)]\n \n+fn func_ret_err<T>(err: T) -> Result<(), T> {\n+    Err(err)\n+}\n+\n+enum SampleEnum {\n+    A,\n+    B,\n+    C,\n+}\n+\n+fn useless_prim_type_match(x: i32) -> i32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        2 => 2,\n+        _ => x,\n+    }\n+}\n+\n+fn useless_custom_type_match(se: SampleEnum) -> SampleEnum {\n+    match se {\n+        SampleEnum::A => SampleEnum::A,\n+        SampleEnum::B => SampleEnum::B,\n+        SampleEnum::C => SampleEnum::C,\n+    }\n+}\n+\n+// Don't trigger\n+fn mingled_custom_type(se: SampleEnum) -> SampleEnum {\n+    match se {\n+        SampleEnum::A => SampleEnum::B,\n+        SampleEnum::B => SampleEnum::C,\n+        SampleEnum::C => SampleEnum::A,\n+    }\n+}\n+\n fn option_match() -> Option<i32> {\n     match Some(1) {\n         Some(a) => Some(a),\n-        None => None\n+        None => None,\n     }\n }\n \n fn result_match() -> Result<i32, i32> {\n     match Ok(1) {\n         Ok(a) => Ok(a),\n-        Err(err) => Err(err)\n+        Err(err) => Err(err),\n     }\n }\n \n+fn result_match_func_call() {\n+    let _ = match func_ret_err(0_i32) {\n+        Ok(a) => Ok(a),\n+        Err(err) => Err(err),\n+    };\n+}\n+\n fn option_check() -> Option<i32> {\n-    if let Some(a) = Some(1) {\n-        Some(a)\n-    } else {\n-        None\n-    }\n+    if let Some(a) = Some(1) { Some(a) } else { None }\n }\n \n fn option_check_no_else() -> Option<i32> {\n@@ -33,10 +72,6 @@ fn option_check_no_else() -> Option<i32> {\n     None\n }\n \n-fn func_ret_err<T>(err: T) -> Result<(), T> {\n-    Err(err)\n-}\n-\n fn result_check_no_else() -> Result<(), i32> {\n     if let Err(e) = func_ret_err(0_i32) {\n         return Err(e);\n@@ -54,30 +89,18 @@ fn result_check_a() -> Result<(), i32> {\n \n // Don't trigger\n fn result_check_b() -> Result<(), i32> {\n-    if let Err(e) = Ok(1) {\n-        Err(e)\n-    } else {\n-        Ok(())\n-    }\n+    if let Err(e) = Ok(1) { Err(e) } else { Ok(()) }\n }\n \n fn result_check_c() -> Result<(), i32> {\n     let example = Ok(());\n-    if let Err(e) = example {\n-        Err(e)\n-    } else {\n-        example\n-    }\n+    if let Err(e) = example { Err(e) } else { example }\n }\n \n // Don't trigger\n fn result_check_d() -> Result<(), i32> {\n     let example = Ok(1);\n-    if let Err(e) = example {\n-        Err(e)\n-    } else {\n-        Ok(())\n-    }\n+    if let Err(e) = example { Err(e) } else { Ok(()) }\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "bb171295f0fc55f6140cc97919fd73eb429582d6", "filename": "tests/ui/nop_match.stderr", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fnop_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db3fcf8df7269f9265e4643d4aa81f11d550e06b/tests%2Fui%2Fnop_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnop_match.stderr?ref=db3fcf8df7269f9265e4643d4aa81f11d550e06b", "patch": "@@ -0,0 +1,53 @@\n+error: this match expression is unnecessary\n+  --> $DIR/nop_match.rs:18:5\n+   |\n+LL | /     match x {\n+LL | |         0 => 0,\n+LL | |         1 => 1,\n+LL | |         2 => 2,\n+LL | |         _ => x,\n+LL | |     }\n+   | |_____^ help: replace it with: `x`\n+   |\n+   = note: `-D clippy::nop-match` implied by `-D warnings`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/nop_match.rs:27:5\n+   |\n+LL | /     match se {\n+LL | |         SampleEnum::A => SampleEnum::A,\n+LL | |         SampleEnum::B => SampleEnum::B,\n+LL | |         SampleEnum::C => SampleEnum::C,\n+LL | |     }\n+   | |_____^ help: replace it with: `se`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/nop_match.rs:44:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => Some(a),\n+LL | |         None => None,\n+LL | |     }\n+   | |_____^ help: replace it with: `Some(1)`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/nop_match.rs:51:5\n+   |\n+LL | /     match Ok(1) {\n+LL | |         Ok(a) => Ok(a),\n+LL | |         Err(err) => Err(err),\n+LL | |     }\n+   | |_____^ help: replace it with: `Ok(1)`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/nop_match.rs:58:13\n+   |\n+LL |       let _ = match func_ret_err(0_i32) {\n+   |  _____________^\n+LL | |         Ok(a) => Ok(a),\n+LL | |         Err(err) => Err(err),\n+LL | |     };\n+   | |_____^ help: replace it with: `func_ret_err(0_i32)`\n+\n+error: aborting due to 5 previous errors\n+"}]}