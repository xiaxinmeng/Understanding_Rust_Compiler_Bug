{"sha": "2830d7d0135f188260f1762e6a47c347e9a603e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MzBkN2QwMTM1ZjE4ODI2MGYxNzYyZTZhNDdjMzQ3ZTlhNjAzZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-29T18:04:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-29T18:04:25Z"}, "message": "auto merge of #8032 : catamorphism/rust/rustpkg-tags, r=graydon\n\nr? @graydon    Package IDs can now be of the form a/b/c#FOO, where (if a/b/c is\r\n    a git repository) FOO is any tag in the repository. Non-numeric\r\n    tags only match against package IDs with the same tag, and aren't\r\n    compared linearly like numeric versions.\r\n    \r\n While I was at it, refactored the code that calls `git clone`,  and segregated build output properly for different packages.", "tree": {"sha": "306a9581e542730705116c0078d05680236e1fa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/306a9581e542730705116c0078d05680236e1fa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2830d7d0135f188260f1762e6a47c347e9a603e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2830d7d0135f188260f1762e6a47c347e9a603e2", "html_url": "https://github.com/rust-lang/rust/commit/2830d7d0135f188260f1762e6a47c347e9a603e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2830d7d0135f188260f1762e6a47c347e9a603e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fddb35e988384c7aa5d9aaf96c1e075bede7a188", "url": "https://api.github.com/repos/rust-lang/rust/commits/fddb35e988384c7aa5d9aaf96c1e075bede7a188", "html_url": "https://github.com/rust-lang/rust/commit/fddb35e988384c7aa5d9aaf96c1e075bede7a188"}, {"sha": "7079ec6e2ed0d9de58d5a87b8ac7f6c31a65a4cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7079ec6e2ed0d9de58d5a87b8ac7f6c31a65a4cd", "html_url": "https://github.com/rust-lang/rust/commit/7079ec6e2ed0d9de58d5a87b8ac7f6c31a65a4cd"}], "stats": {"total": 220, "additions": 140, "deletions": 80}, "files": [{"sha": "46ab7afab43c249e0232c48649aaa18cb19cb1a3", "filename": "doc/rustpkg.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2830d7d0135f188260f1762e6a47c347e9a603e2/doc%2Frustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/2830d7d0135f188260f1762e6a47c347e9a603e2/doc%2Frustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustpkg.md?ref=2830d7d0135f188260f1762e6a47c347e9a603e2", "patch": "@@ -76,6 +76,14 @@ A package ID can also specify a version, like:\n `github.com/mozilla/rust#0.3`.\n In this case, `rustpkg` will check that the repository `github.com/mozilla/rust` has a tag named `0.3`,\n and report an error otherwise.\n+A package ID can also specify a particular revision of a repository, like:\n+`github.com/mozilla/rust#release-0.7`.\n+When the refspec (portion of the package ID after the `#`) can't be parsed as a decimal number,\n+rustpkg passes the refspec along to the version control system without interpreting it.\n+rustpkg also interprets any dependencies on such a package ID literally\n+(as opposed to versions, where a newer version satisfies a dependency on an older version).\n+Thus, `github.com/mozilla/rust#5c4cd30f80` is also a valid package ID,\n+since git can deduce that 5c4cd30f80 refers to a revision of the desired repository.\n \n ## Source files\n "}, {"sha": "3b3f08baa7e8a2a3d2fb6141cc0e8a9960acca2c", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=2830d7d0135f188260f1762e6a47c347e9a603e2", "patch": "@@ -11,14 +11,13 @@\n use target::*;\n use package_id::PkgId;\n use std::path::Path;\n-use std::{os, run, str};\n+use std::{os, str};\n use context::*;\n use crate::Crate;\n use messages::*;\n-use source_control::git_clone;\n+use source_control::{git_clone, git_clone_general};\n use path_util::pkgid_src_in_workspace;\n use util::compile_crate;\n-use version::{ExactRevision, SemanticVersion, NoVersion};\n \n // An enumeration of the unpacked source of a package workspace.\n // This contains a list of files found in the source workspace.\n@@ -102,22 +101,13 @@ impl PkgSrc {\n         }\n \n         let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n-        let branch_args = match self.id.version {\n-                      NoVersion => ~[],\n-                      ExactRevision(ref s) => ~[~\"--branch\", (*s).clone()],\n-                      SemanticVersion(ref s) => ~[~\"--branch\", s.to_str()]\n-        };\n-\n-\n-        note(fmt!(\"Fetching package: git clone %s %s %?\", url, local.to_str(), branch_args));\n-\n-        if run::process_output(\"git\",\n-                               ~[~\"clone\", url.clone(), local.to_str()] + branch_args).status != 0 {\n-            note(fmt!(\"fetching %s failed: can't clone repository\", url));\n-            None\n+        note(fmt!(\"Fetching package: git clone %s %s [version=%s]\",\n+                  url, local.to_str(), self.id.version.to_str()));\n+        if git_clone_general(url, &local, &self.id.version) {\n+            Some(local)\n         }\n         else {\n-            Some(local)\n+            None\n         }\n     }\n "}, {"sha": "696e4b30d1b58605253aa2e6c233d8e2980c3d12", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=2830d7d0135f188260f1762e6a47c347e9a603e2", "patch": "@@ -52,6 +52,7 @@ pub fn rust_path() -> ~[Path] {\n         }\n         None => ~[]\n     };\n+    debug!(\"RUST_PATH entries from environment: %?\", env_rust_path);\n     let cwd = os::getcwd();\n     // now add in default entries\n     env_rust_path.push(cwd.clone());\n@@ -345,7 +346,12 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     let subdir = match what {\n         Lib => \"lib\", Main | Test | Bench => \"bin\"\n     };\n-    let result = workspace.push(subdir);\n+    // Artifacts in the build directory live in a package-ID-specific subdirectory,\n+    // but installed ones don't.\n+    let result = match where {\n+                Build => workspace.push(subdir).push_rel(&*pkgid.local_path),\n+                _     => workspace.push(subdir)\n+    };\n     if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n         cond.raise((result.clone(), fmt!(\"target_file_in_workspace couldn't \\\n             create the %s dir (pkgid=%s, workspace=%s, what=%?, where=%?\","}, {"sha": "e3b796a03bb256baeeb567569c87ad72a7df157b", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=2830d7d0135f188260f1762e6a47c347e9a603e2", "patch": "@@ -10,30 +10,23 @@\n \n // Utils for working with version control repositories. Just git right now.\n \n-use std::{io, os, run, str};\n+use std::{os, run, str};\n+use std::run::{ProcessOutput, ProcessOptions, Process};\n use version::*;\n \n /// For a local git repo\n pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n     assert!(os::path_is_dir(source));\n     assert!(is_git_dir(source));\n     if !os::path_exists(target) {\n-        let version_args = match v {\n-            &ExactRevision(ref s) => ~[~\"--branch\", s.to_owned()],\n-            _ => ~[]\n-        };\n-        debug!(\"Running: git clone %s %s %s\", version_args.to_str(), source.to_str(),\n+        debug!(\"Running: git clone %s %s\", source.to_str(),\n                target.to_str());\n-        let outp = run::process_output(\"git\", ~[~\"clone\"] + version_args +\n-                                       ~[source.to_str(), target.to_str()]);\n-        if outp.status != 0 {\n-            io::println(str::from_bytes_owned(outp.output.clone()));\n-            io::println(str::from_bytes_owned(outp.error));\n-            fail!(\"Couldn't `git clone` %s\", source.to_str());\n-        }\n+        assert!(git_clone_general(source.to_str(), target, v));\n     }\n     else {\n         // Pull changes\n+        // Note that this ignores tags, which is probably wrong. There are no tests for\n+        // it, though.\n         debug!(\"Running: git --work-tree=%s --git-dir=%s pull --no-edit %s\",\n                target.to_str(), target.push(\".git\").to_str(), source.to_str());\n         let outp = run::process_output(\"git\", [fmt!(\"--work-tree=%s\", target.to_str()),\n@@ -43,6 +36,40 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n     }\n }\n \n+/// Source can be either a URL or a local file path.\n+/// true if successful\n+pub fn git_clone_general(source: &str, target: &Path, v: &Version) -> bool {\n+    let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n+    if outp.status != 0 {\n+         debug!(str::from_bytes_owned(outp.output.clone()));\n+         debug!(str::from_bytes_owned(outp.error));\n+         false\n+    }\n+    else {\n+        match v {\n+            &ExactRevision(ref s) | &Tagged(ref s) => {\n+                    let outp = process_output_in_cwd(\"git\", [~\"checkout\", fmt!(\"%s\", *s)],\n+                                                         target);\n+                    if outp.status != 0 {\n+                        debug!(str::from_bytes_owned(outp.output.clone()));\n+                        debug!(str::from_bytes_owned(outp.error));\n+                        false\n+                    }\n+                    else {\n+                        true\n+                    }\n+                }\n+                _ => true\n+            }\n+        }\n+}\n+\n+fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput {\n+    let mut prog = Process::new(prog, args, ProcessOptions{ dir: Some(cwd)\n+                                ,..ProcessOptions::new()});\n+    prog.finish_with_output()\n+}\n+\n pub fn is_git_dir(p: &Path) -> bool {\n     os::path_is_dir(&p.push(\".git\"))\n }"}, {"sha": "5930d8e9043ccfefc2303d1ce7957ab505224d05", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 68, "deletions": 38, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=2830d7d0135f188260f1762e6a47c347e9a603e2", "patch": "@@ -18,7 +18,7 @@ use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n use package_path::*;\n use package_id::{PkgId};\n-use version::{ExactRevision, NoVersion, Version};\n+use version::{ExactRevision, NoVersion, Version, Tagged};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n                make_dir_rwx, U_RWX, library_in_workspace,\n@@ -61,6 +61,16 @@ fn git_repo_pkg() -> PkgId {\n     }\n }\n \n+fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n+    let remote = RemotePath(Path(\"mockgithub.com/catamorphism/test-pkg\"));\n+    PkgId {\n+        local_path: normalize(remote.clone()),\n+        remote_path: remote,\n+        short_name: ~\"test_pkg\",\n+        version: Tagged(a_tag)\n+    }\n+}\n+\n fn writeFile(file_path: &Path, contents: &str) {\n     let out = io::file_writer(file_path, [io::Create, io::Truncate]).unwrap();\n     out.write_line(contents);\n@@ -148,9 +158,13 @@ fn init_git_repo(p: &Path) -> Path {\n     }\n }\n \n-fn add_git_tag(repo: &Path, tag: ~str) {\n-    assert!(repo.is_absolute());\n-    let mut prog = run::Process::new(\"git\", [~\"add\", ~\"-A\"],\n+fn add_all_and_commit(repo: &Path) {\n+    git_add_all(repo);\n+    git_commit(repo, ~\"floop\");\n+}\n+\n+fn git_commit(repo: &Path, msg: ~str) {\n+    let mut prog = run::Process::new(\"git\", [~\"commit\", ~\"-m\", msg],\n                                      run::ProcessOptions { env: None,\n                                                           dir: Some(repo),\n                                                           in_fd: None,\n@@ -159,9 +173,14 @@ fn add_git_tag(repo: &Path, tag: ~str) {\n                                                          });\n     let output = prog.finish_with_output();\n     if output.status != 0 {\n-        fail!(\"Couldn't add all files in %s\", repo.to_str())\n+        fail!(\"Couldn't commit in %s: output was %s\", repo.to_str(),\n+              str::from_bytes(output.output + output.error))\n     }\n-    prog = run::Process::new(\"git\", [~\"commit\", ~\"-m\", ~\"whatever\"],\n+\n+}\n+\n+fn git_add_all(repo: &Path) {\n+    let mut prog = run::Process::new(\"git\", [~\"add\", ~\"-A\"],\n                                      run::ProcessOptions { env: None,\n                                                           dir: Some(repo),\n                                                           in_fd: None,\n@@ -170,10 +189,16 @@ fn add_git_tag(repo: &Path, tag: ~str) {\n                                                          });\n     let output = prog.finish_with_output();\n     if output.status != 0 {\n-        fail!(\"Couldn't commit in %s\", repo.to_str())\n+        fail!(\"Couldn't add all files in %s: output was %s\",\n+              repo.to_str(), str::from_bytes(output.output + output.error))\n     }\n+}\n \n-    prog = run::Process::new(\"git\", [~\"tag\", tag.clone()],\n+fn add_git_tag(repo: &Path, tag: ~str) {\n+    assert!(repo.is_absolute());\n+    git_add_all(repo);\n+    git_commit(repo, ~\"whatever\");\n+    let mut prog = run::Process::new(\"git\", [~\"tag\", tag.clone()],\n                                      run::ProcessOptions { env: None,\n                                                           dir: Some(repo),\n                                                           in_fd: None,\n@@ -622,31 +647,6 @@ fn test_package_request_version() {\n     writeFile(&repo_subdir.push(\"version-0.4-file.txt\"), \"hello\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n-/*\n-\n-    let pkg_src = PkgSrc::new(&repo, &repo, &temp_pkg_id);\n-    match temp_pkg_id.version {\n-        ExactRevision(~\"0.3\") => {\n-            debug!(\"Version matches, calling fetch_git\");\n-            match pkg_src.fetch_git() {\n-                Some(p) => {\n-                    debug!(\"does version-0.3-file exist?\");\n-                    assert!(os::path_exists(&p.push(\"version-0.3-file.txt\")));\n-                    debug!(\"does version-0.4-file exist?\");\n-                    assert!(!os::path_exists(&p.push(\"version-0.4-file.txt\")));\n-\n-                }\n-                None => fail!(\"test_package_request_version: fetch_git failed\")\n-            }\n-        }\n-        ExactRevision(n) => {\n-            fail!(\"n is %? and %? %s %?\", n, n, if n == ~\"0.3\" { \"==\" } else { \"!=\" }, \"0.3\");\n-        }\n-        _ => fail!(fmt!(\"test_package_version: package version was %?, expected ExactRevision(0.3)\",\n-                        temp_pkg_id.version))\n-    }\n-*/\n-\n     command_line_test([~\"install\", fmt!(\"%s#0.3\", local_path)], &repo);\n \n     assert!(match installed_library_in_workspace(\"test_pkg_version\", &repo.push(\".rust\")) {\n@@ -679,6 +679,7 @@ fn rustpkg_install_url_2() {\n }\n \n // FIXME: #7956: temporarily disabled\n+#[test]\n fn rustpkg_library_target() {\n     let foo_repo = init_git_repo(&Path(\"foo\"));\n     let package_dir = foo_repo.push(\"foo\");\n@@ -705,8 +706,10 @@ fn rustpkg_local_pkg() {\n     assert_executable_exists(&dir, \"foo\");\n }\n \n+// FIXME: #7956: temporarily disabled\n+//  Failing on dist-linux bot\n #[test]\n-#[ignore] // XXX Failing on dist-linux bot\n+#[ignore]\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\", &os::getcwd()));\n     debug!(\"dir = %s\", dir.to_str());\n@@ -765,7 +768,7 @@ fn rustpkg_clean_no_arg() {\n }\n \n #[test]\n-#[ignore (reason = \"Un-ignore when #7071 is fixed\")]\n+#[ignore (reason = \"Specifying env doesn't work -- see #8028\")]\n fn rust_path_test() {\n     let dir_for_path = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"rust_path_test failed\");\n     let dir = mk_workspace(&dir_for_path, &normalize(RemotePath(Path(\"foo\"))), &NoVersion);\n@@ -774,9 +777,13 @@ fn rust_path_test() {\n \n     let cwd = os::getcwd();\n     debug!(\"cwd = %s\", cwd.to_str());\n+    debug!(\"Running command: cd %s; RUST_LOG=rustpkg RUST_PATH=%s rustpkg install foo\",\n+           cwd.to_str(), dir_for_path.to_str());\n     let mut prog = run::Process::new(\"rustpkg\",\n                                      [~\"install\", ~\"foo\"],\n-                                     run::ProcessOptions { env: Some(&[(~\"RUST_PATH\",\n+                                     run::ProcessOptions { env: Some(&[(~\"RUST_LOG\",\n+                                                                        ~\"rustpkg\"),\n+                                                                       (~\"RUST_PATH\",\n                                                                        dir_for_path.to_str())]),\n                                                           dir: Some(&cwd),\n                                                           in_fd: None,\n@@ -954,7 +961,6 @@ fn do_rebuild_dep_only_contents_change() {\n }\n \n #[test]\n-#[ignore(reason = \"list not yet implemented\")]\n fn test_versions() {\n     let workspace = create_local_package(&PkgId::new(\"foo#0.1\", &os::getcwd()));\n     create_local_package(&PkgId::new(\"foo#0.2\", &os::getcwd()));\n@@ -992,11 +998,35 @@ fn test_rustpkg_test() {\n }\n \n #[test]\n-#[ignore(reason = \"uninstall not yet implemented\")]\n fn test_uninstall() {\n     let workspace = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n     let _output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n     command_line_test([~\"uninstall\", ~\"foo\"], &workspace);\n     let output = command_line_test([~\"list\"], &workspace);\n     assert!(!str::from_bytes(output.output).contains(\"foo\"));\n }\n+\n+#[test]\n+fn test_non_numeric_tag() {\n+    let temp_pkg_id = git_repo_pkg();\n+    let repo = init_git_repo(&Path(temp_pkg_id.local_path.to_str()));\n+    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg\");\n+    writeFile(&repo_subdir.push(\"foo\"), \"foo\");\n+    writeFile(&repo_subdir.push(\"lib.rs\"),\n+              \"pub fn f() { let _x = (); }\");\n+    add_git_tag(&repo_subdir, ~\"testbranch\");\n+    writeFile(&repo_subdir.push(\"testbranch_only\"), \"hello\");\n+    add_git_tag(&repo_subdir, ~\"another_tag\");\n+    writeFile(&repo_subdir.push(\"not_on_testbranch_only\"), \"bye bye\");\n+    add_all_and_commit(&repo_subdir);\n+\n+\n+    command_line_test([~\"install\", fmt!(\"%s#testbranch\", temp_pkg_id.remote_path.to_str())],\n+                      &repo);\n+    let file1 = repo.push_many([\"mockgithub.com\", \"catamorphism\",\n+                                \"test_pkg\", \"testbranch_only\"]);\n+    let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg\",\n+                                \"master_only\"]);\n+    assert!(os::path_exists(&file1));\n+    assert!(!os::path_exists(&file2));\n+}"}, {"sha": "f5ac82b5684a6d5399f434e8f3ff391d97a74038", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=2830d7d0135f188260f1762e6a47c347e9a603e2", "patch": "@@ -63,20 +63,17 @@ List all installed packages.\");\n }\n \n pub fn install() {\n-    io::println(\"rustpkg [options..] install [url] [target]\n+    io::println(\"rustpkg [options..] install [package-ID]\n \n-Install a package from a URL by Git or cURL (FTP, HTTP, etc.).\n-If target is provided, Git will checkout the branch or tag before\n-continuing. If the URL is a TAR file (with or without compression),\n-extract it before installing. If a URL isn't provided, the package will\n-be built and installed from the current directory (which is\n-functionally the same as `rustpkg build` and installing the result).\n+Install the given package ID if specified. With no package ID\n+argument, install the package in the current directory.\n+In that case, the current directory must be a direct child of a\n+`src` directory in a workspace.\n \n Examples:\n     rustpkg install\n-    rustpkg install git://github.com/mozilla/servo.git\n-    rustpkg install git://github.com/mozilla/servo.git v0.1.2\n-    rustpkg install http://rust-lang.org/servo-0.1.2.tar.gz\n+    rustpkg install github.com/mozilla/servo\n+    rustpkg install github.com/mozilla/servo#0.1.2\n \n Options:\n     -c, --cfg      Pass a cfg flag to the package script\");"}, {"sha": "4fa72b713ace24e9fa07a4c4169af1035059d419", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2830d7d0135f188260f1762e6a47c347e9a603e2/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=2830d7d0135f188260f1762e6a47c347e9a603e2", "patch": "@@ -22,6 +22,8 @@ use extra::tempfile::mkdtemp;\n pub enum Version {\n     ExactRevision(~str), // Should look like a m.n.(...).x\n     SemanticVersion(semver::Version),\n+    Tagged(~str), // String that can't be parsed as a version.\n+                  // Requirements get interpreted exactly\n     NoVersion // user didn't specify a version -- prints as 0.1\n }\n \n@@ -76,7 +78,7 @@ impl Ord for Version {\n impl ToStr for Version {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            ExactRevision(ref n) => fmt!(\"%s\", n.to_str()),\n+            ExactRevision(ref n) | Tagged(ref n) => fmt!(\"%s\", n.to_str()),\n             SemanticVersion(ref v) => fmt!(\"%s\", v.to_str()),\n             NoVersion => ~\"0.1\"\n         }"}]}