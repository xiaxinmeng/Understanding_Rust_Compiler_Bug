{"sha": "dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYjcwMmNmYzE0MTk4NTBlN2QyMDhhMWIzNzVlNGE2OWRiZThlODc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-09-05T19:30:06Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-09-05T19:36:36Z"}, "message": "internal: remove accidental code re-use\n\nFragmentKind played two roles:\n\n* entry point to the parser\n* syntactic category of a macro call\n\nThese are different use-cases, and warrant different types. For example,\nmacro can't expand to visibility, but we have such fragment today.\n\nThis PR introduces `ExpandsTo` enum to separate this two use-cases.\n\nI suspect we might further split `FragmentKind` into `$x:specifier` enum\nspecific to MBE, and a general parser entry point, but that's for\nanother PR!", "tree": {"sha": "a9e4ab2b7f1271c2119a7028c6d893895870a0f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9e4ab2b7f1271c2119a7028c6d893895870a0f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "html_url": "https://github.com/rust-lang/rust/commit/dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "847d0faf92707f84fa32560313e91f7ad8d40b94", "url": "https://api.github.com/repos/rust-lang/rust/commits/847d0faf92707f84fa32560313e91f7ad8d40b94", "html_url": "https://github.com/rust-lang/rust/commit/847d0faf92707f84fa32560313e91f7ad8d40b94"}], "stats": {"total": 311, "additions": 172, "deletions": 139}, "files": [{"sha": "3b08782375961b7a461f3020ba8af7ad5913498f", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -525,7 +525,6 @@ dependencies = [\n  \"la-arena\",\n  \"limit\",\n  \"mbe\",\n- \"parser\",\n  \"profile\",\n  \"rustc-hash\",\n  \"syntax\","}, {"sha": "9f09666e9723d5ad0acb79e21f6c944771e4b9cd", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -695,8 +695,7 @@ impl Attr {\n         hygiene: &Hygiene,\n         id: AttrId,\n     ) -> Option<Attr> {\n-        let (parse, _) =\n-            mbe::token_tree_to_syntax_node(tt, hir_expand::FragmentKind::MetaItem).ok()?;\n+        let (parse, _) = mbe::token_tree_to_syntax_node(tt, mbe::FragmentKind::MetaItem).ok()?;\n         let ast = ast::Meta::cast(parse.syntax_node())?;\n \n         Self::from_src(db, ast, hygiene, id)"}, {"sha": "26621b8c7ebbafccce1bf81c7a9d6345306290a2", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -51,7 +51,7 @@ use hir_expand::{\n     ast_id_map::FileAstId,\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    FragmentKind, HirFileId, InFile,\n+    ExpandTo, HirFileId, InFile,\n };\n use la_arena::{Arena, Idx, RawIdx};\n use profile::Count;\n@@ -739,7 +739,7 @@ pub struct MacroCall {\n     /// Path to the called macro.\n     pub path: Interned<ModPath>,\n     pub ast_id: FileAstId<ast::MacroCall>,\n-    pub fragment: FragmentKind,\n+    pub expand_to: ExpandTo,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]"}, {"sha": "7bed19a7920c3dd5f7bb9fe912d8281ebd8533b2", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -573,8 +573,8 @@ impl<'a> Ctx<'a> {\n     fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n         let path = Interned::new(ModPath::from_src(self.db, m.path()?, &self.hygiene)?);\n         let ast_id = self.source_ast_id_map.ast_id(m);\n-        let fragment = hir_expand::to_fragment_kind(m);\n-        let res = MacroCall { path, ast_id, fragment };\n+        let expand_to = hir_expand::ExpandTo::from_call_site(m);\n+        let res = MacroCall { path, ast_id, expand_to };\n         Some(id(self.data().macro_calls.alloc(res)))\n     }\n "}, {"sha": "3e33b0c46c2963126e3340322e15d6fd20cf9204", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -440,7 +440,7 @@ impl<'a> Printer<'a> {\n                 }\n             }\n             ModItem::MacroCall(it) => {\n-                let MacroCall { path, ast_id: _, fragment: _ } = &self.tree[it];\n+                let MacroCall { path, ast_id: _, expand_to: _ } = &self.tree[it];\n                 wln!(self, \"{}!(...);\", path);\n             }\n             ModItem::MacroRules(it) => {"}, {"sha": "4904ebfd638770c6c31c36381f0ab3ba7cf141f3", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -61,7 +61,7 @@ use hir_expand::{\n     ast_id_map::FileAstId,\n     eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n     hygiene::Hygiene,\n-    AstId, FragmentKind, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    AstId, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use la_arena::Idx;\n use nameres::DefMap;\n@@ -667,7 +667,7 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n         mut error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n-        let fragment = hir_expand::to_fragment_kind(self.value);\n+        let expands_to = hir_expand::ExpandTo::from_call_site(self.value);\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n         let path = self.value.path().and_then(|path| path::ModPath::from_src(db, path, &h));\n@@ -683,7 +683,7 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n \n         macro_call_as_call_id(\n             &AstIdWithPath::new(ast_id.file_id, ast_id.value, path),\n-            fragment,\n+            expands_to,\n             db,\n             krate,\n             resolver,\n@@ -712,7 +712,7 @@ pub struct UnresolvedMacro {\n \n fn macro_call_as_call_id(\n     call: &AstIdWithPath<ast::MacroCall>,\n-    fragment: FragmentKind,\n+    expand_to: ExpandTo,\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n@@ -738,7 +738,7 @@ fn macro_call_as_call_id(\n         Ok(def.as_lazy_macro(\n             db.upcast(),\n             krate,\n-            MacroCallKind::FnLike { ast_id: call.ast_id, fragment },\n+            MacroCallKind::FnLike { ast_id: call.ast_id, expand_to },\n         ))\n     };\n     Ok(res)"}, {"sha": "165cdcba00c7dd7cba993f12b501493aec081e9b", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -14,7 +14,7 @@ use hir_expand::{\n     builtin_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n     proc_macro::ProcMacroExpander,\n-    FragmentKind, HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    ExpandTo, HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use hir_expand::{InFile, MacroCallLoc};\n use itertools::Itertools;\n@@ -223,7 +223,7 @@ struct MacroDirective {\n \n #[derive(Clone, Debug, Eq, PartialEq)]\n enum MacroDirectiveKind {\n-    FnLike { ast_id: AstIdWithPath<ast::MacroCall>, fragment: FragmentKind },\n+    FnLike { ast_id: AstIdWithPath<ast::MacroCall>, expand_to: ExpandTo },\n     Derive { ast_id: AstIdWithPath<ast::Item>, derive_attr: AttrId },\n     Attr { ast_id: AstIdWithPath<ast::Item>, attr: Attr, mod_item: ModItem },\n }\n@@ -1021,10 +1021,10 @@ impl DefCollector<'_> {\n             };\n \n             match &directive.kind {\n-                MacroDirectiveKind::FnLike { ast_id, fragment } => {\n+                MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n                     match macro_call_as_call_id(\n                         ast_id,\n-                        *fragment,\n+                        *expand_to,\n                         self.db,\n                         self.def_map.krate,\n                         &resolver,\n@@ -1223,32 +1223,34 @@ impl DefCollector<'_> {\n \n         for directive in &self.unresolved_macros {\n             match &directive.kind {\n-                MacroDirectiveKind::FnLike { ast_id, fragment } => match macro_call_as_call_id(\n-                    ast_id,\n-                    *fragment,\n-                    self.db,\n-                    self.def_map.krate,\n-                    |path| {\n-                        let resolved_res = self.def_map.resolve_path_fp_with_macro(\n-                            self.db,\n-                            ResolveMode::Other,\n-                            directive.module_id,\n-                            &path,\n-                            BuiltinShadowMode::Module,\n-                        );\n-                        resolved_res.resolved_def.take_macros()\n-                    },\n-                    &mut |_| (),\n-                ) {\n-                    Ok(_) => (),\n-                    Err(UnresolvedMacro { path }) => {\n-                        self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n-                            directive.module_id,\n-                            ast_id.ast_id,\n-                            path,\n-                        ));\n+                MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n+                    match macro_call_as_call_id(\n+                        ast_id,\n+                        *expand_to,\n+                        self.db,\n+                        self.def_map.krate,\n+                        |path| {\n+                            let resolved_res = self.def_map.resolve_path_fp_with_macro(\n+                                self.db,\n+                                ResolveMode::Other,\n+                                directive.module_id,\n+                                &path,\n+                                BuiltinShadowMode::Module,\n+                            );\n+                            resolved_res.resolved_def.take_macros()\n+                        },\n+                        &mut |_| (),\n+                    ) {\n+                        Ok(_) => (),\n+                        Err(UnresolvedMacro { path }) => {\n+                            self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                                directive.module_id,\n+                                ast_id.ast_id,\n+                                path,\n+                            ));\n+                        }\n                     }\n-                },\n+                }\n                 MacroDirectiveKind::Derive { .. } | MacroDirectiveKind::Attr { .. } => {\n                     // FIXME: we might want to diagnose this too\n                 }\n@@ -1899,7 +1901,7 @@ impl ModCollector<'_, '_> {\n         let mut error = None;\n         match macro_call_as_call_id(\n             &ast_id,\n-            mac.fragment,\n+            mac.expand_to,\n             self.def_collector.db,\n             self.def_collector.def_map.krate,\n             |path| {\n@@ -1930,12 +1932,11 @@ impl ModCollector<'_, '_> {\n                 // Built-in macro failed eager expansion.\n \n                 // FIXME: don't parse the file here\n-                let fragment = hir_expand::to_fragment_kind(\n-                    &ast_id.ast_id.to_node(self.def_collector.db.upcast()),\n-                );\n+                let macro_call = ast_id.ast_id.to_node(self.def_collector.db.upcast());\n+                let expand_to = hir_expand::ExpandTo::from_call_site(&macro_call);\n                 self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n                     self.module_id,\n-                    MacroCallKind::FnLike { ast_id: ast_id.ast_id, fragment },\n+                    MacroCallKind::FnLike { ast_id: ast_id.ast_id, expand_to },\n                     error.unwrap().to_string(),\n                 ));\n                 return;\n@@ -1947,7 +1948,7 @@ impl ModCollector<'_, '_> {\n         self.def_collector.unresolved_macros.push(MacroDirective {\n             module_id: self.module_id,\n             depth: self.macro_depth + 1,\n-            kind: MacroDirectiveKind::FnLike { ast_id, fragment: mac.fragment },\n+            kind: MacroDirectiveKind::FnLike { ast_id, expand_to: mac.expand_to },\n         });\n     }\n "}, {"sha": "5655a8fdffeaef063fe5a163ed84f27c87a7de0b", "filename": "crates/hir_expand/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2FCargo.toml?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -19,7 +19,6 @@ itertools = \"0.10.0\"\n base_db = { path = \"../base_db\", version = \"0.0.0\" }\n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-parser = { path = \"../parser\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }\n tt = { path = \"../tt\", version = \"0.0.0\" }\n mbe = { path = \"../mbe\", version = \"0.0.0\" }"}, {"sha": "de846a5cc6d2cc920fa77a452a0eaa6f150e8808", "filename": "crates/hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -3,7 +3,6 @@\n use tracing::debug;\n \n use mbe::ExpandResult;\n-use parser::FragmentKind;\n use syntax::{\n     ast::{self, AstNode, GenericParamsOwner, ModuleItemOwner, NameOwner},\n     match_ast,\n@@ -73,7 +72,7 @@ struct BasicAdtInfo {\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, mbe::ExpandError> {\n-    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, FragmentKind::Items)?; // FragmentKind::Items doesn't parse attrs?\n+    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, mbe::FragmentKind::Items)?; // FragmentKind::Items doesn't parse attrs?\n     let macro_items = ast::MacroItems::cast(parsed.syntax_node()).ok_or_else(|| {\n         debug!(\"derive node didn't parse\");\n         mbe::ExpandError::UnexpectedToken"}, {"sha": "a4b5632e32d5e1cbcbfd3afc5e9f574e181ca7ae", "filename": "crates/hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -554,17 +554,19 @@ fn option_env_expand(\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use crate::{\n-        name::AsName, test_db::TestDB, AstNode, EagerCallInfo, MacroCallId, MacroCallKind,\n-        MacroCallLoc,\n-    };\n+    use std::sync::Arc;\n+\n     use base_db::{fixture::WithFixture, SourceDatabase};\n     use expect_test::{expect, Expect};\n-    use parser::FragmentKind;\n-    use std::sync::Arc;\n     use syntax::ast::NameOwner;\n \n+    use crate::{\n+        name::AsName, test_db::TestDB, AstNode, EagerCallInfo, ExpandTo, MacroCallId,\n+        MacroCallKind, MacroCallLoc,\n+    };\n+\n+    use super::*;\n+\n     fn expand_builtin_macro(ra_fixture: &str) -> String {\n         let (db, file_id) = TestDB::with_single_file(ra_fixture);\n         let parsed = db.parse(file_id);\n@@ -599,7 +601,7 @@ mod tests {\n                     eager: None,\n                     kind: MacroCallKind::FnLike {\n                         ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_call)),\n-                        fragment: FragmentKind::Expr,\n+                        expand_to: ExpandTo::Expr,\n                     },\n                 };\n \n@@ -614,7 +616,6 @@ mod tests {\n                     local_inner: false,\n                 };\n \n-                let fragment = crate::to_fragment_kind(&macro_call);\n                 let args = macro_call.token_tree().unwrap();\n                 let parsed_args = mbe::syntax_node_to_token_tree(args.syntax()).0;\n                 let call_id = AstId::new(file_id.into(), ast_id_map.ast_id(&macro_call));\n@@ -626,18 +627,19 @@ mod tests {\n                         arg_or_expansion: Arc::new(parsed_args.clone()),\n                         included_file: None,\n                     }),\n-                    kind: MacroCallKind::FnLike { ast_id: call_id, fragment: FragmentKind::Expr },\n+                    kind: MacroCallKind::FnLike { ast_id: call_id, expand_to: ExpandTo::Expr },\n                 });\n \n                 let expanded = expander.expand(&db, arg_id, &parsed_args).value.unwrap();\n+                let expand_to = crate::ExpandTo::from_call_site(&macro_call);\n                 let loc = MacroCallLoc {\n                     def,\n                     krate,\n                     eager: Some(EagerCallInfo {\n                         arg_or_expansion: Arc::new(expanded.subtree),\n                         included_file: expanded.included_file,\n                     }),\n-                    kind: MacroCallKind::FnLike { ast_id: call_id, fragment },\n+                    kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n                 };\n \n                 let id: MacroCallId = db.intern_macro(loc);"}, {"sha": "84bf5aea90f94c6d8d5ee0263fdb1d97aff3bb3b", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -6,17 +6,16 @@ use base_db::{salsa, SourceDatabase};\n use itertools::Itertools;\n use limit::Limit;\n use mbe::{ExpandError, ExpandResult};\n-use parser::{FragmentKind, T};\n use syntax::{\n     algo::diff,\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, GreenNode, Parse, SyntaxNode, SyntaxToken, TextRange,\n+    AstNode, GreenNode, Parse, SyntaxNode, SyntaxToken, TextRange, T,\n };\n \n use crate::{\n     ast_id_map::AstIdMap, hygiene::HygieneFrame, BuiltinAttrExpander, BuiltinDeriveExpander,\n-    BuiltinFnLikeExpander, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind, MacroCallLoc,\n-    MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n+    BuiltinFnLikeExpander, ExpandTo, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind,\n+    MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -157,10 +156,9 @@ pub fn expand_speculative(\n \n     let speculative_expansion = macro_def.expand(db, actual_macro_call, &tt);\n \n-    let fragment_kind = macro_fragment_kind(db, actual_macro_call);\n+    let expand_to = macro_expand_to(db, actual_macro_call);\n \n-    let (node, tmap_2) =\n-        mbe::token_tree_to_syntax_node(&speculative_expansion.value, fragment_kind).ok()?;\n+    let (node, tmap_2) = token_tree_to_syntax_node(&speculative_expansion.value, expand_to).ok()?;\n \n     let token_id = macro_def.map_id_down(token_id);\n     let range = tmap_2.first_range_by_token(token_id, token_to_map.kind())?;\n@@ -215,17 +213,17 @@ fn parse_macro_expansion(\n         None => return ExpandResult { value: None, err: result.err },\n     };\n \n-    let fragment_kind = macro_fragment_kind(db, macro_file.macro_call_id);\n+    let expand_to = macro_expand_to(db, macro_file.macro_call_id);\n \n     tracing::debug!(\"expanded = {}\", tt.as_debug_string());\n-    tracing::debug!(\"kind = {:?}\", fragment_kind);\n+    tracing::debug!(\"kind = {:?}\", expand_to);\n \n-    let (parse, rev_token_map) = match mbe::token_tree_to_syntax_node(&tt, fragment_kind) {\n+    let (parse, rev_token_map) = match token_tree_to_syntax_node(&tt, expand_to) {\n         Ok(it) => it,\n         Err(err) => {\n             tracing::debug!(\n                 \"failed to parse expansion to {:?} = {}\",\n-                fragment_kind,\n+                expand_to,\n                 tt.as_debug_string()\n             );\n             return ExpandResult::only_err(err);\n@@ -437,7 +435,21 @@ fn hygiene_frame(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<HygieneFrame>\n     Arc::new(HygieneFrame::new(db, file_id))\n }\n \n-fn macro_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n+fn macro_expand_to(db: &dyn AstDatabase, id: MacroCallId) -> ExpandTo {\n     let loc: MacroCallLoc = db.lookup_intern_macro(id);\n-    loc.kind.fragment_kind()\n+    loc.kind.expand_to()\n+}\n+\n+fn token_tree_to_syntax_node(\n+    tt: &tt::Subtree,\n+    expand_to: ExpandTo,\n+) -> Result<(Parse<SyntaxNode>, mbe::TokenMap), ExpandError> {\n+    let fragment = match expand_to {\n+        ExpandTo::Statements => mbe::FragmentKind::Statements,\n+        ExpandTo::Items => mbe::FragmentKind::Items,\n+        ExpandTo::Pattern => mbe::FragmentKind::Pattern,\n+        ExpandTo::Type => mbe::FragmentKind::Type,\n+        ExpandTo::Expr => mbe::FragmentKind::Expr,\n+    };\n+    mbe::token_tree_to_syntax_node(tt, fragment)\n }"}, {"sha": "e5cf1a5d237f7a417fea3117f1aee5889901e953", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -18,19 +18,19 @@\n //!\n //!\n //! See the full discussion : <https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Eager.20expansion.20of.20built-in.20macros>\n+use std::sync::Arc;\n+\n+use base_db::CrateId;\n+use mbe::ExpandResult;\n+use syntax::{ted, SyntaxNode};\n \n use crate::{\n     ast::{self, AstNode},\n     db::AstDatabase,\n-    EagerCallInfo, InFile, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind,\n+    EagerCallInfo, ExpandTo, InFile, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId,\n+    MacroDefKind,\n };\n \n-use base_db::CrateId;\n-use mbe::ExpandResult;\n-use parser::FragmentKind;\n-use std::sync::Arc;\n-use syntax::{ted, SyntaxNode};\n-\n #[derive(Debug)]\n pub struct ErrorEmitted {\n     _private: (),\n@@ -113,7 +113,7 @@ pub fn expand_eager_macro(\n \n     let ast_map = db.ast_id_map(macro_call.file_id);\n     let call_id = InFile::new(macro_call.file_id, ast_map.ast_id(&macro_call.value));\n-    let fragment = crate::to_fragment_kind(&macro_call.value);\n+    let expand_to = ExpandTo::from_call_site(&macro_call.value);\n \n     // Note:\n     // When `lazy_expand` is called, its *parent* file must be already exists.\n@@ -126,12 +126,13 @@ pub fn expand_eager_macro(\n             arg_or_expansion: Arc::new(parsed_args.clone()),\n             included_file: None,\n         }),\n-        kind: MacroCallKind::FnLike { ast_id: call_id, fragment: FragmentKind::Expr },\n+        kind: MacroCallKind::FnLike { ast_id: call_id, expand_to: ExpandTo::Expr },\n     });\n     let arg_file_id = arg_id;\n \n-    let parsed_args =\n-        diagnostic_sink.result(mbe::token_tree_to_syntax_node(&parsed_args, FragmentKind::Expr))?.0;\n+    let parsed_args = diagnostic_sink\n+        .result(mbe::token_tree_to_syntax_node(&parsed_args, mbe::FragmentKind::Expr))?\n+        .0;\n     let result = eager_macro_recur(\n         db,\n         InFile::new(arg_file_id.as_file(), parsed_args.syntax_node()),\n@@ -153,7 +154,7 @@ pub fn expand_eager_macro(\n                 arg_or_expansion: Arc::new(expanded.subtree),\n                 included_file: expanded.included_file,\n             }),\n-            kind: MacroCallKind::FnLike { ast_id: call_id, fragment },\n+            kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n         };\n \n         Ok(db.intern_macro(loc))\n@@ -176,11 +177,11 @@ fn lazy_expand(\n ) -> ExpandResult<Option<InFile<SyntaxNode>>> {\n     let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n \n-    let fragment = crate::to_fragment_kind(&macro_call.value);\n+    let expand_to = ExpandTo::from_call_site(&macro_call.value);\n     let id = def.as_lazy_macro(\n         db,\n         krate,\n-        MacroCallKind::FnLike { ast_id: macro_call.with_value(ast_id), fragment },\n+        MacroCallKind::FnLike { ast_id: macro_call.with_value(ast_id), expand_to },\n     );\n \n     let err = db.macro_expand_error(id);"}, {"sha": "959cd73b5df6cf3d68e03164c1ffc8f58a3191b9", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -8,10 +8,9 @@ use base_db::CrateId;\n use db::TokenExpander;\n use either::Either;\n use mbe::Origin;\n-use parser::SyntaxKind;\n use syntax::{\n     ast::{self, AttrsOwner},\n-    AstNode, SyntaxNode, TextRange, TextSize,\n+    AstNode, SyntaxKind, SyntaxNode, TextRange, TextSize,\n };\n \n use crate::{"}, {"sha": "a814a2886d29bb75e7851d61e4d6e76cc9000a11", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 59, "deletions": 37, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -19,7 +19,6 @@ use base_db::ProcMacroKind;\n use either::Either;\n \n pub use mbe::{ExpandError, ExpandResult};\n-pub use parser::FragmentKind;\n \n use std::{hash::Hash, iter, sync::Arc};\n \n@@ -268,7 +267,7 @@ pub struct MacroCallLoc {\n pub enum MacroCallKind {\n     FnLike {\n         ast_id: AstId<ast::MacroCall>,\n-        fragment: FragmentKind,\n+        expand_to: ExpandTo,\n     },\n     Derive {\n         ast_id: AstId<ast::Item>,\n@@ -327,11 +326,11 @@ impl MacroCallKind {\n         }\n     }\n \n-    fn fragment_kind(&self) -> FragmentKind {\n+    fn expand_to(&self) -> ExpandTo {\n         match self {\n-            MacroCallKind::FnLike { fragment, .. } => *fragment,\n-            MacroCallKind::Derive { .. } => FragmentKind::Items,\n-            MacroCallKind::Attr { .. } => FragmentKind::Items, // is this always correct?\n+            MacroCallKind::FnLike { expand_to, .. } => *expand_to,\n+            MacroCallKind::Derive { .. } => ExpandTo::Items,\n+            MacroCallKind::Attr { .. } => ExpandTo::Items, // is this always correct?\n         }\n     }\n }\n@@ -653,38 +652,61 @@ impl<N: AstNode> InFile<N> {\n     }\n }\n \n-/// Given a `MacroCallId`, return what `FragmentKind` it belongs to.\n-/// FIXME: Not completed\n-pub fn to_fragment_kind(call: &ast::MacroCall) -> FragmentKind {\n-    use syntax::SyntaxKind::*;\n-\n-    let syn = call.syntax();\n-\n-    let parent = match syn.parent() {\n-        Some(it) => it,\n-        None => return FragmentKind::Statements,\n-    };\n-\n-    match parent.kind() {\n-        MACRO_ITEMS | SOURCE_FILE | ITEM_LIST => FragmentKind::Items,\n-        MACRO_STMTS | EXPR_STMT | BLOCK_EXPR => FragmentKind::Statements,\n-        MACRO_PAT => FragmentKind::Pattern,\n-        MACRO_TYPE => FragmentKind::Type,\n-\n-        ARG_LIST | TRY_EXPR | TUPLE_EXPR | PAREN_EXPR | ARRAY_EXPR | FOR_EXPR | PATH_EXPR\n-        | CLOSURE_EXPR | CONDITION | BREAK_EXPR | RETURN_EXPR | MATCH_EXPR | MATCH_ARM\n-        | MATCH_GUARD | RECORD_EXPR_FIELD | CALL_EXPR | INDEX_EXPR | METHOD_CALL_EXPR\n-        | FIELD_EXPR | AWAIT_EXPR | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR => {\n-            FragmentKind::Expr\n-        }\n-        LET_STMT => {\n-            // FIXME: Handle LHS Pattern\n-            FragmentKind::Expr\n-        }\n+/// In Rust, macros expand token trees to token trees. When we want to turn a\n+/// token tree into an AST node, we need to figure out what kind of AST node we\n+/// want: something like `foo` can be a type, an expression, or a pattern.\n+///\n+/// Naively, one would think that \"what this expands to\" is a property of a\n+/// particular macro: macro `m1` returns an item, while macro `m2` returns an\n+/// expression, etc. That's not the case -- macros are polymorphic in the\n+/// result, and can expand to any type of the AST node.\n+///\n+/// What defines the actual AST node is the syntactic context of the macro\n+/// invocation. As a contrived example, in `let T![*] = T![*];` the first `T`\n+/// expands to a pattern, while the second one expands to an expression.\n+///\n+/// `ExpandTo` captures this bit of information about a particular macro call\n+/// site.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum ExpandTo {\n+    Statements,\n+    Items,\n+    Pattern,\n+    Type,\n+    Expr,\n+}\n \n-        _ => {\n-            // Unknown , Just guess it is `Items`\n-            FragmentKind::Items\n+impl ExpandTo {\n+    pub fn from_call_site(call: &ast::MacroCall) -> ExpandTo {\n+        use syntax::SyntaxKind::*;\n+\n+        let syn = call.syntax();\n+\n+        let parent = match syn.parent() {\n+            Some(it) => it,\n+            None => return ExpandTo::Statements,\n+        };\n+\n+        match parent.kind() {\n+            MACRO_ITEMS | SOURCE_FILE | ITEM_LIST => ExpandTo::Items,\n+            MACRO_STMTS | EXPR_STMT | BLOCK_EXPR => ExpandTo::Statements,\n+            MACRO_PAT => ExpandTo::Pattern,\n+            MACRO_TYPE => ExpandTo::Type,\n+\n+            ARG_LIST | TRY_EXPR | TUPLE_EXPR | PAREN_EXPR | ARRAY_EXPR | FOR_EXPR | PATH_EXPR\n+            | CLOSURE_EXPR | CONDITION | BREAK_EXPR | RETURN_EXPR | MATCH_EXPR | MATCH_ARM\n+            | MATCH_GUARD | RECORD_EXPR_FIELD | CALL_EXPR | INDEX_EXPR | METHOD_CALL_EXPR\n+            | FIELD_EXPR | AWAIT_EXPR | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR\n+            | BIN_EXPR => ExpandTo::Expr,\n+            LET_STMT => {\n+                // FIXME: Handle LHS Pattern\n+                ExpandTo::Expr\n+            }\n+\n+            _ => {\n+                // Unknown , Just guess it is `Items`\n+                ExpandTo::Items\n+            }\n         }\n     }\n }"}, {"sha": "13fec269faba764d22878568f26ce33bf2340a7e", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -18,13 +18,15 @@ mod token_map;\n \n use std::fmt;\n \n-pub use tt::{Delimiter, DelimiterKind, Punct};\n-\n use crate::{\n     parser::{parse_pattern, parse_template, MetaTemplate, Op},\n     tt_iter::TtIter,\n };\n \n+// FIXME: we probably should re-think  `token_tree_to_syntax_node` interfaces\n+pub use ::parser::FragmentKind;\n+pub use tt::{Delimiter, DelimiterKind, Punct};\n+\n #[derive(Debug, PartialEq, Eq)]\n pub enum ParseError {\n     UnexpectedToken(String),\n@@ -39,7 +41,7 @@ pub enum ExpandError {\n     UnexpectedToken,\n     BindingError(String),\n     ConversionError,\n-    // FXME: no way mbe should know about proc macros.\n+    // FIXME: no way mbe should know about proc macros.\n     UnresolvedProcMacro,\n     Other(String),\n }"}, {"sha": "2d3c612146a4fe86987a505b4379c5c6b4b10260", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use parser::{FragmentKind, ParseError, TreeSink};\n+use parser::{ParseError, TreeSink};\n use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, make::tokens::doc_comment},\n@@ -12,8 +12,9 @@ use syntax::{\n };\n use tt::buffer::{Cursor, TokenBuffer};\n \n-use crate::{subtree_source::SubtreeTokenSource, tt_iter::TtIter};\n-use crate::{ExpandError, TokenMap};\n+use crate::{\n+    subtree_source::SubtreeTokenSource, tt_iter::TtIter, ExpandError, FragmentKind, TokenMap,\n+};\n \n /// Convert the syntax node to a `TokenTree` (what macro\n /// will consume)."}, {"sha": "30cafdac7bbdeab032fe49cde0899e8d508c8965", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -3,10 +3,11 @@ mod rule;\n \n use std::fmt::Write;\n \n-use ::parser::FragmentKind;\n use syntax::{ast, AstNode, NodeOrToken, SyntaxNode, WalkEvent};\n use test_utils::assert_eq_text;\n \n+use crate::FragmentKind;\n+\n use super::*;\n \n pub(crate) struct MacroFixture {"}, {"sha": "d883e723012ad7a3d3eea58a7552a028cb0943ba", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb702cfc1419850e7d208a1b375e4a69dbe8e87/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=dbb702cfc1419850e7d208a1b375e4a69dbe8e87", "patch": "@@ -98,12 +98,8 @@ pub enum FragmentKind {\n     Block,\n     Visibility,\n     MetaItem,\n-\n-    // These kinds are used when parsing the result of expansion\n-    // FIXME: use separate fragment kinds for macro inputs and outputs?\n     Items,\n     Statements,\n-\n     Attr,\n }\n "}]}