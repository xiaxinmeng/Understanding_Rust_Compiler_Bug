{"sha": "711273f5b49bacb843d672884522cd6961037669", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMTI3M2Y1YjQ5YmFjYjg0M2Q2NzI4ODQ1MjJjZDY5NjEwMzc2Njk=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-06-23T23:16:57Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-06-24T04:04:02Z"}, "message": "Implement the fixed output size versions of the SHA-2 digest functions.", "tree": {"sha": "1adfee92371140df3490fbcd9c198cf3c9fa98e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1adfee92371140df3490fbcd9c198cf3c9fa98e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/711273f5b49bacb843d672884522cd6961037669", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/711273f5b49bacb843d672884522cd6961037669", "html_url": "https://github.com/rust-lang/rust/commit/711273f5b49bacb843d672884522cd6961037669", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/711273f5b49bacb843d672884522cd6961037669/comments", "author": null, "committer": null, "parents": [{"sha": "89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "html_url": "https://github.com/rust-lang/rust/commit/89eef0b139f0d16844155429a65fc1ac2ea4cd9f"}], "stats": {"total": 1128, "additions": 1128, "deletions": 0}, "files": [{"sha": "60169b347ad84f61c4ab1ccce66e88ad4a98bbd4", "filename": "RELEASES.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/711273f5b49bacb843d672884522cd6961037669/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/711273f5b49bacb843d672884522cd6961037669/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=711273f5b49bacb843d672884522cd6961037669", "patch": "@@ -78,6 +78,7 @@ Version 0.7 (July 2013)\n       * extra: `BigInt`, `BigUint` implement numeric and comparison traits.\n       * extra: `term` uses terminfo now, is more correct.\n       * extra: `arc` functions converted to methods.\n+      * extra: Implementation of fixed output size variations of SHA-2.\n \n    * Tooling\n       * `unused_unsafe` lint mode for detecting unnecessary `unsafe` blocks."}, {"sha": "dd179fde70f5b7bde978b6bfd326490585138c38", "filename": "src/libextra/crypto/sha2.rs", "status": "added", "additions": 1125, "deletions": 0, "changes": 1125, "blob_url": "https://github.com/rust-lang/rust/blob/711273f5b49bacb843d672884522cd6961037669/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/711273f5b49bacb843d672884522cd6961037669/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=711273f5b49bacb843d672884522cd6961037669", "patch": "@@ -0,0 +1,1125 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::uint;\n+use core::vec;\n+\n+use digest::Digest;\n+\n+// BitCounter is a specialized structure intended simply for counting the\n+// number of bits that have been processed by the SHA-2 512 family of functions.\n+// It does very little overflow checking since such checking is not necessary\n+// for how it is used. A more generic structure would have to do this checking.\n+// So, don't copy this structure and use it elsewhere!\n+struct BitCounter {\n+    high_bit_count: u64,\n+    low_byte_count: u64\n+}\n+\n+impl BitCounter {\n+    fn add_bytes(&mut self, bytes: uint) {\n+        self.low_byte_count += bytes as u64;\n+        if(self.low_byte_count > 0x1fffffffffffffffu64) {\n+            self.high_bit_count += (self.low_byte_count >> 61);\n+            self.low_byte_count &= 0x1fffffffffffffffu64;\n+        }\n+    }\n+\n+    fn reset(&mut self) {\n+        self.low_byte_count = 0;\n+        self.high_bit_count = 0;\n+    }\n+\n+    fn get_low_bit_count(&self) -> u64 {\n+        self.low_byte_count << 3\n+    }\n+\n+    fn get_high_bit_count(&self) -> u64 {\n+        self.high_bit_count\n+    }\n+}\n+\n+// A structure that represents that state of a digest computation\n+// for the SHA-2 512 family of digest functions\n+struct Engine512 {\n+    input_buffer: [u8, ..8],\n+    input_buffer_idx: uint,\n+    bit_counter: BitCounter,\n+    H0: u64,\n+    H1: u64,\n+    H2: u64,\n+    H3: u64,\n+    H4: u64,\n+    H5: u64,\n+    H6: u64,\n+    H7: u64,\n+    W: [u64, ..80],\n+    W_idx: uint,\n+    finished: bool,\n+}\n+\n+// Convert a [u8] to a u64 in big-endian format\n+fn to_u64(in: &[u8]) -> u64 {\n+    (in[0] as u64) << 56 |\n+    (in[1] as u64) << 48 |\n+    (in[2] as u64) << 40 |\n+    (in[3] as u64) << 32 |\n+    (in[4] as u64) << 24 |\n+    (in[5] as u64) << 16 |\n+    (in[6] as u64) << 8 |\n+    (in[7] as u64)\n+}\n+\n+// Convert a u64 to a [u8] in big endian format\n+fn from_u64(in: u64, out: &mut [u8]) {\n+    out[0] = (in >> 56) as u8;\n+    out[1] = (in >> 48) as u8;\n+    out[2] = (in >> 40) as u8;\n+    out[3] = (in >> 32) as u8;\n+    out[4] = (in >> 24) as u8;\n+    out[5] = (in >> 16) as u8;\n+    out[6] = (in >> 8) as u8;\n+    out[7] = in as u8;\n+}\n+\n+impl Engine512 {\n+    fn input_byte(&mut self, in: u8) {\n+        assert!(!self.finished)\n+\n+        self.input_buffer[self.input_buffer_idx] = in;\n+        self.input_buffer_idx += 1;\n+\n+        if (self.input_buffer_idx == 8) {\n+            self.input_buffer_idx = 0;\n+            let w = to_u64(self.input_buffer);\n+            self.process_word(w);\n+        }\n+\n+        self.bit_counter.add_bytes(1);\n+    }\n+\n+    fn input_vec(&mut self, in: &[u8]) {\n+        assert!(!self.finished)\n+\n+        let mut i = 0;\n+\n+        while i < in.len() && self.input_buffer_idx != 0 {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+        while in.len() - i >= 8 {\n+            let w = to_u64(vec::slice(in, i, i + 8));\n+            self.process_word(w);\n+            self.bit_counter.add_bytes(8);\n+            i += 8;\n+        }\n+\n+        while i < in.len() {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+    }\n+\n+    fn reset(&mut self) {\n+        self.bit_counter.reset();\n+        self.finished = false;\n+        self.input_buffer_idx = 0;\n+        self.W_idx = 0;\n+    }\n+\n+    fn process_word(&mut self, in: u64) {\n+        self.W[self.W_idx] = in;\n+        self.W_idx += 1;\n+        if (self.W_idx == 16) {\n+            self.W_idx = 0;\n+            self.process_block();\n+        }\n+    }\n+\n+    fn process_block(&mut self) {\n+        fn ch(x: u64, y: u64, z: u64) -> u64 {\n+            ((x & y) ^ ((!x) & z))\n+        }\n+\n+        fn maj(x: u64, y: u64, z: u64) -> u64 {\n+            ((x & y) ^ (x & z) ^ (y & z))\n+        }\n+\n+        fn sum0(x: u64) -> u64 {\n+            ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39))\n+        }\n+\n+        fn sum1(x: u64) -> u64 {\n+            ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41))\n+        }\n+\n+        fn sigma0(x: u64) -> u64 {\n+            ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7)\n+        }\n+\n+        fn sigma1(x: u64) -> u64 {\n+            ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n+        }\n+\n+        for uint::range(16, 80) |t| {\n+            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n+                self.W[t - 16];\n+        }\n+\n+        let mut a = self.H0;\n+        let mut b = self.H1;\n+        let mut c = self.H2;\n+        let mut d = self.H3;\n+        let mut e = self.H4;\n+        let mut f = self.H5;\n+        let mut g = self.H6;\n+        let mut h = self.H7;\n+\n+        let mut t = 0;\n+        for uint::range(0, 10) |_| {\n+            h += sum1(e) + ch(e, f, g) + K64[t] + self.W[t];\n+            d += h;\n+            h += sum0(a) + maj(a, b, c);\n+            t += 1;\n+\n+            g += sum1(d) + ch(d, e, f) + K64[t] + self.W[t];\n+            c += g;\n+            g += sum0(h) + maj(h, a, b);\n+            t += 1;\n+\n+            f += sum1(c) + ch(c, d, e) + K64[t] + self.W[t];\n+            b += f;\n+            f += sum0(g) + maj(g, h, a);\n+            t += 1;\n+\n+            e += sum1(b) + ch(b, c, d) + K64[t] + self.W[t];\n+            a += e;\n+            e += sum0(f) + maj(f, g, h);\n+            t += 1;\n+\n+            d += sum1(a) + ch(a, b, c) + K64[t] + self.W[t];\n+            h += d;\n+            d += sum0(e) + maj(e, f, g);\n+            t += 1;\n+\n+            c += sum1(h) + ch(h, a, b) + K64[t] + self.W[t];\n+            g += c;\n+            c += sum0(d) + maj(d, e, f);\n+            t += 1;\n+\n+            b += sum1(g) + ch(g, h, a) + K64[t] + self.W[t];\n+            f += b;\n+            b += sum0(c) + maj(c, d, e);\n+            t += 1;\n+\n+            a += sum1(f) + ch(f, g, h) + K64[t] + self.W[t];\n+            e += a;\n+            a += sum0(b) + maj(b, c, d);\n+            t += 1;\n+        }\n+\n+        self.H0 += a;\n+        self.H1 += b;\n+        self.H2 += c;\n+        self.H3 += d;\n+        self.H4 += e;\n+        self.H5 += f;\n+        self.H6 += g;\n+        self.H7 += h;\n+    }\n+\n+    fn finish(&mut self) {\n+        if (self.finished) {\n+            return;\n+        }\n+\n+        // must get message length before padding is added\n+        let high_bit_count = self.bit_counter.get_high_bit_count();\n+        let low_bit_count = self.bit_counter.get_low_bit_count();\n+\n+        // add padding\n+        self.input_byte(128u8);\n+\n+        while self.input_buffer_idx != 0 {\n+            self.input_byte(0u8);\n+        }\n+\n+        // add length\n+        if (self.W_idx > 14) {\n+            for uint::range(self.W_idx, 16) |_| {\n+                self.process_word(0);\n+            }\n+        }\n+\n+        while self.W_idx < 14 {\n+            self.process_word(0);\n+        }\n+\n+        self.process_word(high_bit_count);\n+        self.process_word(low_bit_count);\n+\n+        self.finished = true;\n+    }\n+\n+    fn result_512(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n+        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n+        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n+        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n+        from_u64(self.H4, vec::mut_slice(out, 32, 40));\n+        from_u64(self.H5, vec::mut_slice(out, 40, 48));\n+        from_u64(self.H6, vec::mut_slice(out, 48, 56));\n+        from_u64(self.H7, vec::mut_slice(out, 56, 64));\n+    }\n+\n+    fn result_384(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n+        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n+        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n+        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n+        from_u64(self.H4, vec::mut_slice(out, 32, 40));\n+        from_u64(self.H5, vec::mut_slice(out, 40, 48));\n+    }\n+\n+    fn result_256(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n+        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n+        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n+        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n+    }\n+\n+    fn result_224(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n+        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n+        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n+        from_u32((self.H3 >> 32) as u32, vec::mut_slice(out, 24, 28));\n+    }\n+}\n+\n+// Constants necessary for SHA-2 512 family of digests.\n+static K64: [u64, ..80] = [\n+    0x428a2f98d728ae22u64, 0x7137449123ef65cdu64, 0xb5c0fbcfec4d3b2fu64, 0xe9b5dba58189dbbcu64,\n+    0x3956c25bf348b538u64, 0x59f111f1b605d019u64, 0x923f82a4af194f9bu64, 0xab1c5ed5da6d8118u64,\n+    0xd807aa98a3030242u64, 0x12835b0145706fbeu64, 0x243185be4ee4b28cu64, 0x550c7dc3d5ffb4e2u64,\n+    0x72be5d74f27b896fu64, 0x80deb1fe3b1696b1u64, 0x9bdc06a725c71235u64, 0xc19bf174cf692694u64,\n+    0xe49b69c19ef14ad2u64, 0xefbe4786384f25e3u64, 0x0fc19dc68b8cd5b5u64, 0x240ca1cc77ac9c65u64,\n+    0x2de92c6f592b0275u64, 0x4a7484aa6ea6e483u64, 0x5cb0a9dcbd41fbd4u64, 0x76f988da831153b5u64,\n+    0x983e5152ee66dfabu64, 0xa831c66d2db43210u64, 0xb00327c898fb213fu64, 0xbf597fc7beef0ee4u64,\n+    0xc6e00bf33da88fc2u64, 0xd5a79147930aa725u64, 0x06ca6351e003826fu64, 0x142929670a0e6e70u64,\n+    0x27b70a8546d22ffcu64, 0x2e1b21385c26c926u64, 0x4d2c6dfc5ac42aedu64, 0x53380d139d95b3dfu64,\n+    0x650a73548baf63deu64, 0x766a0abb3c77b2a8u64, 0x81c2c92e47edaee6u64, 0x92722c851482353bu64,\n+    0xa2bfe8a14cf10364u64, 0xa81a664bbc423001u64, 0xc24b8b70d0f89791u64, 0xc76c51a30654be30u64,\n+    0xd192e819d6ef5218u64, 0xd69906245565a910u64, 0xf40e35855771202au64, 0x106aa07032bbd1b8u64,\n+    0x19a4c116b8d2d0c8u64, 0x1e376c085141ab53u64, 0x2748774cdf8eeb99u64, 0x34b0bcb5e19b48a8u64,\n+    0x391c0cb3c5c95a63u64, 0x4ed8aa4ae3418acbu64, 0x5b9cca4f7763e373u64, 0x682e6ff3d6b2b8a3u64,\n+    0x748f82ee5defb2fcu64, 0x78a5636f43172f60u64, 0x84c87814a1f0ab72u64, 0x8cc702081a6439ecu64,\n+    0x90befffa23631e28u64, 0xa4506cebde82bde9u64, 0xbef9a3f7b2c67915u64, 0xc67178f2e372532bu64,\n+    0xca273eceea26619cu64, 0xd186b8c721c0c207u64, 0xeada7dd6cde0eb1eu64, 0xf57d4f7fee6ed178u64,\n+    0x06f067aa72176fbau64, 0x0a637dc5a2c898a6u64, 0x113f9804bef90daeu64, 0x1b710b35131c471bu64,\n+    0x28db77f523047d84u64, 0x32caab7b40c72493u64, 0x3c9ebe0a15c9bebcu64, 0x431d67c49c100d4cu64,\n+    0x4cc5d4becb3e42b6u64, 0x597f299cfc657e2au64, 0x5fcb6fab3ad6faecu64, 0x6c44198c4a475817u64\n+];\n+\n+// A structure that represents that state of a digest computation\n+// for the SHA-2 256 family of digest functions\n+struct Engine256 {\n+    input_buffer: [u8, ..4],\n+    input_buffer_idx: uint,\n+    length_bytes: u64,\n+    H0: u32,\n+    H1: u32,\n+    H2: u32,\n+    H3: u32,\n+    H4: u32,\n+    H5: u32,\n+    H6: u32,\n+    H7: u32,\n+    W: [u32, ..64],\n+    W_idx: uint,\n+    finished: bool\n+}\n+\n+// Convert a [u8] to a u32 in big endian format\n+fn to_u32(in: &[u8]) -> u32 {\n+    (in[0] as u32) << 24 |\n+    (in[1] as u32) << 16 |\n+    (in[2] as u32) << 8 |\n+    (in[3] as u32)\n+}\n+\n+// Convert a u32 to a [u8] in big endian format\n+fn from_u32(in: u32, out: &mut [u8]) {\n+    out[0] = (in >> 24) as u8;\n+    out[1] = (in >> 16) as u8;\n+    out[2] = (in >> 8) as u8;\n+    out[3] = in as u8;\n+}\n+\n+impl Engine256 {\n+    fn input_byte(&mut self, in: u8) {\n+        assert!(!self.finished)\n+\n+        self.input_buffer[self.input_buffer_idx] = in;\n+        self.input_buffer_idx += 1;\n+\n+        if (self.input_buffer_idx == 4) {\n+            self.input_buffer_idx = 0;\n+            let w = to_u32(self.input_buffer);\n+            self.process_word(w);\n+        }\n+\n+        self.length_bytes += 1;\n+    }\n+\n+    fn input_vec(&mut self, in: &[u8]) {\n+        assert!(!self.finished)\n+\n+        let mut i = 0;\n+\n+        while i < in.len() && self.input_buffer_idx != 0 {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+        while in.len() - i >= 4 {\n+            let w = to_u32(vec::slice(in, i, i + 4));\n+            self.process_word(w);\n+            self.length_bytes += 4;\n+            i += 4;\n+        }\n+\n+        while i < in.len() {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+    }\n+\n+    fn reset(&mut self) {\n+        self.length_bytes = 0;\n+        self.finished = false;\n+        self.input_buffer_idx = 0;\n+        self.W_idx = 0;\n+    }\n+\n+    fn process_word(&mut self, in: u32) {\n+        self.W[self.W_idx] = in;\n+        self.W_idx += 1;\n+        if (self.W_idx == 16) {\n+            self.W_idx = 0;\n+            self.process_block();\n+        }\n+    }\n+\n+    fn process_block(&mut self) {\n+        fn ch(x: u32, y: u32, z: u32) -> u32 {\n+            ((x & y) ^ ((!x) & z))\n+        }\n+\n+        fn maj(x: u32, y: u32, z: u32) -> u32 {\n+            ((x & y) ^ (x & z) ^ (y & z))\n+        }\n+\n+        fn sum0(x: u32) -> u32 {\n+            ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))\n+        }\n+\n+        fn sum1(x: u32) -> u32 {\n+            ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))\n+        }\n+\n+        fn sigma0(x: u32) -> u32 {\n+            ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)\n+        }\n+\n+        fn sigma1(x: u32) -> u32 {\n+            ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n+        }\n+\n+        for uint::range(16, 64) |t| {\n+            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n+                self.W[t - 16];\n+        }\n+\n+        let mut a = self.H0;\n+        let mut b = self.H1;\n+        let mut c = self.H2;\n+        let mut d = self.H3;\n+        let mut e = self.H4;\n+        let mut f = self.H5;\n+        let mut g = self.H6;\n+        let mut h = self.H7;\n+\n+        let mut t = 0;\n+        for uint::range(0, 8) |_| {\n+            h += sum1(e) + ch(e, f, g) + K32[t] + self.W[t];\n+            d += h;\n+            h += sum0(a) + maj(a, b, c);\n+            t += 1;\n+\n+            g += sum1(d) + ch(d, e, f) + K32[t] + self.W[t];\n+            c += g;\n+            g += sum0(h) + maj(h, a, b);\n+            t += 1;\n+\n+            f += sum1(c) + ch(c, d, e) + K32[t] + self.W[t];\n+            b += f;\n+            f += sum0(g) + maj(g, h, a);\n+            t += 1;\n+\n+            e += sum1(b) + ch(b, c, d) + K32[t] + self.W[t];\n+            a += e;\n+            e += sum0(f) + maj(f, g, h);\n+            t += 1;\n+\n+            d += sum1(a) + ch(a, b, c) + K32[t] + self.W[t];\n+            h += d;\n+            d += sum0(e) + maj(e, f, g);\n+            t += 1;\n+\n+            c += sum1(h) + ch(h, a, b) + K32[t] + self.W[t];\n+            g += c;\n+            c += sum0(d) + maj(d, e, f);\n+            t += 1;\n+\n+            b += sum1(g) + ch(g, h, a) + K32[t] + self.W[t];\n+            f += b;\n+            b += sum0(c) + maj(c, d, e);\n+            t += 1;\n+\n+            a += sum1(f) + ch(f, g, h) + K32[t] + self.W[t];\n+            e += a;\n+            a += sum0(b) + maj(b, c, d);\n+            t += 1;\n+        }\n+\n+        self.H0 += a;\n+        self.H1 += b;\n+        self.H2 += c;\n+        self.H3 += d;\n+        self.H4 += e;\n+        self.H5 += f;\n+        self.H6 += g;\n+        self.H7 += h;\n+    }\n+\n+    fn finish(&mut self) {\n+        if (self.finished) {\n+            return;\n+        }\n+\n+        // must get length before adding padding\n+        let bit_length = self.length_bytes << 3;\n+\n+        // add padding\n+        self.input_byte(128u8);\n+\n+        while self.input_buffer_idx != 0 {\n+            self.input_byte(0u8);\n+        }\n+\n+        // add length\n+        if (self.W_idx > 14) {\n+            for uint::range(self.W_idx, 16) |_| {\n+                self.process_word(0);\n+            }\n+        }\n+\n+        while self.W_idx < 14 {\n+            self.process_word(0);\n+        }\n+\n+        self.process_word((bit_length >> 32) as u32);\n+        self.process_word(bit_length as u32);\n+\n+        self.finished = true;\n+    }\n+\n+    fn result_256(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u32(self.H0, vec::mut_slice(out, 0, 4));\n+        from_u32(self.H1, vec::mut_slice(out, 4, 8));\n+        from_u32(self.H2, vec::mut_slice(out, 8, 12));\n+        from_u32(self.H3, vec::mut_slice(out, 12, 16));\n+        from_u32(self.H4, vec::mut_slice(out, 16, 20));\n+        from_u32(self.H5, vec::mut_slice(out, 20, 24));\n+        from_u32(self.H6, vec::mut_slice(out, 24, 28));\n+        from_u32(self.H7, vec::mut_slice(out, 28, 32));\n+    }\n+\n+    fn result_224(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u32(self.H0, vec::mut_slice(out, 0, 4));\n+        from_u32(self.H1, vec::mut_slice(out, 4, 8));\n+        from_u32(self.H2, vec::mut_slice(out, 8, 12));\n+        from_u32(self.H3, vec::mut_slice(out, 12, 16));\n+        from_u32(self.H4, vec::mut_slice(out, 16, 20));\n+        from_u32(self.H5, vec::mut_slice(out, 20, 24));\n+        from_u32(self.H6, vec::mut_slice(out, 24, 28));\n+    }\n+}\n+\n+static K32: [u32, ..64] = [\n+    0x428a2f98u32, 0x71374491u32, 0xb5c0fbcfu32, 0xe9b5dba5u32,\n+    0x3956c25bu32, 0x59f111f1u32, 0x923f82a4u32, 0xab1c5ed5u32,\n+    0xd807aa98u32, 0x12835b01u32, 0x243185beu32, 0x550c7dc3u32,\n+    0x72be5d74u32, 0x80deb1feu32, 0x9bdc06a7u32, 0xc19bf174u32,\n+    0xe49b69c1u32, 0xefbe4786u32, 0x0fc19dc6u32, 0x240ca1ccu32,\n+    0x2de92c6fu32, 0x4a7484aau32, 0x5cb0a9dcu32, 0x76f988dau32,\n+    0x983e5152u32, 0xa831c66du32, 0xb00327c8u32, 0xbf597fc7u32,\n+    0xc6e00bf3u32, 0xd5a79147u32, 0x06ca6351u32, 0x14292967u32,\n+    0x27b70a85u32, 0x2e1b2138u32, 0x4d2c6dfcu32, 0x53380d13u32,\n+    0x650a7354u32, 0x766a0abbu32, 0x81c2c92eu32, 0x92722c85u32,\n+    0xa2bfe8a1u32, 0xa81a664bu32, 0xc24b8b70u32, 0xc76c51a3u32,\n+    0xd192e819u32, 0xd6990624u32, 0xf40e3585u32, 0x106aa070u32,\n+    0x19a4c116u32, 0x1e376c08u32, 0x2748774cu32, 0x34b0bcb5u32,\n+    0x391c0cb3u32, 0x4ed8aa4au32, 0x5b9cca4fu32, 0x682e6ff3u32,\n+    0x748f82eeu32, 0x78a5636fu32, 0x84c87814u32, 0x8cc70208u32,\n+    0x90befffau32, 0xa4506cebu32, 0xbef9a3f7u32, 0xc67178f2u32\n+];\n+\n+struct Sha512 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha384 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha512Trunc256 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha512Trunc224 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha256 {\n+    priv engine: Engine256\n+}\n+\n+struct Sha224 {\n+    priv engine: Engine256\n+}\n+\n+impl Sha512 {\n+    /**\n+     * Construct an new instance of a SHA-512 digest.\n+     */\n+    pub fn new() -> Sha512 {\n+        Sha512 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x6a09e667f3bcc908u64,\n+                H1: 0xbb67ae8584caa73bu64,\n+                H2: 0x3c6ef372fe94f82bu64,\n+                H3: 0xa54ff53a5f1d36f1u64,\n+                H4: 0x510e527fade682d1u64,\n+                H5: 0x9b05688c2b3e6c1fu64,\n+                H6: 0x1f83d9abfb41bd6bu64,\n+                H7: 0x5be0cd19137e2179u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha384 {\n+    /**\n+     * Construct an new instance of a SHA-384 digest.\n+     */\n+    pub fn new() -> Sha384 {\n+        Sha384 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0xcbbb9d5dc1059ed8u64,\n+                H1: 0x629a292a367cd507u64,\n+                H2: 0x9159015a3070dd17u64,\n+                H3: 0x152fecd8f70e5939u64,\n+                H4: 0x67332667ffc00b31u64,\n+                H5: 0x8eb44a8768581511u64,\n+                H6: 0xdb0c2e0d64f98fa7u64,\n+                H7: 0x47b5481dbefa4fa4u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha512Trunc256 {\n+    /**\n+     * Construct an new instance of a SHA-512/256 digest.\n+     */\n+    pub fn new() -> Sha512Trunc256 {\n+        Sha512Trunc256 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x22312194fc2bf72cu64,\n+                H1: 0x9f555fa3c84c64c2u64,\n+                H2: 0x2393b86b6f53b151u64,\n+                H3: 0x963877195940eabdu64,\n+                H4: 0x96283ee2a88effe3u64,\n+                H5: 0xbe5e1e2553863992u64,\n+                H6: 0x2b0199fc2c85b8aau64,\n+                H7: 0x0eb72ddc81c52ca2u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha512Trunc224 {\n+    /**\n+     * Construct an new instance of a SHA-512/224 digest.\n+     */\n+    pub fn new() -> Sha512Trunc224 {\n+        Sha512Trunc224 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x8c3d37c819544da2u64,\n+                H1: 0x73e1996689dcd4d6u64,\n+                H2: 0x1dfab7ae32ff9c82u64,\n+                H3: 0x679dd514582f9fcfu64,\n+                H4: 0x0f6d2b697bd44da8u64,\n+                H5: 0x77e36f7304c48942u64,\n+                H6: 0x3f9d85a86a1d36c8u64,\n+                H7: 0x1112e6ad91d692a1u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha256 {\n+    /**\n+     * Construct an new instance of a SHA-256 digest.\n+     */\n+    pub fn new() -> Sha256 {\n+        Sha256 {\n+            engine: Engine256 {\n+                input_buffer: [0u8, ..4],\n+                input_buffer_idx: 0,\n+                length_bytes: 0,\n+                H0: 0x6a09e667u32,\n+                H1: 0xbb67ae85u32,\n+                H2: 0x3c6ef372u32,\n+                H3: 0xa54ff53au32,\n+                H4: 0x510e527fu32,\n+                H5: 0x9b05688cu32,\n+                H6: 0x1f83d9abu32,\n+                H7: 0x5be0cd19u32,\n+                W: [0u32, ..64],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha224 {\n+    /**\n+     * Construct an new instance of a SHA-224 digest.\n+     */\n+    pub fn new() -> Sha224 {\n+        Sha224 {\n+            engine: Engine256 {\n+                input_buffer: [0u8, ..4],\n+                input_buffer_idx: 0,\n+                length_bytes: 0,\n+                H0: 0xc1059ed8u32,\n+                H1: 0x367cd507u32,\n+                H2: 0x3070dd17u32,\n+                H3: 0xf70e5939u32,\n+                H4: 0xffc00b31u32,\n+                H5: 0x68581511u32,\n+                H6: 0x64f98fa7u32,\n+                H7: 0xbefa4fa4u32,\n+                W: [0u32, ..64],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Digest for Sha512 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_512(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x6a09e667f3bcc908u64;\n+        self.engine.H1 = 0xbb67ae8584caa73bu64;\n+        self.engine.H2 = 0x3c6ef372fe94f82bu64;\n+        self.engine.H3 = 0xa54ff53a5f1d36f1u64;\n+        self.engine.H4 = 0x510e527fade682d1u64;\n+        self.engine.H5 = 0x9b05688c2b3e6c1fu64;\n+        self.engine.H6 = 0x1f83d9abfb41bd6bu64;\n+        self.engine.H7 = 0x5be0cd19137e2179u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 512 }\n+}\n+\n+impl Digest for Sha384 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_384(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0xcbbb9d5dc1059ed8u64;\n+        self.engine.H1 = 0x629a292a367cd507u64;\n+        self.engine.H2 = 0x9159015a3070dd17u64;\n+        self.engine.H3 = 0x152fecd8f70e5939u64;\n+        self.engine.H4 = 0x67332667ffc00b31u64;\n+        self.engine.H5 = 0x8eb44a8768581511u64;\n+        self.engine.H6 = 0xdb0c2e0d64f98fa7u64;\n+        self.engine.H7 = 0x47b5481dbefa4fa4u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 384 }\n+}\n+\n+impl Digest for Sha512Trunc256 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_256(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x22312194fc2bf72cu64;\n+        self.engine.H1 = 0x9f555fa3c84c64c2u64;\n+        self.engine.H2 = 0x2393b86b6f53b151u64;\n+        self.engine.H3 = 0x963877195940eabdu64;\n+        self.engine.H4 = 0x96283ee2a88effe3u64;\n+        self.engine.H5 = 0xbe5e1e2553863992u64;\n+        self.engine.H6 = 0x2b0199fc2c85b8aau64;\n+        self.engine.H7 = 0x0eb72ddc81c52ca2u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 256 }\n+}\n+\n+impl Digest for Sha512Trunc224 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_224(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x8c3d37c819544da2u64;\n+        self.engine.H1 = 0x73e1996689dcd4d6u64;\n+        self.engine.H2 = 0x1dfab7ae32ff9c82u64;\n+        self.engine.H3 = 0x679dd514582f9fcfu64;\n+        self.engine.H4 = 0x0f6d2b697bd44da8u64;\n+        self.engine.H5 = 0x77e36f7304c48942u64;\n+        self.engine.H6 = 0x3f9d85a86a1d36c8u64;\n+        self.engine.H7 = 0x1112e6ad91d692a1u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 224 }\n+}\n+\n+impl Digest for Sha256 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_256(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x6a09e667u32;\n+        self.engine.H1 = 0xbb67ae85u32;\n+        self.engine.H2 = 0x3c6ef372u32;\n+        self.engine.H3 = 0xa54ff53au32;\n+        self.engine.H4 = 0x510e527fu32;\n+        self.engine.H5 = 0x9b05688cu32;\n+        self.engine.H6 = 0x1f83d9abu32;\n+        self.engine.H7 = 0x5be0cd19u32;\n+    }\n+\n+    fn output_bits(&self) -> uint { 256 }\n+}\n+\n+impl Digest for Sha224 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_224(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0xc1059ed8u32;\n+        self.engine.H1 = 0x367cd507u32;\n+        self.engine.H2 = 0x3070dd17u32;\n+        self.engine.H3 = 0xf70e5939u32;\n+        self.engine.H4 = 0xffc00b31u32;\n+        self.engine.H5 = 0x68581511u32;\n+        self.engine.H6 = 0x64f98fa7u32;\n+        self.engine.H7 = 0xbefa4fa4u32;\n+    }\n+\n+    fn output_bits(&self) -> uint { 224 }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use digest::{Digest, DigestUtil};\n+    use sha2::{Sha512, Sha384, Sha512Trunc256, Sha512Trunc224, Sha256, Sha224};\n+\n+    struct Test {\n+        input: ~str,\n+        output_str: ~str,\n+    }\n+\n+    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n+        // Test that it works when accepting the message all at once\n+        for tests.iter().advance() |t| {\n+            sh.input_str(t.input);\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+\n+        // Test that it works when accepting the message in pieces\n+        for tests.iter().advance() |t| {\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sha512() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\" +\n+                             \"47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb64\" +\n+                             \"2e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"91ea1245f20d46ae9a037a989f54f1f790f0a47607eeb8a14d12890cea77a1bb\" +\n+                             \"c6c7ed9cf205e67b7f2b8fd4c7dfd3a7a8617e45f3c463d481c7e586c39ac1ed\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha384() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"38b060a751ac96384cd9327eb1b1e36a21fdb71114be0743\" +\n+                             \"4c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"ca737f1014a48f4c0b6dd43cb177b0afd9e5169367544c49\" +\n+                             \"4011e3317dbf9a509cb1e5dc1e85a941bbee3d7f2afbc9b1\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"ed892481d8272ca6df370bf706e4d7bc1b5739fa2177aae6\" +\n+                             \"c50e946678718fc67a7af2819a021c2fc34e91bdb63409d7\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha384::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha512_256() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"dd9d67b371519c339ed8dbd25af90e976a1eeefd4ad3d889005e532fc5bef04d\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"1546741840f8a492b959d9b8b2344b9b0eb51b004bba35c0aebaac86d45264c3\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512Trunc256::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha512_224() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"944cd2847fb54558d4775db0485a50003111c8e5daa63fe722c6aa37\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"6d6a9279495ec4061769752e7ff9c68b6b0b3c5a281b7917ce0572de\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512Trunc224::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha256() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha256::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha224() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"619cba8e8e05826e9b8c519c0a5c68f4fb653e8a3d8aa04bb2c8cd4c\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha224::new();\n+\n+        test_hash(sh, tests);\n+    }\n+}"}, {"sha": "11aebdf467ff29ac7ba8857d0b26adcb3156f0ac", "filename": "src/libextra/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/711273f5b49bacb843d672884522cd6961037669/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/711273f5b49bacb843d672884522cd6961037669/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=711273f5b49bacb843d672884522cd6961037669", "patch": "@@ -91,6 +91,8 @@ pub mod treemap;\n pub mod digest;\n #[path=\"crypto/sha1.rs\"]\n pub mod sha1;\n+#[path=\"crypto/sha2.rs\"]\n+pub mod sha2;\n \n // And ... other stuff\n "}]}