{"sha": "7daa1c92ec551488601f28fc788440003aee40f3", "node_id": "C_kwDOAAsO6NoAKDdkYWExYzkyZWM1NTE0ODg2MDFmMjhmYzc4ODQ0MDAwM2FlZTQwZjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-04-24T16:00:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-24T16:00:27Z"}, "message": "Rollup merge of #96303 - jyn514:improved-bootstrap-tests, r=Mark-Simulacrum\n\nImprove bootstrap tests\n\n- Don't checkout submodules in bootstrap tests\n\n  This doesn't cause any tests to fail, and can greatly speed them up.\n\n- Add a test for --exclude test::XXX\n\n  I didn't know that the `test::` syntax was valid before, and it doesn't seem to be documented anywhere. Add a test so it doesn't regress accidentally, and as executable documentation.\n  This also moves the `exclude` tests out of `dist`, to avoid assertion errors when the `cmd` passed to configure didn't match the `subcommand` used.\n\n- Use run_build helper consistently across most bootstrap tests\n  This is not super important to do, but the consistency is nice.\n\n  I didn't change any tests that call `configure(\"dist\")` and then override the subcommand - doing\nthat at all is pretty sketchy, but I don't want to mess with it while already doing a refactor.\n\nFound while working on the \"one call to Step for all paths\" change mentioned in https://github.com/rust-lang/rust/pull/95503#issuecomment-1105914384, but independent of that work.\n\ncc `@pietroalbini` for the `--exclude` test, git blame says you added support for it originally.", "tree": {"sha": "262f0fcca73b3074cde92aec30f9f2da0eaf6dba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/262f0fcca73b3074cde92aec30f9f2da0eaf6dba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7daa1c92ec551488601f28fc788440003aee40f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiZXQbCRBK7hj4Ov3rIwAAprUIAG1YZsWyKsbERti53m+7Nk5J\nqIOGEb1NDeRyhgjb+1+8yj7WtGG9KEBbmdakqYUf/O0MzDyH2dTHxgCTmjK9U3H0\n45HneeG7nOclA086uyAl4/1o+6a4ZsaTtbd6AzjGh1LNAfc+stCaCI1oVlZ3riyg\nnTnSqbsE5hEduGIqVA8YoDDLLbAzpHjp8JwIc317+RleUy0YEY4LefW/eel9g9W3\nFn28ldoaIpvxvMT5LbWMSlBz6h9PRKWU8fpM6ZMLT3bCBEgDy3uWw7yOCmCorIY7\n9UvxDx710Qn2zdBy6vIZVVr2Vo7gm6FWrWXAcwFnWkwXfxHL6byxP05FhjZnrRY=\n=Qm05\n-----END PGP SIGNATURE-----\n", "payload": "tree 262f0fcca73b3074cde92aec30f9f2da0eaf6dba\nparent e1935cc1961ffd81a728589158b1ba982010564b\nparent 3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1650816027 +0200\ncommitter GitHub <noreply@github.com> 1650816027 +0200\n\nRollup merge of #96303 - jyn514:improved-bootstrap-tests, r=Mark-Simulacrum\n\nImprove bootstrap tests\n\n- Don't checkout submodules in bootstrap tests\n\n  This doesn't cause any tests to fail, and can greatly speed them up.\n\n- Add a test for --exclude test::XXX\n\n  I didn't know that the `test::` syntax was valid before, and it doesn't seem to be documented anywhere. Add a test so it doesn't regress accidentally, and as executable documentation.\n  This also moves the `exclude` tests out of `dist`, to avoid assertion errors when the `cmd` passed to configure didn't match the `subcommand` used.\n\n- Use run_build helper consistently across most bootstrap tests\n  This is not super important to do, but the consistency is nice.\n\n  I didn't change any tests that call `configure(\"dist\")` and then override the subcommand - doing\nthat at all is pretty sketchy, but I don't want to mess with it while already doing a refactor.\n\nFound while working on the \"one call to Step for all paths\" change mentioned in https://github.com/rust-lang/rust/pull/95503#issuecomment-1105914384, but independent of that work.\n\ncc `@pietroalbini` for the `--exclude` test, git blame says you added support for it originally.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7daa1c92ec551488601f28fc788440003aee40f3", "html_url": "https://github.com/rust-lang/rust/commit/7daa1c92ec551488601f28fc788440003aee40f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7daa1c92ec551488601f28fc788440003aee40f3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1935cc1961ffd81a728589158b1ba982010564b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1935cc1961ffd81a728589158b1ba982010564b", "html_url": "https://github.com/rust-lang/rust/commit/e1935cc1961ffd81a728589158b1ba982010564b"}, {"sha": "3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f", "html_url": "https://github.com/rust-lang/rust/commit/3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f"}], "stats": {"total": 248, "additions": 129, "deletions": 119}, "files": [{"sha": "3b6cd7564f08ae57e77365128feefc9908217ba3", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 107, "deletions": 119, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/7daa1c92ec551488601f28fc788440003aee40f3/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daa1c92ec551488601f28fc788440003aee40f3/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=7daa1c92ec551488601f28fc788440003aee40f3", "patch": "@@ -7,6 +7,7 @@ fn configure(cmd: &str, host: &[&str], target: &[&str]) -> Config {\n     // don't save toolstates\n     config.save_toolstates = None;\n     config.dry_run = true;\n+    config.submodules = Some(false);\n     config.ninja_in_file = false;\n     // try to avoid spurious failures in dist where we create/delete each others file\n     // HACK: rather than pull in `tempdir`, use the one that cargo has conveniently created for us\n@@ -25,68 +26,102 @@ fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n     v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n }\n \n+fn run_build(paths: &[PathBuf], config: Config) -> Cache {\n+    let kind = config.cmd.kind();\n+    let build = Build::new(config);\n+    let builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(kind), paths);\n+    builder.cache\n+}\n+\n+#[test]\n+fn test_exclude() {\n+    let mut config = configure(\"test\", &[\"A\"], &[\"A\"]);\n+    config.exclude = vec![TaskPath::parse(\"src/tools/tidy\")];\n+    let cache = run_build(&[], config);\n+\n+    // Ensure we have really excluded tidy\n+    assert!(!cache.contains::<test::Tidy>());\n+\n+    // Ensure other tests are not affected.\n+    assert!(cache.contains::<test::RustdocUi>());\n+}\n+\n+#[test]\n+fn test_exclude_kind() {\n+    let path = PathBuf::from(\"src/tools/cargotest\");\n+    let exclude = TaskPath::parse(\"test::src/tools/cargotest\");\n+    assert_eq!(exclude, TaskPath { kind: Some(Kind::Test), path: path.clone() });\n+\n+    let mut config = configure(\"test\", &[\"A\"], &[\"A\"]);\n+    // Ensure our test is valid, and `test::Cargotest` would be run without the exclude.\n+    assert!(run_build(&[path.clone()], config.clone()).contains::<test::Cargotest>());\n+    // Ensure tests for cargotest are skipped.\n+    config.exclude = vec![exclude.clone()];\n+    assert!(!run_build(&[path.clone()], config).contains::<test::Cargotest>());\n+\n+    // Ensure builds for cargotest are not skipped.\n+    let mut config = configure(\"build\", &[\"A\"], &[\"A\"]);\n+    config.exclude = vec![exclude];\n+    assert!(run_build(&[path], config).contains::<tool::CargoTest>());\n+}\n+\n mod defaults {\n-    use super::{configure, first};\n+    use super::{configure, first, run_build};\n     use crate::builder::*;\n     use crate::Config;\n     use pretty_assertions::assert_eq;\n \n     #[test]\n     fn build_default() {\n-        let build = Build::new(configure(\"build\", &[\"A\"], &[\"A\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+        let mut cache = run_build(&[], configure(\"build\", &[\"A\"], &[\"A\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[\n                 compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n             ]\n         );\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert!(!cache.all::<compile::Assemble>().is_empty());\n         // Make sure rustdoc is only built once.\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             // Recall that rustdoc stages are off-by-one\n             // - this is the compiler it's _linked_ to, not built with.\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } }],\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n+            first(cache.all::<compile::Rustc>()),\n             &[compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },]\n         );\n     }\n \n     #[test]\n     fn build_stage_0() {\n         let config = Config { stage: 0, ..configure(\"build\", &[\"A\"], &[\"A\"]) };\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+        let mut cache = run_build(&[], config);\n \n         let a = TargetSelection::from_user(\"A\");\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },]\n         );\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert!(!cache.all::<compile::Assemble>().is_empty());\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             // This is the beta rustdoc.\n             // Add an assert here to make sure this is the only rustdoc built.\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 0 } }],\n         );\n-        assert!(builder.cache.all::<compile::Rustc>().is_empty());\n+        assert!(cache.all::<compile::Rustc>().is_empty());\n     }\n \n     #[test]\n     fn build_cross_compile() {\n         let config = Config { stage: 1, ..configure(\"build\", &[\"A\", \"B\"], &[\"A\", \"B\"]) };\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+        let mut cache = run_build(&[], config);\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n@@ -97,7 +132,7 @@ mod defaults {\n         // (since we're producing stage 1 libraries/binaries).  But currently\n         // rustbuild is just a bit buggy here; this should be fixed though.\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[\n                 compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n@@ -106,22 +141,22 @@ mod defaults {\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n+            first(cache.all::<compile::Assemble>()),\n             &[\n                 compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n                 compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n                 compile::Assemble { target_compiler: Compiler { host: b, stage: 1 } },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             &[\n                 tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n                 tool::Rustdoc { compiler: Compiler { host: b, stage: 1 } },\n             ],\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n+            first(cache.all::<compile::Rustc>()),\n             &[\n                 compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: b },\n@@ -134,33 +169,28 @@ mod defaults {\n         let mut config = configure(\"doc\", &[\"A\"], &[\"A\"]);\n         config.compiler_docs = true;\n         config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n+        let mut cache = run_build(&[], config);\n         let a = TargetSelection::from_user(\"A\");\n \n         // error_index_generator uses stage 0 to share rustdoc artifacts with the\n         // rustdoc tool.\n+        assert_eq!(first(cache.all::<doc::ErrorIndex>()), &[doc::ErrorIndex { target: a },]);\n         assert_eq!(\n-            first(builder.cache.all::<doc::ErrorIndex>()),\n-            &[doc::ErrorIndex { target: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<tool::ErrorIndex>()),\n+            first(cache.all::<tool::ErrorIndex>()),\n             &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 0 } }]\n         );\n         // docs should be built with the beta compiler, not with the stage0 artifacts.\n         // recall that rustdoc is off-by-one: `stage` is the compiler rustdoc is _linked_ to,\n         // not the one it was built by.\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 0 } },]\n         );\n     }\n }\n \n mod dist {\n-    use super::{first, Config};\n+    use super::{first, run_build, Config};\n     use crate::builder::*;\n     use pretty_assertions::assert_eq;\n \n@@ -170,94 +200,88 @@ mod dist {\n \n     #[test]\n     fn dist_baseline() {\n-        let build = Build::new(configure(&[\"A\"], &[\"A\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\"], &[\"A\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n+        assert_eq!(first(cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n+        assert_eq!(first(cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n         // Make sure rustdoc is only built once.\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n         );\n     }\n \n     #[test]\n     fn dist_with_targets() {\n-        let build = Build::new(configure(&[\"A\"], &[\"A\", \"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\"], &[\"A\", \"B\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n+            first(cache.all::<dist::Docs>()),\n             &[dist::Docs { host: a }, dist::Docs { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n+            first(cache.all::<dist::Mingw>()),\n             &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n                 dist::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n             ]\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n     #[test]\n     fn dist_with_hosts() {\n-        let build = Build::new(configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n+            first(cache.all::<dist::Docs>()),\n             &[dist::Docs { host: a }, dist::Docs { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n+            first(cache.all::<dist::Mingw>()),\n             &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[\n                 dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n                 dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[\n                 compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n@@ -266,26 +290,25 @@ mod dist {\n                 compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n             ],\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n     #[test]\n     fn dist_only_cross_host() {\n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n-        let mut build = Build::new(configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n-        build.config.docs = false;\n-        build.config.extended = true;\n-        build.hosts = vec![b];\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut config = configure(&[\"A\", \"B\"], &[\"A\", \"B\"]);\n+        config.docs = false;\n+        config.extended = true;\n+        config.hosts = vec![b];\n+        let mut cache = run_build(&[], config);\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[dist::Rustc { compiler: Compiler { host: b, stage: 2 } },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n+            first(cache.all::<compile::Rustc>()),\n             &[\n                 compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n@@ -295,92 +318,86 @@ mod dist {\n \n     #[test]\n     fn dist_with_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"A\", \"B\"], &[\"A\", \"B\", \"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\", \"B\"], &[\"A\", \"B\", \"C\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n         let c = TargetSelection::from_user(\"C\");\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n+            first(cache.all::<dist::Docs>()),\n             &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n+            first(cache.all::<dist::Mingw>()),\n             &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[\n                 dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n                 dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n                 dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n             ]\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n     #[test]\n     fn dist_with_empty_host() {\n         let config = configure(&[], &[\"C\"]);\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], config);\n \n         let a = TargetSelection::from_user(\"A\");\n         let c = TargetSelection::from_user(\"C\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: c },]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: c },]);\n+        assert_eq!(first(cache.all::<dist::Docs>()), &[dist::Docs { host: c },]);\n+        assert_eq!(first(cache.all::<dist::Mingw>()), &[dist::Mingw { host: c },]);\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },]\n         );\n     }\n \n     #[test]\n     fn dist_with_same_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n+            first(cache.all::<dist::Docs>()),\n             &[dist::Docs { host: a }, dist::Docs { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n+            first(cache.all::<dist::Mingw>()),\n             &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[\n                 dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n                 dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n             ]\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[\n                 compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n@@ -390,7 +407,7 @@ mod dist {\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n+            first(cache.all::<compile::Assemble>()),\n             &[\n                 compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n                 compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n@@ -514,35 +531,6 @@ mod dist {\n         );\n     }\n \n-    #[test]\n-    fn test_exclude() {\n-        let mut config = configure(&[\"A\"], &[\"A\"]);\n-        config.exclude = vec![TaskPath::parse(\"src/tools/tidy\")];\n-        config.cmd = Subcommand::Test {\n-            paths: Vec::new(),\n-            test_args: Vec::new(),\n-            rustc_args: Vec::new(),\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            force_rerun: false,\n-            compare_mode: None,\n-            rustfix_coverage: false,\n-            pass: None,\n-            run: None,\n-        };\n-\n-        let build = Build::new(config);\n-        let builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-\n-        // Ensure we have really excluded tidy\n-        assert!(!builder.cache.contains::<test::Tidy>());\n-\n-        // Ensure other tests are not affected.\n-        assert!(builder.cache.contains::<test::RustdocUi>());\n-    }\n-\n     #[test]\n     fn doc_ci() {\n         let mut config = configure(&[\"A\"], &[\"A\"]);"}, {"sha": "1638d3ed3c2814fe19351268c733e540ea284002", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daa1c92ec551488601f28fc788440003aee40f3/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daa1c92ec551488601f28fc788440003aee40f3/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=7daa1c92ec551488601f28fc788440003aee40f3", "patch": "@@ -41,6 +41,7 @@ macro_rules! check_ci_llvm {\n /// each field, see the corresponding fields in\n /// `config.toml.example`.\n #[derive(Default)]\n+#[cfg_attr(test, derive(Clone))]\n pub struct Config {\n     pub changelog_seen: Option<usize>,\n     pub ccache: Option<String>,\n@@ -330,6 +331,7 @@ impl PartialEq<&str> for TargetSelection {\n \n /// Per-target configuration stored in the global configuration structure.\n #[derive(Default)]\n+#[cfg_attr(test, derive(Clone))]\n pub struct Target {\n     /// Some(path to llvm-config) if using an external LLVM.\n     pub llvm_config: Option<PathBuf>,"}, {"sha": "58571ea129c1940b68766ae64f5b78c9a78a19a7", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7daa1c92ec551488601f28fc788440003aee40f3/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daa1c92ec551488601f28fc788440003aee40f3/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=7daa1c92ec551488601f28fc788440003aee40f3", "patch": "@@ -14,6 +14,7 @@ use crate::setup::Profile;\n use crate::util::t;\n use crate::{Build, DocTests};\n \n+#[derive(Copy, Clone)]\n pub enum Color {\n     Always,\n     Never,\n@@ -79,6 +80,7 @@ pub struct Flags {\n     pub llvm_profile_generate: bool,\n }\n \n+#[cfg_attr(test, derive(Clone))]\n pub enum Subcommand {\n     Build {\n         paths: Vec<PathBuf>,\n@@ -668,6 +670,24 @@ Arguments:\n }\n \n impl Subcommand {\n+    pub fn kind(&self) -> Kind {\n+        match self {\n+            Subcommand::Bench { .. } => Kind::Bench,\n+            Subcommand::Build { .. } => Kind::Build,\n+            Subcommand::Check { .. } => Kind::Check,\n+            Subcommand::Clippy { .. } => Kind::Clippy,\n+            Subcommand::Doc { .. } => Kind::Doc,\n+            Subcommand::Fix { .. } => Kind::Fix,\n+            Subcommand::Format { .. } => Kind::Format,\n+            Subcommand::Test { .. } => Kind::Test,\n+            Subcommand::Clean { .. } => Kind::Clean,\n+            Subcommand::Dist { .. } => Kind::Dist,\n+            Subcommand::Install { .. } => Kind::Install,\n+            Subcommand::Run { .. } => Kind::Run,\n+            Subcommand::Setup { .. } => Kind::Setup,\n+        }\n+    }\n+\n     pub fn test_args(&self) -> Vec<&str> {\n         match *self {\n             Subcommand::Test { ref test_args, .. } | Subcommand::Bench { ref test_args, .. } => {"}]}