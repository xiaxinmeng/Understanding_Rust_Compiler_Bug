{"sha": "b548d8d77339eefb46ca6a0c38fa430ddb05017a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NDhkOGQ3NzMzOWVlZmI0NmNhNmEwYzM4ZmE0MzBkZGIwNTAxN2E=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-03T13:49:29Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-04T10:35:29Z"}, "message": "Refactor rewrite_call", "tree": {"sha": "763a8f2cfb2325b28b1e8442574ac7efc2bf1e6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/763a8f2cfb2325b28b1e8442574ac7efc2bf1e6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b548d8d77339eefb46ca6a0c38fa430ddb05017a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b548d8d77339eefb46ca6a0c38fa430ddb05017a", "html_url": "https://github.com/rust-lang/rust/commit/b548d8d77339eefb46ca6a0c38fa430ddb05017a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b548d8d77339eefb46ca6a0c38fa430ddb05017a/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a01ad304596832ac0b546265200f85e69e8723da", "url": "https://api.github.com/repos/rust-lang/rust/commits/a01ad304596832ac0b546265200f85e69e8723da", "html_url": "https://github.com/rust-lang/rust/commit/a01ad304596832ac0b546265200f85e69e8723da"}], "stats": {"total": 225, "additions": 105, "deletions": 120}, "files": [{"sha": "8ce2ea6d236a4c9177865541e51696798c46a0ef", "filename": "src/expr.rs", "status": "modified", "additions": 105, "deletions": 120, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/b548d8d77339eefb46ca6a0c38fa430ddb05017a/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b548d8d77339eefb46ca6a0c38fa430ddb05017a/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=b548d8d77339eefb46ca6a0c38fa430ddb05017a", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::cmp::{Ordering, min};\n-use std::mem::swap;\n use std::ops::Deref;\n use std::iter::ExactSizeIterator;\n use std::fmt::Write;\n@@ -1376,7 +1375,7 @@ impl Rewrite for ast::Arm {\n             ast::ExprKind::Tup(..) => (true, &**body),\n             _ => (false, &**body),\n         };\n-        extend &= context.config.fn_call_style() == IndentStyle::Block;\n+        extend &= context.use_block_indent();\n \n         let comma = arm_comma(&context.config, body);\n         let alt_block_sep = String::from(\"\\n\") +\n@@ -1697,17 +1696,17 @@ fn rewrite_call_inner(context: &RewriteContext,\n         .ok_or(Ordering::Greater)?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n-    let new_span = mk_sp(span_lo, span.hi);\n+    let args_span = mk_sp(span_lo, span.hi);\n \n     let (extendable, list_str) = rewrite_call_args(context,\n                                                    args,\n-                                                   new_span,\n+                                                   args_span,\n                                                    nested_shape,\n                                                    one_line_width,\n                                                    force_trailing_comma)\n         .ok_or(Ordering::Less)?;\n \n-    if !use_block_indent(context) && need_block_indent(&list_str, nested_shape) && !extendable {\n+    if !context.use_block_indent() && need_block_indent(&list_str, nested_shape) && !extendable {\n         let mut new_context = context.clone();\n         new_context.use_block = true;\n         return rewrite_call_inner(&new_context,\n@@ -1752,41 +1751,49 @@ fn rewrite_call_args(context: &RewriteContext,\n     // Try letting the last argument overflow to the next line with block\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n-    let overflow_last = can_be_overflowed(&item_context, args);\n+    let tactic = try_overflow_last_arg(&item_context, &mut item_vec, args, shape, one_line_width);\n \n-    let mut orig_last = None;\n-    let mut placeholder = None;\n-\n-    // Replace the last item with its first line to see if it fits with\n-    // first arguments.\n-    if overflow_last {\n-        let arg_shape = if use_block_indent(context) && is_extendable(args) {\n-            Shape {\n-                width: context.config.fn_call_width(),\n-                indent: shape.block().indent.block_unindent(context.config),\n-                offset: 0,\n-            }\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: if force_trailing_comma {\n+            SeparatorTactic::Always\n+        } else if context.inside_macro || !context.use_block_indent() {\n+            SeparatorTactic::Never\n         } else {\n-            shape.block()\n-        };\n-        let rewrite = args.last().unwrap().rewrite(&item_context, arg_shape);\n-        swap(&mut item_vec[args.len() - 1].item, &mut orig_last);\n+            context.config.trailing_comma()\n+        },\n+        shape: shape,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n \n-        if let Some(rewrite) = rewrite {\n-            let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n-            placeholder = Some(rewrite);\n+    write_list(&item_vec, &fmt).map(|args_str| (tactic != DefinitiveListTactic::Vertical, args_str))\n+}\n \n-            item_vec[args.len() - 1].item = rewrite_first_line;\n-        }\n-    }\n+fn try_overflow_last_arg(context: &RewriteContext,\n+                         item_vec: &mut Vec<ListItem>,\n+                         args: &[ptr::P<ast::Expr>],\n+                         shape: Shape,\n+                         one_line_width: usize)\n+                         -> DefinitiveListTactic {\n+    let overflow_last = can_be_overflowed(&context, args);\n \n-    let one_line_shape = Shape {\n-        width: one_line_width,\n-        ..shape\n+    // Replace the last item with its first line to see if it fits with\n+    // first arguments.\n+    let (orig_last, placeholder) = if overflow_last {\n+        last_arg_shape(&context, &item_vec, shape).map_or((None, None), |arg_shape| {\n+            rewrite_last_arg_with_overflow(&context,\n+                                           &args[args.len() - 1],\n+                                           &mut item_vec[args.len() - 1],\n+                                           arg_shape)\n+        })\n+    } else {\n+        (None, None)\n     };\n \n     let tactic =\n-        definitive_tactic(&item_vec,\n+        definitive_tactic(&*item_vec,\n                           ListTactic::LimitedHorizontalVertical(context.config.fn_call_width()),\n                           one_line_width);\n \n@@ -1802,100 +1809,78 @@ fn rewrite_call_args(context: &RewriteContext,\n         (false, _, _) => {}\n     }\n \n-    let mut fmt = ListFormatting {\n-        tactic: tactic,\n-        separator: \",\",\n-        trailing_separator: if force_trailing_comma {\n-            SeparatorTactic::Always\n-        } else if context.inside_macro || context.config.fn_call_style() == IndentStyle::Visual ||\n-                  args.len() <= 1 {\n-            SeparatorTactic::Never\n-        } else {\n-            context.config.trailing_comma()\n-        },\n-        shape: one_line_shape,\n-        ends_with_newline: false,\n-        config: context.config,\n-    };\n+    tactic\n+}\n \n-    let one_line_budget = min(one_line_width, context.config.fn_call_width());\n-    let almost_no_newline =\n-        item_vec\n-            .iter()\n-            .rev()\n-            .skip(1)\n-            .all(|item| item.item.as_ref().map_or(false, |s| !s.contains('\\n')));\n-    let extendable = almost_no_newline &&\n-                     item_vec.iter().fold(0, |acc, item| {\n-        acc + item.item.as_ref().map_or(0, |s| 2 + first_line_width(s))\n-    }) <= one_line_budget + 2;\n-\n-    let result = write_list(&item_vec, &fmt);\n-    let last_char_is_not_comma = result\n-        .as_ref()\n-        .map_or(false, |r| r.chars().last().unwrap_or(' ') != ',');\n-    match result {\n-        // If arguments do not fit in a single line and do not contain newline,\n-        // try to put it on the next line. Try this only when we are in block mode\n-        // and not rewriting macro.\n-        Some(ref s) if use_block_indent(context) && !context.inside_macro &&\n-                       ((!can_be_overflowed(context, args) && last_char_is_not_comma &&\n-                         s.contains('\\n')) ||\n-                        first_line_width(s) > one_line_budget) => {\n-            fmt.trailing_separator = SeparatorTactic::Vertical;\n-            fmt.tactic = DefinitiveListTactic::Vertical;\n-            write_list(&item_vec, &fmt).map(|rw| (false, rw))\n-        }\n-        rewrite @ _ => {\n-            rewrite.map(|rw| (extendable && (last_char_is_not_comma || force_trailing_comma), rw))\n-        }\n-    }\n+fn last_arg_shape(context: &RewriteContext, items: &Vec<ListItem>, shape: Shape) -> Option<Shape> {\n+    let overhead = items.iter().rev().skip(1).fold(0, |acc, i| {\n+        acc + i.item.as_ref().map_or(0, |s| first_line_width(&s))\n+    });\n+    let max_width = min(context.config.fn_call_width(), shape.width);\n+    let arg_indent = if context.use_block_indent() {\n+        shape.block().indent.block_unindent(context.config)\n+    } else {\n+        shape.block().indent\n+    };\n+    Some(Shape {\n+             width: try_opt!(max_width.checked_sub(overhead)),\n+             indent: arg_indent,\n+             offset: 0,\n+         })\n }\n \n-fn use_block_indent(context: &RewriteContext) -> bool {\n-    context.config.fn_call_style() == IndentStyle::Block || context.use_block\n+fn rewrite_last_arg_with_overflow(context: &RewriteContext,\n+                                  last_arg: &ptr::P<ast::Expr>,\n+                                  last_item: &mut ListItem,\n+                                  shape: Shape)\n+                                  -> (Option<String>, Option<String>) {\n+    let rewrite = last_arg.rewrite(context, shape);\n+    let orig_last = last_item.item.clone();\n+\n+    if let Some(rewrite) = rewrite {\n+        let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n+        last_item.item = rewrite_first_line;\n+        (orig_last, Some(rewrite))\n+    } else {\n+        (orig_last, None)\n+    }\n }\n \n fn can_be_overflowed(context: &RewriteContext, args: &[ptr::P<ast::Expr>]) -> bool {\n-    match args.last().map(|x| &x.node) {\n-        Some(&ast::ExprKind::Match(..)) => {\n-            (use_block_indent(context) && args.len() == 1) ||\n-            (context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1)\n-        }\n-        Some(&ast::ExprKind::Block(..)) |\n-        Some(&ast::ExprKind::Closure(..)) => {\n-            use_block_indent(context) ||\n-            context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1\n-        }\n-        Some(&ast::ExprKind::Call(..)) |\n-        Some(&ast::ExprKind::Mac(..)) |\n-        Some(&ast::ExprKind::Struct(..)) => use_block_indent(context) && args.len() == 1,\n-        Some(&ast::ExprKind::Tup(..)) => use_block_indent(context),\n-        _ => false,\n-    }\n+    args.last()\n+        .map_or(false, |x| can_be_overflowed_expr(context, &x, args.len()))\n }\n \n-fn is_extendable(args: &[ptr::P<ast::Expr>]) -> bool {\n-    if args.len() == 1 {\n-        match args[0].node {\n-            ast::ExprKind::Block(..) |\n-            ast::ExprKind::Call(..) |\n-            ast::ExprKind::Closure(..) |\n-            ast::ExprKind::Match(..) |\n-            ast::ExprKind::Mac(..) |\n-            ast::ExprKind::Struct(..) |\n-            ast::ExprKind::Tup(..) => true,\n-            _ => false,\n-        }\n-    } else if args.len() > 1 {\n-        match args[args.len() - 1].node {\n-            ast::ExprKind::Block(..) |\n-            ast::ExprKind::Closure(..) |\n-            ast::ExprKind::Tup(..) => true,\n-            _ => false,\n-        }\n-    } else {\n-        false\n+fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n+    match expr.node {\n+        ast::ExprKind::Match(..) => {\n+            (context.use_block_indent() && args_len == 1) ||\n+            (context.config.fn_call_style() == IndentStyle::Visual && args_len > 1)\n+        }\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::ForLoop(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) => {\n+            context.use_block_indent() && args_len == 1\n+        }\n+        ast::ExprKind::Block(..) |\n+        ast::ExprKind::Closure(..) => {\n+            context.use_block_indent() ||\n+            context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n+        }\n+        ast::ExprKind::Call(..) |\n+        ast::ExprKind::MethodCall(..) |\n+        ast::ExprKind::Mac(..) |\n+        ast::ExprKind::Struct(..) => context.use_block_indent() && args_len == 1,\n+        ast::ExprKind::Tup(..) => context.use_block_indent(),\n+        ast::ExprKind::AddrOf(_, ref expr) |\n+        ast::ExprKind::Box(ref expr) |\n+        ast::ExprKind::Try(ref expr) |\n+        ast::ExprKind::Unary(_, ref expr) |\n+        ast::ExprKind::Cast(ref expr, _) => can_be_overflowed_expr(context, expr, args_len),\n+        _ => false,\n     }\n }\n \n@@ -1905,7 +1890,7 @@ fn wrap_args_with_parens(context: &RewriteContext,\n                          shape: Shape,\n                          nested_shape: Shape)\n                          -> String {\n-    if !use_block_indent(context) || (context.inside_macro && !args_str.contains('\\n')) ||\n+    if !context.use_block_indent() || (context.inside_macro && !args_str.contains('\\n')) ||\n        is_extendable {\n         if context.config.spaces_within_parens() && args_str.len() > 0 {\n             format!(\"( {} )\", args_str)\n@@ -2102,7 +2087,7 @@ fn shape_from_fn_call_style(context: &RewriteContext,\n                             overhead: usize,\n                             offset: usize)\n                             -> Option<Shape> {\n-    if use_block_indent(context) {\n+    if context.use_block_indent() {\n         Some(shape.block().block_indent(context.config.tab_spaces()))\n     } else {\n         shape.visual_indent(offset).sub_width(overhead)"}]}