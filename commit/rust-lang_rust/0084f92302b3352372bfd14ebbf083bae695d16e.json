{"sha": "0084f92302b3352372bfd14ebbf083bae695d16e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwODRmOTIzMDJiMzM1MjM3MmJmZDE0ZWJiZjA4M2JhZTY5NWQxNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-19T03:19:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-19T03:19:08Z"}, "message": "Auto merge of #23502 - Manishearth:rollup, r=Manishearth", "tree": {"sha": "7aeee112b2593dfc26968c2c3692371d9dc4a5ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aeee112b2593dfc26968c2c3692371d9dc4a5ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0084f92302b3352372bfd14ebbf083bae695d16e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0084f92302b3352372bfd14ebbf083bae695d16e", "html_url": "https://github.com/rust-lang/rust/commit/0084f92302b3352372bfd14ebbf083bae695d16e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0084f92302b3352372bfd14ebbf083bae695d16e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12cb7c6a2847959460ecac75b2c983d071585472", "url": "https://api.github.com/repos/rust-lang/rust/commits/12cb7c6a2847959460ecac75b2c983d071585472", "html_url": "https://github.com/rust-lang/rust/commit/12cb7c6a2847959460ecac75b2c983d071585472"}, {"sha": "6f930b99b0dbd548abb7bdd9eb9472d166f66811", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f930b99b0dbd548abb7bdd9eb9472d166f66811", "html_url": "https://github.com/rust-lang/rust/commit/6f930b99b0dbd548abb7bdd9eb9472d166f66811"}], "stats": {"total": 646, "additions": 532, "deletions": 114}, "files": [{"sha": "7fbe772b7f5bdd1171971509be08063c3adc86ee", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -19,7 +19,6 @@\n #![feature(unboxed_closures)]\n #![feature(std_misc)]\n #![feature(test)]\n-#![feature(core)]\n #![feature(path_ext)]\n \n #![deny(warnings)]"}, {"sha": "92573d792177362ad724278699f3d9d13cd2839c", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -2068,7 +2068,7 @@ type int8_t = i8;\n   item](#language-items) for more details.\n - `test` - indicates that this function is a test function, to only be compiled\n   in case of `--test`.\n-- `should_fail` - indicates that this test function should panic, inverting the success condition.\n+- `should_panic` - indicates that this test function should panic, inverting the success condition.\n - `cold` - The function is unlikely to be executed, so optimize it (and calls\n   to it) differently.\n "}, {"sha": "65ff42ffdcef411804fc99d4a1967b1632d0a637", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -562,6 +562,11 @@ place in the hierarchy instead. There's one more special form of `use`: you can\n people like to think of `self` as `.` and `super` as `..`, from many shells'\n display for the current directory and the parent directory.\n \n+Outside of `use`, paths are relative: `foo::bar()` refers to a function inside\n+of `foo` relative to where we are. If that's prefixed with `::`, as in\n+`::foo::bar()`, it refers to a different `foo`, an absolute path from your\n+crate root.\n+\n Also, note that we `pub use`d before we declared our `mod`s. Rust requires that\n `use` declarations go first.\n "}, {"sha": "8e8ee8d63d626e6112bf4ef46f86180cf0743e4d", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -179,7 +179,7 @@ Because this function will cause a crash, it will never return, and so it has\n the type '`!`', which is read \"diverges.\" A diverging function can be used\n as any type:\n \n-```should_fail\n+```should_panic\n # fn diverges() -> ! {\n #    panic!(\"This function never returns!\");\n # }"}, {"sha": "72e9ec9f7509ad9ccab80dba6298a07d30f7c8cf", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -129,11 +129,11 @@ $ echo $?\n \n This is useful if you want to integrate `cargo test` into other tooling.\n \n-We can invert our test's failure with another attribute: `should_fail`:\n+We can invert our test's failure with another attribute: `should_panic`:\n \n ```rust\n #[test]\n-#[should_fail]\n+#[should_panic]\n fn it_works() {\n     assert!(false);\n }\n@@ -163,13 +163,13 @@ equality:\n \n ```rust\n #[test]\n-#[should_fail]\n+#[should_panic]\n fn it_works() {\n     assert_eq!(\"Hello\", \"world\");\n }\n ```\n \n-Does this test pass or fail? Because of the `should_fail` attribute, it\n+Does this test pass or fail? Because of the `should_panic` attribute, it\n passes:\n \n ```bash\n@@ -189,15 +189,15 @@ running 0 tests\n test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n ```\n \n-`should_fail` tests can be fragile, as it's hard to guarantee that the test\n+`should_panic` tests can be fragile, as it's hard to guarantee that the test\n didn't fail for an unexpected reason. To help with this, an optional `expected`\n-parameter can be added to the `should_fail` attribute. The test harness will\n+parameter can be added to the `should_panic` attribute. The test harness will\n make sure that the failure message contains the provided text. A safer version\n of the example above would be:\n \n ```\n #[test]\n-#[should_fail(expected = \"assertion failed\")]\n+#[should_panic(expected = \"assertion failed\")]\n fn it_works() {\n     assert_eq!(\"Hello\", \"world\");\n }"}, {"sha": "d2abb59ffabc582eb8f0cb67cd93bd62b068e4f5", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -16,7 +16,7 @@\n //! This macro is implemented in the compiler to emit calls to this module in\n //! order to format arguments at runtime into strings and streams.\n //!\n-//! ## Usage\n+//! # Usage\n //!\n //! The `format!` macro is intended to be familiar to those coming from C's\n //! printf/fprintf functions or Python's `str.format` function. In its current\n@@ -41,7 +41,7 @@\n //! will then parse the format string and determine if the list of arguments\n //! provided is suitable to pass to this format string.\n //!\n-//! ### Positional parameters\n+//! ## Positional parameters\n //!\n //! Each formatting argument is allowed to specify which value argument it's\n //! referencing, and if omitted it is assumed to be \"the next argument\". For\n@@ -54,7 +54,7 @@\n //! iterator over the argument. Each time a \"next argument\" specifier is seen,\n //! the iterator advances. This leads to behavior like this:\n //!\n-//! ```rust\n+//! ```\n //! format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\"\n //! ```\n //!\n@@ -68,7 +68,7 @@\n //! compile-time error. You may refer to the same argument more than once in the\n //! format string, although it must always be referred to with the same type.\n //!\n-//! ### Named parameters\n+//! ## Named parameters\n //!\n //! Rust itself does not have a Python-like equivalent of named parameters to a\n //! function, but the `format!` macro is a syntax extension which allows it to\n@@ -91,7 +91,7 @@\n //! arguments which have names. Like with positional parameters, it is illegal\n //! to provide named parameters that are unused by the format string.\n //!\n-//! ### Argument types\n+//! ## Argument types\n //!\n //! Each argument's type is dictated by the format string. It is a requirement\n //! that every argument is only ever referred to by one type. For example, this\n@@ -105,18 +105,25 @@\n //! hexadecimal as well as an\n //! octal.\n //!\n-//! There are various parameters which do require a particular type, however.\n-//! Namely if the syntax `{:.*}` is used, then the number of characters to print\n-//! precedes the actual object being formatted, and the number of characters\n-//! must have the type `usize`. Although a `usize` can be printed with `{}`, it is\n-//! illegal to reference an argument as such. For example this is another\n+//! There are various parameters which do require a particular type, however. Namely, the `{:.*}`\n+//! syntax, which sets the number of numbers after the decimal in floating-point types:\n+//!\n+//! ```\n+//! let formatted_number = format!(\"{:.*}\", 2, 1.234567);\n+//!\n+//! assert_eq!(\"1.23\", formatted_number)\n+//! ```\n+//!\n+//! If this syntax is used, then the number of characters to print precedes the actual object being\n+//! formatted, and the number of characters must have the type `usize`. Although a `usize` can be\n+//! printed with `{}`, it is illegal to reference an argument as such. For example this is another\n //! invalid format string:\n //!\n //! ```text\n //! {:.*} {0}\n //! ```\n //!\n-//! ### Formatting traits\n+//! ## Formatting traits\n //!\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n@@ -142,7 +149,7 @@\n //! When implementing a format trait for your own type, you will have to\n //! implement a method of the signature:\n //!\n-//! ```rust\n+//! ```\n //! # use std::fmt;\n //! # struct Foo; // our custom type\n //! # impl fmt::Display for Foo {\n@@ -166,7 +173,7 @@\n //! An example of implementing the formatting traits would look\n //! like:\n //!\n-//! ```rust\n+//! ```\n //! use std::fmt;\n //! use std::f64;\n //! use std::num::Float;\n@@ -211,7 +218,7 @@\n //! }\n //! ```\n //!\n-//! #### fmt::Display vs fmt::Debug\n+//! ### fmt::Display vs fmt::Debug\n //!\n //! These two formatting traits have distinct purposes:\n //!\n@@ -231,7 +238,7 @@\n //! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n //! ```\n //!\n-//! ### Related macros\n+//! ## Related macros\n //!\n //! There are a number of related macros in the `format!` family. The ones that\n //! are currently implemented are:\n@@ -245,32 +252,33 @@\n //! format_args! // described below.\n //! ```\n //!\n-//! #### `write!`\n+//! ### `write!`\n //!\n //! This and `writeln` are two macros which are used to emit the format string\n //! to a specified stream. This is used to prevent intermediate allocations of\n //! format strings and instead directly write the output. Under the hood, this\n //! function is actually invoking the `write` function defined in this module.\n //! Example usage is:\n //!\n-//! ```rust\n+//! ```\n //! # #![allow(unused_must_use)]\n //! let mut w = Vec::new();\n //! write!(&mut w, \"Hello {}!\", \"world\");\n //! ```\n //!\n-//! #### `print!`\n+//! ### `print!`\n //!\n //! This and `println` emit their output to stdout. Similarly to the `write!`\n //! macro, the goal of these macros is to avoid intermediate allocations when\n //! printing output. Example usage is:\n //!\n-//! ```rust\n+//! ```\n //! print!(\"Hello {}!\", \"world\");\n //! println!(\"I have a newline {}\", \"character at the end\");\n //! ```\n //!\n-//! #### `format_args!`\n+//! ### `format_args!`\n+//!\n //! This is a curious macro which is used to safely pass around\n //! an opaque object describing the format string. This object\n //! does not require any heap allocations to create, and it only\n@@ -303,7 +311,7 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! ## Syntax\n+//! # Syntax\n //!\n //! The syntax for the formatting language used is drawn from other languages,\n //! so it should not be too alien. Arguments are formatted with python-like\n@@ -326,14 +334,14 @@\n //! parameter := integer '$'\n //! ```\n //!\n-//! ## Formatting Parameters\n+//! # Formatting Parameters\n //!\n //! Each argument being formatted can be transformed by a number of formatting\n //! parameters (corresponding to `format_spec` in the syntax above). These\n //! parameters affect the string representation of what's being formatted. This\n //! syntax draws heavily from Python's, so it may seem a bit familiar.\n //!\n-//! ### Fill/Alignment\n+//! ## Fill/Alignment\n //!\n //! The fill character is provided normally in conjunction with the `width`\n //! parameter. This indicates that if the value being formatted is smaller than\n@@ -345,7 +353,7 @@\n //! * `^` - the argument is center-aligned in `width` columns\n //! * `>` - the argument is right-aligned in `width` columns\n //!\n-//! ### Sign/#/0\n+//! ## Sign/#/0\n //!\n //! These can all be interpreted as flags for a particular formatter.\n //!\n@@ -368,7 +376,7 @@\n //!         same format would yield `-0000001` for the integer `-1`. Notice that\n //!         the negative version has one fewer zero than the positive version.\n //!\n-//! ### Width\n+//! ## Width\n //!\n //! This is a parameter for the \"minimum width\" that the format should take up.\n //! If the value's string does not fill up this many characters, then the\n@@ -384,7 +392,7 @@\n //! parameters by using the `2$` syntax indicating that the second argument is a\n //! `usize` specifying the width.\n //!\n-//! ### Precision\n+//! ## Precision\n //!\n //! For non-numeric types, this can be considered a \"maximum width\". If the\n //! resulting string is longer than this width, then it is truncated down to\n@@ -395,7 +403,7 @@\n //! For floating-point types, this indicates how many digits after the decimal\n //! point should be printed.\n //!\n-//! ## Escaping\n+//! # Escaping\n //!\n //! The literal characters `{` and `}` may be included in a string by preceding\n //! them with the same character. For example, the `{` character is escaped with"}, {"sha": "fe752d5a7e1904d0741f50d3ad056e4f5ea21f08", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -360,7 +360,7 @@ fn test_mut_rev_iter_wrap() {\n     assert_eq!(d.pop_front(), Some(1));\n     d.push_back(4);\n \n-    assert_eq!(d.iter_mut().rev().cloned().collect::<Vec<_>>(),\n+    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(),\n                vec![4, 3, 2]);\n }\n "}, {"sha": "e3a7f23851cde3905ecc061368c2a00340330626", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -168,6 +168,7 @@ impl<T:Copy> Cell<T> {\n     /// let c = Cell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n@@ -237,6 +238,7 @@ unsafe impl<T> Send for Cell<T> where T: Send {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Copy> Clone for Cell<T> {\n+    #[inline]\n     fn clone(&self) -> Cell<T> {\n         Cell::new(self.get())\n     }\n@@ -245,13 +247,15 @@ impl<T:Copy> Clone for Cell<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default + Copy> Default for Cell<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     fn default() -> Cell<T> {\n         Cell::new(Default::default())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n+    #[inline]\n     fn eq(&self, other: &Cell<T>) -> bool {\n         self.get() == other.get()\n     }\n@@ -295,6 +299,7 @@ impl<T> RefCell<T> {\n     /// let c = RefCell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n@@ -314,6 +319,7 @@ impl<T> RefCell<T> {\n     /// let five = c.into_inner();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n         // compiler statically verifies that it is not currently borrowed.\n@@ -327,6 +333,7 @@ impl<T> RefCell<T> {\n     /// The returned value can be dispatched on to determine if a call to\n     /// `borrow` or `borrow_mut` would succeed.\n     #[unstable(feature = \"std_misc\")]\n+    #[inline]\n     pub fn borrow_state(&self) -> BorrowState {\n         match self.borrow.get() {\n             WRITING => BorrowState::Writing,\n@@ -344,6 +351,7 @@ impl<T> RefCell<T> {\n     #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"dispatch on `cell.borrow_state()` instead\")]\n+    #[inline]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n@@ -387,6 +395,7 @@ impl<T> RefCell<T> {\n     /// assert!(result.is_err());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Ref {\n@@ -406,6 +415,7 @@ impl<T> RefCell<T> {\n     #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"dispatch on `cell.borrow_state()` instead\")]\n+    #[inline]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n@@ -448,6 +458,7 @@ impl<T> RefCell<T> {\n     /// assert!(result.is_err());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => RefMut {\n@@ -475,6 +486,7 @@ unsafe impl<T> Send for RefCell<T> where T: Send {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n+    #[inline]\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n     }\n@@ -483,13 +495,15 @@ impl<T: Clone> Clone for RefCell<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default> Default for RefCell<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     fn default() -> RefCell<T> {\n         RefCell::new(Default::default())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for RefCell<T> {\n+    #[inline]\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n     }\n@@ -500,6 +514,7 @@ struct BorrowRef<'b> {\n }\n \n impl<'b> BorrowRef<'b> {\n+    #[inline]\n     fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> {\n         match borrow.get() {\n             WRITING => None,\n@@ -513,6 +528,7 @@ impl<'b> BorrowRef<'b> {\n \n #[unsafe_destructor]\n impl<'b> Drop for BorrowRef<'b> {\n+    #[inline]\n     fn drop(&mut self) {\n         let borrow = self._borrow.get();\n         debug_assert!(borrow != WRITING && borrow != UNUSED);\n@@ -521,6 +537,7 @@ impl<'b> Drop for BorrowRef<'b> {\n }\n \n impl<'b> Clone for BorrowRef<'b> {\n+    #[inline]\n     fn clone(&self) -> BorrowRef<'b> {\n         // Since this Ref exists, we know the borrow flag\n         // is not set to WRITING.\n@@ -561,6 +578,7 @@ impl<'b, T> Deref for Ref<'b, T> {\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n #[unstable(feature = \"core\",\n            reason = \"likely to be moved to a method, pending language changes\")]\n+#[inline]\n pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     Ref {\n         _value: orig._value,\n@@ -574,6 +592,7 @@ struct BorrowRefMut<'b> {\n \n #[unsafe_destructor]\n impl<'b> Drop for BorrowRefMut<'b> {\n+    #[inline]\n     fn drop(&mut self) {\n         let borrow = self._borrow.get();\n         debug_assert!(borrow == WRITING);\n@@ -582,6 +601,7 @@ impl<'b> Drop for BorrowRefMut<'b> {\n }\n \n impl<'b> BorrowRefMut<'b> {\n+    #[inline]\n     fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> {\n         match borrow.get() {\n             UNUSED => {\n@@ -674,6 +694,7 @@ impl<T> UnsafeCell<T> {\n     /// let uc = UnsafeCell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }"}, {"sha": "4f8b1c21ab2e517bd5112ac9fea70a44b5824420", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -65,7 +65,7 @@ use default::Default;\n use marker;\n use mem;\n use num::{ToPrimitive, Int};\n-use ops::{Add, Deref, FnMut, RangeFrom};\n+use ops::{Add, FnMut, RangeFrom};\n use option::Option;\n use option::Option::{Some, None};\n use marker::Sized;\n@@ -976,12 +976,11 @@ pub trait IteratorExt: Iterator + Sized {\n         (ts, us)\n     }\n \n-    /// Creates an iterator that clones the elements it yields. Useful for converting an\n-    /// Iterator<&T> to an Iterator<T>.\n-    #[unstable(feature = \"core\", reason = \"recent addition\")]\n-    fn cloned(self) -> Cloned<Self> where\n-        Self::Item: Deref,\n-        <Self::Item as Deref>::Target: Clone,\n+    /// Creates an iterator that clones the elements it yields. Useful for\n+    /// converting an Iterator<&T> to an Iterator<T>.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn cloned<'a, T: 'a>(self) -> Cloned<Self>\n+        where Self: Iterator<Item=&'a T>, T: Clone\n     {\n         Cloned { it: self }\n     }\n@@ -1279,14 +1278,12 @@ pub struct Cloned<I> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Cloned<I> where\n-    I: Iterator,\n-    I::Item: Deref,\n-    <I::Item as Deref>::Target: Clone\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+    where I: Iterator<Item=&'a T>, T: Clone\n {\n-    type Item = <I::Item as Deref>::Target;\n+    type Item = T;\n \n-    fn next(&mut self) -> Option<<Self as Iterator>::Item> {\n+    fn next(&mut self) -> Option<T> {\n         self.it.next().cloned()\n     }\n \n@@ -1296,36 +1293,30 @@ impl<I> Iterator for Cloned<I> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Cloned<I> where\n-    I: DoubleEndedIterator,\n-    I::Item: Deref,\n-    <I::Item as Deref>::Target: Clone\n+impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n {\n-    fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {\n+    fn next_back(&mut self) -> Option<T> {\n         self.it.next_back().cloned()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Cloned<I> where\n-    I: ExactSizeIterator,\n-    I::Item: Deref,\n-    <I::Item as Deref>::Target: Clone\n+impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n {}\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<I> RandomAccessIterator for Cloned<I> where\n-    I: RandomAccessIterator,\n-    I::Item: Deref,\n-    <I::Item as Deref>::Target: Clone\n+impl<'a, I, T: 'a> RandomAccessIterator for Cloned<I>\n+    where I: RandomAccessIterator<Item=&'a T>, T: Clone\n {\n     #[inline]\n     fn indexable(&self) -> usize {\n         self.it.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: usize) -> Option<<Self as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<T> {\n         self.it.idx(index).cloned()\n     }\n }"}, {"sha": "a5b2fddfd5df61dc9d70cea7e11d0e8003ec6c6f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -330,7 +330,7 @@ impl<T, E> Result<T, E> {\n     /// Convert from `Result<T, E>` to `Option<E>`\n     ///\n     /// Converts `self` into an `Option<E>`, consuming `self`,\n-    /// and discarding the value, if any.\n+    /// and discarding the success value, if any.\n     ///\n     /// # Examples\n     ///"}, {"sha": "893781e6220908ae2823a6eda6ac3e86519fa8e1", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -131,6 +131,7 @@ pub use funcs::bsd43::*;\n #[cfg(unix)] pub use funcs::posix88::net::*;\n #[cfg(unix)] pub use funcs::posix01::stat_::*;\n #[cfg(unix)] pub use funcs::posix01::unistd::*;\n+#[cfg(unix)] pub use funcs::posix01::resource::*;\n \n \n #[cfg(windows)] pub use funcs::extra::kernel32::*;\n@@ -223,6 +224,7 @@ pub mod types {\n                 pub type pthread_t = c_ulong;\n                 #[cfg(target_os = \"nacl\")]\n                 pub type pthread_t = *mut c_void;\n+                pub type rlim_t = u64;\n \n                 #[repr(C)]\n                 #[derive(Copy)] pub struct glob_t {\n@@ -252,7 +254,42 @@ pub mod types {\n                 #[derive(Copy)] pub enum timezone {}\n \n                 pub type sighandler_t = size_t;\n+\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rlimit {\n+                    pub rlim_cur: rlim_t,\n+                    pub rlim_max: rlim_t,\n+                }\n+            }\n+\n+            pub mod bsd43 {\n+                use types::os::common::posix01::timeval;\n+                use types::os::arch::c95::c_long;\n+                // This is also specified in POSIX 2001, but only has two fields. All implementors\n+                // implement BSD 4.3 version.\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rusage {\n+                    pub ru_utime: timeval,\n+                    pub ru_stime: timeval,\n+                    pub ru_maxrss: c_long,\n+                    pub ru_ixrss: c_long,\n+                    pub ru_idrss: c_long,\n+                    pub ru_isrss: c_long,\n+                    pub ru_minflt: c_long,\n+                    pub ru_majflt: c_long,\n+                    pub ru_nswap: c_long,\n+                    pub ru_inblock: c_long,\n+                    pub ru_oublock: c_long,\n+                    pub ru_msgsnd: c_long,\n+                    pub ru_msgrcv: c_long,\n+                    pub ru_nsignals: c_long,\n+                    pub ru_nvcsw: c_long,\n+                    pub ru_nivcsw: c_long\n+                }\n             }\n+\n             pub mod bsd44 {\n                 use types::common::c95::{c_void};\n                 use types::os::arch::c95::{c_char, c_int, c_uint};\n@@ -734,6 +771,7 @@ pub mod types {\n                 use types::os::arch::c99::{uintptr_t};\n \n                 pub type pthread_t = uintptr_t;\n+                pub type rlim_t = i64;\n \n                 #[repr(C)]\n                 #[derive(Copy)] pub struct glob_t {\n@@ -767,7 +805,40 @@ pub mod types {\n                 #[derive(Copy)] pub enum timezone {}\n \n                 pub type sighandler_t = size_t;\n+\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rlimit {\n+                    pub rlim_cur: rlim_t,\n+                    pub rlim_max: rlim_t,\n+                }\n+            }\n+\n+            pub mod bsd43 {\n+                use types::os::common::posix01::timeval;\n+                use types::os::arch::c95::c_long;\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rusage {\n+                    pub ru_utime: timeval,\n+                    pub ru_stime: timeval,\n+                    pub ru_maxrss: c_long,\n+                    pub ru_ixrss: c_long,\n+                    pub ru_idrss: c_long,\n+                    pub ru_isrss: c_long,\n+                    pub ru_minflt: c_long,\n+                    pub ru_majflt: c_long,\n+                    pub ru_nswap: c_long,\n+                    pub ru_inblock: c_long,\n+                    pub ru_oublock: c_long,\n+                    pub ru_msgsnd: c_long,\n+                    pub ru_msgrcv: c_long,\n+                    pub ru_nsignals: c_long,\n+                    pub ru_nvcsw: c_long,\n+                    pub ru_nivcsw: c_long\n+                }\n             }\n+\n             pub mod bsd44 {\n                 use types::common::c95::{c_void};\n                 use types::os::arch::c95::{c_char, c_int, c_uint};\n@@ -962,6 +1033,7 @@ pub mod types {\n                 use types::os::arch::c99::{uintptr_t};\n \n                 pub type pthread_t = uintptr_t;\n+                pub type rlim_t = i64;\n \n                 #[repr(C)]\n                 #[derive(Copy)] pub struct glob_t {\n@@ -995,7 +1067,40 @@ pub mod types {\n                 #[derive(Copy)] pub enum timezone {}\n \n                 pub type sighandler_t = size_t;\n+\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rlimit {\n+                    pub rlim_cur: rlim_t,\n+                    pub rlim_max: rlim_t,\n+                }\n             }\n+\n+            pub mod bsd43 {\n+                use types::os::common::posix01::timeval;\n+                use types::os::arch::c95::c_long;\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rusage {\n+                    pub ru_utime: timeval,\n+                    pub ru_stime: timeval,\n+                    pub ru_maxrss: c_long,\n+                    pub ru_ixrss: c_long,\n+                    pub ru_idrss: c_long,\n+                    pub ru_isrss: c_long,\n+                    pub ru_minflt: c_long,\n+                    pub ru_majflt: c_long,\n+                    pub ru_nswap: c_long,\n+                    pub ru_inblock: c_long,\n+                    pub ru_oublock: c_long,\n+                    pub ru_msgsnd: c_long,\n+                    pub ru_msgrcv: c_long,\n+                    pub ru_nsignals: c_long,\n+                    pub ru_nvcsw: c_long,\n+                    pub ru_nivcsw: c_long\n+                }\n+            }\n+\n             pub mod bsd44 {\n                 use types::common::c95::{c_void};\n                 use types::os::arch::c95::{c_char, c_int, c_uint};\n@@ -1189,6 +1294,7 @@ pub mod types {\n                 use types::os::arch::c99::{uintptr_t};\n \n                 pub type pthread_t = uintptr_t;\n+                pub type rlim_t = u64;\n \n                 #[cfg(target_os = \"bitrig\")]\n                 #[repr(C)]\n@@ -1241,7 +1347,40 @@ pub mod types {\n                 #[derive(Copy)] pub enum timezone {}\n \n                 pub type sighandler_t = size_t;\n+\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rlimit {\n+                    pub rlim_cur: rlim_t,\n+                    pub rlim_max: rlim_t,\n+                }\n+            }\n+\n+            pub mod bsd43 {\n+                use types::os::common::posix01::timeval;\n+                use types::os::arch::c95::c_long;\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rusage {\n+                    pub ru_utime: timeval,\n+                    pub ru_stime: timeval,\n+                    pub ru_maxrss: c_long,\n+                    pub ru_ixrss: c_long,\n+                    pub ru_idrss: c_long,\n+                    pub ru_isrss: c_long,\n+                    pub ru_minflt: c_long,\n+                    pub ru_majflt: c_long,\n+                    pub ru_nswap: c_long,\n+                    pub ru_inblock: c_long,\n+                    pub ru_oublock: c_long,\n+                    pub ru_msgsnd: c_long,\n+                    pub ru_msgrcv: c_long,\n+                    pub ru_nsignals: c_long,\n+                    pub ru_nvcsw: c_long,\n+                    pub ru_nivcsw: c_long\n+                }\n             }\n+\n             pub mod bsd44 {\n                 use types::common::c95::{c_void};\n                 use types::os::arch::c95::{c_char, c_int, c_uint};\n@@ -1840,6 +1979,7 @@ pub mod types {\n                 use types::os::arch::c99::{uintptr_t};\n \n                 pub type pthread_t = uintptr_t;\n+                pub type rlim_t = u64;\n \n                 #[repr(C)]\n                 #[derive(Copy)] pub struct glob_t {\n@@ -1873,6 +2013,38 @@ pub mod types {\n                 #[derive(Copy)] pub enum timezone {}\n \n                 pub type sighandler_t = size_t;\n+\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rlimit {\n+                    pub rlim_cur: rlim_t,\n+                    pub rlim_max: rlim_t,\n+                }\n+            }\n+\n+            pub mod bsd43 {\n+                use types::os::common::posix01::timeval;\n+                use types::os::arch::c95::c_long;\n+                #[repr(C)]\n+                #[derive(Copy)]\n+                pub struct rusage {\n+                    pub ru_utime: timeval,\n+                    pub ru_stime: timeval,\n+                    pub ru_maxrss: c_long,\n+                    pub ru_ixrss: c_long,\n+                    pub ru_idrss: c_long,\n+                    pub ru_isrss: c_long,\n+                    pub ru_minflt: c_long,\n+                    pub ru_majflt: c_long,\n+                    pub ru_nswap: c_long,\n+                    pub ru_inblock: c_long,\n+                    pub ru_oublock: c_long,\n+                    pub ru_msgsnd: c_long,\n+                    pub ru_msgrcv: c_long,\n+                    pub ru_nsignals: c_long,\n+                    pub ru_nvcsw: c_long,\n+                    pub ru_nivcsw: c_long\n+                }\n             }\n \n             pub mod bsd44 {\n@@ -3024,6 +3196,7 @@ pub mod consts {\n         #[cfg(not(target_os = \"nacl\"))]\n         pub mod posix01 {\n             use types::os::arch::c95::{c_int, size_t};\n+            use types::os::common::posix01::rlim_t;\n \n             pub const F_DUPFD : c_int = 0;\n             pub const F_GETFD : c_int = 1;\n@@ -3102,10 +3275,36 @@ pub mod consts {\n \n             pub const CLOCK_REALTIME: c_int = 0;\n             pub const CLOCK_MONOTONIC: c_int = 1;\n+\n+            pub const RLIMIT_CPU: c_int = 0;\n+            pub const RLIMIT_FSIZE: c_int = 1;\n+            pub const RLIMIT_DATA: c_int = 2;\n+            pub const RLIMIT_STACK: c_int = 3;\n+            pub const RLIMIT_CORE: c_int = 4;\n+            pub const RLIMIT_RSS: c_int = 5;\n+            pub const RLIMIT_NOFILE: c_int = 7;\n+            pub const RLIMIT_AS: c_int = 9;\n+            pub const RLIMIT_NPROC: c_int = 6;\n+            pub const RLIMIT_MEMLOCK: c_int = 8;\n+            pub const RLIMIT_LOCKS: c_int = 10;\n+            pub const RLIMIT_SIGPENDING: c_int = 11;\n+            pub const RLIMIT_MSGQUEUE: c_int = 12;\n+            pub const RLIMIT_NICE: c_int = 13;\n+            pub const RLIMIT_RTPRIO: c_int = 14;\n+            pub const RLIMIT_RTTIME: c_int = 15;\n+            pub const RLIMIT_NLIMITS: c_int = 16;\n+            pub const RLIM_INFINITY: rlim_t = 0xffff_ffff_ffff_ffff;\n+            pub const RLIM_SAVED_MAX: rlim_t = RLIM_INFINITY;\n+            pub const RLIM_SAVED_CUR: rlim_t = RLIM_INFINITY;\n+\n+            pub const RUSAGE_SELF: c_int = 0;\n+            pub const RUSAGE_CHILDREN: c_int = -1;\n+            pub const RUSAGE_THREAD: c_int = 1;\n         }\n         #[cfg(target_os = \"nacl\")]\n         pub mod posix01 {\n             use types::os::arch::c95::{c_int, size_t};\n+            use types::os::common::posix01::rlim_t;\n \n             pub const F_DUPFD : c_int = 0;\n             pub const F_GETFD : c_int = 1;\n@@ -3170,6 +3369,32 @@ pub mod consts {\n \n             pub const CLOCK_REALTIME: c_int = 0;\n             pub const CLOCK_MONOTONIC: c_int = 1;\n+\n+            pub const RLIMIT_CPU: c_int = 0;\n+            pub const RLIMIT_FSIZE: c_int = 1;\n+            pub const RLIMIT_DATA: c_int = 2;\n+            pub const RLIMIT_STACK: c_int = 3;\n+            pub const RLIMIT_CORE: c_int = 4;\n+            pub const RLIMIT_RSS: c_int = 5;\n+            pub const RLIMIT_NOFILE: c_int = 7;\n+            pub const RLIMIT_AS: c_int = 9;\n+            pub const RLIMIT_NPROC: c_int = 6;\n+            pub const RLIMIT_MEMLOCK: c_int = 8;\n+            pub const RLIMIT_LOCKS: c_int = 10;\n+            pub const RLIMIT_SIGPENDING: c_int = 11;\n+            pub const RLIMIT_MSGQUEUE: c_int = 12;\n+            pub const RLIMIT_NICE: c_int = 13;\n+            pub const RLIMIT_RTPRIO: c_int = 14;\n+            pub const RLIMIT_RTTIME: c_int = 15;\n+            pub const RLIMIT_NLIMITS: c_int = 16;\n+\n+            pub const RLIM_INFINITY: rlim_t = 0xffff_ffff_ffff_ffff;\n+            pub const RLIM_SAVED_MAX: rlim_t = RLIM_INFINITY;\n+            pub const RLIM_SAVED_CUR: rlim_t = RLIM_INFINITY;\n+\n+            pub const RUSAGE_SELF: c_int = 0;\n+            pub const RUSAGE_CHILDREN: c_int = -1;\n+            pub const RUSAGE_THREAD: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -3632,6 +3857,7 @@ pub mod consts {\n         }\n         pub mod posix01 {\n             use types::os::arch::c95::{c_int, size_t};\n+            use types::os::common::posix01::rlim_t;\n \n             pub const F_DUPFD : c_int = 0;\n             pub const F_GETFD : c_int = 1;\n@@ -3707,6 +3933,29 @@ pub mod consts {\n \n             pub const CLOCK_REALTIME: c_int = 0;\n             pub const CLOCK_MONOTONIC: c_int = 4;\n+\n+            pub const RLIMIT_CPU: c_int = 0;\n+            pub const RLIMIT_FSIZE: c_int = 1;\n+            pub const RLIMIT_DATA: c_int = 2;\n+            pub const RLIMIT_STACK: c_int = 3;\n+            pub const RLIMIT_CORE: c_int = 4;\n+            pub const RLIMIT_RSS: c_int = 5;\n+            pub const RLIMIT_MEMLOCK: c_int = 6;\n+            pub const RLIMIT_NPROC: c_int = 7;\n+            pub const RLIMIT_NOFILE: c_int = 8;\n+            pub const RLIMIT_SBSIZE: c_int = 9;\n+            pub const RLIMIT_VMEM: c_int = 10;\n+            pub const RLIMIT_AS: c_int = RLIMIT_VMEM;\n+            pub const RLIMIT_NPTS: c_int = 11;\n+            pub const RLIMIT_SWAP: c_int = 12;\n+            pub const RLIMIT_KQUEUES: c_int = 13;\n+\n+            pub const RLIM_NLIMITS: rlim_t = 14;\n+            pub const RLIM_INFINITY: rlim_t = 0x7fff_ffff_ffff_ffff;\n+\n+            pub const RUSAGE_SELF: c_int = 0;\n+            pub const RUSAGE_CHILDREN: c_int = -1;\n+            pub const RUSAGE_THREAD: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -4032,6 +4281,7 @@ pub mod consts {\n         }\n         pub mod posix01 {\n             use types::os::arch::c95::{c_int, size_t};\n+            use types::os::common::posix01::rlim_t;\n \n             pub const F_DUPFD : c_int = 0;\n             pub const F_GETFD : c_int = 1;\n@@ -4101,6 +4351,25 @@ pub mod consts {\n \n             pub const CLOCK_REALTIME : c_int = 0;\n             pub const CLOCK_MONOTONIC : c_int = 3;\n+\n+            pub const RLIMIT_CPU: c_int = 0;\n+            pub const RLIMIT_FSIZE: c_int = 1;\n+            pub const RLIMIT_DATA: c_int = 2;\n+            pub const RLIMIT_STACK: c_int = 3;\n+            pub const RLIMIT_CORE: c_int = 4;\n+            pub const RLIMIT_RSS: c_int = 5;\n+            pub const RLIMIT_MEMLOCK: c_int = 6;\n+            pub const RLIMIT_NPROC: c_int = 7;\n+            pub const RLIMIT_NOFILE: c_int = 8;\n+            pub const RLIM_NLIMITS: c_int = 9;\n+\n+            pub const RLIM_INFINITY: rlim_t = 0x7fff_ffff_ffff_ffff;\n+            pub const RLIM_SAVED_MAX: rlim_t = RLIM_INFINITY;\n+            pub const RLIM_SAVED_CUR: rlim_t = RLIM_INFINITY;\n+\n+            pub const RUSAGE_SELF: c_int = 0;\n+            pub const RUSAGE_CHILDREN: c_int = -1;\n+            pub const RUSAGE_THREAD: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -4428,6 +4697,7 @@ pub mod consts {\n         }\n         pub mod posix01 {\n             use types::os::arch::c95::{c_int, size_t};\n+            use types::os::common::posix01::rlim_t;\n \n             pub const F_DUPFD : c_int = 0;\n             pub const F_GETFD : c_int = 1;\n@@ -4488,6 +4758,24 @@ pub mod consts {\n             pub const PTHREAD_CREATE_JOINABLE: c_int = 1;\n             pub const PTHREAD_CREATE_DETACHED: c_int = 2;\n             pub const PTHREAD_STACK_MIN: size_t = 8192;\n+\n+            pub const RLIMIT_CPU: c_int = 0;\n+            pub const RLIMIT_FSIZE: c_int = 1;\n+            pub const RLIMIT_DATA: c_int = 2;\n+            pub const RLIMIT_STACK: c_int = 3;\n+            pub const RLIMIT_CORE: c_int = 4;\n+            pub const RLIMIT_AS: c_int = 5;\n+            pub const RLIMIT_MEMLOCK: c_int = 6;\n+            pub const RLIMIT_NPROC: c_int = 7;\n+            pub const RLIMIT_NOFILE: c_int = 8;\n+            pub const RLIM_NLIMITS: c_int = 9;\n+            pub const _RLIMIT_POSIX_FLAG: c_int = 0x1000;\n+\n+            pub const RLIM_INFINITY: rlim_t = 0xffff_ffff_ffff_ffff;\n+\n+            pub const RUSAGE_SELF: c_int = 0;\n+            pub const RUSAGE_CHILDREN: c_int = -1;\n+            pub const RUSAGE_THREAD: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -5348,6 +5636,18 @@ pub mod funcs {\n                                      -> c_int;\n             }\n         }\n+\n+        pub mod resource {\n+            use types::os::arch::c95::c_int;\n+            use types::os::common::posix01::rlimit;\n+            use types::os::common::bsd43::rusage;\n+            extern {\n+                pub fn getrlimit(resource: c_int, rlim: *mut rlimit) -> c_int;\n+                pub fn setrlimit(resource: c_int, rlim: *const rlimit) -> c_int;\n+                pub fn getrusage(resource: c_int, usage: *mut rusage) -> c_int;\n+\n+            }\n+        }\n     }\n \n     #[cfg(target_os = \"windows\")]"}, {"sha": "9b36408aa5116f3ebe97deb02a71204cdf392e68", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -146,7 +146,7 @@ impl Stdin {\n     /// accessing the underlying data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdinLock {\n-        StdinLock { inner: self.inner.lock().unwrap() }\n+        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n     }\n \n     /// Locks this handle and reads a line of input into the specified buffer.\n@@ -249,7 +249,7 @@ impl Stdout {\n     /// returned guard also implements the `Write` trait for writing data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdoutLock {\n-        StdoutLock { inner: self.inner.lock().unwrap() }\n+        StdoutLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n     }\n }\n \n@@ -319,7 +319,7 @@ impl Stderr {\n     /// returned guard also implements the `Write` trait for writing data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StderrLock {\n-        StderrLock { inner: self.inner.lock().unwrap() }\n+        StderrLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n     }\n }\n \n@@ -402,3 +402,29 @@ pub fn _print(args: fmt::Arguments) {\n         panic!(\"failed printing to stdout: {}\", e);\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use thread;\n+    use super::*;\n+\n+    #[test]\n+    fn panic_doesnt_poison() {\n+        thread::spawn(|| {\n+            let _a = stdin();\n+            let _a = _a.lock();\n+            let _a = stdout();\n+            let _a = _a.lock();\n+            let _a = stderr();\n+            let _a = _a.lock();\n+            panic!();\n+        }).join().unwrap_err();\n+\n+        let _a = stdin();\n+        let _a = _a.lock();\n+        let _a = stdout();\n+        let _a = _a.lock();\n+        let _a = stderr();\n+        let _a = _a.lock();\n+    }\n+}"}, {"sha": "f4a7e8b1b982441654b505b96fefdd654a38c594", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -404,4 +404,18 @@ pub mod builtin {\n     /// ```\n     #[macro_export]\n     macro_rules! cfg { ($cfg:tt) => ({ /* compiler built-in */ }) }\n+\n+    /// Parse the current given file as an expression.\n+    ///\n+    /// This is generally a bad idea, because it's going to behave unhygenically.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// fn foo() {\n+    ///     include!(\"/path/to/a/file\")\n+    /// }\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include { ($cfg:tt) => ({ /* compiler built-in */ }) }\n }"}, {"sha": "a5a2f71acb7e0db572dd89fee95e1b3df3b5f715", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -306,12 +306,11 @@ pub fn args() -> Args {\n // In general it looks like:\n // res = Vec::new()\n // let args = [[NSProcessInfo processInfo] arguments]\n-// for i in range(0, [args count])\n+// for i in (0..[args count])\n //      res.push([args objectAtIndex:i])\n // res\n #[cfg(target_os = \"ios\")]\n pub fn args() -> Args {\n-    use iter::range;\n     use mem;\n \n     #[link(name = \"objc\")]\n@@ -341,7 +340,7 @@ pub fn args() -> Args {\n         let args = objc_msgSend(info, arguments_sel);\n \n         let cnt: int = mem::transmute(objc_msgSend(args, count_sel));\n-        for i in range(0, cnt) {\n+        for i in (0..cnt) {\n             let tmp = objc_msgSend(args, object_at_sel, i);\n             let utf_c_str: *const libc::c_char =\n                 mem::transmute(objc_msgSend(tmp, utf8_sel));"}, {"sha": "c5f07c6c75a7072bd2345212e81c94c434b9c6bd", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -130,12 +130,13 @@ pub mod guard {\n     #[cfg(any(target_os = \"openbsd\", target_os = \"bitrig\"))]\n     pub unsafe fn current() -> usize {\n         #[repr(C)]\n-        pub struct stack_t {\n+        struct stack_t {\n             ss_sp: *mut libc::c_void,\n             ss_size: libc::size_t,\n             ss_flags: libc::c_int,\n         }\n         extern {\n+            fn pthread_main_np() -> libc::c_uint;\n             fn pthread_stackseg_np(thread: pthread_t,\n                                    sinfo: *mut stack_t) -> libc::c_uint;\n         }\n@@ -339,9 +340,6 @@ fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n }\n \n extern {\n-    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-    fn pthread_main_np() -> libc::c_uint;\n-\n     fn pthread_self() -> libc::pthread_t;\n     fn pthread_create(native: *mut libc::pthread_t,\n                       attr: *const libc::pthread_attr_t,"}, {"sha": "6006366ad9abe9f0202bbbda2293b1882b4ca3d0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -215,8 +215,8 @@ pub struct Lifetime {\n     pub name: Name\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n /// A lifetime definition, eg `'a: 'b+'c+'d`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n     pub bounds: Vec<Lifetime>\n@@ -590,6 +590,7 @@ pub enum Pat_ {\n     /// A PatIdent may either be a new bound variable,\n     /// or a nullary enum (in which case the third field\n     /// is None).\n+    ///\n     /// In the nullary enum case, the parser can't determine\n     /// which it is. The resolver determines this, and\n     /// records this pattern's NodeId in an auxiliary\n@@ -786,18 +787,22 @@ pub enum Expr_ {\n     /// An array (`[a, b, c, d]`)\n     ExprVec(Vec<P<Expr>>),\n     /// A function call\n+    ///\n     /// The first field resolves to the function itself,\n     /// and the second field is the list of arguments\n     ExprCall(P<Expr>, Vec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n-    /// The `SpannedIdent` is the identifier for the method name\n+    ///\n+    /// The `SpannedIdent` is the identifier for the method name.\n     /// The vector of `Ty`s are the ascripted type parameters for the method\n-    /// (within the angle brackets)\n+    /// (within the angle brackets).\n+    ///\n     /// The first element of the vector of `Expr`s is the expression that evaluates\n     /// to the object on which the method is being called on (the receiver),\n     /// and the remaining elements are the rest of the arguments.\n+    ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`\n+    /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n     ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n     /// A tuple (`(a, b, c ,d)`)\n     ExprTup(Vec<P<Expr>>),\n@@ -810,32 +815,41 @@ pub enum Expr_ {\n     /// A cast (`foo as f64`)\n     ExprCast(P<Expr>, P<Ty>),\n     /// An `if` block, with an optional else block\n+    ///\n     /// `if expr { block } else { expr }`\n     ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n     /// An `if let` expression with an optional else block\n+    ///\n     /// `if let pat = expr { block } else { expr }`\n-    /// This is desugared to a `match` expression\n+    ///\n+    /// This is desugared to a `match` expression.\n     ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while loop, with an optional label\n+    ///\n     /// `'label: while expr { block }`\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while-let loop, with an optional label\n+    ///\n     /// `'label: while let pat = expr { block }`\n-    /// This is desugared to a combination of `loop` and `match` expressions\n+    ///\n+    /// This is desugared to a combination of `loop` and `match` expressions.\n     ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A for loop, with an optional label\n+    ///\n     /// `'label: for pat in expr { block }`\n-    /// This is desugared to a combination of `loop` and `match` expressions\n+    ///\n+    /// This is desugared to a combination of `loop` and `match` expressions.\n     ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n+    ///\n     /// `'label: loop { block }`\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n-    /// the result of a desugaring, and if so, which kind\n+    /// the result of a desugaring, and if so, which kind.\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n     ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n@@ -845,20 +859,24 @@ pub enum Expr_ {\n     /// An assignment (`a = foo()`)\n     ExprAssign(P<Expr>, P<Expr>),\n     /// An assignment with an operator\n-    /// For example, `a += 1`\n+    ///\n+    /// For example, `a += 1`.\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named struct field (`obj.foo`)\n     ExprField(P<Expr>, SpannedIdent),\n     /// Access of an unnamed field of a struct or tuple-struct\n-    /// For example, `foo.0`\n+    ///\n+    /// For example, `foo.0`.\n     ExprTupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n     /// A range (`1..2`, `1..`, or `..2`)\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or type\n-    /// parameters, e.g. foo::bar::<baz>. Optionally \"qualified\",\n+    /// parameters, e.g. foo::bar::<baz>.\n+    ///\n+    /// Optionally \"qualified\",\n     /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n     ExprPath(Option<QSelf>, Path),\n \n@@ -878,13 +896,15 @@ pub enum Expr_ {\n     ExprMac(Mac),\n \n     /// A struct literal expression.\n+    ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n-    /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`\n+    /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n     ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n \n     /// A vector literal constructed from one repeated element.\n+    ///\n     /// For example, `[1u8; 5]`. The first expression is the element\n-    /// to be repeated; the second is the number of times to repeat it\n+    /// to be repeated; the second is the number of times to repeat it.\n     ExprRepeat(P<Expr>, P<Expr>),\n \n     /// No-op: used solely so we can pretty-print faithfully\n@@ -1092,6 +1112,7 @@ pub type Mac = Spanned<Mac_>;\n /// Represents a macro invocation. The Path indicates which macro\n /// is being invoked, and the vector of token-trees contains the source\n /// of the macro invocation.\n+///\n /// There's only one flavor, now, so this could presumably be simplified.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Mac_ {\n@@ -1105,6 +1126,7 @@ pub enum StrStyle {\n     /// A regular string, like `\"foo\"`\n     CookedStr,\n     /// A raw string, like `r##\"foo\"##`\n+    ///\n     /// The uint is the number of `#` symbols used\n     RawStr(usize)\n }\n@@ -1155,7 +1177,7 @@ pub enum Lit_ {\n     LitByte(u8),\n     /// A character literal (`'a'`)\n     LitChar(char),\n-    /// An integer liteal (`1u8`)\n+    /// An integer literal (`1u8`)\n     LitInt(u64, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n     LitFloat(InternedString, FloatTy),\n@@ -1459,7 +1481,7 @@ impl Arg {\n     }\n }\n \n-/// represents the header (not the body) of a function declaration\n+/// Represents the header (not the body) of a function declaration\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n@@ -1505,7 +1527,9 @@ pub enum FunctionRetTy {\n     /// Functions with return type `!`that always\n     /// raise an error or exit (i.e. never return to the caller)\n     NoReturn(Span),\n-    /// Return type is not specified. Functions default to `()` and\n+    /// Return type is not specified.\n+    ///\n+    /// Functions default to `()` and\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n     DefaultReturn(Span),\n@@ -1645,6 +1669,7 @@ pub struct Attribute_ {\n }\n \n /// TraitRef's appear in impls.\n+///\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n /// If this impl is an ItemImpl, the impl_id is redundant (it could be the\n@@ -1745,6 +1770,7 @@ pub struct Item {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n     /// An`extern crate` item, with optional original crate name,\n+    ///\n     /// e.g. `extern crate foo` or `extern crate \"foo-bar\" as foo`\n     ItemExternCrate(Option<(InternedString, StrStyle)>),\n     /// A `use` or `pub use` item\n@@ -1773,6 +1799,7 @@ pub enum Item_ {\n               Vec<P<TraitItem>>),\n \n     // Default trait implementations\n+    ///\n     // `impl Trait for .. {}`\n     ItemDefaultImpl(Unsafety, TraitRef),\n     /// An implementation, eg `impl<A> Trait for Foo { .. }`"}, {"sha": "968d2fd7e2a47c6e216845b527b97e82a8548a79", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -404,7 +404,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n         .map(|x| (x, len as isize))\n     }\n \n-    let unicode_escape = || -> Option<(char, isize)>\n+    let unicode_escape = || -> Option<(char, isize)> {\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n             let subslice = &lit[3..idx];\n@@ -413,7 +413,8 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n                 .map(|x| (x, subslice.chars().count() as isize + 4))\n         } else {\n             esc(6, lit)\n-        };\n+        }\n+    };\n \n     // Unicode escapes\n     return match lit.as_bytes()[1] as char {"}, {"sha": "667af642744b9db478dad5ce0fcd12f528599e3b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -2099,10 +2099,7 @@ impl<'a> Parser<'a> {\n                 }\n             },\n             token::OpenDelim(token::Brace) => {\n-                self.bump();\n-                let blk = self.parse_block_tail(lo, DefaultBlock);\n-                return self.mk_expr(blk.span.lo, blk.span.hi,\n-                                    ExprBlock(blk));\n+                return self.parse_block_expr(lo, DefaultBlock);\n             },\n             token::BinOp(token::Or) |  token::OrOr => {\n                 return self.parse_lambda_expr(CaptureByRef);\n@@ -2998,19 +2995,30 @@ impl<'a> Parser<'a> {\n     {\n         let lo = self.span.lo;\n         let decl = self.parse_fn_block_decl();\n-        let body = self.parse_expr();\n-        let fakeblock = P(ast::Block {\n-            id: ast::DUMMY_NODE_ID,\n-            stmts: vec![],\n-            span: body.span,\n-            expr: Some(body),\n-            rules: DefaultBlock,\n-        });\n+        let body = match decl.output {\n+            DefaultReturn(_) => {\n+                // If no explicit return type is given, parse any\n+                // expr and wrap it up in a dummy block:\n+                let body_expr = self.parse_expr();\n+                P(ast::Block {\n+                    id: ast::DUMMY_NODE_ID,\n+                    stmts: vec![],\n+                    span: body_expr.span,\n+                    expr: Some(body_expr),\n+                    rules: DefaultBlock,\n+                })\n+            }\n+            _ => {\n+                // If an explicit return type is given, require a\n+                // block to appear (RFC 968).\n+                self.parse_block()\n+            }\n+        };\n \n         self.mk_expr(\n             lo,\n-            fakeblock.span.hi,\n-            ExprClosure(capture_clause, decl, fakeblock))\n+            body.span.hi,\n+            ExprClosure(capture_clause, decl, body))\n     }\n \n     pub fn parse_else_expr(&mut self) -> P<Expr> {"}, {"sha": "b58c121c5fd54730df170197ef956b41145b95cc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -1777,7 +1777,12 @@ impl<'a> State<'a> {\n                 try!(self.print_fn_block_args(&**decl));\n                 try!(space(&mut self.s));\n \n-                if !body.stmts.is_empty() || !body.expr.is_some() {\n+                let default_return = match decl.output {\n+                    ast::DefaultReturn(..) => true,\n+                    _ => false\n+                };\n+\n+                if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n                     try!(self.print_block_unclosed(&**body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes"}, {"sha": "35c551931366d28c732260ef2d523197a14c4759", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -26,7 +26,7 @@ fn main() {\n     //~| found `Box<core::ops::Fn(isize, isize)>`\n     //~| expected ()\n     //~| found box\n-    let _: () = (box || -> isize unimplemented!()) as Box<FnMut() -> isize>;\n+    let _: () = (box || -> isize { unimplemented!() }) as Box<FnMut() -> isize>;\n     //~^ ERROR mismatched types\n     //~| expected `()`\n     //~| found `Box<core::ops::FnMut() -> isize>`"}, {"sha": "7c94e33b47b38c4296012d4aa7d63a6bacbf5b2a", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -13,6 +13,6 @@ use std::vec::Vec;\n fn main() {\n     let a: Vec<isize> = Vec::new();\n     a.iter().all(|_| -> bool {\n-        //~^ ERROR mismatched types\n+        //~^ ERROR not all control paths return a value\n     });\n }"}, {"sha": "da6245597f8f42518847ea4663c57a9770c62860", "filename": "src/test/parse-fail/closure-return-syntax.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fclosure-return-syntax.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we cannot parse a closure with an explicit return type\n+// unless it uses braces.\n+\n+fn main() {\n+    let x = || -> i32 22; //~ ERROR expected `{`, found `22`\n+}"}, {"sha": "835d356d8aaa1d98106622ff8df38de6c514baae", "filename": "src/test/run-pass/block-explicit-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -10,5 +10,5 @@\n \n pub fn main() {\n     fn as_buf<T, F>(s: String, f: F) -> T where F: FnOnce(String) -> T { f(s) }\n-    as_buf(\"foo\".to_string(), |foo: String| -> () println!(\"{}\", foo) );\n+    as_buf(\"foo\".to_string(), |foo: String| -> () { println!(\"{}\", foo) });\n }"}, {"sha": "4364391cf0c60c9d403250ba778af1ac69bdb926", "filename": "src/test/run-pass/borrowck-move-by-capture-ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -14,6 +14,6 @@\n \n pub fn main() {\n     let bar: Box<_> = box 3;\n-    let h = || -> int *bar;\n+    let h = || -> int { *bar };\n     assert_eq!(h(), 3);\n }"}, {"sha": "8e3cb414566c7577279db2ba4f0fc60d45c7af7b", "filename": "src/test/run-pass/issue-17816.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Frun-pass%2Fissue-17816.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084f92302b3352372bfd14ebbf083bae695d16e/src%2Ftest%2Frun-pass%2Fissue-17816.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17816.rs?ref=0084f92302b3352372bfd14ebbf083bae695d16e", "patch": "@@ -14,7 +14,7 @@ use std::marker::PhantomData;\n \n fn main() {\n     struct Symbol<'a, F: Fn(Vec<&'a str>) -> &'a str> { function: F, marker: PhantomData<&'a ()> }\n-    let f = |x: Vec<&str>| -> &str \"foobar\";\n+    let f = |x: Vec<&str>| -> &str { \"foobar\" };\n     let sym = Symbol { function: f, marker: PhantomData };\n     (sym.function)(vec![]);\n }"}]}