{"sha": "63087b6b15bff0346fda199e1a077ab3cdc30ba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMDg3YjZiMTViZmYwMzQ2ZmRhMTk5ZTFhMDc3YWIzY2RjMzBiYTM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-19T07:28:24Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-26T08:22:45Z"}, "message": "Parametrise by try_collect_active_jobs.", "tree": {"sha": "75b262023cdcf6a5fe41c5327eb8d025171a20cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75b262023cdcf6a5fe41c5327eb8d025171a20cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63087b6b15bff0346fda199e1a077ab3cdc30ba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63087b6b15bff0346fda199e1a077ab3cdc30ba3", "html_url": "https://github.com/rust-lang/rust/commit/63087b6b15bff0346fda199e1a077ab3cdc30ba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63087b6b15bff0346fda199e1a077ab3cdc30ba3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "232364a580fb60199db8e3c9c1cfd391d0046a2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/232364a580fb60199db8e3c9c1cfd391d0046a2a", "html_url": "https://github.com/rust-lang/rust/commit/232364a580fb60199db8e3c9c1cfd391d0046a2a"}], "stats": {"total": 147, "additions": 78, "deletions": 69}, "files": [{"sha": "9495d9bfc6b314b3ad550f621e2037137ee49458", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63087b6b15bff0346fda199e1a077ab3cdc30ba3/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63087b6b15bff0346fda199e1a077ab3cdc30ba3/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=63087b6b15bff0346fda199e1a077ab3cdc30ba3", "patch": "@@ -2,13 +2,14 @@\n \n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::job::QueryJobId;\n+use crate::ty::query::job::{QueryJobId, QueryJobInfo};\n use crate::ty::query::plumbing::CycleError;\n use crate::ty::query::QueryState;\n use rustc_data_structures::profiling::ProfileCategory;\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_query_system::dep_graph::{DepContext, DepNode};\n use rustc_session::Session;\n use std::borrow::Cow;\n@@ -24,7 +25,7 @@ pub trait QueryConfig<CTX> {\n }\n \n pub trait QueryContext: DepContext {\n-    type Query;\n+    type Query: Clone;\n \n     /// Access the session.\n     fn session(&self) -> &Session;\n@@ -34,6 +35,10 @@ pub trait QueryContext: DepContext {\n \n     /// Get the query information from the TLS context.\n     fn read_query_job<R>(&self, op: impl FnOnce(Option<QueryJobId<Self::DepKind>>) -> R) -> R;\n+\n+    fn try_collect_active_jobs(\n+        &self,\n+    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>>;\n }\n \n pub(crate) trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n@@ -56,7 +61,7 @@ pub(crate) trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n         result: &Self::Value,\n     ) -> Option<Fingerprint>;\n \n-    fn handle_cycle_error(tcx: CTX, error: CycleError<CTX>) -> Self::Value;\n+    fn handle_cycle_error(tcx: CTX, error: CycleError<CTX::Query>) -> Self::Value;\n }\n \n pub(crate) trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {"}, {"sha": "253c814588fbaccf8e8fb1d3767ac8921b0228f1", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 59, "deletions": 61, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/63087b6b15bff0346fda199e1a077ab3cdc30ba3/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63087b6b15bff0346fda199e1a077ab3cdc30ba3/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=63087b6b15bff0346fda199e1a077ab3cdc30ba3", "patch": "@@ -1,11 +1,10 @@\n-use crate::dep_graph::DepKind;\n-use crate::ty::context::TyCtxt;\n use crate::ty::query::config::QueryContext;\n use crate::ty::query::plumbing::CycleError;\n-use crate::ty::query::Query;\n+#[cfg(parallel_compiler)]\n use crate::ty::tls;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_query_system::dep_graph::DepContext;\n use rustc_span::Span;\n \n use std::convert::TryFrom;\n@@ -28,13 +27,13 @@ use {\n \n /// Represents a span and a query key.\n #[derive(Clone, Debug)]\n-pub struct QueryInfo<CTX: QueryContext> {\n+pub struct QueryInfo<Q> {\n     /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n-    pub query: CTX::Query,\n+    pub query: Q,\n }\n \n-type QueryMap<'tcx> = FxHashMap<QueryJobId<DepKind>, QueryJobInfo<TyCtxt<'tcx>>>;\n+type QueryMap<CTX> = FxHashMap<QueryJobId<<CTX as DepContext>::DepKind>, QueryJobInfo<CTX>>;\n \n /// A value uniquely identifiying an active query job within a shard in the query cache.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n@@ -53,35 +52,36 @@ pub struct QueryJobId<K> {\n     pub kind: K,\n }\n \n-impl<K> QueryJobId<K> {\n+impl<K: rustc_query_system::dep_graph::DepKind> QueryJobId<K> {\n     pub fn new(job: QueryShardJobId, shard: usize, kind: K) -> Self {\n         QueryJobId { job, shard: u16::try_from(shard).unwrap(), kind }\n     }\n-}\n \n-impl QueryJobId<DepKind> {\n-    fn query<'tcx>(self, map: &QueryMap<'tcx>) -> Query<'tcx> {\n+    fn query<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> CTX::Query {\n         map.get(&self).unwrap().info.query.clone()\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn span(self, map: &QueryMap<'_>) -> Span {\n+    fn span<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> Span {\n         map.get(&self).unwrap().job.span\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn parent(self, map: &QueryMap<'_>) -> Option<QueryJobId<DepKind>> {\n+    fn parent<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> Option<QueryJobId<K>> {\n         map.get(&self).unwrap().job.parent\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn latch<'a, 'tcx>(self, map: &'a QueryMap<'tcx>) -> Option<&'a QueryLatch<TyCtxt<'tcx>>> {\n+    fn latch<'a, CTX: QueryContext<DepKind = K>>(\n+        self,\n+        map: &'a QueryMap<CTX>,\n+    ) -> Option<&'a QueryLatch<CTX>> {\n         map.get(&self).unwrap().job.latch.as_ref()\n     }\n }\n \n pub struct QueryJobInfo<CTX: QueryContext> {\n-    pub info: QueryInfo<CTX>,\n+    pub info: QueryInfo<CTX::Query>,\n     pub job: QueryJob<CTX>,\n }\n \n@@ -147,16 +147,12 @@ pub(super) struct QueryLatch<CTX: QueryContext> {\n }\n \n #[cfg(not(parallel_compiler))]\n-impl<'tcx> QueryLatch<TyCtxt<'tcx>> {\n-    pub(super) fn find_cycle_in_stack(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        span: Span,\n-    ) -> CycleError<TyCtxt<'tcx>> {\n-        let query_map = tcx.queries.try_collect_active_jobs().unwrap();\n+impl<CTX: QueryContext> QueryLatch<CTX> {\n+    pub(super) fn find_cycle_in_stack(&self, tcx: CTX, span: Span) -> CycleError<CTX::Query> {\n+        let query_map = tcx.try_collect_active_jobs().unwrap();\n \n         // Get the current executing query (waiter) and find the waitee amongst its parents\n-        let mut current_job = tls::with_related_context(tcx, |icx| icx.query);\n+        let mut current_job = tcx.read_query_job(|query| query);\n         let mut cycle = Vec::new();\n \n         while let Some(job) = current_job {\n@@ -192,7 +188,7 @@ struct QueryWaiter<CTX: QueryContext> {\n     query: Option<QueryJobId<CTX::DepKind>>,\n     condvar: Condvar,\n     span: Span,\n-    cycle: Lock<Option<CycleError<CTX>>>,\n+    cycle: Lock<Option<CycleError<CTX::Query>>>,\n }\n \n #[cfg(parallel_compiler)]\n@@ -225,13 +221,9 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n }\n \n #[cfg(parallel_compiler)]\n-impl<K, CTX> QueryLatch<CTX>\n-where\n-    K: rustc_query_system::dep_graph::DepKind,\n-    CTX: QueryContext<DepKind = K>,\n-{\n+impl<CTX: QueryContext> QueryLatch<CTX> {\n     /// Awaits for the query job to complete.\n-    pub(super) fn wait_on(&self, tcx: CTX, span: Span) -> Result<(), CycleError<CTX>> {\n+    pub(super) fn wait_on(&self, tcx: CTX, span: Span) -> Result<(), CycleError<CTX::Query>> {\n         tcx.read_query_job(move |query| {\n             let waiter = Lrc::new(QueryWaiter {\n                 query,\n@@ -299,7 +291,7 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n \n /// A resumable waiter of a query. The usize is the index into waiters in the query's latch\n #[cfg(parallel_compiler)]\n-type Waiter = (QueryJobId<DepKind>, usize);\n+type Waiter<K> = (QueryJobId<K>, usize);\n \n /// Visits all the non-resumable and resumable waiters of a query.\n /// Only waiters in a query are visited.\n@@ -311,13 +303,13 @@ type Waiter = (QueryJobId<DepKind>, usize);\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n #[cfg(parallel_compiler)]\n-fn visit_waiters<'tcx, F>(\n-    query_map: &QueryMap<'tcx>,\n-    query: QueryJobId<DepKind>,\n+fn visit_waiters<CTX: QueryContext, F>(\n+    query_map: &QueryMap<CTX>,\n+    query: QueryJobId<CTX::DepKind>,\n     mut visit: F,\n-) -> Option<Option<Waiter>>\n+) -> Option<Option<Waiter<CTX::DepKind>>>\n where\n-    F: FnMut(Span, QueryJobId<DepKind>) -> Option<Option<Waiter>>,\n+    F: FnMut(Span, QueryJobId<CTX::DepKind>) -> Option<Option<Waiter<CTX::DepKind>>>,\n {\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n     if let Some(parent) = query.parent(query_map) {\n@@ -346,13 +338,13 @@ where\n /// If a cycle is detected, this initial value is replaced with the span causing\n /// the cycle.\n #[cfg(parallel_compiler)]\n-fn cycle_check<'tcx>(\n-    query_map: &QueryMap<'tcx>,\n-    query: QueryJobId<DepKind>,\n+fn cycle_check<CTX: QueryContext>(\n+    query_map: &QueryMap<CTX>,\n+    query: QueryJobId<CTX::DepKind>,\n     span: Span,\n-    stack: &mut Vec<(Span, QueryJobId<DepKind>)>,\n-    visited: &mut FxHashSet<QueryJobId<DepKind>>,\n-) -> Option<Option<Waiter>> {\n+    stack: &mut Vec<(Span, QueryJobId<CTX::DepKind>)>,\n+    visited: &mut FxHashSet<QueryJobId<CTX::DepKind>>,\n+) -> Option<Option<Waiter<CTX::DepKind>>> {\n     if !visited.insert(query) {\n         return if let Some(p) = stack.iter().position(|q| q.1 == query) {\n             // We detected a query cycle, fix up the initial span and return Some\n@@ -387,10 +379,10 @@ fn cycle_check<'tcx>(\n /// from `query` without going through any of the queries in `visited`.\n /// This is achieved with a depth first search.\n #[cfg(parallel_compiler)]\n-fn connected_to_root<'tcx>(\n-    query_map: &QueryMap<'tcx>,\n-    query: QueryJobId<DepKind>,\n-    visited: &mut FxHashSet<QueryJobId<DepKind>>,\n+fn connected_to_root<CTX: QueryContext>(\n+    query_map: &QueryMap<CTX>,\n+    query: QueryJobId<CTX::DepKind>,\n+    visited: &mut FxHashSet<QueryJobId<CTX::DepKind>>,\n ) -> bool {\n     // We already visited this or we're deliberately ignoring it\n     if !visited.insert(query) {\n@@ -410,12 +402,12 @@ fn connected_to_root<'tcx>(\n \n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n-fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, QueryJobId<DepKind>)>(\n-    query_map: &QueryMap<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    queries: &'a [T],\n-    f: F,\n-) -> &'a T {\n+fn pick_query<'a, CTX, T, F>(query_map: &QueryMap<CTX>, tcx: CTX, queries: &'a [T], f: F) -> &'a T\n+where\n+    CTX: QueryContext,\n+    CTX::Query: HashStable<CTX::StableHashingContext>,\n+    F: Fn(&T) -> (Span, QueryJobId<CTX::DepKind>),\n+{\n     // Deterministically pick an entry point\n     // FIXME: Sort this instead\n     let mut hcx = tcx.create_stable_hashing_context();\n@@ -440,12 +432,15 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, QueryJobId<DepKind>)>(\n /// If a cycle was not found, the starting query is removed from `jobs` and\n /// the function returns false.\n #[cfg(parallel_compiler)]\n-fn remove_cycle<'tcx>(\n-    query_map: &QueryMap<'tcx>,\n-    jobs: &mut Vec<QueryJobId<DepKind>>,\n-    wakelist: &mut Vec<Lrc<QueryWaiter<TyCtxt<'tcx>>>>,\n-    tcx: TyCtxt<'tcx>,\n-) -> bool {\n+fn remove_cycle<CTX: QueryContext>(\n+    query_map: &QueryMap<CTX>,\n+    jobs: &mut Vec<QueryJobId<CTX::DepKind>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<CTX>>>,\n+    tcx: CTX,\n+) -> bool\n+where\n+    CTX::Query: HashStable<CTX::StableHashingContext>,\n+{\n     let mut visited = FxHashSet::default();\n     let mut stack = Vec::new();\n     // Look for a cycle starting with the last query in `jobs`\n@@ -497,7 +492,7 @@ fn remove_cycle<'tcx>(\n                     }\n                 }\n             })\n-            .collect::<Vec<(Span, QueryJobId<DepKind>, Option<(Span, QueryJobId<DepKind>)>)>>();\n+            .collect::<Vec<(Span, QueryJobId<CTX::DepKind>, Option<(Span, QueryJobId<CTX::DepKind>)>)>>();\n \n         // Deterministically pick an entry point\n         let (_, entry_point, usage) = pick_query(query_map, tcx, &entry_points, |e| (e.0, e.1));\n@@ -569,15 +564,18 @@ pub unsafe fn handle_deadlock() {\n /// There may be multiple cycles involved in a deadlock, so this searches\n /// all active queries for cycles before finally resuming all the waiters at once.\n #[cfg(parallel_compiler)]\n-fn deadlock(tcx: TyCtxt<'_>, registry: &rayon_core::Registry) {\n+fn deadlock<CTX: QueryContext>(tcx: CTX, registry: &rayon_core::Registry)\n+where\n+    CTX::Query: HashStable<CTX::StableHashingContext>,\n+{\n     let on_panic = OnDrop(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");\n         process::abort();\n     });\n \n     let mut wakelist = Vec::new();\n-    let query_map = tcx.queries.try_collect_active_jobs().unwrap();\n-    let mut jobs: Vec<QueryJobId<DepKind>> = query_map.keys().cloned().collect();\n+    let query_map = tcx.try_collect_active_jobs().unwrap();\n+    let mut jobs: Vec<QueryJobId<CTX::DepKind>> = query_map.keys().cloned().collect();\n \n     let mut found_cycle = false;\n "}, {"sha": "14c0aea7c8fa1abcac42774c9dcbc96395e37f88", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63087b6b15bff0346fda199e1a077ab3cdc30ba3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63087b6b15bff0346fda199e1a077ab3cdc30ba3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=63087b6b15bff0346fda199e1a077ab3cdc30ba3", "patch": "@@ -332,10 +332,10 @@ where\n }\n \n #[derive(Clone)]\n-pub(crate) struct CycleError<CTX: QueryContext> {\n+pub(crate) struct CycleError<Q> {\n     /// The query and related span that uses the cycle.\n-    pub(super) usage: Option<(Span, CTX::Query)>,\n-    pub(super) cycle: Vec<QueryInfo<CTX>>,\n+    pub(super) usage: Option<(Span, Q)>,\n+    pub(super) cycle: Vec<QueryInfo<Q>>,\n }\n \n /// The result of `try_start`.\n@@ -371,6 +371,12 @@ impl QueryContext for TyCtxt<'tcx> {\n     fn read_query_job<R>(&self, op: impl FnOnce(Option<QueryJobId<Self::DepKind>>) -> R) -> R {\n         tls::with_related_context(*self, move |icx| op(icx.query))\n     }\n+\n+    fn try_collect_active_jobs(\n+        &self,\n+    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>> {\n+        self.queries.try_collect_active_jobs()\n+    }\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -409,7 +415,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[cold]\n     pub(super) fn report_cycle(\n         self,\n-        CycleError { usage, cycle: stack }: CycleError<TyCtxt<'tcx>>,\n+        CycleError { usage, cycle: stack }: CycleError<Query<'tcx>>,\n     ) -> DiagnosticBuilder<'tcx> {\n         assert!(!stack.is_empty());\n \n@@ -1033,7 +1039,7 @@ macro_rules! define_queries_inner {\n \n             fn handle_cycle_error(\n                 tcx: TyCtxt<'tcx>,\n-                error: CycleError<TyCtxt<'tcx>>\n+                error: CycleError<Query<'tcx>>\n             ) -> Self::Value {\n                 handle_cycle_error!([$($modifiers)*][tcx, error])\n             }"}]}