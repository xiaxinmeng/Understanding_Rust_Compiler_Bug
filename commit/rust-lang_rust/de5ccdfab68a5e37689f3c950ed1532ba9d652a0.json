{"sha": "de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNWNjZGZhYjY4YTVlMzc2ODlmM2M5NTBlZDE1MzJiYTlkNjUyYTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-31T06:30:06Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-31T06:30:06Z"}, "message": "Upgrade to rustc 1.3.0-nightly (4d52d7c85 2015-07-30)", "tree": {"sha": "418214ef206262cee4230f0e8b5d8fff6aa3fbae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/418214ef206262cee4230f0e8b5d8fff6aa3fbae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "html_url": "https://github.com/rust-lang/rust/commit/de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e8e8cfc9be642311be9995934bb864560b8c553", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8e8cfc9be642311be9995934bb864560b8c553", "html_url": "https://github.com/rust-lang/rust/commit/0e8e8cfc9be642311be9995934bb864560b8c553"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "d0955c313e9d061ac61af7873b3d17897dfedbff", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.6\"\n+version = \"0.0.7\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\"\n@@ -23,4 +23,4 @@ lazy_static = \"*\"\n \n [features]\n \n-structured_logging = []\n\\ No newline at end of file\n+structured_logging = []"}, {"sha": "8d9e289fadaa4d590b6d748ff10fe8d6a4c97859", "filename": "src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "patch": "@@ -103,7 +103,7 @@ fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident,\n \t\t\t\tspan_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n \t\t\t\t\t\"You have declared #[inline(always)] on {}. This \\\n \t\t\t\t\tis usually a bad idea. Are you sure?\", \n-\t\t\t\t\tident.as_str()));\n+\t\t\t\t\tident.name.as_str()));\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "0e139983bbfff5cfb83bfabd02bfb5e2d517701b", "filename": "src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "patch": "@@ -50,7 +50,7 @@ impl LintPass for LenZero {\n \n fn check_trait_items(cx: &Context, item: &Item, trait_items: &[P<TraitItem>]) {\n \tfn is_named_self(item: &TraitItem, name: &str) -> bool {\n-\t\titem.ident.as_str() == name && if let MethodTraitItem(ref sig, _) =\n+\t\titem.ident.name == name && if let MethodTraitItem(ref sig, _) =\n \t\t\titem.node { is_self_sig(sig) } else { false }\n \t}\n \n@@ -61,15 +61,15 @@ fn check_trait_items(cx: &Context, item: &Item, trait_items: &[P<TraitItem>]) {\n \t\t\t\tspan_lint(cx, LEN_WITHOUT_IS_EMPTY, i.span,\n \t\t\t\t\t&format!(\"Trait '{}' has a '.len(_: &Self)' method, but no \\\n \t\t\t\t\t\t'.is_empty(_: &Self)' method. Consider adding one.\", \n-\t\t\t\t\t\titem.ident.as_str()));\n+\t\t\t\t\t\titem.ident.name));\n \t\t\t}\n \t\t};\n \t}\n }\n \n fn check_impl_items(cx: &Context, item: &Item, impl_items: &[P<ImplItem>]) {\n \tfn is_named_self(item: &ImplItem, name: &str) -> bool {\n-\t\titem.ident.as_str() == name && if let MethodImplItem(ref sig, _) = \n+\t\titem.ident.name == name && if let MethodImplItem(ref sig, _) = \n \t\t\t\titem.node { is_self_sig(sig) } else { false }\n \t}\n \n@@ -81,7 +81,7 @@ fn check_impl_items(cx: &Context, item: &Item, impl_items: &[P<ImplItem>]) {\n \t\t\t\t\tSpan{ lo: s.lo, hi: s.lo, expn_id: s.expn_id },\n \t\t\t\t\t&format!(\"Item '{}' has a '.len(_: &Self)' method, but no \\\n \t\t\t\t\t\t'.is_empty(_: &Self)' method. Consider adding one.\", \n-\t\t\t\t\t\titem.ident.as_str()));\n+\t\t\t\t\t\titem.ident.name));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n@@ -106,7 +106,7 @@ fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, empty: &str) {\n fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent, \n \t\targs: &[P<Expr>], lit: &Lit, empty: &str) {\n \tif let &Spanned{node: LitInt(0, _), ..} = lit {\n-\t\tif method.node.as_str() == \"len\" && args.len() == 1 &&\n+\t\tif method.node.name == \"len\" && args.len() == 1 &&\n \t\t\thas_is_empty(cx, &*args[0]) {\n \t\t\tspan_lint(cx, LEN_ZERO, span, &format!(\n \t\t\t\t\"Consider replacing the len comparison with '{}_.is_empty()'\","}, {"sha": "73b94875b30e6238e46f92942f606b4f74c66178", "filename": "src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "patch": "@@ -70,7 +70,7 @@ impl LintPass for StrToStringPass {\n     fn check_expr(&mut self, cx: &Context, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprMethodCall(ref method, _, ref args)\n-                if method.node.as_str() == \"to_string\"\n+                if method.node.name == \"to_string\"\n                 && is_str(cx, &*args[0]) => {\n                 span_lint(cx, STR_TO_STRING, expr.span, \"str.to_owned() is faster\");\n             },\n@@ -135,7 +135,7 @@ impl LintPass for CmpNan {\n }\n \n fn check_nan(cx: &Context, path: &Path, span: Span) {\n-\tpath.segments.last().map(|seg| if seg.identifier.as_str() == \"NAN\" {\n+\tpath.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n \t\tspan_lint(cx, CMP_NAN, span, \"Doomed comparison with NAN, use std::{f32,f64}::is_nan instead\");\n \t});\n }\n@@ -238,7 +238,7 @@ impl LintPass for CmpOwned {\n fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n \tmatch &expr.node {\n \t\t&ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n-\t\t\tlet name = ident.as_str();\n+\t\t\tlet name = ident.name;\n \t\t\tif name == \"to_string\" || \n \t\t\t   name == \"to_owned\" && is_str_arg(cx, args) {\n \t\t\t\tspan_lint(cx, CMP_OWNED, expr.span, &format!("}, {"sha": "d138239b5a76aa7f67d043f3a8ec24fae50b80dc", "filename": "src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "patch": "@@ -25,7 +25,7 @@ pub fn match_ty_unwrap<'a>(ty: &'a Ty, segments: &[&str]) -> Option<&'a [P<Ty>]>\n             // I could muck around with the maps and find the full path\n             // however the more efficient way is to simply reverse the iterators and zip them\n             // which will compare them in reverse until one of them runs out of segments\n-            if seg.iter().rev().zip(segments.iter().rev()).all(|(a,b)| a.identifier.as_str() == *b) {\n+            if seg.iter().rev().zip(segments.iter().rev()).all(|(a,b)| a.identifier.name == b) {\n                 match seg[..].last() {\n                     Some(&PathSegment {parameters: AngleBracketedParameters(ref a), ..}) => {\n                         Some(&a.types[..])"}, {"sha": "d62e082c1fc2ed2f9c9aa996f666046ad023a39b", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de5ccdfab68a5e37689f3c950ed1532ba9d652a0/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=de5ccdfab68a5e37689f3c950ed1532ba9d652a0", "patch": "@@ -41,7 +41,7 @@ pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n \tpath.segments.iter().rev().zip(segments.iter().rev()).all(\n-\t\t|(a,b)| a.identifier.as_str() == *b)\n+\t\t|(a,b)| a.identifier.name == b)\n }\n \n /// convert a span to a code snippet if available, otherwise use default, e.g."}]}