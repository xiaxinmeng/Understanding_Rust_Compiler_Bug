{"sha": "5f9c004d355ecff847743de3c6a16e8f3c17ef71", "node_id": "C_kwDOAAsO6NoAKDVmOWMwMDRkMzU1ZWNmZjg0Nzc0M2RlM2M2YTE2ZThmM2MxN2VmNzE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-29T15:56:47Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-23T19:52:27Z"}, "message": "Separate find_*_stability.", "tree": {"sha": "e2bf4e0d6ff0753566798ff42ac9d922dff7ff6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2bf4e0d6ff0753566798ff42ac9d922dff7ff6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f9c004d355ecff847743de3c6a16e8f3c17ef71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f9c004d355ecff847743de3c6a16e8f3c17ef71", "html_url": "https://github.com/rust-lang/rust/commit/5f9c004d355ecff847743de3c6a16e8f3c17ef71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f9c004d355ecff847743de3c6a16e8f3c17ef71/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17f1db672ef5fa3200a2e21791ad3ed3d174b6ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/17f1db672ef5fa3200a2e21791ad3ed3d174b6ac", "html_url": "https://github.com/rust-lang/rust/commit/17f1db672ef5fa3200a2e21791ad3ed3d174b6ac"}], "stats": {"total": 218, "additions": 101, "deletions": 117}, "files": [{"sha": "ccc5eedfe260fcddc9b318afa2077d26b5c9797d", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 93, "deletions": 113, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c004d355ecff847743de3c6a16e8f3c17ef71/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c004d355ecff847743de3c6a16e8f3c17ef71/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=5f9c004d355ecff847743de3c6a16e8f3c17ef71", "patch": "@@ -232,118 +232,89 @@ pub fn find_stability(\n     sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-{\n-    find_stability_generic(sess, attrs.iter(), item_sp)\n+) -> Option<(Stability, Span)> {\n+    let mut stab: Option<(Stability, Span)> = None;\n+    let mut allowed_through_unstable_modules = false;\n+\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_allowed_through_unstable_modules => allowed_through_unstable_modules = true,\n+            sym::unstable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n+\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n+                }\n+            }\n+            sym::stable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    if allowed_through_unstable_modules {\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n+        }\n+    }\n+\n+    stab\n }\n \n-fn find_stability_generic<'a, I>(\n+/// Collects stability info from all stability attributes in `attrs`.\n+/// Returns `None` if no stability attributes are found.\n+pub fn find_const_stability(\n     sess: &Session,\n-    attrs_iter: I,\n+    attrs: &[Attribute],\n     item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-where\n-    I: Iterator<Item = &'a Attribute>,\n-{\n-    let mut stab: Option<(Stability, Span)> = None;\n+) -> Option<(ConstStability, Span)> {\n     let mut const_stab: Option<(ConstStability, Span)> = None;\n-    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n     let mut promotable = false;\n-    let mut allowed_through_unstable_modules = false;\n-\n-    for attr in attrs_iter {\n-        if ![\n-            sym::rustc_const_unstable,\n-            sym::rustc_const_stable,\n-            sym::unstable,\n-            sym::stable,\n-            sym::rustc_promotable,\n-            sym::rustc_allowed_through_unstable_modules,\n-            sym::rustc_default_body_unstable,\n-        ]\n-        .iter()\n-        .any(|&s| attr.has_name(s))\n-        {\n-            continue; // not a stability level\n-        }\n \n-        let meta = attr.meta();\n-\n-        if attr.has_name(sym::rustc_promotable) {\n-            promotable = true;\n-        } else if attr.has_name(sym::rustc_allowed_through_unstable_modules) {\n-            allowed_through_unstable_modules = true;\n-        } else if let Some(meta) = &meta {\n-            let meta_name = meta.name_or_empty();\n-            match meta_name {\n-                sym::rustc_const_unstable | sym::rustc_default_body_unstable | sym::unstable => {\n-                    if meta_name == sym::unstable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_unstable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_default_body_unstable && body_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_promotable => promotable = true,\n+            sym::rustc_const_unstable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n \n-                    if let Some((feature, level)) = parse_unstability(sess, attr) {\n-                        if sym::unstable == meta_name {\n-                            stab = Some((Stability { level, feature }, attr.span));\n-                        } else if sym::rustc_const_unstable == meta_name {\n-                            const_stab = Some((\n-                                ConstStability { level, feature, promotable: false },\n-                                attr.span,\n-                            ));\n-                        } else if sym::rustc_default_body_unstable == meta_name {\n-                            body_stab = Some((DefaultBodyStability { level, feature }, attr.span));\n-                        } else {\n-                            unreachable!(\"Unknown stability attribute {meta_name}\");\n-                        }\n-                    }\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n                 }\n-                sym::rustc_const_stable | sym::stable => {\n-                    if meta_name == sym::stable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_stable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n-                    if let Some((feature, level)) = parse_stability(sess, attr) {\n-                        if sym::stable == meta_name {\n-                            stab = Some((Stability { level, feature }, attr.span));\n-                        } else {\n-                            const_stab = Some((\n-                                ConstStability { level, feature, promotable: false },\n-                                attr.span,\n-                            ));\n-                        }\n-                    }\n+            }\n+            sym::rustc_const_stable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n                 }\n-                _ => unreachable!(),\n             }\n+            _ => {}\n         }\n     }\n \n@@ -355,22 +326,31 @@ where\n         }\n     }\n \n-    if allowed_through_unstable_modules {\n-        match &mut stab {\n-            Some((\n-                Stability {\n-                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n-                    ..\n-                },\n-                _,\n-            )) => *allowed_through_unstable_modules = true,\n-            _ => {\n-                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+    const_stab\n+}\n+\n+/// Collects stability info from all stability attributes in `attrs`.\n+/// Returns `None` if no stability attributes are found.\n+pub fn find_body_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+) -> Option<(DefaultBodyStability, Span)> {\n+    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n+\n+    for attr in attrs {\n+        if attr.has_name(sym::rustc_default_body_unstable) {\n+            if body_stab.is_some() {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                break;\n+            }\n+\n+            if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                body_stab = Some((DefaultBodyStability { level, feature }, attr.span));\n             }\n         }\n     }\n \n-    (stab, const_stab, body_stab)\n+    body_stab\n }\n \n fn parse_stability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {"}, {"sha": "caa2a201c758dbfae4dd1a6398ea05e264670b14", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c004d355ecff847743de3c6a16e8f3c17ef71/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c004d355ecff847743de3c6a16e8f3c17ef71/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=5f9c004d355ecff847743de3c6a16e8f3c17ef71", "patch": "@@ -793,7 +793,9 @@ impl SyntaxExtension {\n                 )\n             })\n             .unwrap_or_else(|| (None, helper_attrs));\n-        let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n+        let stability = attr::find_stability(&sess, attrs, span);\n+        let const_stability = attr::find_const_stability(&sess, attrs, span);\n+        let body_stability = attr::find_body_stability(&sess, attrs);\n         if let Some((_, sp)) = const_stability {\n             sess.emit_err(errors::MacroConstStability {\n                 span: sp,"}, {"sha": "4a1ba19c92064c714bfd5c3ca00cc4a0b3bfc101", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f9c004d355ecff847743de3c6a16e8f3c17ef71/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9c004d355ecff847743de3c6a16e8f3c17ef71/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=5f9c004d355ecff847743de3c6a16e8f3c17ef71", "patch": "@@ -159,7 +159,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             return;\n         }\n \n-        let (stab, const_stab, body_stab) = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let stab = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let const_stab = attr::find_const_stability(&self.tcx.sess, attrs, item_sp);\n+        let body_stab = attr::find_body_stability(&self.tcx.sess, attrs);\n         let mut const_span = None;\n \n         let const_stab = const_stab.map(|(const_stab, const_span_node)| {\n@@ -742,8 +744,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                 let features = self.tcx.features();\n                 if features.staged_api {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n-                    let (stab, const_stab, _) =\n-                        attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let stab = attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let const_stab = attr::find_const_stability(&self.tcx.sess, attrs, item.span);\n \n                     // If this impl block has an #[unstable] attribute, give an\n                     // error if all involved types and traits are stable, because"}]}