{"sha": "d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MWE5OGVjODQzZWM4NTYyYzU4Y2NiMDFhMWUyOWQwMGNjNzQ0ZGM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-07T13:15:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T08:20:15Z"}, "message": "switch ra_syntax to new rowan API", "tree": {"sha": "c628b6afbbe2e3a31ea88e6c16f556309dd0dde9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c628b6afbbe2e3a31ea88e6c16f556309dd0dde9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "html_url": "https://github.com/rust-lang/rust/commit/d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55272f2023e69f3eff727ecbf77078e1b45e7f86", "url": "https://api.github.com/repos/rust-lang/rust/commits/55272f2023e69f3eff727ecbf77078e1b45e7f86", "html_url": "https://github.com/rust-lang/rust/commit/55272f2023e69f3eff727ecbf77078e1b45e7f86"}], "stats": {"total": 593, "additions": 266, "deletions": 327}, "files": [{"sha": "13f50d2ef80438a16b7f2d40750ceacf7e9da19f", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -1,19 +1,23 @@\n pub mod visit;\n \n-use crate::{SyntaxNode, SyntaxNodeRef, TextRange, TextUnit};\n+use rowan::TransparentNewType;\n+\n+use crate::{SyntaxNode, TextRange, TextUnit};\n \n pub use rowan::LeafAtOffset;\n \n-pub fn find_leaf_at_offset(node: SyntaxNodeRef, offset: TextUnit) -> LeafAtOffset<SyntaxNodeRef> {\n+pub fn find_leaf_at_offset(node: &SyntaxNode, offset: TextUnit) -> LeafAtOffset<&SyntaxNode> {\n     match node.0.leaf_at_offset(offset) {\n         LeafAtOffset::None => LeafAtOffset::None,\n-        LeafAtOffset::Single(n) => LeafAtOffset::Single(SyntaxNode(n)),\n-        LeafAtOffset::Between(l, r) => LeafAtOffset::Between(SyntaxNode(l), SyntaxNode(r)),\n+        LeafAtOffset::Single(n) => LeafAtOffset::Single(SyntaxNode::from_repr(n)),\n+        LeafAtOffset::Between(l, r) => {\n+            LeafAtOffset::Between(SyntaxNode::from_repr(l), SyntaxNode::from_repr(r))\n+        }\n     }\n }\n \n-pub fn find_covering_node(root: SyntaxNodeRef, range: TextRange) -> SyntaxNodeRef {\n-    SyntaxNode(root.0.covering_node(range))\n+pub fn find_covering_node(root: &SyntaxNode, range: TextRange) -> &SyntaxNode {\n+    SyntaxNode::from_repr(root.0.covering_node(range))\n }\n \n pub fn generate<T>(seed: Option<T>, step: impl Fn(&T) -> Option<T>) -> impl Iterator<Item = T> {"}, {"sha": "38f21594cd46dad43c6d56b10aa5fbe17789eb8d", "filename": "crates/ra_syntax/src/algo/visit.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -1,4 +1,4 @@\n-use crate::{AstNode, SyntaxNodeRef};\n+use crate::{AstNode, SyntaxNode};\n \n use std::marker::PhantomData;\n \n@@ -15,11 +15,11 @@ pub fn visitor_ctx<'a, T, C>(ctx: C) -> impl VisitorCtx<'a, Output = T, Ctx = C>\n \n pub trait Visitor<'a>: Sized {\n     type Output;\n-    fn accept(self, node: SyntaxNodeRef<'a>) -> Option<Self::Output>;\n+    fn accept(self, node: &'a SyntaxNode) -> Option<Self::Output>;\n     fn visit<N, F>(self, f: F) -> Vis<Self, N, F>\n     where\n-        N: AstNode<'a>,\n-        F: FnOnce(N) -> Self::Output,\n+        N: AstNode + 'a,\n+        F: FnOnce(&'a N) -> Self::Output,\n     {\n         Vis {\n             inner: self,\n@@ -32,11 +32,11 @@ pub trait Visitor<'a>: Sized {\n pub trait VisitorCtx<'a>: Sized {\n     type Output;\n     type Ctx;\n-    fn accept(self, node: SyntaxNodeRef<'a>) -> Result<Self::Output, Self::Ctx>;\n+    fn accept(self, node: &'a SyntaxNode) -> Result<Self::Output, Self::Ctx>;\n     fn visit<N, F>(self, f: F) -> VisCtx<Self, N, F>\n     where\n-        N: AstNode<'a>,\n-        F: FnOnce(N, Self::Ctx) -> Self::Output,\n+        N: AstNode + 'a,\n+        F: FnOnce(&'a N, Self::Ctx) -> Self::Output,\n     {\n         VisCtx {\n             inner: self,\n@@ -54,7 +54,7 @@ struct EmptyVisitor<T> {\n impl<'a, T> Visitor<'a> for EmptyVisitor<T> {\n     type Output = T;\n \n-    fn accept(self, _node: SyntaxNodeRef<'a>) -> Option<T> {\n+    fn accept(self, _node: &'a SyntaxNode) -> Option<T> {\n         None\n     }\n }\n@@ -69,7 +69,7 @@ impl<'a, T, C> VisitorCtx<'a> for EmptyVisitorCtx<T, C> {\n     type Output = T;\n     type Ctx = C;\n \n-    fn accept(self, _node: SyntaxNodeRef<'a>) -> Result<T, C> {\n+    fn accept(self, _node: &'a SyntaxNode) -> Result<T, C> {\n         Err(self.ctx)\n     }\n }\n@@ -84,12 +84,12 @@ pub struct Vis<V, N, F> {\n impl<'a, V, N, F> Visitor<'a> for Vis<V, N, F>\n where\n     V: Visitor<'a>,\n-    N: AstNode<'a>,\n-    F: FnOnce(N) -> <V as Visitor<'a>>::Output,\n+    N: AstNode + 'a,\n+    F: FnOnce(&'a N) -> <V as Visitor<'a>>::Output,\n {\n     type Output = <V as Visitor<'a>>::Output;\n \n-    fn accept(self, node: SyntaxNodeRef<'a>) -> Option<Self::Output> {\n+    fn accept(self, node: &'a SyntaxNode) -> Option<Self::Output> {\n         let Vis { inner, f, .. } = self;\n         inner.accept(node).or_else(|| N::cast(node).map(f))\n     }\n@@ -105,13 +105,13 @@ pub struct VisCtx<V, N, F> {\n impl<'a, V, N, F> VisitorCtx<'a> for VisCtx<V, N, F>\n where\n     V: VisitorCtx<'a>,\n-    N: AstNode<'a>,\n-    F: FnOnce(N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n+    N: AstNode + 'a,\n+    F: FnOnce(&'a N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n {\n     type Output = <V as VisitorCtx<'a>>::Output;\n     type Ctx = <V as VisitorCtx<'a>>::Ctx;\n \n-    fn accept(self, node: SyntaxNodeRef<'a>) -> Result<Self::Output, Self::Ctx> {\n+    fn accept(self, node: &'a SyntaxNode) -> Result<Self::Output, Self::Ctx> {\n         let VisCtx { inner, f, .. } = self;\n         inner.accept(node).or_else(|ctx| match N::cast(node) {\n             None => Err(ctx),"}, {"sha": "285dda1e0c50871361f10a47ea8ce0e2f2c94ab0", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 84, "deletions": 115, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -1,119 +1,88 @@\n mod generated;\n \n use std::marker::PhantomData;\n-use std::string::String as RustString;\n \n use itertools::Itertools;\n \n pub use self::generated::*;\n use crate::{\n-    yellow::{RefRoot, SyntaxNodeChildren},\n+    yellow::{SyntaxNode, SyntaxNodeChildren, TreePtr, RaTypes},\n     SmolStr,\n     SyntaxKind::*,\n-    SyntaxNodeRef,\n };\n \n /// The main trait to go from untyped `SyntaxNode`  to a typed ast. The\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n-pub trait AstNode<'a>: Clone + Copy + 'a {\n-    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self>\n+pub trait AstNode: rowan::TransparentNewType<Repr = rowan::SyntaxNode<RaTypes>> {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self>\n     where\n         Self: Sized;\n-    fn syntax(self) -> SyntaxNodeRef<'a>;\n+    fn syntax(&self) -> &SyntaxNode;\n+    fn to_owned(&self) -> TreePtr<Self>;\n }\n \n-pub trait NameOwner<'a>: AstNode<'a> {\n-    fn name(self) -> Option<Name<'a>> {\n+pub trait NameOwner: AstNode {\n+    fn name(&self) -> Option<&Name> {\n         child_opt(self)\n     }\n }\n \n-pub trait VisibilityOwner<'a>: AstNode<'a> {\n-    fn visibility(self) -> Option<Visibility<'a>> {\n+pub trait VisibilityOwner: AstNode {\n+    fn visibility(&self) -> Option<&Visibility> {\n         child_opt(self)\n     }\n }\n \n-pub trait LoopBodyOwner<'a>: AstNode<'a> {\n-    fn loop_body(self) -> Option<Block<'a>> {\n+pub trait LoopBodyOwner: AstNode {\n+    fn loop_body(&self) -> Option<&Block> {\n         child_opt(self)\n     }\n }\n \n-pub trait ArgListOwner<'a>: AstNode<'a> {\n-    fn arg_list(self) -> Option<ArgList<'a>> {\n+pub trait ArgListOwner: AstNode {\n+    fn arg_list(&self) -> Option<&ArgList> {\n         child_opt(self)\n     }\n }\n \n-pub trait FnDefOwner<'a>: AstNode<'a> {\n-    fn functions(self) -> AstChildren<'a, FnDef<'a>> {\n+pub trait FnDefOwner: AstNode {\n+    fn functions(&self) -> AstChildren<FnDef> {\n         children(self)\n     }\n }\n \n-// ModuleItem\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ItemOrMacro<'a> {\n-    Item(ModuleItem<'a>),\n-    Macro(MacroCall<'a>),\n-}\n-\n-impl<'a> AstNode<'a> for ItemOrMacro<'a> {\n-    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n-        let res = if let Some(item) = ModuleItem::cast(syntax) {\n-            ItemOrMacro::Item(item)\n-        } else if let Some(macro_call) = MacroCall::cast(syntax) {\n-            ItemOrMacro::Macro(macro_call)\n-        } else {\n-            return None;\n-        };\n-        Some(res)\n-    }\n-    fn syntax(self) -> SyntaxNodeRef<'a> {\n-        match self {\n-            ItemOrMacro::Item(it) => it.syntax(),\n-            ItemOrMacro::Macro(it) => it.syntax(),\n-        }\n-    }\n-}\n-\n-pub trait ModuleItemOwner<'a>: AstNode<'a> {\n-    fn items(self) -> AstChildren<'a, ModuleItem<'a>> {\n-        children(self)\n-    }\n-\n-    fn items_with_macros(self) -> AstChildren<'a, ItemOrMacro<'a>> {\n+pub trait ModuleItemOwner: AstNode {\n+    fn items(&self) -> AstChildren<ModuleItem> {\n         children(self)\n     }\n }\n \n-pub trait TypeParamsOwner<'a>: AstNode<'a> {\n-    fn type_param_list(self) -> Option<TypeParamList<'a>> {\n+pub trait TypeParamsOwner: AstNode {\n+    fn type_param_list(&self) -> Option<&TypeParamList> {\n         child_opt(self)\n     }\n \n-    fn where_clause(self) -> Option<WhereClause<'a>> {\n+    fn where_clause(&self) -> Option<&WhereClause> {\n         child_opt(self)\n     }\n }\n \n-pub trait AttrsOwner<'a>: AstNode<'a> {\n-    fn attrs(self) -> AstChildren<'a, Attr<'a>> {\n+pub trait AttrsOwner: AstNode {\n+    fn attrs(&self) -> AstChildren<Attr> {\n         children(self)\n     }\n }\n \n-pub trait DocCommentsOwner<'a>: AstNode<'a> {\n-    fn doc_comments(self) -> AstChildren<'a, Comment<'a>> {\n+pub trait DocCommentsOwner: AstNode {\n+    fn doc_comments(&self) -> AstChildren<Comment> {\n         children(self)\n     }\n \n     /// Returns the textual content of a doc comment block as a single string.\n     /// That is, strips leading `///` and joins lines\n-    fn doc_comment_text(self) -> RustString {\n+    fn doc_comment_text(&self) -> std::string::String {\n         self.doc_comments()\n             .filter(|comment| comment.is_doc_comment())\n             .map(|comment| {\n@@ -130,13 +99,13 @@ pub trait DocCommentsOwner<'a>: AstNode<'a> {\n     }\n }\n \n-impl<'a> FnDef<'a> {\n+impl FnDef {\n     pub fn has_atom_attr(&self, atom: &str) -> bool {\n         self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n     }\n }\n \n-impl<'a> Attr<'a> {\n+impl Attr {\n     pub fn as_atom(&self) -> Option<SmolStr> {\n         let tt = self.value()?;\n         let (_bra, attr, _ket) = tt.syntax().children().collect_tuple()?;\n@@ -147,7 +116,7 @@ impl<'a> Attr<'a> {\n         }\n     }\n \n-    pub fn as_call(&self) -> Option<(SmolStr, TokenTree<'a>)> {\n+    pub fn as_call(&self) -> Option<(SmolStr, &TokenTree)> {\n         let tt = self.value()?;\n         let (_bra, attr, args, _ket) = tt.syntax().children().collect_tuple()?;\n         let args = TokenTree::cast(args)?;\n@@ -159,37 +128,37 @@ impl<'a> Attr<'a> {\n     }\n }\n \n-impl<'a> Lifetime<'a> {\n+impl Lifetime {\n     pub fn text(&self) -> SmolStr {\n         self.syntax().leaf_text().unwrap().clone()\n     }\n }\n \n-impl<'a> Char<'a> {\n+impl Char {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n }\n \n-impl<'a> Byte<'a> {\n+impl Byte {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n }\n \n-impl<'a> ByteString<'a> {\n+impl ByteString {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n }\n \n-impl<'a> String<'a> {\n+impl String {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n }\n \n-impl<'a> Comment<'a> {\n+impl Comment {\n     pub fn text(&self) -> &SmolStr {\n         self.syntax().leaf_text().unwrap()\n     }\n@@ -251,7 +220,7 @@ impl CommentFlavor {\n     }\n }\n \n-impl<'a> Whitespace<'a> {\n+impl Whitespace {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()\n     }\n@@ -265,90 +234,90 @@ impl<'a> Whitespace<'a> {\n     }\n }\n \n-impl<'a> Name<'a> {\n+impl Name {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child().unwrap();\n         ident.leaf_text().unwrap().clone()\n     }\n }\n \n-impl<'a> NameRef<'a> {\n+impl NameRef {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child().unwrap();\n         ident.leaf_text().unwrap().clone()\n     }\n }\n \n-impl<'a> ImplBlock<'a> {\n-    pub fn target_type(self) -> Option<TypeRef<'a>> {\n+impl ImplBlock {\n+    pub fn target_type(&self) -> Option<&TypeRef> {\n         match self.target() {\n             (Some(t), None) | (_, Some(t)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    pub fn target_trait(self) -> Option<TypeRef<'a>> {\n+    pub fn target_trait(&self) -> Option<&TypeRef> {\n         match self.target() {\n             (Some(t), Some(_)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    fn target(self) -> (Option<TypeRef<'a>>, Option<TypeRef<'a>>) {\n+    fn target(&self) -> (Option<&TypeRef>, Option<&TypeRef>) {\n         let mut types = children(self);\n         let first = types.next();\n         let second = types.next();\n         (first, second)\n     }\n }\n \n-impl<'a> Module<'a> {\n-    pub fn has_semi(self) -> bool {\n+impl Module {\n+    pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child() {\n             None => false,\n             Some(node) => node.kind() == SEMI,\n         }\n     }\n }\n \n-impl<'a> LetStmt<'a> {\n-    pub fn has_semi(self) -> bool {\n+impl LetStmt {\n+    pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child() {\n             None => false,\n             Some(node) => node.kind() == SEMI,\n         }\n     }\n }\n \n-impl<'a> IfExpr<'a> {\n-    pub fn then_branch(self) -> Option<Block<'a>> {\n+impl IfExpr {\n+    pub fn then_branch(&self) -> Option<&Block> {\n         self.blocks().nth(0)\n     }\n-    pub fn else_branch(self) -> Option<Block<'a>> {\n+    pub fn else_branch(&self) -> Option<&Block> {\n         self.blocks().nth(1)\n     }\n-    fn blocks(self) -> AstChildren<'a, Block<'a>> {\n+    fn blocks(&self) -> AstChildren<Block> {\n         children(self)\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum PathSegmentKind<'a> {\n-    Name(NameRef<'a>),\n+    Name(&'a NameRef),\n     SelfKw,\n     SuperKw,\n     CrateKw,\n }\n \n-impl<'a> PathSegment<'a> {\n-    pub fn parent_path(self) -> Path<'a> {\n+impl PathSegment {\n+    pub fn parent_path(&self) -> &Path {\n         self.syntax()\n             .parent()\n             .and_then(Path::cast)\n             .expect(\"segments are always nested in paths\")\n     }\n \n-    pub fn kind(self) -> Option<PathSegmentKind<'a>> {\n+    pub fn kind(&self) -> Option<PathSegmentKind> {\n         let res = if let Some(name_ref) = self.name_ref() {\n             PathSegmentKind::Name(name_ref)\n         } else {\n@@ -363,53 +332,53 @@ impl<'a> PathSegment<'a> {\n     }\n }\n \n-impl<'a> Path<'a> {\n-    pub fn parent_path(self) -> Option<Path<'a>> {\n+impl Path {\n+    pub fn parent_path(&self) -> Option<&Path> {\n         self.syntax().parent().and_then(Path::cast)\n     }\n }\n \n-impl<'a> UseTree<'a> {\n-    pub fn has_star(self) -> bool {\n+impl UseTree {\n+    pub fn has_star(&self) -> bool {\n         self.syntax().children().any(|it| it.kind() == STAR)\n     }\n }\n \n-impl<'a> UseTreeList<'a> {\n-    pub fn parent_use_tree(self) -> UseTree<'a> {\n+impl UseTreeList {\n+    pub fn parent_use_tree(&self) -> &UseTree {\n         self.syntax()\n             .parent()\n             .and_then(UseTree::cast)\n             .expect(\"UseTreeLists are always nested in UseTrees\")\n     }\n }\n \n-fn child_opt<'a, P: AstNode<'a>, C: AstNode<'a>>(parent: P) -> Option<C> {\n+fn child_opt<P: AstNode, C: AstNode>(parent: &P) -> Option<&C> {\n     children(parent).next()\n }\n \n-fn children<'a, P: AstNode<'a>, C: AstNode<'a>>(parent: P) -> AstChildren<'a, C> {\n+fn children<P: AstNode, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n #[derive(Debug)]\n pub struct AstChildren<'a, N> {\n-    inner: SyntaxNodeChildren<RefRoot<'a>>,\n+    inner: SyntaxNodeChildren<'a>,\n     ph: PhantomData<N>,\n }\n \n impl<'a, N> AstChildren<'a, N> {\n-    fn new(parent: SyntaxNodeRef<'a>) -> Self {\n+    fn new(parent: &'a SyntaxNode) -> Self {\n         AstChildren {\n             inner: parent.children(),\n             ph: PhantomData,\n         }\n     }\n }\n \n-impl<'a, N: AstNode<'a>> Iterator for AstChildren<'a, N> {\n-    type Item = N;\n-    fn next(&mut self) -> Option<N> {\n+impl<'a, N: AstNode + 'a> Iterator for AstChildren<'a, N> {\n+    type Item = &'a N;\n+    fn next(&mut self) -> Option<&'a N> {\n         loop {\n             if let Some(n) = N::cast(self.inner.next()?) {\n                 return Some(n);\n@@ -420,13 +389,13 @@ impl<'a, N: AstNode<'a>> Iterator for AstChildren<'a, N> {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum StructFlavor<'a> {\n-    Tuple(PosFieldList<'a>),\n-    Named(NamedFieldDefList<'a>),\n+    Tuple(&'a PosFieldList),\n+    Named(&'a NamedFieldDefList),\n     Unit,\n }\n \n-impl<'a> StructFlavor<'a> {\n-    fn from_node<N: AstNode<'a>>(node: N) -> StructFlavor<'a> {\n+impl StructFlavor<'_> {\n+    fn from_node<N: AstNode>(node: &N) -> StructFlavor {\n         if let Some(nfdl) = child_opt::<_, NamedFieldDefList>(node) {\n             StructFlavor::Named(nfdl)\n         } else if let Some(pfl) = child_opt::<_, PosFieldList>(node) {\n@@ -437,31 +406,31 @@ impl<'a> StructFlavor<'a> {\n     }\n }\n \n-impl<'a> StructDef<'a> {\n-    pub fn flavor(self) -> StructFlavor<'a> {\n+impl StructDef {\n+    pub fn flavor(&self) -> StructFlavor {\n         StructFlavor::from_node(self)\n     }\n }\n \n-impl<'a> EnumVariant<'a> {\n-    pub fn flavor(self) -> StructFlavor<'a> {\n+impl EnumVariant {\n+    pub fn flavor(&self) -> StructFlavor {\n         StructFlavor::from_node(self)\n     }\n }\n \n-impl<'a> PointerType<'a> {\n+impl PointerType {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children().any(|n| n.kind() == MUT_KW)\n     }\n }\n \n-impl<'a> ReferenceType<'a> {\n+impl ReferenceType {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children().any(|n| n.kind() == MUT_KW)\n     }\n }\n \n-impl<'a> RefExpr<'a> {\n+impl RefExpr {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children().any(|n| n.kind() == MUT_KW)\n     }\n@@ -477,7 +446,7 @@ pub enum PrefixOp {\n     Neg,\n }\n \n-impl<'a> PrefixExpr<'a> {\n+impl PrefixExpr {\n     pub fn op(&self) -> Option<PrefixOp> {\n         match self.syntax().first_child()?.kind() {\n             STAR => Some(PrefixOp::Deref),\n@@ -552,7 +521,7 @@ pub enum BinOp {\n     BitXorAssign,\n }\n \n-impl<'a> BinExpr<'a> {\n+impl BinExpr {\n     pub fn op(&self) -> Option<BinOp> {\n         self.syntax()\n             .children()\n@@ -592,15 +561,15 @@ impl<'a> BinExpr<'a> {\n             .next()\n     }\n \n-    pub fn lhs(self) -> Option<Expr<'a>> {\n+    pub fn lhs(&self) -> Option<&Expr> {\n         children(self).nth(0)\n     }\n \n-    pub fn rhs(self) -> Option<Expr<'a>> {\n+    pub fn rhs(&self) -> Option<&Expr> {\n         children(self).nth(1)\n     }\n \n-    pub fn sub_exprs(self) -> (Option<Expr<'a>>, Option<Expr<'a>>) {\n+    pub fn sub_exprs(&self) -> (Option<&Expr>, Option<&Expr>) {\n         let mut children = children(self);\n         let first = children.next();\n         let second = children.next();\n@@ -618,7 +587,7 @@ pub enum SelfParamFlavor {\n     MutRef,\n }\n \n-impl<'a> SelfParam<'a> {\n+impl SelfParam {\n     pub fn flavor(&self) -> SelfParamFlavor {\n         let borrowed = self.syntax().children().any(|n| n.kind() == AMP);\n         if borrowed {\n@@ -641,7 +610,7 @@ impl<'a> SelfParam<'a> {\n \n #[test]\n fn test_doc_comment_of_items() {\n-    let file = SourceFileNode::parse(\n+    let file = SourceFile::parse(\n         r#\"\n         //! doc\n         // non-doc"}, {"sha": "0a20fc78e74b4927656f802644e61a54a7acb734", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -11,89 +11,92 @@ the below applies to the result of this template\n \n #![cfg_attr(rustfmt, rustfmt_skip)]\n \n-use std::hash::{Hash, Hasher};\n+use rowan::TransparentNewType;\n \n use crate::{\n-    ast,\n-    SyntaxNode, SyntaxNodeRef, AstNode,\n-    yellow::{TreeRoot, RaTypes, OwnedRoot, RefRoot},\n-    SyntaxKind::*,\n+    SyntaxNode, SyntaxKind::*,\n+    yellow::{RaTypes, TreePtr},\n+    ast::{self, AstNode},\n };\n {% for node, methods in ast %}\n // {{ node }}\n \n {%- if methods.enum %}\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct {{ node }} {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for {{ node }} {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum {{ node }}<'a> {\n+pub enum {{ node }}Kind<'a> {\n {%- for kind in methods.enum %}\n-    {{ kind }}({{ kind }}<'a>),\n+    {{ kind }}(&'a {{ kind }}),\n {%- endfor %}\n }\n \n-impl<'a> AstNode<'a> for {{ node }}<'a> {\n-    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+impl AstNode for {{ node }} {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n         match syntax.kind() {\n-{%- for kind in methods.enum %}\n-            {{ kind | SCREAM }} => Some({{ node }}::{{ kind }}({{ kind }} { syntax })),\n-{%- endfor %}\n+            {%- for kind in methods.enum %}\n+            | {{ kind | SCREAM }}\n+            {%- endfor %} => Some({{ node }}::from_repr(syntax.into_repr())),\n             _ => None,\n         }\n     }\n-    fn syntax(self) -> SyntaxNodeRef<'a> {\n-        match self {\n-{%- for kind in methods.enum %}\n-            {{ node }}::{{ kind }}(inner) => inner.syntax(),\n-{%- endfor %}\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreePtr<{{ node }}> { TreePtr::cast(self.syntax.to_owned()) }\n+}\n+\n+impl {{ node }} {\n+    pub fn kind(&self) -> {{ node }}Kind {\n+        match self.syntax.kind() {\n+            {%- for kind in methods.enum %}\n+            {{ kind | SCREAM }} => {{ node }}Kind::{{ kind }}({{ kind }}::cast(&self.syntax).unwrap()),\n+            {%- endfor %}\n+            _ => unreachable!(),\n         }\n     }\n }\n {% else %}\n-#[derive(Debug, Clone, Copy,)]\n-pub struct {{ node }}Node<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    pub(crate) syntax: SyntaxNode<R>,\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct {{ node }} {\n+    pub(crate) syntax: SyntaxNode,\n }\n-pub type {{ node }}<'a> = {{ node }}Node<RefRoot<'a>>;\n-\n-impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<{{node}}Node<R1>> for {{node}}Node<R2> {\n-    fn eq(&self, other: &{{node}}Node<R1>) -> bool { self.syntax == other.syntax }\n-}\n-impl<R: TreeRoot<RaTypes>> Eq for {{node}}Node<R> {}\n-impl<R: TreeRoot<RaTypes>> Hash for {{node}}Node<R> {\n-    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+unsafe impl TransparentNewType for {{ node }} {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n }\n \n-impl<'a> AstNode<'a> for {{ node }}<'a> {\n-    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+impl AstNode for {{ node }} {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n         match syntax.kind() {\n-            {{ node | SCREAM }} => Some({{ node }} { syntax }),\n+            {{ node | SCREAM }} => Some({{ node }}::from_repr(syntax.into_repr())),\n             _ => None,\n         }\n     }\n-    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n-}\n-\n-impl<R: TreeRoot<RaTypes>> {{ node }}Node<R> {\n-    pub fn borrowed(&self) -> {{ node }} {\n-        {{ node }}Node { syntax: self.syntax.borrowed() }\n-    }\n-    pub fn owned(&self) -> {{ node }}Node {\n-        {{ node }}Node { syntax: self.syntax.owned() }\n-    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreePtr<{{ node }}> { TreePtr::cast(self.syntax.to_owned()) }\n }\n \n {% endif %}\n {% if methods.traits -%}\n+\n {%- for t in methods.traits -%}\n-impl<'a> ast::{{ t }}<'a> for {{ node }}<'a> {}\n+impl ast::{{ t }} for {{ node }} {}\n {% endfor -%}\n+\n {%- endif -%}\n \n-impl<'a> {{ node }}<'a> {\n+impl {{ node }} {\n {%- if methods.collections -%}\n {%- for m in methods.collections -%}\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n-    pub fn {{ method_name }}(self) -> impl Iterator<Item = {{ ChildName }}<'a>> + 'a {\n+    pub fn {{ method_name }}(&self) -> impl Iterator<Item = &{{ ChildName }}> {\n         super::children(self)\n     }\n {% endfor -%}\n@@ -109,7 +112,7 @@ impl<'a> {{ node }}<'a> {\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n {%- endif %}\n-    pub fn {{ method_name }}(self) -> Option<{{ ChildName }}<'a>> {\n+    pub fn {{ method_name }}(&self) -> Option<&{{ ChildName }}> {\n         super::child_opt(self)\n     }\n {% endfor -%}"}, {"sha": "a75e641eada1ff0a2755aeae3271363ac46b2b5e", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -42,52 +42,42 @@ pub use crate::{\n     ast::AstNode,\n     lexer::{tokenize, Token},\n     syntax_kinds::SyntaxKind,\n-    yellow::{\n-        Direction, OwnedRoot, RefRoot, SyntaxError, SyntaxNode, SyntaxNodeRef, TreeRoot, WalkEvent, Location,\n-    },\n+    yellow::{Direction, SyntaxError, SyntaxNode, WalkEvent, Location, TreePtr},\n };\n \n use ra_text_edit::AtomTextEdit;\n use crate::yellow::GreenNode;\n \n-/// `SourceFileNode` represents a parse tree for a single Rust file.\n-pub use crate::ast::{SourceFile, SourceFileNode};\n+/// `SourceFile` represents a parse tree for a single Rust file.\n+pub use crate::ast::SourceFile;\n \n-impl SourceFileNode {\n-    fn new(green: GreenNode, errors: Vec<SyntaxError>) -> SourceFileNode {\n+impl SourceFile {\n+    fn new(green: GreenNode, errors: Vec<SyntaxError>) -> TreePtr<SourceFile> {\n         let root = SyntaxNode::new(green, errors);\n         if cfg!(debug_assertions) {\n-            utils::validate_block_structure(root.borrowed());\n+            utils::validate_block_structure(&root);\n         }\n         assert_eq!(root.kind(), SyntaxKind::SOURCE_FILE);\n-        ast::SourceFileNode { syntax: root }\n+        TreePtr::cast(root)\n     }\n-    pub fn parse(text: &str) -> SourceFileNode {\n+    pub fn parse(text: &str) -> TreePtr<SourceFile> {\n         let tokens = tokenize(&text);\n         let (green, errors) =\n             parser_impl::parse_with(yellow::GreenBuilder::new(), text, &tokens, grammar::root);\n-        SourceFileNode::new(green, errors)\n+        SourceFile::new(green, errors)\n     }\n-    pub fn reparse(&self, edit: &AtomTextEdit) -> SourceFileNode {\n+    pub fn reparse(&self, edit: &AtomTextEdit) -> TreePtr<SourceFile> {\n         self.incremental_reparse(edit)\n             .unwrap_or_else(|| self.full_reparse(edit))\n     }\n-    pub fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<SourceFileNode> {\n+    pub fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<TreePtr<SourceFile>> {\n         reparsing::incremental_reparse(self.syntax(), edit, self.errors())\n-            .map(|(green_node, errors)| SourceFileNode::new(green_node, errors))\n+            .map(|(green_node, errors)| SourceFile::new(green_node, errors))\n     }\n-    fn full_reparse(&self, edit: &AtomTextEdit) -> SourceFileNode {\n+    fn full_reparse(&self, edit: &AtomTextEdit) -> TreePtr<SourceFile> {\n         let text =\n             text_utils::replace_range(self.syntax().text().to_string(), edit.delete, &edit.insert);\n-        SourceFileNode::parse(&text)\n-    }\n-    /// Typed AST representation of the parse tree.\n-    pub fn ast(&self) -> ast::SourceFile {\n-        self.borrowed()\n-    }\n-    /// Untyped homogeneous representation of the parse tree.\n-    pub fn syntax(&self) -> SyntaxNodeRef {\n-        self.syntax.borrowed()\n+        SourceFile::parse(&text)\n     }\n     pub fn errors(&self) -> Vec<SyntaxError> {\n         let mut errors = self.syntax.root_data().clone();"}, {"sha": "d5d72e1f8e5220f944a2f794304b74b93d3f2bfb", "filename": "crates/ra_syntax/src/reparsing.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Freparsing.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -4,12 +4,12 @@ use crate::lexer::{tokenize, Token};\n use crate::parser_api::Parser;\n use crate::parser_impl;\n use crate::text_utils::replace_range;\n-use crate::yellow::{self, GreenNode, SyntaxError, SyntaxNodeRef};\n+use crate::yellow::{self, GreenNode, SyntaxError, SyntaxNode};\n use crate::{SyntaxKind::*, TextRange, TextUnit};\n use ra_text_edit::AtomTextEdit;\n \n pub(crate) fn incremental_reparse(\n-    node: SyntaxNodeRef,\n+    node: &SyntaxNode,\n     edit: &AtomTextEdit,\n     errors: Vec<SyntaxError>,\n ) -> Option<(GreenNode, Vec<SyntaxError>)> {\n@@ -21,9 +21,9 @@ pub(crate) fn incremental_reparse(\n }\n \n fn reparse_leaf<'node>(\n-    node: SyntaxNodeRef<'node>,\n+    node: &'node SyntaxNode,\n     edit: &AtomTextEdit,\n-) -> Option<(SyntaxNodeRef<'node>, GreenNode, Vec<SyntaxError>)> {\n+) -> Option<(&'node SyntaxNode, GreenNode, Vec<SyntaxError>)> {\n     let node = algo::find_covering_node(node, edit.delete);\n     match node.kind() {\n         WHITESPACE | COMMENT | IDENT | STRING | RAW_STRING => {\n@@ -47,9 +47,9 @@ fn reparse_leaf<'node>(\n }\n \n fn reparse_block<'node>(\n-    node: SyntaxNodeRef<'node>,\n+    node: &'node SyntaxNode,\n     edit: &AtomTextEdit,\n-) -> Option<(SyntaxNodeRef<'node>, GreenNode, Vec<SyntaxError>)> {\n+) -> Option<(&'node SyntaxNode, GreenNode, Vec<SyntaxError>)> {\n     let (node, reparser) = find_reparsable_node(node, edit.delete)?;\n     let text = get_text_after_edit(node, &edit);\n     let tokens = tokenize(&text);\n@@ -61,7 +61,7 @@ fn reparse_block<'node>(\n     Some((node, green, new_errors))\n }\n \n-fn get_text_after_edit(node: SyntaxNodeRef, edit: &AtomTextEdit) -> String {\n+fn get_text_after_edit(node: &SyntaxNode, edit: &AtomTextEdit) -> String {\n     replace_range(\n         node.text().to_string(),\n         edit.delete - node.range().start(),\n@@ -77,17 +77,14 @@ fn is_contextual_kw(text: &str) -> bool {\n }\n \n type ParseFn = fn(&mut Parser);\n-fn find_reparsable_node(\n-    node: SyntaxNodeRef<'_>,\n-    range: TextRange,\n-) -> Option<(SyntaxNodeRef<'_>, ParseFn)> {\n+fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(&SyntaxNode, ParseFn)> {\n     let node = algo::find_covering_node(node, range);\n     return node\n         .ancestors()\n         .filter_map(|node| reparser(node).map(|r| (node, r)))\n         .next();\n \n-    fn reparser(node: SyntaxNodeRef) -> Option<ParseFn> {\n+    fn reparser(node: &SyntaxNode) -> Option<ParseFn> {\n         let res = match node.kind() {\n             BLOCK => grammar::block,\n             NAMED_FIELD_DEF_LIST => grammar::named_field_def_list,\n@@ -138,7 +135,7 @@ fn is_balanced(tokens: &[Token]) -> bool {\n fn merge_errors(\n     old_errors: Vec<SyntaxError>,\n     new_errors: Vec<SyntaxError>,\n-    old_node: SyntaxNodeRef,\n+    old_node: &SyntaxNode,\n     edit: &AtomTextEdit,\n ) -> Vec<SyntaxError> {\n     let mut res = Vec::new();\n@@ -159,22 +156,22 @@ fn merge_errors(\n mod tests {\n     use test_utils::{extract_range, assert_eq_text};\n \n-    use crate::{SourceFileNode, text_utils::replace_range, utils::dump_tree };\n+    use crate::{SourceFile, AstNode, text_utils::replace_range, utils::dump_tree};\n     use super::*;\n \n     fn do_check<F>(before: &str, replace_with: &str, reparser: F)\n     where\n         for<'a> F: Fn(\n-            SyntaxNodeRef<'a>,\n+            &'a SyntaxNode,\n             &AtomTextEdit,\n-        ) -> Option<(SyntaxNodeRef<'a>, GreenNode, Vec<SyntaxError>)>,\n+        ) -> Option<(&'a SyntaxNode, GreenNode, Vec<SyntaxError>)>,\n     {\n         let (range, before) = extract_range(before);\n         let after = replace_range(before.clone(), range, replace_with);\n \n-        let fully_reparsed = SourceFileNode::parse(&after);\n+        let fully_reparsed = SourceFile::parse(&after);\n         let incrementally_reparsed = {\n-            let f = SourceFileNode::parse(&before);\n+            let f = SourceFile::parse(&before);\n             let edit = AtomTextEdit {\n                 delete: range,\n                 insert: replace_with.to_string(),\n@@ -183,7 +180,7 @@ mod tests {\n                 reparser(f.syntax(), &edit).expect(\"cannot incrementally reparse\");\n             let green_root = node.replace_with(green);\n             let errors = super::merge_errors(f.errors(), new_errors, node, &edit);\n-            SourceFileNode::new(green_root, errors)\n+            SourceFile::new(green_root, errors)\n         };\n \n         assert_eq_text!("}, {"sha": "2e1b42da0f6af6b90d2bb9543623b4733db34638", "filename": "crates/ra_syntax/src/utils.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Futils.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -1,11 +1,11 @@\n-use crate::{SourceFileNode, SyntaxKind, SyntaxNodeRef, WalkEvent, AstNode};\n-use std::fmt::Write;\n-use std::str;\n+use std::{str, fmt::Write};\n+\n+use crate::{SourceFile, SyntaxKind, WalkEvent, AstNode, SyntaxNode};\n \n /// Parse a file and create a string representation of the resulting parse tree.\n-pub fn dump_tree(syntax: SyntaxNodeRef) -> String {\n-    let mut errors: Vec<_> = match syntax.ancestors().find_map(SourceFileNode::cast) {\n-        Some(file) => file.owned().errors(),\n+pub fn dump_tree(syntax: &SyntaxNode) -> String {\n+    let mut errors: Vec<_> = match syntax.ancestors().find_map(SourceFile::cast) {\n+        Some(file) => file.errors(),\n         None => syntax.root_data().to_vec(),\n     };\n     errors.sort_by_key(|e| e.offset());\n@@ -48,14 +48,13 @@ pub fn dump_tree(syntax: SyntaxNodeRef) -> String {\n }\n \n pub fn check_fuzz_invariants(text: &str) {\n-    let file = SourceFileNode::parse(text);\n+    let file = SourceFile::parse(text);\n     let root = file.syntax();\n     validate_block_structure(root);\n-    let _ = file.ast();\n     let _ = file.errors();\n }\n \n-pub(crate) fn validate_block_structure(root: SyntaxNodeRef) {\n+pub(crate) fn validate_block_structure(root: &SyntaxNode) {\n     let mut stack = Vec::new();\n     for node in root.descendants() {\n         match node.kind() {"}, {"sha": "73e1d20b9f86d09dc42045a74f49cd158949eb99", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -1,16 +1,15 @@\n-use crate::{\n-    algo::visit::{visitor_ctx, VisitorCtx},\n-    ast,\n-    SourceFileNode,\n-    yellow::SyntaxError,\n-};\n-\n mod byte;\n mod byte_string;\n mod char;\n mod string;\n \n-pub(crate) fn validate(file: &SourceFileNode) -> Vec<SyntaxError> {\n+use crate::{\n+    SourceFile, yellow::SyntaxError, AstNode,\n+    ast,\n+    algo::visit::{visitor_ctx, VisitorCtx},\n+};\n+\n+pub(crate) fn validate(file: &SourceFile) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();\n     for node in file.syntax().descendants() {\n         let _ = visitor_ctx(&mut errors)"}, {"sha": "4deb302a740c8ab235c5b85a8ed75d5b734c4ace", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     },\n };\n \n-pub(super) fn validate_byte_node(node: ast::Byte, errors: &mut Vec<SyntaxError>) {\n+pub(super) fn validate_byte_node(node: &ast::Byte, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_byte_literal(literal_text);\n@@ -106,11 +106,11 @@ fn validate_byte_code_escape(text: &str, range: TextRange, errors: &mut Vec<Synt\n \n #[cfg(test)]\n mod test {\n-    use crate::SourceFileNode;\n+    use crate::{SourceFile, TreePtr};\n \n-    fn build_file(literal: &str) -> SourceFileNode {\n+    fn build_file(literal: &str) -> TreePtr<SourceFile> {\n         let src = format!(\"const C: u8 = b'{}';\", literal);\n-        SourceFileNode::parse(&src)\n+        SourceFile::parse(&src)\n     }\n \n     fn assert_valid_byte(literal: &str) {"}, {"sha": "670c43a09a39b58c2a5a0f99e81cd16a0f8e8293", "filename": "crates/ra_syntax/src/validation/byte_string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -9,7 +9,7 @@ use crate::{\n \n use super::byte;\n \n-pub(crate) fn validate_byte_string_node(node: ast::ByteString, errors: &mut Vec<SyntaxError>) {\n+pub(crate) fn validate_byte_string_node(node: &ast::ByteString, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_byte_string_literal(literal_text);\n@@ -43,12 +43,12 @@ pub(crate) fn validate_byte_string_node(node: ast::ByteString, errors: &mut Vec<\n \n #[cfg(test)]\n mod test {\n-    use crate::SourceFileNode;\n+    use crate::{SourceFile, TreePtr};\n \n-    fn build_file(literal: &str) -> SourceFileNode {\n+    fn build_file(literal: &str) -> TreePtr<SourceFile> {\n         let src = format!(r#\"const S: &'static [u8] = b\"{}\";\"#, literal);\n         println!(\"Source: {}\", src);\n-        SourceFileNode::parse(&src)\n+        SourceFile::parse(&src)\n     }\n \n     fn assert_valid_str(literal: &str) {"}, {"sha": "9cbd43fba4166d719ec641a8e92b2c7b69261399", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     },\n };\n \n-pub(super) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n+pub(super) fn validate_char_node(node: &ast::Char, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_char_literal(literal_text);\n@@ -175,11 +175,11 @@ fn validate_unicode_escape(text: &str, range: TextRange, errors: &mut Vec<Syntax\n \n #[cfg(test)]\n mod test {\n-    use crate::SourceFileNode;\n+    use crate::{SourceFile, TreePtr};\n \n-    fn build_file(literal: &str) -> SourceFileNode {\n+    fn build_file(literal: &str) -> TreePtr<SourceFile> {\n         let src = format!(\"const C: char = '{}';\", literal);\n-        SourceFileNode::parse(&src)\n+        SourceFile::parse(&src)\n     }\n \n     fn assert_valid_char(literal: &str) {"}, {"sha": "7b2a68d1208ce0ca8ffe4a2997b8438d82e20bab", "filename": "crates/ra_syntax/src/validation/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fstring.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -9,7 +9,7 @@ use crate::{\n \n use super::char;\n \n-pub(crate) fn validate_string_node(node: ast::String, errors: &mut Vec<SyntaxError>) {\n+pub(crate) fn validate_string_node(node: &ast::String, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_string_literal(literal_text);\n@@ -38,12 +38,12 @@ pub(crate) fn validate_string_node(node: ast::String, errors: &mut Vec<SyntaxErr\n \n #[cfg(test)]\n mod test {\n-    use crate::SourceFileNode;\n+    use crate::{SourceFile, TreePtr};\n \n-    fn build_file(literal: &str) -> SourceFileNode {\n+    fn build_file(literal: &str) -> TreePtr<SourceFile> {\n         let src = format!(r#\"const S: &'static str = \"{}\";\"#, literal);\n         println!(\"Source: {}\", src);\n-        SourceFileNode::parse(&src)\n+        SourceFile::parse(&src)\n     }\n \n     fn assert_valid_str(literal: &str) {"}, {"sha": "6dc846f33a4f0860048f180f90f39f936e86015b", "filename": "crates/ra_syntax/src/yellow.rs", "status": "modified", "additions": 41, "deletions": 63, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -4,15 +4,12 @@ mod syntax_text;\n \n use self::syntax_text::SyntaxText;\n use crate::{SmolStr, SyntaxKind, TextRange};\n-use rowan::Types;\n-use std::{\n-    fmt,\n-    hash::{Hash, Hasher},\n-};\n+use rowan::{Types, TransparentNewType};\n+use std::fmt;\n \n pub(crate) use self::builder::GreenBuilder;\n pub use self::syntax_error::{SyntaxError, SyntaxErrorKind, Location};\n-pub use rowan::{TreeRoot, WalkEvent};\n+pub use rowan::WalkEvent;\n \n #[derive(Debug, Clone, Copy)]\n pub enum RaTypes {}\n@@ -21,35 +18,19 @@ impl Types for RaTypes {\n     type RootData = Vec<SyntaxError>;\n }\n \n-pub type OwnedRoot = ::rowan::OwnedRoot<RaTypes>;\n-pub type RefRoot<'a> = ::rowan::RefRoot<'a, RaTypes>;\n-\n pub type GreenNode = ::rowan::GreenNode<RaTypes>;\n+pub type TreePtr<T> = ::rowan::TreePtr<RaTypes, T>;\n \n-#[derive(Clone, Copy)]\n-pub struct SyntaxNode<R: TreeRoot<RaTypes> = OwnedRoot>(pub(crate) ::rowan::SyntaxNode<RaTypes, R>);\n-pub type SyntaxNodeRef<'a> = SyntaxNode<RefRoot<'a>>;\n-\n-impl<R1, R2> PartialEq<SyntaxNode<R1>> for SyntaxNode<R2>\n-where\n-    R1: TreeRoot<RaTypes>,\n-    R2: TreeRoot<RaTypes>,\n-{\n-    fn eq(&self, other: &SyntaxNode<R1>) -> bool {\n-        self.0 == other.0\n-    }\n-}\n-\n-impl<R: TreeRoot<RaTypes>> Eq for SyntaxNode<R> {}\n-impl<R: TreeRoot<RaTypes>> Hash for SyntaxNode<R> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.0.hash(state)\n-    }\n+#[derive(PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct SyntaxNode(pub(crate) ::rowan::SyntaxNode<RaTypes>);\n+unsafe impl TransparentNewType for SyntaxNode {\n+    type Repr = ::rowan::SyntaxNode<RaTypes>;\n }\n \n impl SyntaxNode {\n-    pub(crate) fn new(green: GreenNode, errors: Vec<SyntaxError>) -> SyntaxNode {\n-        SyntaxNode(::rowan::SyntaxNode::new(green, errors))\n+    pub(crate) fn new(green: GreenNode, errors: Vec<SyntaxError>) -> TreePtr<SyntaxNode> {\n+        TreePtr::cast(::rowan::SyntaxNode::new(green, errors))\n     }\n }\n \n@@ -59,45 +40,42 @@ pub enum Direction {\n     Prev,\n }\n \n-impl<'a> SyntaxNodeRef<'a> {\n-    pub fn leaf_text(self) -> Option<&'a SmolStr> {\n+impl SyntaxNode {\n+    pub fn leaf_text(&self) -> Option<&SmolStr> {\n         self.0.leaf_text()\n     }\n-    pub fn ancestors(self) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n+    pub fn ancestors(&self) -> impl Iterator<Item = &SyntaxNode> {\n         crate::algo::generate(Some(self), |&node| node.parent())\n     }\n-    pub fn descendants(self) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n+    pub fn descendants(&self) -> impl Iterator<Item = &SyntaxNode> {\n         self.preorder().filter_map(|event| match event {\n             WalkEvent::Enter(node) => Some(node),\n             WalkEvent::Leave(_) => None,\n         })\n     }\n-    pub fn siblings(self, direction: Direction) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n+    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = &SyntaxNode> {\n         crate::algo::generate(Some(self), move |&node| match direction {\n             Direction::Next => node.next_sibling(),\n             Direction::Prev => node.prev_sibling(),\n         })\n     }\n-    pub fn preorder(self) -> impl Iterator<Item = WalkEvent<SyntaxNodeRef<'a>>> {\n+    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<&SyntaxNode>> {\n         self.0.preorder().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode(n)),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode(n)),\n+            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode::from_repr(n)),\n+            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode::from_repr(n)),\n         })\n     }\n }\n \n-impl<R: TreeRoot<RaTypes>> SyntaxNode<R> {\n+impl SyntaxNode {\n     pub(crate) fn root_data(&self) -> &Vec<SyntaxError> {\n         self.0.root_data()\n     }\n     pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n-        self.0.replace_with(replacement)\n-    }\n-    pub fn borrowed<'a>(&'a self) -> SyntaxNode<RefRoot<'a>> {\n-        SyntaxNode(self.0.borrowed())\n+        self.0.replace_self(replacement)\n     }\n-    pub fn owned(&self) -> SyntaxNode<OwnedRoot> {\n-        SyntaxNode(self.0.owned())\n+    pub fn to_owned(&self) -> TreePtr<SyntaxNode> {\n+        TreePtr::cast(self.0.to_owned())\n     }\n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind()\n@@ -106,32 +84,32 @@ impl<R: TreeRoot<RaTypes>> SyntaxNode<R> {\n         self.0.range()\n     }\n     pub fn text(&self) -> SyntaxText {\n-        SyntaxText::new(self.borrowed())\n+        SyntaxText::new(self)\n     }\n     pub fn is_leaf(&self) -> bool {\n         self.0.is_leaf()\n     }\n-    pub fn parent(&self) -> Option<SyntaxNode<R>> {\n-        self.0.parent().map(SyntaxNode)\n+    pub fn parent(&self) -> Option<&SyntaxNode> {\n+        self.0.parent().map(SyntaxNode::from_repr)\n     }\n-    pub fn first_child(&self) -> Option<SyntaxNode<R>> {\n-        self.0.first_child().map(SyntaxNode)\n+    pub fn first_child(&self) -> Option<&SyntaxNode> {\n+        self.0.first_child().map(SyntaxNode::from_repr)\n     }\n-    pub fn last_child(&self) -> Option<SyntaxNode<R>> {\n-        self.0.last_child().map(SyntaxNode)\n+    pub fn last_child(&self) -> Option<&SyntaxNode> {\n+        self.0.last_child().map(SyntaxNode::from_repr)\n     }\n-    pub fn next_sibling(&self) -> Option<SyntaxNode<R>> {\n-        self.0.next_sibling().map(SyntaxNode)\n+    pub fn next_sibling(&self) -> Option<&SyntaxNode> {\n+        self.0.next_sibling().map(SyntaxNode::from_repr)\n     }\n-    pub fn prev_sibling(&self) -> Option<SyntaxNode<R>> {\n-        self.0.prev_sibling().map(SyntaxNode)\n+    pub fn prev_sibling(&self) -> Option<&SyntaxNode> {\n+        self.0.prev_sibling().map(SyntaxNode::from_repr)\n     }\n-    pub fn children(&self) -> SyntaxNodeChildren<R> {\n+    pub fn children(&self) -> SyntaxNodeChildren {\n         SyntaxNodeChildren(self.0.children())\n     }\n }\n \n-impl<R: TreeRoot<RaTypes>> fmt::Debug for SyntaxNode<R> {\n+impl fmt::Debug for SyntaxNode {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n         if has_short_text(self.kind()) {\n@@ -142,13 +120,13 @@ impl<R: TreeRoot<RaTypes>> fmt::Debug for SyntaxNode<R> {\n }\n \n #[derive(Debug)]\n-pub struct SyntaxNodeChildren<R: TreeRoot<RaTypes>>(::rowan::SyntaxNodeChildren<RaTypes, R>);\n+pub struct SyntaxNodeChildren<'a>(::rowan::SyntaxNodeChildren<'a, RaTypes>);\n \n-impl<R: TreeRoot<RaTypes>> Iterator for SyntaxNodeChildren<R> {\n-    type Item = SyntaxNode<R>;\n+impl<'a> Iterator for SyntaxNodeChildren<'a> {\n+    type Item = &'a SyntaxNode;\n \n-    fn next(&mut self) -> Option<SyntaxNode<R>> {\n-        self.0.next().map(SyntaxNode)\n+    fn next(&mut self) -> Option<&'a SyntaxNode> {\n+        self.0.next().map(SyntaxNode::from_repr)\n     }\n }\n "}, {"sha": "31db0fdab38a495e2fdee6cdab3da55a4baac9af", "filename": "crates/ra_syntax/src/yellow/syntax_text.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -3,17 +3,17 @@ use std::{fmt, ops};\n use ra_text_edit::text_utils::contains_offset_nonstrict;\n use crate::{\n     text_utils::intersect,\n-    SyntaxNodeRef, TextRange, TextUnit,\n+    SyntaxNode, TextRange, TextUnit,\n };\n \n #[derive(Clone)]\n pub struct SyntaxText<'a> {\n-    node: SyntaxNodeRef<'a>,\n+    node: &'a SyntaxNode,\n     range: TextRange,\n }\n \n impl<'a> SyntaxText<'a> {\n-    pub(crate) fn new(node: SyntaxNodeRef<'a>) -> SyntaxText<'a> {\n+    pub(crate) fn new(node: &'a SyntaxNode) -> SyntaxText<'a> {\n         SyntaxText {\n             node,\n             range: node.range(),"}, {"sha": "3243b27aec0a377458ec1f2cd2c1f84757af3527", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91a98ec843ec8562c58ccb01a1e29d00cc744dc/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=d91a98ec843ec8562c58ccb01a1e29d00cc744dc", "patch": "@@ -9,8 +9,8 @@ use std::{\n \n use test_utils::{project_dir, dir_tests, read_text, collect_tests};\n use ra_syntax::{\n+    SourceFile, AstNode,\n     utils::{check_fuzz_invariants, dump_tree},\n-    SourceFileNode,\n };\n \n #[test]\n@@ -27,7 +27,7 @@ fn parser_tests() {\n         &test_data_dir(),\n         &[\"parser/inline/ok\", \"parser/ok\"],\n         |text, path| {\n-            let file = SourceFileNode::parse(text);\n+            let file = SourceFile::parse(text);\n             let errors = file.errors();\n             assert_eq!(\n                 &*errors,\n@@ -42,7 +42,7 @@ fn parser_tests() {\n         &test_data_dir(),\n         &[\"parser/err\", \"parser/inline/err\"],\n         |text, path| {\n-            let file = SourceFileNode::parse(text);\n+            let file = SourceFile::parse(text);\n             let errors = file.errors();\n             assert_ne!(\n                 &*errors,\n@@ -85,7 +85,7 @@ fn self_hosting_parsing() {\n     {\n         count += 1;\n         let text = read_text(entry.path());\n-        let node = SourceFileNode::parse(&text);\n+        let node = SourceFile::parse(&text);\n         let errors = node.errors();\n         assert_eq!(\n             &*errors,"}]}