{"sha": "eea329b0f71905518902d34ef77c0923096dde1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYTMyOWIwZjcxOTA1NTE4OTAyZDM0ZWY3N2MwOTIzMDk2ZGRlMWQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-05-15T13:33:51Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-05-29T12:21:03Z"}, "message": "debuginfo: Make DWARF representation of enums uniform.\n\nSo far the DWARF information for enums was different\nfor regular enums, univariant enums, Option-like enums,\netc. Regular enums were encoded as unions of structs,\nwhile the other variants were encoded as bare structs.\n\nWith the changes in this PR all enums are encoded as\nunions so that debuggers can reconstruct if something\noriginally was a struct, a univariant enum, or an\nOption-like enum. For the latter case, information\nabout the Null variant is encoded into the union field\nname. This information can then be used by the\ndebugger to print a None value actually as None\ninstead of Some(0x0).", "tree": {"sha": "e734cbe1994eb783eb47bc01f106ba69c443689a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e734cbe1994eb783eb47bc01f106ba69c443689a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eea329b0f71905518902d34ef77c0923096dde1d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eea329b0f71905518902d34ef77c0923096dde1d", "html_url": "https://github.com/rust-lang/rust/commit/eea329b0f71905518902d34ef77c0923096dde1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eea329b0f71905518902d34ef77c0923096dde1d/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "138089355d7a1bc28fa58f2bea7680af96bd5b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/138089355d7a1bc28fa58f2bea7680af96bd5b92", "html_url": "https://github.com/rust-lang/rust/commit/138089355d7a1bc28fa58f2bea7680af96bd5b92"}], "stats": {"total": 370, "additions": 223, "deletions": 147}, "files": [{"sha": "39f796fe074bb85509e17b094cdd61af49951ec0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 198, "deletions": 124, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -1272,7 +1272,7 @@ enum RecursiveTypeDescription {\n }\n \n impl RecursiveTypeDescription {\n-    // Finishes up the description of the type in question (mostly by providing description of the\n+    // Finishes up the description of the type in question (mostly by providing descriptions of the\n     // fields of the given type) and returns the final type metadata.\n     fn finalize(&self, cx: &CrateContext) -> DICompositeType {\n         match *self {\n@@ -1453,49 +1453,178 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n struct EnumMemberDescriptionFactory {\n     type_rep: Rc<adt::Repr>,\n     variants: Rc<Vec<Rc<ty::VariantInfo>>>,\n-    discriminant_type_metadata: DIType,\n+    discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n     span: Span,\n }\n \n impl EnumMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n-        // Capture type_rep, so we don't have to copy the struct_defs array\n-        let struct_defs = match *self.type_rep {\n-            adt::General(_, ref struct_defs) => struct_defs,\n-            _ => cx.sess().bug(\"unreachable\")\n-        };\n-\n-        struct_defs\n-            .iter()\n-            .enumerate()\n-            .map(|(i, struct_def)| {\n-                let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n+        match *self.type_rep {\n+            adt::General(_, ref struct_defs) => {\n+                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n+                    .expect(\"\"));\n+\n+                struct_defs\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, struct_def)| {\n+                        let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n+                            describe_enum_variant(cx,\n+                                                  struct_def,\n+                                                  &**self.variants.get(i),\n+                                                  discriminant_info,\n+                                                  self.containing_scope,\n+                                                  self.file_metadata,\n+                                                  self.span);\n+\n+                        let member_descriptions = member_desc_factory\n+                            .create_member_descriptions(cx);\n+\n+                        set_members_of_composite_type(cx,\n+                                                      variant_type_metadata,\n+                                                      variant_llvm_type,\n+                                                      member_descriptions.as_slice(),\n+                                                      self.file_metadata,\n+                                                      codemap::DUMMY_SP);\n+                        MemberDescription {\n+                            name: \"\".to_string(),\n+                            llvm_type: variant_llvm_type,\n+                            type_metadata: variant_type_metadata,\n+                            offset: FixedMemberOffset { bytes: 0 },\n+                        }\n+                    }).collect()\n+            },\n+            adt::Univariant(ref struct_def, _) => {\n+                assert!(self.variants.len() <= 1);\n+\n+                if self.variants.len() == 0 {\n+                    vec![]\n+                } else {\n+                    let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n+                        describe_enum_variant(cx,\n+                                              struct_def,\n+                                              &**self.variants.get(0),\n+                                              NoDiscriminant,\n+                                              self.containing_scope,\n+                                              self.file_metadata,\n+                                              self.span);\n+\n+                    let member_descriptions =\n+                        member_description_factory.create_member_descriptions(cx);\n+\n+                    set_members_of_composite_type(cx,\n+                                                  variant_type_metadata,\n+                                                  variant_llvm_type,\n+                                                  member_descriptions.as_slice(),\n+                                                  self.file_metadata,\n+                                                  codemap::DUMMY_SP);\n+                    vec![\n+                        MemberDescription {\n+                            name: \"\".to_string(),\n+                            llvm_type: variant_llvm_type,\n+                            type_metadata: variant_type_metadata,\n+                            offset: FixedMemberOffset { bytes: 0 },\n+                        }\n+                    ]\n+                }\n+            }\n+            adt::RawNullablePointer { nndiscr: non_null_variant_index, nnty, .. } => {\n+                // As far as debuginfo is concerned, the pointer this enum represents is still\n+                // wrapped in a struct. This is to make the DWARF representation of enums uniform.\n+\n+                // First create a description of the artifical wrapper struct:\n+                let non_null_variant = self.variants.get(non_null_variant_index as uint);\n+                let non_null_variant_ident = non_null_variant.name;\n+                let non_null_variant_name = token::get_ident(non_null_variant_ident);\n+\n+                // The llvm type and metadata of the pointer\n+                let non_null_llvm_type = type_of::type_of(cx, nnty);\n+                let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n+\n+                // The type of the artificial struct wrapping the pointer\n+                let artificial_struct_llvm_type = Type::struct_(cx, &[non_null_llvm_type], false);\n+\n+                // For the metadata of the wrapper struct, we need to create a MemberDescription\n+                // of the struct's single field.\n+                let sole_struct_member_description = MemberDescription {\n+                    name: match non_null_variant.arg_names {\n+                        Some(ref names) => token::get_ident(*names.get(0)).get().to_string(),\n+                        None => \"\".to_string()\n+                    },\n+                    llvm_type: non_null_llvm_type,\n+                    type_metadata: non_null_type_metadata,\n+                    offset: FixedMemberOffset { bytes: 0 },\n+                };\n+\n+                // Now we can create the metadata of the artificial struct\n+                let artificial_struct_metadata =\n+                    composite_type_metadata(cx,\n+                                            artificial_struct_llvm_type,\n+                                            non_null_variant_name.get(),\n+                                            &[sole_struct_member_description],\n+                                            self.containing_scope,\n+                                            self.file_metadata,\n+                                            codemap::DUMMY_SP);\n+\n+                // Encode the information about the null variant in the union member's name\n+                let null_variant_index = (1 - non_null_variant_index) as uint;\n+                let null_variant_ident = self.variants.get(null_variant_index).name;\n+                let null_variant_name = token::get_ident(null_variant_ident);\n+                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\", 0, null_variant_name);\n+\n+                // Finally create the (singleton) list of descriptions of union members\n+                vec![\n+                    MemberDescription {\n+                        name: union_member_name,\n+                        llvm_type: artificial_struct_llvm_type,\n+                        type_metadata: artificial_struct_metadata,\n+                        offset: FixedMemberOffset { bytes: 0 },\n+                    }\n+                ]\n+            },\n+            adt::StructWrappedNullablePointer { nonnull: ref struct_def, nndiscr, ptrfield, ..} => {\n+                // Create a description of the non-null variant\n+                let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          &**self.variants.get(i),\n-                                          RegularDiscriminant(self.discriminant_type_metadata),\n+                                          &**self.variants.get(nndiscr as uint),\n+                                          OptimizedDiscriminant(ptrfield),\n                                           self.containing_scope,\n                                           self.file_metadata,\n                                           self.span);\n \n-                let member_descriptions =\n-                    member_desc_factory.create_member_descriptions(cx);\n+                let variant_member_descriptions =\n+                    member_description_factory.create_member_descriptions(cx);\n \n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              member_descriptions.as_slice(),\n+                                              variant_member_descriptions.as_slice(),\n                                               self.file_metadata,\n                                               codemap::DUMMY_SP);\n-                MemberDescription {\n-                    name: \"\".to_string(),\n-                    llvm_type: variant_llvm_type,\n-                    type_metadata: variant_type_metadata,\n-                    offset: FixedMemberOffset { bytes: 0 },\n-                }\n-        }).collect()\n+\n+                // Encode the information about the null variant in the union member's name\n+                let null_variant_index = (1 - nndiscr) as uint;\n+                let null_variant_ident = self.variants.get(null_variant_index).name;\n+                let null_variant_name = token::get_ident(null_variant_ident);\n+                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n+                                                ptrfield,\n+                                                null_variant_name);\n+\n+                // Create the (singleton) list of descriptions of union members\n+                vec![\n+                    MemberDescription {\n+                        name: union_member_name,\n+                        llvm_type: variant_llvm_type,\n+                        type_metadata: variant_type_metadata,\n+                        offset: FixedMemberOffset { bytes: 0 },\n+                    }\n+                ]\n+            },\n+            adt::CEnum(..) => cx.sess().span_bug(self.span, \"This should be unreachable.\")\n+        }\n     }\n }\n \n@@ -1546,7 +1675,7 @@ fn describe_enum_variant(cx: &CrateContext,\n                                     .collect::<Vec<_>>()\n                                     .as_slice(),\n                       struct_def.packed);\n-    // Could some consistency checks here: size, align, field count, discr type\n+    // Could do some consistency checks here: size, align, field count, discr type\n \n     // Find the source code location of the variant's definition\n     let variant_definition_span = if variant_info.id.krate == ast::LOCAL_CRATE {\n@@ -1610,21 +1739,6 @@ fn prepare_enum_metadata(cx: &CrateContext,\n     let loc = span_start(cx, definition_span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    // For empty enums there is an early exit. Just describe it as an empty struct with the\n-    // appropriate type name\n-    if ty::type_is_empty(cx.tcx(), enum_type) {\n-        let empty_type_metadata = composite_type_metadata(\n-            cx,\n-            Type::nil(cx),\n-            enum_name.as_slice(),\n-            [],\n-            containing_scope,\n-            file_metadata,\n-            definition_span);\n-\n-        return FinalMetadata(empty_type_metadata);\n-    }\n-\n     let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n     let enumerators_metadata: Vec<DIDescriptor> = variants\n@@ -1685,92 +1799,52 @@ fn prepare_enum_metadata(cx: &CrateContext,\n \n     let type_rep = adt::represent_type(cx, enum_type);\n \n-    return match *type_rep {\n+    let discriminant_type_metadata = match *type_rep {\n         adt::CEnum(inttype, _, _) => {\n-            FinalMetadata(discriminant_type_metadata(inttype))\n-        }\n-        adt::Univariant(ref struct_def, _) => {\n-            assert!(variants.len() == 1);\n-            let (metadata_stub,\n-                 variant_llvm_type,\n-                 member_description_factory) =\n-                    describe_enum_variant(cx,\n-                                          struct_def,\n-                                          &**variants.get(0),\n-                                          NoDiscriminant,\n-                                          containing_scope,\n-                                          file_metadata,\n-                                          span);\n-            UnfinishedMetadata {\n-                cache_id: cache_id_for_type(enum_type),\n-                metadata_stub: metadata_stub,\n-                llvm_type: variant_llvm_type,\n-                file_metadata: file_metadata,\n-                member_description_factory: member_description_factory\n-            }\n-        }\n-        adt::General(inttype, _) => {\n-            let discriminant_type_metadata = discriminant_type_metadata(inttype);\n-            let enum_llvm_type = type_of::type_of(cx, enum_type);\n-            let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n-            let unique_id = generate_unique_type_id(\"DI_ENUM_\");\n-\n-            let enum_metadata = enum_name.as_slice().with_c_str(|enum_name| {\n-                unique_id.as_slice().with_c_str(|unique_id| {\n-                    unsafe {\n-                        llvm::LLVMDIBuilderCreateUnionType(\n-                        DIB(cx),\n-                        containing_scope,\n-                        enum_name,\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        bytes_to_bits(enum_type_size),\n-                        bytes_to_bits(enum_type_align),\n-                        0, // Flags\n-                        ptr::null(),\n-                        0, // RuntimeLang\n-                        unique_id)\n-                    }\n-                })\n-            });\n+            return FinalMetadata(discriminant_type_metadata(inttype))\n+        },\n+        adt::RawNullablePointer { .. }           |\n+        adt::StructWrappedNullablePointer { .. } |\n+        adt::Univariant(..)                      => None,\n+        adt::General(inttype, _) => Some(discriminant_type_metadata(inttype)),\n+    };\n \n-            UnfinishedMetadata {\n-                cache_id: cache_id_for_type(enum_type),\n-                metadata_stub: enum_metadata,\n-                llvm_type: enum_llvm_type,\n-                file_metadata: file_metadata,\n-                member_description_factory: EnumMDF(EnumMemberDescriptionFactory {\n-                    type_rep: type_rep.clone(),\n-                    variants: variants,\n-                    discriminant_type_metadata: discriminant_type_metadata,\n-                    containing_scope: containing_scope,\n-                    file_metadata: file_metadata,\n-                    span: span,\n-                }),\n-            }\n-        }\n-        adt::RawNullablePointer { nnty, .. } => {\n-            FinalMetadata(type_metadata(cx, nnty, span))\n-        }\n-        adt::StructWrappedNullablePointer { nonnull: ref struct_def, nndiscr, ptrfield, .. } => {\n-            let (metadata_stub,\n-                 variant_llvm_type,\n-                 member_description_factory) =\n-                    describe_enum_variant(cx,\n-                                          struct_def,\n-                                          &**variants.get(nndiscr as uint),\n-                                          OptimizedDiscriminant(ptrfield),\n-                                          containing_scope,\n-                                          file_metadata,\n-                                          span);\n-            UnfinishedMetadata {\n-                cache_id: cache_id_for_type(enum_type),\n-                metadata_stub: metadata_stub,\n-                llvm_type: variant_llvm_type,\n-                file_metadata: file_metadata,\n-                member_description_factory: member_description_factory\n+    let enum_llvm_type = type_of::type_of(cx, enum_type);\n+    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+    let unique_id = generate_unique_type_id(\"DI_ENUM_\");\n+\n+    let enum_metadata = enum_name.as_slice().with_c_str(|enum_name| {\n+        unique_id.as_slice().with_c_str(|unique_id| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateUnionType(\n+                DIB(cx),\n+                containing_scope,\n+                enum_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(enum_type_size),\n+                bytes_to_bits(enum_type_align),\n+                0, // Flags\n+                ptr::null(),\n+                0, // RuntimeLang\n+                unique_id)\n             }\n-        }\n+        })\n+    });\n+\n+    return UnfinishedMetadata {\n+        cache_id: cache_id_for_type(enum_type),\n+        metadata_stub: enum_metadata,\n+        llvm_type: enum_llvm_type,\n+        file_metadata: file_metadata,\n+        member_description_factory: EnumMDF(EnumMemberDescriptionFactory {\n+            type_rep: type_rep.clone(),\n+            variants: variants,\n+            discriminant_type_metadata: discriminant_type_metadata,\n+            containing_scope: containing_scope,\n+            file_metadata: file_metadata,\n+            span: span,\n+        }),\n     };\n \n     fn get_enum_discriminant_name(cx: &CrateContext, def_id: ast::DefId) -> token::InternedString {"}, {"sha": "a377d68a33d8cbd9502a69848d8f1ab36714baae", "filename": "src/test/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -22,7 +22,7 @@\n // gdb-check:$2 = {{TheB, x = 0, y = 1229782938247303441}, {TheB, 0, 286331153, 286331153}}\n \n // gdb-command:print *univariant_ref\n-// gdb-check:$3 = {4820353753753434}\n+// gdb-check:$3 = {{4820353753753434}}\n \n #![allow(unused_variable)]\n #![feature(struct_variant)]"}, {"sha": "eddf4dfd7553ec4a905cdf3839a1f0928283d134", "filename": "src/test/debuginfo/generic-struct-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -27,7 +27,7 @@\n // gdb-check:$3 = {{Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {Case3, a = 0, b = 1499027801, c = 1499027801}, {Case3, a = 0, b = 6438275382588823897}}\n \n // gdb-command:print univariant\n-// gdb-check:$4 = {a = -1}\n+// gdb-check:$4 = {{a = -1}}\n \n #![feature(struct_variant)]\n "}, {"sha": "07f7546068ca9f7fc12125638e26c221b1c20e0a", "filename": "src/test/debuginfo/generic-tuple-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -27,7 +27,7 @@\n // gdb-check:$3 = {{Case3, 0, 22873, 22873, 22873, 22873}, {Case3, 0, 1499027801, 1499027801}, {Case3, 0, 6438275382588823897}}\n \n // gdb-command:print univariant\n-// gdb-check:$4 = {-1}\n+// gdb-check:$4 = {{-1}}\n \n \n // NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be"}, {"sha": "36e75812debdff0b03f00e50290179c340740fb2", "filename": "src/test/debuginfo/managed-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fmanaged-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fmanaged-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmanaged-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -22,7 +22,7 @@\n // gdb-check:$2 = {{TheB, x = 0, y = 1229782938247303441}, {TheB, 0, 286331153, 286331153}}\n \n // gdb-command:print univariant->val\n-// gdb-check:$3 = {-9747455}\n+// gdb-check:$3 = {{-9747455}}\n \n #![allow(unused_variable)]\n #![feature(struct_variant, managed_boxes)]"}, {"sha": "04cd7e1386324312ff7ad2325105a5ddadecfa2a", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g\n@@ -16,19 +17,19 @@\n // gdb-command:finish\n \n // gdb-command:print some\n-// gdb-check:$1 = (u32 *) 0x12345678\n+// gdb-check:$1 = {RUST$ENCODED$ENUM$0$None = {0x12345678}}\n \n // gdb-command:print none\n-// gdb-check:$2 = (u32 *) 0x0\n+// gdb-check:$2 = {RUST$ENCODED$ENUM$0$None = {0x0}}\n \n // gdb-command:print full\n-// gdb-check:$3 = {454545, 0x87654321, 9988}\n+// gdb-check:$3 = {RUST$ENCODED$ENUM$1$Empty = {454545, 0x87654321, 9988}}\n \n // gdb-command:print empty->discr\n // gdb-check:$4 = (int *) 0x0\n \n // gdb-command:print droid\n-// gdb-check:$5 = {id = 675675, range = 10000001, internals = 0x43218765}\n+// gdb-check:$5 = {RUST$ENCODED$ENUM$2$Void = {id = 675675, range = 10000001, internals = 0x43218765}}\n \n // gdb-command:print void_droid->internals\n // gdb-check:$6 = (int *) 0x0"}, {"sha": "518ef62fe9a68551c9793306dff2201d88d99e48", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n // ignore-android: FIXME(#10381)\n \n #![feature(managed_boxes)]\n@@ -20,53 +21,53 @@\n \n // gdb-command:print stack_unique.value\n // gdb-check:$1 = 0\n-// gdb-command:print stack_unique.next->value\n+// gdb-command:print stack_unique.next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdb-check:$2 = 1\n \n // gdb-command:print unique_unique->value\n // gdb-check:$3 = 2\n-// gdb-command:print unique_unique->next->value\n+// gdb-command:print unique_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdb-check:$4 = 3\n \n // gdb-command:print box_unique->val.value\n // gdb-check:$5 = 4\n-// gdb-command:print box_unique->val.next->value\n+// gdb-command:print box_unique->val.next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdb-check:$6 = 5\n \n // gdb-command:print vec_unique[0].value\n // gdb-check:$7 = 6.5\n-// gdb-command:print vec_unique[0].next->value\n+// gdb-command:print vec_unique[0].next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdb-check:$8 = 7.5\n \n // gdb-command:print borrowed_unique->value\n // gdb-check:$9 = 8.5\n-// gdb-command:print borrowed_unique->next->value\n+// gdb-command:print borrowed_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n // gdb-check:$10 = 9.5\n \n // MANAGED\n // gdb-command:print stack_managed.value\n // gdb-check:$11 = 10\n-// gdb-command:print stack_managed.next.val->value\n+// gdb-command:print stack_managed.next.RUST$ENCODED$ENUM$0$Empty.val->val.value\n // gdb-check:$12 = 11\n \n // gdb-command:print unique_managed->value\n // gdb-check:$13 = 12\n-// gdb-command:print unique_managed->next.val->value\n+// gdb-command:print unique_managed->next.RUST$ENCODED$ENUM$0$Empty.val->val.value\n // gdb-check:$14 = 13\n \n // gdb-command:print box_managed.val->value\n // gdb-check:$15 = 14\n-// gdb-command:print box_managed->val->next.val->value\n+// gdb-command:print box_managed->val->next.RUST$ENCODED$ENUM$0$Empty.val->val.value\n // gdb-check:$16 = 15\n \n // gdb-command:print vec_managed[0].value\n // gdb-check:$17 = 16.5\n-// gdb-command:print vec_managed[0].next.val->value\n+// gdb-command:print vec_managed[0].next.RUST$ENCODED$ENUM$0$Empty.val->val.value\n // gdb-check:$18 = 17.5\n \n // gdb-command:print borrowed_managed->value\n // gdb-check:$19 = 18.5\n-// gdb-command:print borrowed_managed->next.val->value\n+// gdb-command:print borrowed_managed->next.RUST$ENCODED$ENUM$0$Empty.val->val.value\n // gdb-check:$20 = 19.5\n \n // LONG CYCLE\n@@ -97,7 +98,7 @@\n // gdb-command:print (*****long_cycle_w_anonymous_types).value\n // gdb-check:$31 = 30\n \n-// gdb-command:print (*****((*****long_cycle_w_anonymous_types).next)).value\n+// gdb-command:print (*****((*****long_cycle_w_anonymous_types).next.RUST$ENCODED$ENUM$0$Empty.val)).value\n // gdb-check:$32 = 31\n \n // gdb-command:continue"}, {"sha": "0cba56ad320ec834ce77cda38252487f0823a26c", "filename": "src/test/debuginfo/struct-in-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -24,7 +24,7 @@\n // gdb-check:$2 = {{Case2, 0, {x = 286331153, y = 286331153, z = 4369}}, {Case2, 0, 1229782938247303441, 4369}}\n \n // gdb-command:print univariant\n-// gdb-check:$3 = {{x = 123, y = 456, z = 789}}\n+// gdb-check:$3 = {{{x = 123, y = 456, z = 789}}}\n \n #![allow(unused_variable)]\n "}, {"sha": "70d4d709d23c81547ad410057f09d40027a8866e", "filename": "src/test/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -27,7 +27,7 @@\n // gdb-check:$3 = {{Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {Case3, a = 0, b = 1499027801, c = 1499027801}, {Case3, a = 0, b = 6438275382588823897}}\n \n // gdb-command:print univariant\n-// gdb-check:$4 = {a = -1}\n+// gdb-check:$4 = {{a = -1}}\n \n #![allow(unused_variable)]\n #![feature(struct_variant)]"}, {"sha": "81c72d16886439bc468288a3087ff198286a8ffe", "filename": "src/test/debuginfo/tuple-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -27,7 +27,7 @@\n // gdb-check:$3 = {{Case3, 0, 22873, 22873, 22873, 22873}, {Case3, 0, 1499027801, 1499027801}, {Case3, 0, 6438275382588823897}}\n \n // gdb-command:print univariant\n-// gdb-check:$4 = {-1}\n+// gdb-check:$4 = {{-1}}\n \n #![allow(unused_variable)]\n "}, {"sha": "3949a315adca2b79783cca5175e6f8ec672f06f5", "filename": "src/test/debuginfo/unique-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea329b0f71905518902d34ef77c0923096dde1d/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum.rs?ref=eea329b0f71905518902d34ef77c0923096dde1d", "patch": "@@ -22,7 +22,7 @@\n // gdb-check:$2 = {{TheB, x = 0, y = 1229782938247303441}, {TheB, 0, 286331153, 286331153}}\n \n // gdb-command:print *univariant\n-// gdb-check:$3 = {123234}\n+// gdb-check:$3 = {{123234}}\n \n #![allow(unused_variable)]\n #![feature(struct_variant)]"}]}