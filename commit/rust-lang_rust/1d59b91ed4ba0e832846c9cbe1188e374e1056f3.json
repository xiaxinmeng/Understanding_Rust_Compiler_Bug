{"sha": "1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNTliOTFlZDRiYTBlODMyODQ2YzljYmUxMTg4ZTM3NGUxMDU2ZjM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-07T17:56:19Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-07T17:56:19Z"}, "message": "Rollup merge of #32741 - tbu-:pr_remove_fixme_12808, r=bluss\n\nRemove strange names created by lack of privacy-conscious name lookup\n\nThe fixed issue that allowed this was #12808.", "tree": {"sha": "64f227c48d1bde66115f9e4ffe0882f03ad18024", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64f227c48d1bde66115f9e4ffe0882f03ad18024"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "html_url": "https://github.com/rust-lang/rust/commit/1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d59b91ed4ba0e832846c9cbe1188e374e1056f3/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "751d6ede9db85f724b1e62306ea3de5221d8d92a", "url": "https://api.github.com/repos/rust-lang/rust/commits/751d6ede9db85f724b1e62306ea3de5221d8d92a", "html_url": "https://github.com/rust-lang/rust/commit/751d6ede9db85f724b1e62306ea3de5221d8d92a"}, {"sha": "0936b5885d5886304ecb8639882f2e5a6d20ab7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0936b5885d5886304ecb8639882f2e5a6d20ab7d", "html_url": "https://github.com/rust-lang/rust/commit/0936b5885d5886304ecb8639882f2e5a6d20ab7d"}], "stats": {"total": 160, "additions": 74, "deletions": 86}, "files": [{"sha": "4aba567fa1c202215b361bba0db7ea1b6f913124", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1d59b91ed4ba0e832846c9cbe1188e374e1056f3/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d59b91ed4ba0e832846c9cbe1188e374e1056f3/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "patch": "@@ -124,9 +124,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: Shared<ArcInner<T>>,\n+    ptr: Shared<ArcInner<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -144,9 +142,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n #[unsafe_no_drop_flag]\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: Shared<ArcInner<T>>,\n+    ptr: Shared<ArcInner<T>>,\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n@@ -198,7 +194,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data: data,\n         };\n-        Arc { _ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n+        Arc { ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n     }\n \n     /// Unwraps the contained value if the `Arc<T>` has exactly one strong reference.\n@@ -230,11 +226,11 @@ impl<T> Arc<T> {\n         atomic::fence(Acquire);\n \n         unsafe {\n-            let ptr = *this._ptr;\n+            let ptr = *this.ptr;\n             let elem = ptr::read(&(*ptr).data);\n \n             // Make a weak pointer to clean up the implicit strong-weak reference\n-            let _weak = Weak { _ptr: this._ptr };\n+            let _weak = Weak { ptr: this.ptr };\n             mem::forget(this);\n \n             Ok(elem)\n@@ -275,7 +271,7 @@ impl<T: ?Sized> Arc<T> {\n             // synchronize with the write coming from `is_unique`, so that the\n             // events prior to that write happen before this read.\n             match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {\n-                Ok(_) => return Weak { _ptr: this._ptr },\n+                Ok(_) => return Weak { ptr: this.ptr },\n                 Err(old) => cur = old,\n             }\n         }\n@@ -304,13 +300,13 @@ impl<T: ?Sized> Arc<T> {\n         // `ArcInner` structure itself is `Sync` because the inner data is\n         // `Sync` as well, so we're ok loaning out an immutable pointer to these\n         // contents.\n-        unsafe { &**self._ptr }\n+        unsafe { &**self.ptr }\n     }\n \n     // Non-inlined part of `drop`.\n     #[inline(never)]\n     unsafe fn drop_slow(&mut self) {\n-        let ptr = *self._ptr;\n+        let ptr = *self.ptr;\n \n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n@@ -368,7 +364,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n             }\n         }\n \n-        Arc { _ptr: self._ptr }\n+        Arc { ptr: self.ptr }\n     }\n }\n \n@@ -436,15 +432,15 @@ impl<T: Clone> Arc<T> {\n \n             // Materialize our own implicit weak pointer, so that it can clean\n             // up the ArcInner as needed.\n-            let weak = Weak { _ptr: this._ptr };\n+            let weak = Weak { ptr: this.ptr };\n \n             // mark the data itself as already deallocated\n             unsafe {\n                 // there is no data race in the implicit write caused by `read`\n                 // here (due to zeroing) because data is no longer accessed by\n                 // other threads (due to there being no more strong refs at this\n                 // point).\n-                let mut swap = Arc::new(ptr::read(&(**weak._ptr).data));\n+                let mut swap = Arc::new(ptr::read(&(**weak.ptr).data));\n                 mem::swap(this, &mut swap);\n                 mem::forget(swap);\n             }\n@@ -457,7 +453,7 @@ impl<T: Clone> Arc<T> {\n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n         unsafe {\n-            let inner = &mut **this._ptr;\n+            let inner = &mut **this.ptr;\n             &mut inner.data\n         }\n     }\n@@ -489,7 +485,7 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                let inner = &mut **this._ptr;\n+                let inner = &mut **this.ptr;\n                 Some(&mut inner.data)\n             }\n         } else {\n@@ -558,7 +554,7 @@ impl<T: ?Sized> Drop for Arc<T> {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n         // more than once (but it is guaranteed to be zeroed after the first if\n         // it's run more than once)\n-        let thin = *self._ptr as *const ();\n+        let thin = *self.ptr as *const ();\n \n         if thin as usize == mem::POST_DROP_USIZE {\n             return;\n@@ -639,7 +635,7 @@ impl<T: ?Sized> Weak<T> {\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n             match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n-                Ok(_) => return Some(Arc { _ptr: self._ptr }),\n+                Ok(_) => return Some(Arc { ptr: self.ptr }),\n                 Err(old) => n = old,\n             }\n         }\n@@ -648,7 +644,7 @@ impl<T: ?Sized> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &**self._ptr }\n+        unsafe { &**self.ptr }\n     }\n }\n \n@@ -682,7 +678,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n             }\n         }\n \n-        return Weak { _ptr: self._ptr };\n+        return Weak { ptr: self.ptr };\n     }\n }\n \n@@ -714,7 +710,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// } // implicit drop\n     /// ```\n     fn drop(&mut self) {\n-        let ptr = *self._ptr;\n+        let ptr = *self.ptr;\n         let thin = ptr as *const ();\n \n         // see comments above for why this check is here\n@@ -886,7 +882,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self._ptr, f)\n+        fmt::Pointer::fmt(&*self.ptr, f)\n     }\n }\n \n@@ -931,7 +927,7 @@ impl<T> Weak<T> {\n                issue = \"30425\")]\n     pub fn new() -> Weak<T> {\n         unsafe {\n-            Weak { _ptr: Shared::new(Box::into_raw(box ArcInner {\n+            Weak { ptr: Shared::new(Box::into_raw(box ArcInner {\n                 strong: atomic::AtomicUsize::new(0),\n                 weak: atomic::AtomicUsize::new(1),\n                 data: uninitialized(),"}, {"sha": "c2f0a96132733221514a09f067ad59e8b4aca1a8", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1d59b91ed4ba0e832846c9cbe1188e374e1056f3/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d59b91ed4ba0e832846c9cbe1188e374e1056f3/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "patch": "@@ -184,9 +184,7 @@ struct RcBox<T: ?Sized> {\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n-    // FIXME #12808: strange names to try to avoid interfering with field\n-    // accesses of the contained type via Deref\n-    _ptr: Shared<RcBox<T>>,\n+    ptr: Shared<RcBox<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -215,7 +213,7 @@ impl<T> Rc<T> {\n                 // pointers, which ensures that the weak destructor never frees\n                 // the allocation while the strong destructor is running, even\n                 // if the weak pointer is stored inside the strong one.\n-                _ptr: Shared::new(Box::into_raw(box RcBox {\n+                ptr: Shared::new(Box::into_raw(box RcBox {\n                     strong: Cell::new(1),\n                     weak: Cell::new(1),\n                     value: value,\n@@ -254,7 +252,7 @@ impl<T> Rc<T> {\n                 // pointer while also handling drop logic by just crafting a\n                 // fake Weak.\n                 this.dec_strong();\n-                let _weak = Weak { _ptr: this._ptr };\n+                let _weak = Weak { ptr: this.ptr };\n                 forget(this);\n                 Ok(val)\n             }\n@@ -287,7 +285,7 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn downgrade(this: &Self) -> Weak<T> {\n         this.inc_weak();\n-        Weak { _ptr: this._ptr }\n+        Weak { ptr: this.ptr }\n     }\n \n     /// Get the number of weak references to this value.\n@@ -348,7 +346,7 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n-            let inner = unsafe { &mut **this._ptr };\n+            let inner = unsafe { &mut **this.ptr };\n             Some(&mut inner.value)\n         } else {\n             None\n@@ -390,7 +388,7 @@ impl<T: Clone> Rc<T> {\n         } else if Rc::weak_count(this) != 0 {\n             // Can just steal the data, all that's left is Weaks\n             unsafe {\n-                let mut swap = Rc::new(ptr::read(&(**this._ptr).value));\n+                let mut swap = Rc::new(ptr::read(&(**this.ptr).value));\n                 mem::swap(this, &mut swap);\n                 swap.dec_strong();\n                 // Remove implicit strong-weak ref (no need to craft a fake\n@@ -404,7 +402,7 @@ impl<T: Clone> Rc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the inner value.\n-        let inner = unsafe { &mut **this._ptr };\n+        let inner = unsafe { &mut **this.ptr };\n         &mut inner.value\n     }\n }\n@@ -449,7 +447,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = *self._ptr;\n+            let ptr = *self.ptr;\n             let thin = ptr as *const ();\n \n             if thin as usize != mem::POST_DROP_USIZE {\n@@ -490,7 +488,7 @@ impl<T: ?Sized> Clone for Rc<T> {\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n-        Rc { _ptr: self._ptr }\n+        Rc { ptr: self.ptr }\n     }\n }\n \n@@ -691,7 +689,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self._ptr, f)\n+        fmt::Pointer::fmt(&*self.ptr, f)\n     }\n }\n \n@@ -711,9 +709,7 @@ impl<T> From<T> for Rc<T> {\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: Shared<RcBox<T>>,\n+    ptr: Shared<RcBox<T>>,\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n@@ -749,7 +745,7 @@ impl<T: ?Sized> Weak<T> {\n             None\n         } else {\n             self.inc_strong();\n-            Some(Rc { _ptr: self._ptr })\n+            Some(Rc { ptr: self.ptr })\n         }\n     }\n }\n@@ -783,7 +779,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = *self._ptr;\n+            let ptr = *self.ptr;\n             let thin = ptr as *const ();\n \n             if thin as usize != mem::POST_DROP_USIZE {\n@@ -816,7 +812,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         self.inc_weak();\n-        Weak { _ptr: self._ptr }\n+        Weak { ptr: self.ptr }\n     }\n }\n \n@@ -848,7 +844,7 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                _ptr: Shared::new(Box::into_raw(box RcBox {\n+                ptr: Shared::new(Box::into_raw(box RcBox {\n                     strong: Cell::new(0),\n                     weak: Cell::new(1),\n                     value: uninitialized(),\n@@ -910,8 +906,8 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n-            &(**self._ptr)\n+            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n+            &(**self.ptr)\n         }\n     }\n }\n@@ -924,8 +920,8 @@ impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n-            &(**self._ptr)\n+            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n+            &(**self.ptr)\n         }\n     }\n }"}, {"sha": "a1c7a293af0b3d759a8b828c1a74b0e0a3ee81c7", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1d59b91ed4ba0e832846c9cbe1188e374e1056f3/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d59b91ed4ba0e832846c9cbe1188e374e1056f3/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "patch": "@@ -390,8 +390,8 @@ impl<T: ?Sized> RefCell<T> {\n     pub fn borrow(&self) -> Ref<T> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Ref {\n-                _value: unsafe { &*self.value.get() },\n-                _borrow: b,\n+                value: unsafe { &*self.value.get() },\n+                borrow: b,\n             },\n             None => panic!(\"RefCell<T> already mutably borrowed\"),\n         }\n@@ -438,8 +438,8 @@ impl<T: ?Sized> RefCell<T> {\n     pub fn borrow_mut(&self) -> RefMut<T> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => RefMut {\n-                _value: unsafe { &mut *self.value.get() },\n-                _borrow: b,\n+                value: unsafe { &mut *self.value.get() },\n+                borrow: b,\n             },\n             None => panic!(\"RefCell<T> already borrowed\"),\n         }\n@@ -491,7 +491,7 @@ impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> {\n impl<T: ?Sized + Eq> Eq for RefCell<T> {}\n \n struct BorrowRef<'b> {\n-    _borrow: &'b Cell<BorrowFlag>,\n+    borrow: &'b Cell<BorrowFlag>,\n }\n \n impl<'b> BorrowRef<'b> {\n@@ -501,7 +501,7 @@ impl<'b> BorrowRef<'b> {\n             WRITING => None,\n             b => {\n                 borrow.set(b + 1);\n-                Some(BorrowRef { _borrow: borrow })\n+                Some(BorrowRef { borrow: borrow })\n             },\n         }\n     }\n@@ -510,9 +510,9 @@ impl<'b> BorrowRef<'b> {\n impl<'b> Drop for BorrowRef<'b> {\n     #[inline]\n     fn drop(&mut self) {\n-        let borrow = self._borrow.get();\n+        let borrow = self.borrow.get();\n         debug_assert!(borrow != WRITING && borrow != UNUSED);\n-        self._borrow.set(borrow - 1);\n+        self.borrow.set(borrow - 1);\n     }\n }\n \n@@ -521,10 +521,10 @@ impl<'b> Clone for BorrowRef<'b> {\n     fn clone(&self) -> BorrowRef<'b> {\n         // Since this Ref exists, we know the borrow flag\n         // is not set to WRITING.\n-        let borrow = self._borrow.get();\n+        let borrow = self.borrow.get();\n         debug_assert!(borrow != WRITING && borrow != UNUSED);\n-        self._borrow.set(borrow + 1);\n-        BorrowRef { _borrow: self._borrow }\n+        self.borrow.set(borrow + 1);\n+        BorrowRef { borrow: self.borrow }\n     }\n }\n \n@@ -534,10 +534,8 @@ impl<'b> Clone for BorrowRef<'b> {\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ref<'b, T: ?Sized + 'b> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _value: &'b T,\n-    _borrow: BorrowRef<'b>,\n+    value: &'b T,\n+    borrow: BorrowRef<'b>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -546,7 +544,7 @@ impl<'b, T: ?Sized> Deref for Ref<'b, T> {\n \n     #[inline]\n     fn deref(&self) -> &T {\n-        self._value\n+        self.value\n     }\n }\n \n@@ -565,8 +563,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     #[inline]\n     pub fn clone(orig: &Ref<'b, T>) -> Ref<'b, T> {\n         Ref {\n-            _value: orig._value,\n-            _borrow: orig._borrow.clone(),\n+            value: orig.value,\n+            borrow: orig.borrow.clone(),\n         }\n     }\n \n@@ -594,8 +592,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         where F: FnOnce(&T) -> &U\n     {\n         Ref {\n-            _value: f(orig._value),\n-            _borrow: orig._borrow,\n+            value: f(orig.value),\n+            borrow: orig.borrow,\n         }\n     }\n \n@@ -627,9 +625,9 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     pub fn filter_map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Option<Ref<'b, U>>\n         where F: FnOnce(&T) -> Option<&U>\n     {\n-        f(orig._value).map(move |new| Ref {\n-            _value: new,\n-            _borrow: orig._borrow,\n+        f(orig.value).map(move |new| Ref {\n+            value: new,\n+            borrow: orig.borrow,\n         })\n     }\n }\n@@ -667,8 +665,8 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         where F: FnOnce(&mut T) -> &mut U\n     {\n         RefMut {\n-            _value: f(orig._value),\n-            _borrow: orig._borrow,\n+            value: f(orig.value),\n+            borrow: orig.borrow,\n         }\n     }\n \n@@ -706,24 +704,24 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     pub fn filter_map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> Option<RefMut<'b, U>>\n         where F: FnOnce(&mut T) -> Option<&mut U>\n     {\n-        let RefMut { _value, _borrow } = orig;\n-        f(_value).map(move |new| RefMut {\n-            _value: new,\n-            _borrow: _borrow,\n+        let RefMut { value, borrow } = orig;\n+        f(value).map(move |new| RefMut {\n+            value: new,\n+            borrow: borrow,\n         })\n     }\n }\n \n struct BorrowRefMut<'b> {\n-    _borrow: &'b Cell<BorrowFlag>,\n+    borrow: &'b Cell<BorrowFlag>,\n }\n \n impl<'b> Drop for BorrowRefMut<'b> {\n     #[inline]\n     fn drop(&mut self) {\n-        let borrow = self._borrow.get();\n+        let borrow = self.borrow.get();\n         debug_assert!(borrow == WRITING);\n-        self._borrow.set(UNUSED);\n+        self.borrow.set(UNUSED);\n     }\n }\n \n@@ -733,7 +731,7 @@ impl<'b> BorrowRefMut<'b> {\n         match borrow.get() {\n             UNUSED => {\n                 borrow.set(WRITING);\n-                Some(BorrowRefMut { _borrow: borrow })\n+                Some(BorrowRefMut { borrow: borrow })\n             },\n             _ => None,\n         }\n@@ -745,10 +743,8 @@ impl<'b> BorrowRefMut<'b> {\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefMut<'b, T: ?Sized + 'b> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _value: &'b mut T,\n-    _borrow: BorrowRefMut<'b>,\n+    value: &'b mut T,\n+    borrow: BorrowRefMut<'b>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -757,15 +753,15 @@ impl<'b, T: ?Sized> Deref for RefMut<'b, T> {\n \n     #[inline]\n     fn deref(&self) -> &T {\n-        self._value\n+        self.value\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut T {\n-        self._value\n+        self.value\n     }\n }\n "}]}