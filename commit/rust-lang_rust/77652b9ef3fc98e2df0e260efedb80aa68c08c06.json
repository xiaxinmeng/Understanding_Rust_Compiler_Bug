{"sha": "77652b9ef3fc98e2df0e260efedb80aa68c08c06", "node_id": "C_kwDOAAsO6NoAKDc3NjUyYjllZjNmYzk4ZTJkZjBlMjYwZWZlZGI4MGFhNjhjMDhjMDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-06T20:14:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-06T20:14:01Z"}, "message": "Auto merge of #96785 - GuillaumeGomez:rollup-rgiwa57, r=GuillaumeGomez\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #96557 (Allow inline consts to reference generic params)\n - #96590 (rustdoc: when running a function-signature search, tweak the tab bar)\n - #96650 (Collect function instance used in `global_asm!` sym operand)\n - #96733 (turn `append_place_to_string` from recursion into iteration)\n - #96748 (Fixes reexports in search)\n - #96752 (Put the incompatible_closure_captures lint messages in alphabetical order)\n - #96754 (rustdoc: ensure HTML/JS side implementors don't have dups)\n - #96772 (Suggest fully qualified path with appropriate params)\n - #96776 (Fix two minor issues in hir.rs)\n - #96782 (a small `mirror_expr` cleanup)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4432c37cab5ef0de178ce0e3411f4baffda60d0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4432c37cab5ef0de178ce0e3411f4baffda60d0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77652b9ef3fc98e2df0e260efedb80aa68c08c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77652b9ef3fc98e2df0e260efedb80aa68c08c06", "html_url": "https://github.com/rust-lang/rust/commit/77652b9ef3fc98e2df0e260efedb80aa68c08c06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77652b9ef3fc98e2df0e260efedb80aa68c08c06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60b4f52c92facae291151dd5a23399f8044d01e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60b4f52c92facae291151dd5a23399f8044d01e", "html_url": "https://github.com/rust-lang/rust/commit/d60b4f52c92facae291151dd5a23399f8044d01e"}, {"sha": "a0e2c7e8bbd7773e2c709ac812c75d0902d6cf6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0e2c7e8bbd7773e2c709ac812c75d0902d6cf6a", "html_url": "https://github.com/rust-lang/rust/commit/a0e2c7e8bbd7773e2c709ac812c75d0902d6cf6a"}], "stats": {"total": 877, "additions": 625, "deletions": 252}, "files": [{"sha": "05d29503180ef73a6b9aacdfb97a931f92f1d8db", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 78, "deletions": 132, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -1,5 +1,6 @@\n //! Borrow checker diagnostics.\n \n+use itertools::Itertools;\n use rustc_const_eval::util::{call_kind, CallDesugaringKind};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n@@ -161,158 +162,103 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// End-user visible description of `place` if one can be found.\n-    /// If the place is a temporary for instance, None will be returned.\n+    /// If the place is a temporary for instance, `None` will be returned.\n     pub(super) fn describe_place(&self, place_ref: PlaceRef<'tcx>) -> Option<String> {\n         self.describe_place_with_options(place_ref, IncludingDowncast(false))\n     }\n \n-    /// End-user visible description of `place` if one can be found. If the\n-    /// place is a temporary for instance, None will be returned.\n-    /// `IncludingDowncast` parameter makes the function return `Err` if `ProjectionElem` is\n+    /// End-user visible description of `place` if one can be found. If the place is a temporary\n+    /// for instance, `None` will be returned.\n+    /// `IncludingDowncast` parameter makes the function return `None` if `ProjectionElem` is\n     /// `Downcast` and `IncludingDowncast` is true\n     pub(super) fn describe_place_with_options(\n         &self,\n         place: PlaceRef<'tcx>,\n         including_downcast: IncludingDowncast,\n     ) -> Option<String> {\n+        let local = place.local;\n+        let mut autoderef_index = None;\n         let mut buf = String::new();\n-        match self.append_place_to_string(place, &mut buf, false, &including_downcast) {\n-            Ok(()) => Some(buf),\n-            Err(()) => None,\n-        }\n-    }\n-\n-    /// Appends end-user visible description of `place` to `buf`.\n-    fn append_place_to_string(\n-        &self,\n-        place: PlaceRef<'tcx>,\n-        buf: &mut String,\n-        mut autoderef: bool,\n-        including_downcast: &IncludingDowncast,\n-    ) -> Result<(), ()> {\n-        match place {\n-            PlaceRef { local, projection: [] } => {\n-                self.append_local_to_string(local, buf)?;\n-            }\n-            PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_for_guard() =>\n-            {\n-                self.append_place_to_string(\n-                    PlaceRef { local, projection: &[] },\n-                    buf,\n-                    autoderef,\n-                    &including_downcast,\n-                )?;\n-            }\n-            PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_to_static() =>\n-            {\n-                let local_info = &self.body.local_decls[local].local_info;\n-                if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n-                    buf.push_str(self.infcx.tcx.item_name(def_id).as_str());\n-                } else {\n-                    unreachable!();\n-                }\n-            }\n-            PlaceRef { local, projection: [proj_base @ .., elem] } => {\n-                match elem {\n-                    ProjectionElem::Deref => {\n-                        let upvar_field_projection = self.is_upvar_field_projection(place);\n-                        if let Some(field) = upvar_field_projection {\n-                            let var_index = field.index();\n-                            let name = self.upvars[var_index].place.to_string(self.infcx.tcx);\n-                            if self.upvars[var_index].by_ref {\n-                                buf.push_str(&name);\n-                            } else {\n-                                buf.push('*');\n-                                buf.push_str(&name);\n-                            }\n-                        } else {\n-                            if autoderef {\n-                                // FIXME turn this recursion into iteration\n-                                self.append_place_to_string(\n-                                    PlaceRef { local, projection: proj_base },\n-                                    buf,\n-                                    autoderef,\n-                                    &including_downcast,\n-                                )?;\n-                            } else {\n-                                buf.push('*');\n-                                self.append_place_to_string(\n-                                    PlaceRef { local, projection: proj_base },\n-                                    buf,\n-                                    autoderef,\n-                                    &including_downcast,\n-                                )?;\n-                            }\n+        let mut ok = self.append_local_to_string(local, &mut buf);\n+\n+        for (index, elem) in place.projection.into_iter().enumerate() {\n+            match elem {\n+                ProjectionElem::Deref => {\n+                    if index == 0 {\n+                        if self.body.local_decls[local].is_ref_for_guard() {\n+                            continue;\n                         }\n-                    }\n-                    ProjectionElem::Downcast(..) => {\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        if including_downcast.0 {\n-                            return Err(());\n+                        if let Some(box LocalInfo::StaticRef { def_id, .. }) =\n+                            &self.body.local_decls[local].local_info\n+                        {\n+                            buf.push_str(self.infcx.tcx.item_name(*def_id).as_str());\n+                            ok = Ok(());\n+                            continue;\n                         }\n                     }\n-                    ProjectionElem::Field(field, _ty) => {\n-                        autoderef = true;\n-\n-                        // FIXME(project-rfc_2229#36): print capture precisely here.\n-                        let upvar_field_projection = self.is_upvar_field_projection(place);\n-                        if let Some(field) = upvar_field_projection {\n-                            let var_index = field.index();\n-                            let name = self.upvars[var_index].place.to_string(self.infcx.tcx);\n-                            buf.push_str(&name);\n-                        } else {\n-                            let field_name = self\n-                                .describe_field(PlaceRef { local, projection: proj_base }, *field);\n-                            self.append_place_to_string(\n-                                PlaceRef { local, projection: proj_base },\n-                                buf,\n-                                autoderef,\n-                                &including_downcast,\n-                            )?;\n-                            buf.push('.');\n-                            buf.push_str(&field_name);\n+                    if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n+                        local,\n+                        projection: place.projection.split_at(index + 1).0,\n+                    }) {\n+                        let var_index = field.index();\n+                        buf = self.upvars[var_index].place.to_string(self.infcx.tcx);\n+                        ok = Ok(());\n+                        if !self.upvars[var_index].by_ref {\n+                            buf.insert(0, '*');\n                         }\n-                    }\n-                    ProjectionElem::Index(index) => {\n-                        autoderef = true;\n-\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        buf.push('[');\n-                        if self.append_local_to_string(*index, buf).is_err() {\n-                            buf.push('_');\n+                    } else {\n+                        if autoderef_index.is_none() {\n+                            autoderef_index =\n+                                match place.projection.into_iter().rev().find_position(|elem| {\n+                                    !matches!(\n+                                        elem,\n+                                        ProjectionElem::Deref | ProjectionElem::Downcast(..)\n+                                    )\n+                                }) {\n+                                    Some((index, _)) => Some(place.projection.len() - index),\n+                                    None => Some(0),\n+                                };\n+                        }\n+                        if index >= autoderef_index.unwrap() {\n+                            buf.insert(0, '*');\n                         }\n-                        buf.push(']');\n                     }\n-                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n-                        autoderef = true;\n-                        // Since it isn't possible to borrow an element on a particular index and\n-                        // then use another while the borrow is held, don't output indices details\n-                        // to avoid confusing the end-user\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        buf.push_str(\"[..]\");\n+                }\n+                ProjectionElem::Downcast(..) if including_downcast.0 => return None,\n+                ProjectionElem::Downcast(..) => (),\n+                ProjectionElem::Field(field, _ty) => {\n+                    // FIXME(project-rfc_2229#36): print capture precisely here.\n+                    if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n+                        local,\n+                        projection: place.projection.split_at(index + 1).0,\n+                    }) {\n+                        buf = self.upvars[field.index()].place.to_string(self.infcx.tcx);\n+                        ok = Ok(());\n+                    } else {\n+                        let field_name = self.describe_field(\n+                            PlaceRef { local, projection: place.projection.split_at(index).0 },\n+                            *field,\n+                        );\n+                        buf.push('.');\n+                        buf.push_str(&field_name);\n                     }\n-                };\n+                }\n+                ProjectionElem::Index(index) => {\n+                    buf.push('[');\n+                    if self.append_local_to_string(*index, &mut buf).is_err() {\n+                        buf.push('_');\n+                    }\n+                    buf.push(']');\n+                }\n+                ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                    // Since it isn't possible to borrow an element on a particular index and\n+                    // then use another while the borrow is held, don't output indices details\n+                    // to avoid confusing the end-user\n+                    buf.push_str(\"[..]\");\n+                }\n             }\n         }\n-\n-        Ok(())\n+        ok.ok().map(|_| buf)\n     }\n \n     /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have"}, {"sha": "cc6ddad2e15dfb126076486c0178554df5c87bc8", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -1441,7 +1441,7 @@ pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,\n \n-    /// An explicit `async` block written by the user.\n+    /// An explicit `async` closure written by the user.\n     Closure,\n \n     /// The `async` block generated as the body of an async function.\n@@ -2078,10 +2078,7 @@ pub enum YieldSource {\n \n impl YieldSource {\n     pub fn is_await(&self) -> bool {\n-        match self {\n-            YieldSource::Await { .. } => true,\n-            YieldSource::Yield => false,\n-        }\n+        matches!(self, YieldSource::Await { .. })\n     }\n }\n "}, {"sha": "78e0864d918d99360d8d8fe47a3b10aea2845d0e", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -731,6 +731,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 //    |               help: specify type like: `<Impl as Into<u32>>::into(foo_impl)`\n                 //    |\n                 //    = note: cannot satisfy `Impl: Into<_>`\n+                debug!(?segment);\n                 if !impl_candidates.is_empty() && e.span.contains(span)\n                     && let Some(expr) = exprs.first()\n                     && let ExprKind::Path(hir::QPath::Resolved(_, path)) = expr.kind\n@@ -739,9 +740,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let mut eraser = TypeParamEraser(self.tcx);\n                     let candidate_len = impl_candidates.len();\n                     let mut suggestions: Vec<_> = impl_candidates.iter().map(|candidate| {\n+                        let trait_item = self.tcx\n+                            .associated_items(candidate.def_id)\n+                            .find_by_name_and_kind(\n+                                self.tcx,\n+                                segment.ident,\n+                                ty::AssocKind::Fn,\n+                                candidate.def_id\n+                            );\n+                        let prefix = if let Some(trait_item) = trait_item\n+                            && let Some(trait_m) = trait_item.def_id.as_local()\n+                            && let hir::TraitItemKind::Fn(fn_, _) = &self.tcx.hir().trait_item(hir::TraitItemId { def_id: trait_m }).kind\n+                        {\n+                            match fn_.decl.implicit_self {\n+                                hir::ImplicitSelfKind::ImmRef => \"&\",\n+                                hir::ImplicitSelfKind::MutRef => \"&mut \",\n+                                _ => \"\",\n+                            }\n+                        } else {\n+                            \"\"\n+                        };\n                         let candidate = candidate.super_fold_with(&mut eraser);\n                         vec![\n-                            (expr.span.shrink_to_lo(), format!(\"{}::{}(\", candidate, segment.ident)),\n+                            (expr.span.shrink_to_lo(), format!(\"{}::{}({}\", candidate, segment.ident, prefix)),\n                             if exprs.len() == 1 {\n                                 (expr.span.shrink_to_hi().with_hi(e.span.hi()), \")\".to_string())\n                             } else {"}, {"sha": "a1d1b6b3a785bcc6e522d6e7363140e4a4fcdb90", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -136,6 +136,10 @@ pub trait Printer<'tcx>: Sized {\n                     match key.disambiguated_data.data {\n                         // Closures' own generics are only captures, don't print them.\n                         DefPathData::ClosureExpr => {}\n+                        // This covers both `DefKind::AnonConst` and `DefKind::InlineConst`.\n+                        // Anon consts doesn't have their own generics, and inline consts' own\n+                        // generics are their inferred types, so don't print them.\n+                        DefPathData::AnonConst => {}\n \n                         // If we have any generic arguments to print, we do that\n                         // on top of the same path, but without its own generics."}, {"sha": "147c136e651dd6ccf15dea84b0b5ab315c78e630", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -158,6 +158,7 @@ impl<'tcx> Cx<'tcx> {\n     }\n \n     fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n+        let tcx = self.tcx;\n         let expr_ty = self.typeck_results().expr_ty(expr);\n         let expr_span = expr.span;\n         let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n@@ -196,7 +197,7 @@ impl<'tcx> Cx<'tcx> {\n \n                     let arg_tys = args.iter().map(|e| self.typeck_results().expr_ty_adjusted(e));\n                     let tupled_args = Expr {\n-                        ty: self.tcx.mk_tup(arg_tys),\n+                        ty: tcx.mk_tup(arg_tys),\n                         temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Tuple { fields: self.mirror_exprs(args) },\n@@ -488,24 +489,24 @@ impl<'tcx> Cx<'tcx> {\n                             out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n                         },\n                         hir::InlineAsmOperand::Const { ref anon_const } => {\n-                            let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                            let anon_const_def_id = tcx.hir().local_def_id(anon_const.hir_id);\n                             let value = mir::ConstantKind::from_anon_const(\n-                                self.tcx,\n+                                tcx,\n                                 anon_const_def_id,\n                                 self.param_env,\n                             );\n-                            let span = self.tcx.hir().span(anon_const.hir_id);\n+                            let span = tcx.hir().span(anon_const.hir_id);\n \n                             InlineAsmOperand::Const { value, span }\n                         }\n                         hir::InlineAsmOperand::SymFn { ref anon_const } => {\n-                            let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                            let anon_const_def_id = tcx.hir().local_def_id(anon_const.hir_id);\n                             let value = mir::ConstantKind::from_anon_const(\n-                                self.tcx,\n+                                tcx,\n                                 anon_const_def_id,\n                                 self.param_env,\n                             );\n-                            let span = self.tcx.hir().span(anon_const.hir_id);\n+                            let span = tcx.hir().span(anon_const.hir_id);\n \n                             InlineAsmOperand::SymFn { value, span }\n                         }\n@@ -519,21 +520,16 @@ impl<'tcx> Cx<'tcx> {\n             },\n \n             hir::ExprKind::ConstBlock(ref anon_const) => {\n-                let tcx = self.tcx;\n-                let local_def_id = tcx.hir().local_def_id(anon_const.hir_id);\n-                let anon_const_def_id = local_def_id.to_def_id();\n-\n-                // Need to include the parent substs\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n-                let ty = tcx.typeck(local_def_id).node_type(hir_id);\n-                let typeck_root_def_id = tcx.typeck_root_def_id(anon_const_def_id);\n+                let ty = self.typeck_results().node_type(anon_const.hir_id);\n+                let did = tcx.hir().local_def_id(anon_const.hir_id).to_def_id();\n+                let typeck_root_def_id = tcx.typeck_root_def_id(did);\n                 let parent_substs =\n                     tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n                 let substs =\n                     InlineConstSubsts::new(tcx, InlineConstSubstsParts { parent_substs, ty })\n                         .substs;\n \n-                ExprKind::ConstBlock { did: anon_const_def_id, substs }\n+                ExprKind::ConstBlock { did, substs }\n             }\n             // Now comes the rote stuff:\n             hir::ExprKind::Repeat(ref v, _) => {\n@@ -591,7 +587,7 @@ impl<'tcx> Cx<'tcx> {\n             }\n             hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n                 lhs: self.mirror_expr(source),\n-                name: Field::new(self.tcx.field_index(expr.hir_id, self.typeck_results)),\n+                name: Field::new(tcx.field_index(expr.hir_id, self.typeck_results)),\n             },\n             hir::ExprKind::Cast(ref source, ref cast_ty) => {\n                 // Check for a user-given type annotation on this `cast`\n@@ -640,7 +636,7 @@ impl<'tcx> Cx<'tcx> {\n                                     let (d, o) = adt_def.discriminant_def_for_variant(idx);\n                                     use rustc_middle::ty::util::IntTypeExt;\n                                     let ty = adt_def.repr().discr_type();\n-                                    let ty = ty.to_ty(self.tcx());\n+                                    let ty = ty.to_ty(tcx);\n                                     Some((d, o, ty))\n                                 }\n                                 _ => None,\n@@ -652,8 +648,7 @@ impl<'tcx> Cx<'tcx> {\n \n                     let source = if let Some((did, offset, var_ty)) = var {\n                         let param_env_ty = self.param_env.and(var_ty);\n-                        let size = self\n-                            .tcx\n+                        let size = tcx\n                             .layout_of(param_env_ty)\n                             .unwrap_or_else(|e| {\n                                 panic!(\"could not compute layout for {:?}: {:?}\", param_env_ty, e)\n@@ -671,7 +666,7 @@ impl<'tcx> Cx<'tcx> {\n                             Some(did) => {\n                                 // in case we are offsetting from a computed discriminant\n                                 // and not the beginning of discriminants (which is always `0`)\n-                                let substs = InternalSubsts::identity_for_item(self.tcx(), did);\n+                                let substs = InternalSubsts::identity_for_item(tcx, did);\n                                 let kind =\n                                     ExprKind::NamedConst { def_id: did, substs, user_ty: None };\n                                 let lhs = self.thir.exprs.push(Expr {"}, {"sha": "18f32b04fadca5aee2e066896992cefbd1986066", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -445,12 +445,9 @@ fn collect_items_rec<'tcx>(\n                             // depend on any other items.\n                         }\n                         hir::InlineAsmOperand::SymFn { anon_const } => {\n-                            let def_id = tcx.hir().body_owner_def_id(anon_const.body).to_def_id();\n-                            if let Ok(val) = tcx.const_eval_poly(def_id) {\n-                                rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                                    collect_const_value(tcx, val, &mut neighbors);\n-                                });\n-                            }\n+                            let fn_ty =\n+                                tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n+                            visit_fn_use(tcx, fn_ty, false, *op_sp, &mut neighbors);\n                         }\n                         hir::InlineAsmOperand::SymStatic { path: _, def_id } => {\n                             let instance = Instance::mono(tcx, *def_id);"}, {"sha": "723e66e9ef61807d42ed927cdf72970d2157ecab", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -3105,6 +3105,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         );\n     }\n \n+    fn resolve_inline_const(&mut self, constant: &'ast AnonConst) {\n+        debug!(\"resolve_anon_const {constant:?}\");\n+        self.with_constant_rib(IsRepeatExpr::No, HasGenericParams::Yes, None, |this| {\n+            visit::walk_anon_const(this, constant);\n+        });\n+    }\n+\n     fn resolve_expr(&mut self, expr: &'ast Expr, parent: Option<&'ast Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -3261,7 +3268,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 });\n             }\n             ExprKind::ConstBlock(ref ct) => {\n-                self.resolve_anon_const(ct, IsRepeatExpr::No);\n+                self.resolve_inline_const(ct);\n             }\n             ExprKind::Index(ref elem, ref idx) => {\n                 self.resolve_expr(elem, Some(expr));"}, {"sha": "c1d4bb92173da6d00fc0a76fd3b36ff733371b19", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -914,6 +914,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         reasons.auto_traits.extend(auto_trait_reasons);\n         reasons.drop_order = drop_order;\n \n+        // `auto_trait_reasons` are in hashset order, so sort them to put the\n+        // diagnostics we emit later in a cross-platform-consistent order.\n+        reasons.auto_traits.sort_unstable();\n+\n         reasons\n     }\n "}, {"sha": "30190138750ca2cda6d61860175870cf9ba2f536", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -248,7 +248,16 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         }\n \n         // Index this method for searching later on.\n-        if let Some(ref s) = item.name {\n+        if let Some(ref s) = item.name.or_else(|| {\n+            if item.is_stripped() {\n+                None\n+            } else if let clean::ImportItem(ref i) = *item.kind &&\n+                let clean::ImportKind::Simple(s) = i.kind {\n+                Some(s)\n+            } else {\n+                None\n+            }\n+        }) {\n             let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::AssocTypeItem(..)"}, {"sha": "19582481910173dd3c7ff86ec2b690f716b05cb1", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -2542,7 +2542,16 @@ fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n \n     let item_sections_in_use: FxHashSet<_> = items\n         .iter()\n-        .filter(|it| !it.is_stripped() && it.name.is_some())\n+        .filter(|it| {\n+            !it.is_stripped()\n+                && it\n+                    .name\n+                    .or_else(|| {\n+                        if let clean::ImportItem(ref i) = *it.kind &&\n+                            let clean::ImportKind::Simple(s) = i.kind { Some(s) } else { None }\n+                    })\n+                    .is_some()\n+        })\n         .map(|it| item_ty_to_section(it.type_()))\n         .collect();\n     for &sec in ItemSection::ALL.iter().filter(|sec| item_sections_in_use.contains(sec)) {"}, {"sha": "fbb3d3e45845ba5db751ee8bdbcce9750fb913ba", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 96, "deletions": 13, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -3,7 +3,7 @@ use clean::AttributesExt;\n use std::cmp::Ordering;\n use std::fmt;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n@@ -346,7 +346,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 w.write_str(ITEM_TABLE_ROW_OPEN);\n                 write!(\n                     w,\n-                    \"<div class=\\\"item-left {stab}{add}import-item\\\">\\\n+                    \"<div class=\\\"item-left {stab}{add}import-item\\\"{id}>\\\n                          <code>{vis}{imp}</code>\\\n                      </div>\\\n                      <div class=\\\"item-right docblock-short\\\">{stab_tags}</div>\",\n@@ -355,6 +355,11 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     vis = myitem.visibility.print_with_space(myitem.item_id, cx),\n                     imp = import.print(cx),\n                     stab_tags = stab_tags.unwrap_or_default(),\n+                    id = match import.kind {\n+                        clean::ImportKind::Simple(s) =>\n+                            format!(\" id=\\\"{}\\\"\", cx.derive_id(format!(\"reexport.{}\", s))),\n+                        clean::ImportKind::Glob => String::new(),\n+                    },\n                 );\n                 w.write_str(ITEM_TABLE_ROW_CLOSE);\n             }\n@@ -790,16 +795,18 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All);\n \n     let cache = cx.cache();\n+    let mut extern_crates = FxHashSet::default();\n     if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n         for implementor in implementors {\n-            match implementor.inner_impl().for_ {\n-                clean::Type::Path { ref path }\n-                | clean::BorrowedRef { type_: box clean::Type::Path { ref path }, .. }\n-                    if !path.is_assoc_ty() =>\n-                {\n+            if let Some(did) = implementor.inner_impl().for_.without_borrowed_ref().def_id(cx.cache()) &&\n+                !did.is_local() {\n+                extern_crates.insert(did.krate);\n+            }\n+            match implementor.inner_impl().for_.without_borrowed_ref() {\n+                clean::Type::Path { ref path } if !path.is_assoc_ty() => {\n                     let did = path.def_id();\n                     let &mut (prev_did, ref mut has_duplicates) =\n                         implementor_dups.entry(path.last()).or_insert((did, false));\n@@ -898,20 +905,96 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         }\n     }\n \n+    // Include implementors in crates that depend on the current crate.\n+    //\n+    // This is complicated by the way rustdoc is invoked, which is basically\n+    // the same way rustc is invoked: it gets called, one at a time, for each\n+    // crate. When building the rustdocs for the current crate, rustdoc can\n+    // see crate metadata for its dependencies, but cannot see metadata for its\n+    // dependents.\n+    //\n+    // To make this work, we generate a \"hook\" at this stage, and our\n+    // dependents can \"plug in\" to it when they build. For simplicity's sake,\n+    // it's [JSONP]: a JavaScript file with the data we need (and can parse),\n+    // surrounded by a tiny wrapper that the Rust side ignores, but allows the\n+    // JavaScript side to include without having to worry about Same Origin\n+    // Policy. The code for *that* is in `write_shared.rs`.\n+    //\n+    // This is further complicated by `#[doc(inline)]`. We want all copies\n+    // of an inlined trait to reference the same JS file, to address complex\n+    // dependency graphs like this one (lower crates depend on higher crates):\n+    //\n+    // ```text\n+    //  --------------------------------------------\n+    //  |            crate A: trait Foo            |\n+    //  --------------------------------------------\n+    //      |                               |\n+    //  --------------------------------    |\n+    //  | crate B: impl A::Foo for Bar |    |\n+    //  --------------------------------    |\n+    //      |                               |\n+    //  ---------------------------------------------\n+    //  | crate C: #[doc(inline)] use A::Foo as Baz |\n+    //  |          impl Baz for Quux                |\n+    //  ---------------------------------------------\n+    // ```\n+    //\n+    // Basically, we want `C::Baz` and `A::Foo` to show the same set of\n+    // impls, which is easier if they both treat `/implementors/A/trait.Foo.js`\n+    // as the Single Source of Truth.\n+    //\n+    // We also want the `impl Baz for Quux` to be written to\n+    // `trait.Foo.js`. However, when we generate plain HTML for `C::Baz`,\n+    // we're going to want to generate plain HTML for `impl Baz for Quux` too,\n+    // because that'll load faster, and it's better for SEO. And we don't want\n+    // the same impl to show up twice on the same page.\n+    //\n+    // To make this work, the implementors JS file has a structure kinda\n+    // like this:\n+    //\n+    // ```js\n+    // JSONP({\n+    // \"B\": {\"impl A::Foo for Bar\"},\n+    // \"C\": {\"impl Baz for Quux\"},\n+    // });\n+    // ```\n+    //\n+    // First of all, this means we can rebuild a crate, and it'll replace its own\n+    // data if something changes. That is, `rustdoc` is idempotent. The other\n+    // advantage is that we can list the crates that get included in the HTML,\n+    // and ignore them when doing the JavaScript-based part of rendering.\n+    // So C's HTML will have something like this:\n+    //\n+    // ```html\n+    // <script type=\"text/javascript\" src=\"/implementors/A/trait.Foo.js\"\n+    //     data-ignore-extern-crates=\"A,B\" async></script>\n+    // ```\n+    //\n+    // And, when the JS runs, anything in data-ignore-extern-crates is known\n+    // to already be in the HTML, and will be ignored.\n+    //\n+    // [JSONP]: https://en.wikipedia.org/wiki/JSONP\n     let mut js_src_path: UrlPartsBuilder = std::iter::repeat(\"..\")\n         .take(cx.current.len())\n         .chain(std::iter::once(\"implementors\"))\n         .collect();\n-    if it.item_id.is_local() {\n-        js_src_path.extend(cx.current.iter().copied());\n+    if let Some(did) = it.item_id.as_def_id() &&\n+        let get_extern = { || cache.external_paths.get(&did).map(|s| s.0.clone()) } &&\n+        let Some(fqp) = cache.exact_paths.get(&did).cloned().or_else(get_extern) {\n+        js_src_path.extend(fqp[..fqp.len() - 1].iter().copied());\n+        js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), fqp.last().unwrap()));\n     } else {\n-        let (ref path, _) = cache.external_paths[&it.item_id.expect_def_id()];\n-        js_src_path.extend(path[..path.len() - 1].iter().copied());\n+        js_src_path.extend(cx.current.iter().copied());\n+        js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), it.name.unwrap()));\n     }\n-    js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), it.name.unwrap()));\n+    let extern_crates = extern_crates\n+        .into_iter()\n+        .map(|cnum| cx.shared.tcx.crate_name(cnum).to_string())\n+        .collect::<Vec<_>>()\n+        .join(\",\");\n     write!(\n         w,\n-        \"<script type=\\\"text/javascript\\\" src=\\\"{src}\\\" async></script>\",\n+        \"<script type=\\\"text/javascript\\\" src=\\\"{src}\\\" data-ignore-extern-crates=\\\"{extern_crates}\\\" async></script>\",\n         src = js_src_path.finish(),\n     );\n }"}, {"sha": "e8e5fa17993337ddbaf0b0684de78e8d34cad61f", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -501,10 +501,13 @@ pub(super) fn write_shared(\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n-            Some(p) => p,\n+        let (remote_path, remote_item_type) = match cache.exact_paths.get(&did) {\n+            Some(p) => match cache.paths.get(&did).or_else(|| cache.external_paths.get(&did)) {\n+                Some((_, t)) => (p, t),\n+                None => continue,\n+            },\n             None => match cache.external_paths.get(&did) {\n-                Some(p) => p,\n+                Some((p, t)) => (p, t),\n                 None => continue,\n             },\n         };"}, {"sha": "eb3ce37e313d065ef6387c0a03e57a0194ac8d16", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -1333,6 +1333,11 @@ pre.rust {\n \tborder-top: 2px solid;\n }\n \n+#titles > button:first-child:last-child {\n+\tmargin-right: 1px;\n+\twidth: calc(100% - 1px);\n+}\n+\n #titles > button:not(:last-child) {\n \tmargin-right: 1px;\n \twidth: calc(33.3% - 1px);"}, {"sha": "2d8339e839424e362770e40072e2f579b35bbee2", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -759,8 +759,14 @@ function loadCss(cssFileName) {\n         const traitName = document.querySelector(\"h1.fqn > .in-band > .trait\").textContent;\n         const baseIdName = \"impl-\" + traitName + \"-\";\n         const libs = Object.getOwnPropertyNames(imp);\n+        // We don't want to include impls from this JS file, when the HTML already has them.\n+        // The current crate should always be ignored. Other crates that should also be\n+        // ignored are included in the attribute `data-ignore-extern-crates`.\n+        const ignoreExternCrates = document\n+            .querySelector(\"script[data-ignore-extern-crates]\")\n+            .getAttribute(\"data-ignore-extern-crates\");\n         for (const lib of libs) {\n-            if (lib === window.currentCrate) {\n+            if (lib === window.currentCrate || ignoreExternCrates.indexOf(lib) !== -1) {\n                 continue;\n             }\n             const structs = imp[lib];"}, {"sha": "2eafa540a1aa281be000e182067450e5ef8ab560", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -45,26 +45,33 @@ const TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n \n // In the search display, allows to switch between tabs.\n function printTab(nb) {\n-    if (nb === 0 || nb === 1 || nb === 2) {\n-        searchState.currentTab = nb;\n-    }\n-    let nb_copy = nb;\n+    let iter = 0;\n+    let foundCurrentTab = false;\n+    let foundCurrentResultSet = false;\n     onEachLazy(document.getElementById(\"titles\").childNodes, elem => {\n-        if (nb_copy === 0) {\n+        if (nb === iter) {\n             addClass(elem, \"selected\");\n+            foundCurrentTab = true;\n         } else {\n             removeClass(elem, \"selected\");\n         }\n-        nb_copy -= 1;\n+        iter += 1;\n     });\n+    iter = 0;\n     onEachLazy(document.getElementById(\"results\").childNodes, elem => {\n-        if (nb === 0) {\n+        if (nb === iter) {\n             addClass(elem, \"active\");\n+            foundCurrentResultSet = true;\n         } else {\n             removeClass(elem, \"active\");\n         }\n-        nb -= 1;\n+        iter += 1;\n     });\n+    if (foundCurrentTab && foundCurrentResultSet) {\n+        searchState.currentTab = nb;\n+    } else if (nb != 0) {\n+        printTab(0);\n+    }\n }\n \n /**\n@@ -1409,18 +1416,12 @@ window.initSearch = rawSearchIndex => {\n                     for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n                         row = searchIndex[i];\n                         in_returned = checkReturned(row, elem, parsedQuery.typeFilter);\n-                        addIntoResults(results_returned, row.id, i, -1, in_returned);\n+                        addIntoResults(results_others, row.id, i, -1, in_returned);\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {\n-                let container = results_others;\n-                // In the special case where only a \"returned\" information is available, we want to\n-                // put the information into the \"results_returned\" dict.\n-                if (parsedQuery.returned.length !== 0 && parsedQuery.elems.length === 0) {\n-                    container = results_returned;\n-                }\n                 for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n-                    handleArgs(searchIndex[i], i, container);\n+                    handleArgs(searchIndex[i], i, results_others);\n                 }\n             }\n         }\n@@ -1509,6 +1510,9 @@ window.initSearch = rawSearchIndex => {\n             displayPath = path + \"::\";\n             href = window.rootPath + path.replace(/::/g, \"/\") + \"/\" +\n                    name + \"/index.html\";\n+        } else if (type === \"import\") {\n+            displayPath = item.path + \"::\";\n+            href = window.rootPath + item.path.replace(/::/g, \"/\") + \"/index.html#reexport.\" + name;\n         } else if (type === \"primitive\" || type === \"keyword\") {\n             displayPath = \"\";\n             href = window.rootPath + path.replace(/::/g, \"/\") +\n@@ -1725,12 +1729,26 @@ window.initSearch = rawSearchIndex => {\n             `${typeFilter}</h1> in ${crates} </div>`;\n         if (results.query.error !== null) {\n             output += `<h3>Query parser error: \"${results.query.error}\".</h3>`;\n+            output += '<div id=\"titles\">' +\n+                makeTabHeader(0, \"In Names\", ret_others[1]) +\n+                \"</div>\";\n+            currentTab = 0;\n+        } else if (results.query.foundElems <= 1 && results.query.returned.length === 0) {\n+            output += `<div id=\"titles\">` +\n+                makeTabHeader(0, \"In Names\", ret_others[1]) +\n+                makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n+                makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n+                \"</div>\";\n+        } else {\n+            const signatureTabTitle =\n+                results.query.elems.length === 0 ? \"In Function Return Types\" :\n+                results.query.returned.length === 0 ? \"In Function Parameters\" :\n+                \"In Function Signatures\";\n+            output += '<div id=\"titles\">' +\n+                makeTabHeader(0, signatureTabTitle, ret_others[1]) +\n+                \"</div>\";\n+            currentTab = 0;\n         }\n-        output += `<div id=\"titles\">` +\n-            makeTabHeader(0, \"In Names\", ret_others[1]) +\n-            makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n-            makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n-            \"</div>\";\n \n         const resultsElem = document.createElement(\"div\");\n         resultsElem.id = \"results\";\n@@ -1745,12 +1763,16 @@ window.initSearch = rawSearchIndex => {\n         }\n         search.appendChild(resultsElem);\n         // Reset focused elements.\n-        searchState.focusedByTab = [null, null, null];\n         searchState.showResults(search);\n         const elems = document.getElementById(\"titles\").childNodes;\n-        elems[0].onclick = () => { printTab(0); };\n-        elems[1].onclick = () => { printTab(1); };\n-        elems[2].onclick = () => { printTab(2); };\n+        searchState.focusedByTab = [];\n+        let i = 0;\n+        for (const elem of elems) {\n+            const j = i;\n+            elem.onclick = () => { printTab(j); };\n+            searchState.focusedByTab.push(null);\n+            i += 1;\n+        }\n         printTab(currentTab);\n     }\n "}, {"sha": "4cf73b40faf0b070f4ac9b79e8bd051dc2990341", "filename": "src/test/assembly/asm/global_asm.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fassembly%2Fasm%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fassembly%2Fasm%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fglobal_asm.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -2,6 +2,7 @@\n // only-linux\n // assembly-output: emit-asm\n // compile-flags: -C llvm-args=--x86-asm-syntax=intel\n+// compile-flags: -C symbol-mangling-version=v0\n \n #![feature(asm_const, asm_sym)]\n #![crate_type = \"rlib\"]\n@@ -24,3 +25,7 @@ global_asm!(\"movl ${}, %ecx\", const 5, options(att_syntax));\n global_asm!(\"call {}\", sym my_func);\n // CHECK: lea rax, [rip + MY_STATIC]\n global_asm!(\"lea rax, [rip + {}]\", sym MY_STATIC);\n+// CHECK: call _RNvCsiubXh4Yz005_10global_asm6foobar\n+global_asm!(\"call {}\", sym foobar);\n+// CHECK: _RNvCsiubXh4Yz005_10global_asm6foobar:\n+fn foobar() { loop {} }"}, {"sha": "f29613f78b1b2e2e842fe46709b276ce026d63eb", "filename": "src/test/rustdoc-gui/implementors.goml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -18,3 +18,10 @@ assert: \"#implementors-list .impl:nth-child(2) > .code-header.in-band\"\n goto: file://|DOC_PATH|/test_docs/struct.HasEmptyTraits.html\n compare-elements-position-near-false: (\"#impl-EmptyTrait1\", \"#impl-EmptyTrait2\", {\"y\": 30})\n compare-elements-position-near: (\"#impl-EmptyTrait3 h3\", \"#impl-EmptyTrait3 .item-info\", {\"y\": 30})\n+\n+// Now check that re-exports work correctly.\n+// There should be exactly one impl shown on both of these pages.\n+goto: file://|DOC_PATH|/lib2/trait.TraitToReexport.html\n+assert-count: (\"#implementors-list .impl\", 1)\n+goto: file://|DOC_PATH|/implementors/trait.TraitToReexport.html\n+assert-count: (\"#implementors-list .impl\", 1)"}, {"sha": "557781d481092e6663d2cf4a3e641ae6159ee7fe", "filename": "src/test/rustdoc-gui/search-reexport.goml", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsearch-reexport.goml", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsearch-reexport.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-reexport.goml?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,29 @@\n+// Checks that the reexports are present in the search index, can have\n+// doc aliases and are highligted when their ID is the hash of the page.\n+goto: file://|DOC_PATH|/test_docs/index.html\n+local-storage: {\"rustdoc-theme\": \"dark\", \"rustdoc-use-system-theme\": \"false\"}\n+reload:\n+// First we check that the reexport has the correct ID and no background color.\n+assert-text: (\"//*[@id='reexport.TheStdReexport']\", \"pub use ::std as TheStdReexport;\")\n+assert-css: (\"//*[@id='reexport.TheStdReexport']\", {\"background-color\": \"rgba(0, 0, 0, 0)\"})\n+write: (\".search-input\", \"TheStdReexport\")\n+wait-for: \"//a[@class='result-import']\"\n+assert-attribute: (\n+    \"//a[@class='result-import']\",\n+    {\"href\": \"../test_docs/index.html#reexport.TheStdReexport\"},\n+)\n+assert-text: (\"//a[@class='result-import']\", \"test_docs::TheStdReexport\")\n+click: \"//a[@class='result-import']\"\n+// We check that it has the background modified thanks to the focus.\n+wait-for-css: (\"//*[@id='reexport.TheStdReexport']\", {\"background-color\": \"rgb(73, 74, 61)\"})\n+\n+// We now check that the alias is working as well on the reexport.\n+write: (\".search-input\", \"AliasForTheStdReexport\")\n+wait-for: \"//a[@class='result-import']\"\n+assert-text: (\n+    \"//a[@class='result-import']\",\n+    \"AliasForTheStdReexport - see test_docs::TheStdReexport\",\n+)\n+// Same thing again, we click on it to ensure the background is once again set as expected.\n+click: \"//a[@class='result-import']\"\n+wait-for-css: (\"//*[@id='reexport.TheStdReexport']\", {\"background-color\": \"rgb(73, 74, 61)\"})"}, {"sha": "763927f9d0fe9d810b7acc4924e5ae5e25483508", "filename": "src/test/rustdoc-gui/search-tab-change-title-fn-sig.goml", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-change-title-fn-sig.goml", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-change-title-fn-sig.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-change-title-fn-sig.goml?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,64 @@\n+// Checks that the search tab results work correctly with function signature syntax\n+// First, try a search-by-name\n+goto: file://|DOC_PATH|/test_docs/index.html\n+write: (\".search-input\", \"Foo\")\n+// Waiting for the search results to appear...\n+wait-for: \"#titles\"\n+assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+assert-text: (\"#titles > button:nth-of-type(1)\", \"In Names\", STARTS_WITH)\n+assert: \"input.search-input:focus\"\n+// Use left-right keys\n+press-key: \"ArrowDown\"\n+assert: \"#results > .search-results.active > a:nth-of-type(1):focus\"\n+press-key: \"ArrowRight\"\n+wait-for-attribute: (\"#titles > button:nth-of-type(2)\", {\"class\": \"selected\"})\n+press-key: \"ArrowRight\"\n+wait-for-attribute: (\"#titles > button:nth-of-type(3)\", {\"class\": \"selected\"})\n+press-key: \"ArrowRight\"\n+wait-for-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+press-key: \"ArrowLeft\"\n+wait-for-attribute: (\"#titles > button:nth-of-type(3)\", {\"class\": \"selected\"})\n+\n+// Now try search-by-return\n+goto: file://|DOC_PATH|/test_docs/index.html\n+write: (\".search-input\", \"-> String\")\n+// Waiting for the search results to appear...\n+wait-for: \"#titles\"\n+assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+assert-text: (\"#titles > button:nth-of-type(1)\", \"In Function Return Types\", STARTS_WITH)\n+assert: \"input.search-input:focus\"\n+// Use left-right keys\n+press-key: \"ArrowDown\"\n+assert: \"#results > .search-results.active > a:nth-of-type(1):focus\"\n+press-key: \"ArrowRight\"\n+wait-for-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+press-key: \"ArrowRight\"\n+wait-for-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+press-key: \"ArrowRight\"\n+wait-for-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+press-key: \"ArrowLeft\"\n+wait-for-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+\n+// Try with a search-by-return with no results\n+goto: file://|DOC_PATH|/test_docs/index.html\n+write: (\".search-input\", \"-> Something\")\n+// Waiting for the search results to appear...\n+wait-for: \"#titles\"\n+assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+assert-text: (\"#titles > button:nth-of-type(1)\", \"In Function Return Types\", STARTS_WITH)\n+\n+// Try with a search-by-parameter\n+goto: file://|DOC_PATH|/test_docs/index.html\n+write: (\".search-input\", \"usize pattern\")\n+// Waiting for the search results to appear...\n+wait-for: \"#titles\"\n+assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+assert-text: (\"#titles > button:nth-of-type(1)\", \"In Function Parameters\", STARTS_WITH)\n+\n+// Try with a search-by-parameter-and-return\n+goto: file://|DOC_PATH|/test_docs/index.html\n+write: (\".search-input\", \"pattern -> str\")\n+// Waiting for the search results to appear...\n+wait-for: \"#titles\"\n+assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n+assert-text: (\"#titles > button:nth-of-type(1)\", \"In Function Signatures\", STARTS_WITH)"}, {"sha": "52b3ceae7b115ae09186d12cb9a38a60cf02dd55", "filename": "src/test/rustdoc-gui/search-tab-selection-if-current-is-empty.goml", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d60b4f52c92facae291151dd5a23399f8044d01e/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-selection-if-current-is-empty.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d60b4f52c92facae291151dd5a23399f8044d01e/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-selection-if-current-is-empty.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-selection-if-current-is-empty.goml?ref=d60b4f52c92facae291151dd5a23399f8044d01e", "patch": "@@ -1,23 +0,0 @@\n-// Checks that the first non-empty search result tab is selected if the default/currently selected\n-// one is empty.\n-goto: file://|DOC_PATH|/test_docs/index.html\n-write: (\".search-input\", \"Foo\")\n-// Waiting for the search results to appear...\n-wait-for: \"#titles\"\n-assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n-\n-// To go back to the original \"state\"\n-goto: file://|DOC_PATH|/test_docs/index.html\n-write: (\".search-input\", \"-> String\")\n-// Waiting for the search results to appear...\n-wait-for: \"#titles\"\n-// With this search, only the last tab shouldn't be empty so it should be selected.\n-assert-attribute: (\"#titles > button:nth-of-type(3)\", {\"class\": \"selected\"})\n-\n-// To go back to the original \"state\"\n-goto: file://|DOC_PATH|/test_docs/index.html\n-write: (\".search-input\", \"-> Something\")\n-// Waiting for the search results to appear...\n-wait-for: \"#titles\"\n-// With this search, all the tabs are empty so the first one should remain selected.\n-assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})"}, {"sha": "32fe3334f36440ffc0fd4ff25ade5a42297daf37", "filename": "src/test/rustdoc-gui/sidebar.goml", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -13,15 +13,16 @@ assert-css: (\"#all-types\", {\"color\": \"rgb(53, 109, 164)\"})\n // We check that we have the crates list and that the \"current\" on is \"test_docs\".\n assert-text: (\".sidebar-elems .crate > ul > li > a.current\", \"test_docs\")\n // And we're also supposed to have the list of items in the current module.\n-assert-text: (\".sidebar-elems section ul > li:nth-child(1)\", \"Modules\")\n-assert-text: (\".sidebar-elems section ul > li:nth-child(2)\", \"Macros\")\n-assert-text: (\".sidebar-elems section ul > li:nth-child(3)\", \"Structs\")\n-assert-text: (\".sidebar-elems section ul > li:nth-child(4)\", \"Enums\")\n-assert-text: (\".sidebar-elems section ul > li:nth-child(5)\", \"Traits\")\n-assert-text: (\".sidebar-elems section ul > li:nth-child(6)\", \"Functions\")\n-assert-text: (\".sidebar-elems section ul > li:nth-child(7)\", \"Type Definitions\")\n-assert-text: (\".sidebar-elems section ul > li:nth-child(8)\", \"Unions\")\n-assert-text: (\".sidebar-elems section ul > li:nth-child(9)\", \"Keywords\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(1)\", \"Re-exports\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(2)\", \"Modules\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(3)\", \"Macros\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(4)\", \"Structs\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(5)\", \"Enums\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(6)\", \"Traits\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(7)\", \"Functions\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(8)\", \"Type Definitions\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(9)\", \"Unions\")\n+assert-text: (\".sidebar-elems section ul > li:nth-child(10)\", \"Keywords\")\n assert-text: (\"#structs + .item-table .item-left > a\", \"Foo\")\n click: \"#structs + .item-table .item-left > a\"\n "}, {"sha": "1620e842291915ea8a8ffdc54235b2c75ad1a770", "filename": "src/test/rustdoc-gui/src/lib2/implementors/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Fimplementors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Fimplementors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Fimplementors%2Flib.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -9,3 +9,12 @@ pub struct Struct;\n impl Whatever for Struct {\n     type Foo = u8;\n }\n+\n+mod traits {\n+    pub trait TraitToReexport {\n+        fn method() {}\n+    }\n+}\n+\n+#[doc(inline)]\n+pub use traits::TraitToReexport;"}, {"sha": "d06b46f952d0e7cf559b5c7bd4eb11b72ac197bd", "filename": "src/test/rustdoc-gui/src/lib2/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -43,6 +43,13 @@ impl implementors::Whatever for Foo {\n     type Foo = u32;\n }\n \n+#[doc(inline)]\n+pub use implementors::TraitToReexport;\n+\n+pub struct StructToImplOnReexport;\n+\n+impl TraitToReexport for StructToImplOnReexport {}\n+\n pub mod sub_mod {\n     /// ```txt\n     /// aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}, {"sha": "b6fe9eb2565bd0b568d7bc670e66358bc6565c17", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -274,3 +274,6 @@ impl EmptyTrait3 for HasEmptyTraits {}\n \n mod macros;\n pub use macros::*;\n+\n+#[doc(alias = \"AliasForTheStdReexport\")]\n+pub use ::std as TheStdReexport;"}, {"sha": "8f33a6604c2195d317c696f806e6802ab0b7c34d", "filename": "src/test/rustdoc/hidden-impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc%2Fhidden-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Frustdoc%2Fhidden-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhidden-impls.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -12,6 +12,6 @@ pub mod __hidden {\n \n // @has foo/trait.Clone.html\n // @!has - 'Foo'\n-// @has implementors/foo/trait.Clone.js\n+// @has implementors/core/clone/trait.Clone.js\n // @!has - 'Foo'\n pub use std::clone::Clone;"}, {"sha": "a8367766ae1cff4383c7331f9715539d968cbcb0", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -29,8 +29,8 @@ error: changes to closure capture in Rust 2021 will affect which traits the clos\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^\n    |                   |\n-   |                   in Rust 2018, this closure implements `Sync` as `fptr` implements `Sync`, but in Rust 2021, this closure will no longer implement `Sync` because `fptr` is not fully captured and `fptr.0.0` does not implement `Sync`\n    |                   in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0.0` does not implement `Send`\n+   |                   in Rust 2018, this closure implements `Sync` as `fptr` implements `Sync`, but in Rust 2021, this closure will no longer implement `Sync` because `fptr` is not fully captured and `fptr.0.0` does not implement `Sync`\n ...\n LL |         *fptr.0.0 = 20;\n    |         --------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0.0`"}, {"sha": "2648b00435b319c32563b73c34b205506ea39b00", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -4,8 +4,8 @@ error: changes to closure capture in Rust 2021 will affect which traits the clos\n LL |     let result = panic::catch_unwind(move || {\n    |                                      ^^^^^^^\n    |                                      |\n-   |                                      in Rust 2018, this closure implements `UnwindSafe` as `f` implements `UnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe` because `f` is not fully captured and `f.0` does not implement `UnwindSafe`\n    |                                      in Rust 2018, this closure implements `RefUnwindSafe` as `f` implements `RefUnwindSafe`, but in Rust 2021, this closure will no longer implement `RefUnwindSafe` because `f` is not fully captured and `f.0` does not implement `RefUnwindSafe`\n+   |                                      in Rust 2018, this closure implements `UnwindSafe` as `f` implements `UnwindSafe`, but in Rust 2021, this closure will no longer implement `UnwindSafe` because `f` is not fully captured and `f.0` does not implement `UnwindSafe`\n ...\n LL |         f.0()\n    |         --- in Rust 2018, this closure captures all of `f`, but in Rust 2021, it will only capture `f.0`"}, {"sha": "483eae6bb4b1f250261d02e2a6df899d88308bf8", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -94,8 +94,8 @@ error: changes to closure capture in Rust 2021 will affect which traits the clos\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^\n    |                   |\n-   |                   in Rust 2018, this closure implements `Sync` as `fptr1` implements `Sync`, but in Rust 2021, this closure will no longer implement `Sync` because `fptr1` is not fully captured and `fptr1.0.0` does not implement `Sync`\n    |                   in Rust 2018, this closure implements `Send` as `fptr1` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr1` is not fully captured and `fptr1.0.0` does not implement `Send`\n+   |                   in Rust 2018, this closure implements `Sync` as `fptr1` implements `Sync`, but in Rust 2021, this closure will no longer implement `Sync` because `fptr1` is not fully captured and `fptr1.0.0` does not implement `Sync`\n    |                   in Rust 2018, this closure implements `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr2` is not fully captured and `fptr2.0` does not implement `Send`\n ...\n LL |         *fptr1.0.0 = 20;"}, {"sha": "4e8879af54aff015e1de748d3486a56ba0252b6a", "filename": "src/test/ui/inline-const/const-expr-generic-err.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,15 @@\n+// build-fail\n+#![feature(inline_const)]\n+\n+fn foo<T>() {\n+    const { assert!(std::mem::size_of::<T>() == 0); } //~ ERROR E0080\n+}\n+\n+fn bar<const N: usize>() -> usize {\n+    const { N - 1 } //~ ERROR E0080\n+}\n+\n+fn main() {\n+    foo::<i32>();\n+    bar::<0>();\n+}"}, {"sha": "db0d85a2d4e74c5ca4d30ddd54c7f6b677dd4346", "filename": "src/test/ui/inline-const/const-expr-generic-err.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.stderr?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,29 @@\n+error[E0080]: evaluation of `foo::<i32>::{constant#0}` failed\n+  --> $DIR/const-expr-generic-err.rs:5:13\n+   |\n+LL |     const { assert!(std::mem::size_of::<T>() == 0); }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'assertion failed: std::mem::size_of::<T>() == 0', $DIR/const-expr-generic-err.rs:5:13\n+   |\n+   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+note: the above error was encountered while instantiating `fn foo::<i32>`\n+  --> $DIR/const-expr-generic-err.rs:13:5\n+   |\n+LL |     foo::<i32>();\n+   |     ^^^^^^^^^^^^\n+\n+error[E0080]: evaluation of `bar::<0_usize>::{constant#0}` failed\n+  --> $DIR/const-expr-generic-err.rs:9:13\n+   |\n+LL |     const { N - 1 }\n+   |             ^^^^^ attempt to compute `0_usize - 1_usize`, which would overflow\n+\n+note: the above error was encountered while instantiating `fn bar::<0_usize>`\n+  --> $DIR/const-expr-generic-err.rs:14:5\n+   |\n+LL |     bar::<0>();\n+   |     ^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "e097cbe9dd6d1d3187c09a80b1eb78271f3fa425", "filename": "src/test/ui/inline-const/const-expr-generic-err2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err2.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,10 @@\n+#![feature(inline_const)]\n+\n+fn foo<T>() {\n+    let _ = [0u8; const { std::mem::size_of::<T>() }];\n+    //~^ ERROR: constant expression depends on a generic parameter\n+}\n+\n+fn main() {\n+    foo::<i32>();\n+}"}, {"sha": "00b716cd25965da94bde26294fa0065da3605db8", "filename": "src/test/ui/inline-const/const-expr-generic-err2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err2.stderr?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,10 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/const-expr-generic-err2.rs:4:19\n+   |\n+LL |     let _ = [0u8; const { std::mem::size_of::<T>() }];\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error\n+"}, {"sha": "3207bfa0e89e6bfc5967ee068e8718d0af709898", "filename": "src/test/ui/inline-const/const-expr-generic.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+#![feature(inline_const)]\n+\n+fn foo<T>() -> usize {\n+    const { std::mem::size_of::<T>() }\n+}\n+\n+fn bar<const N: usize>() -> usize {\n+    const { N + 1 }\n+}\n+\n+fn main() {\n+    foo::<i32>();\n+    bar::<1>();\n+}"}, {"sha": "e1946467583e908c1ea23d85bdaacd88a9a909ac", "filename": "src/test/ui/inline-const/const-match-pat-generic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -1,6 +1,5 @@\n #![allow(incomplete_features)]\n #![feature(inline_const_pat)]\n-#![feature(generic_const_exprs)]\n \n // rust-lang/rust#82518: ICE with inline-const in match referencing const-generic parameter\n \n@@ -16,7 +15,7 @@ const fn f(x: usize) -> usize {\n     x + 1\n }\n \n-fn bar<const V: usize>() where [(); f(V)]: {\n+fn bar<const V: usize>() {\n     match 0 {\n         const { f(V) } => {},\n         //~^ ERROR constant pattern depends on a generic parameter"}, {"sha": "ade200d99ba39c46390e7b9009866ec396c2f683", "filename": "src/test/ui/inline-const/const-match-pat-generic.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -1,17 +1,17 @@\n error[E0158]: const parameters cannot be referenced in patterns\n-  --> $DIR/const-match-pat-generic.rs:9:9\n+  --> $DIR/const-match-pat-generic.rs:8:9\n    |\n LL |         const { V } => {},\n    |         ^^^^^^^^^^^\n \n error: constant pattern depends on a generic parameter\n-  --> $DIR/const-match-pat-generic.rs:21:9\n+  --> $DIR/const-match-pat-generic.rs:20:9\n    |\n LL |         const { f(V) } => {},\n    |         ^^^^^^^^^^^^^^\n \n error: constant pattern depends on a generic parameter\n-  --> $DIR/const-match-pat-generic.rs:21:9\n+  --> $DIR/const-match-pat-generic.rs:20:9\n    |\n LL |         const { f(V) } => {},\n    |         ^^^^^^^^^^^^^^"}, {"sha": "da68b996be999df60ade17d648d78960cd56c9ec", "filename": "src/test/ui/traits/suggest-fully-qualified-path-with-appropriate-params.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.rs?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,24 @@\n+struct Thing;\n+\n+trait Method<T> {\n+    fn method(&self) -> T;\n+    fn mut_method(&mut self) -> T;\n+}\n+\n+impl Method<i32> for Thing {\n+    fn method(&self) -> i32 { 0 }\n+    fn mut_method(&mut self) -> i32 { 0 }\n+}\n+\n+impl Method<u32> for Thing {\n+    fn method(&self) -> u32 { 0 }\n+    fn mut_method(&mut self) -> u32 { 0 }\n+}\n+\n+fn main() {\n+    let thing = Thing;\n+    thing.method();\n+    //~^ ERROR type annotations needed\n+    //~| ERROR type annotations needed\n+    thing.mut_method(); //~ ERROR type annotations needed\n+}"}, {"sha": "0c4962417e9bc152e2544744a8089f99de7ea149", "filename": "src/test/ui/traits/suggest-fully-qualified-path-with-appropriate-params.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.stderr?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -0,0 +1,61 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:20:11\n+   |\n+LL |     thing.method();\n+   |     ------^^^^^^--\n+   |     |     |\n+   |     |     cannot infer type for type parameter `T` declared on the trait `Method`\n+   |     this method call resolves to `T`\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:20:11\n+   |\n+LL |     thing.method();\n+   |     ------^^^^^^--\n+   |     |     |\n+   |     |     cannot infer type for type parameter `T` declared on the trait `Method`\n+   |     this method call resolves to `T`\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:8:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use the fully qualified path for the potential candidates\n+   |\n+LL |     <Thing as Method<i32>>::method(&thing);\n+   |     ++++++++++++++++++++++++++++++++     ~\n+LL |     <Thing as Method<u32>>::method(&thing);\n+   |     ++++++++++++++++++++++++++++++++     ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:23:11\n+   |\n+LL |     thing.mut_method();\n+   |     ------^^^^^^^^^^--\n+   |     |     |\n+   |     |     cannot infer type for type parameter `T` declared on the trait `Method`\n+   |     this method call resolves to `T`\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:8:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use the fully qualified path for the potential candidates\n+   |\n+LL |     <Thing as Method<i32>>::mut_method(&mut thing);\n+   |     +++++++++++++++++++++++++++++++++++++++      ~\n+LL |     <Thing as Method<u32>>::mut_method(&mut thing);\n+   |     +++++++++++++++++++++++++++++++++++++++      ~\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0282, E0283.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "6ae700753f06d672724d197018dd7fbecceb6ecf", "filename": "src/tools/clippy/tests/ui/indexing_slicing_index.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftools%2Fclippy%2Ftests%2Fui%2Findexing_slicing_index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77652b9ef3fc98e2df0e260efedb80aa68c08c06/src%2Ftools%2Fclippy%2Ftests%2Fui%2Findexing_slicing_index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Findexing_slicing_index.stderr?ref=77652b9ef3fc98e2df0e260efedb80aa68c08c06", "patch": "@@ -1,4 +1,4 @@\n-error[E0080]: evaluation of `main::{constant#3}::<&i32>` failed\n+error[E0080]: evaluation of `main::{constant#3}` failed\n   --> $DIR/indexing_slicing_index.rs:31:14\n    |\n LL |     const { &ARR[idx4()] }; // Ok, let rustc handle const contexts."}]}