{"sha": "e204aa281d093bd7de4214c45375949d197eb2ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMDRhYTI4MWQwOTNiZDdkZTQyMTRjNDUzNzU5NDlkMTk3ZWIyYWI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-01T05:08:53Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-01T05:08:53Z"}, "message": "Merge branch 'master' into register-snapshots", "tree": {"sha": "f3eafafb7ca6ea30aa36fba34b750a4501f07c8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3eafafb7ca6ea30aa36fba34b750a4501f07c8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e204aa281d093bd7de4214c45375949d197eb2ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e204aa281d093bd7de4214c45375949d197eb2ab", "html_url": "https://github.com/rust-lang/rust/commit/e204aa281d093bd7de4214c45375949d197eb2ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e204aa281d093bd7de4214c45375949d197eb2ab/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11ecec1b716aa430f80cc18cf850336a990c2850", "url": "https://api.github.com/repos/rust-lang/rust/commits/11ecec1b716aa430f80cc18cf850336a990c2850", "html_url": "https://github.com/rust-lang/rust/commit/11ecec1b716aa430f80cc18cf850336a990c2850"}, {"sha": "e8a5d81b24967abe53509e187cef60ce8d2fe5cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8a5d81b24967abe53509e187cef60ce8d2fe5cd", "html_url": "https://github.com/rust-lang/rust/commit/e8a5d81b24967abe53509e187cef60ce8d2fe5cd"}], "stats": {"total": 1562, "additions": 1018, "deletions": 544}, "files": [{"sha": "3bc5a031949371d0f0faf6b02ee74baa40747db3", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -30,7 +30,7 @@ This behavior can be disabled with the `no_core` crate attribute.\"\n \n export box, char, float, bessel, f32, f64, int, str, ptr;\n export uint, u8, u32, u64, vec, bool;\n-export either, option, result;\n+export either, option, result, iter;\n export ctypes, sys, unsafe, comm, task, logging;\n export extfmt;\n export math;\n@@ -64,7 +64,7 @@ mod either;\n mod option;\n mod result;\n mod tuple;\n-\n+mod iter;\n \n // Runtime and language-primitive support\n "}, {"sha": "7aa08a6980c3c646fbec1d55b75c3ed124f9d182", "filename": "src/libcore/iter.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -0,0 +1,171 @@\n+iface iterable<A> {\n+    fn iter(blk: fn(A));\n+}\n+\n+impl<A> of iterable<A> for fn@(fn(A)) {\n+    fn iter(blk: fn(A)) {\n+        self(blk);\n+    }\n+}\n+\n+// accomodate the fact that int/uint are passed by value by default:\n+impl of iterable<int> for fn@(fn(int)) {\n+    fn iter(blk: fn(&&int)) {\n+        self {|i| blk(i)}\n+    }\n+}\n+\n+impl of iterable<uint> for fn@(fn(uint)) {\n+    fn iter(blk: fn(&&uint)) {\n+        self {|i| blk(i)}\n+    }\n+}\n+\n+impl<A> of iterable<A> for [A] {\n+    fn iter(blk: fn(A)) {\n+        vec::iter(self, blk)\n+    }\n+}\n+\n+impl<A> of iterable<A> for option<A> {\n+    fn iter(blk: fn(A)) {\n+        option::may(self, blk)\n+    }\n+}\n+\n+fn enumerate<A,IA:iterable<A>>(self: IA, blk: fn(uint, A)) {\n+    let i = 0u;\n+    self.iter {|a|\n+        blk(i, a);\n+        i += 1u;\n+    }\n+}\n+\n+// Here: we have to use fn@ for predicates and map functions, because\n+// we will be binding them up into a closure.  Disappointing.  A true\n+// region type system might be able to do better than this.\n+\n+fn filter<A,IA:iterable<A>>(self: IA, prd: fn@(A) -> bool, blk: fn(A)) {\n+    self.iter {|a|\n+        if prd(a) { blk(a) }\n+    }\n+}\n+\n+fn map<A,B,IA:iterable<A>>(self: IA, cnv: fn@(A) -> B, blk: fn(B)) {\n+    self.iter {|a|\n+        let b = cnv(a);\n+        blk(b);\n+    }\n+}\n+\n+fn flat_map<A,B,IA:iterable<A>,IB:iterable<B>>(\n+    self: IA, cnv: fn@(A) -> IB, blk: fn(B)) {\n+    self.iter {|a|\n+        cnv(a).iter(blk)\n+    }\n+}\n+\n+fn foldl<A,B:copy,IA:iterable<A>>(self: IA, b0: B, blk: fn(B, A) -> B) -> B {\n+    let b = b0;\n+    self.iter {|a|\n+        b = blk(b, a);\n+    }\n+    ret b;\n+}\n+\n+fn to_list<A:copy,IA:iterable<A>>(self: IA) -> [A] {\n+    foldl::<A,[A],IA>(self, [], {|r, a| r + [a]})\n+}\n+\n+fn repeat(times: uint, blk: fn()) {\n+    let i = 0u;\n+    while i < times {\n+        blk();\n+        i += 1u;\n+    }\n+}\n+\n+\n+#[test]\n+fn test_enumerate() {\n+    enumerate([\"0\", \"1\", \"2\"]) {|i,j|\n+        assert #fmt[\"%u\",i] == j;\n+    }\n+}\n+\n+#[test]\n+fn test_map_and_to_list() {\n+    let a = bind vec::iter([0, 1, 2], _);\n+    let b = bind map(a, {|i| i*2}, _);\n+    let c = to_list(b);\n+    assert c == [0, 2, 4];\n+}\n+\n+#[test]\n+fn test_map_directly_on_vec() {\n+    let b = bind map([0, 1, 2], {|i| i*2}, _);\n+    let c = to_list(b);\n+    assert c == [0, 2, 4];\n+}\n+\n+#[test]\n+fn test_filter_on_int_range() {\n+    fn is_even(&&i: int) -> bool {\n+        ret (i % 2) == 0;\n+    }\n+\n+    let l = to_list(bind filter(bind int::range(0, 10, _), is_even, _));\n+    assert l == [0, 2, 4, 6, 8];\n+}\n+\n+#[test]\n+fn test_filter_on_uint_range() {\n+    fn is_even(&&i: uint) -> bool {\n+        ret (i % 2u) == 0u;\n+    }\n+\n+    let l = to_list(bind filter(bind uint::range(0u, 10u, _), is_even, _));\n+    assert l == [0u, 2u, 4u, 6u, 8u];\n+}\n+\n+#[test]\n+fn test_flat_map_with_option() {\n+    fn if_even(&&i: int) -> option<int> {\n+        if (i % 2) == 0 { some(i) }\n+        else { none }\n+    }\n+\n+    let a = bind vec::iter([0, 1, 2], _);\n+    let b = bind flat_map(a, if_even, _);\n+    let c = to_list(b);\n+    assert c == [0, 2];\n+}\n+\n+#[test]\n+fn test_flat_map_with_list() {\n+    fn repeat(&&i: int) -> [int] {\n+        let r = [];\n+        int::range(0, i) {|_j| r += [i]; }\n+        r\n+    }\n+\n+    let a = bind vec::iter([0, 1, 2, 3], _);\n+    let b = bind flat_map(a, repeat, _);\n+    let c = to_list(b);\n+    #debug[\"c = %?\", c];\n+    assert c == [1, 2, 2, 3, 3, 3];\n+}\n+\n+#[test]\n+fn test_repeat() {\n+    let c = [],\n+        i = 0u;\n+    repeat(5u) {||\n+        c += [(i * i)];\n+        i += 1u;\n+    };\n+    #debug[\"c = %?\", c];\n+    assert c == [0u, 1u, 4u, 9u, 16u];\n+}\n+\n+"}, {"sha": "818efe018fe09b6313a2ea6e443bfe4558bb80a6", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -11,10 +11,10 @@ import core::tuple;\n \n export crate_attrs, mod_attrs, fn_attrs, arg_attrs,\n        const_attrs, enum_attrs, variant_attrs, res_attrs,\n-       iface_attrs, method_attrs;\n+       iface_attrs, method_attrs, impl_attrs;\n export parse_crate, parse_mod, parse_fn, parse_const,\n        parse_enum, parse_variant, parse_res,\n-       parse_iface, parse_method;\n+       parse_iface, parse_method, parse_impl;\n \n type crate_attrs = {\n     name: option<str>\n@@ -63,6 +63,11 @@ type iface_attrs = {\n     desc: option<str>\n };\n \n+type impl_attrs = {\n+    brief: option<str>,\n+    desc: option<str>\n+};\n+\n type method_attrs = fn_attrs;\n \n #[cfg(test)]\n@@ -499,3 +504,7 @@ fn parse_iface(attrs: [ast::attribute]) -> iface_attrs {\n fn parse_method(attrs: [ast::attribute]) -> method_attrs {\n     parse_fn(attrs)\n }\n+\n+fn parse_impl(attrs: [ast::attribute]) -> impl_attrs {\n+    parse_basic(attrs)\n+}\n\\ No newline at end of file"}, {"sha": "4e0c85c8ac389872ec58e03118ee1cf332db216d", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 101, "deletions": 92, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -26,7 +26,8 @@ fn run(\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n         fold_res: fold_res,\n-        fold_iface: fold_iface\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n         with *fold::default_seq_fold(srv)\n     });\n     fold.fold_crate(fold, doc)\n@@ -55,11 +56,7 @@ fn fold_crate(\n \n #[test]\n fn should_replace_top_module_name_with_crate_name() {\n-    let source = \"#[link(name = \\\"bond\\\")];\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_crate(fold, doc);\n+    let doc = test::mk_doc(\"#[link(name = \\\"bond\\\")];\");\n     assert doc.topmod.name == \"bond\";\n }\n \n@@ -105,22 +102,14 @@ fn fold_mod(fold: fold::fold<astsrv::srv>, doc: doc::moddoc) -> doc::moddoc {\n \n #[test]\n fn fold_mod_should_extract_mod_attributes() {\n-    let source = \"#[doc = \\\"test\\\"] mod a { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_mod(fold, doc.topmod.mods()[0]);\n-    assert doc.desc == some(\"test\");\n+    let doc = test::mk_doc(\"#[doc = \\\"test\\\"] mod a { }\");\n+    assert doc.topmod.mods()[0].desc == some(\"test\");\n }\n \n #[test]\n fn fold_mod_should_extract_top_mod_attributes() {\n-    let source = \"#[doc = \\\"test\\\"];\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_mod(fold, doc.topmod);\n-    assert doc.desc == some(\"test\");\n+    let doc = test::mk_doc(\"#[doc = \\\"test\\\"];\");\n+    assert doc.topmod.desc == some(\"test\");\n }\n \n fn fold_fn(\n@@ -181,22 +170,14 @@ fn merge_ret_attrs(\n \n #[test]\n fn fold_fn_should_extract_fn_attributes() {\n-    let source = \"#[doc = \\\"test\\\"] fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_fn(fold, doc.topmod.fns()[0]);\n-    assert doc.desc == some(\"test\");\n+    let doc = test::mk_doc(\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n+    assert doc.topmod.fns()[0].desc == some(\"test\");\n }\n \n #[test]\n fn fold_fn_should_extract_arg_attributes() {\n-    let source = \"#[doc(args(a = \\\"b\\\"))] fn c(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_fn(fold, doc.topmod.fns()[0]);\n-    assert doc.args[0].desc == some(\"b\");\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn c(a: bool) { }\");\n+    assert doc.topmod.fns()[0].args[0].desc == some(\"b\");\n }\n \n #[test]\n@@ -223,12 +204,8 @@ fn fold_fn_should_preserve_sig() {\n \n #[test]\n fn fold_fn_should_extract_failure_conditions() {\n-    let source = \"#[doc(failure = \\\"what\\\")] fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_fn(fold, doc.topmod.fns()[0]);\n-    assert doc.failure == some(\"what\");\n+    let doc = test::mk_doc(\"#[doc(failure = \\\"what\\\")] fn a() { }\");\n+    assert doc.topmod.fns()[0].failure == some(\"what\");\n }\n \n fn fold_const(\n@@ -247,14 +224,10 @@ fn fold_const(\n \n #[test]\n fn fold_const_should_extract_docs() {\n-    let source = \"#[doc(brief = \\\"foo\\\", desc = \\\"bar\\\")]\\\n-                  const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_const(fold, doc.topmod.consts()[0]);\n-    assert doc.brief == some(\"foo\");\n-    assert doc.desc == some(\"bar\");\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"foo\\\", desc = \\\"bar\\\")]\\\n+                            const a: bool = true;\");\n+    assert doc.topmod.consts()[0].brief == some(\"foo\");\n+    assert doc.topmod.consts()[0].desc == some(\"bar\");\n }\n \n fn fold_enum(\n@@ -295,24 +268,16 @@ fn fold_enum(\n \n #[test]\n fn fold_enum_should_extract_docs() {\n-    let source = \"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n-                  enum a { v }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_enum(fold, doc.topmod.enums()[0]);\n-    assert doc.brief == some(\"a\");\n-    assert doc.desc == some(\"b\");\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n+                            enum a { v }\");\n+    assert doc.topmod.enums()[0].brief == some(\"a\");\n+    assert doc.topmod.enums()[0].desc == some(\"b\");\n }\n \n #[test]\n fn fold_enum_should_extract_variant_docs() {\n-    let source = \"enum a { #[doc = \\\"c\\\"] v }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_enum(fold, doc.topmod.enums()[0]);\n-    assert doc.variants[0].desc == some(\"c\");\n+    let doc = test::mk_doc(\"enum a { #[doc = \\\"c\\\"] v }\");\n+    assert doc.topmod.enums()[0].variants[0].desc == some(\"c\");\n }\n \n fn fold_res(\n@@ -345,26 +310,18 @@ fn fold_res(\n \n #[test]\n fn fold_res_should_extract_docs() {\n-    let source = \"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n-                  resource r(b: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_res(fold, doc.topmod.resources()[0]);\n-    assert doc.brief == some(\"a\");\n-    assert doc.desc == some(\"b\");\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n+                            resource r(b: bool) { }\");\n+    assert doc.topmod.resources()[0].brief == some(\"a\");\n+    assert doc.topmod.resources()[0].desc == some(\"b\");\n }\n \n #[test]\n fn fold_res_should_extract_arg_docs() {\n-    let source = \"#[doc(args(a = \\\"b\\\"))]\\\n-                  resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let fold = fold::default_seq_fold(srv);\n-    let doc = fold_res(fold, doc.topmod.resources()[0]);\n-    assert doc.args[0].name == \"a\";\n-    assert doc.args[0].desc == some(\"b\");\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))]\\\n+                            resource r(a: bool) { }\");\n+    assert doc.topmod.resources()[0].args[0].name == \"a\";\n+    assert doc.topmod.resources()[0].args[0].desc == some(\"b\");\n }\n \n fn fold_iface(\n@@ -398,9 +355,14 @@ fn merge_method_attrs(\n                 (method.ident, attr_parser::parse_method(method.attrs))\n             }\n           }\n-          _ {\n-            fail \"Undocumented invariant in merge_method_attrs\";\n+          ast_map::node_item(@{\n+            node: ast::item_impl(_, _, _, methods), _\n+          }) {\n+            vec::map(methods) {|method|\n+                (method.ident, attr_parser::parse_method(method.attrs))\n+            }\n           }\n+          _ { fail \"unexpected item\" }\n         }\n     };\n \n@@ -421,30 +383,77 @@ fn merge_method_attrs(\n \n #[test]\n fn should_extract_iface_docs() {\n-    let source = \"#[doc = \\\"whatever\\\"] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"whatever\\\"] iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].desc == some(\"whatever\");\n }\n \n #[test]\n fn should_extract_iface_method_docs() {\n-    let source = \"iface i {\\\n-                  #[doc(\\\n-                  brief = \\\"brief\\\",\\\n-                  desc = \\\"desc\\\",\\\n-                  args(a = \\\"a\\\"),\\\n-                  return = \\\"return\\\",\\\n-                  failure = \\\"failure\\\")]\\\n-                  fn f(a: bool) -> bool;\\\n-                  }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i {\\\n+         #[doc(\\\n+         brief = \\\"brief\\\",\\\n+         desc = \\\"desc\\\",\\\n+         args(a = \\\"a\\\"),\\\n+         return = \\\"return\\\",\\\n+         failure = \\\"failure\\\")]\\\n+         fn f(a: bool) -> bool;\\\n+         }\");\n     assert doc.topmod.ifaces()[0].methods[0].brief == some(\"brief\");\n     assert doc.topmod.ifaces()[0].methods[0].desc == some(\"desc\");\n     assert doc.topmod.ifaces()[0].methods[0].args[0].desc == some(\"a\");\n     assert doc.topmod.ifaces()[0].methods[0].return.desc == some(\"return\");\n     assert doc.topmod.ifaces()[0].methods[0].failure == some(\"failure\");\n }\n+\n+\n+fn fold_impl(\n+    fold: fold::fold<astsrv::srv>,\n+    doc: doc::impldoc\n+) -> doc::impldoc {\n+    let srv = fold.ctxt;\n+    let doc = fold::default_seq_fold_impl(fold, doc);\n+    let attrs = parse_item_attrs(srv, doc.id, attr_parser::parse_impl);\n+\n+    {\n+        brief: attrs.brief,\n+        desc: attrs.desc,\n+        methods: merge_method_attrs(srv, doc.id, doc.methods)\n+        with doc\n+    }\n+}\n+\n+#[test]\n+fn should_extract_impl_docs() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"whatever\\\"] impl i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].desc == some(\"whatever\");\n+}\n+\n+#[test]\n+fn should_extract_impl_method_docs() {\n+    let doc = test::mk_doc(\n+        \"impl i for int {\\\n+         #[doc(\\\n+         brief = \\\"brief\\\",\\\n+         desc = \\\"desc\\\",\\\n+         args(a = \\\"a\\\"),\\\n+         return = \\\"return\\\",\\\n+         failure = \\\"failure\\\")]\\\n+         fn f(a: bool) -> bool { }\\\n+         }\");\n+    assert doc.topmod.impls()[0].methods[0].brief == some(\"brief\");\n+    assert doc.topmod.impls()[0].methods[0].desc == some(\"desc\");\n+    assert doc.topmod.impls()[0].methods[0].args[0].desc == some(\"a\");\n+    assert doc.topmod.impls()[0].methods[0].return.desc == some(\"return\");\n+    assert doc.topmod.impls()[0].methods[0].failure == some(\"failure\");\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        run(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "4feae4106a5f9a2902fdcb6effb54a5ae2ce3617", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -167,4 +167,15 @@ iface the_shunned_house {\n         failure = \"Will fail if bodies are removed from premises\"\n     )]\n     fn construct() -> bool;\n+}\n+\n+#[doc = \"Whatever\"]\n+impl of the_shunned_house for omnomnomy {\n+    #[doc(args(_unkempt_yard = \"Whatever\"))]\n+    fn dingy_house(_unkempt_yard: int) {\n+    }\n+\n+    fn construct() -> bool {\n+        fail;\n+    }\n }\n\\ No newline at end of file"}, {"sha": "317c1f70a43738aa8c7ed80023e884ff0a03e1d1", "filename": "src/rustdoc/desc_pass.rs", "status": "modified", "additions": 111, "deletions": 83, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fdesc_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fdesc_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_pass.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -21,7 +21,8 @@ fn run(\n         fold_fn: fold_fn,\n         fold_enum: fold_enum,\n         fold_res: fold_res,\n-        fold_iface: fold_iface\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n         with *fold::default_seq_fold(op)\n     });\n     fold.fold_crate(fold, doc)\n@@ -104,154 +105,181 @@ fn fold_iface(fold: fold::fold<op>, doc: doc::ifacedoc) -> doc::ifacedoc {\n     {\n         brief: maybe_apply_op(fold.ctxt, doc.brief),\n         desc: maybe_apply_op(fold.ctxt, doc.desc),\n-        methods: vec::map(doc.methods) {|doc|\n-            {\n-                brief: maybe_apply_op(fold.ctxt, doc.brief),\n-                desc: maybe_apply_op(fold.ctxt, doc.desc),\n-                args: vec::map(doc.args) {|doc|\n-                    {\n-                        desc: maybe_apply_op(fold.ctxt, doc.desc)\n-                        with doc\n-                    }\n-                },\n-                return: {\n-                    desc: maybe_apply_op(fold.ctxt, doc.return.desc)\n-                    with doc.return\n-                },\n-                failure: maybe_apply_op(fold.ctxt, doc.failure)\n-                with doc\n-            }\n+        methods: apply_to_methods(fold.ctxt, doc.methods)\n+        with doc\n+    }\n+}\n+\n+fn apply_to_methods(op: op, docs: [doc::methoddoc]) -> [doc::methoddoc] {\n+    vec::map(docs) {|doc|\n+        {\n+            brief: maybe_apply_op(op, doc.brief),\n+            desc: maybe_apply_op(op, doc.desc),\n+            args: vec::map(doc.args) {|doc|\n+                {\n+                    desc: maybe_apply_op(op, doc.desc)\n+                    with doc\n+                }\n+            },\n+            return: {\n+                desc: maybe_apply_op(op, doc.return.desc)\n+                with doc.return\n+            },\n+            failure: maybe_apply_op(op, doc.failure)\n+            with doc\n         }\n+    }\n+}\n+\n+fn fold_impl(fold: fold::fold<op>, doc: doc::impldoc) -> doc::impldoc {\n+    {\n+        brief: maybe_apply_op(fold.ctxt, doc.brief),\n+        desc: maybe_apply_op(fold.ctxt, doc.desc),\n+        methods: apply_to_methods(fold.ctxt, doc.methods)\n         with doc\n     }\n }\n \n #[test]\n fn should_execute_op_on_enum_brief() {\n-    let source = \"#[doc(brief = \\\" a \\\")] enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\" a \\\")] enum a { b }\");\n     assert doc.topmod.enums()[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_enum_desc() {\n-    let source = \"#[doc(desc = \\\" a \\\")] enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\" a \\\")] enum a { b }\");\n     assert doc.topmod.enums()[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_variant_desc() {\n-    let source = \"enum a { #[doc = \\\" a \\\"] b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"enum a { #[doc = \\\" a \\\"] b }\");\n     assert doc.topmod.enums()[0].variants[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_brief() {\n-    let source = \"#[doc(brief = \\\" a \\\")] resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\" a \\\")] resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_desc() {\n-    let source = \"#[doc(desc = \\\" a \\\")] resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\" a \\\")] resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_resource_args() {\n-    let source = \"#[doc(args(a = \\\" a \\\"))] resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc(args(a = \\\" a \\\"))] resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_brief() {\n-    let source = \"#[doc(brief = \\\" a \\\")] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc(brief = \\\" a \\\")] iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_desc() {\n-    let source = \"#[doc(desc = \\\" a \\\")] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc(desc = \\\" a \\\")] iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_brief() {\n-    let source = \"iface i { #[doc(brief = \\\" a \\\")] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i { #[doc(brief = \\\" a \\\")] fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].brief == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_desc() {\n-    let source = \"iface i { #[doc(desc = \\\" a \\\")] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i { #[doc(desc = \\\" a \\\")] fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_args() {\n-    let source = \"iface i { #[doc(args(a = \\\" a \\\"))] fn a(a: bool); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i { #[doc(args(a = \\\" a \\\"))] fn a(a: bool); }\");\n     assert doc.topmod.ifaces()[0].methods[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_return() {\n-    let source = \"iface i { #[doc(return = \\\" a \\\")] fn a() -> int; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\n+        \"iface i { #[doc(return = \\\" a \\\")] fn a() -> int; }\");\n     assert doc.topmod.ifaces()[0].methods[0].return.desc == some(\"a\");\n }\n \n #[test]\n fn should_execute_op_on_iface_method_failure_condition() {\n-    let source = \"iface i { #[doc(failure = \\\" a \\\")] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass(str::trim)(srv, doc);\n+    let doc = test::mk_doc(\"iface i { #[doc(failure = \\\" a \\\")] fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].failure == some(\"a\");\n }\n+\n+#[test]\n+fn should_execute_op_on_impl_brief() {\n+    let doc = test::mk_doc(\n+        \"#[doc(brief = \\\" a \\\")] impl i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].brief == some(\"a\");\n+}\n+\n+#[test]\n+fn should_execute_op_on_impl_desc() {\n+    let doc = test::mk_doc(\n+        \"#[doc(desc = \\\" a \\\")] impl i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].desc == some(\"a\");\n+}\n+\n+#[test]\n+fn should_execute_op_on_impl_method_brief() {\n+    let doc = test::mk_doc(\n+        \"impl i for int { #[doc(brief = \\\" a \\\")] fn a() { } }\");\n+    assert doc.topmod.impls()[0].methods[0].brief == some(\"a\");\n+}\n+\n+#[test]\n+fn should_execute_op_on_impl_method_desc() {\n+    let doc = test::mk_doc(\n+        \"impl i for int { #[doc(desc = \\\" a \\\")] fn a() { } }\");\n+    assert doc.topmod.impls()[0].methods[0].desc == some(\"a\");\n+}\n+\n+#[test]\n+fn should_execute_op_on_impl_method_args() {\n+    let doc = test::mk_doc(\n+        \"impl i for int { #[doc(args(a = \\\" a \\\"))] fn a(a: bool) { } }\");\n+    assert doc.topmod.impls()[0].methods[0].args[0].desc == some(\"a\");\n+}\n+\n+#[test]\n+fn should_execute_op_on_impl_method_return() {\n+    let doc = test::mk_doc(\n+        \"impl i for int { #[doc(return = \\\" a \\\")] fn a() -> int { fail } }\");\n+    assert doc.topmod.impls()[0].methods[0].return.desc == some(\"a\");\n+}\n+\n+#[test]\n+fn should_execute_op_on_impl_method_failure_condition() {\n+    let doc = test::mk_doc(\n+        \"impl i for int { #[doc(failure = \\\" a \\\")] fn a() { } }\");\n+    assert doc.topmod.impls()[0].methods[0].failure == some(\"a\");\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        mk_pass(str::trim)(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "315138db3d325c74ac7417b2b414733d0b62fc7f", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 56, "deletions": 36, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -23,7 +23,8 @@ fn run(\n         fold_fn: fold_fn,\n         fold_enum: fold_enum,\n         fold_res: fold_res,\n-        fold_iface: fold_iface\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n         with *fold::default_seq_fold(())\n     });\n     fold.fold_crate(fold, doc)\n@@ -104,83 +105,102 @@ fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n     }\n }\n \n+fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n+    let doc =fold::default_seq_fold_impl(fold, doc);\n+    let (brief, desc) = modify(doc.brief, doc.desc);\n+\n+    {\n+        brief: brief,\n+        desc: desc,\n+        methods: vec::map(doc.methods) {|doc|\n+            let (brief, desc) = modify(doc.brief, doc.desc);\n+\n+            {\n+                brief: brief,\n+                desc: desc\n+                with doc\n+            }\n+        }\n+        with doc\n+    }\n+}\n+\n #[test]\n fn should_promote_mod_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] mod m { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] mod m { }\");\n     assert doc.topmod.mods()[0].brief == some(\"desc\");\n     assert doc.topmod.mods()[0].desc == none;\n }\n \n #[test]\n fn should_promote_const_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] const a: bool = true;\");\n     assert doc.topmod.consts()[0].brief == some(\"desc\");\n     assert doc.topmod.consts()[0].desc == none;\n }\n \n #[test]\n fn should_promote_fn_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] fn a() { }\");\n     assert doc.topmod.fns()[0].brief == some(\"desc\");\n     assert doc.topmod.fns()[0].desc == none;\n }\n \n #[test]\n fn should_promote_enum_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] enum a { b }\");\n     assert doc.topmod.enums()[0].brief == some(\"desc\");\n     assert doc.topmod.enums()[0].desc == none;\n }\n \n #[test]\n fn should_promote_resource_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"#[doc(desc = \\\"desc\\\")] resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].brief == some(\"desc\");\n     assert doc.topmod.resources()[0].desc == none;\n }\n \n #[test]\n fn should_promote_iface_desc() {\n-    let source = \"#[doc(desc = \\\"desc\\\")] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(desc = \\\"desc\\\")] iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].brief == some(\"desc\");\n     assert doc.topmod.ifaces()[0].desc == none;\n }\n \n #[test]\n fn should_promote_iface_method_desc() {\n-    let source = \"iface i { #[doc(desc = \\\"desc\\\")] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { #[doc(desc = \\\"desc\\\")] fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].brief == some(\"desc\");\n     assert doc.topmod.ifaces()[0].methods[0].desc == none;\n }\n \n+#[test]\n+fn should_promote_impl_desc() {\n+    let doc = test::mk_doc(\n+        \"#[doc(desc = \\\"desc\\\")] impl i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].brief == some(\"desc\");\n+    assert doc.topmod.impls()[0].desc == none;\n+}\n+\n+#[test]\n+fn should_promote_impl_method_desc() {\n+    let doc = test::mk_doc(\n+        \"impl i for int { #[doc(desc = \\\"desc\\\")] fn a() { } }\");\n+    assert doc.topmod.impls()[0].methods[0].brief == some(\"desc\");\n+    assert doc.topmod.impls()[0].methods[0].desc == none;\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        run(srv, doc)\n+    }\n+}\n+\n fn modify(\n     brief: option<str>,\n     desc: option<str>"}, {"sha": "9370ffb6c5148de8718c792fa990967103db576f", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -12,7 +12,8 @@ enum itemtag {\n     fntag(fndoc),\n     enumtag(enumdoc),\n     restag(resdoc),\n-    ifacetag(ifacedoc)\n+    ifacetag(ifacedoc),\n+    impltag(impldoc)\n }\n \n type moddoc = {\n@@ -96,6 +97,16 @@ type methoddoc = {\n     sig: option<str>\n };\n \n+type impldoc = {\n+    id: ast_id,\n+    name: str,\n+    brief: option<str>,\n+    desc: option<str>,\n+    iface_ty: option<str>,\n+    self_ty: option<str>,\n+    methods: [methoddoc]\n+};\n+\n #[doc = \"Some helper methods on moddoc, mostly for testing\"]\n impl util for moddoc {\n \n@@ -152,6 +163,15 @@ impl util for moddoc {\n             }\n         }\n     }\n+\n+    fn impls() -> [impldoc] {\n+        vec::filter_map(*self.items) {|itemtag|\n+            alt itemtag {\n+              impltag(impldoc) { some(impldoc) }\n+              _ { none }\n+            }\n+        }\n+    }\n }\n \n #[doc = \"Helper methods on itemtag\"]\n@@ -164,6 +184,7 @@ impl util for itemtag {\n           doc::enumtag({name, _}) { name }\n           doc::restag({name, _}) { name }\n           doc::ifacetag({name, _}) { name }\n+          doc::impltag({name, _}) { name }\n         }\n     }\n }"}, {"sha": "a36536fd3e8d65b381e903faa9e81a6e634f3d9e", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 79, "deletions": 44, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -75,6 +75,11 @@ fn moddoc_from_mod(\n                     ifacedoc_from_iface(methods, item.ident, item.id)\n                 ))\n               }\n+              ast::item_impl(_, _, _, methods) {\n+                some(doc::impltag(\n+                    impldoc_from_impl(methods, item.ident, item.id)\n+                ))\n+              }\n               _ {\n                 none\n               }\n@@ -140,9 +145,7 @@ fn constdoc_from_const(\n \n #[test]\n fn should_extract_const_name_and_id() {\n-    let source = \"const a: int = 0;\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"const a: int = 0;\");\n     assert doc.topmod.consts()[0].id != 0;\n     assert doc.topmod.consts()[0].name == \"a\";\n }\n@@ -177,18 +180,14 @@ fn variantdoc_from_variant(variant: ast::variant) -> doc::variantdoc {\n \n #[test]\n fn should_extract_enums() {\n-    let source = \"enum e { v }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"enum e { v }\");\n     assert doc.topmod.enums()[0].id != 0;\n     assert doc.topmod.enums()[0].name == \"e\";\n }\n \n #[test]\n fn should_extract_enum_variants() {\n-    let source = \"enum e { v }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"enum e { v }\");\n     assert doc.topmod.enums()[0].variants[0].name == \"v\";\n }\n \n@@ -209,18 +208,14 @@ fn resdoc_from_resource(\n \n #[test]\n fn should_extract_resources() {\n-    let source = \"resource r(b: bool) { }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n     assert doc.topmod.resources()[0].id != 0;\n     assert doc.topmod.resources()[0].name == \"r\";\n }\n \n #[test]\n fn should_extract_resource_args() {\n-    let source = \"resource r(b: bool) { }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n     assert doc.topmod.resources()[0].args[0].name == \"b\";\n }\n \n@@ -253,82 +248,122 @@ fn ifacedoc_from_iface(\n \n #[test]\n fn should_extract_ifaces() {\n-    let source = \"iface i { fn f(); }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"iface i { fn f(); }\");\n     assert doc.topmod.ifaces()[0].name == \"i\";\n }\n \n #[test]\n fn should_extract_iface_methods() {\n-    let source = \"iface i { fn f(); }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"iface i { fn f(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].name == \"f\";\n }\n \n #[test]\n fn should_extract_iface_method_args() {\n-    let source = \"iface i { fn f(a: bool); }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n+    let doc = test::mk_doc(\"iface i { fn f(a: bool); }\");\n     assert doc.topmod.ifaces()[0].methods[0].args[0].name == \"a\";\n }\n \n+fn impldoc_from_impl(\n+    methods: [@ast::method],\n+    name: str,\n+    id: ast::node_id\n+) -> doc::impldoc {\n+    {\n+        id: id,\n+        name: name,\n+        brief: none,\n+        desc: none,\n+        iface_ty: none,\n+        self_ty: none,\n+        methods: vec::map(methods) {|method|\n+            {\n+                name: method.ident,\n+                brief: none,\n+                desc: none,\n+                args: argdocs_from_args(method.decl.inputs),\n+                return: {\n+                    desc: none,\n+                    ty: none\n+                },\n+                failure: none,\n+                sig: none\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn should_extract_impls_with_names() {\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].name == \"i\";\n+}\n+\n+#[test]\n+fn should_extract_impls_without_names() {\n+    let doc = test::mk_doc(\"impl of i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].name == \"i\";\n+}\n+\n+#[test]\n+fn should_extract_impl_methods() {\n+    let doc = test::mk_doc(\"impl i for int { fn f() { } }\");\n+    assert doc.topmod.impls()[0].methods[0].name == \"f\";\n+}\n+\n+#[test]\n+fn should_extract_impl_method_args() {\n+    let doc = test::mk_doc(\"impl i for int { fn f(a: bool) { } }\");\n+    assert doc.topmod.impls()[0].methods[0].args[0].name == \"a\";\n+}\n+\n #[cfg(test)]\n-mod tests {\n+mod test {\n+\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let ast = parse::from_str(source);\n+        extract(ast, \"\")\n+    }\n \n     #[test]\n     fn extract_empty_crate() {\n-        let source = \"\"; // empty crate\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"\");\n         assert vec::is_empty(doc.topmod.mods());\n         assert vec::is_empty(doc.topmod.fns());\n     }\n \n     #[test]\n     fn extract_mods() {\n-        let source = \"mod a { mod b { } mod c { } }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"mod a { mod b { } mod c { } }\");\n         assert doc.topmod.mods()[0].name == \"a\";\n         assert doc.topmod.mods()[0].mods()[0].name == \"b\";\n         assert doc.topmod.mods()[0].mods()[1].name == \"c\";\n     }\n \n     #[test]\n     fn extract_mods_deep() {\n-        let source = \"mod a { mod b { mod c { } } }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"mod a { mod b { mod c { } } }\");\n         assert doc.topmod.mods()[0].mods()[0].mods()[0].name == \"c\";\n     }\n \n     #[test]\n     fn extract_should_set_mod_ast_id() {\n-        let source = \"mod a { }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"mod a { }\");\n         assert doc.topmod.mods()[0].id != 0;\n     }\n \n     #[test]\n     fn extract_fns() {\n-        let source =\n+        let doc = mk_doc(\n             \"fn a() { } \\\n-             mod b { fn c() { } }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+             mod b { fn c() { } }\");\n         assert doc.topmod.fns()[0].name == \"a\";\n         assert doc.topmod.mods()[0].fns()[0].name == \"c\";\n     }\n \n     #[test]\n     fn extract_should_set_fn_ast_id() {\n-        let source = \"fn a() { }\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, \"\");\n+        let doc = mk_doc(\"fn a() { }\");\n         assert doc.topmod.fns()[0].id != 0;\n     }\n "}, {"sha": "ba5283bd6ff4134312327c976e4bd1b209f16164", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -11,6 +11,7 @@ export default_seq_fold_const;\n export default_seq_fold_enum;\n export default_seq_fold_res;\n export default_seq_fold_iface;\n+export default_seq_fold_impl;\n \n enum fold<T> = t<T>;\n \n@@ -21,6 +22,7 @@ type fold_const<T> = fn~(fold: fold<T>, doc: doc::constdoc) -> doc::constdoc;\n type fold_enum<T> = fn~(fold: fold<T>, doc: doc::enumdoc) -> doc::enumdoc;\n type fold_res<T> = fn~(fold: fold<T>, doc: doc::resdoc) -> doc::resdoc;\n type fold_iface<T> = fn~(fold: fold<T>, doc: doc::ifacedoc) -> doc::ifacedoc;\n+type fold_impl<T> = fn~(fold: fold<T>, doc: doc::impldoc) -> doc::impldoc;\n \n type t<T> = {\n     ctxt: T,\n@@ -30,7 +32,8 @@ type t<T> = {\n     fold_const: fold_const<T>,\n     fold_enum: fold_enum<T>,\n     fold_res: fold_res<T>,\n-    fold_iface: fold_iface<T>\n+    fold_iface: fold_iface<T>,\n+    fold_impl: fold_impl<T>\n };\n \n \n@@ -44,7 +47,8 @@ fn mk_fold<T:copy>(\n     fold_const: fold_const<T>,\n     fold_enum: fold_enum<T>,\n     fold_res: fold_res<T>,\n-    fold_iface: fold_iface<T>\n+    fold_iface: fold_iface<T>,\n+    fold_impl: fold_impl<T>\n ) -> fold<T> {\n     fold({\n         ctxt: ctxt,\n@@ -54,7 +58,8 @@ fn mk_fold<T:copy>(\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n         fold_res: fold_res,\n-        fold_iface: fold_iface\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n     })\n }\n \n@@ -67,7 +72,8 @@ fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n         {|f, d| default_seq_fold_const(f, d)},\n         {|f, d| default_seq_fold_enum(f, d)},\n         {|f, d| default_seq_fold_res(f, d)},\n-        {|f, d| default_seq_fold_iface(f, d)}\n+        {|f, d| default_seq_fold_iface(f, d)},\n+        {|f, d| default_seq_fold_impl(f, d)}\n     )\n }\n \n@@ -105,6 +111,9 @@ fn default_seq_fold_mod<T>(\n               doc::ifacetag(ifacedoc) {\n                 doc::ifacetag(fold.fold_iface(fold, ifacedoc))\n               }\n+              doc::impltag(impldoc) {\n+                doc::impltag(fold.fold_impl(fold, impldoc))\n+              }\n             }\n         }\n         with doc\n@@ -146,6 +155,13 @@ fn default_seq_fold_iface<T>(\n     doc\n }\n \n+fn default_seq_fold_impl<T>(\n+    _fold: fold<T>,\n+    doc: doc::impldoc\n+) -> doc::impldoc {\n+    doc\n+}\n+\n #[test]\n fn default_fold_should_produce_same_doc() {\n     let source = \"mod a { fn b() { } mod c { fn d() { } } }\";"}, {"sha": "4aab41e38ccc385aa3031628443bfc47f34234fb", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -138,6 +138,7 @@ fn write_mod_contents(\n           doc::enumtag(enumdoc) { write_enum(ctxt, enumdoc) }\n           doc::restag(resdoc) { write_res(ctxt, resdoc) }\n           doc::ifacetag(ifacedoc) { write_iface(ctxt, ifacedoc) }\n+          doc::impltag(impldoc) { write_impl(ctxt, impldoc) }\n         }\n     }\n }\n@@ -647,6 +648,101 @@ fn should_write_iface_method_failure_conditions() {\n     assert str::contains(markdown, \"Failure conditions: nuked\");\n }\n \n+fn write_impl(ctxt: ctxt, doc: doc::impldoc) {\n+    assert option::is_some(doc.self_ty);\n+    let self_ty = option::get(doc.self_ty);\n+    alt doc.iface_ty {\n+      some(iface_ty) {\n+        write_header(ctxt, h2,\n+                     #fmt(\"Implementation `%s` of `%s` for `%s`\",\n+                          doc.name, iface_ty, self_ty));\n+      }\n+      none {\n+        write_header(ctxt, h2,\n+                     #fmt(\"Implementation `%s` for `%s`\",\n+                          doc.name, self_ty));\n+      }\n+    }\n+    write_brief(ctxt, doc.brief);\n+    write_desc(ctxt, doc.desc);\n+    write_methods(ctxt, doc.methods);\n+}\n+\n+#[test]\n+fn should_write_impl_header() {\n+    let markdown = test::render(\"impl i for int { fn a() { } }\");\n+    assert str::contains(markdown, \"## Implementation `i` for `int`\");\n+}\n+\n+#[test]\n+fn should_write_impl_header_with_iface() {\n+    let markdown = test::render(\"impl i of j for int { fn a() { } }\");\n+    assert str::contains(markdown, \"## Implementation `i` of `j` for `int`\");\n+}\n+\n+#[test]\n+fn should_write_impl_brief() {\n+    let markdown = test::render(\n+        \"#[doc(brief = \\\"brief\\\")] impl i for int { fn a() { } }\");\n+    assert str::contains(markdown, \"brief\");\n+}\n+\n+#[test]\n+fn should_write_impl_desc() {\n+    let markdown = test::render(\n+        \"#[doc(desc = \\\"desc\\\")] impl i for int { fn a() { } }\");\n+    assert str::contains(markdown, \"desc\");\n+}\n+\n+#[test]\n+fn should_write_impl_method_header() {\n+    let markdown = test::render(\n+        \"impl i for int { fn a() { } }\");\n+    assert str::contains(markdown, \"### Method `a`\");\n+}\n+\n+#[test]\n+fn should_write_impl_method_signature() {\n+    let markdown = test::render(\n+        \"impl i for int { fn a() { } }\");\n+    assert str::contains(markdown, \"\\n    fn a()\");\n+}\n+\n+#[test]\n+fn should_write_impl_method_argument_header() {\n+    let markdown = test::render(\n+        \"impl a for int { fn a(b: int) { } }\");\n+    assert str::contains(markdown, \"\\n\\nArguments:\\n\\n\");\n+}\n+\n+#[test]\n+fn should_write_impl_method_arguments() {\n+    let markdown = test::render(\n+        \"impl a for int { fn a(b: int) { } }\");\n+    assert str::contains(markdown, \"* `b`: `int`\\n\");\n+}\n+\n+#[test]\n+fn should_not_write_impl_method_arguments_if_none() {\n+    let markdown = test::render(\n+        \"impl a for int { fn a() { } }\");\n+    assert !str::contains(markdown, \"Arguments\");\n+}\n+\n+#[test]\n+fn should_write_impl_method_return_info() {\n+    let markdown = test::render(\n+        \"impl a for int { fn a() -> int { } }\");\n+    assert str::contains(markdown, \"Returns `int`\");\n+}\n+\n+#[test]\n+fn should_write_impl_method_failure_conditions() {\n+    let markdown = test::render(\n+        \"impl a for int { #[doc(failure = \\\"nuked\\\")] fn a() { } }\");\n+    assert str::contains(markdown, \"Failure conditions: nuked\");\n+}\n+\n #[cfg(test)]\n mod test {\n     fn render(source: str) -> str {"}, {"sha": "5b197b9859a9566fd47ede9a81992ea55fdd3d75", "filename": "src/rustdoc/prune_undoc_pass.rs", "status": "modified", "additions": 121, "deletions": 117, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fprune_undoc_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fprune_undoc_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_pass.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -23,7 +23,8 @@ fn run(\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n         fold_res: fold_res,\n-        fold_iface: fold_iface\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n         with *fold::default_seq_fold(ctxt)\n     });\n     fold.fold_crate(fold, doc)\n@@ -84,6 +85,14 @@ fn fold_mod(\n                     none\n                 }\n               }\n+              doc::impltag(impldoc) {\n+                let doc = fold.fold_impl(fold, impldoc);\n+                if fold.ctxt.have_docs {\n+                    some(doc::impltag(doc))\n+                } else {\n+                    none\n+                }\n+              }\n               _ { some(itemtag) }\n             }\n         }\n@@ -138,21 +147,13 @@ fn prune_return(doc: doc::retdoc) -> doc::retdoc {\n \n #[test]\n fn should_elide_undocumented_arguments() {\n-    let source = \"#[doc = \\\"hey\\\"] fn a(b: int) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] fn a(b: int) { }\");\n     assert vec::is_empty(doc.topmod.fns()[0].args);\n }\n \n #[test]\n fn should_not_elide_fns_with_documented_arguments() {\n-    let source = \"#[doc(args(a = \\\"b\\\"))] fn a(a: int) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn a(a: int) { }\");\n     assert vec::is_not_empty(doc.topmod.fns());\n }\n \n@@ -169,49 +170,31 @@ fn should_elide_undocumented_return_values() {\n \n #[test]\n fn should_not_elide_fns_with_documented_failure_conditions() {\n-    let source = \"#[doc(failure = \\\"yup\\\")] fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(failure = \\\"yup\\\")] fn a() { }\");\n     assert vec::is_not_empty(doc.topmod.fns());\n }\n \n #[test]\n fn should_elide_undocumented_mods() {\n-    let source = \"mod a { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { }\");\n     assert vec::is_empty(doc.topmod.mods());\n }\n \n #[test]\n fn should_not_elide_undocument_mods_with_documented_mods() {\n-    let source = \"mod a { #[doc = \\\"b\\\"] mod b { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] mod b { } }\");\n     assert vec::is_not_empty(doc.topmod.mods());\n }\n \n #[test]\n fn should_not_elide_undocument_mods_with_documented_fns() {\n-    let source = \"mod a { #[doc = \\\"b\\\"] fn b() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] fn b() { } }\");\n     assert vec::is_not_empty(doc.topmod.mods());\n }\n \n #[test]\n fn should_elide_undocumented_fns() {\n-    let source = \"fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a() { }\");\n     assert vec::is_empty(doc.topmod.fns());\n }\n \n@@ -228,10 +211,7 @@ fn fold_const(\n \n #[test]\n fn should_elide_undocumented_consts() {\n-    let source = \"const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"const a: bool = true;\");\n     assert vec::is_empty(doc.topmod.consts());\n }\n \n@@ -255,31 +235,19 @@ fn fold_enum(fold: fold::fold<ctxt>, doc: doc::enumdoc) -> doc::enumdoc {\n \n #[test]\n fn should_elide_undocumented_enums() {\n-    let source = \"enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"enum a { b }\");\n     assert vec::is_empty(doc.topmod.enums());\n }\n \n #[test]\n fn should_elide_undocumented_variants() {\n-    let source = \"#[doc = \\\"a\\\"] enum a { b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"a\\\"] enum a { b }\");\n     assert vec::is_empty(doc.topmod.enums()[0].variants);\n }\n \n #[test]\n fn should_not_elide_enums_with_documented_variants() {\n-    let source = \"enum a { #[doc = \\\"a\\\"] b }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"enum a { #[doc = \\\"a\\\"] b }\");\n     assert vec::is_not_empty(doc.topmod.enums());\n }\n \n@@ -303,32 +271,21 @@ fn fold_res(fold: fold::fold<ctxt>, doc: doc::resdoc) -> doc::resdoc {\n \n #[test]\n fn should_elide_undocumented_resources() {\n-    let source = \"resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"resource r(a: bool) { }\");\n     assert vec::is_empty(doc.topmod.resources());\n }\n \n #[test]\n fn should_elide_undocumented_resource_args() {\n-    let source = \"#[doc = \\\"drunk\\\"]\\\n-                  resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"drunk\\\"]\\\n+                            resource r(a: bool) { }\");\n     assert vec::is_empty(doc.topmod.resources()[0].args);\n }\n \n #[test]\n fn should_not_elide_resources_with_documented_args() {\n-    let source = \"#[doc(args(a = \\\"drunk\\\"))]\\\n-                  resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"drunk\\\"))]\\\n+                            resource r(a: bool) { }\");\n     assert vec::is_not_empty(doc.topmod.resources());\n }\n \n@@ -338,86 +295,133 @@ fn fold_iface(\n ) -> doc::ifacedoc {\n     let doc = fold::default_seq_fold_iface(fold, doc);\n     let doc = {\n-        methods: vec::map(doc.methods) {|doc|\n-            {\n-                args: prune_args(doc.args),\n-                return: prune_return(doc.return)\n-                with doc\n-            }\n-        }\n+        methods: prune_methods(doc.methods)\n         with doc\n     };\n-    let methods_have_docs = vec::foldl(false, doc.methods) {|accum, doc|\n+    fold.ctxt.have_docs =\n+        doc.brief != none\n+        || doc.desc != none\n+        || methods_have_docs(doc.methods);\n+    ret doc;\n+}\n+\n+fn prune_methods(docs: [doc::methoddoc]) -> [doc::methoddoc] {\n+    vec::map(docs) {|doc|\n+        {\n+            args: prune_args(doc.args),\n+            return: prune_return(doc.return)\n+            with doc\n+        }\n+    }\n+}\n+\n+fn methods_have_docs(docs: [doc::methoddoc]) -> bool {\n+    vec::foldl(false, docs) {|accum, doc|\n         accum\n             || doc.brief != none\n             || doc.desc != none\n             || vec::is_not_empty(doc.args)\n             || doc.return.desc != none\n             || doc.failure != none\n-    };\n-    fold.ctxt.have_docs =\n-        doc.brief != none\n-        || doc.desc != none\n-        || methods_have_docs;\n-    ret doc;\n+    }\n }\n \n #[test]\n fn should_elide_undocumented_ifaces() {\n-    let source = \"iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a(); }\");\n     assert vec::is_empty(doc.topmod.ifaces());\n }\n \n #[test]\n fn should_not_elide_documented_ifaces() {\n-    let source = \"#[doc = \\\"hey\\\"] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n     assert vec::is_not_empty(doc.topmod.ifaces());\n }\n \n #[test]\n fn should_not_elide_ifaces_with_documented_methods() {\n-    let source = \"iface i { #[doc = \\\"hey\\\"] fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { #[doc = \\\"hey\\\"] fn a(); }\");\n     assert vec::is_not_empty(doc.topmod.ifaces());\n }\n \n #[test]\n-fn should_not_elide_undocumented_methods() {\n-    let source = \"#[doc = \\\"hey\\\"] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+fn should_not_elide_undocumented_iface_methods() {\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n     assert vec::is_not_empty(doc.topmod.ifaces()[0].methods);\n }\n \n #[test]\n-fn should_elide_undocumented_method_args() {\n-    let source = \"#[doc = \\\"hey\\\"] iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+fn should_elide_undocumented_iface_method_args() {\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n     assert vec::is_empty(doc.topmod.ifaces()[0].methods[0].args);\n }\n \n #[test]\n-fn should_elide_undocumented_method_return_values() {\n-    let source = \"#[doc = \\\"hey\\\"] iface i { fn a() -> int; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = run(srv, doc);\n+fn should_elide_undocumented_iface_method_return_values() {\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a() -> int; }\");\n     assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n-}\n\\ No newline at end of file\n+}\n+\n+fn fold_impl(\n+    fold: fold::fold<ctxt>,\n+    doc: doc::impldoc\n+) -> doc::impldoc {\n+    let doc = fold::default_seq_fold_impl(fold, doc);\n+    let doc = {\n+        methods: prune_methods(doc.methods)\n+        with doc\n+    };\n+    fold.ctxt.have_docs =\n+        doc.brief != none\n+        || doc.desc != none\n+        || methods_have_docs(doc.methods);\n+    ret doc;\n+}\n+\n+#[test]\n+fn should_elide_undocumented_impls() {\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n+    assert vec::is_empty(doc.topmod.impls());\n+}\n+\n+#[test]\n+fn should_not_elide_documented_impls() {\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] impl i for int { fn a() { } }\");\n+    assert vec::is_not_empty(doc.topmod.impls());\n+}\n+\n+#[test]\n+fn should_not_elide_impls_with_documented_methods() {\n+    let doc = test::mk_doc(\"impl i for int { #[doc = \\\"hey\\\"] fn a() { } }\");\n+    assert vec::is_not_empty(doc.topmod.impls());\n+}\n+\n+#[test]\n+fn should_not_elide_undocumented_impl_methods() {\n+    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] impl i for int { fn a() { } }\");\n+    assert vec::is_not_empty(doc.topmod.impls()[0].methods);\n+}\n+\n+#[test]\n+fn should_elide_undocumented_impl_method_args() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"hey\\\"] impl i for int { fn a(b: bool) { } }\");\n+    assert vec::is_empty(doc.topmod.impls()[0].methods[0].args);\n+}\n+\n+#[test]\n+fn should_elide_undocumented_impl_method_return_values() {\n+    let doc = test::mk_doc(\n+        \"#[doc = \\\"hey\\\"] impl i for int { fn a() -> int { } }\");\n+    assert doc.topmod.impls()[0].methods[0].return.ty == none;\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        run(srv, doc)\n+    }\n+}"}, {"sha": "94e7332e2ccd0a6dff397095853923a7b8859616", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 34, "deletions": 54, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -132,119 +132,99 @@ fn is_exported_from_crate(\n \n #[test]\n fn should_prune_unexported_fns() {\n-    let source = \"mod b { export a; fn a() { } fn b() { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod b { export a; fn a() { } fn b() { } }\");\n     assert vec::len(doc.topmod.mods()[0].fns()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_fns_from_top_mod() {\n-    let source = \"export a; fn a() { } fn b() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; fn a() { } fn b() { }\");\n     assert vec::len(doc.topmod.fns()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_modules() {\n-    let source = \"mod a { export a; mod a { } mod b { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { export a; mod a { } mod b { } }\");\n     assert vec::len(doc.topmod.mods()[0].mods()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_modules_from_top_mod() {\n-    let source = \"export a; mod a { } mod b { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; mod a { } mod b { }\");\n     assert vec::len(doc.topmod.mods()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_consts() {\n-    let source = \"mod a { export a; \\\n-                  const a: bool = true; \\\n-                  const b: bool = true; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"mod a { export a; \\\n+         const a: bool = true; \\\n+         const b: bool = true; }\");\n     assert vec::len(doc.topmod.mods()[0].consts()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_consts_from_top_mod() {\n-    let source = \"export a; const a: bool = true; const b: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"export a; const a: bool = true; const b: bool = true;\");\n     assert vec::len(doc.topmod.consts()) == 1u;\n }\n \n #[test]\n fn should_prune_unexported_enums_from_top_mod() {\n-    let source = \"export a; mod a { } enum b { c }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; mod a { } enum b { c }\");\n     assert vec::len(doc.topmod.enums()) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_enums() {\n-    let source = \"mod a { export a; mod a { } enum b { c } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { export a; mod a { } enum b { c } }\");\n     assert vec::len(doc.topmod.mods()[0].enums()) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_variants_from_top_mod() {\n-    let source = \"export b::{}; enum b { c }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export b::{}; enum b { c }\");\n     assert vec::len(doc.topmod.enums()[0].variants) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_variants() {\n-    let source = \"mod a { export b::{}; enum b { c } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"mod a { export b::{}; enum b { c } }\");\n     assert vec::len(doc.topmod.mods()[0].enums()[0].variants) == 0u;\n }\n \n #[test]\n fn should_prune_unexported_resources_from_top_mod() {\n-    let source = \"export a; mod a { } resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; mod a { } resource r(a: bool) { }\");\n     assert vec::is_empty(doc.topmod.resources());\n }\n \n #[test]\n fn should_prune_unexported_resources() {\n-    let source = \"mod a { export a; mod a { } resource r(a: bool) { } }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\n+        \"mod a { export a; mod a { } resource r(a: bool) { } }\");\n     assert vec::is_empty(doc.topmod.mods()[0].resources());\n }\n \n #[test]\n fn should_prune_unexported_ifaces_from_top_mod() {\n-    let source = \"export a; mod a { } iface b { fn c(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"export a; mod a { } iface b { fn c(); }\");\n     assert vec::is_empty(doc.topmod.ifaces());\n }\n+\n+#[test]\n+fn should_prune_unexported_impls_from_top_mod() {\n+    let doc = test::mk_doc(\n+        \"export a; mod a { } impl b for int { fn c() { } }\");\n+    assert vec::is_empty(doc.topmod.impls())\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        run(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "bec08afdbd2bd58997aa58fbf5226f18655aae1c", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -15,69 +15,55 @@ fn mk_pass() -> pass {\n \n #[test]\n fn should_trim_mod() {\n-    let source = \"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                  desc = \\\"\\ndesc\\n\\\")] \\\n-                  mod m { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n+                            desc = \\\"\\ndesc\\n\\\")] \\\n+                            mod m { }\");\n     assert doc.topmod.mods()[0].brief == some(\"brief\");\n     assert doc.topmod.mods()[0].desc == some(\"desc\");\n }\n \n #[test]\n fn should_trim_const() {\n-    let source = \"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                  desc = \\\"\\ndesc\\n\\\")] \\\n-                  const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n+                            desc = \\\"\\ndesc\\n\\\")] \\\n+                            const a: bool = true;\");\n     assert doc.topmod.consts()[0].brief == some(\"brief\");\n     assert doc.topmod.consts()[0].desc == some(\"desc\");\n }\n \n #[test]\n fn should_trim_fn() {\n-    let source = \"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n-                  desc = \\\"\\ndesc\\n\\\")] \\\n-                  fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(brief = \\\"\\nbrief\\n\\\", \\\n+                            desc = \\\"\\ndesc\\n\\\")] \\\n+                            fn a() { }\");\n     assert doc.topmod.fns()[0].brief == some(\"brief\");\n     assert doc.topmod.fns()[0].desc == some(\"desc\");\n }\n \n #[test]\n fn should_trim_args() {\n-    let source = \"#[doc(args(a = \\\"\\na\\n\\\"))] fn a(a: int) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(args(a = \\\"\\na\\n\\\"))] fn a(a: int) { }\");\n     assert doc.topmod.fns()[0].args[0].desc == some(\"a\");\n }\n \n #[test]\n fn should_trim_ret() {\n-    let source = \"#[doc(return = \\\"\\na\\n\\\")] fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(return = \\\"\\na\\n\\\")] fn a() -> int { }\");\n     assert doc.topmod.fns()[0].return.desc == some(\"a\");\n }\n \n #[test]\n fn should_trim_failure_conditions() {\n-    let source = \"#[doc(failure = \\\"\\na\\n\\\")] fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = attr_pass::mk_pass()(srv, doc);\n-    let doc = mk_pass()(srv, doc);\n+    let doc = test::mk_doc(\"#[doc(failure = \\\"\\na\\n\\\")] fn a() -> int { }\");\n     assert doc.topmod.fns()[0].failure == some(\"a\");\n }\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = attr_pass::mk_pass()(srv, doc);\n+        mk_pass()(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "604e411dde072bc4c02081ae1f05fd3c55f7589d", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 161, "deletions": 73, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e204aa281d093bd7de4214c45375949d197eb2ab/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=e204aa281d093bd7de4214c45375949d197eb2ab", "patch": "@@ -20,7 +20,8 @@ fn run(\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n         fold_res: fold_res,\n-        fold_iface: fold_iface\n+        fold_iface: fold_iface,\n+        fold_impl: fold_impl\n         with *fold::default_seq_fold(srv)\n     });\n     fold.fold_crate(fold, doc)\n@@ -59,10 +60,7 @@ fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n \n #[test]\n fn should_add_fn_sig() {\n-    let source = \"fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a() -> int { }\");\n     assert doc.topmod.fns()[0].sig == some(\"fn a() -> int\");\n }\n \n@@ -106,19 +104,13 @@ fn ret_ty_to_str(decl: ast::fn_decl) -> option<str> {\n \n #[test]\n fn should_add_fn_ret_types() {\n-    let source = \"fn a() -> int { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a() -> int { }\");\n     assert doc.topmod.fns()[0].return.ty == some(\"int\");\n }\n \n #[test]\n fn should_not_add_nil_ret_type() {\n-    let source = \"fn a() { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a() { }\");\n     assert doc.topmod.fns()[0].return.ty == none;\n }\n \n@@ -164,10 +156,7 @@ fn decl_arg_tys(decl: ast::fn_decl) -> [(str, str)] {\n \n #[test]\n fn should_add_arg_types() {\n-    let source = \"fn a(b: int, c: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"fn a(b: int, c: bool) { }\");\n     let fn_ = doc.topmod.fns()[0];\n     assert fn_.args[0].ty == some(\"int\");\n     assert fn_.args[1].ty == some(\"bool\");\n@@ -198,10 +187,7 @@ fn fold_const(\n \n #[test]\n fn should_add_const_types() {\n-    let source = \"const a: bool = true;\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"const a: bool = true;\");\n     assert doc.topmod.consts()[0].ty == some(\"bool\");\n }\n \n@@ -240,10 +226,7 @@ fn fold_enum(\n \n #[test]\n fn should_add_variant_sigs() {\n-    let source = \"enum a { b(int) }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"enum a { b(int) }\");\n     assert doc.topmod.enums()[0].variants[0].sig == some(\"b(int)\");\n }\n \n@@ -271,50 +254,49 @@ fn fold_res(\n \n #[test]\n fn should_add_resource_sigs() {\n-    let source = \"resource r(b: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n     assert doc.topmod.resources()[0].sig == some(\"resource r(b: bool)\");\n }\n \n #[test]\n fn should_add_resource_arg_tys() {\n-    let source = \"resource r(a: bool) { }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"resource r(a: bool) { }\");\n     assert doc.topmod.resources()[0].args[0].ty == some(\"bool\");\n }\n \n fn fold_iface(\n     fold: fold::fold<astsrv::srv>,\n     doc: doc::ifacedoc\n ) -> doc::ifacedoc {\n-\n-    let srv = fold.ctxt;\n-\n     {\n-        methods: vec::map(doc.methods) {|methoddoc|\n-            {\n-                args: merge_method_arg_tys(\n-                    srv,\n-                    doc.id,\n-                    methoddoc.args,\n-                    methoddoc.name),\n-                return: merge_method_ret_ty(\n-                    srv,\n-                    doc.id,\n-                    methoddoc.return,\n-                    methoddoc.name),\n-                sig: get_method_sig(srv, doc.id, methoddoc.name)\n-                with methoddoc\n-            }\n-        }\n+        methods: merge_methods(fold.ctxt, doc.id, doc.methods)\n         with doc\n     }\n }\n \n+fn merge_methods(\n+    srv: astsrv::srv,\n+    item_id: doc::ast_id,\n+    docs: [doc::methoddoc]\n+) -> [doc::methoddoc] {\n+    vec::map(docs) {|doc|\n+        {\n+            args: merge_method_arg_tys(\n+                srv,\n+                item_id,\n+                doc.args,\n+                doc.name),\n+            return: merge_method_ret_ty(\n+                srv,\n+                item_id,\n+                doc.return,\n+                doc.name),\n+            sig: get_method_sig(srv, item_id, doc.name)\n+            with doc\n+        }\n+    }\n+}\n+\n fn merge_method_ret_ty(\n     srv: astsrv::srv,\n     item_id: doc::ast_id,\n@@ -351,7 +333,19 @@ fn get_method_ret_ty(\n                 _ { fail \"get_method_ret_ty: undocumented invariant\"; }\n             }\n           }\n-          _ { fail \"get_method_ret_ty: undocumented invariant\"; }\n+          ast_map::node_item(@{\n+            node: ast::item_impl(_, _, _, methods), _\n+          }) {\n+            alt vec::find(methods) {|method|\n+                method.ident == method_name\n+            } {\n+                some(method) {\n+                    ret_ty_to_str(method.decl)\n+                }\n+                _ { fail \"get_method_ret_ty: undocumented invariant\"; }\n+            }\n+          }\n+          _ { fail }\n         }\n     }\n }\n@@ -372,10 +366,22 @@ fn get_method_sig(\n                 some(method) {\n                     some(pprust::fun_to_str(method.decl, method.ident, []))\n                 }\n-                _ { fail \"get_method_ret_sig: undocumented invariant\"; }\n+                _ { fail \"get_method_sig: undocumented invariant\"; }\n             }\n           }\n-          _ { fail \"get_method_ret_sig: undocumented invariant\"; }\n+          ast_map::node_item(@{\n+            node: ast::item_impl(_, _, _, methods), _\n+          }) {\n+            alt vec::find(methods) {|method|\n+                method.ident == method_name\n+            } {\n+                some(method) {\n+                    some(pprust::fun_to_str(method.decl, method.ident, []))\n+                }\n+                _ { fail \"get_method_sig: undocumented invariant\"; }\n+            }\n+          }\n+          _ { fail \"get_method_sig: undocumented invariant\"; }\n         }\n     }\n }\n@@ -412,48 +418,130 @@ fn get_method_arg_tys(\n                 some(method) {\n                     decl_arg_tys(method.decl)\n                 }\n-                _ { fail \"get_method_arg_tys: undocumented invariant\"; }\n+                _ { fail \"get_method_arg_tys: expected method\"; }\n             }\n           }\n-          _ { fail \"get_method_arg_tys: undocumented invariant\"; }\n+          ast_map::node_item(@{\n+            node: ast::item_impl(_, _, _, methods), _\n+          }) {\n+            alt vec::find(methods) {|method|\n+                method.ident == method_name\n+            } {\n+                some(method) {\n+                    decl_arg_tys(method.decl)\n+                }\n+                _ { fail \"get_method_arg_tys: expected method\"; }\n+            }\n+          }\n+          _ { fail }\n         }\n     }\n }\n \n #[test]\n fn should_add_iface_method_sigs() {\n-    let source = \"iface i { fn a() -> int; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a() -> int; }\");\n     assert doc.topmod.ifaces()[0].methods[0].sig == some(\"fn a() -> int\");\n }\n \n #[test]\n fn should_add_iface_method_ret_types() {\n-    let source = \"iface i { fn a() -> int; }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a() -> int; }\");\n     assert doc.topmod.ifaces()[0].methods[0].return.ty == some(\"int\");\n }\n \n #[test]\n fn should_not_add_iface_method_nil_ret_type() {\n-    let source = \"iface i { fn a(); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a(); }\");\n     assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n }\n \n #[test]\n fn should_add_iface_method_arg_types() {\n-    let source = \"iface i { fn a(b: int, c: bool); }\";\n-    let srv = astsrv::mk_srv_from_str(source);\n-    let doc = extract::from_srv(srv, \"\");\n-    let doc = run(srv, doc);\n+    let doc = test::mk_doc(\"iface i { fn a(b: int, c: bool); }\");\n     let fn_ = doc.topmod.ifaces()[0].methods[0];\n     assert fn_.args[0].ty == some(\"int\");\n     assert fn_.args[1].ty == some(\"bool\");\n }\n+\n+fn fold_impl(\n+    fold: fold::fold<astsrv::srv>,\n+    doc: doc::impldoc\n+) -> doc::impldoc {\n+\n+    let srv = fold.ctxt;\n+\n+    let (iface_ty, self_ty) = astsrv::exec(srv) {|ctxt|\n+        alt ctxt.ast_map.get(doc.id) {\n+          ast_map::node_item(@{\n+            node: ast::item_impl(_, iface_ty, self_ty, _), _\n+          }) {\n+            let iface_ty = option::map(iface_ty) {|iface_ty|\n+                pprust::ty_to_str(iface_ty)\n+            };\n+            (iface_ty, some(pprust::ty_to_str(self_ty)))\n+          }\n+          _ { fail \"expected impl\" }\n+        }\n+    };\n+\n+    {\n+        iface_ty: iface_ty,\n+        self_ty: self_ty,\n+        methods: merge_methods(fold.ctxt, doc.id, doc.methods)\n+        with doc\n+    }\n+}\n+\n+#[test]\n+fn should_add_impl_iface_ty() {\n+    let doc = test::mk_doc(\"impl i of j for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].iface_ty == some(\"j\");\n+}\n+\n+#[test]\n+fn should_not_add_impl_iface_ty_if_none() {\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].iface_ty == none;\n+}\n+\n+#[test]\n+fn should_add_impl_self_ty() {\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].self_ty == some(\"int\");\n+}\n+\n+#[test]\n+fn should_add_impl_method_sigs() {\n+    let doc = test::mk_doc(\"impl i for int { fn a() -> int { fail } }\");\n+    assert doc.topmod.impls()[0].methods[0].sig == some(\"fn a() -> int\");\n+}\n+\n+#[test]\n+fn should_add_impl_method_ret_types() {\n+    let doc = test::mk_doc(\"impl i for int { fn a() -> int { fail } }\");\n+    assert doc.topmod.impls()[0].methods[0].return.ty == some(\"int\");\n+}\n+\n+#[test]\n+fn should_not_add_impl_method_nil_ret_type() {\n+    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n+    assert doc.topmod.impls()[0].methods[0].return.ty == none;\n+}\n+\n+#[test]\n+fn should_add_impl_method_arg_types() {\n+    let doc = test::mk_doc(\"impl i for int { fn a(b: int, c: bool) { } }\");\n+    let fn_ = doc.topmod.impls()[0].methods[0];\n+    assert fn_.args[0].ty == some(\"int\");\n+    assert fn_.args[1].ty == some(\"bool\");\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        run(srv, doc)\n+    }\n+}\n\\ No newline at end of file"}]}