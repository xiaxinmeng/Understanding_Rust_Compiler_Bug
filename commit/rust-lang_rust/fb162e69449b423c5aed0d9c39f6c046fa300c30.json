{"sha": "fb162e69449b423c5aed0d9c39f6c046fa300c30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMTYyZTY5NDQ5YjQyM2M1YWVkMGQ5YzM5ZjZjMDQ2ZmEzMDBjMzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-26T02:48:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-26T02:48:13Z"}, "message": "Auto merge of #58357 - sfackler:vectored-io, r=alexcrichton\n\nAdd vectored read and write support\n\nThis functionality has lived for a while in the tokio ecosystem, where\nit can improve performance by minimizing copies.\n\nr? @alexcrichton", "tree": {"sha": "5d4292df6a7db1b62137c4472f1e65317d3919e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d4292df6a7db1b62137c4472f1e65317d3919e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb162e69449b423c5aed0d9c39f6c046fa300c30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb162e69449b423c5aed0d9c39f6c046fa300c30", "html_url": "https://github.com/rust-lang/rust/commit/fb162e69449b423c5aed0d9c39f6c046fa300c30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb162e69449b423c5aed0d9c39f6c046fa300c30/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55c173c8ae8bda689fd609f391ee5e2e5b1b6d44", "url": "https://api.github.com/repos/rust-lang/rust/commits/55c173c8ae8bda689fd609f391ee5e2e5b1b6d44", "html_url": "https://github.com/rust-lang/rust/commit/55c173c8ae8bda689fd609f391ee5e2e5b1b6d44"}, {"sha": "4785c748f2190440fb3f90b5319f121f2d31e0e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4785c748f2190440fb3f90b5319f121f2d31e0e4", "html_url": "https://github.com/rust-lang/rust/commit/4785c748f2190440fb3f90b5319f121f2d31e0e4"}], "stats": {"total": 1147, "additions": 1052, "deletions": 95}, "files": [{"sha": "6383a14cf184cdccb8826b0ec6b57e5cba964338", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -5,7 +5,7 @@ use io::prelude::*;\n use cmp;\n use error;\n use fmt;\n-use io::{self, Initializer, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom};\n+use io::{self, Initializer, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom, IoVec, IoVecMut};\n use memchr;\n \n /// The `BufReader` struct adds buffering to any reader.\n@@ -235,6 +235,19 @@ impl<R: Read> Read for BufReader<R> {\n         Ok(nread)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n+        if self.pos == self.cap && total_len >= self.buf.len() {\n+            return self.inner.read_vectored(bufs);\n+        }\n+        let nread = {\n+            let mut rem = self.fill_buf()?;\n+            rem.read_vectored(bufs)?\n+        };\n+        self.consume(nread);\n+        Ok(nread)\n+    }\n+\n     // we can't skip unconditionally because of the large buffer case in read.\n     unsafe fn initializer(&self) -> Initializer {\n         self.inner.initializer()\n@@ -577,9 +590,25 @@ impl<W: Write> Write for BufWriter<W> {\n             self.panicked = false;\n             r\n         } else {\n-            Write::write(&mut self.buf, buf)\n+            self.buf.write(buf)\n+        }\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n+        if self.buf.len() + total_len > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        if total_len >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.inner.as_mut().unwrap().write_vectored(bufs);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.write_vectored(bufs)\n         }\n     }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         self.flush_buf().and_then(|()| self.get_mut().flush())\n     }"}, {"sha": "577a115025ba7b951a866cdac28accdd5fa67415", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 210, "deletions": 5, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -2,7 +2,7 @@ use io::prelude::*;\n \n use core::convert::TryInto;\n use cmp;\n-use io::{self, Initializer, SeekFrom, Error, ErrorKind};\n+use io::{self, Initializer, SeekFrom, Error, ErrorKind, IoVec, IoVecMut};\n \n /// A `Cursor` wraps an in-memory buffer and provides it with a\n /// [`Seek`] implementation.\n@@ -221,6 +221,18 @@ impl<T> Read for Cursor<T> where T: AsRef<[u8]> {\n         Ok(n)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let mut nread = 0;\n+        for buf in bufs {\n+            let n = self.read(buf)?;\n+            nread += n;\n+            if n < buf.len() {\n+                break;\n+            }\n+        }\n+        Ok(nread)\n+    }\n+\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         let n = buf.len();\n         Read::read_exact(&mut self.fill_buf()?, buf)?;\n@@ -251,6 +263,23 @@ fn slice_write(pos_mut: &mut u64, slice: &mut [u8], buf: &[u8]) -> io::Result<us\n     Ok(amt)\n }\n \n+fn slice_write_vectored(\n+    pos_mut: &mut u64,\n+    slice: &mut [u8],\n+    bufs: &[IoVec<'_>],\n+) -> io::Result<usize>\n+{\n+    let mut nwritten = 0;\n+    for buf in bufs {\n+        let n = slice_write(pos_mut, slice, buf)?;\n+        nwritten += n;\n+        if n < buf.len() {\n+            break;\n+        }\n+    }\n+    Ok(nwritten)\n+}\n+\n // Resizing write implementation\n fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n     let pos: usize = (*pos_mut).try_into().map_err(|_| {\n@@ -278,12 +307,31 @@ fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usi\n     Ok(buf.len())\n }\n \n+fn vec_write_vectored(\n+    pos_mut: &mut u64,\n+    vec: &mut Vec<u8>,\n+    bufs: &[IoVec<'_>],\n+) -> io::Result<usize>\n+{\n+    let mut nwritten = 0;\n+    for buf in bufs {\n+        nwritten += vec_write(pos_mut, vec, buf)?;\n+    }\n+    Ok(nwritten)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Cursor<&mut [u8]> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         slice_write(&mut self.pos, self.inner, buf)\n     }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        slice_write_vectored(&mut self.pos, self.inner, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -292,6 +340,11 @@ impl Write for Cursor<&mut Vec<u8>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, self.inner, buf)\n     }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        vec_write_vectored(&mut self.pos, self.inner, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -300,6 +353,11 @@ impl Write for Cursor<Vec<u8>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, &mut self.inner, buf)\n     }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        vec_write_vectored(&mut self.pos, &mut self.inner, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -309,21 +367,30 @@ impl Write for Cursor<Box<[u8]>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         slice_write(&mut self.pos, &mut self.inner, buf)\n     }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        slice_write_vectored(&mut self.pos, &mut self.inner, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n #[cfg(test)]\n mod tests {\n     use io::prelude::*;\n-    use io::{Cursor, SeekFrom};\n+    use io::{Cursor, SeekFrom, IoVec, IoVecMut};\n \n     #[test]\n     fn test_vec_writer() {\n         let mut writer = Vec::new();\n         assert_eq!(writer.write(&[0]).unwrap(), 1);\n         assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n         assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.write_vectored(\n+            &[IoVec::new(&[]), IoVec::new(&[8, 9]), IoVec::new(&[10])],\n+        ).unwrap(), 3);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(writer, b);\n     }\n \n@@ -333,7 +400,10 @@ mod tests {\n         assert_eq!(writer.write(&[0]).unwrap(), 1);\n         assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n         assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.write_vectored(\n+            &[IoVec::new(&[]), IoVec::new(&[8, 9]), IoVec::new(&[10])],\n+        ).unwrap(), 3);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(&writer.get_ref()[..], b);\n     }\n \n@@ -344,7 +414,10 @@ mod tests {\n         assert_eq!(writer.write(&[0]).unwrap(), 1);\n         assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n         assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.write_vectored(\n+            &[IoVec::new(&[]), IoVec::new(&[8, 9]), IoVec::new(&[10])],\n+        ).unwrap(), 3);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         assert_eq!(&writer.get_ref()[..], b);\n     }\n \n@@ -366,6 +439,26 @@ mod tests {\n         assert_eq!(&**writer.get_ref(), b);\n     }\n \n+    #[test]\n+    fn test_box_slice_writer_vectored() {\n+        let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write_vectored(&[IoVec::new(&[0])]).unwrap(), 1);\n+        assert_eq!(writer.position(), 1);\n+        assert_eq!(\n+            writer.write_vectored(&[IoVec::new(&[1, 2, 3]), IoVec::new(&[4, 5, 6, 7])]).unwrap(),\n+            7,\n+        );\n+        assert_eq!(writer.position(), 8);\n+        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+        assert_eq!(writer.position(), 8);\n+\n+        assert_eq!(writer.write_vectored(&[IoVec::new(&[8, 9])]).unwrap(), 1);\n+        assert_eq!(writer.write_vectored(&[IoVec::new(&[10])]).unwrap(), 0);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+        assert_eq!(&**writer.get_ref(), b);\n+    }\n+\n     #[test]\n     fn test_buf_writer() {\n         let mut buf = [0 as u8; 9];\n@@ -387,6 +480,31 @@ mod tests {\n         assert_eq!(buf, b);\n     }\n \n+    #[test]\n+    fn test_buf_writer_vectored() {\n+        let mut buf = [0 as u8; 9];\n+        {\n+            let mut writer = Cursor::new(&mut buf[..]);\n+            assert_eq!(writer.position(), 0);\n+            assert_eq!(writer.write_vectored(&[IoVec::new(&[0])]).unwrap(), 1);\n+            assert_eq!(writer.position(), 1);\n+            assert_eq!(\n+                writer.write_vectored(\n+                    &[IoVec::new(&[1, 2, 3]), IoVec::new(&[4, 5, 6, 7])],\n+                ).unwrap(),\n+                7,\n+            );\n+            assert_eq!(writer.position(), 8);\n+            assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+            assert_eq!(writer.position(), 8);\n+\n+            assert_eq!(writer.write_vectored(&[IoVec::new(&[8, 9])]).unwrap(), 1);\n+            assert_eq!(writer.write_vectored(&[IoVec::new(&[10])]).unwrap(), 0);\n+        }\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+        assert_eq!(buf, b);\n+    }\n+\n     #[test]\n     fn test_buf_writer_seek() {\n         let mut buf = [0 as u8; 8];\n@@ -447,6 +565,35 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n+    #[test]\n+    fn test_mem_reader_vectored() {\n+        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n+        let mut buf = [];\n+        assert_eq!(reader.read_vectored(&mut [IoVecMut::new(&mut buf)]).unwrap(), 0);\n+        assert_eq!(reader.position(), 0);\n+        let mut buf = [0];\n+        assert_eq!(\n+            reader.read_vectored(&mut [IoVecMut::new(&mut []), IoVecMut::new(&mut buf)]).unwrap(),\n+            1,\n+        );\n+        assert_eq!(reader.position(), 1);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf1 = [0; 4];\n+        let mut buf2 = [0; 4];\n+        assert_eq!(\n+            reader.read_vectored(\n+                &mut [IoVecMut::new(&mut buf1), IoVecMut::new(&mut buf2)],\n+            ).unwrap(),\n+            7,\n+        );\n+        let b1: &[_] = &[1, 2, 3, 4];\n+        let b2: &[_] = &[5, 6, 7];\n+        assert_eq!(buf1, b1);\n+        assert_eq!(&buf2[..3], b2);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    }\n+\n     #[test]\n     fn test_boxed_slice_reader() {\n         let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n@@ -469,6 +616,35 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n+    #[test]\n+    fn test_boxed_slice_reader_vectored() {\n+        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n+        let mut buf = [];\n+        assert_eq!(reader.read_vectored(&mut [IoVecMut::new(&mut buf)]).unwrap(), 0);\n+        assert_eq!(reader.position(), 0);\n+        let mut buf = [0];\n+        assert_eq!(\n+            reader.read_vectored(&mut [IoVecMut::new(&mut []), IoVecMut::new(&mut buf)]).unwrap(),\n+            1,\n+        );\n+        assert_eq!(reader.position(), 1);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf1 = [0; 4];\n+        let mut buf2 = [0; 4];\n+        assert_eq!(\n+            reader.read_vectored(\n+                &mut [IoVecMut::new(&mut buf1), IoVecMut::new(&mut buf2)],\n+            ).unwrap(),\n+            7,\n+        );\n+        let b1: &[_] = &[1, 2, 3, 4];\n+        let b2: &[_] = &[5, 6, 7];\n+        assert_eq!(buf1, b1);\n+        assert_eq!(&buf2[..3], b2);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    }\n+\n     #[test]\n     fn read_to_end() {\n         let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -499,6 +675,35 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n+    #[test]\n+    fn test_slice_reader_vectored() {\n+        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n+        let reader = &mut &in_buf[..];\n+        let mut buf = [];\n+        assert_eq!(reader.read_vectored(&mut [IoVecMut::new(&mut buf)]).unwrap(), 0);\n+        let mut buf = [0];\n+        assert_eq!(\n+            reader.read_vectored(&mut [IoVecMut::new(&mut []), IoVecMut::new(&mut buf)]).unwrap(),\n+            1,\n+        );\n+        assert_eq!(reader.len(), 7);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf1 = [0; 4];\n+        let mut buf2 = [0; 4];\n+        assert_eq!(\n+            reader.read_vectored(\n+                &mut [IoVecMut::new(&mut buf1), IoVecMut::new(&mut buf2)],\n+            ).unwrap(),\n+            7,\n+        );\n+        let b1: &[_] = &[1, 2, 3, 4];\n+        let b2: &[_] = &[5, 6, 7];\n+        assert_eq!(buf1, b1);\n+        assert_eq!(&buf2[..3], b2);\n+        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    }\n+\n     #[test]\n     fn test_read_exact() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];"}, {"sha": "aa8db177ffcd10908c8d836fd9ad8d1a2776cbdc", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,5 +1,6 @@\n use cmp;\n-use io::{self, SeekFrom, Read, Initializer, Write, Seek, BufRead, Error, ErrorKind};\n+use io::{self, SeekFrom, Read, Initializer, Write, Seek, BufRead, Error, ErrorKind, IoVecMut,\n+         IoVec};\n use fmt;\n use mem;\n \n@@ -13,6 +14,11 @@ impl<R: Read + ?Sized> Read for &mut R {\n         (**self).read(buf)\n     }\n \n+    #[inline]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        (**self).read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         (**self).initializer()\n@@ -38,6 +44,11 @@ impl<W: Write + ?Sized> Write for &mut W {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        (**self).write_vectored(bufs)\n+    }\n+\n     #[inline]\n     fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n \n@@ -82,6 +93,11 @@ impl<R: Read + ?Sized> Read for Box<R> {\n         (**self).read(buf)\n     }\n \n+    #[inline]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        (**self).read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         (**self).initializer()\n@@ -107,6 +123,11 @@ impl<W: Write + ?Sized> Write for Box<W> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        (**self).write_vectored(bufs)\n+    }\n+\n     #[inline]\n     fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n \n@@ -171,6 +192,19 @@ impl Read for &[u8] {\n         Ok(amt)\n     }\n \n+    #[inline]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let mut nread = 0;\n+        for buf in bufs {\n+            nread += self.read(buf)?;\n+            if self.is_empty() {\n+                break;\n+            }\n+        }\n+\n+        Ok(nread)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -231,6 +265,19 @@ impl Write for &mut [u8] {\n         Ok(amt)\n     }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let mut nwritten = 0;\n+        for buf in bufs {\n+            nwritten += self.write(buf)?;\n+            if self.is_empty() {\n+                break;\n+            }\n+        }\n+\n+        Ok(nwritten)\n+    }\n+\n     #[inline]\n     fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n         if self.write(data)? == data.len() {\n@@ -254,6 +301,16 @@ impl Write for Vec<u8> {\n         Ok(buf.len())\n     }\n \n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let len = bufs.iter().map(|b| b.len()).sum();\n+        self.reserve(len);\n+        for buf in bufs {\n+            self.extend_from_slice(buf);\n+        }\n+        Ok(len)\n+    }\n+\n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         self.extend_from_slice(buf);"}, {"sha": "12b158e4197fc7b8468fad3b9fa26f16f1fbca87", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -264,7 +264,9 @@ use fmt;\n use slice;\n use str;\n use memchr;\n+use ops::{Deref, DerefMut};\n use ptr;\n+use sys;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::{BufReader, BufWriter, LineWriter};\n@@ -520,6 +522,22 @@ pub trait Read {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n \n+    /// Like `read`, except that it reads into a slice of buffers.\n+    ///\n+    /// Data is copied to fill each buffer in order, with the final buffer\n+    /// written to possibly being only partially filled. This method must behave\n+    /// as a single call to `read` with the buffers concatenated would.\n+    ///\n+    /// The default implementation simply passes the first nonempty buffer to\n+    /// `read`.\n+    #[unstable(feature = \"iovec\", issue = \"58452\")]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> Result<usize> {\n+        match bufs.iter_mut().find(|b| !b.is_empty()) {\n+            Some(buf) => self.read(buf),\n+            None => Ok(0),\n+        }\n+    }\n+\n     /// Determines if this `Read`er can work with buffers of uninitialized\n     /// memory.\n     ///\n@@ -867,6 +885,92 @@ pub trait Read {\n     }\n }\n \n+/// A buffer type used with `Read::read_vectored`.\n+///\n+/// It is semantically a wrapper around an `&mut [u8]`, but is guaranteed to be\n+/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n+/// Windows.\n+#[unstable(feature = \"iovec\", issue = \"58452\")]\n+#[repr(transparent)]\n+pub struct IoVecMut<'a>(sys::io::IoVecMut<'a>);\n+\n+#[unstable(feature = \"iovec\", issue = \"58452\")]\n+impl<'a> fmt::Debug for IoVecMut<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.0.as_slice(), fmt)\n+    }\n+}\n+\n+impl<'a> IoVecMut<'a> {\n+    /// Creates a new `IoVecMut` wrapping a byte slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics on Windows if the slice is larger than 4GB.\n+    #[unstable(feature = \"iovec\", issue = \"58452\")]\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(sys::io::IoVecMut::new(buf))\n+    }\n+}\n+\n+#[unstable(feature = \"iovec\", issue = \"58452\")]\n+impl<'a> Deref for IoVecMut<'a> {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        self.0.as_slice()\n+    }\n+}\n+\n+#[unstable(feature = \"iovec\", issue = \"58452\")]\n+impl<'a> DerefMut for IoVecMut<'a> {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        self.0.as_mut_slice()\n+    }\n+}\n+\n+/// A buffer type used with `Write::write_vectored`.\n+///\n+/// It is semantically a wrapper around an `&[u8]`, but is guaranteed to be\n+/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n+/// Windows.\n+#[unstable(feature = \"iovec\", issue = \"58452\")]\n+#[repr(transparent)]\n+pub struct IoVec<'a>(sys::io::IoVec<'a>);\n+\n+#[unstable(feature = \"iovec\", issue = \"58452\")]\n+impl<'a> fmt::Debug for IoVec<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.0.as_slice(), fmt)\n+    }\n+}\n+\n+impl<'a> IoVec<'a> {\n+    /// Creates a new `IoVec` wrapping a byte slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics on Windows if the slice is larger than 4GB.\n+    #[unstable(feature = \"iovec\", issue = \"58452\")]\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(sys::io::IoVec::new(buf))\n+    }\n+}\n+\n+#[unstable(feature = \"iovec\", issue = \"58452\")]\n+impl<'a> Deref for IoVec<'a> {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        self.0.as_slice()\n+    }\n+}\n+\n /// A type used to conditionally initialize buffers passed to `Read` methods.\n #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n #[derive(Debug)]\n@@ -997,6 +1101,22 @@ pub trait Write {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n \n+    /// Like `write`, except that it writes from a slice of buffers.\n+    ///\n+    /// Data is copied to from each buffer in order, with the final buffer\n+    /// read from possibly being only partially consumed. This method must\n+    /// behave as a call to `write` with the buffers concatenated would.\n+    ///\n+    /// The default implementation simply passes the first nonempty buffer to\n+    /// `write`.\n+    #[unstable(feature = \"iovec\", issue = \"58452\")]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> Result<usize> {\n+        match bufs.iter().find(|b| !b.is_empty()) {\n+            Some(buf) => self.write(buf),\n+            None => Ok(0),\n+        }\n+    }\n+\n     /// Flush this output stream, ensuring that all intermediately buffered\n     /// contents reach their destination.\n     ///\n@@ -1691,13 +1811,23 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n         if !self.done_first {\n             match self.first.read(buf)? {\n-                0 if buf.len() != 0 => { self.done_first = true; }\n+                0 if buf.len() != 0 => self.done_first = true,\n                 n => return Ok(n),\n             }\n         }\n         self.second.read(buf)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> Result<usize> {\n+        if !self.done_first {\n+            match self.first.read_vectored(bufs)? {\n+                0 if bufs.iter().any(|b| !b.is_empty()) => self.done_first = true,\n+                n => return Ok(n),\n+            }\n+        }\n+        self.second.read_vectored(bufs)\n+    }\n+\n     unsafe fn initializer(&self) -> Initializer {\n         let initializer = self.first.initializer();\n         if initializer.should_initialize() {"}, {"sha": "5ce955eb1e4af049f84a3a9bda520d2be93530da", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,7 +1,7 @@\n #![allow(missing_copy_implementations)]\n \n use fmt;\n-use io::{self, Read, Initializer, Write, ErrorKind, BufRead};\n+use io::{self, Read, Initializer, Write, ErrorKind, BufRead, IoVec, IoVecMut};\n use mem;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -152,6 +152,15 @@ impl Read for Repeat {\n         Ok(buf.len())\n     }\n \n+    #[inline]\n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let mut nwritten = 0;\n+        for buf in bufs {\n+            nwritten += self.read(buf)?;\n+        }\n+        Ok(nwritten)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -195,6 +204,13 @@ pub fn sink() -> Sink { Sink { _priv: () } }\n impl Write for Sink {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.len()).sum();\n+        Ok(total_len)\n+    }\n+\n     #[inline]\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }"}, {"sha": "877a5a96c10bae7a7b7a6d35d0158e31eab4065f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -234,6 +234,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n+#![feature(bind_by_move_pattern_guards)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_target_has_atomic)]"}, {"sha": "3aa29f83b2938f31d2604b6c21c5377dfecf0a35", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,7 +1,7 @@\n use io::prelude::*;\n \n use fmt;\n-use io::{self, Initializer};\n+use io::{self, Initializer, IoVec, IoVecMut};\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner, IntoInner};\n@@ -569,6 +569,10 @@ impl TcpStream {\n impl Read for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -577,12 +581,21 @@ impl Read for TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for &TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -591,6 +604,11 @@ impl Read for &TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for &TcpStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+\n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n@@ -911,7 +929,7 @@ impl fmt::Debug for TcpListener {\n \n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n-    use io::ErrorKind;\n+    use io::{ErrorKind, IoVec, IoVecMut};\n     use io::prelude::*;\n     use net::*;\n     use net::test::{next_test_ip4, next_test_ip6};\n@@ -1184,6 +1202,53 @@ mod tests {\n         })\n     }\n \n+    #[test]\n+    fn read_vectored() {\n+        each_ip(&mut |addr| {\n+            let srv = t!(TcpListener::bind(&addr));\n+            let mut s1 = t!(TcpStream::connect(&addr));\n+            let mut s2 = t!(srv.accept()).0;\n+\n+            let len = s1.write(&[10, 11, 12]).unwrap();\n+            assert_eq!(len, 3);\n+\n+            let mut a = [];\n+            let mut b = [0];\n+            let mut c = [0; 3];\n+            let len = t!(s2.read_vectored(\n+                &mut [IoVecMut::new(&mut a), IoVecMut::new(&mut b), IoVecMut::new(&mut c)],\n+            ));\n+            assert!(len > 0);\n+            assert_eq!(b, [10]);\n+            // some implementations don't support readv, so we may only fill the first buffer\n+            assert!(len == 1 || c == [11, 12, 0]);\n+        })\n+    }\n+\n+    #[test]\n+    fn write_vectored() {\n+        each_ip(&mut |addr| {\n+            let srv = t!(TcpListener::bind(&addr));\n+            let mut s1 = t!(TcpStream::connect(&addr));\n+            let mut s2 = t!(srv.accept()).0;\n+\n+            let a = [];\n+            let b = [10];\n+            let c = [11, 12];\n+            t!(s1.write_vectored(&[IoVec::new(&a), IoVec::new(&b), IoVec::new(&c)]));\n+\n+            let mut buf = [0; 4];\n+            let len = t!(s2.read(&mut buf));\n+            // some implementations don't support writev, so we may only write the first buffer\n+            if len == 1 {\n+                assert_eq!(buf, [10, 0, 0, 0]);\n+            } else {\n+                assert_eq!(len, 3);\n+                assert_eq!(buf, [10, 11, 12, 0]);\n+            }\n+        })\n+    }\n+\n     #[test]\n     fn double_bind() {\n         each_ip(&mut |addr| {"}, {"sha": "8b02d3fd19d304f19d5c58a444e2ab8dfdc41678", "filename": "src/libstd/sys/cloudabi/io.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fio.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -0,0 +1,32 @@\n+pub struct IoVec<'a>(&'a [u8]);\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoVecMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "d9bc21861c90da0c74391637aa174d81a6053fd6", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,4 +1,3 @@\n-use io;\n use libc;\n use mem;\n \n@@ -10,6 +9,7 @@ pub mod backtrace;\n #[path = \"../unix/cmath.rs\"]\n pub mod cmath;\n pub mod condvar;\n+pub mod io;\n #[path = \"../unix/memchr.rs\"]\n pub mod memchr;\n pub mod mutex;\n@@ -32,24 +32,24 @@ pub use self::shims::*;\n #[allow(dead_code)]\n pub fn init() {}\n \n-pub fn decode_error_kind(errno: i32) -> io::ErrorKind {\n+pub fn decode_error_kind(errno: i32) -> ::io::ErrorKind {\n     match errno {\n-        x if x == abi::errno::ACCES as i32 => io::ErrorKind::PermissionDenied,\n-        x if x == abi::errno::ADDRINUSE as i32 => io::ErrorKind::AddrInUse,\n-        x if x == abi::errno::ADDRNOTAVAIL as i32 => io::ErrorKind::AddrNotAvailable,\n-        x if x == abi::errno::AGAIN as i32 => io::ErrorKind::WouldBlock,\n-        x if x == abi::errno::CONNABORTED as i32 => io::ErrorKind::ConnectionAborted,\n-        x if x == abi::errno::CONNREFUSED as i32 => io::ErrorKind::ConnectionRefused,\n-        x if x == abi::errno::CONNRESET as i32 => io::ErrorKind::ConnectionReset,\n-        x if x == abi::errno::EXIST as i32 => io::ErrorKind::AlreadyExists,\n-        x if x == abi::errno::INTR as i32 => io::ErrorKind::Interrupted,\n-        x if x == abi::errno::INVAL as i32 => io::ErrorKind::InvalidInput,\n-        x if x == abi::errno::NOENT as i32 => io::ErrorKind::NotFound,\n-        x if x == abi::errno::NOTCONN as i32 => io::ErrorKind::NotConnected,\n-        x if x == abi::errno::PERM as i32 => io::ErrorKind::PermissionDenied,\n-        x if x == abi::errno::PIPE as i32 => io::ErrorKind::BrokenPipe,\n-        x if x == abi::errno::TIMEDOUT as i32 => io::ErrorKind::TimedOut,\n-        _ => io::ErrorKind::Other,\n+        x if x == abi::errno::ACCES as i32 => ::io::ErrorKind::PermissionDenied,\n+        x if x == abi::errno::ADDRINUSE as i32 => ::io::ErrorKind::AddrInUse,\n+        x if x == abi::errno::ADDRNOTAVAIL as i32 => ::io::ErrorKind::AddrNotAvailable,\n+        x if x == abi::errno::AGAIN as i32 => ::io::ErrorKind::WouldBlock,\n+        x if x == abi::errno::CONNABORTED as i32 => ::io::ErrorKind::ConnectionAborted,\n+        x if x == abi::errno::CONNREFUSED as i32 => ::io::ErrorKind::ConnectionRefused,\n+        x if x == abi::errno::CONNRESET as i32 => ::io::ErrorKind::ConnectionReset,\n+        x if x == abi::errno::EXIST as i32 => ::io::ErrorKind::AlreadyExists,\n+        x if x == abi::errno::INTR as i32 => ::io::ErrorKind::Interrupted,\n+        x if x == abi::errno::INVAL as i32 => ::io::ErrorKind::InvalidInput,\n+        x if x == abi::errno::NOENT as i32 => ::io::ErrorKind::NotFound,\n+        x if x == abi::errno::NOTCONN as i32 => ::io::ErrorKind::NotConnected,\n+        x if x == abi::errno::PERM as i32 => ::io::ErrorKind::PermissionDenied,\n+        x if x == abi::errno::PIPE as i32 => ::io::ErrorKind::BrokenPipe,\n+        x if x == abi::errno::TIMEDOUT as i32 => ::io::ErrorKind::TimedOut,\n+        _ => ::io::ErrorKind::Other,\n     }\n }\n "}, {"sha": "869a0ef87a70e8949bb0c35b600cf79bd03bfb45", "filename": "src/libstd/sys/cloudabi/shims/net.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,5 +1,5 @@\n use fmt;\n-use io;\n+use io::{self, IoVec, IoVecMut};\n use net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use time::Duration;\n use sys::{unsupported, Void};\n@@ -42,10 +42,18 @@ impl TcpStream {\n         match self.0 {}\n     }\n \n+    pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n     pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n         match self.0 {}\n     }\n \n+    pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         match self.0 {}\n     }"}, {"sha": "8b02d3fd19d304f19d5c58a444e2ab8dfdc41678", "filename": "src/libstd/sys/redox/io.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fredox%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fredox%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fio.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -0,0 +1,32 @@\n+pub struct IoVec<'a>(&'a [u8]);\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoVecMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "c3878349bb329c6ab1cc519f87626f8972fe3cbf", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,6 +1,6 @@\n #![allow(dead_code, missing_docs, nonstandard_style)]\n \n-use io::{self, ErrorKind};\n+use ::io::{ErrorKind};\n \n pub use libc::strlen;\n pub use self::rand::hashmap_random_keys;\n@@ -17,6 +17,7 @@ pub mod ext;\n pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n+pub mod io;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n@@ -63,8 +64,8 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-pub fn cvt(result: Result<usize, syscall::Error>) -> io::Result<usize> {\n-    result.map_err(|err| io::Error::from_raw_os_error(err.errno))\n+pub fn cvt(result: Result<usize, syscall::Error>) -> ::io::Result<usize> {\n+    result.map_err(|err| ::io::Error::from_raw_os_error(err.errno))\n }\n \n #[doc(hidden)]\n@@ -82,9 +83,9 @@ macro_rules! impl_is_minus_one {\n \n impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n-pub fn cvt_libc<T: IsMinusOne>(t: T) -> io::Result<T> {\n+pub fn cvt_libc<T: IsMinusOne>(t: T) -> ::io::Result<T> {\n     if t.is_minus_one() {\n-        Err(io::Error::last_os_error())\n+        Err(::io::Error::last_os_error())\n     } else {\n         Ok(t)\n     }"}, {"sha": "abb9f72c324b6452ac8fb9c0bd183efbffa690b5", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,5 +1,5 @@\n use cmp;\n-use io::{self, Error, ErrorKind, Result};\n+use io::{self, Error, ErrorKind, Result, IoVec, IoVecMut};\n use mem;\n use net::{SocketAddr, Shutdown};\n use path::Path;\n@@ -34,10 +34,24 @@ impl TcpStream {\n         self.0.read(buf)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        match bufs.iter_mut().find(|b| !b.is_empty()) {\n+            Some(buf) => self.read(buf),\n+            None => Ok(0),\n+        }\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> Result<usize> {\n         self.0.write(buf)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        match bufs.iter().find(|b| !b.is_empty()) {\n+            Some(buf) => self.write(buf),\n+            None => Ok(0),\n+        }\n+    }\n+\n     pub fn take_error(&self) -> Result<Option<Error>> {\n         Ok(None)\n     }"}, {"sha": "8b02d3fd19d304f19d5c58a444e2ab8dfdc41678", "filename": "src/libstd/sys/sgx/io.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fio.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -0,0 +1,32 @@\n+pub struct IoVec<'a>(&'a [u8]);\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoVecMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "403dd61187fc3146ff308e158a29d6f2f385677f", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -3,7 +3,6 @@\n //! This module contains the facade (aka platform-specific) implementations of\n //! OS level functionality for Fortanix SGX.\n \n-use io;\n use os::raw::c_char;\n use sync::atomic::{AtomicBool, Ordering};\n \n@@ -20,6 +19,7 @@ pub mod env;\n pub mod ext;\n pub mod fd;\n pub mod fs;\n+pub mod io;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n@@ -41,12 +41,12 @@ pub fn init() {\n \n /// This function is used to implement functionality that simply doesn't exist.\n /// Programs relying on this functionality will need to deal with the error.\n-pub fn unsupported<T>() -> io::Result<T> {\n+pub fn unsupported<T>() -> ::io::Result<T> {\n     Err(unsupported_err())\n }\n \n-pub fn unsupported_err() -> io::Error {\n-    io::Error::new(io::ErrorKind::Other,\n+pub fn unsupported_err() -> ::io::Error {\n+    ::io::Error::new(::io::ErrorKind::Other,\n                    \"operation not supported on SGX yet\")\n }\n \n@@ -55,58 +55,58 @@ pub fn unsupported_err() -> io::Error {\n /// returned, the program might very well be able to function normally. This is\n /// what happens when `SGX_INEFFECTIVE_ERROR` is set to `true`. If it is\n /// `false`, the behavior is the same as `unsupported`.\n-pub fn sgx_ineffective<T>(v: T) -> io::Result<T> {\n+pub fn sgx_ineffective<T>(v: T) -> ::io::Result<T> {\n     static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n     if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n-        Err(io::Error::new(io::ErrorKind::Other,\n+        Err(::io::Error::new(::io::ErrorKind::Other,\n                        \"operation can't be trusted to have any effect on SGX\"))\n     } else {\n         Ok(v)\n     }\n }\n \n-pub fn decode_error_kind(code: i32) -> io::ErrorKind {\n+pub fn decode_error_kind(code: i32) -> ::io::ErrorKind {\n     use fortanix_sgx_abi::Error;\n \n     // FIXME: not sure how to make sure all variants of Error are covered\n     if code == Error::NotFound as _ {\n-        io::ErrorKind::NotFound\n+        ::io::ErrorKind::NotFound\n     } else if code == Error::PermissionDenied as _ {\n-        io::ErrorKind::PermissionDenied\n+        ::io::ErrorKind::PermissionDenied\n     } else if code == Error::ConnectionRefused as _ {\n-        io::ErrorKind::ConnectionRefused\n+        ::io::ErrorKind::ConnectionRefused\n     } else if code == Error::ConnectionReset as _ {\n-        io::ErrorKind::ConnectionReset\n+        ::io::ErrorKind::ConnectionReset\n     } else if code == Error::ConnectionAborted as _ {\n-        io::ErrorKind::ConnectionAborted\n+        ::io::ErrorKind::ConnectionAborted\n     } else if code == Error::NotConnected as _ {\n-        io::ErrorKind::NotConnected\n+        ::io::ErrorKind::NotConnected\n     } else if code == Error::AddrInUse as _ {\n-        io::ErrorKind::AddrInUse\n+        ::io::ErrorKind::AddrInUse\n     } else if code == Error::AddrNotAvailable as _ {\n-        io::ErrorKind::AddrNotAvailable\n+        ::io::ErrorKind::AddrNotAvailable\n     } else if code == Error::BrokenPipe as _ {\n-        io::ErrorKind::BrokenPipe\n+        ::io::ErrorKind::BrokenPipe\n     } else if code == Error::AlreadyExists as _ {\n-        io::ErrorKind::AlreadyExists\n+        ::io::ErrorKind::AlreadyExists\n     } else if code == Error::WouldBlock as _ {\n-        io::ErrorKind::WouldBlock\n+        ::io::ErrorKind::WouldBlock\n     } else if code == Error::InvalidInput as _ {\n-        io::ErrorKind::InvalidInput\n+        ::io::ErrorKind::InvalidInput\n     } else if code == Error::InvalidData as _ {\n-        io::ErrorKind::InvalidData\n+        ::io::ErrorKind::InvalidData\n     } else if code == Error::TimedOut as _ {\n-        io::ErrorKind::TimedOut\n+        ::io::ErrorKind::TimedOut\n     } else if code == Error::WriteZero as _ {\n-        io::ErrorKind::WriteZero\n+        ::io::ErrorKind::WriteZero\n     } else if code == Error::Interrupted as _ {\n-        io::ErrorKind::Interrupted\n+        ::io::ErrorKind::Interrupted\n     } else if code == Error::Other as _ {\n-        io::ErrorKind::Other\n+        ::io::ErrorKind::Other\n     } else if code == Error::UnexpectedEof as _ {\n-        io::ErrorKind::UnexpectedEof\n+        ::io::ErrorKind::UnexpectedEof\n     } else {\n-        io::ErrorKind::Other\n+        ::io::ErrorKind::Other\n     }\n }\n "}, {"sha": "c4c2de43ff7df8b43ff3cb9247454148f3f9693a", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,5 +1,5 @@\n use fmt;\n-use io;\n+use io::{self, IoVec, IoVecMut};\n use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n use time::Duration;\n use sys::{unsupported, Void, sgx_ineffective, AsInner, FromInner, IntoInner, TryIntoInner};\n@@ -103,10 +103,26 @@ impl TcpStream {\n         self.inner.inner.read(buf)\n     }\n \n+    pub fn read_vectored(&self, buf: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let buf = match buf.get_mut(0) {\n+            Some(buf) => buf,\n+            None => return Ok(0),\n+        };\n+        self.read(buf)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.write(buf)\n     }\n \n+    pub fn write_vectored(&self, buf: &[IoVec<'_>]) -> io::Result<usize> {\n+        let buf = match buf.get(0) {\n+            Some(buf) => buf,\n+            None => return Ok(0),\n+        };\n+        self.write(buf)\n+    }\n+\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         addr_to_sockaddr(&self.peer_addr)\n     }"}, {"sha": "4b60ea654c1f19d49bbce92cb1dc3ab663d0e44a", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -18,7 +18,7 @@ mod libc {\n use ascii;\n use ffi::OsStr;\n use fmt;\n-use io::{self, Initializer};\n+use io::{self, Initializer, IoVec, IoVecMut};\n use mem;\n use net::{self, Shutdown};\n use os::unix::ffi::OsStrExt;\n@@ -551,6 +551,10 @@ impl io::Read for UnixStream {\n         io::Read::read(&mut &*self, buf)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        io::Read::read_vectored(&mut &*self, bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -563,6 +567,10 @@ impl<'a> io::Read for &'a UnixStream {\n         self.0.read(buf)\n     }\n \n+    fn read_vectored(&mut self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n         Initializer::nop()\n@@ -575,6 +583,10 @@ impl io::Write for UnixStream {\n         io::Write::write(&mut &*self, buf)\n     }\n \n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        io::Write::write_vectored(&mut &*self, bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         io::Write::flush(&mut &*self)\n     }\n@@ -586,6 +598,10 @@ impl<'a> io::Write for &'a UnixStream {\n         self.0.write(buf)\n     }\n \n+    fn write_vectored(&mut self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n@@ -1510,6 +1526,25 @@ mod test {\n         thread.join().unwrap();\n     }\n \n+    #[test]\n+    fn vectored() {\n+        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n+\n+        let len = or_panic!(s1.write_vectored(\n+            &[IoVec::new(b\"hello\"), IoVec::new(b\" \"), IoVec::new(b\"world!\")],\n+        ));\n+        assert_eq!(len, 12);\n+\n+        let mut buf1 = [0; 6];\n+        let mut buf2 = [0; 7];\n+        let len = or_panic!(s2.read_vectored(\n+            &mut [IoVecMut::new(&mut buf1), IoVecMut::new(&mut buf2)],\n+        ));\n+        assert_eq!(len, 12);\n+        assert_eq!(&buf1, b\"hello \");\n+        assert_eq!(&buf2, b\"world!\\0\");\n+    }\n+\n     #[test]\n     fn pair() {\n         let msg1 = b\"hello\";"}, {"sha": "6946b7b5dfa48e9ff4c567670eb2fa3d271e6635", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,7 +1,7 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n use cmp;\n-use io::{self, Read, Initializer};\n+use io::{self, Read, Initializer, IoVec, IoVecMut};\n use libc::{self, c_int, c_void, ssize_t};\n use mem;\n use sync::atomic::{AtomicBool, Ordering};\n@@ -52,6 +52,15 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::readv(self.fd,\n+                        bufs.as_ptr() as *const libc::iovec,\n+                        cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         let mut me = self;\n         (&mut me).read_to_end(buf)\n@@ -105,6 +114,15 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::writev(self.fd,\n+                         bufs.as_ptr() as *const libc::iovec,\n+                         cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n         #[cfg(target_os = \"android\")]\n         use super::android::cvt_pwrite64;"}, {"sha": "65e4c6e0577509027d6a3c49b6efa27d3a661fb5", "filename": "src/libstd/sys/unix/io.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fio.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -0,0 +1,61 @@\n+use marker::PhantomData;\n+use libc::{iovec, c_void};\n+use slice;\n+\n+#[repr(transparent)]\n+pub struct IoVec<'a> {\n+    vec: iovec,\n+    _p: PhantomData<&'a [u8]>,\n+}\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec {\n+            vec: iovec {\n+                iov_base: buf.as_ptr() as *mut u8 as *mut c_void,\n+                iov_len: buf.len()\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+}\n+\n+pub struct IoVecMut<'a> {\n+    vec: iovec,\n+    _p: PhantomData<&'a mut [u8]>,\n+}\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut {\n+            vec: iovec {\n+                iov_base: buf.as_mut_ptr() as *mut c_void,\n+                iov_len: buf.len()\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+}"}, {"sha": "4775e29fb570919c817818b6d64b34677808de52", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -5,7 +5,7 @@ macro_rules! unimpl {\n pub mod net {\n     #![allow(warnings)]\n     use fmt;\n-    use io;\n+    use io::{self, IoVec, IoVecMut};\n     use libc;\n     use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n     use sys_common::{AsInner, FromInner, IntoInner};\n@@ -46,6 +46,10 @@ pub mod net {\n             unimpl!();\n         }\n \n+        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n         pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n             unimpl!();\n         }\n@@ -62,6 +66,10 @@ pub mod net {\n             unimpl!();\n         }\n \n+        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n         pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n             unimpl!();\n         }\n@@ -144,10 +152,18 @@ pub mod net {\n             unimpl!();\n         }\n \n+        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n         pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n             unimpl!();\n         }\n \n+        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n         pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n             unimpl!();\n         }"}, {"sha": "0de1a223fbd12a478a6ea4fe3459c5fa1b94dcd7", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,6 +1,6 @@\n #![allow(missing_docs, nonstandard_style)]\n \n-use io::{self, ErrorKind};\n+use io::ErrorKind;\n use libc;\n \n #[cfg(any(rustdoc, target_os = \"linux\"))] pub use os::linux as platform;\n@@ -39,6 +39,7 @@ pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n pub mod memchr;\n+pub mod io;\n pub mod mutex;\n #[cfg(not(target_os = \"l4re\"))]\n pub mod net;\n@@ -126,15 +127,15 @@ macro_rules! impl_is_minus_one {\n \n impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n-pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+pub fn cvt<T: IsMinusOne>(t: T) -> ::io::Result<T> {\n     if t.is_minus_one() {\n-        Err(io::Error::last_os_error())\n+        Err(::io::Error::last_os_error())\n     } else {\n         Ok(t)\n     }\n }\n \n-pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n+pub fn cvt_r<T, F>(mut f: F) -> ::io::Result<T>\n     where T: IsMinusOne,\n           F: FnMut() -> T\n {"}, {"sha": "521d9b425179b438b426e03b89a3e2e4d4b5f90d", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,5 +1,5 @@\n use ffi::CStr;\n-use io;\n+use io::{self, IoVec, IoVecMut};\n use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n use mem;\n use net::{SocketAddr, Shutdown};\n@@ -241,6 +241,10 @@ impl Socket {\n         self.recv_with_flags(buf, MSG_PEEK)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n     fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n                             -> io::Result<(usize, SocketAddr)> {\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n@@ -269,6 +273,10 @@ impl Socket {\n         self.0.write(buf)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n         let timeout = match dur {\n             Some(dur) => {"}, {"sha": "8b02d3fd19d304f19d5c58a444e2ab8dfdc41678", "filename": "src/libstd/sys/wasm/io.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fio.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -0,0 +1,32 @@\n+pub struct IoVec<'a>(&'a [u8]);\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        IoVec(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoVecMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        IoVecMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "e71c6bcd7fe76dc447a5813d09f88f7aa36349f3", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -14,7 +14,6 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-use io;\n use os::raw::c_char;\n use ptr;\n use sys::os_str::Buf;\n@@ -29,6 +28,7 @@ pub mod backtrace;\n pub mod cmath;\n pub mod env;\n pub mod fs;\n+pub mod io;\n pub mod memchr;\n pub mod net;\n pub mod os;\n@@ -63,17 +63,17 @@ cfg_if! {\n pub fn init() {\n }\n \n-pub fn unsupported<T>() -> io::Result<T> {\n+pub fn unsupported<T>() -> ::io::Result<T> {\n     Err(unsupported_err())\n }\n \n-pub fn unsupported_err() -> io::Error {\n-    io::Error::new(io::ErrorKind::Other,\n+pub fn unsupported_err() -> ::io::Error {\n+    ::io::Error::new(::io::ErrorKind::Other,\n                    \"operation not supported on wasm yet\")\n }\n \n-pub fn decode_error_kind(_code: i32) -> io::ErrorKind {\n-    io::ErrorKind::Other\n+pub fn decode_error_kind(_code: i32) -> ::io::ErrorKind {\n+    ::io::ErrorKind::Other\n }\n \n // This enum is used as the storage for a bunch of types which can't actually"}, {"sha": "d9f5d538432055d59c086479e6e555469e7a8edd", "filename": "src/libstd/sys/wasm/net.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,5 +1,5 @@\n use fmt;\n-use io;\n+use io::{self, IoVec, IoVecMut};\n use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n use time::Duration;\n use sys::{unsupported, Void};\n@@ -40,10 +40,18 @@ impl TcpStream {\n         match self.0 {}\n     }\n \n+    pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n     pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n         match self.0 {}\n     }\n \n+    pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         match self.0 {}\n     }"}, {"sha": "a78b599204b200ddeddecd41c52c9af0ca6065d8", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -57,6 +57,9 @@ pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n pub type LPSTR = *mut CHAR;\n pub type LPWSTR = *mut WCHAR;\n pub type LPFILETIME = *mut FILETIME;\n+pub type LPWSABUF = *mut WSABUF;\n+pub type LPWSAOVERLAPPED = *mut c_void;\n+pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE = *mut c_void;\n \n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n pub type PLARGE_INTEGER = *mut c_longlong;\n@@ -324,6 +327,12 @@ pub struct WSADATA {\n     pub szSystemStatus: [u8; WSASYS_STATUS_LEN + 1],\n }\n \n+#[repr(C)]\n+pub struct WSABUF {\n+    pub len: ULONG,\n+    pub buf: *mut CHAR,\n+}\n+\n #[repr(C)]\n pub struct WSAPROTOCOL_INFO {\n     pub dwServiceFlags1: DWORD,\n@@ -988,6 +997,22 @@ extern \"system\" {\n                                dwProcessId: DWORD,\n                                lpProtocolInfo: LPWSAPROTOCOL_INFO)\n                                -> c_int;\n+    pub fn WSASend(s: SOCKET,\n+                   lpBuffers: LPWSABUF,\n+                   dwBufferCount: DWORD,\n+                   lpNumberOfBytesSent: LPDWORD,\n+                   dwFlags: DWORD,\n+                   lpOverlapped: LPWSAOVERLAPPED,\n+                   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE)\n+                   -> c_int;\n+    pub fn WSARecv(s: SOCKET,\n+                   lpBuffers: LPWSABUF,\n+                   dwBufferCount: DWORD,\n+                   lpNumberOfBytesRecvd: LPDWORD,\n+                   lpFlags: LPDWORD,\n+                   lpOverlapped: LPWSAOVERLAPPED,\n+                   lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE)\n+                   -> c_int;\n     pub fn GetCurrentProcessId() -> DWORD;\n     pub fn WSASocketW(af: c_int,\n                       kind: c_int,"}, {"sha": "662e304792386e303a4633d2164c02736faf7f3f", "filename": "src/libstd/sys/windows/io.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -0,0 +1,63 @@\n+use marker::PhantomData;\n+use slice;\n+use sys::c;\n+\n+#[repr(transparent)]\n+pub struct IoVec<'a> {\n+    vec: c::WSABUF,\n+    _p: PhantomData<&'a [u8]>,\n+}\n+\n+impl<'a> IoVec<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoVec<'a> {\n+        assert!(buf.len() <= c::ULONG::max_value() as usize);\n+        IoVec {\n+            vec: c::WSABUF {\n+                len: buf.len() as c::ULONG,\n+                buf: buf.as_ptr() as *mut u8 as *mut c::CHAR,\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize)\n+        }\n+    }\n+}\n+\n+pub struct IoVecMut<'a> {\n+    vec: c::WSABUF,\n+    _p: PhantomData<&'a mut [u8]>,\n+}\n+\n+impl<'a> IoVecMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoVecMut<'a> {\n+        assert!(buf.len() <= c::ULONG::max_value() as usize);\n+        IoVecMut {\n+            vec: c::WSABUF {\n+                len: buf.len() as c::ULONG,\n+                buf: buf.as_mut_ptr() as *mut c::CHAR,\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.buf as *mut u8, self.vec.len as usize)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self.vec.buf as *mut u8, self.vec.len as usize)\n+        }\n+    }\n+}"}, {"sha": "56c76a169feb8959519308d5d0111489a5174aa7", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -2,7 +2,7 @@\n \n use ptr;\n use ffi::{OsStr, OsString};\n-use io::{self, ErrorKind};\n+use io::ErrorKind;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n@@ -26,6 +26,7 @@ pub mod ext;\n pub mod fast_thread_local;\n pub mod fs;\n pub mod handle;\n+pub mod io;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n@@ -75,12 +76,12 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n-    fn inner(s: &OsStr) -> io::Result<Vec<u16>> {\n+pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> ::io::Result<Vec<u16>> {\n+    fn inner(s: &OsStr) -> ::io::Result<Vec<u16>> {\n         let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n         if maybe_result.iter().any(|&u| u == 0) {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"strings passed to WinAPI cannot contain NULs\"));\n+            return Err(::io::Error::new(::io::ErrorKind::InvalidInput,\n+                                        \"strings passed to WinAPI cannot contain NULs\"));\n         }\n         maybe_result.push(0);\n         Ok(maybe_result)\n@@ -102,7 +103,7 @@ pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n // Once the syscall has completed (errors bail out early) the second closure is\n // yielded the data which has been read from the syscall. The return value\n // from this closure is then the return value of the function.\n-fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n+fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> ::io::Result<T>\n     where F1: FnMut(*mut u16, c::DWORD) -> c::DWORD,\n           F2: FnOnce(&[u16]) -> T\n {\n@@ -134,7 +135,7 @@ fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n             c::SetLastError(0);\n             let k = match f1(buf.as_mut_ptr(), n as c::DWORD) {\n                 0 if c::GetLastError() == 0 => 0,\n-                0 => return Err(io::Error::last_os_error()),\n+                0 => return Err(::io::Error::last_os_error()),\n                 n => n,\n             } as usize;\n             if k == n && c::GetLastError() == c::ERROR_INSUFFICIENT_BUFFER {\n@@ -157,7 +158,7 @@ fn wide_char_to_multi_byte(code_page: u32,\n                            flags: u32,\n                            s: &[u16],\n                            no_default_char: bool)\n-                           -> io::Result<Vec<i8>> {\n+                           -> ::io::Result<Vec<i8>> {\n     unsafe {\n         let mut size = c::WideCharToMultiByte(code_page,\n                                               flags,\n@@ -168,7 +169,7 @@ fn wide_char_to_multi_byte(code_page: u32,\n                                               ptr::null(),\n                                               ptr::null_mut());\n         if size == 0 {\n-            return Err(io::Error::last_os_error());\n+            return Err(::io::Error::last_os_error());\n         }\n \n         let mut buf = Vec::with_capacity(size as usize);\n@@ -185,10 +186,10 @@ fn wide_char_to_multi_byte(code_page: u32,\n                                       if no_default_char { &mut used_default_char }\n                                       else { ptr::null_mut() });\n         if size == 0 {\n-            return Err(io::Error::last_os_error());\n+            return Err(::io::Error::last_os_error());\n         }\n         if no_default_char && used_default_char == c::TRUE {\n-            return Err(io::Error::new(io::ErrorKind::InvalidData,\n+            return Err(::io::Error::new(::io::ErrorKind::InvalidData,\n                                       \"string cannot be converted to requested code page\"));\n         }\n \n@@ -220,9 +221,9 @@ macro_rules! impl_is_zero {\n \n impl_is_zero! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n \n-pub fn cvt<I: IsZero>(i: I) -> io::Result<I> {\n+pub fn cvt<I: IsZero>(i: I) -> ::io::Result<I> {\n     if i.is_zero() {\n-        Err(io::Error::last_os_error())\n+        Err(::io::Error::last_os_error())\n     } else {\n         Ok(i)\n     }"}, {"sha": "76be26a9d1a578a01ae0b8dc69974809ccf76b6e", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,7 +1,7 @@\n #![unstable(issue = \"0\", feature = \"windows_net\")]\n \n use cmp;\n-use io::{self, Read};\n+use io::{self, Read, IoVec, IoVecMut};\n use libc::{c_int, c_void, c_ulong, c_long};\n use mem;\n use net::{SocketAddr, Shutdown};\n@@ -207,6 +207,30 @@ impl Socket {\n         self.recv_with_flags(buf, 0)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        // On unix when a socket is shut down all further reads return 0, so we\n+        // do the same on windows to map a shut down socket to returning EOF.\n+        let len = cmp::min(bufs.len(), c::DWORD::max_value() as usize) as c::DWORD;\n+        let mut nread = 0;\n+        let mut flags = 0;\n+        unsafe {\n+            let ret = c::WSARecv(\n+                self.0,\n+                bufs.as_mut_ptr() as *mut c::WSABUF,\n+                len,\n+                &mut nread,\n+                &mut flags,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+            );\n+            match ret {\n+                0 => Ok(nread as usize),\n+                _ if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n+                _ => Err(last_error()),\n+            }\n+        }\n+    }\n+\n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.recv_with_flags(buf, c::MSG_PEEK)\n     }\n@@ -243,6 +267,23 @@ impl Socket {\n         self.recv_from_with_flags(buf, c::MSG_PEEK)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        let len = cmp::min(bufs.len(), c::DWORD::max_value() as usize) as c::DWORD;\n+        let mut nwritten = 0;\n+        unsafe {\n+            cvt(c::WSASend(\n+                self.0,\n+                bufs.as_ptr() as *const c::WSABUF as *mut c::WSABUF,\n+                len,\n+                &mut nwritten,\n+                0,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+            ))?;\n+        }\n+        Ok(nwritten as usize)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>,\n                        kind: c_int) -> io::Result<()> {\n         let timeout = match dur {"}, {"sha": "0d60593ce1f2ff3939517e782eff75e85a14525d", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -1,7 +1,7 @@\n use cmp;\n use ffi::CString;\n use fmt;\n-use io::{self, Error, ErrorKind};\n+use io::{self, Error, ErrorKind, IoVec, IoVecMut};\n use libc::{c_int, c_void};\n use mem;\n use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n@@ -255,6 +255,10 @@ impl TcpStream {\n         self.inner.read(buf)\n     }\n \n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.inner.read_vectored(bufs)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let ret = cvt(unsafe {\n@@ -266,6 +270,10 @@ impl TcpStream {\n         Ok(ret as usize)\n     }\n \n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.inner.write_vectored(bufs)\n+    }\n+\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         sockname(|buf, len| unsafe {\n             c::getpeername(*self.inner.as_inner(), buf, len)"}, {"sha": "9a6c97dbca015599236c3904f4c8ed1d234b13de", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb162e69449b423c5aed0d9c39f6c046fa300c30/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=fb162e69449b423c5aed0d9c39f6c046fa300c30", "patch": "@@ -134,7 +134,9 @@ fn check(cache: &mut Cache,\n        file.ends_with(\"log/index.html\") ||\n        file.ends_with(\"ty/struct.Slice.html\") ||\n        file.ends_with(\"ty/enum.Attributes.html\") ||\n-       file.ends_with(\"ty/struct.SymbolName.html\") {\n+       file.ends_with(\"ty/struct.SymbolName.html\") ||\n+       file.ends_with(\"io/struct.IoVec.html\") ||\n+       file.ends_with(\"io/struct.IoVecMut.html\") {\n         return None;\n     }\n     // FIXME(#32553)"}]}