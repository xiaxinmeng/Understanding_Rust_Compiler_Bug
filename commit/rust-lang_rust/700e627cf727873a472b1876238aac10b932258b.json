{"sha": "700e627cf727873a472b1876238aac10b932258b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMGU2MjdjZjcyNzg3M2E0NzJiMTg3NjIzOGFhYzEwYjkzMjI1OGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-10T18:39:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:14:19Z"}, "message": "test: Fixup many library unit tests", "tree": {"sha": "2869ad99d029315b6b7170ab3685b7f3a9bd1144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2869ad99d029315b6b7170ab3685b7f3a9bd1144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/700e627cf727873a472b1876238aac10b932258b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/700e627cf727873a472b1876238aac10b932258b", "html_url": "https://github.com/rust-lang/rust/commit/700e627cf727873a472b1876238aac10b932258b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/700e627cf727873a472b1876238aac10b932258b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dddfbe0441476cd366943fcf14f4896e6bb09851", "url": "https://api.github.com/repos/rust-lang/rust/commits/dddfbe0441476cd366943fcf14f4896e6bb09851", "html_url": "https://github.com/rust-lang/rust/commit/dddfbe0441476cd366943fcf14f4896e6bb09851"}], "stats": {"total": 584, "additions": 105, "deletions": 479}, "files": [{"sha": "391439bcdf2ff93beecabfcf1cc4834d79946aeb", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -943,7 +943,7 @@ mod test {\n     use std::clone::Clone;\n     use std::iter::Iterator;\n     use std::option::Option::{Some, None, self};\n-    use std::rand;\n+    use std::__rand::{thread_rng, Rng};\n     use std::thread;\n     use std::vec::Vec;\n \n@@ -1095,7 +1095,7 @@ mod test {\n         let mut v = vec![];\n         for i in 0..sz {\n             check_links(&m);\n-            let r: u8 = rand::random();\n+            let r: u8 = thread_rng().next_u32() as u8;\n             match r % 6 {\n                 0 => {\n                     m.pop_back();"}, {"sha": "07f8dab0c4947bbed8d73c6160268000fc4b54ac", "filename": "src/libcollectionstest/bench.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollectionstest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollectionstest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbench.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -12,14 +12,13 @@ macro_rules! map_insert_rand_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n         pub fn $name(b: &mut ::test::Bencher) {\n-            use std::rand;\n-            use std::rand::Rng;\n+            use std::__rand::{thread_rng, Rng};\n             use test::black_box;\n \n             let n: usize = $n;\n             let mut map = $map::new();\n             // setup\n-            let mut rng = rand::weak_rng();\n+            let mut rng = thread_rng();\n \n             for _ in 0..n {\n                 let i = rng.gen::<usize>() % n;\n@@ -67,16 +66,15 @@ macro_rules! map_find_rand_bench {\n         #[bench]\n         pub fn $name(b: &mut ::test::Bencher) {\n             use std::iter::Iterator;\n-            use std::rand::Rng;\n-            use std::rand;\n+            use std::__rand::{thread_rng, Rng};\n             use std::vec::Vec;\n             use test::black_box;\n \n             let mut map = $map::new();\n             let n: usize = $n;\n \n             // setup\n-            let mut rng = rand::weak_rng();\n+            let mut rng = rand::thread_rng();\n             let mut keys: Vec<_> = (0..n).map(|_| rng.gen::<usize>() % n).collect();\n \n             for &k in &keys {"}, {"sha": "a6ce9692e701b3028ed69099a45d53d22b4e7b47", "filename": "src/libcollectionstest/bit/vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -633,15 +633,14 @@ fn test_bit_vec_extend() {\n mod bench {\n     use std::collections::BitVec;\n     use std::u32;\n-    use std::rand::{Rng, self};\n+    use std::__rand::{Rng, thread_rng};\n \n     use test::{Bencher, black_box};\n \n     const BENCH_BITS : usize = 1 << 14;\n \n-    fn rng() -> rand::IsaacRng {\n-        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::SeedableRng::from_seed(seed)\n+    fn rng() -> ThreadRng {\n+        thread_rng()\n     }\n \n     #[bench]"}, {"sha": "9b2ec0eacdcdf700cb0fc1af4bbd111e385c1753", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -251,7 +251,7 @@ fn test_entry(){\n \n mod bench {\n     use std::collections::BTreeMap;\n-    use std::rand::{Rng, weak_rng};\n+    use std::rand::{Rng, thread_rng};\n \n     use test::{Bencher, black_box};\n \n@@ -269,7 +269,7 @@ mod bench {\n \n     fn bench_iter(b: &mut Bencher, size: i32) {\n         let mut map = BTreeMap::<i32, i32>::new();\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n \n         for _ in 0..size {\n             map.insert(rng.gen(), rng.gen());"}, {"sha": "e3022fc77faf69ee92626cb564f363166e814ddf", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -1296,7 +1296,7 @@ fn test_to_vec() {\n mod bench {\n     use std::iter::repeat;\n     use std::{mem, ptr};\n-    use std::rand::{Rng, weak_rng};\n+    use std::rand::{Rng, thread_rng};\n \n     use test::{Bencher, black_box};\n \n@@ -1465,7 +1465,7 @@ mod bench {\n \n     #[bench]\n     fn random_inserts(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = repeat((0, 0)).take(30).collect();\n             for _ in 0..100 {\n@@ -1477,7 +1477,7 @@ mod bench {\n     }\n     #[bench]\n     fn random_removes(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = repeat((0, 0)).take(130).collect();\n             for _ in 0..100 {\n@@ -1489,7 +1489,7 @@ mod bench {\n \n     #[bench]\n     fn sort_random_small(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = rng.gen_iter::<u64>().take(5).collect();\n             v.sort();\n@@ -1499,7 +1499,7 @@ mod bench {\n \n     #[bench]\n     fn sort_random_medium(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = rng.gen_iter::<u64>().take(100).collect();\n             v.sort();\n@@ -1509,7 +1509,7 @@ mod bench {\n \n     #[bench]\n     fn sort_random_large(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = rng.gen_iter::<u64>().take(10000).collect();\n             v.sort();\n@@ -1530,7 +1530,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_random_small(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>().take(5)\n                            .collect::<Vec<BigSortable>>();\n@@ -1541,7 +1541,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_random_medium(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>().take(100)\n                            .collect::<Vec<BigSortable>>();\n@@ -1552,7 +1552,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_random_large(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>().take(10000)\n                            .collect::<Vec<BigSortable>>();"}, {"sha": "cab2175f897819a80566347fe9eee68c5dc6d413", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -169,85 +169,85 @@ fn test_radix_base_too_large() {\n mod u32 {\n     use test::Bencher;\n     use core::fmt::radix;\n-    use std::rand::{weak_rng, Rng};\n+    use std::__rand::{thread_rng, Rng};\n     use std::io::{Write, sink};\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:b}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_oct(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:o}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_hex(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:x}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_show(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:?}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{}\", radix(rng.gen::<u32>(), 36)) })\n     }\n }\n \n mod i32 {\n     use test::Bencher;\n     use core::fmt::radix;\n-    use std::rand::{weak_rng, Rng};\n+    use std::__rand::{thread_rng, Rng};\n     use std::io::{Write, sink};\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:b}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_oct(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:o}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_hex(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:x}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_show(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:?}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{}\", radix(rng.gen::<i32>(), 36)) })\n     }\n }"}, {"sha": "1e0e2018050baff53e4ba74c07adc4ac47548cad", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -155,12 +155,11 @@ pub fn inflate_bytes_zlib(bytes: &[u8]) -> Result<Bytes,Error> {\n mod tests {\n     #![allow(deprecated)]\n     use super::{inflate_bytes, deflate_bytes};\n-    use std::rand;\n-    use std::rand::Rng;\n+    use std::__rand::{thread_rng, Rng};\n \n     #[test]\n     fn test_flate_round_trip() {\n-        let mut r = rand::thread_rng();\n+        let mut r = thread_rng();\n         let mut words = vec![];\n         for _ in 0..20 {\n             let range = r.gen_range(1, 10);"}, {"sha": "d17165735ea5a7e584aa192953b1214d75cc6c2c", "filename": "src/librand/lib.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -516,25 +516,21 @@ pub struct Closed01<F>(pub F);\n \n #[cfg(test)]\n mod test {\n-    use std::rand;\n+    use std::__rand as rand;\n \n-    pub struct MyRng<R> { inner: R }\n+    pub struct MyRng { inner: Box<rand::Rng> }\n \n     impl<R: rand::Rng> ::Rng for MyRng<R> {\n         fn next_u32(&mut self) -> u32 {\n-            fn next<T: rand::Rng>(t: &mut T) -> u32 {\n-                use std::rand::Rng;\n-                t.next_u32()\n-            }\n-            next(&mut self.inner)\n+            rand::Rng::next_u32(&mut self.inner)\n         }\n     }\n \n     pub fn rng() -> MyRng<rand::ThreadRng> {\n-        MyRng { inner: rand::thread_rng() }\n+        MyRng { inner: Box::new(rand::thread_rng()) }\n     }\n \n-    pub fn weak_rng() -> MyRng<rand::XorShiftRng> {\n-        MyRng { inner: rand::weak_rng() }\n+    pub fn weak_rng() -> MyRng<rand::ThreadRng> {\n+        MyRng { inner: Box::new(rand::thread_rng()) }\n     }\n }"}, {"sha": "2f37451ecbb3a095318c0ffefc1b47d0bccff72a", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -211,55 +211,3 @@ impl<T:Rand> Rand for Option<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::rand::{Rng, thread_rng, Open01, Closed01};\n-\n-    struct ConstantRng(u64);\n-    impl Rng for ConstantRng {\n-        fn next_u32(&mut self) -> u32 {\n-            let ConstantRng(v) = *self;\n-            v as u32\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            let ConstantRng(v) = *self;\n-            v\n-        }\n-    }\n-\n-    #[test]\n-    fn floating_point_edge_cases() {\n-        // the test for exact equality is correct here.\n-        assert!(ConstantRng(0xffff_ffff).gen::<f32>() != 1.0);\n-        assert!(ConstantRng(0xffff_ffff_ffff_ffff).gen::<f64>() != 1.0);\n-    }\n-\n-    #[test]\n-    fn rand_open() {\n-        // this is unlikely to catch an incorrect implementation that\n-        // generates exactly 0 or 1, but it keeps it sane.\n-        let mut rng = thread_rng();\n-        for _ in 0..1_000 {\n-            // strict inequalities\n-            let Open01(f) = rng.gen::<Open01<f64>>();\n-            assert!(0.0 < f && f < 1.0);\n-\n-            let Open01(f) = rng.gen::<Open01<f32>>();\n-            assert!(0.0 < f && f < 1.0);\n-        }\n-    }\n-\n-    #[test]\n-    fn rand_closed() {\n-        let mut rng = thread_rng();\n-        for _ in 0..1_000 {\n-            // strict inequalities\n-            let Closed01(f) = rng.gen::<Closed01<f64>>();\n-            assert!(0.0 <= f && f <= 1.0);\n-\n-            let Closed01(f) = rng.gen::<Closed01<f32>>();\n-            assert!(0.0 <= f && f <= 1.0);\n-        }\n-    }\n-}"}, {"sha": "2e4dedd2ad27dbabb581294fc5f63e3b2f54de44", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -68,7 +68,7 @@ pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n mod test {\n     use tempdir::TempDir;\n     use std::fs::{self, File};\n-    use std::path::{Path, PathBuf};\n+    use super::realpath;\n \n     #[test]\n     fn realpath_works() {"}, {"sha": "620ea40b48a35e141b8261da183db1e7d744e300", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -2627,9 +2627,9 @@ mod tests {\n     use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n                 StackElement, Stack, Decoder, Encoder, EncoderError};\n     use std::{i64, u64, f32, f64};\n+    use std::io::prelude::*;\n     use std::collections::BTreeMap;\n     use std::string;\n-    use std::old_io::Writer;\n \n     #[derive(RustcDecodable, Eq, PartialEq, Debug)]\n     struct OptionData {\n@@ -3464,7 +3464,6 @@ mod tests {\n     #[test]\n     fn test_encode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n-        use std::old_io::Writer;\n         use std::collections::HashMap;\n         let mut hm: HashMap<usize, bool> = HashMap::new();\n         hm.insert(1, true);\n@@ -3480,7 +3479,6 @@ mod tests {\n     #[test]\n     fn test_prettyencode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n-        use std::old_io::Writer;\n         use std::collections::HashMap;\n         let mut hm: HashMap<usize, bool> = HashMap::new();\n         hm.insert(1, true);"}, {"sha": "dde79b123e602f456a9c3cb8d2e7371d64abbb6e", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -35,7 +35,7 @@ Core encoding and decoding interfaces.\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(str_char)]\n-#![cfg_attr(test, feature(test, old_io))]\n+#![cfg_attr(test, feature(test))]\n \n // test harness access\n #[cfg(test)] extern crate test;"}, {"sha": "d0d71a128b6e53e2c69e4294bbdf50a8b9058ebe", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -1631,7 +1631,7 @@ mod test_map {\n     use super::Entry::{Occupied, Vacant};\n     use iter::{range_inclusive, range_step_inclusive, repeat};\n     use cell::RefCell;\n-    use rand::{weak_rng, Rng};\n+    use rand::{thread_rng, Rng};\n \n     #[test]\n     fn test_create_capacity_zero() {\n@@ -2290,7 +2290,7 @@ mod test_map {\n         }\n \n         let mut m = HashMap::new();\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n \n         // Populate the map with some items.\n         for _ in 0..50 {"}, {"sha": "d519e1df13b9a3fa3df86ce93ab575fdaa6fc585", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -123,7 +123,7 @@ pub struct WalkDir {\n /// Opening a file for both reading and writing, as well as creating it if it\n /// doesn't exist:\n ///\n-/// ```\n+/// ```no_run\n /// use std::fs::OpenOptions;\n ///\n /// let file = OpenOptions::new()\n@@ -1195,7 +1195,8 @@ mod tests {\n \n     pub fn tmpdir() -> TempDir {\n         let p = env::temp_dir();\n-        let ret = p.join(&format!(\"rust-{}\", rand::random::<u32>()));\n+        let mut r = rand::thread_rng();\n+        let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n         check!(fs::create_dir(&ret));\n         TempDir(ret)\n     }"}, {"sha": "b2bcbaa7b1c2b212cdca06ef2283915d069c5629", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -288,7 +288,7 @@ mod rand;\n #[doc(hidden)]\n #[unstable(feature = \"rand\")]\n pub mod __rand {\n-    pub use rand::{thread_rng, Rng};\n+    pub use rand::{thread_rng, ThreadRng, Rng};\n }\n \n // Modules that exist purely to document + host impl docs for primitive types"}, {"sha": "8ab66f2328fb6f837d2e2361fda5fb5487d5edbe", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -464,7 +464,7 @@ mod bench {\n \n     mod usize {\n         use super::test::Bencher;\n-        use rand::{weak_rng, Rng};\n+        use rand::{thread_rng, Rng};\n         use std::fmt;\n \n         #[inline]\n@@ -474,38 +474,38 @@ mod bench {\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 36); })\n         }\n     }\n \n     mod isize {\n         use super::test::Bencher;\n-        use rand::{weak_rng, Rng};\n+        use rand::{thread_rng, Rng};\n         use std::fmt;\n \n         #[inline]\n@@ -515,43 +515,43 @@ mod bench {\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 36); })\n         }\n     }\n \n     mod f64 {\n         use super::test::Bencher;\n-        use rand::{weak_rng, Rng};\n+        use rand::{thread_rng, Rng};\n         use f64;\n \n         #[bench]\n         fn float_to_string(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { f64::to_string(rng.gen()); })\n         }\n     }"}, {"sha": "a92c6318c3264fd87eea53c27be5beda282049d8", "filename": "src/libstd/process.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -534,8 +534,6 @@ mod tests {\n     use io::prelude::*;\n \n     use io::ErrorKind;\n-    use old_path::{self, GenericPath};\n-    use old_io::fs::PathExtensions;\n     use rt::running_on_valgrind;\n     use str;\n     use super::{Command, Output, Stdio};\n@@ -748,43 +746,6 @@ mod tests {\n         cmd\n     }\n \n-    #[cfg(not(target_arch = \"aarch64\"))]\n-    #[test]\n-    fn test_keep_current_working_dir() {\n-        use os;\n-        let prog = pwd_cmd().spawn().unwrap();\n-\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().stdout).unwrap();\n-        let parent_dir = ::env::current_dir().unwrap().to_str().unwrap().to_string();\n-        let parent_dir = old_path::Path::new(parent_dir);\n-        let child_dir = old_path::Path::new(output.trim());\n-\n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n-\n-        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n-        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    }\n-\n-    #[test]\n-    fn test_change_working_directory() {\n-        use os;\n-        // test changing to the parent of os::getcwd() because we know\n-        // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = ::env::current_dir().unwrap().to_str().unwrap().to_string();\n-        let parent_dir = old_path::Path::new(parent_dir).dir_path();\n-        let result = pwd_cmd().current_dir(parent_dir.as_str().unwrap()).output().unwrap();\n-\n-        let output = String::from_utf8(result.stdout).unwrap();\n-        let child_dir = old_path::Path::new(output.trim());\n-\n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n-\n-        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n-        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    }\n-\n     #[cfg(all(unix, not(target_os=\"android\")))]\n     pub fn env_cmd() -> Command {\n         Command::new(\"env\")"}, {"sha": "ca5a50f289a611ed0e14b9a9d2d1a017943af84c", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -354,261 +354,3 @@ impl Rng for ThreadRng {\n         self.rng.borrow_mut().fill_bytes(bytes)\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use super::{Rng, thread_rng, random, SeedableRng, StdRng, sample};\n-    use iter::{order, repeat};\n-\n-    struct ConstRng { i: u64 }\n-    impl Rng for ConstRng {\n-        fn next_u32(&mut self) -> u32 { self.i as u32 }\n-        fn next_u64(&mut self) -> u64 { self.i }\n-\n-        // no fill_bytes on purpose\n-    }\n-\n-    #[test]\n-    fn test_fill_bytes_default() {\n-        let mut r = ConstRng { i: 0x11_22_33_44_55_66_77_88 };\n-\n-        // check every remainder mod 8, both in small and big vectors.\n-        let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n-                       80, 81, 82, 83, 84, 85, 86, 87];\n-        for &n in &lengths {\n-            let mut v = repeat(0).take(n).collect::<Vec<_>>();\n-            r.fill_bytes(&mut v);\n-\n-            // use this to get nicer error messages.\n-            for (i, &byte) in v.iter().enumerate() {\n-                if byte == 0 {\n-                    panic!(\"byte {} of {} is zero\", i, n)\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_gen_range() {\n-        let mut r = thread_rng();\n-        for _ in 0..1000 {\n-            let a = r.gen_range(-3, 42);\n-            assert!(a >= -3 && a < 42);\n-            assert_eq!(r.gen_range(0, 1), 0);\n-            assert_eq!(r.gen_range(-12, -11), -12);\n-        }\n-\n-        for _ in 0..1000 {\n-            let a = r.gen_range(10, 42);\n-            assert!(a >= 10 && a < 42);\n-            assert_eq!(r.gen_range(0, 1), 0);\n-            assert_eq!(r.gen_range(3_000_000, 3_000_001), 3_000_000);\n-        }\n-\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_gen_range_panic_int() {\n-        let mut r = thread_rng();\n-        r.gen_range(5, -2);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_gen_range_panic_uint() {\n-        let mut r = thread_rng();\n-        r.gen_range(5, 2);\n-    }\n-\n-    #[test]\n-    fn test_gen_f64() {\n-        let mut r = thread_rng();\n-        let a = r.gen::<f64>();\n-        let b = r.gen::<f64>();\n-        debug!(\"{:?}\", (a, b));\n-    }\n-\n-    #[test]\n-    fn test_gen_weighted_bool() {\n-        let mut r = thread_rng();\n-        assert_eq!(r.gen_weighted_bool(0), true);\n-        assert_eq!(r.gen_weighted_bool(1), true);\n-    }\n-\n-    #[test]\n-    fn test_gen_ascii_str() {\n-        let mut r = thread_rng();\n-        assert_eq!(r.gen_ascii_chars().take(0).count(), 0);\n-        assert_eq!(r.gen_ascii_chars().take(10).count(), 10);\n-        assert_eq!(r.gen_ascii_chars().take(16).count(), 16);\n-    }\n-\n-    #[test]\n-    fn test_gen_vec() {\n-        let mut r = thread_rng();\n-        assert_eq!(r.gen_iter::<u8>().take(0).count(), 0);\n-        assert_eq!(r.gen_iter::<u8>().take(10).count(), 10);\n-        assert_eq!(r.gen_iter::<f64>().take(16).count(), 16);\n-    }\n-\n-    #[test]\n-    fn test_choose() {\n-        let mut r = thread_rng();\n-        assert_eq!(r.choose(&[1, 1, 1]).cloned(), Some(1));\n-\n-        let v: &[isize] = &[];\n-        assert_eq!(r.choose(v), None);\n-    }\n-\n-    #[test]\n-    fn test_shuffle() {\n-        let mut r = thread_rng();\n-        let empty: &mut [isize] = &mut [];\n-        r.shuffle(empty);\n-        let mut one = [1];\n-        r.shuffle(&mut one);\n-        let b: &[_] = &[1];\n-        assert_eq!(one, b);\n-\n-        let mut two = [1, 2];\n-        r.shuffle(&mut two);\n-        assert!(two == [1, 2] || two == [2, 1]);\n-\n-        let mut x = [1, 1, 1];\n-        r.shuffle(&mut x);\n-        let b: &[_] = &[1, 1, 1];\n-        assert_eq!(x, b);\n-    }\n-\n-    #[test]\n-    fn test_thread_rng() {\n-        let mut r = thread_rng();\n-        r.gen::<isize>();\n-        let mut v = [1, 1, 1];\n-        r.shuffle(&mut v);\n-        let b: &[_] = &[1, 1, 1];\n-        assert_eq!(v, b);\n-        assert_eq!(r.gen_range(0, 1), 0);\n-    }\n-\n-    #[test]\n-    fn test_random() {\n-        // not sure how to test this aside from just getting some values\n-        let _n : usize = random();\n-        let _f : f32 = random();\n-        let _o : Option<Option<i8>> = random();\n-        let _many : ((),\n-                     (usize,\n-                      isize,\n-                      Option<(u32, (bool,))>),\n-                     (u8, i8, u16, i16, u32, i32, u64, i64),\n-                     (f32, (f64, (f64,)))) = random();\n-    }\n-\n-    #[test]\n-    fn test_sample() {\n-        let min_val = 1;\n-        let max_val = 100;\n-\n-        let mut r = thread_rng();\n-        let vals = (min_val..max_val).collect::<Vec<isize>>();\n-        let small_sample = sample(&mut r, vals.iter(), 5);\n-        let large_sample = sample(&mut r, vals.iter(), vals.len() + 5);\n-\n-        assert_eq!(small_sample.len(), 5);\n-        assert_eq!(large_sample.len(), vals.len());\n-\n-        assert!(small_sample.iter().all(|e| {\n-            **e >= min_val && **e <= max_val\n-        }));\n-    }\n-\n-    #[test]\n-    fn test_std_rng_seeded() {\n-        let s = thread_rng().gen_iter::<usize>().take(256).collect::<Vec<usize>>();\n-        let mut ra: StdRng = SeedableRng::from_seed(&*s);\n-        let mut rb: StdRng = SeedableRng::from_seed(&*s);\n-        assert!(order::equals(ra.gen_ascii_chars().take(100),\n-                              rb.gen_ascii_chars().take(100)));\n-    }\n-\n-    #[test]\n-    fn test_std_rng_reseed() {\n-        let s = thread_rng().gen_iter::<usize>().take(256).collect::<Vec<usize>>();\n-        let mut r: StdRng = SeedableRng::from_seed(&*s);\n-        let string1 = r.gen_ascii_chars().take(100).collect::<String>();\n-\n-        r.reseed(&s);\n-\n-        let string2 = r.gen_ascii_chars().take(100).collect::<String>();\n-        assert_eq!(string1, string2);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use prelude::v1::*;\n-\n-    use self::test::Bencher;\n-    use super::{XorShiftRng, StdRng, IsaacRng, Isaac64Rng, Rng};\n-    use super::{OsRng, weak_rng};\n-    use mem::size_of;\n-\n-    const RAND_BENCH_N: u64 = 100;\n-\n-    #[bench]\n-    fn rand_xorshift(b: &mut Bencher) {\n-        let mut rng: XorShiftRng = OsRng::new().unwrap().gen();\n-        b.iter(|| {\n-            for _ in 0..RAND_BENCH_N {\n-                rng.gen::<usize>();\n-            }\n-        });\n-        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n-    }\n-\n-    #[bench]\n-    fn rand_isaac(b: &mut Bencher) {\n-        let mut rng: IsaacRng = OsRng::new().unwrap().gen();\n-        b.iter(|| {\n-            for _ in 0..RAND_BENCH_N {\n-                rng.gen::<usize>();\n-            }\n-        });\n-        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n-    }\n-\n-    #[bench]\n-    fn rand_isaac64(b: &mut Bencher) {\n-        let mut rng: Isaac64Rng = OsRng::new().unwrap().gen();\n-        b.iter(|| {\n-            for _ in 0..RAND_BENCH_N {\n-                rng.gen::<usize>();\n-            }\n-        });\n-        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n-    }\n-\n-    #[bench]\n-    fn rand_std(b: &mut Bencher) {\n-        let mut rng = StdRng::new().unwrap();\n-        b.iter(|| {\n-            for _ in 0..RAND_BENCH_N {\n-                rng.gen::<usize>();\n-            }\n-        });\n-        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n-    }\n-\n-    #[bench]\n-    fn rand_shuffle_100(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n-        let x : &mut[usize] = &mut [1; 100];\n-        b.iter(|| {\n-            rng.shuffle(x);\n-        })\n-    }\n-}"}, {"sha": "60645707c6aeefde6ea4ef78d86bf86b7043507e", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -67,26 +67,25 @@ mod test {\n     use prelude::v1::*;\n \n     use super::ReaderRng;\n-    use old_io::MemReader;\n     use num::Int;\n     use rand::Rng;\n \n     #[test]\n     fn test_reader_rng_u64() {\n         // transmute from the target to avoid endianness concerns.\n-        let v = vec![0, 0, 0, 0, 0, 0, 0, 1,\n-                     0  , 0, 0, 0, 0, 0, 0, 2,\n-                     0,   0, 0, 0, 0, 0, 0, 3];\n-        let mut rng = ReaderRng::new(MemReader::new(v));\n+        let v = &[0, 0, 0, 0, 0, 0, 0, 1,\n+                  0  , 0, 0, 0, 0, 0, 0, 2,\n+                  0,   0, 0, 0, 0, 0, 0, 3][..];\n+        let mut rng = ReaderRng::new(v);\n \n         assert_eq!(rng.next_u64(), 1.to_be());\n         assert_eq!(rng.next_u64(), 2.to_be());\n         assert_eq!(rng.next_u64(), 3.to_be());\n     }\n     #[test]\n     fn test_reader_rng_u32() {\n-        let v = vec![0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3];\n-        let mut rng = ReaderRng::new(MemReader::new(v));\n+        let v = &[0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3][..];\n+        let mut rng = ReaderRng::new(v);\n \n         assert_eq!(rng.next_u32(), 1.to_be());\n         assert_eq!(rng.next_u32(), 2.to_be());\n@@ -97,7 +96,7 @@ mod test {\n         let v = [1, 2, 3, 4, 5, 6, 7, 8];\n         let mut w = [0; 8];\n \n-        let mut rng = ReaderRng::new(MemReader::new(v.to_vec()));\n+        let mut rng = ReaderRng::new(&v[..]);\n         rng.fill_bytes(&mut w);\n \n         assert!(v == w);\n@@ -106,7 +105,7 @@ mod test {\n     #[test]\n     #[should_panic]\n     fn test_reader_rng_insufficient_bytes() {\n-        let mut rng = ReaderRng::new(MemReader::new(vec!()));\n+        let mut rng = ReaderRng::new(&[][..]);\n         let mut v = [0; 3];\n         rng.fill_bytes(&mut v);\n     }"}, {"sha": "c47e23894327263f8ded2aa4ac2207b3de6ffc0e", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -728,7 +728,6 @@ mod test {\n     use any::Any;\n     use sync::mpsc::{channel, Sender};\n     use result;\n-    use std::old_io::{ChanReader, ChanWriter};\n     use super::{Builder};\n     use thread;\n     use thunk::Thunk;\n@@ -967,13 +966,11 @@ mod test {\n \n     #[test]\n     fn test_park_timeout_unpark_called_other_thread() {\n-        use std::old_io;\n-\n         for _ in 0..10 {\n             let th = thread::current();\n \n             let _guard = thread::spawn(move || {\n-                old_io::timer::sleep(Duration::milliseconds(50));\n+                super::sleep_ms(50);\n                 th.unpark();\n             });\n "}, {"sha": "a786d24ed8581426c778ac346ab16084e02b48db", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -43,7 +43,6 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n     /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n     /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n-    /// *Discrete & Computational Geometry 18*, 3 (Oct 1997), 305-363, Shewchuk J.R.\n     fn sum(&self) -> T;\n \n     /// Minimum value of the samples.\n@@ -334,8 +333,9 @@ pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n mod tests {\n     use stats::Stats;\n     use stats::Summary;\n-    use std::old_io::{self, Writer};\n     use std::f64;\n+    use std::io::prelude::*;\n+    use std::io;\n \n     macro_rules! assert_approx_eq {\n         ($a:expr, $b:expr) => ({\n@@ -350,7 +350,7 @@ mod tests {\n \n         let summ2 = Summary::new(samples);\n \n-        let mut w = old_io::stdout();\n+        let mut w = io::sink();\n         let w = &mut w;\n         (write!(w, \"\\n\")).unwrap();\n "}, {"sha": "327e2c9e0f996d7aac466c30a3dfa78ef5b19e40", "filename": "src/test/compile-fail/derive-no-std-not-supported.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Fcompile-fail%2Fderive-no-std-not-supported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Fcompile-fail%2Fderive-no-std-not-supported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderive-no-std-not-supported.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -15,12 +15,6 @@ extern crate core;\n extern crate rand;\n extern crate serialize as rustc_serialize;\n \n-#[derive(Rand)]  //~ ERROR this trait cannot be derived\n-//~^ WARNING `#[derive(Rand)]` is deprecated\n-struct Foo {\n-    x: u32,\n-}\n-\n #[derive(RustcEncodable)]  //~ ERROR this trait cannot be derived\n struct Bar {\n     x: u32,"}, {"sha": "fe84db08da9008f6af7349f7e4dc98fb16a9d08e", "filename": "src/test/run-make/save-analysis/SubDir/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -12,21 +12,18 @@\n \n use sub::sub2 as msalias;\n use sub::sub2;\n-use std::old_io::stdio::println;\n \n static yy: usize = 25;\n \n mod sub {\n     pub mod sub2 {\n-        use std::old_io::stdio::println;\n         pub mod sub3 {\n-            use std::old_io::stdio::println;\n             pub fn hello() {\n-                println(\"hello from module 3\");\n+                println!(\"hello from module 3\");\n             }\n         }\n         pub fn hello() {\n-            println(\"hello from a module\");\n+            println!(\"hello from a module\");\n         }\n \n         pub struct nested_struct {"}, {"sha": "fe0f32d97d6b102c07e0d49cd80293934503436c", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -10,7 +10,7 @@\n \n #![ crate_name = \"test\" ]\n #![allow(unstable)]\n-#![feature(box_syntax, old_io, rustc_private, core, zero_one)]\n+#![feature(box_syntax, rustc_private, core, zero_one)]\n \n extern crate graphviz;\n // A simple rust project\n@@ -19,7 +19,6 @@ extern crate flate as myflate;\n \n use std::collections::{HashMap,HashSet};\n use std::cell::RefCell;\n-use std::old_io::stdio::println;\n \n \n use sub::sub2 as msalias;\n@@ -61,15 +60,13 @@ fn test_tup_struct(x: TupStruct) -> isize {\n \n mod sub {\n     pub mod sub2 {\n-        use std::old_io::stdio::println;\n         pub mod sub3 {\n-            use std::old_io::stdio::println;\n             pub fn hello() {\n-                println(\"hello from module 3\");\n+                println!(\"hello from module 3\");\n             }\n         }\n         pub fn hello() {\n-            println(\"hello from a module\");\n+            println!(\"hello from a module\");\n         }\n \n         pub struct nested_struct {\n@@ -106,7 +103,7 @@ trait SomeTrait: SuperTrait {\n     fn Method(&self, x: u32) -> u32;\n \n     fn prov(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n+        println!(\"{}\", &x.to_string());\n         42\n     }\n     fn provided_method(&self) -> u32 {\n@@ -122,7 +119,7 @@ trait SubTrait: SomeTrait {\n \n impl SomeTrait for some_fields {\n     fn Method(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n+        println!(\"{}\", &x.to_string());\n         self.field1\n     }\n }\n@@ -134,7 +131,7 @@ impl SubTrait for some_fields {}\n \n impl some_fields {\n     fn stat(x: u32) -> u32 {\n-        println(&x.to_string());\n+        println!(\"{}\", &x.to_string());\n         42\n     }\n     fn stat2(x: &some_fields) -> u32 {\n@@ -194,53 +191,53 @@ enum SomeStructEnum {\n \n fn matchSomeEnum(val: SomeEnum) {\n     match val {\n-        SomeEnum::Ints(int1, int2) => { println(&(int1+int2).to_string()); }\n-        SomeEnum::Floats(float1, float2) => { println(&(float2*float1).to_string()); }\n-        SomeEnum::Strings(_, _, s3) => { println(s3); }\n+        SomeEnum::Ints(int1, int2) => { println!(\"{}\", &(int1+int2).to_string()); }\n+        SomeEnum::Floats(float1, float2) => { println!(\"{}\", &(float2*float1).to_string()); }\n+        SomeEnum::Strings(_, _, s3) => { println!(\"{}\", s3); }\n         SomeEnum::MyTypes(mt1, mt2) => {\n-            println(&(mt1.field1 - mt2.field1).to_string());\n+            println!(\"{}\", &(mt1.field1 - mt2.field1).to_string());\n         }\n     }\n }\n \n fn matchSomeStructEnum(se: SomeStructEnum) {\n     match se {\n-        SomeStructEnum::EnumStruct{a:a, ..} => println(&a.to_string()),\n-        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println(&f_2.field1.to_string()),\n-        SomeStructEnum::EnumStruct3{f1, ..} => println(&f1.field1.to_string()),\n+        SomeStructEnum::EnumStruct{a:a, ..} => println!(\"{}\", &a.to_string()),\n+        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println!(\"{}\", &f_2.field1.to_string()),\n+        SomeStructEnum::EnumStruct3{f1, ..} => println!(\"{}\", &f1.field1.to_string()),\n     }\n }\n \n \n fn matchSomeStructEnum2(se: SomeStructEnum) {\n     use SomeStructEnum::*;\n     match se {\n-        EnumStruct{a: ref aaa, ..} => println(&aaa.to_string()),\n-        EnumStruct2{f1, f2: f2} => println(&f1.field1.to_string()),\n-        EnumStruct3{f1, f3: SomeEnum::Ints(_, _), f2} => println(&f1.field1.to_string()),\n+        EnumStruct{a: ref aaa, ..} => println!(\"{}\", &aaa.to_string()),\n+        EnumStruct2{f1, f2: f2} => println!(\"{}\", &f1.field1.to_string()),\n+        EnumStruct3{f1, f3: SomeEnum::Ints(_, _), f2} => println!(\"{}\", &f1.field1.to_string()),\n         _ => {},\n     }\n }\n \n fn matchSomeOtherEnum(val: SomeOtherEnum) {\n     use SomeOtherEnum::{SomeConst2, SomeConst3};\n     match val {\n-        SomeOtherEnum::SomeConst1 => { println(\"I'm const1.\"); }\n-        SomeConst2 | SomeConst3 => { println(\"I'm const2 or const3.\"); }\n+        SomeOtherEnum::SomeConst1 => { println!(\"I'm const1.\"); }\n+        SomeConst2 | SomeConst3 => { println!(\"I'm const2 or const3.\"); }\n     }\n }\n \n fn hello<X: SomeTrait>((z, a) : (u32, String), ex: X) {\n     SameDir2::hello(43);\n \n-    println(&yy.to_string());\n+    println!(\"{}\", &yy.to_string());\n     let (x, y): (u32, u32) = (5, 3);\n-    println(&x.to_string());\n-    println(&z.to_string());\n+    println!(\"{}\", &x.to_string());\n+    println!(\"{}\", &z.to_string());\n     let x: u32 = x;\n-    println(&x.to_string());\n+    println!(\"{}\", &x.to_string());\n     let x = \"hello\";\n-    println(x);\n+    println!(\"{}\", x);\n \n     let x = 32.0f32;\n     let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n@@ -312,7 +309,7 @@ fn main() { // foo\n     let s3: some_fields = some_fields{ field1: 55};\n     let s4: msalias::nested_struct = sub::sub2::nested_struct{ field2: 55};\n     let s4: msalias::nested_struct = sub2::nested_struct{ field2: 55};\n-    println(&s2.field1.to_string());\n+    println!(\"{}\", &s2.field1.to_string());\n     let s5: MyType = box some_fields{ field1: 55};\n     let s = SameDir::SameStruct{name: \"Bob\".to_string()};\n     let s = SubDir::SubStruct{name:\"Bob\".to_string()};"}, {"sha": "b1fe938767dc912cd8a533b7df908799b2e6fd3d", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -14,7 +14,7 @@ use std::fs::File;\n use std::io::prelude::*;\n use std::path::Path;\n use std::process::Command;\n-use std::rand::{thread_rng, Rng};\n+use std::__rand::{thread_rng, Rng};\n use std::{char, env};\n \n // creates unicode_input_multiple_files_{main,chars}.rs, where the"}, {"sha": "0c01a84d1bf93c1025dfe6a4f76ad987e383797f", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700e627cf727873a472b1876238aac10b932258b/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=700e627cf727873a472b1876238aac10b932258b", "patch": "@@ -15,7 +15,7 @@ use std::io::prelude::*;\n use std::iter::repeat;\n use std::path::Path;\n use std::process::Command;\n-use std::rand::{thread_rng, Rng};\n+use std::__rand::{thread_rng, Rng};\n use std::{char, env};\n \n // creates a file with `fn main() { <random ident> }` and checks the"}]}