{"sha": "12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZDA4NDlmOWRkYjc1MTViZTdjMTQ1MWEzN2NmYWNkY2ZlZjUwYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-15T14:52:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-15T14:52:58Z"}, "message": "Auto merge of #85154 - cjgillot:lessfn, r=bjorn3\n\nReduce amount of function pointers in query invocation.\n\nr? `@ghost`", "tree": {"sha": "b91f541ff465b4718a3eadeca8c66130922a8ae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b91f541ff465b4718a3eadeca8c66130922a8ae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "html_url": "https://github.com/rust-lang/rust/commit/12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6936ca8c993a82c5b5d453c3203d3b7df74c1b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6936ca8c993a82c5b5d453c3203d3b7df74c1b4b", "html_url": "https://github.com/rust-lang/rust/commit/6936ca8c993a82c5b5d453c3203d3b7df74c1b4b"}, {"sha": "8ed82ebb2ad82b1cb95b7f68482a3a6d201a7462", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed82ebb2ad82b1cb95b7f68482a3a6d201a7462", "html_url": "https://github.com/rust-lang/rust/commit/8ed82ebb2ad82b1cb95b7f68482a3a6d201a7462"}], "stats": {"total": 281, "additions": 167, "deletions": 114}, "files": [{"sha": "b3cc7de4662a5dd5aa613af4fe414b0d71cc2147", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 109, "deletions": 73, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "patch": "@@ -14,16 +14,17 @@ use rustc_span::{Span, DUMMY_SP};\n pub trait Key {\n     /// Given an instance of this key, what crate is it referring to?\n     /// This is used to find the provider.\n-    fn query_crate(&self) -> CrateNum;\n+    fn query_crate_is_local(&self) -> bool;\n \n     /// In the event that a cycle occurs, if no explicit span has been\n     /// given for a query with key `self`, what span should we use?\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span;\n }\n \n impl Key for () {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n \n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n@@ -32,8 +33,9 @@ impl Key for () {\n }\n \n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -42,8 +44,9 @@ impl<'tcx> Key for ty::InstanceDef<'tcx> {\n }\n \n impl<'tcx> Key for ty::Instance<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -52,8 +55,9 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        self.instance.query_crate()\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -62,8 +66,9 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n \n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n@@ -72,125 +77,139 @@ impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n }\n \n impl Key for CrateNum {\n-    fn query_crate(&self) -> CrateNum {\n-        *self\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        *self == LOCAL_CRATE\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl Key for LocalDefId {\n-    fn query_crate(&self) -> CrateNum {\n-        self.to_def_id().query_crate()\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.to_def_id().default_span(tcx)\n     }\n }\n \n impl Key for DefId {\n-    fn query_crate(&self) -> CrateNum {\n-        self.krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(*self)\n     }\n }\n \n impl Key for ty::WithOptConstParam<LocalDefId> {\n-    fn query_crate(&self) -> CrateNum {\n-        self.did.query_crate()\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.did.default_span(tcx)\n     }\n }\n \n impl Key for (DefId, DefId) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n \n impl Key for (ty::Instance<'tcx>, LocalDefId) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.query_crate()\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n }\n \n impl Key for (DefId, LocalDefId) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n \n impl Key for (LocalDefId, DefId) {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n }\n \n impl Key for (DefId, Option<Ident>) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.0)\n     }\n }\n \n impl Key for (DefId, LocalDefId, Ident) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n \n impl Key for (CrateNum, DefId) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0 == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n \n impl Key for (DefId, SimplifiedType) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n }\n \n impl<'tcx> Key for SubstsRef<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n@@ -203,125 +222,139 @@ impl<'tcx> Key\n         (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n     )\n {\n-    fn query_crate(&self) -> CrateNum {\n-        (self.0).0.did.krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        (self.0).0.did.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         (self.0).0.did.default_span(tcx)\n     }\n }\n \n impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.0.default_span(tcx)\n     }\n }\n \n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.1.def_id().krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.1.def_id().krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.1.def_id())\n     }\n }\n \n impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx> Key for mir::interpret::ConstAlloc<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        self.def_id().krate\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.def_id().krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n }\n \n impl<'tcx> Key for GenericArg<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx> Key for mir::ConstantKind<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx> Key for Ty<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx> Key for ty::ParamEnv<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n-    fn query_crate(&self) -> CrateNum {\n-        self.value.query_crate()\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.value.query_crate_is_local()\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n         self.value.default_span(tcx)\n     }\n }\n \n impl Key for Symbol {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n@@ -331,8 +364,9 @@ impl Key for Symbol {\n /// Canonical query goals correspond to abstract trait operations that\n /// are not tied to any crate in particular.\n impl<'tcx, T> Key for Canonical<'tcx, T> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n \n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n@@ -341,8 +375,9 @@ impl<'tcx, T> Key for Canonical<'tcx, T> {\n }\n \n impl Key for (Symbol, u32, u32) {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n \n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n@@ -351,8 +386,9 @@ impl Key for (Symbol, u32, u32) {\n }\n \n impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n     }\n \n     fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {"}, {"sha": "1d831affd1deef441f39089ab879f7fb5d93670a", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "patch": "@@ -15,7 +15,6 @@ extern crate tracing;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{DiagnosticBuilder, Handler};\n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::dep_graph;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};"}, {"sha": "5907a587e1690cdc7cd338defd75bc9ead95d5aa", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "patch": "@@ -353,14 +353,14 @@ macro_rules! define_queries {\n             }\n \n             #[inline]\n-            fn compute(tcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                let is_local = key.query_crate() == LOCAL_CRATE;\n-                let provider = if is_local {\n+            fn compute_fn(tcx: QueryCtxt<'tcx>, key: &Self::Key) ->\n+                fn(TyCtxt<'tcx>, Self::Key) -> Self::Value\n+            {\n+                if key.query_crate_is_local() {\n                     tcx.queries.local_providers.$name\n                 } else {\n                     tcx.queries.extern_providers.$name\n-                };\n-                provider(*tcx, key)\n+                }\n             }\n \n             fn hash_result("}, {"sha": "d1e527dff9840e6b5fa0ab314c93083a34d36a4b", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "patch": "@@ -23,9 +23,6 @@ pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n     pub dep_kind: CTX::DepKind,\n     pub eval_always: bool,\n \n-    // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    pub compute: fn(CTX, K) -> V,\n-\n     pub hash_result: fn(&mut CTX::StableHashingContext, &V) -> Option<Fingerprint>,\n     pub handle_cycle_error: fn(CTX, DiagnosticBuilder<'_>) -> V,\n     pub cache_on_disk: fn(CTX, &K, Option<&V>) -> bool,\n@@ -40,10 +37,6 @@ impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n         DepNode::construct(tcx, self.dep_kind, key)\n     }\n \n-    pub(crate) fn compute(&self, tcx: CTX, key: K) -> V {\n-        (self.compute)(tcx, key)\n-    }\n-\n     pub(crate) fn hash_result(\n         &self,\n         hcx: &mut CTX::StableHashingContext,\n@@ -79,7 +72,7 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n         CTX: 'a;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn compute(tcx: CTX, key: Self::Key) -> Self::Value;\n+    fn compute_fn(tcx: CTX, key: &Self::Key) -> fn(CTX::DepContext, Self::Key) -> Self::Value;\n \n     fn hash_result(\n         hcx: &mut CTX::StableHashingContext,\n@@ -115,7 +108,6 @@ where\n         anon: Q::ANON,\n         dep_kind: Q::DEP_KIND,\n         eval_always: Q::EVAL_ALWAYS,\n-        compute: Q::compute,\n         hash_result: Q::hash_result,\n         handle_cycle_error: Q::handle_cycle_error,\n         cache_on_disk: Q::cache_on_disk,"}, {"sha": "c227c2aaff549164f2101449b12dac782666132e", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d0849f9ddb7515be7c1451a37cfacdcfef50c9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=12d0849f9ddb7515be7c1451a37cfacdcfef50c9", "patch": "@@ -428,6 +428,7 @@ fn try_execute_query<CTX, C>(\n     key: C::Key,\n     lookup: QueryLookup,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n+    compute: fn(CTX::DepContext, C::Key) -> C::Value,\n ) -> C::Stored\n where\n     C: QueryCache,\n@@ -457,7 +458,7 @@ where\n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n-        let result = tcx.start_query(job.id, None, || query.compute(tcx, key));\n+        let result = tcx.start_query(job.id, None, || compute(*tcx.dep_context(), key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return job.complete(result, dep_node_index);\n@@ -468,8 +469,9 @@ where\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             tcx.start_query(job.id, diagnostics, || {\n-                dep_graph\n-                    .with_anon_task(*tcx.dep_context(), query.dep_kind, || query.compute(tcx, key))\n+                dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n+                    compute(*tcx.dep_context(), key)\n+                })\n             })\n         });\n \n@@ -501,6 +503,7 @@ where\n                         dep_node_index,\n                         &dep_node,\n                         query,\n+                        compute,\n                     ),\n                     dep_node_index,\n                 )\n@@ -511,7 +514,7 @@ where\n         }\n     }\n \n-    let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, query);\n+    let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, query, compute);\n     dep_graph.read_index(dep_node_index);\n     result\n }\n@@ -523,6 +526,7 @@ fn load_from_disk_and_cache_in_memory<CTX, K, V: Debug>(\n     dep_node_index: DepNodeIndex,\n     dep_node: &DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, K, V>,\n+    compute: fn(CTX::DepContext, K) -> V,\n ) -> V\n where\n     CTX: QueryContext,\n@@ -565,7 +569,7 @@ where\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n \n         // The dep-graph for this computation is already in-place.\n-        let result = tcx.dep_context().dep_graph().with_ignore(|| query.compute(tcx, key));\n+        let result = tcx.dep_context().dep_graph().with_ignore(|| compute(*tcx.dep_context(), key));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -627,6 +631,7 @@ fn force_query_with_job<C, CTX>(\n     job: JobOwner<'_, CTX::DepKind, C>,\n     dep_node: DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n+    compute: fn(CTX::DepContext, C::Key) -> C::Value,\n ) -> (C::Stored, DepNodeIndex)\n where\n     C: QueryCache,\n@@ -653,17 +658,17 @@ where\n             if query.eval_always {\n                 tcx.dep_context().dep_graph().with_eval_always_task(\n                     dep_node,\n-                    tcx,\n+                    *tcx.dep_context(),\n                     key,\n-                    query.compute,\n+                    compute,\n                     query.hash_result,\n                 )\n             } else {\n                 tcx.dep_context().dep_graph().with_task(\n                     dep_node,\n-                    tcx,\n+                    *tcx.dep_context(),\n                     key,\n-                    query.compute,\n+                    compute,\n                     query.hash_result,\n                 )\n             }\n@@ -690,13 +695,14 @@ fn get_query_impl<CTX, C>(\n     key: C::Key,\n     lookup: QueryLookup,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n+    compute: fn(CTX::DepContext, C::Key) -> C::Value,\n ) -> C::Stored\n where\n     CTX: QueryContext,\n     C: QueryCache,\n     C::Key: DepNodeParams<CTX::DepContext>,\n {\n-    try_execute_query(tcx, state, cache, span, key, lookup, query)\n+    try_execute_query(tcx, state, cache, span, key, lookup, query, compute)\n }\n \n /// Ensure that either this query has all green inputs or been executed.\n@@ -744,8 +750,10 @@ fn force_query_impl<CTX, C>(\n     tcx: CTX,\n     state: &QueryState<CTX::DepKind, C::Key>,\n     cache: &QueryCacheStore<C>,\n+    key: C::Key,\n     dep_node: DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n+    compute: fn(CTX::DepContext, C::Key) -> C::Value,\n ) -> bool\n where\n     C: QueryCache,\n@@ -754,18 +762,6 @@ where\n {\n     debug_assert!(!query.anon);\n \n-    if !<C::Key as DepNodeParams<CTX::DepContext>>::can_reconstruct_query_key() {\n-        return false;\n-    }\n-\n-    let key = if let Some(key) =\n-        <C::Key as DepNodeParams<CTX::DepContext>>::recover(*tcx.dep_context(), &dep_node)\n-    {\n-        key\n-    } else {\n-        return false;\n-    };\n-\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n     let cached = cache.cache.lookup(cache, &key, |_, index| {\n@@ -798,7 +794,7 @@ where\n         TryGetJob::JobCompleted(_) => return true,\n     };\n \n-    force_query_with_job(tcx, key, job, dep_node, query);\n+    force_query_with_job(tcx, key, job, dep_node, query, compute);\n \n     true\n }\n@@ -828,8 +824,17 @@ where\n     }\n \n     debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n-    let value =\n-        get_query_impl(tcx, Q::query_state(tcx), Q::query_cache(tcx), span, key, lookup, query);\n+    let compute = Q::compute_fn(tcx, &key);\n+    let value = get_query_impl(\n+        tcx,\n+        Q::query_state(tcx),\n+        Q::query_cache(tcx),\n+        span,\n+        key,\n+        lookup,\n+        query,\n+        compute,\n+    );\n     Some(value)\n }\n \n@@ -843,5 +848,26 @@ where\n         return false;\n     }\n \n-    force_query_impl(tcx, Q::query_state(tcx), Q::query_cache(tcx), *dep_node, &Q::VTABLE)\n+    if !<Q::Key as DepNodeParams<CTX::DepContext>>::can_reconstruct_query_key() {\n+        return false;\n+    }\n+\n+    let key = if let Some(key) =\n+        <Q::Key as DepNodeParams<CTX::DepContext>>::recover(*tcx.dep_context(), &dep_node)\n+    {\n+        key\n+    } else {\n+        return false;\n+    };\n+\n+    let compute = Q::compute_fn(tcx, &key);\n+    force_query_impl(\n+        tcx,\n+        Q::query_state(tcx),\n+        Q::query_cache(tcx),\n+        key,\n+        *dep_node,\n+        &Q::VTABLE,\n+        compute,\n+    )\n }"}]}