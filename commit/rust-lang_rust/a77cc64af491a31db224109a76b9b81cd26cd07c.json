{"sha": "a77cc64af491a31db224109a76b9b81cd26cd07c", "node_id": "C_kwDOAAsO6NoAKGE3N2NjNjRhZjQ5MWEzMWRiMjI0MTA5YTc2YjliODFjZDI2Y2QwN2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-06T12:21:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-06T12:21:10Z"}, "message": "Auto merge of #89819 - davidtwco:issue-81024-multiple-crates-multiple-dwarves, r=nagisa\n\ncg: split dwarf for crate dependencies\n\nFixes #81024.\n\n- In #79570, `-Z split-dwarf-kind={none,single,split}` was replaced by `-C split-debuginfo={off,packed,unpacked}`. `-C split-debuginfo`'s packed and unpacked aren't exact parallels to single and split, respectively.\n\n  On Unix, `-C split-debuginfo=packed` will put debuginfo in object files and package debuginfo into a DWARF package file (`.dwp`) and `-C split-debuginfo=unpacked` will put debuginfo in dwarf object files and won't package it.\n\n  In the initial implementation of Split DWARF, split mode wrote sections which did not require relocation into a DWARF object (`.dwo`) file which was ignored by the linker and then packaged those DWARF objects into DWARF packages (`.dwp`). In single mode, sections which did not require relocation were written into object files but ignored by the linker and were not packaged. However, both split and single modes could be packaged or not, the primary difference in behaviour was where the debuginfo sections that did not require link-time relocation were written (in a DWARF object or the object file).\n\n  In the first commit of this PR, I re-introduce a `-Z split-dwarf-kind` flag, which can be used to pick between split and single modes when `-C split-debuginfo` is used to enable Split DWARF (either packed or unpacked).\n- Split DWARF packaging requires all of the object files to exist, including those in dependencies. ~~Therefore, the second commit of this PR makes rustc keep all objects or dwarf objects for unpacked mode and if the crate is a dependency in packed mode (determined by heuristic: if no linking is taking place), then objects or dwarf objects are kept. Objects are kept if `-Z split-dwarf-kind` is `SplitDwarfKind::Single`, and dwarf objects if `SplitDwarfKind::Split`.~~\n\n  ~~There are other approaches that could be taken to supporting packed Split DWARF with crate dependencies but this seemed like the least complicated and was contained to only rustc. Other potential approaches are described in https://github.com/rust-lang/rust/issues/81024#issuecomment-760478223, I'm happy to change the approach I've taken here if it isn't what we're looking for.~~ See https://github.com/rust-lang/rust/pull/89819#issuecomment-985671867 for the current approach.\n- ~~There's still a dependency on `llvm-dwp` after this change, which [we probably want to move away from](https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/llvm-dwp.20is.20not.20recommended) but that seems out-of-scope for this PR. Ideally, Split DWARF (in packed or unpacked modes) will be usable on nightly after this lands. If there aren't any bugs reported then it's possible we could allow Split DWARF to be used on stable after this change, it depends whether or not switching away from `llvm-dwp` later would break any guarantees, or whether we'd want to change how we handle this cross-crate case in future.~~ See https://github.com/rust-lang/rust/pull/89819#issuecomment-985671867.\n\nr? `@nagisa`\ncc `@alexcrichton`", "tree": {"sha": "2fb00c728a1961aa8c8f9b091f5ac30f81daab52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fb00c728a1961aa8c8f9b091f5ac30f81daab52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a77cc64af491a31db224109a76b9b81cd26cd07c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a77cc64af491a31db224109a76b9b81cd26cd07c", "html_url": "https://github.com/rust-lang/rust/commit/a77cc64af491a31db224109a76b9b81cd26cd07c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a77cc64af491a31db224109a76b9b81cd26cd07c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1ce0e6a00593493a12e0e3662119786c761f375", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ce0e6a00593493a12e0e3662119786c761f375", "html_url": "https://github.com/rust-lang/rust/commit/f1ce0e6a00593493a12e0e3662119786c761f375"}, {"sha": "7ecdc89436bb1aeac473030b250e87abd939c5fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ecdc89436bb1aeac473030b250e87abd939c5fa", "html_url": "https://github.com/rust-lang/rust/commit/7ecdc89436bb1aeac473030b250e87abd939c5fa"}], "stats": {"total": 605, "additions": 443, "deletions": 162}, "files": [{"sha": "50a5d78731febc6ebab8d2c5151b9f2e5d3c5362", "filename": "Cargo.lock", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -9,7 +9,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3e61f2b7f93d2c7d2b08263acaa4a363b3e276806c68af6134c44f523bf1aacd\"\n dependencies = [\n  \"compiler_builtins\",\n- \"gimli\",\n+ \"gimli 0.25.0\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n@@ -87,9 +87,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.34\"\n+version = \"1.0.51\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf8dcb5b4bbaa28653b647d8c77bd4ed40183b48882e130c1f1ffb73de069fd7\"\n+checksum = \"8b26702f315f53b6071259e15dd9d64528213b44d61de1ec926eca7715d62203\"\n \n [[package]]\n name = \"array_tool\"\n@@ -1158,6 +1158,12 @@ version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \n+[[package]]\n+name = \"fallible-iterator\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4443176a9f2c162692bd3d352d745ef9413eec5782a80d8fd6f8a1ac692a07f7\"\n+\n [[package]]\n name = \"filetime\"\n version = \"0.2.14\"\n@@ -1446,6 +1452,17 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"gimli\"\n+version = \"0.26.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+dependencies = [\n+ \"fallible-iterator\",\n+ \"indexmap\",\n+ \"stable_deref_trait\",\n+]\n+\n [[package]]\n name = \"git2\"\n version = \"0.13.23\"\n@@ -2339,6 +2356,18 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.27.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"67ac1d3f9a1d3616fd9a60c8d74296f22406a238b6a72f5cc1e6f314df4ffbf9\"\n+dependencies = [\n+ \"crc32fast\",\n+ \"flate2\",\n+ \"indexmap\",\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"odht\"\n version = \"0.3.1\"\n@@ -3725,10 +3754,11 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n- \"object\",\n+ \"object 0.26.2\",\n  \"pathdiff\",\n  \"regex\",\n  \"rustc_apfloat\",\n+ \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -3749,6 +3779,7 @@ dependencies = [\n  \"smallvec\",\n  \"snap\",\n  \"tempfile\",\n+ \"thorin-dwp\",\n  \"tracing\",\n ]\n \n@@ -4993,7 +5024,7 @@ dependencies = [\n  \"hermit-abi\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.26.2\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n@@ -5057,9 +5088,9 @@ checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \n [[package]]\n name = \"structopt\"\n-version = \"0.3.16\"\n+version = \"0.3.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"de5472fb24d7e80ae84a7801b7978f95a19ec32cb1876faea59ab711eb901976\"\n+checksum = \"40b9788f4202aa75c240ecc9c15c65185e6a39ccdeb0fd5d008b98825464c87c\"\n dependencies = [\n  \"clap\",\n  \"lazy_static\",\n@@ -5068,9 +5099,9 @@ dependencies = [\n \n [[package]]\n name = \"structopt-derive\"\n-version = \"0.4.9\"\n+version = \"0.4.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1e0eb37335aeeebe51be42e2dc07f031163fbabfa6ac67d7ea68b5c2f68d5f99\"\n+checksum = \"dcb5ae327f9cc13b68763b5749770cb9e048a99bd9dfdfa58d0cf05d5f64afe0\"\n dependencies = [\n  \"heck\",\n  \"proc-macro-error\",\n@@ -5249,24 +5280,36 @@ dependencies = [\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.20\"\n+version = \"1.0.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7dfdd070ccd8ccb78f4ad66bf1982dc37f620ef696c6b5028fe2ed83dd3d0d08\"\n+checksum = \"854babe52e4df1653706b98fcfc05843010039b406875930a70e4d9644e5c417\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.20\"\n+version = \"1.0.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bd80fc12f73063ac132ac92aceea36734f04a1d93c1240c6944e23a3b8841793\"\n+checksum = \"aa32fd3f627f367fe16f893e2597ae3c05020f8bba2666a4e6ea73d377e5714b\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"thorin-dwp\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"039d1fc0bfdb73910c2702893515580e38c192f47a987bc98ddd38a36f2d953a\"\n+dependencies = [\n+ \"gimli 0.26.1\",\n+ \"indexmap\",\n+ \"object 0.27.1\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"thread_local\"\n version = \"1.0.1\"\n@@ -5394,9 +5437,9 @@ checksum = \"360dfd1d6d30e05fda32ace2c8c70e9c0a9da713275777f5a4dbb8a1893930c6\"\n \n [[package]]\n name = \"tracing\"\n-version = \"0.1.28\"\n+version = \"0.1.29\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84f96e095c0c82419687c20ddf5cb3eadb61f4e1405923c9dc8e53a1adacbda8\"\n+checksum = \"375a639232caf30edfc78e8d89b2d4c375515393e7af7e16f01cd96917fb2105\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"pin-project-lite\",\n@@ -5406,9 +5449,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.17\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c4f915eb6abf914599c200260efced9203504c4c37380af10cdf3b7d36970650\"\n+checksum = \"f4f480b8f81512e825f337ad51e94c1eb5d3bbdf2b363dcd01e2b19a9ffe3f8e\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "384596dfff5033c3e010d3bc27f634f00bfc5f1b", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -23,7 +23,7 @@ use rustc_errors::{FatalError, Handler, Level};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, Lto, OutputType, Passes, SwitchWithOptPath};\n+use rustc_session::config::{self, Lto, OutputType, Passes, SplitDwarfKind, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n@@ -106,7 +106,11 @@ pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm:\n \n pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n     let split_dwarf_file = if tcx.sess.target_can_use_split_dwarf() {\n-        tcx.output_filenames(()).split_dwarf_path(tcx.sess.split_debuginfo(), Some(mod_name))\n+        tcx.output_filenames(()).split_dwarf_path(\n+            tcx.sess.split_debuginfo(),\n+            tcx.sess.opts.debugging_opts.split_dwarf_kind,\n+            Some(mod_name),\n+        )\n     } else {\n         None\n     };\n@@ -892,17 +896,18 @@ pub(crate) unsafe fn codegen(\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &*module.name);\n \n                 let dwo_out = cgcx.output_filenames.temp_path_dwo(module_name);\n-                let dwo_out = match cgcx.split_debuginfo {\n-                    // Don't change how DWARF is emitted in single mode (or when disabled).\n-                    SplitDebuginfo::Off | SplitDebuginfo::Packed => None,\n-                    // Emit (a subset of the) DWARF into a separate file in split mode.\n-                    SplitDebuginfo::Unpacked => {\n-                        if cgcx.target_can_use_split_dwarf {\n-                            Some(dwo_out.as_path())\n-                        } else {\n-                            None\n-                        }\n-                    }\n+                let dwo_out = match (cgcx.split_debuginfo, cgcx.split_dwarf_kind) {\n+                    // Don't change how DWARF is emitted when disabled.\n+                    (SplitDebuginfo::Off, _) => None,\n+                    // Don't provide a DWARF object path if split debuginfo is enabled but this is\n+                    // a platform that doesn't support Split DWARF.\n+                    _ if !cgcx.target_can_use_split_dwarf => None,\n+                    // Don't provide a DWARF object path in single mode, sections will be written\n+                    // into the object as normal but ignored by linker.\n+                    (_, SplitDwarfKind::Single) => None,\n+                    // Emit (a subset of the) DWARF into a separate dwarf object file in split\n+                    // mode.\n+                    (_, SplitDwarfKind::Split) => Some(dwo_out.as_path()),\n                 };\n \n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n@@ -939,7 +944,9 @@ pub(crate) unsafe fn codegen(\n \n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n-        cgcx.target_can_use_split_dwarf && cgcx.split_debuginfo == SplitDebuginfo::Unpacked,\n+        cgcx.target_can_use_split_dwarf\n+            && cgcx.split_debuginfo != SplitDebuginfo::Off\n+            && cgcx.split_dwarf_kind == SplitDwarfKind::Split,\n         config.emit_bc,\n         &cgcx.output_filenames,\n     ))"}, {"sha": "e8d35cf5697f1050df9f6dfeda5fdffe9e4d003c", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -1072,7 +1072,11 @@ pub fn compile_unit_metadata<'ll, 'tcx>(\n     let output_filenames = tcx.output_filenames(());\n     let split_name = if tcx.sess.target_can_use_split_dwarf() {\n         output_filenames\n-            .split_dwarf_path(tcx.sess.split_debuginfo(), Some(codegen_unit_name))\n+            .split_dwarf_path(\n+                tcx.sess.split_debuginfo(),\n+                tcx.sess.opts.debugging_opts.split_dwarf_kind,\n+                Some(codegen_unit_name),\n+            )\n             // We get a path relative to the working directory from split_dwarf_path\n             .map(|f| tcx.sess.source_map().path_mapping().map_prefix(f).0)\n     } else {"}, {"sha": "5c13dfdc1b50537e8811c2bca03d1f2608495b4d", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -14,12 +14,14 @@ tracing = \"0.1\"\n libc = \"0.2.50\"\n jobserver = \"0.1.22\"\n tempfile = \"3.2\"\n+thorin-dwp = \"0.1.1\"\n pathdiff = \"0.2.0\"\n snap = \"1\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n regex = \"1.4\"\n \n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "f7fe194d207d31faf611f23d877195b93bd83ba6", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 170, "deletions": 87, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -1,11 +1,13 @@\n+use rustc_arena::TypedArena;\n use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n+use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{ErrorReported, Handler};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Strip};\n-use rustc_session::config::{OutputFilenames, OutputType, PrintRequest};\n+use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, SplitDwarfKind};\n use rustc_session::cstore::DllImport;\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n@@ -32,7 +34,10 @@ use cc::windows_registry;\n use regex::Regex;\n use tempfile::Builder as TempFileBuilder;\n \n-use std::ffi::{OsStr, OsString};\n+use std::borrow::Borrow;\n+use std::ffi::OsString;\n+use std::fs::{File, OpenOptions};\n+use std::io::{BufWriter, Write};\n use std::lazy::OnceCell;\n use std::path::{Path, PathBuf};\n use std::process::{ExitStatus, Output, Stdio};\n@@ -134,31 +139,47 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         }\n     }\n \n-    // Remove the temporary object file and metadata if we aren't saving temps\n+    // Remove the temporary object file and metadata if we aren't saving temps.\n     sess.time(\"link_binary_remove_temps\", || {\n-        if !sess.opts.cg.save_temps {\n-            let remove_temps_from_module = |module: &CompiledModule| {\n-                if let Some(ref obj) = module.object {\n-                    ensure_removed(sess.diagnostic(), obj);\n-                }\n-\n-                if let Some(ref obj) = module.dwarf_object {\n-                    ensure_removed(sess.diagnostic(), obj);\n-                }\n-            };\n+        // If the user requests that temporaries are saved, don't delete any.\n+        if sess.opts.cg.save_temps {\n+            return;\n+        }\n \n-            if sess.opts.output_types.should_link() && !preserve_objects_for_their_debuginfo(sess) {\n-                for module in &codegen_results.modules {\n-                    remove_temps_from_module(module);\n-                }\n+        let remove_temps_from_module = |module: &CompiledModule| {\n+            if let Some(ref obj) = module.object {\n+                ensure_removed(sess.diagnostic(), obj);\n             }\n+        };\n+\n+        // Otherwise, always remove the metadata and allocator module temporaries.\n+        if let Some(ref metadata_module) = codegen_results.metadata_module {\n+            remove_temps_from_module(metadata_module);\n+        }\n+\n+        if let Some(ref allocator_module) = codegen_results.allocator_module {\n+            remove_temps_from_module(allocator_module);\n+        }\n \n-            if let Some(ref metadata_module) = codegen_results.metadata_module {\n-                remove_temps_from_module(metadata_module);\n+        // If no requested outputs require linking, then the object temporaries should\n+        // be kept.\n+        if !sess.opts.output_types.should_link() {\n+            return;\n+        }\n+\n+        // Potentially keep objects for their debuginfo.\n+        let (preserve_objects, preserve_dwarf_objects) = preserve_objects_for_their_debuginfo(sess);\n+        debug!(?preserve_objects, ?preserve_dwarf_objects);\n+\n+        for module in &codegen_results.modules {\n+            if !preserve_objects {\n+                remove_temps_from_module(module);\n             }\n \n-            if let Some(ref allocator_module) = codegen_results.allocator_module {\n-                remove_temps_from_module(allocator_module);\n+            if !preserve_dwarf_objects {\n+                if let Some(ref obj) = module.dwarf_object {\n+                    ensure_removed(sess.diagnostic(), obj);\n+                }\n             }\n         }\n     });\n@@ -245,8 +266,14 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n \n     let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n \n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        ab.add_file(obj);\n+    for m in &codegen_results.modules {\n+        if let Some(obj) = m.object.as_ref() {\n+            ab.add_file(obj);\n+        }\n+\n+        if let Some(dwarf_obj) = m.dwarf_object.as_ref() {\n+            ab.add_file(dwarf_obj);\n+        }\n     }\n \n     // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n@@ -502,59 +529,108 @@ fn escape_stdout_stderr_string(s: &[u8]) -> String {\n     })\n }\n \n-const LLVM_DWP_EXECUTABLE: &'static str = \"rust-llvm-dwp\";\n-\n-/// Invoke `llvm-dwp` (shipped alongside rustc) to link debuginfo in object files into a `dwp`\n-/// file.\n-fn link_dwarf_object<'a, I>(sess: &'a Session, executable_out_filename: &Path, object_files: I)\n-where\n-    I: IntoIterator<Item: AsRef<OsStr>>,\n-{\n-    info!(\"preparing dwp to {}.dwp\", executable_out_filename.to_str().unwrap());\n-\n+/// Use `thorin` (rust implementation of a dwarf packaging utility) to link DWARF objects into a\n+/// DWARF package.\n+fn link_dwarf_object<'a>(\n+    sess: &'a Session,\n+    cg_results: &CodegenResults,\n+    executable_out_filename: &Path,\n+) {\n     let dwp_out_filename = executable_out_filename.with_extension(\"dwp\");\n-    let mut cmd = Command::new(LLVM_DWP_EXECUTABLE);\n-    cmd.arg(\"-o\");\n-    cmd.arg(&dwp_out_filename);\n-    cmd.args(object_files);\n+    debug!(?dwp_out_filename, ?executable_out_filename);\n \n-    let mut new_path = sess.get_tools_search_paths(false);\n-    if let Some(path) = env::var_os(\"PATH\") {\n-        new_path.extend(env::split_paths(&path));\n+    #[derive(Default)]\n+    struct ThorinSession<Relocations> {\n+        arena_data: TypedArena<Vec<u8>>,\n+        arena_mmap: TypedArena<Mmap>,\n+        arena_relocations: TypedArena<Relocations>,\n     }\n-    let new_path = env::join_paths(new_path).unwrap();\n-    cmd.env(\"PATH\", new_path);\n \n-    info!(\"{:?}\", &cmd);\n-    match sess.time(\"run_dwp\", || cmd.output()) {\n-        Ok(prog) if !prog.status.success() => {\n-            sess.struct_err(&format!(\n-                \"linking dwarf objects with `{}` failed: {}\",\n-                LLVM_DWP_EXECUTABLE, prog.status\n-            ))\n-            .note(&format!(\"{:?}\", &cmd))\n-            .note(&escape_stdout_stderr_string(&prog.stdout))\n-            .note(&escape_stdout_stderr_string(&prog.stderr))\n-            .emit();\n-            info!(\"linker stderr:\\n{}\", escape_stdout_stderr_string(&prog.stderr));\n-            info!(\"linker stdout:\\n{}\", escape_stdout_stderr_string(&prog.stdout));\n+    impl<Relocations> ThorinSession<Relocations> {\n+        fn alloc_mmap<'arena>(&'arena self, data: Mmap) -> &'arena Mmap {\n+            (*self.arena_mmap.alloc(data)).borrow()\n         }\n-        Ok(_) => {}\n-        Err(e) => {\n-            let dwp_not_found = e.kind() == io::ErrorKind::NotFound;\n-            let mut err = if dwp_not_found {\n-                sess.struct_err(&format!(\"linker `{}` not found\", LLVM_DWP_EXECUTABLE))\n-            } else {\n-                sess.struct_err(&format!(\"could not exec the linker `{}`\", LLVM_DWP_EXECUTABLE))\n-            };\n+    }\n \n-            err.note(&e.to_string());\n+    impl<Relocations> thorin::Session<Relocations> for ThorinSession<Relocations> {\n+        fn alloc_data<'arena>(&'arena self, data: Vec<u8>) -> &'arena [u8] {\n+            (*self.arena_data.alloc(data)).borrow()\n+        }\n \n-            if !dwp_not_found {\n-                err.note(&format!(\"{:?}\", &cmd));\n+        fn alloc_relocation<'arena>(&'arena self, data: Relocations) -> &'arena Relocations {\n+            (*self.arena_relocations.alloc(data)).borrow()\n+        }\n+\n+        fn read_input<'arena>(&'arena self, path: &Path) -> std::io::Result<&'arena [u8]> {\n+            let file = File::open(&path)?;\n+            let mmap = (unsafe { Mmap::map(file) })?;\n+            Ok(self.alloc_mmap(mmap))\n+        }\n+    }\n+\n+    match sess.time(\"run_thorin\", || -> Result<(), thorin::Error> {\n+        let thorin_sess = ThorinSession::default();\n+        let mut package = thorin::DwarfPackage::new(&thorin_sess);\n+\n+        // Input objs contain .o/.dwo files from the current crate.\n+        match sess.opts.debugging_opts.split_dwarf_kind {\n+            SplitDwarfKind::Single => {\n+                for input_obj in cg_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+                    package.add_input_object(input_obj)?;\n+                }\n             }\n+            SplitDwarfKind::Split => {\n+                for input_obj in cg_results.modules.iter().filter_map(|m| m.dwarf_object.as_ref()) {\n+                    package.add_input_object(input_obj)?;\n+                }\n+            }\n+        }\n \n-            err.emit();\n+        // Input rlibs contain .o/.dwo files from dependencies.\n+        let input_rlibs = cg_results\n+            .crate_info\n+            .used_crate_source\n+            .values()\n+            .filter_map(|csource| csource.rlib.as_ref())\n+            .map(|(path, _)| path);\n+        for input_rlib in input_rlibs {\n+            debug!(?input_rlib);\n+            package.add_input_object(input_rlib)?;\n+        }\n+\n+        // Failing to read the referenced objects is expected for dependencies where the path in the\n+        // executable will have been cleaned by Cargo, but the referenced objects will be contained\n+        // within rlibs provided as inputs.\n+        //\n+        // If paths have been remapped, then .o/.dwo files from the current crate also won't be\n+        // found, but are provided explicitly above.\n+        //\n+        // Adding an executable is primarily done to make `thorin` check that all the referenced\n+        // dwarf objects are found in the end.\n+        package.add_executable(\n+            &executable_out_filename,\n+            thorin::MissingReferencedObjectBehaviour::Skip,\n+        )?;\n+\n+        let output = package.finish()?.write()?;\n+        let mut output_stream = BufWriter::new(\n+            OpenOptions::new()\n+                .read(true)\n+                .write(true)\n+                .create(true)\n+                .truncate(true)\n+                .open(dwp_out_filename)?,\n+        );\n+        output_stream.write_all(&output)?;\n+        output_stream.flush()?;\n+\n+        Ok(())\n+    }) {\n+        Ok(()) => {}\n+        Err(e) => {\n+            sess.struct_err(\"linking dwarf objects with thorin failed\")\n+                .note(&format!(\"{:?}\", e))\n+                .emit();\n         }\n     }\n }\n@@ -900,14 +976,11 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         SplitDebuginfo::Packed if sess.target.is_like_msvc => {}\n \n         // ... and otherwise we're processing a `*.dwp` packed dwarf file.\n+        //\n         // We cannot rely on the .o paths in the exectuable because they may have been\n-        // remapped by --remap-path-prefix and therefore invalid. So we need to provide\n-        // the .o paths explicitly\n-        SplitDebuginfo::Packed => link_dwarf_object(\n-            sess,\n-            &out_filename,\n-            codegen_results.modules.iter().filter_map(|m| m.object.as_ref()),\n-        ),\n+        // remapped by --remap-path-prefix and therefore invalid, so we need to provide\n+        // the .o/.dwo paths explicitly.\n+        SplitDebuginfo::Packed => link_dwarf_object(sess, codegen_results, out_filename),\n     }\n \n     let strip = strip_value(sess);\n@@ -1138,26 +1211,36 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n     bug!(\"Not enough information provided to determine how to invoke the linker\");\n }\n \n-/// Returns a boolean indicating whether we should preserve the object files on\n-/// the filesystem for their debug information. This is often useful with\n-/// split-dwarf like schemes.\n-fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+/// Returns a pair of boolean indicating whether we should preserve the object and\n+/// dwarf object files on the filesystem for their debug information. This is often\n+/// useful with split-dwarf like schemes.\n+fn preserve_objects_for_their_debuginfo(sess: &Session) -> (bool, bool) {\n     // If the objects don't have debuginfo there's nothing to preserve.\n     if sess.opts.debuginfo == config::DebugInfo::None {\n-        return false;\n+        return (false, false);\n     }\n \n     // If we're only producing artifacts that are archives, no need to preserve\n     // the objects as they're losslessly contained inside the archives.\n-    let output_linked =\n-        sess.crate_types().iter().any(|&x| x != CrateType::Rlib && x != CrateType::Staticlib);\n-    if !output_linked {\n-        return false;\n+    if sess.crate_types().iter().all(|&x| x.is_archive()) {\n+        return (false, false);\n+    }\n+\n+    match (sess.split_debuginfo(), sess.opts.debugging_opts.split_dwarf_kind) {\n+        // If there is no split debuginfo then do not preserve objects.\n+        (SplitDebuginfo::Off, _) => (false, false),\n+        // If there is packed split debuginfo, then the debuginfo in the objects\n+        // has been packaged and the objects can be deleted.\n+        (SplitDebuginfo::Packed, _) => (false, false),\n+        // If there is unpacked split debuginfo and the current target can not use\n+        // split dwarf, then keep objects.\n+        (SplitDebuginfo::Unpacked, _) if !sess.target_can_use_split_dwarf() => (true, false),\n+        // If there is unpacked split debuginfo and the target can use split dwarf, then\n+        // keep the object containing that debuginfo (whether that is an object file or\n+        // dwarf object file depends on the split dwarf kind).\n+        (SplitDebuginfo::Unpacked, SplitDwarfKind::Single) => (true, false),\n+        (SplitDebuginfo::Unpacked, SplitDwarfKind::Split) => (false, true),\n     }\n-\n-    // \"unpacked\" split debuginfo means that we leave object files as the\n-    // debuginfo is found in the original object files themselves\n-    sess.split_debuginfo() == SplitDebuginfo::Unpacked\n }\n \n fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {"}, {"sha": "bea454458c4c028170767eac17cd63b29acb43a9", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -286,7 +286,11 @@ impl TargetMachineFactoryConfig {\n         module_name: &str,\n     ) -> TargetMachineFactoryConfig {\n         let split_dwarf_file = if cgcx.target_can_use_split_dwarf {\n-            cgcx.output_filenames.split_dwarf_path(cgcx.split_debuginfo, Some(module_name))\n+            cgcx.output_filenames.split_dwarf_path(\n+                cgcx.split_debuginfo,\n+                cgcx.split_dwarf_kind,\n+                Some(module_name),\n+            )\n         } else {\n             None\n         };\n@@ -329,6 +333,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n     pub split_debuginfo: rustc_target::spec::SplitDebuginfo,\n+    pub split_dwarf_kind: rustc_session::config::SplitDwarfKind,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -1060,6 +1065,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         target_arch: tcx.sess.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n         split_debuginfo: tcx.sess.split_debuginfo(),\n+        split_dwarf_kind: tcx.sess.opts.debugging_opts.split_dwarf_kind,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen."}, {"sha": "62b351f5e0279a54eabbcdbe6386df03ebdf4585", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -231,6 +231,37 @@ pub enum DebugInfo {\n     Full,\n }\n \n+/// Split debug-information is enabled by `-C split-debuginfo`, this enum is only used if split\n+/// debug-information is enabled (in either `Packed` or `Unpacked` modes), and the platform\n+/// uses DWARF for debug-information.\n+///\n+/// Some debug-information requires link-time relocation and some does not. LLVM can partition\n+/// the debuginfo into sections depending on whether or not it requires link-time relocation. Split\n+/// DWARF provides a mechanism which allows the linker to skip the sections which don't require\n+/// link-time relocation - either by putting those sections in DWARF object files, or by keeping\n+/// them in the object file in such a way that the linker will skip them.\n+#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n+pub enum SplitDwarfKind {\n+    /// Sections which do not require relocation are written into object file but ignored by the\n+    /// linker.\n+    Single,\n+    /// Sections which do not require relocation are written into a DWARF object (`.dwo`) file\n+    /// which is ignored by the linker.\n+    Split,\n+}\n+\n+impl FromStr for SplitDwarfKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, ()> {\n+        Ok(match s {\n+            \"single\" => SplitDwarfKind::Single,\n+            \"split\" => SplitDwarfKind::Split,\n+            _ => return Err(()),\n+        })\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n #[derive(Encodable, Decodable)]\n pub enum OutputType {\n@@ -378,7 +409,7 @@ impl OutputTypes {\n         self.0.len()\n     }\n \n-    // Returns `true` if any of the output types require codegen or linking.\n+    /// Returns `true` if any of the output types require codegen or linking.\n     pub fn should_codegen(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n             OutputType::Bitcode\n@@ -391,7 +422,7 @@ impl OutputTypes {\n         })\n     }\n \n-    // Returns `true` if any of the output types require linking.\n+    /// Returns `true` if any of the output types require linking.\n     pub fn should_link(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n             OutputType::Bitcode\n@@ -681,18 +712,23 @@ impl OutputFilenames {\n     pub fn split_dwarf_path(\n         &self,\n         split_debuginfo_kind: SplitDebuginfo,\n+        split_dwarf_kind: SplitDwarfKind,\n         cgu_name: Option<&str>,\n     ) -> Option<PathBuf> {\n         let obj_out = self.temp_path(OutputType::Object, cgu_name);\n         let dwo_out = self.temp_path_dwo(cgu_name);\n-        match split_debuginfo_kind {\n-            SplitDebuginfo::Off => None,\n+        match (split_debuginfo_kind, split_dwarf_kind) {\n+            (SplitDebuginfo::Off, SplitDwarfKind::Single | SplitDwarfKind::Split) => None,\n             // Single mode doesn't change how DWARF is emitted, but does add Split DWARF attributes\n             // (pointing at the path which is being determined here). Use the path to the current\n             // object file.\n-            SplitDebuginfo::Packed => Some(obj_out),\n+            (SplitDebuginfo::Packed | SplitDebuginfo::Unpacked, SplitDwarfKind::Single) => {\n+                Some(obj_out)\n+            }\n             // Split mode emits the DWARF into a different file, use that path.\n-            SplitDebuginfo::Unpacked => Some(dwo_out),\n+            (SplitDebuginfo::Packed | SplitDebuginfo::Unpacked, SplitDwarfKind::Split) => {\n+                Some(dwo_out)\n+            }\n         }\n     }\n }\n@@ -821,6 +857,18 @@ pub enum CrateType {\n \n impl_stable_hash_via_hash!(CrateType);\n \n+impl CrateType {\n+    /// When generated, is this crate type an archive?\n+    pub fn is_archive(&self) -> bool {\n+        match *self {\n+            CrateType::Rlib | CrateType::Staticlib => true,\n+            CrateType::Executable | CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro => {\n+                false\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone, Hash, Debug, PartialEq, Eq)]\n pub enum Passes {\n     Some(Vec<String>),"}, {"sha": "0b9623d1c7d6f69c4e99cd5265fc27e618e9b666", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -412,6 +412,8 @@ mod desc {\n     pub const parse_wasi_exec_model: &str = \"either `command` or `reactor`\";\n     pub const parse_split_debuginfo: &str =\n         \"one of supported split-debuginfo modes (`off`, `packed`, or `unpacked`)\";\n+    pub const parse_split_dwarf_kind: &str =\n+        \"one of supported split dwarf modes (`split` or `single`)\";\n     pub const parse_gcc_ld: &str = \"one of: no value, `lld`\";\n     pub const parse_stack_protector: &str =\n         \"one of (`none` (default), `basic`, `strong`, or `all`)\";\n@@ -941,6 +943,14 @@ mod parse {\n         true\n     }\n \n+    crate fn parse_split_dwarf_kind(slot: &mut SplitDwarfKind, v: Option<&str>) -> bool {\n+        match v.and_then(|s| SplitDwarfKind::from_str(s).ok()) {\n+            Some(e) => *slot = e,\n+            _ => return false,\n+        }\n+        true\n+    }\n+\n     crate fn parse_gcc_ld(slot: &mut Option<LdImpl>, v: Option<&str>) -> bool {\n         match v {\n             None => *slot = None,\n@@ -1403,6 +1413,14 @@ options! {\n         \"control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n+    split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [UNTRACKED],\n+        \"split dwarf variant (only if -Csplit-debuginfo is enabled and on relevant platform)\n+        (default: `split`)\n+\n+        `split`: sections which do not require relocation are written into a DWARF object (`.dwo`)\n+                 file which is ignored by the linker\n+        `single`: sections which do not require relocation are written into object file but ignored\n+                  by the linker\"),\n     split_dwarf_inlining: bool = (true, parse_bool, [UNTRACKED],\n         \"provide minimal debug info in the object/executable to facilitate online \\\n          symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),"}, {"sha": "ca1949b9f75a3668de55bc9b49b68f93a161997d", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -479,7 +479,7 @@ pub enum SplitDebuginfo {\n     ///\n     /// * Windows - not supported\n     /// * macOS - supported, scattered object files\n-    /// * ELF - supported, scattered `*.dwo` files\n+    /// * ELF - supported, scattered `*.dwo` or `*.o` files (see `SplitDwarfKind`)\n     Unpacked,\n }\n "}, {"sha": "043b38ecece7da5cb58ab42914468bf0543c123a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -1143,7 +1143,6 @@ impl Step for Assemble {\n         let libdir = builder.sysroot_libdir(target_compiler, target_compiler.host);\n         let libdir_bin = libdir.parent().unwrap().join(\"bin\");\n         t!(fs::create_dir_all(&libdir_bin));\n-\n         if let Some(lld_install) = lld_install {\n             let src_exe = exe(\"lld\", target_compiler.host);\n             let dst_exe = exe(\"rust-lld\", target_compiler.host);\n@@ -1161,17 +1160,11 @@ impl Step for Assemble {\n             }\n         }\n \n-        // Similarly, copy `llvm-dwp` into libdir for Split DWARF. Only copy it when the LLVM\n-        // backend is used to avoid unnecessarily building LLVM and because LLVM is not checked\n-        // out by default when the LLVM backend is not enabled.\n         if builder.config.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\")) {\n-            let src_exe = exe(\"llvm-dwp\", target_compiler.host);\n-            let dst_exe = exe(\"rust-llvm-dwp\", target_compiler.host);\n             let llvm_config_bin = builder.ensure(native::Llvm { target: target_compiler.host });\n             if !builder.config.dry_run {\n                 let llvm_bin_dir = output(Command::new(llvm_config_bin).arg(\"--bindir\"));\n                 let llvm_bin_dir = Path::new(llvm_bin_dir.trim());\n-                builder.copy(&llvm_bin_dir.join(&src_exe), &libdir_bin.join(&dst_exe));\n \n                 // Since we've already built the LLVM tools, install them to the sysroot.\n                 // This is the equivalent of installing the `llvm-tools-preview` component via"}, {"sha": "7d9b3da48ecb0578e12720eddb115844ecea3b66", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -398,12 +398,12 @@ impl Step for Rustc {\n             // component for now.\n             maybe_install_llvm_runtime(builder, host, image);\n \n-            let src_dir = builder.sysroot_libdir(compiler, host).parent().unwrap().join(\"bin\");\n             let dst_dir = image.join(\"lib/rustlib\").join(&*host.triple).join(\"bin\");\n             t!(fs::create_dir_all(&dst_dir));\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n+                let src_dir = builder.sysroot_libdir(compiler, host).parent().unwrap().join(\"bin\");\n                 let rust_lld = exe(\"rust-lld\", compiler.host);\n                 builder.copy(&src_dir.join(&rust_lld), &dst_dir.join(&rust_lld));\n                 // for `-Z gcc-ld=lld`\n@@ -417,10 +417,6 @@ impl Step for Rustc {\n                 }\n             }\n \n-            // Copy over llvm-dwp if it's there\n-            let exe = exe(\"rust-llvm-dwp\", compiler.host);\n-            builder.copy(&src_dir.join(&exe), &dst_dir.join(&exe));\n-\n             // Man pages\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n             let man_src = builder.src.join(\"src/doc/man\");"}, {"sha": "e2dc64d8ce2ddcce90949d447403a3424db38b99", "filename": "src/test/run-make-fulldeps/split-debuginfo/Makefile", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -44,16 +44,78 @@ off:\n \t[ ! -f $(TMPDIR)/*.dwp ]\n \t[ ! -f $(TMPDIR)/*.dwo ]\n \n-packed:\n-\t$(RUSTC) foo.rs -g -C split-debuginfo=packed -Z unstable-options\n+packed: packed-split packed-single\n+\n+packed-split:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=packed -Z unstable-options -Zsplit-dwarf-kind=split\n+\tls $(TMPDIR)/*.dwp\n+\trm -rf $(TMPDIR)/*.dwp $(TMPDIR)/*.dwo\n+\n+packed-single:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=packed -Z unstable-options -Zsplit-dwarf-kind=single\n \tls $(TMPDIR)/*.dwp\n \tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n \trm -rf $(TMPDIR)/*.dwp\n \n-unpacked:\n-\t$(RUSTC) foo.rs -g -C split-debuginfo=unpacked -Z unstable-options\n+packed-remapped: packed-remapped-split packed-remapped-single\n+\n+packed-remapped-split:\n+\t$(RUSTC) -Z unstable-options -C split-debuginfo=packed -C debuginfo=2 \\\n+\t\t-Z split-dwarf-kind=split --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n+\tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n+\n+packed-remapped-single:\n+\t$(RUSTC) -Z unstable-options -C split-debuginfo=packed -C debuginfo=2 \\\n+\t\t-Z split-dwarf-kind=single --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n+\tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n+\n+packed-crosscrate: packed-crosscrate-split packed-crosscrate-single\n+\n+packed-crosscrate-split:\n+\t$(RUSTC) --crate-type lib -Z unstable-options -C split-debuginfo=packed \\\n+\t\t-Zsplit-dwarf-kind=split -C debuginfo=2 -g bar.rs\n+\tls $(TMPDIR)/*.rlib\n+\tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n+\tls $(TMPDIR)/*.dwp && exit 1 || exit 0\n+\t$(RUSTC) --extern bar=$(TMPDIR)/libbar.rlib -Z unstable-options -C split-debuginfo=packed \\\n+\t\t-Zsplit-dwarf-kind=split -C debuginfo=2 -g main.rs\n+\trm $(TMPDIR)/*.dwo\n+\trm $(TMPDIR)/main.dwp\n+\trm $(TMPDIR)/$(call BIN,main)\n+\n+packed-crosscrate-single:\n+\t$(RUSTC) --crate-type lib -Z unstable-options -C split-debuginfo=packed \\\n+\t\t-Zsplit-dwarf-kind=single -C debuginfo=2 -g bar.rs\n+\tls $(TMPDIR)/*.rlib\n+\tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n+\tls $(TMPDIR)/*.dwp && exit 1 || exit 0\n+\t$(RUSTC) --extern bar=$(TMPDIR)/libbar.rlib -Z unstable-options -C split-debuginfo=packed \\\n+\t\t-Zsplit-dwarf-kind=single -C debuginfo=2 -g main.rs\n+\tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n+\trm $(TMPDIR)/main.dwp\n+\trm $(TMPDIR)/$(call BIN,main)\n+\n+unpacked: unpacked-split unpacked-single unpacked-remapped-split unpacked-remapped-single\n+\n+unpacked-split:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=unpacked -Z unstable-options -Zsplit-dwarf-kind=split\n \tls $(TMPDIR)/*.dwp && exit 1 || exit 0\n \tls $(TMPDIR)/*.dwo\n-\trm -rf $(TMPDIR)/*.dwo\n+\trm -rf $(TMPDIR)/*.dwp $(TMPDIR)/*.dwo\n+\n+unpacked-single:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=unpacked -Z unstable-options -Zsplit-dwarf-kind=single\n+\tls $(TMPDIR)/*.dwp && exit 1 || exit 0\n+\tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n+\n+unpacked-remapped-split:\n+\t$(RUSTC) -Z unstable-options -C split-debuginfo=unpacked -C debuginfo=2 \\\n+\t\t-Z split-dwarf-kind=split --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n+\tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n+\n+unpacked-remapped-single:\n+\t$(RUSTC) -Z unstable-options -C split-debuginfo=unpacked -C debuginfo=2 \\\n+\t\t-Z split-dwarf-kind=single --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n+\tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n endif\n endif"}, {"sha": "07dd0715252cc346913b560ee70946ab9467e4aa", "filename": "src/test/run-make-fulldeps/split-debuginfo/bar.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Fbar.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -0,0 +1,13 @@\n+pub struct Bar {\n+    x: u32,\n+}\n+\n+impl Bar {\n+    pub fn print(&self) {\n+        println!(\"{}\", self.x);\n+    }\n+}\n+\n+pub fn make_bar(x: u32) -> Bar {\n+    Bar { x }\n+}"}, {"sha": "b058e540862343f7a2b2b791e78fdfc830dc65e3", "filename": "src/test/run-make-fulldeps/split-debuginfo/foo.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Ffoo.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -1 +1,15 @@\n+pub struct Foo {\n+    x: u32,\n+}\n+\n+impl Foo {\n+    pub fn print(&self) {\n+        println!(\"{}\", self.x);\n+    }\n+}\n+\n+pub fn make_foo(x: u32) -> Foo {\n+    Foo { x }\n+}\n+\n fn main() {}"}, {"sha": "21fa16e40a4abaa42ac9f0d68df9f20630979027", "filename": "src/test/run-make-fulldeps/split-debuginfo/main.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Fmain.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -0,0 +1,8 @@\n+extern crate bar;\n+\n+use bar::{Bar, make_bar};\n+\n+fn main() {\n+    let b = make_bar(3);\n+    b.print();\n+}"}, {"sha": "eef04c767fb7c6bf7871b6997e3f67c274701b9d", "filename": "src/test/run-make-fulldeps/split-dwarf/Makefile", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce0e6a00593493a12e0e3662119786c761f375/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce0e6a00593493a12e0e3662119786c761f375/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile?ref=f1ce0e6a00593493a12e0e3662119786c761f375", "patch": "@@ -1,17 +0,0 @@\n--include ../tools.mk\n-\n-# only-linux\n-\n-all: packed remapped\n-\n-remapped:\n-\t$(RUSTC) -Z unstable-options -C split-debuginfo=packed -C debuginfo=2 --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n-\tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n-\n-\t$(RUSTC) -Z unstable-options -C split-debuginfo=unpacked -C debuginfo=2 --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n-\tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n-\n-packed:\n-\t$(RUSTC) -Z unstable-options -C split-debuginfo=packed -C debuginfo=2 foo.rs -g\n-\trm $(TMPDIR)/foo.dwp\n-\trm $(TMPDIR)/$(call BIN,foo)"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/test/run-make-fulldeps/split-dwarf/foo.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce0e6a00593493a12e0e3662119786c761f375/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce0e6a00593493a12e0e3662119786c761f375/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2Ffoo.rs?ref=f1ce0e6a00593493a12e0e3662119786c761f375", "patch": "@@ -1 +0,0 @@\n-fn main() {}"}, {"sha": "4c28655bc865354926422bed5ecb321bd328404a", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77cc64af491a31db224109a76b9b81cd26cd07c/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=a77cc64af491a31db224109a76b9b81cd26cd07c", "patch": "@@ -109,6 +109,7 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"env_logger\",\n     \"expect-test\",\n     \"fake-simd\",\n+    \"fallible-iterator\", // dependency of `thorin`\n     \"filetime\",\n     \"fixedbitset\",\n     \"flate2\",\n@@ -201,6 +202,7 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"tempfile\",\n     \"termcolor\",\n     \"termize\",\n+    \"thorin-dwp\",\n     \"thread_local\",\n     \"time\",\n     \"tinyvec\","}]}