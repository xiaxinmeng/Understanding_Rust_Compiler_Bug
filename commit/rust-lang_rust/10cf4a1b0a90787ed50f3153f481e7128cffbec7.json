{"sha": "10cf4a1b0a90787ed50f3153f481e7128cffbec7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwY2Y0YTFiMGE5MDc4N2VkNTBmMzE1M2Y0ODFlNzEyOGNmZmJlYzc=", "commit": {"author": {"name": "Elly Jones", "email": "elly@leptoquark.net", "date": "2011-12-17T01:33:39Z"}, "committer": {"name": "Elly Jones", "email": "elly@leptoquark.net", "date": "2011-12-17T01:33:39Z"}, "message": "cargo: wip", "tree": {"sha": "e40ad39c0bb326ea89763480b1960e7d98ead24a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e40ad39c0bb326ea89763480b1960e7d98ead24a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10cf4a1b0a90787ed50f3153f481e7128cffbec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10cf4a1b0a90787ed50f3153f481e7128cffbec7", "html_url": "https://github.com/rust-lang/rust/commit/10cf4a1b0a90787ed50f3153f481e7128cffbec7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10cf4a1b0a90787ed50f3153f481e7128cffbec7/comments", "author": null, "committer": null, "parents": [{"sha": "89e880d613bc797b3867f91cd7f676c9b4737397", "url": "https://api.github.com/repos/rust-lang/rust/commits/89e880d613bc797b3867f91cd7f676c9b4737397", "html_url": "https://github.com/rust-lang/rust/commit/89e880d613bc797b3867f91cd7f676c9b4737397"}], "stats": {"total": 200, "additions": 190, "deletions": 10}, "files": [{"sha": "54267c570fe340cc7f3d2e524798605f3cd849ef", "filename": "src/cargo/cargo.rc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10cf4a1b0a90787ed50f3153f481e7128cffbec7/src%2Fcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/10cf4a1b0a90787ed50f3153f481e7128cffbec7/src%2Fcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rc?ref=10cf4a1b0a90787ed50f3153f481e7128cffbec7", "patch": "@@ -2,13 +2,15 @@\n \n // cargo.rs - Rust package manager\n \n-use std;\n-use rustc;\n-\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n // compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n+\n+#[link(name = \"cargo\",\n+       vers = \"0.1\",\n+       uuid = \"9ff87a04-8fed-4295-9ff8-f99bb802650b\",\n+       url = \"http://rust-lang.org/doc/cargo\")];"}, {"sha": "ab6493ae77cc08412061cd19a01814c0b3059e51", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 185, "deletions": 7, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/10cf4a1b0a90787ed50f3153f481e7128cffbec7/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10cf4a1b0a90787ed50f3153f481e7128cffbec7/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=10cf4a1b0a90787ed50f3153f481e7128cffbec7", "patch": "@@ -1,5 +1,8 @@\n // cargo.rs - Rust package manager\n \n+use rustc;\n+use std;\n+\n import rustc::syntax::{ast, codemap, visit};\n import rustc::syntax::parse::parser;\n \n@@ -9,18 +12,39 @@ import std::io;\n import std::json;\n import option;\n import option::{none, some};\n+import result;\n+import std::map;\n import std::os;\n import std::run;\n import str;\n import std::tempfile;\n import vec;\n \n+tag _src {\n+    /* Break cycles in package <-> source */\n+    _source(source);\n+}\n+\n+type package = {\n+    source: _src,\n+    name: str,\n+    uuid: str,\n+    url: str\n+};\n+\n+type source = {\n+    name: str,\n+    url: str,\n+    mutable packages: [package]\n+};\n+\n type cargo = {\n     root: str,\n     bindir: str,\n     libdir: str,\n     workdir: str,\n-    fetchdir: str\n+    sourcedir: str,\n+    sources: map::hashmap<str, source>\n };\n \n type pkg = {\n@@ -32,6 +56,14 @@ type pkg = {\n     crate_type: option::t<str>\n };\n \n+fn info(msg: str) {\n+    io::stdout().write_line(msg);\n+}\n+\n+fn warn(msg: str) {\n+    io::stdout().write_line(\"warning: \" + msg);\n+}\n+\n fn load_link(mis: [@ast::meta_item]) -> (option::t<str>,\n                                          option::t<str>,\n                                          option::t<str>) {\n@@ -118,6 +150,96 @@ fn need_dir(s: str) {\n     }\n }\n \n+fn parse_source(name: str, j: json::json) -> source {\n+    alt j {\n+        json::dict(_j) {\n+            alt _j.find(\"url\") {\n+                some(json::string(u)) {\n+                    ret { name: name, url: u, mutable packages: [] };\n+                }\n+                _ { fail \"Needed 'url' field in source.\"; }\n+            };\n+        }\n+        _ { fail \"Needed dict value in source.\"; }\n+    };\n+}\n+\n+fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n+    if !fs::path_exists(filename)  { ret; }\n+    let c = io::read_whole_file_str(filename);\n+    let j = json::from_str(result::get(c));\n+    alt j {\n+        some(json::dict(_j)) {\n+            _j.items { |k, v|\n+                sources.insert(k, parse_source(k, v));\n+                log #fmt[\"source: %s\", k];\n+            }\n+        }\n+        _ { fail \"malformed sources.json\"; }\n+    }\n+}\n+\n+fn load_one_source_package(c: cargo, src: source, p: map::hashmap<str, json::json>) {\n+    let name = alt p.find(\"name\") {\n+        some(json::string(_n)) { _n }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name + \" (missing name)\");\n+            ret;\n+        }\n+    };\n+\n+    let uuid = alt p.find(\"uuid\") {\n+        some(json::string(_n)) { _n }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name + \" (missing uuid)\");\n+            ret;\n+        }\n+    };\n+\n+    let url = alt p.find(\"url\") {\n+        some(json::string(_n)) { _n }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name + \" (missing url)\");\n+            ret;\n+        }\n+    };\n+\n+    vec::grow(src.packages, 1u, {\n+        source: _source(src),\n+        name: name,\n+        uuid: uuid,\n+        url: url\n+    });\n+    info(\"  Loaded package: \" + src.name + \"/\" + name);\n+}\n+\n+fn load_source_packages(c: cargo, src: source) {\n+    info(\"Loading source: \" + src.name);\n+    let dir = fs::connect(c.sourcedir, src.name);\n+    let pkgfile = fs::connect(dir, \"packages.json\");\n+    if !fs::path_exists(pkgfile) { ret; }\n+    let pkgstr = io::read_whole_file_str(pkgfile);\n+    let j = json::from_str(result::get(pkgstr));\n+    alt j {\n+        some(json::list(js)) {\n+            for _j: json::json in *js {\n+                alt _j {\n+                    json::dict(_p) {\n+                        load_one_source_package(c, src, _p);\n+                    }\n+                    _ {\n+                        warn(\"Malformed source json: \" + src.name + \" (non-dict pkg)\");\n+                        ret;\n+                    }\n+                }\n+            }\n+        }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name);\n+        }\n+    };\n+}\n+\n fn configure() -> cargo {\n     let p = alt generic_os::getenv(\"CARGO_ROOT\") {\n         some(_p) { _p }\n@@ -129,25 +251,39 @@ fn configure() -> cargo {\n         }\n     };\n \n-    log #fmt[\"p: %s\", p];\n-\n+    let sources = map::new_str_hash::<source>();\n+    try_parse_sources(fs::connect(p, \"sources.json\"), sources);\n+    try_parse_sources(fs::connect(p, \"local-sources.json\"), sources);\n     let c = {\n         root: p,\n         bindir: fs::connect(p, \"bin\"),\n         libdir: fs::connect(p, \"lib\"),\n         workdir: fs::connect(p, \"work\"),\n-        fetchdir: fs::connect(p, \"fetch\")\n+        sourcedir: fs::connect(p, \"sources\"),\n+        sources: sources\n     };\n \n     need_dir(c.root);\n-    need_dir(c.fetchdir);\n+    need_dir(c.sourcedir);\n     need_dir(c.workdir);\n     need_dir(c.libdir);\n     need_dir(c.bindir);\n \n+    sources.values { |v|\n+        load_source_packages(c, v);\n+    };\n+\n     c\n }\n \n+fn for_each_package(c: cargo, b: block(package)) {\n+    c.sources.values({ |v|\n+        for p in v.packages {\n+            b(p);\n+        }\n+    })\n+}\n+\n fn install_one_crate(c: cargo, _path: str, cf: str, _p: pkg) {\n     let name = fs::basename(cf);\n     let ri = str::index(name, '.' as u8);\n@@ -233,11 +369,29 @@ fn install_resolved(c: cargo, wd: str, key: str) {\n }\n \n fn install_uuid(c: cargo, wd: str, uuid: str) {\n-    install_resolved(c, wd, \"by-uuid/\" + uuid);\n+    let ps = [];\n+    for_each_package(c, { |p|\n+        if p.uuid == uuid {\n+            vec::grow(ps, 1u, p);\n+        }\n+    });\n+    info(\"Found:\");\n+    for p in ps {\n+        info(\"  \" + p.source.name + \"/\" + p.name);\n+    }\n }\n \n fn install_named(c: cargo, wd: str, name: str) {\n-    install_resolved(c, wd, \"by-name/\" + name);\n+    let ps = [];\n+    for_each_package(c, { |p|\n+        if p.name == name {\n+            vec::grow(ps, 1u, p);\n+        }\n+    });\n+    info(\"Found:\");\n+    for p in ps {\n+        info(\"  \" + p.source.name + \"/\" + p.name);\n+    }\n }\n \n fn cmd_install(c: cargo, argv: [str]) {\n@@ -268,6 +422,29 @@ fn cmd_install(c: cargo, argv: [str]) {\n     }\n }\n \n+fn sync_one(c: cargo, name: str, src: source) {\n+    let dir = fs::connect(c.sourcedir, name);\n+    let pkgfile = fs::connect(dir, \"packages.json\");\n+    let url = src.url;\n+    need_dir(dir);\n+    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]);\n+    if p.status != 0 {\n+        warn(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+    } else {\n+        info(#fmt[\"fetched source: %s\", name]);\n+    }\n+}\n+\n+fn cmd_sync(c: cargo, argv: [str]) {\n+    if vec::len(argv) == 3u {\n+        sync_one(c, argv[2], c.sources.get(argv[2]));\n+    } else {\n+        c.sources.items { |k, v|\n+            sync_one(c, k, v);\n+        }\n+    }\n+}\n+\n fn cmd_usage() {\n     print(\"Usage: cargo <verb> [args...]\");\n }\n@@ -280,6 +457,7 @@ fn main(argv: [str]) {\n     let c = configure();\n     alt argv[1] {\n         \"install\" { cmd_install(c, argv); }\n+        \"sync\" { cmd_sync(c, argv); }\n         \"usage\" { cmd_usage(); }\n         _ { cmd_usage(); }\n     }"}]}