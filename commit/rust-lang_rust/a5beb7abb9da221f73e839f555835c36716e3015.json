{"sha": "a5beb7abb9da221f73e839f555835c36716e3015", "node_id": "C_kwDOAAsO6NoAKGE1YmViN2FiYjlkYTIyMWY3M2U4MzlmNTU1ODM1YzM2NzE2ZTMwMTU", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-12-14T05:30:42Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-12-15T07:11:52Z"}, "message": "Various cleanups to dest prop", "tree": {"sha": "3fef8a6276d7c1d60b1abf8827c149195499d2b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fef8a6276d7c1d60b1abf8827c149195499d2b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5beb7abb9da221f73e839f555835c36716e3015", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5beb7abb9da221f73e839f555835c36716e3015", "html_url": "https://github.com/rust-lang/rust/commit/a5beb7abb9da221f73e839f555835c36716e3015", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5beb7abb9da221f73e839f555835c36716e3015/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939a3ddf943f962807b84a44e8b31d99c0db0a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/939a3ddf943f962807b84a44e8b31d99c0db0a94", "html_url": "https://github.com/rust-lang/rust/commit/939a3ddf943f962807b84a44e8b31d99c0db0a94"}], "stats": {"total": 171, "additions": 88, "deletions": 83}, "files": [{"sha": "3e45319431cec0e9de6816ed78310c892d09d461", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 88, "deletions": 83, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/a5beb7abb9da221f73e839f555835c36716e3015/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5beb7abb9da221f73e839f555835c36716e3015/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=a5beb7abb9da221f73e839f555835c36716e3015", "patch": "@@ -132,15 +132,12 @@ use std::collections::hash_map::{Entry, OccupiedEntry};\n use crate::MirPass;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n use rustc_middle::mir::{dump_mir, PassWhere};\n use rustc_middle::mir::{\n     traversal, BasicBlock, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place,\n     Rvalue, Statement, StatementKind, TerminatorKind,\n };\n-use rustc_middle::mir::{\n-    visit::{MutVisitor, PlaceContext, Visitor},\n-    ProjectionElem,\n-};\n use rustc_middle::ty::TyCtxt;\n use rustc_mir_dataflow::impls::MaybeLiveLocals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -359,40 +356,45 @@ struct FilterInformation<'a, 'body, 'alloc, 'tcx> {\n // through these methods, and not directly.\n impl<'alloc> Candidates<'alloc> {\n     /// Just `Vec::retain`, but the condition is inverted and we add debugging output\n-    fn vec_remove_debug(\n+    fn vec_filter_candidates(\n         src: Local,\n         v: &mut Vec<Local>,\n-        mut f: impl FnMut(Local) -> bool,\n+        mut f: impl FnMut(Local) -> CandidateFilter,\n         at: Location,\n     ) {\n         v.retain(|dest| {\n             let remove = f(*dest);\n-            if remove {\n+            if remove == CandidateFilter::Remove {\n                 trace!(\"eliminating {:?} => {:?} due to conflict at {:?}\", src, dest, at);\n             }\n-            !remove\n+            remove == CandidateFilter::Keep\n         });\n     }\n \n-    /// `vec_remove_debug` but for an `Entry`\n-    fn entry_remove(\n+    /// `vec_filter_candidates` but for an `Entry`\n+    fn entry_filter_candidates(\n         mut entry: OccupiedEntry<'_, Local, Vec<Local>>,\n         p: Local,\n-        f: impl FnMut(Local) -> bool,\n+        f: impl FnMut(Local) -> CandidateFilter,\n         at: Location,\n     ) {\n         let candidates = entry.get_mut();\n-        Self::vec_remove_debug(p, candidates, f, at);\n+        Self::vec_filter_candidates(p, candidates, f, at);\n         if candidates.len() == 0 {\n             entry.remove();\n         }\n     }\n \n-    /// Removes all candidates `(p, q)` or `(q, p)` where `p` is the indicated local and `f(q)` is true.\n-    fn remove_candidates_if(&mut self, p: Local, mut f: impl FnMut(Local) -> bool, at: Location) {\n+    /// For all candidates `(p, q)` or `(q, p)` removes the candidate if `f(q)` says to do so\n+    fn filter_candidates_by(\n+        &mut self,\n+        p: Local,\n+        mut f: impl FnMut(Local) -> CandidateFilter,\n+        at: Location,\n+    ) {\n         // Cover the cases where `p` appears as a `src`\n         if let Entry::Occupied(entry) = self.c.entry(p) {\n-            Self::entry_remove(entry, p, &mut f, at);\n+            Self::entry_filter_candidates(entry, p, &mut f, at);\n         }\n         // And the cases where `p` appears as a `dest`\n         let Some(srcs) = self.reverse.get_mut(&p) else {\n@@ -401,18 +403,31 @@ impl<'alloc> Candidates<'alloc> {\n         // We use `retain` here to remove the elements from the reverse set if we've removed the\n         // matching candidate in the forward set.\n         srcs.retain(|src| {\n-            if !f(*src) {\n+            if f(*src) == CandidateFilter::Keep {\n                 return true;\n             }\n             let Entry::Occupied(entry) = self.c.entry(*src) else {\n                 return false;\n             };\n-            Self::entry_remove(entry, *src, |dest| dest == p, at);\n+            Self::entry_filter_candidates(\n+                entry,\n+                *src,\n+                |dest| {\n+                    if dest == p { CandidateFilter::Remove } else { CandidateFilter::Keep }\n+                },\n+                at,\n+            );\n             false\n         });\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum CandidateFilter {\n+    Keep,\n+    Remove,\n+}\n+\n impl<'a, 'body, 'alloc, 'tcx> FilterInformation<'a, 'body, 'alloc, 'tcx> {\n     /// Filters the set of candidates to remove those that conflict.\n     ///\n@@ -460,7 +475,7 @@ impl<'a, 'body, 'alloc, 'tcx> FilterInformation<'a, 'body, 'alloc, 'tcx> {\n             for (i, statement) in data.statements.iter().enumerate().rev() {\n                 self.at = Location { block, statement_index: i };\n                 self.live.seek_after_primary_effect(self.at);\n-                self.get_statement_write_info(&statement.kind);\n+                self.write_info.for_statement(&statement.kind, self.body);\n                 self.apply_conflicts();\n             }\n         }\n@@ -469,80 +484,59 @@ impl<'a, 'body, 'alloc, 'tcx> FilterInformation<'a, 'body, 'alloc, 'tcx> {\n     fn apply_conflicts(&mut self) {\n         let writes = &self.write_info.writes;\n         for p in writes {\n-            self.candidates.remove_candidates_if(\n+            let other_skip = self.write_info.skip_pair.and_then(|(a, b)| {\n+                if a == *p {\n+                    Some(b)\n+                } else if b == *p {\n+                    Some(a)\n+                } else {\n+                    None\n+                }\n+            });\n+            self.candidates.filter_candidates_by(\n                 *p,\n-                // It is possible that a local may be live for less than the\n-                // duration of a statement This happens in the case of function\n-                // calls or inline asm. Because of this, we also mark locals as\n-                // conflicting when both of them are written to in the same\n-                // statement.\n-                |q| self.live.contains(q) || writes.contains(&q),\n+                |q| {\n+                    if Some(q) == other_skip {\n+                        return CandidateFilter::Keep;\n+                    }\n+                    // It is possible that a local may be live for less than the\n+                    // duration of a statement This happens in the case of function\n+                    // calls or inline asm. Because of this, we also mark locals as\n+                    // conflicting when both of them are written to in the same\n+                    // statement.\n+                    if self.live.contains(q) || writes.contains(&q) {\n+                        CandidateFilter::Remove\n+                    } else {\n+                        CandidateFilter::Keep\n+                    }\n+                },\n                 self.at,\n             );\n         }\n     }\n-\n-    /// Gets the write info for the `statement`.\n-    fn get_statement_write_info(&mut self, statement: &StatementKind<'tcx>) {\n-        self.write_info.writes.clear();\n-        match statement {\n-            StatementKind::Assign(box (lhs, rhs)) => match rhs {\n-                Rvalue::Use(op) => {\n-                    if !lhs.is_indirect() {\n-                        self.get_assign_use_write_info(*lhs, op);\n-                        return;\n-                    }\n-                }\n-                _ => (),\n-            },\n-            _ => (),\n-        }\n-\n-        self.write_info.for_statement(statement);\n-    }\n-\n-    fn get_assign_use_write_info(&mut self, lhs: Place<'tcx>, rhs: &Operand<'tcx>) {\n-        // We register the writes for the operand unconditionally\n-        self.write_info.add_operand(rhs);\n-        // However, we cannot do the same thing for the `lhs` as that would always block the\n-        // optimization. Instead, we consider removing candidates manually.\n-        let Some(rhs) = rhs.place() else {\n-            self.write_info.add_place(lhs);\n-            return;\n-        };\n-        // Find out which candidate pair we should skip, if any\n-        let Some((src, dest)) = places_to_candidate_pair(lhs, rhs, self.body) else {\n-            self.write_info.add_place(lhs);\n-            return;\n-        };\n-        self.candidates.remove_candidates_if(\n-            lhs.local,\n-            |other| {\n-                // Check if this is the candidate pair that should not be removed\n-                if (lhs.local == src && other == dest) || (lhs.local == dest && other == src) {\n-                    return false;\n-                }\n-                // Otherwise, do the \"standard\" thing\n-                self.live.contains(other)\n-            },\n-            self.at,\n-        )\n-    }\n }\n \n /// Describes where a statement/terminator writes to\n #[derive(Default, Debug)]\n struct WriteInfo {\n     writes: Vec<Local>,\n+    /// If this pair of locals is a candidate pair, completely skip processing it during this\n+    /// statement. All other candidates are unaffected.\n+    skip_pair: Option<(Local, Local)>,\n }\n \n impl WriteInfo {\n-    fn for_statement<'tcx>(&mut self, statement: &StatementKind<'tcx>) {\n+    fn for_statement<'tcx>(&mut self, statement: &StatementKind<'tcx>, body: &Body<'tcx>) {\n+        self.reset();\n         match statement {\n             StatementKind::Assign(box (lhs, rhs)) => {\n                 self.add_place(*lhs);\n                 match rhs {\n-                    Rvalue::Use(op) | Rvalue::Repeat(op, _) => {\n+                    Rvalue::Use(op) => {\n+                        self.add_operand(op);\n+                        self.consider_skipping_for_assign_use(*lhs, op, body);\n+                    }\n+                    Rvalue::Repeat(op, _) => {\n                         self.add_operand(op);\n                     }\n                     Rvalue::Cast(_, op, _)\n@@ -586,8 +580,22 @@ impl WriteInfo {\n         }\n     }\n \n+    fn consider_skipping_for_assign_use<'tcx>(\n+        &mut self,\n+        lhs: Place<'tcx>,\n+        rhs: &Operand<'tcx>,\n+        body: &Body<'tcx>,\n+    ) {\n+        let Some(rhs) = rhs.place() else {\n+            return\n+        };\n+        if let Some(pair) = places_to_candidate_pair(lhs, rhs, body) {\n+            self.skip_pair = Some(pair);\n+        }\n+    }\n+\n     fn for_terminator<'tcx>(&mut self, terminator: &TerminatorKind<'tcx>) {\n-        self.writes.clear();\n+        self.reset();\n         match terminator {\n             TerminatorKind::SwitchInt { discr: op, .. }\n             | TerminatorKind::Assert { cond: op, .. } => {\n@@ -657,15 +665,16 @@ impl WriteInfo {\n             Operand::Copy(_) | Operand::Constant(_) => (),\n         }\n     }\n+\n+    fn reset(&mut self) {\n+        self.writes.clear();\n+        self.skip_pair = None;\n+    }\n }\n \n /////////////////////////////////////////////////////\n // Candidate accumulation\n \n-fn is_constant<'tcx>(place: Place<'tcx>) -> bool {\n-    place.projection.iter().all(|p| !matches!(p, ProjectionElem::Deref | ProjectionElem::Index(_)))\n-}\n-\n /// If the pair of places is being considered for merging, returns the candidate which would be\n /// merged in order to accomplish this.\n ///\n@@ -741,10 +750,6 @@ impl<'tcx> Visitor<'tcx> for FindAssignments<'_, '_, 'tcx> {\n             Rvalue::Use(Operand::Copy(rhs) | Operand::Move(rhs)),\n         )) = &statement.kind\n         {\n-            if !is_constant(*lhs) || !is_constant(*rhs) {\n-                return;\n-            }\n-\n             let Some((src, dest)) = places_to_candidate_pair(*lhs, *rhs, self.body) else {\n                 return;\n             };"}]}