{"sha": "3410c52eecf7e10399d105f312203198a597b4ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MTBjNTJlZWNmN2UxMDM5OWQxMDVmMzEyMjAzMTk4YTU5N2I0ZWQ=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-10-15T15:14:30Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-10-16T15:15:36Z"}, "message": "librustc: Remove trans::reflect and the opaque and ty_visitor lang items.", "tree": {"sha": "d2ab30ff17e3f43c9b73fcf650be06a0f20ffa79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2ab30ff17e3f43c9b73fcf650be06a0f20ffa79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3410c52eecf7e10399d105f312203198a597b4ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3410c52eecf7e10399d105f312203198a597b4ed", "html_url": "https://github.com/rust-lang/rust/commit/3410c52eecf7e10399d105f312203198a597b4ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3410c52eecf7e10399d105f312203198a597b4ed/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7210a5af8716765f5ed9b71edc6f7e1719f71f18", "url": "https://api.github.com/repos/rust-lang/rust/commits/7210a5af8716765f5ed9b71edc6f7e1719f71f18", "html_url": "https://github.com/rust-lang/rust/commit/7210a5af8716765f5ed9b71edc6f7e1719f71f18"}], "stats": {"total": 497, "additions": 4, "deletions": 493}, "files": [{"sha": "dfdadb3546bac9195cc7dd44bffd191c44bf2cc0", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3410c52eecf7e10399d105f312203198a597b4ed/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/3410c52eecf7e10399d105f312203198a597b4ed/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=3410c52eecf7e10399d105f312203198a597b4ed", "patch": "@@ -2279,8 +2279,6 @@ These types help drive the compiler's analysis\n   : The lifetime parameter should be considered invariant\n * `malloc`\n   : Allocate memory on the managed heap.\n-* `opaque`\n-  : ___Needs filling in___\n * `owned_box`\n   : ___Needs filling in___\n * `stack_exhausted`\n@@ -2295,8 +2293,6 @@ These types help drive the compiler's analysis\n   : The type parameter should be considered invariant\n * `ty_desc`\n   : ___Needs filling in___\n-* `ty_visitor`\n-  : ___Needs filling in___\n \n > **Note:** This list is likely to become out of date. We should auto-generate\n > it from `librustc/middle/lang_items.rs`."}, {"sha": "3d593a0d026d09555b767306597a165df0fb3eee", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3410c52eecf7e10399d105f312203198a597b4ed/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410c52eecf7e10399d105f312203198a597b4ed/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=3410c52eecf7e10399d105f312203198a597b4ed", "patch": "@@ -65,11 +65,14 @@ pub struct TyDesc {\n     pub name: &'static str,\n }\n \n+#[cfg(stage0)]\n #[lang=\"opaque\"]\n pub enum Opaque { }\n \n+#[cfg(stage0)]\n pub type Disr = u64;\n \n+#[cfg(stage0)]\n #[lang=\"ty_visitor\"]\n pub trait TyVisitor {\n     fn visit_bot(&mut self) -> bool;"}, {"sha": "68411549c3cefc1a91782b97b71089a7b5871940", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3410c52eecf7e10399d105f312203198a597b4ed/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410c52eecf7e10399d105f312203198a597b4ed/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3410c52eecf7e10399d105f312203198a597b4ed", "patch": "@@ -284,7 +284,6 @@ lets_do_this! {\n     StartFnLangItem,                 \"start\",                   start_fn;\n \n     TyDescStructLangItem,            \"ty_desc\",                 ty_desc;\n-    TyVisitorTraitLangItem,          \"ty_visitor\",              ty_visitor;\n     OpaqueStructLangItem,            \"opaque\",                  opaque;\n \n     TypeIdLangItem,                  \"type_id\",                 type_id;"}, {"sha": "fe7697447acda8a897a3f7af36cc0e92c80672df", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3410c52eecf7e10399d105f312203198a597b4ed/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410c52eecf7e10399d105f312203198a597b4ed/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=3410c52eecf7e10399d105f312203198a597b4ed", "patch": "@@ -36,7 +36,6 @@ pub mod cabi_arm;\n pub mod cabi_mips;\n pub mod foreign;\n pub mod intrinsic;\n-pub mod reflect;\n pub mod debuginfo;\n pub mod machine;\n pub mod adt;"}, {"sha": "96c2c1f1450b8c5791133a124526f7ed238e0a11", "filename": "src/librustc/middle/trans/reflect.rs", "status": "removed", "additions": 0, "deletions": 458, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/7210a5af8716765f5ed9b71edc6f7e1719f71f18/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7210a5af8716765f5ed9b71edc6f7e1719f71f18/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=7210a5af8716765f5ed9b71edc6f7e1719f71f18", "patch": "@@ -1,458 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm::{ValueRef, get_param};\n-use middle::trans::adt;\n-use middle::trans::base::*;\n-use middle::trans::build::*;\n-use middle::trans::callee::ArgVals;\n-use middle::trans::callee;\n-use middle::trans::common::*;\n-use middle::trans::datum::*;\n-use middle::trans::machine;\n-use middle::trans::meth;\n-use middle::trans::type_::Type;\n-use middle::trans::type_of::*;\n-use middle::ty;\n-use util::ppaux::ty_to_string;\n-\n-use arena::TypedArena;\n-use libc::c_uint;\n-use syntax::ast::DefId;\n-use syntax::ast;\n-use syntax::ast_map;\n-use syntax::parse::token::{InternedString, special_idents};\n-use syntax::parse::token;\n-\n-pub struct Reflector<'a, 'blk, 'tcx: 'blk> {\n-    visitor_val: ValueRef,\n-    visitor_items: &'a [ty::ImplOrTraitItem],\n-    final_bcx: Block<'blk, 'tcx>,\n-    tydesc_ty: Type,\n-    bcx: Block<'blk, 'tcx>\n-}\n-\n-impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n-    pub fn c_uint(&mut self, u: uint) -> ValueRef {\n-        C_uint(self.bcx.ccx(), u)\n-    }\n-\n-    pub fn c_bool(&mut self, b: bool) -> ValueRef {\n-        C_bool(self.bcx.ccx(), b)\n-    }\n-\n-    pub fn c_slice(&mut self, s: InternedString) -> ValueRef {\n-        // We're careful to not use first class aggregates here because that\n-        // will kick us off fast isel. (Issue #4352.)\n-        let bcx = self.bcx;\n-        let str_ty = ty::mk_str_slice(bcx.tcx(), ty::ReStatic, ast::MutImmutable);\n-        let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n-        let len = C_uint(bcx.ccx(), s.get().len());\n-        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s, false), Type::i8p(bcx.ccx()));\n-        Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n-        Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n-        scratch.val\n-    }\n-\n-    pub fn c_size_and_align(&mut self, t: ty::t) -> Vec<ValueRef> {\n-        let tr = type_of(self.bcx.ccx(), t);\n-        let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n-        let a = align_of(self.bcx.ccx(), t);\n-        return vec!(self.c_uint(s as uint),\n-             self.c_uint(a as uint));\n-    }\n-\n-    pub fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n-        let bcx = self.bcx;\n-        let static_ti = get_tydesc(bcx.ccx(), t);\n-        PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n-    }\n-\n-    pub fn c_mt(&mut self, mt: &ty::mt) -> Vec<ValueRef> {\n-        vec!(self.c_uint(mt.mutbl as uint),\n-          self.c_tydesc(mt.ty))\n-    }\n-\n-    pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n-        let fcx = self.bcx.fcx;\n-        let tcx = self.bcx.tcx();\n-        let mth_idx = ty::impl_or_trait_item_idx(token::str_to_ident(format!(\n-                        \"visit_{}\", ty_name).as_slice()),\n-                                     self.visitor_items.as_slice()).expect(\n-                format!(\"couldn't find visit method for {}\", ty_name).as_slice());\n-        let method = match self.visitor_items[mth_idx] {\n-            ty::MethodTraitItem(ref method) => (*method).clone(),\n-            ty::TypeTraitItem(_) => return,\n-        };\n-        let mth_ty = ty::mk_bare_fn(tcx, method.fty.clone());\n-        debug!(\"Emit call visit method: visit_{}: {}\", ty_name, ty_to_string(tcx, mth_ty));\n-        let v = self.visitor_val;\n-        debug!(\"passing {} args:\", args.len());\n-        let mut bcx = self.bcx;\n-        for (i, a) in args.iter().enumerate() {\n-            debug!(\"arg {}: {}\", i, bcx.val_to_string(*a));\n-        }\n-        let result = unpack_result!(bcx, callee::trans_call_inner(\n-            self.bcx, None, mth_ty,\n-            |bcx, _| meth::trans_trait_callee_from_llval(bcx,\n-                                                         mth_ty,\n-                                                         mth_idx,\n-                                                         v),\n-            ArgVals(args), None));\n-        let next_bcx = fcx.new_temp_block(\"next\");\n-        CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n-        self.bcx = next_bcx\n-    }\n-\n-    pub fn bracketed(&mut self,\n-                     bracket_name: &str,\n-                     extra: &[ValueRef],\n-                     inner: |&mut Reflector|) {\n-        self.visit(format!(\"enter_{}\", bracket_name).as_slice(), extra);\n-        inner(self);\n-        self.visit(format!(\"leave_{}\", bracket_name).as_slice(), extra);\n-    }\n-\n-    pub fn leaf(&mut self, name: &str) {\n-        self.visit(name, []);\n-    }\n-\n-    fn visit_closure_ty(&mut self, fty: &ty::ClosureTy, is_unboxed: bool) {\n-        let pureval = ast_fn_style_constant(fty.fn_style);\n-        let sigilval = match fty.store {\n-            ty::UniqTraitStore => 2u,\n-            ty::RegionTraitStore(..) => 4u,\n-        };\n-        let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-        let extra = vec!(self.c_uint(pureval),\n-                         self.c_uint(sigilval),\n-                         self.c_uint(fty.sig.inputs.len()),\n-                         self.c_uint(retval));\n-        self.visit(\"enter_fn\", extra.as_slice());\n-        self.visit_sig(retval, &fty.sig, is_unboxed);\n-        self.visit(\"leave_fn\", extra.as_slice());\n-    }\n-\n-    // Entrypoint\n-    pub fn visit_ty(&mut self, t: ty::t) {\n-        let bcx = self.bcx;\n-        let tcx = bcx.tcx();\n-        debug!(\"reflect::visit_ty {}\", ty_to_string(bcx.tcx(), t));\n-\n-        match ty::get(t).sty {\n-          ty::ty_bot => self.leaf(\"bot\"),\n-          ty::ty_nil => self.leaf(\"nil\"),\n-          ty::ty_bool => self.leaf(\"bool\"),\n-          ty::ty_char => self.leaf(\"char\"),\n-          ty::ty_int(ast::TyI) => self.leaf(\"int\"),\n-          ty::ty_int(ast::TyI8) => self.leaf(\"i8\"),\n-          ty::ty_int(ast::TyI16) => self.leaf(\"i16\"),\n-          ty::ty_int(ast::TyI32) => self.leaf(\"i32\"),\n-          ty::ty_int(ast::TyI64) => self.leaf(\"i64\"),\n-          ty::ty_uint(ast::TyU) => self.leaf(\"uint\"),\n-          ty::ty_uint(ast::TyU8) => self.leaf(\"u8\"),\n-          ty::ty_uint(ast::TyU16) => self.leaf(\"u16\"),\n-          ty::ty_uint(ast::TyU32) => self.leaf(\"u32\"),\n-          ty::ty_uint(ast::TyU64) => self.leaf(\"u64\"),\n-          ty::ty_float(ast::TyF32) => self.leaf(\"f32\"),\n-          ty::ty_float(ast::TyF64) => self.leaf(\"f64\"),\n-\n-          ty::ty_open(_) | ty::ty_str | ty::ty_vec(_, None) | ty::ty_trait(..) => {\n-              // Unfortunately we can't do anything here because at runtime we\n-              // pass around the value by pointer (*u8). But unsized pointers are\n-              // fat and so we can't just cast them to *u8 and back. So we have\n-              // to work with the pointer directly (see ty_ptr/ty_rptr/ty_uniq).\n-              fail!(\"Can't reflect unsized type\")\n-          }\n-          // FIXME(15049) Reflection for unsized structs.\n-          ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), t) => {\n-              fail!(\"Can't reflect unsized type\")\n-          }\n-\n-          // Should rename to vec_*.\n-          ty::ty_vec(ty, Some(sz)) => {\n-              let mut extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n-              extra.push(self.c_tydesc(ty));\n-              self.visit(\"evec_fixed\", extra.as_slice())\n-          }\n-          ty::ty_ptr(ref mt) => {\n-              match ty::get(mt.ty).sty {\n-                  ty::ty_vec(ty, None) => {\n-                      let extra = self.c_mt(&ty::mt{ty: ty, mutbl: mt.mutbl});\n-                      self.visit(\"evec_slice\", extra.as_slice())\n-                  }\n-                  ty::ty_str => self.visit(\"estr_slice\", &[]),\n-                  ty::ty_trait(..) => {\n-                      let extra = [\n-                          self.c_slice(token::intern_and_get_ident(\n-                                  ty_to_string(tcx, t).as_slice()))\n-                      ];\n-                      self.visit(\"trait\", extra);\n-                  }\n-                  _ => {\n-                      let extra = self.c_mt(mt);\n-                      self.visit(\"ptr\", extra.as_slice())\n-                  }\n-              }\n-          }\n-          ty::ty_uniq(typ) => {\n-              match ty::get(typ).sty {\n-                  ty::ty_trait(..) => {\n-                      let extra = [\n-                          self.c_slice(token::intern_and_get_ident(\n-                                  ty_to_string(tcx, t).as_slice()))\n-                      ];\n-                      self.visit(\"trait\", extra);\n-                  }\n-                  // FIXME(15049) allow reflection of Box<[T]>. You'll need to\n-                  // restore visit_evec_uniq.\n-                  ty::ty_vec(_, None) => {\n-                      fail!(\"Box<[T]> theoretically doesn't exist, so don't try to reflect it\")\n-                  }\n-                  ty::ty_str => fail!(\"Can't reflect Box<str> which shouldn't be used anyway\"),\n-                  _ => {\n-                      let extra = self.c_mt(&ty::mt {\n-                          ty: typ,\n-                          mutbl: ast::MutImmutable,\n-                      });\n-                      self.visit(\"uniq\", extra.as_slice())\n-                  }\n-              }\n-          }\n-          ty::ty_rptr(_, ref mt) => {\n-              match ty::get(mt.ty).sty {\n-                  ty::ty_vec(ty, None) => {\n-                      let extra = self.c_mt(&ty::mt{ty: ty, mutbl: mt.mutbl});\n-                      self.visit(\"evec_slice\", extra.as_slice())\n-                  }\n-                  ty::ty_str => self.visit(\"estr_slice\", &[]),\n-                  ty::ty_trait(..) => {\n-                      let extra = [\n-                          self.c_slice(token::intern_and_get_ident(\n-                                  ty_to_string(tcx, t).as_slice()))\n-                      ];\n-                      self.visit(\"trait\", extra);\n-                  }\n-                  _ => {\n-                      let extra = self.c_mt(mt);\n-                      self.visit(\"rptr\", extra.as_slice())\n-                  }\n-              }\n-          }\n-\n-          ty::ty_tup(ref tys) => {\n-              let extra = (vec!(self.c_uint(tys.len())))\n-                          .append(self.c_size_and_align(t).as_slice());\n-              self.bracketed(\"tup\", extra.as_slice(), |this| {\n-                  for (i, t) in tys.iter().enumerate() {\n-                      let extra = vec!(this.c_uint(i), this.c_tydesc(*t));\n-                      this.visit(\"tup_field\", extra.as_slice());\n-                  }\n-              })\n-          }\n-\n-          // FIXME (#2594): fetch constants out of intrinsic\n-          // FIXME (#4809): visitor should break out bare fns from other fns\n-          ty::ty_closure(box ref fty) => {\n-              self.visit_closure_ty(fty, false);\n-          }\n-\n-          // FIXME (#2594): fetch constants out of intrinsic:: for the\n-          // numbers.\n-          ty::ty_bare_fn(ref fty) => {\n-            let pureval = ast_fn_style_constant(fty.fn_style);\n-            let sigilval = 0u;\n-            let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-            let extra = vec!(self.c_uint(pureval),\n-                          self.c_uint(sigilval),\n-                          self.c_uint(fty.sig.inputs.len()),\n-                          self.c_uint(retval));\n-            self.visit(\"enter_fn\", extra.as_slice());\n-            self.visit_sig(retval, &fty.sig, false);\n-            self.visit(\"leave_fn\", extra.as_slice());\n-          }\n-\n-          ty::ty_struct(did, ref substs) => {\n-              let fields = ty::struct_fields(tcx, did, substs);\n-              let mut named_fields = false;\n-              if !fields.is_empty() {\n-                  named_fields = fields.get(0).ident.name !=\n-                      special_idents::unnamed_field.name;\n-              }\n-\n-              // This and the type_is_sized check on individual field types are\n-              // because we cannot reflect unsized types (see note above). We\n-              // just pretend the unsized field does not exist and print nothing.\n-              // This is sub-optimal.\n-              let len = fields.len();\n-\n-              let extra = (vec!(\n-                  self.c_slice(\n-                      token::intern_and_get_ident(ty_to_string(tcx,\n-                                                            t).as_slice())),\n-                  self.c_bool(named_fields),\n-                  self.c_uint(len)\n-              )).append(self.c_size_and_align(t).as_slice());\n-              self.bracketed(\"class\", extra.as_slice(), |this| {\n-                  for (i, field) in fields.iter().enumerate() {\n-                      let extra = (vec!(\n-                        this.c_uint(i),\n-                        this.c_slice(token::get_ident(field.ident)),\n-                        this.c_bool(named_fields)\n-                      )).append(this.c_mt(&field.mt).as_slice());\n-                      this.visit(\"class_field\", extra.as_slice());\n-                  }\n-              })\n-          }\n-\n-          // FIXME (#2595): visiting all the variants in turn is probably\n-          // not ideal. It'll work but will get costly on big enums. Maybe\n-          // let the visitor tell us if it wants to visit only a particular\n-          // variant?\n-          ty::ty_enum(did, ref substs) => {\n-            let ccx = bcx.ccx();\n-            let repr = adt::represent_type(bcx.ccx(), t);\n-            let variants = ty::substd_enum_variants(ccx.tcx(), did, substs);\n-            let llptrty = type_of(ccx, t).ptr_to();\n-            let opaquety = ty::get_opaque_ty(ccx.tcx()).unwrap();\n-            let opaqueptrty = ty::mk_ptr(ccx.tcx(), ty::mt { ty: opaquety,\n-                                                           mutbl: ast::MutImmutable });\n-\n-            let make_get_disr = || {\n-                let sym = mangle_internal_name_by_path_and_seq(\n-                    ast_map::Values([].iter()).chain(None), \"get_disr\");\n-\n-                let fn_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n-                                           [opaqueptrty], ty::mk_u64());\n-                let llfdecl = decl_internal_rust_fn(ccx,\n-                                                    fn_ty,\n-                                                    sym.as_slice());\n-                let arena = TypedArena::new();\n-                let empty_param_substs = param_substs::empty();\n-                let fcx = new_fn_ctxt(ccx, llfdecl, ast::DUMMY_NODE_ID, false,\n-                                      ty::mk_u64(), &empty_param_substs,\n-                                      None, &arena);\n-                let bcx = init_function(&fcx, false, ty::mk_u64());\n-\n-                // we know the return type of llfdecl is an int here, so\n-                // no need for a special check to see if the return type\n-                // is immediate.\n-                let arg = get_param(llfdecl, fcx.arg_pos(0u) as c_uint);\n-                let arg = BitCast(bcx, arg, llptrty);\n-                let ret = adt::trans_get_discr(bcx, &*repr, arg, Some(Type::i64(ccx)));\n-                assert!(!fcx.needs_ret_allocas);\n-                let ret_slot = fcx.get_ret_slot(bcx, ty::mk_u64(), \"ret_slot\");\n-                Store(bcx, ret, ret_slot);\n-                match fcx.llreturn.get() {\n-                    Some(llreturn) => Br(bcx, llreturn),\n-                    None => {}\n-                };\n-                finish_fn(&fcx, bcx, ty::mk_u64());\n-                llfdecl\n-            };\n-\n-            let enum_args = (vec!(self.c_uint(variants.len()), make_get_disr()))\n-                            .append(self.c_size_and_align(t).as_slice());\n-            self.bracketed(\"enum\", enum_args.as_slice(), |this| {\n-                for (i, v) in variants.iter().enumerate() {\n-                    let name = token::get_ident(v.name);\n-                    let variant_args = [this.c_uint(i),\n-                                         C_u64(ccx, v.disr_val),\n-                                         this.c_uint(v.args.len()),\n-                                         this.c_slice(name)];\n-                    this.bracketed(\"enum_variant\",\n-                                   variant_args,\n-                                   |this| {\n-                        for (j, a) in v.args.iter().enumerate() {\n-                            let bcx = this.bcx;\n-                            let null = C_null(llptrty);\n-                            let ptr = adt::trans_field_ptr(bcx, &*repr, null, v.disr_val, j);\n-                            let offset = p2i(ccx, ptr);\n-                            let field_args = [this.c_uint(j),\n-                                               offset,\n-                                               this.c_tydesc(*a)];\n-                            this.visit(\"enum_variant_field\",\n-                                       field_args);\n-                        }\n-                    })\n-                }\n-            })\n-          }\n-\n-          // Miscellaneous extra types\n-          ty::ty_infer(_) => self.leaf(\"infer\"),\n-          ty::ty_err => self.leaf(\"err\"),\n-          ty::ty_unboxed_closure(ref def_id, _) => {\n-              let closure_map = tcx.unboxed_closures.borrow();\n-              let fty = &closure_map.find(def_id).unwrap().closure_type;\n-              self.visit_closure_ty(fty, true);\n-          }\n-          ty::ty_param(ref p) => {\n-              let extra = vec!(self.c_uint(p.idx));\n-              self.visit(\"param\", extra.as_slice())\n-          }\n-        }\n-    }\n-\n-    pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig, is_unboxed: bool) {\n-        let args = if is_unboxed {\n-            match ty::get(sig.inputs[0]).sty {\n-                ty::ty_tup(ref contents) => contents.iter(),\n-                ty::ty_nil => [].iter(),\n-                _ => unreachable!()\n-            }\n-        } else {\n-            sig.inputs.iter()\n-        };\n-\n-        for (i, arg) in args.enumerate() {\n-            let modeval = 5u;   // \"by copy\"\n-            let extra = vec!(self.c_uint(i),\n-                         self.c_uint(modeval),\n-                         self.c_tydesc(*arg));\n-            self.visit(\"fn_input\", extra.as_slice());\n-        }\n-        let extra = vec!(self.c_uint(retval),\n-                      self.c_bool(sig.variadic),\n-                      self.c_tydesc(sig.output));\n-        self.visit(\"fn_output\", extra.as_slice());\n-    }\n-}\n-\n-// Emit a sequence of calls to visit_ty::visit_foo\n-pub fn emit_calls_to_trait_visit_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                t: ty::t,\n-                                                visitor_val: ValueRef,\n-                                                visitor_trait_id: DefId)\n-                                                -> Block<'blk, 'tcx> {\n-    let fcx = bcx.fcx;\n-    let final_bcx = fcx.new_temp_block(\"final\");\n-    let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();\n-    let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n-    let visitor_items = ty::trait_items(bcx.tcx(), visitor_trait_id);\n-    let mut r = Reflector {\n-        visitor_val: visitor_val,\n-        visitor_items: visitor_items.as_slice(),\n-        final_bcx: final_bcx,\n-        tydesc_ty: tydesc_ty,\n-        bcx: bcx\n-    };\n-    r.visit_ty(t);\n-    Br(r.bcx, final_bcx.llbb);\n-    return final_bcx;\n-}\n-\n-pub fn ast_fn_style_constant(fn_style: ast::FnStyle) -> uint {\n-    match fn_style {\n-        ast::UnsafeFn => 1u,\n-        ast::NormalFn => 2u,\n-    }\n-}"}, {"sha": "b84bfe9522446632a61e4a25cde9e3e34e9580e5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3410c52eecf7e10399d105f312203198a597b4ed/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3410c52eecf7e10399d105f312203198a597b4ed/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3410c52eecf7e10399d105f312203198a597b4ed", "patch": "@@ -18,8 +18,7 @@ use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n-use middle::lang_items::{FnOnceTraitLangItem, OpaqueStructLangItem};\n-use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n+use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n use middle::mem_categorization as mc;\n use middle::resolve;\n use middle::resolve_lifetime;\n@@ -4821,33 +4820,6 @@ pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, String> {\n     })\n }\n \n-pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, String> {\n-    tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n-        tcx.intrinsic_defs.borrow().find_copy(&opaque_lang_item)\n-            .expect(\"Failed to resolve Opaque\")\n-    })\n-}\n-\n-pub fn visitor_object_ty(tcx: &ctxt,\n-                         ptr_region: ty::Region,\n-                         trait_region: ty::Region)\n-                         -> Result<(Rc<TraitRef>, t), String>\n-{\n-    let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n-        Ok(id) => id,\n-        Err(s) => { return Err(s); }\n-    };\n-    let substs = Substs::empty();\n-    let trait_ref = Rc::new(TraitRef { def_id: trait_lang_item, substs: substs });\n-    Ok((trait_ref.clone(),\n-        mk_rptr(tcx, ptr_region,\n-                mt {mutbl: ast::MutMutable,\n-                    ty: mk_trait(tcx,\n-                                 trait_ref.def_id,\n-                                 trait_ref.substs.clone(),\n-                                 ty::region_existential_bound(trait_region))})))\n-}\n-\n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),"}]}