{"sha": "889d8dcaa7546acf5b2f406b338caa708a8d93f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4OWQ4ZGNhYTc1NDZhY2Y1YjJmNDA2YjMzOGNhYTcwOGE4ZDkzZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-29T12:50:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-29T12:50:06Z"}, "message": "Auto merge of #51134 - RalfJung:from_raw_parts, r=SimonSapin\n\nextend from_raw_parts docs for slices and strs to mention alignment requirement\n\nThe documentation for `str::from_raw_parts_mut` seems to not be visible because that method is private, bit I figured it could still be fixed. I also removed the reference to the no-longer-existing `str::from_raw_parts` while I was at it.\n\nAlternatively, should I remove `str::from_raw_parts_mut` completely? it is only used in `str::split_at_mut`, where it might as well be inlined.", "tree": {"sha": "e6814ac3d79e0a5eb38f326117597e95ff5156d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6814ac3d79e0a5eb38f326117597e95ff5156d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/889d8dcaa7546acf5b2f406b338caa708a8d93f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/889d8dcaa7546acf5b2f406b338caa708a8d93f8", "html_url": "https://github.com/rust-lang/rust/commit/889d8dcaa7546acf5b2f406b338caa708a8d93f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/889d8dcaa7546acf5b2f406b338caa708a8d93f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61f35e507a56dcdce88bfce99bb2d1eeacb0e9d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/61f35e507a56dcdce88bfce99bb2d1eeacb0e9d1", "html_url": "https://github.com/rust-lang/rust/commit/61f35e507a56dcdce88bfce99bb2d1eeacb0e9d1"}, {"sha": "b30aaf244e73f638007220445be53180c8f2db87", "url": "https://api.github.com/repos/rust-lang/rust/commits/b30aaf244e73f638007220445be53180c8f2db87", "html_url": "https://github.com/rust-lang/rust/commit/b30aaf244e73f638007220445be53180c8f2db87"}], "stats": {"total": 49, "additions": 11, "deletions": 38}, "files": [{"sha": "d52cc8cbe3f5b7605dd8bdd0a5a4ddbf9169e0b6", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/889d8dcaa7546acf5b2f406b338caa708a8d93f8/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889d8dcaa7546acf5b2f406b338caa708a8d93f8/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=889d8dcaa7546acf5b2f406b338caa708a8d93f8", "patch": "@@ -3839,10 +3839,9 @@ unsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n /// valid for `len` elements, nor whether the lifetime inferred is a suitable\n /// lifetime for the returned slice.\n ///\n-/// `p` must be non-null, even for zero-length slices, because non-zero bits\n-/// are required to distinguish between a zero-length slice within `Some()`\n-/// from `None`. `p` can be a bogus non-dereferencable pointer, such as `0x1`,\n-/// for zero-length slices, though.\n+/// `p` must be non-null and aligned, even for zero-length slices, as is\n+/// required for all references. However, for zero-length slices, `p` can be\n+/// a bogus non-dereferencable pointer such as [`NonNull::dangling()`].\n ///\n /// # Caveat\n ///\n@@ -3864,6 +3863,8 @@ unsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n ///     let slice = slice::from_raw_parts(ptr, amt);\n /// }\n /// ```\n+///\n+/// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n@@ -3875,7 +3876,7 @@ pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n ///\n /// This function is unsafe for the same reasons as `from_raw_parts`, as well\n /// as not being able to provide a non-aliasing guarantee of the returned\n-/// mutable slice. `p` must be non-null even for zero-length slices as with\n+/// mutable slice. `p` must be non-null and aligned even for zero-length slices as with\n /// `from_raw_parts`.\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "3169893fcde142e59404e0f73e7a890d7d5f3d31", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/889d8dcaa7546acf5b2f406b338caa708a8d93f8/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889d8dcaa7546acf5b2f406b338caa708a8d93f8/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=889d8dcaa7546acf5b2f406b338caa708a8d93f8", "patch": "@@ -376,37 +376,6 @@ pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n     Ok(unsafe { from_utf8_unchecked_mut(v) })\n }\n \n-/// Forms a str from a pointer and a length.\n-///\n-/// The `len` argument is the number of bytes in the string.\n-///\n-/// # Safety\n-///\n-/// This function is unsafe as there is no guarantee that the given pointer is\n-/// valid for `len` bytes, nor whether the lifetime inferred is a suitable\n-/// lifetime for the returned str.\n-///\n-/// The data must be valid UTF-8\n-///\n-/// `p` must be non-null, even for zero-length strs, because non-zero bits\n-/// are required to distinguish between a zero-length str within `Some()`\n-/// from `None`. `p` can be a bogus non-dereferencable pointer, such as `0x1`,\n-/// for zero-length strs, though.\n-///\n-/// # Caveat\n-///\n-/// The lifetime for the returned str is inferred from its usage. To\n-/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n-/// source lifetime is safe in the context, such as by providing a helper\n-/// function taking the lifetime of a host value for the str, or by explicit\n-/// annotation.\n-/// Performs the same functionality as `from_raw_parts`, except that a mutable\n-/// str is returned.\n-///\n-unsafe fn from_raw_parts_mut<'a>(p: *mut u8, len: usize) -> &'a mut str {\n-    from_utf8_unchecked_mut(slice::from_raw_parts_mut(p, len))\n-}\n-\n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n ///\n@@ -2602,8 +2571,11 @@ impl str {\n             let len = self.len();\n             let ptr = self.as_ptr() as *mut u8;\n             unsafe {\n-                (from_raw_parts_mut(ptr, mid),\n-                 from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+                (from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, mid)),\n+                 from_utf8_unchecked_mut(slice::from_raw_parts_mut(\n+                    ptr.offset(mid as isize),\n+                    len - mid\n+                 )))\n             }\n         } else {\n             slice_error_fail(self, 0, mid)"}]}