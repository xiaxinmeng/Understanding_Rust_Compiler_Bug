{"sha": "5e52010304e885f8991e73223c22051503fa1d13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNTIwMTAzMDRlODg1Zjg5OTFlNzMyMjNjMjIwNTE1MDNmYTFkMTM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-09T16:18:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-09T16:18:16Z"}, "message": "Rollup merge of #58660 - RalfJung:maybe-uninit, r=Centril\n\nMaybeUninit: add read_initialized, add examples\n\nThis adds a new `read_initialized` method, similar to suggestions by @Amanieu and @shepmaster. I also added examples to this and other methods.", "tree": {"sha": "a13a6b3a5c5605cb8f5bf1eb22a1c60397e959d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a13a6b3a5c5605cb8f5bf1eb22a1c60397e959d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e52010304e885f8991e73223c22051503fa1d13", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcg+dICRBK7hj4Ov3rIwAAdHIIAGwDJ8svUeOtzuxCXHr4x3bs\nDm1LmWY0QlrfZlXAVzrHFAnxZGRxdPF1OHK7/wSP7oTbRUkjtUy7uHpfkE2x88WU\njEZtWJCoFF5XnlvrhCATrOov3Xvv0T02KBzVRnDMDIePzUKe27EChTCt1W10Y0ba\nUDFz46ktNGpBqt9Vhykk8XDPczzbSazg5LyoU+DMTMT2yicvDrPO9kGrPgnBNtnZ\n2Ikq2oDkX38TBnCR20kqd4mjAy8jpd08G5Nt5o4Cf0LGMFfOBB5SNHeS7A32rd11\nwww92ZZx68p3cKeQ5Xe0P28FwuQ3sNyb9dLk7yYfRFbu4eVjXUIuGKDVrLjSFcU=\n=03N7\n-----END PGP SIGNATURE-----\n", "payload": "tree a13a6b3a5c5605cb8f5bf1eb22a1c60397e959d5\nparent 63716226621e7b74d1021469436affbde14cb866\nparent cefe9b09c120cfd8684fc2310ed2b295aafca01c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1552148296 +0100\ncommitter GitHub <noreply@github.com> 1552148296 +0100\n\nRollup merge of #58660 - RalfJung:maybe-uninit, r=Centril\n\nMaybeUninit: add read_initialized, add examples\n\nThis adds a new `read_initialized` method, similar to suggestions by @Amanieu and @shepmaster. I also added examples to this and other methods.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e52010304e885f8991e73223c22051503fa1d13", "html_url": "https://github.com/rust-lang/rust/commit/5e52010304e885f8991e73223c22051503fa1d13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e52010304e885f8991e73223c22051503fa1d13/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63716226621e7b74d1021469436affbde14cb866", "url": "https://api.github.com/repos/rust-lang/rust/commits/63716226621e7b74d1021469436affbde14cb866", "html_url": "https://github.com/rust-lang/rust/commit/63716226621e7b74d1021469436affbde14cb866"}, {"sha": "cefe9b09c120cfd8684fc2310ed2b295aafca01c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefe9b09c120cfd8684fc2310ed2b295aafca01c", "html_url": "https://github.com/rust-lang/rust/commit/cefe9b09c120cfd8684fc2310ed2b295aafca01c"}], "stats": {"total": 259, "additions": 229, "deletions": 30}, "files": [{"sha": "edeb65afd67b2d89e336cbcbedae2a6ef3a8f9bf", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e52010304e885f8991e73223c22051503fa1d13/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52010304e885f8991e73223c22051503fa1d13/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=5e52010304e885f8991e73223c22051503fa1d13", "patch": "@@ -15,6 +15,7 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter, num: &T,\n         // FIXME(#53491): Technically, this is calling `get_mut` on an uninitialized\n         // `MaybeUninit` (here and elsewhere in this file).  Revisit this once\n         // we decided whether that is valid or not.\n+        // Using `freeze` is *not enough*; `flt2dec::Part` is an enum!\n         let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n                                                     *num, sign, precision,\n                                                     false, buf.get_mut(), parts.get_mut());\n@@ -33,6 +34,7 @@ fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter, num: &T,\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n         let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n                                                  sign, precision, false, buf.get_mut(),\n                                                  parts.get_mut());\n@@ -71,6 +73,7 @@ fn float_to_exponential_common_exact<T>(fmt: &mut Formatter, num: &T,\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n                                                   *num, sign, precision,\n                                                   upper, buf.get_mut(), parts.get_mut());\n@@ -90,6 +93,7 @@ fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter,\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n         let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        // FIXME(#53491)\n         let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n                                                      *num, sign, (0, 0), upper,\n                                                      buf.get_mut(), parts.get_mut());"}, {"sha": "90e84d0b28c3b0bea5c8d0a0c3d315f74ab73148", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 224, "deletions": 29, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/5e52010304e885f8991e73223c22051503fa1d13/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52010304e885f8991e73223c22051503fa1d13/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=5e52010304e885f8991e73223c22051503fa1d13", "patch": "@@ -1043,7 +1043,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     }\n }\n \n-/// A newtype to construct uninitialized instances of `T`.\n+/// A wrapper to construct uninitialized instances of `T`.\n ///\n /// The compiler, in general, assumes that variables are properly initialized\n /// at their respective type. For example, a variable of reference type must\n@@ -1057,41 +1057,51 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n-/// // equivalent code with `MaybeUninit`\n+/// // The equivalent code with `MaybeUninit<&i32>`:\n /// let x: &i32 = unsafe { MaybeUninit::zeroed().into_initialized() }; // undefined behavior!\n /// ```\n ///\n /// This is exploited by the compiler for various optimizations, such as eliding\n /// run-time checks and optimizing `enum` layout.\n ///\n-/// Not initializing memory at all (instead of zero-initializing it) causes the same\n-/// issue: after all, the initial value of the variable might just happen to be\n-/// one that violates the invariant. Moreover, uninitialized memory is special\n-/// in that the compiler knows that it does not have a fixed value. This makes\n-/// it undefined behavior to have uninitialized data in a variable even if that\n-/// variable has otherwise no restrictions about which values are valid:\n+/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n+/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n+///\n+/// ```rust,no_run\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<bool>`:\n+/// let b: bool = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// ```\n+///\n+/// Moreover, uninitialized memory is special in that the compiler knows that\n+/// it does not have a fixed value. This makes it undefined behavior to have\n+/// uninitialized data in a variable even if that variable has an integer type,\n+/// which otherwise can hold any bit pattern:\n ///\n /// ```rust,no_run\n /// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // equivalent code with `MaybeUninit`\n+/// // The equivalent code with `MaybeUninit<i32>`:\n /// let x: i32 = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n /// ```\n /// (Notice that the rules around uninitialized integers are not finalized yet, but\n /// until they are, it is advisable to avoid them.)\n ///\n-/// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n-/// it is a signal to the compiler indicating that the data here might *not*\n+/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n+/// It is a signal to the compiler indicating that the data here might *not*\n /// be initialized:\n ///\n /// ```rust\n /// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n /// // Create an explicitly uninitialized reference. The compiler knows that data inside\n-/// // a `MaybeUninit` may be invalid, and hence this is not UB:\n+/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninitialized();\n /// // Set it to a valid value.\n /// x.set(&0);\n@@ -1100,45 +1110,84 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// let x = unsafe { x.into_initialized() };\n /// ```\n ///\n-/// The compiler then knows to not optimize this code.\n+/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n // FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n+#[derive(Copy)]\n+// NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n }\n \n+#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+impl<T: Copy> Clone for MaybeUninit<T> {\n+    #[inline(always)]\n+    fn clone(&self) -> Self {\n+        // Not calling T::clone(), we cannot know if we are initialized enough for that.\n+        *self\n+    }\n+}\n+\n impl<T> MaybeUninit<T> {\n-    /// Create a new `MaybeUninit` initialized with the given value.\n+    /// Create a new `MaybeUninit<T>` initialized with the given value.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub const fn new(val: T) -> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n     }\n \n-    /// Creates a new `MaybeUninit` in an uninitialized state.\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub const fn uninitialized() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n-    /// Creates a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n     /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n     /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n     /// be null.\n     ///\n-    /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// # Example\n+    ///\n+    /// Correct usage of this function: initializing a struct with zero, where all\n+    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n+    /// let x = unsafe { x.into_initialized() };\n+    /// assert_eq!(x, (0, false));\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n+    /// cannot hold 0 as a valid value.\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// enum NotZero { One = 1, Two = 2 };\n+    ///\n+    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n+    /// let x = unsafe { x.into_initialized() };\n+    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n+    /// // This is undefined behavior.\n+    /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline]\n     pub fn zeroed() -> MaybeUninit<T> {\n@@ -1149,9 +1198,10 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Sets the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n-    /// For your convenience, this also returns a mutable reference to the (now safely initialized)\n-    /// contents of `self`.\n+    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n+    /// without dropping it, so be careful not to use this twice unless you want to\n+    /// skip running the destructor. For your convenience, this also returns a mutable\n+    /// reference to the (now safely initialized) contents of `self`.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn set(&mut self, val: T) -> &mut T {\n@@ -1162,42 +1212,187 @@ impl<T> MaybeUninit<T> {\n     }\n \n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// assert_eq!(x_vec.len(), 3);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n     }\n \n     /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n+    /// // This is okay because we initialized it.\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// x_vec.push(3);\n+    /// assert_eq!(x_vec.len(), 4);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n     }\n \n-    /// Extracts the value from the `MaybeUninit` container. This is a great way\n+    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<bool>::uninitialized();\n+    /// unsafe { x.as_mut_ptr().write(true); }\n+    /// let x_init = unsafe { x.into_initialized() };\n+    /// assert_eq!(x_init, true);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x_init = unsafe { x.into_initialized() };\n+    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n+    /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn into_initialized(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n     }\n \n+    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n+    /// to the usual drop handling.\n+    ///\n+    /// Whenever possible, it is preferrable to use [`into_initialized`] instead, which\n+    /// prevents duplicating the content of the `MaybeUninit<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    ///\n+    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n+    /// multiple copies of the data (by calling `read_initialized` multiple times, or first\n+    /// calling `read_initialized` and then [`into_initialized`]), it is your responsibility\n+    /// to ensure that that data may indeed be duplicated.\n+    ///\n+    /// [`into_initialized`]: #method.into_initialized\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<u32>::uninitialized();\n+    /// x.set(13);\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// // `u32` is `Copy`, so we may read multiple times.\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// assert_eq!(x1, x2);\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninitialized();\n+    /// x.set(None);\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// // Duplicating a `None` value is okay, so we may read multiple times.\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// assert_eq!(x1, x2);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninitialized();\n+    /// x.set(Some(vec![0,1,2]));\n+    /// let x1 = unsafe { x.read_initialized() };\n+    /// let x2 = unsafe { x.read_initialized() };\n+    /// // We now created two copies of the same vector, leading to a double-free when\n+    /// // they both get dropped!\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn read_initialized(&self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        self.as_ptr().read()\n+    }\n+\n     /// Gets a reference to the contained value.\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n@@ -1210,7 +1405,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references"}, {"sha": "a2599ae834c69fc0bec39951adeebab59ab73c70", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e52010304e885f8991e73223c22051503fa1d13/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e52010304e885f8991e73223c22051503fa1d13/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5e52010304e885f8991e73223c22051503fa1d13", "patch": "@@ -301,7 +301,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Perform the swap\n     copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n     copy(y, x, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(tmp.get_ref(), y, 1);\n+    copy_nonoverlapping(tmp.as_ptr(), y, 1);\n }\n \n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory"}]}