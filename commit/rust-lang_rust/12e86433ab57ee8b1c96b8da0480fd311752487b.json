{"sha": "12e86433ab57ee8b1c96b8da0480fd311752487b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZTg2NDMzYWI1N2VlOGIxYzk2YjhkYTA0ODBmZDMxMTc1MjQ4N2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-06T13:32:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-06T13:32:15Z"}, "message": "Merge #8368\n\n8368: Move Ty accessors to TyExt r=flodiebold a=Veykril\n\nCC #8313\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "7f4d2f298c242cc64432cf5c015f77c29f7e5a25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f4d2f298c242cc64432cf5c015f77c29f7e5a25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12e86433ab57ee8b1c96b8da0480fd311752487b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgbGLfCRBK7hj4Ov3rIwAAdHIIAHl1yWk2shtQK3GArZSFp+iO\n724MoNEuvzZrCYdtv1O9lp9DexIoO1YfsaAl5fDSYm81tiXgUaVZmjypVPjAhDzX\nSUOHSAEpefqmzVmS59cALLO3mgFzCxlaaS2rNFNwmyxkmgY76ZnHzkiAJK5IfA00\nen+SEGHqY7nJI2k/cDdUp5fSojWTwI/gpBSOTJH9zqWBJdP2wP0uvyaLyml6b5X7\nwct7gQ4ooaAsKka3OZAZ59PGXXAoYNk6yctDqUSYssRmjTp52sNrt1G0HsjauG/k\nsS++JmboI1PhlLMPxt/v2+VV1xocA0PtzuVqpAp0yr5IRcuctlSAv90IcAKO1VE=\n=omRL\n-----END PGP SIGNATURE-----\n", "payload": "tree 7f4d2f298c242cc64432cf5c015f77c29f7e5a25\nparent 4414071074759dee637e0ce968805de63e60da7b\nparent bc993bbe85a231a7aa0414c6bea65d31d7375277\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617715935 +0000\ncommitter GitHub <noreply@github.com> 1617715935 +0000\n\nMerge #8368\n\n8368: Move Ty accessors to TyExt r=flodiebold a=Veykril\n\nCC #8313\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12e86433ab57ee8b1c96b8da0480fd311752487b", "html_url": "https://github.com/rust-lang/rust/commit/12e86433ab57ee8b1c96b8da0480fd311752487b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12e86433ab57ee8b1c96b8da0480fd311752487b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4414071074759dee637e0ce968805de63e60da7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4414071074759dee637e0ce968805de63e60da7b", "html_url": "https://github.com/rust-lang/rust/commit/4414071074759dee637e0ce968805de63e60da7b"}, {"sha": "bc993bbe85a231a7aa0414c6bea65d31d7375277", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc993bbe85a231a7aa0414c6bea65d31d7375277", "html_url": "https://github.com/rust-lang/rust/commit/bc993bbe85a231a7aa0414c6bea65d31d7375277"}], "stats": {"total": 472, "additions": 246, "deletions": 226}, "files": [{"sha": "8d00f7401b6ee9359fb9abca710b51cce24ad5a5", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -59,7 +59,7 @@ use hir_ty::{\n     traits::FnTrait,\n     AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast,\n     DebruijnIndex, InEnvironment, Interner, QuantifiedWhereClause, Scalar, Solution,\n-    SolutionVariables, Substitution, TraitEnvironment, Ty, TyBuilder, TyDefId, TyKind,\n+    SolutionVariables, Substitution, TraitEnvironment, Ty, TyBuilder, TyDefId, TyExt, TyKind,\n     TyVariableKind, WhereClause,\n };\n use itertools::Itertools;"}, {"sha": "09512d1ce4d18f4efe0f21f72326cb554ebd889f", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -13,7 +13,7 @@ use smallvec::SmallVec;\n use crate::{\n     db::HirDatabase, primitive, to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders,\n     CallableSig, FnPointer, FnSig, FnSubst, GenericArg, Interner, ProjectionTy, Substitution,\n-    TraitRef, Ty, TyDefId, TyKind, TypeWalk, ValueTyDefId,\n+    TraitRef, Ty, TyDefId, TyExt, TyKind, TypeWalk, ValueTyDefId,\n };\n \n /// This is a builder for `Ty` or anything that needs a `Substitution`."}, {"sha": "8e8a1aa481655c6f0491531b72bbcb643f6178c8", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 226, "deletions": 3, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -1,20 +1,243 @@\n //! Various extensions traits for Chalk types.\n \n-use hir_def::{AssocContainerId, Lookup, TraitId};\n+use chalk_ir::Mutability;\n+use hir_def::{\n+    type_ref::Rawness, AssocContainerId, FunctionId, GenericDefId, HasModule, Lookup, TraitId,\n+};\n \n use crate::{\n-    db::HirDatabase, from_assoc_type_id, to_chalk_trait_id, Interner, ProjectionTy, TraitRef, Ty,\n-    TyKind,\n+    db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n+    from_placeholder_idx, to_chalk_trait_id, AdtId, AliasEq, AliasTy, Binders, CallableDefId,\n+    CallableSig, ImplTraitId, Interner, Lifetime, ProjectionTy, QuantifiedWhereClause,\n+    Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n pub trait TyExt {\n     fn is_unit(&self) -> bool;\n+    fn is_never(&self) -> bool;\n+    fn is_unknown(&self) -> bool;\n+\n+    fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n+    fn as_tuple(&self) -> Option<&Substitution>;\n+    fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId>;\n+    fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)>;\n+    fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)>;\n+    fn as_generic_def(&self, db: &dyn HirDatabase) -> Option<GenericDefId>;\n+\n+    fn callable_def(&self, db: &dyn HirDatabase) -> Option<CallableDefId>;\n+    fn callable_sig(&self, db: &dyn HirDatabase) -> Option<CallableSig>;\n+\n+    fn strip_references(&self) -> &Ty;\n+\n+    /// If this is a `dyn Trait`, returns that trait.\n+    fn dyn_trait(&self) -> Option<TraitId>;\n+\n+    fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>>;\n+    fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId>;\n }\n \n impl TyExt for Ty {\n     fn is_unit(&self) -> bool {\n         matches!(self.kind(&Interner), TyKind::Tuple(0, _))\n     }\n+\n+    fn is_never(&self) -> bool {\n+        matches!(self.kind(&Interner), TyKind::Never)\n+    }\n+\n+    fn is_unknown(&self) -> bool {\n+        matches!(self.kind(&Interner), TyKind::Error)\n+    }\n+\n+    fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)> {\n+        match self.kind(&Interner) {\n+            TyKind::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),\n+            _ => None,\n+        }\n+    }\n+\n+    fn as_tuple(&self) -> Option<&Substitution> {\n+        match self.kind(&Interner) {\n+            TyKind::Tuple(_, substs) => Some(substs),\n+            _ => None,\n+        }\n+    }\n+\n+    fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId> {\n+        if let Some(CallableDefId::FunctionId(func)) = self.callable_def(db) {\n+            Some(func)\n+        } else {\n+            None\n+        }\n+    }\n+    fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)> {\n+        match self.kind(&Interner) {\n+            TyKind::Ref(mutability, lifetime, ty) => Some((ty, *lifetime, *mutability)),\n+            _ => None,\n+        }\n+    }\n+\n+    fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n+        match self.kind(&Interner) {\n+            TyKind::Ref(mutability, _, ty) => Some((ty, Rawness::Ref, *mutability)),\n+            TyKind::Raw(mutability, ty) => Some((ty, Rawness::RawPtr, *mutability)),\n+            _ => None,\n+        }\n+    }\n+\n+    fn as_generic_def(&self, db: &dyn HirDatabase) -> Option<GenericDefId> {\n+        match *self.kind(&Interner) {\n+            TyKind::Adt(AdtId(adt), ..) => Some(adt.into()),\n+            TyKind::FnDef(callable, ..) => {\n+                Some(db.lookup_intern_callable_def(callable.into()).into())\n+            }\n+            TyKind::AssociatedType(type_alias, ..) => Some(from_assoc_type_id(type_alias).into()),\n+            TyKind::Foreign(type_alias, ..) => Some(from_foreign_def_id(type_alias).into()),\n+            _ => None,\n+        }\n+    }\n+\n+    fn callable_def(&self, db: &dyn HirDatabase) -> Option<CallableDefId> {\n+        match self.kind(&Interner) {\n+            &TyKind::FnDef(def, ..) => Some(db.lookup_intern_callable_def(def.into())),\n+            _ => None,\n+        }\n+    }\n+\n+    fn callable_sig(&self, db: &dyn HirDatabase) -> Option<CallableSig> {\n+        match self.kind(&Interner) {\n+            TyKind::Function(fn_ptr) => Some(CallableSig::from_fn_ptr(fn_ptr)),\n+            TyKind::FnDef(def, parameters) => {\n+                let callable_def = db.lookup_intern_callable_def((*def).into());\n+                let sig = db.callable_item_signature(callable_def);\n+                Some(sig.substitute(&Interner, &parameters))\n+            }\n+            TyKind::Closure(.., substs) => {\n+                let sig_param = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n+                sig_param.callable_sig(db)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn dyn_trait(&self) -> Option<TraitId> {\n+        let trait_ref = match self.kind(&Interner) {\n+            TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n+                match b.skip_binders() {\n+                    WhereClause::Implemented(trait_ref) => Some(trait_ref),\n+                    _ => None,\n+                }\n+            }),\n+            _ => None,\n+        }?;\n+        Some(from_chalk_trait_id(trait_ref.trait_id))\n+    }\n+\n+    fn strip_references(&self) -> &Ty {\n+        let mut t: &Ty = self;\n+        while let TyKind::Ref(_mutability, _lifetime, ty) = t.kind(&Interner) {\n+            t = ty;\n+        }\n+        t\n+    }\n+\n+    fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>> {\n+        match self.kind(&Interner) {\n+            TyKind::OpaqueType(opaque_ty_id, ..) => {\n+                match db.lookup_intern_impl_trait_id((*opaque_ty_id).into()) {\n+                    ImplTraitId::AsyncBlockTypeImplTrait(def, _expr) => {\n+                        let krate = def.module(db.upcast()).krate();\n+                        if let Some(future_trait) = db\n+                            .lang_item(krate, \"future_trait\".into())\n+                            .and_then(|item| item.as_trait())\n+                        {\n+                            // This is only used by type walking.\n+                            // Parameters will be walked outside, and projection predicate is not used.\n+                            // So just provide the Future trait.\n+                            let impl_bound = Binders::empty(\n+                                &Interner,\n+                                WhereClause::Implemented(TraitRef {\n+                                    trait_id: to_chalk_trait_id(future_trait),\n+                                    substitution: Substitution::empty(&Interner),\n+                                }),\n+                            );\n+                            Some(vec![impl_bound])\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    ImplTraitId::ReturnTypeImplTrait(..) => None,\n+                }\n+            }\n+            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n+                let predicates = match db.lookup_intern_impl_trait_id(opaque_ty.opaque_ty_id.into())\n+                {\n+                    ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n+                        db.return_type_impl_traits(func).map(|it| {\n+                            let data = (*it)\n+                                .as_ref()\n+                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            data.substitute(&Interner, &opaque_ty.substitution)\n+                        })\n+                    }\n+                    // It always has an parameter for Future::Output type.\n+                    ImplTraitId::AsyncBlockTypeImplTrait(..) => unreachable!(),\n+                };\n+\n+                predicates.map(|it| it.into_value_and_skipped_binders().0)\n+            }\n+            TyKind::Placeholder(idx) => {\n+                let id = from_placeholder_idx(db, *idx);\n+                let generic_params = db.generic_params(id.parent);\n+                let param_data = &generic_params.types[id.local_id];\n+                match param_data.provenance {\n+                    hir_def::generics::TypeParamProvenance::ArgumentImplTrait => {\n+                        let substs = TyBuilder::type_params_subst(db, id.parent);\n+                        let predicates = db\n+                            .generic_predicates(id.parent)\n+                            .into_iter()\n+                            .map(|pred| pred.clone().substitute(&Interner, &substs))\n+                            .filter(|wc| match &wc.skip_binders() {\n+                                WhereClause::Implemented(tr) => {\n+                                    tr.self_type_parameter(&Interner) == self\n+                                }\n+                                WhereClause::AliasEq(AliasEq {\n+                                    alias: AliasTy::Projection(proj),\n+                                    ty: _,\n+                                }) => proj.self_type_parameter(&Interner) == self,\n+                                _ => false,\n+                            })\n+                            .collect::<Vec<_>>();\n+\n+                        Some(predicates)\n+                    }\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId> {\n+        match self.kind(&Interner) {\n+            TyKind::AssociatedType(id, ..) => {\n+                match from_assoc_type_id(*id).lookup(db.upcast()).container {\n+                    AssocContainerId::TraitId(trait_id) => Some(trait_id),\n+                    _ => None,\n+                }\n+            }\n+            TyKind::Alias(AliasTy::Projection(projection_ty)) => {\n+                match from_assoc_type_id(projection_ty.associated_ty_id)\n+                    .lookup(db.upcast())\n+                    .container\n+                {\n+                    AssocContainerId::TraitId(trait_id) => Some(trait_id),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n pub trait ProjectionTyExt {"}, {"sha": "e9762622f3174488c90bd0c011e4d6d1ed97e721", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -227,7 +227,7 @@ use hir_def::{\n use la_arena::Idx;\n use smallvec::{smallvec, SmallVec};\n \n-use crate::{db::HirDatabase, AdtId, InferenceResult, Interner, TyKind};\n+use crate::{db::HirDatabase, AdtId, InferenceResult, Interner, TyExt, TyKind};\n \n #[derive(Debug, Clone, Copy)]\n /// Either a pattern from the source code being analyzed, represented as"}, {"sha": "ed97dc0e3f37de367b00a3087cc5663f05625682", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -11,7 +11,9 @@ use hir_def::{\n };\n use hir_expand::diagnostics::DiagnosticSink;\n \n-use crate::{db::HirDatabase, diagnostics::MissingUnsafe, InferenceResult, Interner, TyKind};\n+use crate::{\n+    db::HirDatabase, diagnostics::MissingUnsafe, InferenceResult, Interner, TyExt, TyKind,\n+};\n \n pub(super) struct UnsafeValidator<'a, 'b: 'a> {\n     owner: DefWithBodyId,"}, {"sha": "5146d873bb8abd8581948ab1fb9329ba533d7026", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -42,7 +42,7 @@ use super::{\n };\n use crate::{\n     db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n-    to_assoc_type_id, AliasEq, AliasTy, Interner, TyBuilder, TyKind,\n+    to_assoc_type_id, AliasEq, AliasTy, Interner, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details."}, {"sha": "159a53a63182b842db2fae9e2b1ea07487f1a5f0", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -7,7 +7,7 @@\n use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n use hir_def::lang_item::LangItemTarget;\n \n-use crate::{autoderef, Interner, Solution, Ty, TyBuilder, TyKind};\n+use crate::{autoderef, Interner, Solution, Ty, TyBuilder, TyExt, TyKind};\n \n use super::{InEnvironment, InferenceContext};\n "}, {"sha": "dab137ae1544e343c3b599a8eb84312e5305d677", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -23,7 +23,8 @@ use crate::{\n     traits::{chalk::from_chalk, FnTrait},\n     utils::{generics, variant_data, Generics},\n     AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, InEnvironment, Interner,\n-    ProjectionTyExt, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeWalk,\n+    ProjectionTyExt, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    TypeWalk,\n };\n \n use super::{"}, {"sha": "fc2bc3ef86c0182d9588a876921dfdd9392c6a13", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -14,7 +14,7 @@ use hir_expand::name::Name;\n use super::{BindingMode, Expectation, InferenceContext};\n use crate::{\n     lower::lower_to_chalk_mutability, static_lifetime, utils::variant_data, Interner, Substitution,\n-    Ty, TyBuilder, TyKind,\n+    Ty, TyBuilder, TyExt, TyKind,\n };\n \n impl<'a> InferenceContext<'a> {"}, {"sha": "b19d67bb1f31c95b32ab30173ffb9eba742f1b51", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -10,7 +10,9 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n \n-use crate::{method_resolution, Interner, Substitution, Ty, TyBuilder, TyKind, ValueTyDefId};\n+use crate::{\n+    method_resolution, Interner, Substitution, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n+};\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n "}, {"sha": "f5b658cbaea3bad7e2bc485de357416f2f4f6556", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 3, "deletions": 211, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -30,13 +30,11 @@ mod test_db;\n \n use std::sync::Arc;\n \n-use chalk_ir::UintTy;\n-use itertools::Itertools;\n-\n use base_db::salsa;\n+use chalk_ir::UintTy;\n use hir_def::{\n-    expr::ExprId, type_ref::Rawness, AssocContainerId, ConstParamId, FunctionId, GenericDefId,\n-    HasModule, LifetimeParamId, Lookup, TraitId, TypeAliasId, TypeParamId,\n+    expr::ExprId, type_ref::Rawness, ConstParamId, LifetimeParamId, TraitId, TypeAliasId,\n+    TypeParamId,\n };\n \n use crate::{db::HirDatabase, display::HirDisplay, utils::generics};\n@@ -171,65 +169,6 @@ impl CallableSig {\n }\n \n impl Ty {\n-    pub fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)> {\n-        match self.kind(&Interner) {\n-            TyKind::Ref(mutability, lifetime, ty) => Some((ty, *lifetime, *mutability)),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n-        match self.kind(&Interner) {\n-            TyKind::Ref(mutability, _, ty) => Some((ty, Rawness::Ref, *mutability)),\n-            TyKind::Raw(mutability, ty) => Some((ty, Rawness::RawPtr, *mutability)),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn strip_references(&self) -> &Ty {\n-        let mut t: &Ty = self;\n-\n-        while let TyKind::Ref(_mutability, _lifetime, ty) = t.kind(&Interner) {\n-            t = ty;\n-        }\n-\n-        t\n-    }\n-\n-    pub fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)> {\n-        match self.kind(&Interner) {\n-            TyKind::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_tuple(&self) -> Option<&Substitution> {\n-        match self.kind(&Interner) {\n-            TyKind::Tuple(_, substs) => Some(substs),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_generic_def(&self, db: &dyn HirDatabase) -> Option<GenericDefId> {\n-        match *self.kind(&Interner) {\n-            TyKind::Adt(AdtId(adt), ..) => Some(adt.into()),\n-            TyKind::FnDef(callable, ..) => {\n-                Some(db.lookup_intern_callable_def(callable.into()).into())\n-            }\n-            TyKind::AssociatedType(type_alias, ..) => Some(from_assoc_type_id(type_alias).into()),\n-            TyKind::Foreign(type_alias, ..) => Some(from_foreign_def_id(type_alias).into()),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn is_never(&self) -> bool {\n-        matches!(self.kind(&Interner), TyKind::Never)\n-    }\n-\n-    pub fn is_unknown(&self) -> bool {\n-        matches!(self.kind(&Interner), TyKind::Error)\n-    }\n-\n     pub fn equals_ctor(&self, other: &Ty) -> bool {\n         match (self.kind(&Interner), other.kind(&Interner)) {\n             (TyKind::Adt(adt, ..), TyKind::Adt(adt2, ..)) => adt == adt2,\n@@ -260,24 +199,6 @@ impl Ty {\n         }\n     }\n \n-    /// If this is a `dyn Trait` type, this returns the `Trait` part.\n-    fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n-        match self.kind(&Interner) {\n-            TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n-                match b.skip_binders() {\n-                    WhereClause::Implemented(trait_ref) => Some(trait_ref),\n-                    _ => None,\n-                }\n-            }),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If this is a `dyn Trait`, returns that trait.\n-    pub fn dyn_trait(&self) -> Option<TraitId> {\n-        self.dyn_trait_ref().map(|it| it.trait_id).map(from_chalk_trait_id)\n-    }\n-\n     fn builtin_deref(&self) -> Option<Ty> {\n         match self.kind(&Interner) {\n             TyKind::Ref(.., ty) => Some(ty.clone()),\n@@ -286,37 +207,6 @@ impl Ty {\n         }\n     }\n \n-    pub fn callable_def(&self, db: &dyn HirDatabase) -> Option<CallableDefId> {\n-        match self.kind(&Interner) {\n-            &TyKind::FnDef(def, ..) => Some(db.lookup_intern_callable_def(def.into())),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId> {\n-        if let Some(CallableDefId::FunctionId(func)) = self.callable_def(db) {\n-            Some(func)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn callable_sig(&self, db: &dyn HirDatabase) -> Option<CallableSig> {\n-        match self.kind(&Interner) {\n-            TyKind::Function(fn_ptr) => Some(CallableSig::from_fn_ptr(fn_ptr)),\n-            TyKind::FnDef(def, parameters) => {\n-                let callable_def = db.lookup_intern_callable_def((*def).into());\n-                let sig = db.callable_item_signature(callable_def);\n-                Some(sig.substitute(&Interner, &parameters))\n-            }\n-            TyKind::Closure(.., substs) => {\n-                let sig_param = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n-                sig_param.callable_sig(db)\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     /// Returns the type parameters of this type if it has some (i.e. is an ADT\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     pub fn substs(&self) -> Option<&Substitution> {\n@@ -344,104 +234,6 @@ impl Ty {\n             _ => None,\n         }\n     }\n-\n-    pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>> {\n-        match self.kind(&Interner) {\n-            TyKind::OpaqueType(opaque_ty_id, ..) => {\n-                match db.lookup_intern_impl_trait_id((*opaque_ty_id).into()) {\n-                    ImplTraitId::AsyncBlockTypeImplTrait(def, _expr) => {\n-                        let krate = def.module(db.upcast()).krate();\n-                        if let Some(future_trait) = db\n-                            .lang_item(krate, \"future_trait\".into())\n-                            .and_then(|item| item.as_trait())\n-                        {\n-                            // This is only used by type walking.\n-                            // Parameters will be walked outside, and projection predicate is not used.\n-                            // So just provide the Future trait.\n-                            let impl_bound = Binders::empty(\n-                                &Interner,\n-                                WhereClause::Implemented(TraitRef {\n-                                    trait_id: to_chalk_trait_id(future_trait),\n-                                    substitution: Substitution::empty(&Interner),\n-                                }),\n-                            );\n-                            Some(vec![impl_bound])\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    ImplTraitId::ReturnTypeImplTrait(..) => None,\n-                }\n-            }\n-            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n-                let predicates = match db.lookup_intern_impl_trait_id(opaque_ty.opaque_ty_id.into())\n-                {\n-                    ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n-                        db.return_type_impl_traits(func).map(|it| {\n-                            let data = (*it)\n-                                .as_ref()\n-                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            data.substitute(&Interner, &opaque_ty.substitution)\n-                        })\n-                    }\n-                    // It always has an parameter for Future::Output type.\n-                    ImplTraitId::AsyncBlockTypeImplTrait(..) => unreachable!(),\n-                };\n-\n-                predicates.map(|it| it.into_value_and_skipped_binders().0)\n-            }\n-            TyKind::Placeholder(idx) => {\n-                let id = from_placeholder_idx(db, *idx);\n-                let generic_params = db.generic_params(id.parent);\n-                let param_data = &generic_params.types[id.local_id];\n-                match param_data.provenance {\n-                    hir_def::generics::TypeParamProvenance::ArgumentImplTrait => {\n-                        let substs = TyBuilder::type_params_subst(db, id.parent);\n-                        let predicates = db\n-                            .generic_predicates(id.parent)\n-                            .into_iter()\n-                            .map(|pred| pred.clone().substitute(&Interner, &substs))\n-                            .filter(|wc| match &wc.skip_binders() {\n-                                WhereClause::Implemented(tr) => {\n-                                    tr.self_type_parameter(&Interner) == self\n-                                }\n-                                WhereClause::AliasEq(AliasEq {\n-                                    alias: AliasTy::Projection(proj),\n-                                    ty: _,\n-                                }) => proj.self_type_parameter(&Interner) == self,\n-                                _ => false,\n-                            })\n-                            .collect_vec();\n-\n-                        Some(predicates)\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId> {\n-        match self.kind(&Interner) {\n-            TyKind::AssociatedType(id, ..) => {\n-                match from_assoc_type_id(*id).lookup(db.upcast()).container {\n-                    AssocContainerId::TraitId(trait_id) => Some(trait_id),\n-                    _ => None,\n-                }\n-            }\n-            TyKind::Alias(AliasTy::Projection(projection_ty)) => {\n-                match from_assoc_type_id(projection_ty.associated_ty_id)\n-                    .lookup(db.upcast())\n-                    .container\n-                {\n-                    AssocContainerId::TraitId(trait_id) => Some(trait_id),\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "ee725fd468bbb12f4c02169963c6386a68c678b0", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -22,7 +22,7 @@ use crate::{\n     static_lifetime,\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer, FnSig, ForeignDefId,\n-    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, Ty, TyBuilder, TyKind,\n+    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind,\n     TypeWalk,\n };\n "}, {"sha": "f03b92422f9036d0f5377d2489f5e5a389b835f2", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -22,7 +22,7 @@ use crate::{\n     to_assoc_type_id, to_chalk_trait_id,\n     utils::generics,\n     AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId, ProjectionTy, Substitution,\n-    TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n+    TraitRef, Ty, TyBuilder, TyExt, TyKind, WhereClause,\n };\n use mapping::{\n     convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsValue,"}, {"sha": "fe9f273b0aac49d6107a9fb8345b4b9cfac62b8e", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e86433ab57ee8b1c96b8da0480fd311752487b/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=12e86433ab57ee8b1c96b8da0480fd311752487b", "patch": "@@ -12,7 +12,7 @@ use hir::{\n     AssocItem, Crate, Function, HasSource, HirDisplay, ModuleDef,\n };\n use hir_def::FunctionId;\n-use hir_ty::TypeWalk;\n+use hir_ty::{TyExt, TypeWalk};\n use ide::{AnalysisHost, RootDatabase};\n use ide_db::base_db::{\n     salsa::{self, ParallelDatabase},"}]}