{"sha": "f1be8d16c55990fff8c265352328fd90555feabd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYmU4ZDE2YzU1OTkwZmZmOGMyNjUzNTIzMjhmZDkwNTU1ZmVhYmQ=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-04-15T15:08:46Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-04-19T17:13:45Z"}, "message": "Identify missing ambiguous case with best effort suggestion", "tree": {"sha": "99c16d9f73b4cf921c383eb1bc226d906211267b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99c16d9f73b4cf921c383eb1bc226d906211267b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1be8d16c55990fff8c265352328fd90555feabd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1be8d16c55990fff8c265352328fd90555feabd", "html_url": "https://github.com/rust-lang/rust/commit/f1be8d16c55990fff8c265352328fd90555feabd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1be8d16c55990fff8c265352328fd90555feabd/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f36b54f0f33427e926872935c325a660967af6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f36b54f0f33427e926872935c325a660967af6f", "html_url": "https://github.com/rust-lang/rust/commit/2f36b54f0f33427e926872935c325a660967af6f"}], "stats": {"total": 183, "additions": 132, "deletions": 51}, "files": [{"sha": "b7deb546882153890fe6493afe0862e6d0ca2a71", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 81, "deletions": 47, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f1be8d16c55990fff8c265352328fd90555feabd/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1be8d16c55990fff8c265352328fd90555feabd/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=f1be8d16c55990fff8c265352328fd90555feabd", "patch": "@@ -240,6 +240,56 @@ impl<'a> Resolver<'a> {\n         (err, candidates)\n     }\n \n+    fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n+        // HACK(estebank): find a better way to figure out that this was a\n+        // parser issue where a struct literal is being used on an expression\n+        // where a brace being opened means a block is being started. Look\n+        // ahead for the next text to see if `span` is followed by a `{`.\n+        let sm = self.session.source_map();\n+        let mut sp = span;\n+        loop {\n+            sp = sm.next_point(sp);\n+            match sm.span_to_snippet(sp) {\n+                Ok(ref snippet) => {\n+                    if snippet.chars().any(|c| { !c.is_whitespace() }) {\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+        }\n+        let followed_by_brace = match sm.span_to_snippet(sp) {\n+            Ok(ref snippet) if snippet == \"{\" => true,\n+            _ => false,\n+        };\n+        // In case this could be a struct literal that needs to be surrounded\n+        // by parenthesis, find the appropriate span.\n+        let mut i = 0;\n+        let mut closing_brace = None;\n+        loop {\n+            sp = sm.next_point(sp);\n+            match sm.span_to_snippet(sp) {\n+                Ok(ref snippet) => {\n+                    if snippet == \"}\" {\n+                        let sp = span.to(sp);\n+                        if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                            closing_brace = Some((sp, snippet));\n+                        }\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+            i += 1;\n+            // The bigger the span, the more likely we're incorrect --\n+            // bound it to 100 chars long.\n+            if i > 100 {\n+                break;\n+            }\n+        }\n+        return (followed_by_brace, closing_brace)\n+    }\n+\n     /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n     /// function.\n     /// Returns `true` if able to provide context-dependent help.\n@@ -278,6 +328,8 @@ impl<'a> Resolver<'a> {\n             _ => false,\n         };\n \n+        let (followed_by_brace, closing_brace) = self.followed_by_brace(span);\n+\n         match (def, source) {\n             (Def::Macro(..), _) => {\n                 err.span_suggestion(\n@@ -331,52 +383,6 @@ impl<'a> Resolver<'a> {\n                         );\n                     }\n                 } else {\n-                    // HACK(estebank): find a better way to figure out that this was a\n-                    // parser issue where a struct literal is being used on an expression\n-                    // where a brace being opened means a block is being started. Look\n-                    // ahead for the next text to see if `span` is followed by a `{`.\n-                    let sm = self.session.source_map();\n-                    let mut sp = span;\n-                    loop {\n-                        sp = sm.next_point(sp);\n-                        match sm.span_to_snippet(sp) {\n-                            Ok(ref snippet) => {\n-                                if snippet.chars().any(|c| { !c.is_whitespace() }) {\n-                                    break;\n-                                }\n-                            }\n-                            _ => break,\n-                        }\n-                    }\n-                    let followed_by_brace = match sm.span_to_snippet(sp) {\n-                        Ok(ref snippet) if snippet == \"{\" => true,\n-                        _ => false,\n-                    };\n-                    // In case this could be a struct literal that needs to be surrounded\n-                    // by parenthesis, find the appropriate span.\n-                    let mut i = 0;\n-                    let mut closing_brace = None;\n-                    loop {\n-                        sp = sm.next_point(sp);\n-                        match sm.span_to_snippet(sp) {\n-                            Ok(ref snippet) => {\n-                                if snippet == \"}\" {\n-                                    let sp = span.to(sp);\n-                                    if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                                        closing_brace = Some((sp, snippet));\n-                                    }\n-                                    break;\n-                                }\n-                            }\n-                            _ => break,\n-                        }\n-                        i += 1;\n-                        // The bigger the span, the more likely we're incorrect --\n-                        // bound it to 100 chars long.\n-                        if i > 100 {\n-                            break;\n-                        }\n-                    }\n                     match source {\n                         PathSource::Expr(Some(parent)) => if !path_sep(err, &parent) {\n                             err.span_label(\n@@ -411,7 +417,35 @@ impl<'a> Resolver<'a> {\n             (Def::Union(..), _) |\n             (Def::Variant(..), _) |\n             (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n-                err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str));\n+                    match source {\n+                        PathSource::Expr(Some(parent)) => if !path_sep(err, &parent) {\n+                            err.span_label(\n+                                span,\n+                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                            );\n+                        }\n+                        PathSource::Expr(None) if followed_by_brace == true => {\n+                            if let Some((sp, snippet)) = closing_brace {\n+                                err.span_suggestion(\n+                                    sp,\n+                                    \"surround the struct literal with parenthesis\",\n+                                    format!(\"({})\", snippet),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else {\n+                                err.span_label(\n+                                    span,\n+                                    format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n+                                );\n+                            }\n+                        },\n+                        _ => {\n+                            err.span_label(\n+                                span,\n+                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                            );\n+                        },\n+                    }\n             }\n             (Def::SelfTy(..), _) if ns == ValueNS => {\n                 err.span_label(span, fallback_label);"}, {"sha": "a82b1e11a52279f281cc16f494a1f277d893d306", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1be8d16c55990fff8c265352328fd90555feabd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1be8d16c55990fff8c265352328fd90555feabd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f1be8d16c55990fff8c265352328fd90555feabd", "patch": "@@ -2856,7 +2856,7 @@ impl<'a> Parser<'a> {\n                         hi = self.prev_span;\n                         ex = ExprKind::Mac(respan(lo.to(hi), Mac_ { path, tts, delim }));\n                     } else if self.check(&token::OpenDelim(token::Brace)) {\n-                        if let Some(expr) = self.should_parse_struct_expr(lo, path.clone(), attrs.clone()) {\n+                        if let Some(expr) = self.should_parse_struct_expr(lo, &path, &attrs) {\n                             return expr;\n                         } else {\n                             hi = path.span;\n@@ -2907,8 +2907,8 @@ impl<'a> Parser<'a> {\n     fn should_parse_struct_expr(\n         &mut self,\n         lo: Span,\n-        path: ast::Path,\n-        attrs: ThinVec<Attribute>,\n+        path: &ast::Path,\n+        attrs: &ThinVec<Attribute>,\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let could_be_struct = self.look_ahead(1, |t| t.is_ident()) && (\n             self.look_ahead(2, |t| *t == token::Colon)\n@@ -2924,7 +2924,7 @@ impl<'a> Parser<'a> {\n             parse_struct = true;\n         }\n         if parse_struct {\n-            match self.parse_struct_expr(lo, path, attrs) {\n+            match self.parse_struct_expr(lo, path.clone(), attrs.clone()) {\n                 Err(err) => return Some(Err(err)),\n                 Ok(expr) => {\n                     if bad_struct {"}, {"sha": "2d87c4ca73d01c8d7ec484e5f7d90ba4fa18a504", "filename": "src/test/ui/struct-literal-variant-in-if.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1be8d16c55990fff8c265352328fd90555feabd/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1be8d16c55990fff8c265352328fd90555feabd/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs?ref=f1be8d16c55990fff8c265352328fd90555feabd", "patch": "@@ -0,0 +1,14 @@\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+enum E {\n+    V { field: bool }\n+}\n+fn test_E(x: E) {\n+    let field = true;\n+    if x == E::V { field } {}\n+    //~^ ERROR expected value, found struct variant `E::V`\n+    //~| ERROR mismatched types\n+    let y: usize = ();\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "e38eb0d61e060faa7fe5ade143e458ebdcf7d012", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f1be8d16c55990fff8c265352328fd90555feabd/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1be8d16c55990fff8c265352328fd90555feabd/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=f1be8d16c55990fff8c265352328fd90555feabd", "patch": "@@ -0,0 +1,33 @@\n+error[E0423]: expected value, found struct variant `E::V`\n+  --> $DIR/struct-literal-variant-in-if.rs:7:13\n+   |\n+LL |     if x == E::V { field } {}\n+   |             ^^^^----------\n+   |             |\n+   |             help: surround the struct literal with parenthesis: `(E::V { field })`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/struct-literal-variant-in-if.rs:7:20\n+   |\n+LL | fn test_E(x: E) {\n+   |                 - help: try adding a return type: `-> bool`\n+LL |     let field = true;\n+LL |     if x == E::V { field } {}\n+   |                    ^^^^^ expected (), found bool\n+   |\n+   = note: expected type `()`\n+              found type `bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/struct-literal-variant-in-if.rs:10:20\n+   |\n+LL |     let y: usize = ();\n+   |                    ^^ expected usize, found ()\n+   |\n+   = note: expected type `usize`\n+              found type `()`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0308, E0423.\n+For more information about an error, try `rustc --explain E0308`."}]}