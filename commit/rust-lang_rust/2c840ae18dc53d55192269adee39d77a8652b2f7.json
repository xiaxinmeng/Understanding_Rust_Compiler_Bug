{"sha": "2c840ae18dc53d55192269adee39d77a8652b2f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjODQwYWUxOGRjNTNkNTUxOTIyNjlhZGVlMzlkNzdhODY1MmIyZjc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-02T16:38:12Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-21T19:03:34Z"}, "message": "Use normal mutable borrows in MIR match lowering", "tree": {"sha": "2055a2c49e9d331e40df05793bd3a9b20f5358ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2055a2c49e9d331e40df05793bd3a9b20f5358ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c840ae18dc53d55192269adee39d77a8652b2f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c840ae18dc53d55192269adee39d77a8652b2f7", "html_url": "https://github.com/rust-lang/rust/commit/2c840ae18dc53d55192269adee39d77a8652b2f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c840ae18dc53d55192269adee39d77a8652b2f7/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5407fbdef83b552ac5ee35c9577319c59d851467", "url": "https://api.github.com/repos/rust-lang/rust/commits/5407fbdef83b552ac5ee35c9577319c59d851467", "html_url": "https://github.com/rust-lang/rust/commit/5407fbdef83b552ac5ee35c9577319c59d851467"}], "stats": {"total": 535, "additions": 227, "deletions": 308}, "files": [{"sha": "ddc091b7187063eb714aecee9d1724c5f329a9ee", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -196,7 +196,12 @@ impl_stable_hash_for!(impl<'gcx> for enum mir::StatementKind<'gcx> [ mir::Statem\n });\n \n impl_stable_hash_for!(enum mir::RetagKind { FnEntry, TwoPhase, Raw, Default });\n-impl_stable_hash_for!(enum mir::FakeReadCause { ForMatchGuard, ForMatchedPlace, ForLet });\n+impl_stable_hash_for!(enum mir::FakeReadCause {\n+    ForMatchGuard,\n+    ForMatchedPlace,\n+    ForGuardBinding,\n+    ForLet\n+});\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "6c72a7c31591e74e9a2a0ee339f3445d7adb74e0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -1823,17 +1823,22 @@ pub enum RetagKind {\n /// The `FakeReadCause` describes the type of pattern why a `FakeRead` statement exists.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum FakeReadCause {\n-    /// Inject a fake read of the borrowed input at the start of each arm's\n-    /// pattern testing code.\n+    /// Inject a fake read of the borrowed input at the end of each guards\n+    /// code.\n     ///\n-    /// This should ensure that you cannot change the variant for an enum\n-    /// while you are in the midst of matching on it.\n+    /// This should ensure that you cannot change the variant for an enum while\n+    /// you are in the midst of matching on it.\n     ForMatchGuard,\n \n     /// `let x: !; match x {}` doesn't generate any read of x so we need to\n     /// generate a read of x to check that it is initialized and safe.\n     ForMatchedPlace,\n \n+    /// A fake read of the RefWithinGuard version of a bind-by-value variable\n+    /// in a match guard to ensure that it's value hasn't change by the time\n+    /// we create the OutsideGuard version.\n+    ForGuardBinding,\n+\n     /// Officially, the semantics of\n     ///\n     /// `let pattern = <expr>;`"}, {"sha": "1e9dab5016f8d24abe2b21171a48ece212d7a609", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -998,7 +998,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared)\n-                | (Read(_), BorrowKind::Shallow) | (Reservation(..), BorrowKind::Shallow) => {\n+                | (Read(_), BorrowKind::Shallow) | (Reservation(..), BorrowKind::Shallow)\n+                | (Read(ReadKind::Borrow(BorrowKind::Shallow)), BorrowKind::Unique)\n+                | (Read(ReadKind::Borrow(BorrowKind::Shallow)), BorrowKind::Mut { .. }) => {\n                     Control::Continue\n                 }\n "}, {"sha": "9c067677621081998c9f4af0835d6948366a119b", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -78,13 +78,8 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                     JustWrite\n                 );\n             }\n-            StatementKind::FakeRead(_, ref place) => {\n-                self.access_place(\n-                    ContextKind::FakeRead.new(location),\n-                    place,\n-                    (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n-                    LocalMutationIsAllowed::No,\n-                );\n+            StatementKind::FakeRead(_, _) => {\n+                // Only relavent for initialized/liveness/safety checks.\n             }\n             StatementKind::SetDiscriminant {\n                 ref place,\n@@ -438,7 +433,9 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                     }\n \n                     (Read(_), BorrowKind::Shallow) | (Reservation(..), BorrowKind::Shallow)\n-                    | (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                    | (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared)\n+                    | (Read(ReadKind::Borrow(BorrowKind::Shallow)), BorrowKind::Unique)\n+                    | (Read(ReadKind::Borrow(BorrowKind::Shallow)), BorrowKind::Mut { .. }) => {\n                         // Reads/reservations don't invalidate shared or shallow borrows\n                     }\n "}, {"sha": "627fd7d2e16677a68b1bf3d8751a32f2f8da24a8", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -6,8 +6,6 @@ use rustc::mir::*;\n use rustc::hir;\n use syntax_pos::Span;\n \n-use std::slice;\n-\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n                      destination: &Place<'tcx>,\n@@ -125,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             None,\n                             remainder_span,\n                             lint_level,\n-                            slice::from_ref(&pattern),\n+                            &pattern,\n                             ArmHasGuard(false),\n                             Some((None, initializer_span)),\n                         );\n@@ -138,7 +136,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             }));\n                     } else {\n                         scope = this.declare_bindings(\n-                            None, remainder_span, lint_level, slice::from_ref(&pattern),\n+                            None, remainder_span, lint_level, &pattern,\n                             ArmHasGuard(false), None);\n \n                         debug!(\"ast_block_stmts: pattern={:?}\", pattern);"}, {"sha": "07c179ded593fa87210885f0325f8a487dc879f5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 95, "deletions": 122, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -6,15 +6,15 @@\n //! function parameters.\n \n use crate::build::scope::{CachedBlock, DropKind};\n-use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n+use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::bit_set::BitSet;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use syntax::ast::{Name, NodeId};\n use syntax_pos::Span;\n \n@@ -71,7 +71,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// ## Fake Reads and borrows\n     ///\n-    /// Match exhaustiveness checking is no able to handle the case where the\n+    /// Match exhaustiveness checking is not able to handle the case where the\n     /// place being matched on is mutated in the guards. There is an AST check\n     /// that tries to stop this but it is buggy and overly restrictive. Instead\n     /// we add \"fake borrows\" to the guards that prevent any mutation of the\n@@ -84,7 +84,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///    borrows of `x`, so we only add fake borrows for places which are\n     ///    bound or tested by the match.\n     /// 3. We don't want the fake borrows to conflict with `ref mut` bindings,\n-    ///    so we lower `ref mut` bindings as two-phase borrows for the guard.\n+    ///    so we use a special BorrowKind for them.\n     /// 4. The fake borrows may be of places in inactive variants, so it would\n     ///    be UB to generate code for them. They therefore have to be removed\n     ///    by a MIR pass run after borrow checking.\n@@ -145,8 +145,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n \n-        // There's one move pre_binding block that there are candidates so that\n-        // every candidate has a next prebinding_block.\n+        // There's one more pre_binding block than there are candidates so that\n+        // every candidate can have a `next_candidate_pre_binding_block`.\n         let outer_source_info = self.source_info(span);\n         self.cfg.terminate(\n             *pre_binding_blocks.last().unwrap(),\n@@ -197,13 +197,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Step 3. Create the decision tree and record the places that we bind or test.\n \n-        // Maps a place to the kind of Fake borrow that we want to perform on\n-        // it: either Shallow or Shared, depending on whether the place is\n-        // bound in the match, or just switched on.\n-        // If there are no match guards then we don't need any fake borrows,\n-        // so don't track them.\n+        // The set of places that we are creating fake borrows of. If there are\n+        // no match guards then we don't need any fake borrows, so don't track\n+        // them.\n         let mut fake_borrows = if match_has_guard && tcx.generate_borrow_of_any_match_input() {\n-            Some(FxHashMap::default())\n+            Some(FxHashSet::default())\n         } else {\n             None\n         };\n@@ -265,19 +263,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 None,\n                 body.span,\n                 LintLevel::Inherited,\n-                &arm.patterns[..],\n+                &arm.patterns[0],\n                 ArmHasGuard(arm.guard.is_some()),\n                 Some((Some(&scrutinee_place), scrutinee_span)),\n             );\n \n-            for (pat_index, candidate) in candidates.into_iter().enumerate() {\n+            for candidate in candidates {\n                 self.bind_and_guard_matched_candidate(\n                     candidate,\n                     arm.guard.clone(),\n                     arm_block,\n                     &fake_borrow_temps,\n                     scrutinee_span,\n-                    pat_index,\n                 );\n             }\n \n@@ -482,7 +479,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n         lint_level: LintLevel,\n-        patterns: &[Pattern<'tcx>],\n+        pattern: &Pattern<'tcx>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n@@ -491,10 +488,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             \"can't have both a visibility and a lint scope at the same time\"\n         );\n         let mut scope = self.source_scope;\n-        let num_patterns = patterns.len();\n-        debug!(\"declare_bindings: patterns={:?}\", patterns);\n+        debug!(\"declare_bindings: pattern={:?}\", pattern);\n         self.visit_bindings(\n-            &patterns[0],\n+            &pattern,\n             UserTypeProjections::none(),\n             &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n                 if visibility_scope.is_none() {\n@@ -515,13 +511,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     mutability,\n                     name,\n                     mode,\n-                    num_patterns,\n                     var,\n                     ty,\n                     user_ty,\n                     has_guard,\n                     opt_match_place.map(|(x, y)| (x.cloned(), y)),\n-                    patterns[0].span,\n+                    pattern.span,\n                 );\n             },\n         );\n@@ -804,7 +799,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         span: Span,\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         mut block: BasicBlock,\n-        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) -> Vec<BasicBlock> {\n         debug!(\n             \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n@@ -901,19 +896,41 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         &mut self,\n         matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n         block: BasicBlock,\n-        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) -> Option<BasicBlock> {\n         debug_assert!(\n             !matched_candidates.is_empty(),\n             \"select_matched_candidates called with no candidates\",\n         );\n \n-        // Insert a *Shared* borrow of any places that are bound.\n+        // Insert a borrows of prefixes of places that are bound and are\n+        // behind a dereference projection.\n+        //\n+        // These borrows are taken to avoid situations like the following:\n+        //\n+        // match x[10] {\n+        //     _ if { x = &[0]; false } => (),\n+        //     y => (), // Out of bounds array access!\n+        // }\n+        //\n+        // match *x {\n+        //     // y is bound by reference in the guard and then by copy in the\n+        //     // arm, so y is 2 in the arm!\n+        //     y if { y == 1 && (x = &2) == () } => y,\n+        //     _ => 3,\n+        // }\n         if let Some(fake_borrows) = fake_borrows {\n             for Binding { source, .. }\n                 in matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n             {\n-                fake_borrows.insert(source.clone(), BorrowKind::Shared);\n+                let mut cursor = source;\n+                while let Place::Projection(box Projection { base, elem }) = cursor {\n+                    cursor = base;\n+                    if let ProjectionElem::Deref = elem {\n+                        fake_borrows.insert(cursor.clone());\n+                        break;\n+                    }\n+                }\n             }\n         }\n \n@@ -959,8 +976,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-\n-        // if None is returned, then\n         debug!(\"match_candidates: add false edges for unreachable {:?}\", unreachable_candidates);\n         for candidate in unreachable_candidates {\n             if let Some(otherwise) = candidate.otherwise_block {\n@@ -1133,7 +1148,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         span: Span,\n         mut candidates: &'b mut [&'c mut Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n-        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) -> (Vec<BasicBlock>, &'b mut [&'c mut Candidate<'pat, 'tcx>]) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n@@ -1177,7 +1192,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         fake_borrows.as_mut().map(|fb| {\n-            fb.entry(match_place.clone()).or_insert(BorrowKind::Shallow)\n+            fb.insert(match_place.clone())\n         });\n \n         // perform the test, branching to one of N blocks. For each of\n@@ -1236,30 +1251,30 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // will evaluate to the same thing until an arm has been chosen.\n     fn calculate_fake_borrows<'b>(\n         &mut self,\n-        fake_borrows: &'b FxHashMap<Place<'tcx>, BorrowKind>,\n+        fake_borrows: &'b FxHashSet<Place<'tcx>>,\n         temp_span: Span,\n-    ) -> Vec<(&'b Place<'tcx>, BorrowKind, Local)> {\n+    ) -> Vec<(&'b Place<'tcx>, Local)> {\n         let tcx = self.hir.tcx();\n \n         debug!(\"add_fake_borrows fake_borrows = {:?}\", fake_borrows);\n \n         let mut all_fake_borrows = Vec::with_capacity(fake_borrows.len());\n \n         // Insert a Shallow borrow of the prefixes of any fake borrows.\n-        for (place, borrow_kind) in fake_borrows\n+        for place in fake_borrows\n         {\n             let mut prefix_cursor = place;\n             while let Place::Projection(box Projection { base, elem }) = prefix_cursor {\n                 if let ProjectionElem::Deref = elem {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n-                    all_fake_borrows.push((base, BorrowKind::Shallow));\n+                    all_fake_borrows.push(base);\n                 }\n                 prefix_cursor = base;\n             }\n \n-            all_fake_borrows.push((place, *borrow_kind));\n+            all_fake_borrows.push(place);\n         }\n \n         // Deduplicate and ensure a deterministic order.\n@@ -1268,14 +1283,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n \n-        all_fake_borrows.into_iter().map(|(matched_place, borrow_kind)| {\n+        all_fake_borrows.into_iter().map(|matched_place| {\n             let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).to_ty(tcx);\n             let fake_borrow_ty = tcx.mk_imm_ref(tcx.types.re_erased, fake_borrow_deref_ty);\n             let fake_borrow_temp = self.local_decls.push(\n                 LocalDecl::new_temp(fake_borrow_ty, temp_span)\n             );\n \n-            (matched_place, borrow_kind, fake_borrow_temp)\n+            (matched_place, fake_borrow_temp)\n         }).collect()\n     }\n }\n@@ -1301,9 +1316,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         candidate: Candidate<'pat, 'tcx>,\n         guard: Option<Guard<'tcx>>,\n         arm_block: BasicBlock,\n-        fake_borrows: &Vec<(&Place<'tcx>, BorrowKind, Local)>,\n+        fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n-        pat_index: usize,\n     ) {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n@@ -1399,18 +1413,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //\n         //    * Here, the guard expression wants a `&&` or `&&mut`\n         //      into the original input. This means we need to borrow\n-        //      a reference that we do not immediately have at hand\n-        //      (because all we have is the places associated with the\n-        //      match input itself; it is up to us to create a place\n-        //      holding a `&` or `&mut` that we can then borrow).\n-\n+        //      the reference that we create for the arm.\n+        //    * So we eagerly create the reference for the arm and then take a\n+        //      reference to that.\n         let tcx = self.hir.tcx();\n         let autoref = tcx.all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = guard {\n             if autoref {\n                 self.bind_matched_candidate_for_guard(\n                     block,\n-                    pat_index,\n                     &candidate.bindings,\n                 );\n                 let guard_frame = GuardFrame {\n@@ -1428,10 +1439,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             let re_erased = tcx.types.re_erased;\n             let scrutinee_source_info = self.source_info(scrutinee_span);\n-            for &(place, borrow_kind, temp) in fake_borrows {\n+            for &(place, temp) in fake_borrows {\n                 let borrow = Rvalue::Ref(\n                     re_erased,\n-                    borrow_kind,\n+                    BorrowKind::Shallow,\n                     place.clone(),\n                 );\n                 self.cfg.push_assign(\n@@ -1458,7 +1469,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n             }\n \n-            for &(_, _, temp) in fake_borrows {\n+            for &(_, temp) in fake_borrows {\n                 self.cfg.push(block, Statement {\n                     source_info: guard_end,\n                     kind: StatementKind::FakeRead(\n@@ -1507,7 +1518,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             );\n \n             if autoref {\n-                self.bind_matched_candidate_for_arm_body(post_guard_block, &candidate.bindings);\n+                let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n+                    if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n+                });\n+                // Read all of the by reference bindings to ensure that the\n+                // place they refer to can't be modified by the guard.\n+                for binding in by_value_bindings.clone() {\n+                    let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n+                    let place = Place::Local(local_id);\n+                    self.cfg.push(\n+                        block,\n+                        Statement {\n+                            source_info: guard_end,\n+                            kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, place),\n+                        },\n+                    );\n+                }\n+                self.bind_matched_candidate_for_arm_body(\n+                    post_guard_block,\n+                    by_value_bindings,\n+                );\n             }\n \n             self.cfg.terminate(\n@@ -1570,13 +1600,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn bind_matched_candidate_for_guard(\n         &mut self,\n         block: BasicBlock,\n-        pat_index: usize,\n         bindings: &[Binding<'tcx>],\n     ) {\n-        debug!(\n-            \"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n-            block, pat_index, bindings\n-        );\n+        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\", block, bindings);\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n@@ -1603,66 +1629,35 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(borrow_kind) => {\n-                    // Tricky business: For `ref id` and `ref mut id`\n-                    // patterns, we want `id` within the guard to\n-                    // correspond to a temp of type `& &T` or `& &mut\n-                    // T` (i.e., a \"borrow of a borrow\") that is\n-                    // implicitly dereferenced.\n-                    //\n-                    // To borrow a borrow, we need that inner borrow\n-                    // to point to. So, create a temp for the inner\n-                    // borrow, and then take a reference to it.\n-                    //\n-                    // Note: the temp created here is *not* the one\n-                    // used by the arm body itself. This eases\n-                    // observing two-phase borrow restrictions.\n-                    let val_for_guard = self.storage_live_binding(\n+                    let value_for_arm = self.storage_live_binding(\n                         block,\n                         binding.var_id,\n                         binding.span,\n-                        ValWithinGuard(pat_index),\n+                        OutsideGuard,\n                     );\n                     self.schedule_drop_for_binding(\n                         binding.var_id,\n                         binding.span,\n-                        ValWithinGuard(pat_index),\n+                        OutsideGuard,\n                     );\n \n-                    // rust-lang/rust#27282: We reuse the two-phase\n-                    // borrow infrastructure so that the mutable\n-                    // borrow (whose mutabilty is *unusable* within\n-                    // the guard) does not conflict with the implicit\n-                    // borrow of the whole match input. See additional\n-                    // discussion on rust-lang/rust#49870.\n-                    let borrow_kind = match borrow_kind {\n-                        BorrowKind::Shared\n-                        | BorrowKind::Shallow\n-                        | BorrowKind::Unique => borrow_kind,\n-                        BorrowKind::Mut { .. } => BorrowKind::Mut {\n-                            allow_two_phase_borrow: true,\n-                        },\n-                    };\n                     let rvalue = Rvalue::Ref(re_erased, borrow_kind, binding.source.clone());\n                     self.cfg\n-                        .push_assign(block, source_info, &val_for_guard, rvalue);\n-                    let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, val_for_guard);\n+                        .push_assign(block, source_info, &value_for_arm, rvalue);\n+                    let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, value_for_arm);\n                     self.cfg\n                         .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n             }\n         }\n     }\n \n-    fn bind_matched_candidate_for_arm_body(\n+    fn bind_matched_candidate_for_arm_body<'b>(\n         &mut self,\n         block: BasicBlock,\n-        bindings: &[Binding<'tcx>],\n-    ) {\n-        debug!(\n-            \"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\",\n-            block, bindings\n-        );\n-\n+        bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n+    ) where 'tcx: 'b {\n+        debug!(\"bind_matched_candidate_for_arm_body(block={:?})\", block);\n \n         let re_erased = self.hir.tcx().types.re_erased;\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n@@ -1683,29 +1678,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where\n-    /// the bound `var` has type `T` in the arm body) in a pattern\n-    /// maps to `2+N` locals. The first local is a binding for\n-    /// occurrences of `var` in the guard, which will all have type\n-    /// `&T`. The N locals are bindings for the `T` that is referenced\n-    /// by the first local; they are not used outside of the\n-    /// guard. The last local is a binding for occurrences of `var` in\n-    /// the arm body, which will have type `T`.\n-    ///\n-    /// The reason we have N locals rather than just 1 is to\n-    /// accommodate rust-lang/rust#51348: If the arm has N candidate\n-    /// patterns, then in general they can correspond to distinct\n-    /// parts of the matched data, and we want them to be distinct\n-    /// temps in order to simplify checks performed by our internal\n-    /// leveraging of two-phase borrows).\n+    /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where the bound\n+    /// `var` has type `T` in the arm body) in a pattern maps to 2 locals. The\n+    /// first local is a binding for occurrences of `var` in the guard, which\n+    /// will have type `&T`. The second local is a binding for occurrences of\n+    /// `var` in the arm body, which will have type `T`.\n     fn declare_binding(\n         &mut self,\n         source_info: SourceInfo,\n         visibility_scope: SourceScope,\n         mutability: Mutability,\n         name: Name,\n         mode: BindingMode,\n-        num_patterns: usize,\n         var_id: NodeId,\n         var_ty: Ty<'tcx>,\n         user_ty: UserTypeProjections<'tcx>,\n@@ -1747,31 +1731,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n         let for_arm_body = self.local_decls.push(local.clone());\n         let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n-            let mut vals_for_guard = Vec::with_capacity(num_patterns);\n-            for _ in 0..num_patterns {\n-                let val_for_guard_idx = self.local_decls.push(LocalDecl {\n-                    // This variable isn't mutated but has a name, so has to be\n-                    // immutable to avoid the unused mut lint.\n-                    mutability: Mutability::Not,\n-                    ..local.clone()\n-                });\n-                vals_for_guard.push(val_for_guard_idx);\n-            }\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n-                // See previous comment.\n+                // This variable isn't mutated but has a name, so has to be\n+                // immutable to avoid the unused mut lint.\n                 mutability: Mutability::Not,\n                 ty: tcx.mk_imm_ref(tcx.types.re_erased, var_ty),\n                 user_ty: UserTypeProjections::none(),\n                 name: Some(name),\n                 source_info,\n                 visibility_scope,\n-                // FIXME: should these secretly injected ref_for_guard's be marked as `internal`?\n                 internal: false,\n                 is_block_tail: None,\n                 is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n             LocalsForNode::ForGuard {\n-                vals_for_guard,\n                 ref_for_guard,\n                 for_arm_body,\n             }"}, {"sha": "903c8f8657f3d38c13f283d224b55226367003dd", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -459,25 +459,15 @@ enum LocalsForNode {\n \n     /// The exceptional case is identifiers in a match arm's pattern\n     /// that are referenced in a guard of that match arm. For these,\n-    /// we can have `2 + k` Locals, where `k` is the number of candidate\n-    /// patterns (separated by `|`) in the arm.\n+    /// we have `2` Locals.\n     ///\n     /// * `for_arm_body` is the Local used in the arm body (which is\n     ///   just like the `One` case above),\n     ///\n     /// * `ref_for_guard` is the Local used in the arm's guard (which\n     ///   is a reference to a temp that is an alias of\n     ///   `for_arm_body`).\n-    ///\n-    /// * `vals_for_guard` is the `k` Locals; at most one of them will\n-    ///   get initialized by the arm's execution, and after it is\n-    ///   initialized, `ref_for_guard` will be assigned a reference to\n-    ///   it.\n-    ///\n-    /// There reason we have `k` Locals rather than just 1 is to\n-    /// accommodate some restrictions imposed by two-phase borrows,\n-    /// which apply when we have a `ref mut` pattern.\n-    ForGuard { vals_for_guard: Vec<Local>, ref_for_guard: Local, for_arm_body: Local },\n+    ForGuard { ref_for_guard: Local, for_arm_body: Local },\n }\n \n #[derive(Debug)]\n@@ -510,16 +500,11 @@ struct GuardFrame {\n }\n \n /// `ForGuard` indicates whether we are talking about:\n-///   1. the temp for a local binding used solely within guard expressions,\n-///   2. the temp that holds reference to (1.), which is actually what the\n-///      guard expressions see, or\n-///   3. the temp for use outside of guard expressions.\n+///   1. The variable for use outside of guard expressions, or\n+///   2. The temp that holds reference to (1.), which is actually what the\n+///      guard expressions see.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ForGuard {\n-    /// The `usize` identifies for which candidate pattern we want the\n-    /// local binding. We keep a temp per-candidate to accommodate\n-    /// two-phase borrows (see `LocalsForNode` documentation).\n-    ValWithinGuard(usize),\n     RefWithinGuard,\n     OutsideGuard,\n }\n@@ -532,11 +517,6 @@ impl LocalsForNode {\n             (&LocalsForNode::ForGuard { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n                 local_id,\n \n-            (&LocalsForNode::ForGuard { ref vals_for_guard, .. },\n-             ForGuard::ValWithinGuard(pat_idx)) =>\n-                vals_for_guard[pat_idx],\n-\n-            (&LocalsForNode::One(_), ForGuard::ValWithinGuard(_)) |\n             (&LocalsForNode::One(_), ForGuard::RefWithinGuard) =>\n                 bug!(\"anything with one local should never be within a guard.\"),\n         }\n@@ -941,7 +921,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n-                                                      LintLevel::Inherited, &[pattern.clone()],\n+                                                      LintLevel::Inherited, &pattern,\n                                                       matches::ArmHasGuard(false),\n                                                       Some((Some(&place), span)));\n                         unpack!(block = self.place_into_pattern(block, pattern, &place, false));"}, {"sha": "cf650b5a0ba584345da8930bc38e854255dce6ee", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 60, "deletions": 64, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -73,34 +73,33 @@ fn main() {\n //      return;\n //  }\n //  bb9: { // binding1 and guard\n-//      StorageLive(_8);\n-//      _8 = &(((promoted[2]: std::option::Option<i32>) as Some).0: i32);\n-//      _4 = &shallow (promoted[1]: std::option::Option<i32>);\n-//      _5 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n-//      StorageLive(_9);\n-//      _9 = const guard() -> [return: bb10, unwind: bb1];\n+//      StorageLive(_6);\n+//      _6 = &(((promoted[1]: std::option::Option<i32>) as Some).0: i32);\n+//      _4 = &shallow (promoted[0]: std::option::Option<i32>);\n+//      StorageLive(_7);\n+//      _7 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n //  bb10: {\n //      FakeRead(ForMatchGuard, _4);\n-//      FakeRead(ForMatchGuard, _5);\n-//      switchInt(move _9) -> [false: bb6, otherwise: bb11];\n+//      FakeRead(ForGuardBinding, _6);\n+//      switchInt(move _7) -> [false: bb6, otherwise: bb11];\n //  }\n //  bb11: {\n-//      StorageLive(_6);\n-//      _6 = ((_2 as Some).0: i32);\n-//      StorageLive(_10);\n-//      _10 = _6;\n-//      _1 = (const 1i32, move _10);\n-//      StorageDead(_10);\n+//      StorageLive(_5);\n+//      _5 = ((_2 as Some).0: i32);\n+//      StorageLive(_8);\n+//      _8 = _5;\n+//      _1 = (const 1i32, move _8);\n+//      StorageDead(_8);\n //      goto -> bb8;\n //  }\n //  bb12: {\n-//      StorageLive(_11);\n-//      _11 = ((_2 as Some).0: i32);\n-//      StorageLive(_12);\n-//      _12 = _11;\n-//      _1 = (const 2i32, move _12);\n-//      StorageDead(_12);\n+//      StorageLive(_9);\n+//      _9 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _9;\n+//      _1 = (const 2i32, move _10);\n+//      StorageDead(_10);\n //      goto -> bb8;\n //  }\n //  bb13: {\n@@ -143,38 +142,37 @@ fn main() {\n //      return;\n //  }\n //  bb9: { // binding1 and guard\n-//      StorageLive(_8);\n-//      _8 = &((_2 as Some).0: i32);\n+//      StorageLive(_6);\n+//      _6 = &((_2 as Some).0: i32);\n //      _4 = &shallow _2;\n-//      _5 = &((_2 as Some).0: i32);\n-//      StorageLive(_9);\n-//      _9 = const guard() -> [return: bb10, unwind: bb1];\n+//      StorageLive(_7);\n+//      _7 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n //  bb10: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n-//      FakeRead(ForMatchGuard, _5);\n-//      switchInt(move _9) -> [false: bb6, otherwise: bb11];\n+//      FakeRead(ForGuardBinding, _6);\n+//      switchInt(move _7) -> [false: bb6, otherwise: bb11];\n //  }\n //  bb11: { // arm1\n-//      StorageLive(_6);\n-//      _6 = ((_2 as Some).0: i32);\n-//      StorageLive(_10);\n-//      _10 = _6;\n-//      _1 = (const 1i32, move _10);\n-//      StorageDead(_10);\n+//      StorageLive(_5);\n+//      _5 = ((_2 as Some).0: i32);\n+//      StorageLive(_8);\n+//      _8 = _5;\n+//      _1 = (const 1i32, move _8);\n+//      StorageDead(_8);\n //      goto -> bb8;\n //  }\n //  bb12: { // arm2\n //      _1 = (const 3i32, const 3i32);\n //      goto -> bb8;\n //  }\n //  bb13: { // binding3 and arm3\n-//      StorageLive(_11);\n-//      _11 = ((_2 as Some).0: i32);\n-//      StorageLive(_12);\n-//      _12 = _11;\n-//      _1 = (const 2i32, move _12);\n-//      StorageDead(_12);\n+//      StorageLive(_9);\n+//      _9 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _9;\n+//      _1 = (const 2i32, move _10);\n+//      StorageDead(_10);\n //      goto -> bb8;\n //  }\n // END rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n@@ -216,55 +214,53 @@ fn main() {\n //      return;\n //  }\n //  bb10: { // binding1: Some(w) if guard()\n-//      StorageLive(_9);\n-//      _9 = &((_2 as Some).0: i32);\n+//      StorageLive(_7);\n+//      _7 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n-//      _6 = &((_2 as Some).0: i32);\n-//      StorageLive(_10);\n-//      _10 = const guard() -> [return: bb11, unwind: bb1];\n+//      StorageLive(_8);\n+//      _8 = const guard() -> [return: bb11, unwind: bb1];\n //  }\n //  bb11: { //end of guard\n //      FakeRead(ForMatchGuard, _5);\n-//      FakeRead(ForMatchGuard, _6);\n-//      switchInt(move _10) -> [false: bb7, otherwise: bb12];\n+//      FakeRead(ForGuardBinding, _7);\n+//      switchInt(move _8) -> [false: bb7, otherwise: bb12];\n //  }\n //  bb12: { // set up bindings for arm1\n-//      StorageLive(_7);\n-//      _7 = ((_2 as Some).0: i32);\n+//      StorageLive(_6);\n+//      _6 = ((_2 as Some).0: i32);\n //      _1 = const 1i32;\n //      goto -> bb9;\n //  }\n //  bb13: { // binding2 & arm2\n-//      StorageLive(_11);\n-//      _11 = _2;\n+//      StorageLive(_9);\n+//      _9 = _2;\n //      _1 = const 2i32;\n //      goto -> bb9;\n //  }\n //  bb14: { // binding3: Some(y) if guard2(y)\n-//      StorageLive(_14);\n-//      _14 = &((_2 as Some).0: i32);\n+//      StorageLive(_11);\n+//      _11 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n-//      _6 = &((_2 as Some).0: i32);\n-//      StorageLive(_15);\n-//      StorageLive(_16);\n-//      _16 = (*_14);\n-//      _15 = const guard2(move _16) -> [return: bb15, unwind: bb1];\n+//      StorageLive(_12);\n+//      StorageLive(_13);\n+//      _13 = (*_11);\n+//      _12 = const guard2(move _13) -> [return: bb15, unwind: bb1];\n //  }\n //  bb15: { // end of guard2\n-//      StorageDead(_16);\n+//      StorageDead(_13);\n //      FakeRead(ForMatchGuard, _5);\n-//      FakeRead(ForMatchGuard, _6);\n-//      switchInt(move _15) -> [false: bb8, otherwise: bb16];\n+//      FakeRead(ForGuardBinding, _11);\n+//      switchInt(move _12) -> [false: bb8, otherwise: bb16];\n //  }\n //  bb16: { // binding4 & arm4\n-//      StorageLive(_12);\n-//      _12 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = ((_2 as Some).0: i32);\n //      _1 = const 3i32;\n //      goto -> bb9;\n //  }\n //  bb17: {\n-//      StorageLive(_17);\n-//      _17 = _2;\n+//      StorageLive(_14);\n+//      _14 = _2;\n //      _1 = const 4i32;\n //      goto -> bb9;\n //  }"}, {"sha": "6e158713146f15a0e1521dae7eda854e39945e4a", "filename": "src/test/ui/nll/match-guards-partially-borrow.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -17,6 +17,30 @@ fn ok_mutation_in_guard(mut q: i32) {\n     }\n }\n \n+fn ok_mutation_in_guard2(mut u: bool) {\n+    // OK value of u is unused before modification\n+    match u {\n+        _ => (),\n+        _ if {\n+            u = true;\n+            false\n+        } => (),\n+        x => (),\n+    }\n+}\n+\n+fn ok_mutation_in_guard4(mut w: (&mut bool,)) {\n+    // OK value of u is unused before modification\n+    match w {\n+        _ => (),\n+        _ if {\n+            *w.0 = true;\n+            false\n+        } => (),\n+        x => (),\n+    }\n+}\n+\n fn ok_indirect_mutation_in_guard(mut p: &bool) {\n     match *p {\n         // OK, mutation doesn't change which patterns s matches\n@@ -53,8 +77,8 @@ fn mutation_invalidates_previous_pattern_in_guard(mut r: bool) {\n \n fn match_on_borrowed_early_end(mut s: bool) {\n     let h = &mut s;\n-    match s { //~ ERROR\n-        // s changes value between the start of the match and when its value is checked.\n+    // OK value of s is unused before modification.\n+    match s {\n         _ if {\n             *h = !*h;\n             false\n@@ -75,19 +99,7 @@ fn bad_mutation_in_guard(mut t: bool) {\n     }\n }\n \n-fn bad_mutation_in_guard2(mut u: bool) {\n-    match u {\n-        // Guard changes the value bound in the last pattern.\n-        _ => (),\n-        _ if {\n-            u = true; //~ ERROR\n-            false\n-        } => (),\n-        x => (),\n-    }\n-}\n-\n-pub fn bad_mutation_in_guard3(mut x: Option<Option<&i32>>) {\n+fn bad_mutation_in_guard2(mut x: Option<Option<&i32>>) {\n     // Check that nested patterns are checked.\n     match x {\n         None => (),\n@@ -103,20 +115,7 @@ pub fn bad_mutation_in_guard3(mut x: Option<Option<&i32>>) {\n     }\n }\n \n-\n-fn bad_mutation_in_guard4(mut w: (&mut bool,)) {\n-    match w {\n-        // Guard changes the value bound in the last pattern.\n-        _ => (),\n-        _ if {\n-            *w.0 = true; //~ ERROR\n-            false\n-        } => (),\n-        x => (),\n-    }\n-}\n-\n-fn bad_mutation_in_guard5(mut t: bool) {\n+fn bad_mutation_in_guard3(mut t: bool) {\n     match t {\n         s if {\n             t = !t; //~ ERROR"}, {"sha": "baff2fda9f5d143e58213eb3ad93eab8567519a9", "filename": "src/test/ui/nll/match-guards-partially-borrow.stderr", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c840ae18dc53d55192269adee39d77a8652b2f7/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr?ref=2c840ae18dc53d55192269adee39d77a8652b2f7", "patch": "@@ -1,5 +1,5 @@\n error[E0510]: cannot assign `q` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:35:13\n+  --> $DIR/match-guards-partially-borrow.rs:59:13\n    |\n LL |     match q {\n    |           - value is immutable in match guard\n@@ -8,81 +8,45 @@ LL |             q = true; //~ ERROR\n    |             ^^^^^^^^ cannot assign\n \n error[E0510]: cannot assign `r` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:47:13\n+  --> $DIR/match-guards-partially-borrow.rs:71:13\n    |\n LL |     match r {\n    |           - value is immutable in match guard\n ...\n LL |             r = true; //~ ERROR\n    |             ^^^^^^^^ cannot assign\n \n-error[E0503]: cannot use `s` because it was mutably borrowed\n-  --> $DIR/match-guards-partially-borrow.rs:56:11\n-   |\n-LL |     let h = &mut s;\n-   |             ------ borrow of `s` occurs here\n-LL |     match s { //~ ERROR\n-   |           ^ use of borrowed `s`\n-...\n-LL |             *h = !*h;\n-   |                   -- borrow later used here\n-\n error[E0510]: cannot assign `t` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:71:13\n+  --> $DIR/match-guards-partially-borrow.rs:95:13\n    |\n LL |     match t {\n    |           - value is immutable in match guard\n ...\n LL |             t = true; //~ ERROR\n    |             ^^^^^^^^ cannot assign\n \n-error[E0506]: cannot assign to `u` because it is borrowed\n-  --> $DIR/match-guards-partially-borrow.rs:83:13\n-   |\n-LL |     match u {\n-   |           - borrow of `u` occurs here\n-...\n-LL |             u = true; //~ ERROR\n-   |             ^^^^^^^^ assignment to borrowed `u` occurs here\n-LL |             false\n-LL |         } => (),\n-   |         - borrow later used here\n-\n error[E0510]: cannot mutably borrow `x.0` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:97:22\n+  --> $DIR/match-guards-partially-borrow.rs:109:22\n    |\n LL |     match x {\n    |           - value is immutable in match guard\n ...\n LL |                 Some(ref mut r) => *r = None, //~ ERROR\n    |                      ^^^^^^^^^ cannot mutably borrow\n \n-error[E0506]: cannot assign to `*w.0` because it is borrowed\n-  --> $DIR/match-guards-partially-borrow.rs:112:13\n-   |\n-LL |     match w {\n-   |           - borrow of `*w.0` occurs here\n-...\n-LL |             *w.0 = true; //~ ERROR\n-   |             ^^^^^^^^^^^ assignment to borrowed `*w.0` occurs here\n-LL |             false\n-LL |         } => (),\n-   |         - borrow later used here\n-\n error[E0506]: cannot assign to `t` because it is borrowed\n-  --> $DIR/match-guards-partially-borrow.rs:122:13\n+  --> $DIR/match-guards-partially-borrow.rs:121:13\n    |\n-LL |     match t {\n-   |           - borrow of `t` occurs here\n LL |         s if {\n+   |         - borrow of `t` occurs here\n LL |             t = !t; //~ ERROR\n    |             ^^^^^^ assignment to borrowed `t` occurs here\n LL |             false\n LL |         } => (), // What value should `s` have in the arm?\n    |         - borrow later used here\n \n error[E0510]: cannot assign `y` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:133:13\n+  --> $DIR/match-guards-partially-borrow.rs:132:13\n    |\n LL |     match *y {\n    |           -- value is immutable in match guard\n@@ -91,7 +55,7 @@ LL |             y = &true; //~ ERROR\n    |             ^^^^^^^^^ cannot assign\n \n error[E0510]: cannot assign `z` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:144:13\n+  --> $DIR/match-guards-partially-borrow.rs:143:13\n    |\n LL |     match z {\n    |           - value is immutable in match guard\n@@ -100,7 +64,7 @@ LL |             z = &true; //~ ERROR\n    |             ^^^^^^^^^ cannot assign\n \n error[E0510]: cannot assign `a` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:156:13\n+  --> $DIR/match-guards-partially-borrow.rs:155:13\n    |\n LL |     match a {\n    |           - value is immutable in match guard\n@@ -109,15 +73,15 @@ LL |             a = &true; //~ ERROR\n    |             ^^^^^^^^^ cannot assign\n \n error[E0510]: cannot assign `b` in match guard\n-  --> $DIR/match-guards-partially-borrow.rs:167:13\n+  --> $DIR/match-guards-partially-borrow.rs:166:13\n    |\n LL |     match b {\n    |           - value is immutable in match guard\n ...\n LL |             b = &true; //~ ERROR\n    |             ^^^^^^^^^ cannot assign\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 9 previous errors\n \n-Some errors occurred: E0503, E0506, E0510.\n-For more information about an error, try `rustc --explain E0503`.\n+Some errors occurred: E0506, E0510.\n+For more information about an error, try `rustc --explain E0506`."}]}