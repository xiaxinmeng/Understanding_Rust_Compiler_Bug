{"sha": "2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYjg1NGNjZGFlNmYxZjEyYjYwNDQxZTVjM2IyODNiZGM4MWZiMGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-07T15:28:30Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-07T15:36:33Z"}, "message": ":tada: extend selection", "tree": {"sha": "ed4f31d31473a2faf8e014907960f855b96cca22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed4f31d31473a2faf8e014907960f855b96cca22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "html_url": "https://github.com/rust-lang/rust/commit/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a04473e2bb95483e84404c57426ee9ed21fa5d6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a04473e2bb95483e84404c57426ee9ed21fa5d6b", "html_url": "https://github.com/rust-lang/rust/commit/a04473e2bb95483e84404c57426ee9ed21fa5d6b"}], "stats": {"total": 382, "additions": 376, "deletions": 6}, "files": [{"sha": "cb304a141b9d300edcb2c25a3e9a508e95219955", "filename": "code/native/src/lib.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/code%2Fnative%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/code%2Fnative%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fnative%2Fsrc%2Flib.rs?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -3,6 +3,7 @@ extern crate neon;\n extern crate libeditor;\n \n use neon::prelude::*;\n+use libeditor::TextRange;\n \n pub struct Wrapper {\n     inner: libeditor::File,\n@@ -19,8 +20,8 @@ declare_types! {\n         }\n \n         method syntaxTree(mut cx) {\n-            let this = cx.this();\n             let tree = {\n+            let this = cx.this();\n                 let guard = cx.lock();\n                 let wrapper = this.borrow(&guard);\n                 wrapper.inner.syntax_tree()\n@@ -29,8 +30,8 @@ declare_types! {\n         }\n \n         method highlight(mut cx) {\n-            let this = cx.this();\n             let highlights = {\n+                let this = cx.this();\n                 let guard = cx.lock();\n                 let wrapper = this.borrow(&guard);\n                 wrapper.inner.highlight()\n@@ -51,6 +52,33 @@ declare_types! {\n \n             Ok(res.upcast())\n         }\n+\n+        method extendSelection(mut cx) {\n+            let from_offset = cx.argument::<JsNumber>(0)?.value() as u32;\n+            let to_offset = cx.argument::<JsNumber>(1)?.value() as u32;\n+            let text_range = TextRange::from_to(from_offset.into(), to_offset.into());\n+            let extended_range = {\n+                let this = cx.this();\n+                let guard = cx.lock();\n+                let wrapper = this.borrow(&guard);\n+                wrapper.inner.extend_selection(text_range)\n+            };\n+\n+            match extended_range {\n+                None => Ok(cx.null().upcast()),\n+                Some(range) => {\n+                    let start: u32 = range.start().into();\n+                    let end: u32 = range.end().into();\n+                    let start = cx.number(start);\n+                    let end = cx.number(end);\n+                    let arr = cx.empty_array();\n+                    arr.set(&mut cx, 0, start)?;\n+                    arr.set(&mut cx, 1, end)?;\n+                    Ok(arr.upcast())\n+                }\n+            }\n+\n+        }\n     }\n \n }"}, {"sha": "66c4f266fcfc9c39a257fd8de70b54049f6f21df", "filename": "code/package.json", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/code%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/code%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fpackage.json?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -36,11 +36,15 @@\n             {\n                 \"command\": \"libsyntax-rust.syntaxTree\",\n                 \"title\": \"Show Rust syntax tree\"\n+            },\n+            {\n+                \"command\": \"libsyntax-rust.extendSelection\",\n+                \"title\": \"Rust Extend Selection\"\n             }\n         ],\n         \"keybindings\": [\n             {\n-                \"command\": \"libsyntax-rust.semanticSelection\",\n+                \"command\": \"libsyntax-rust.extendSelection\",\n                 \"key\": \"ctrl+w\",\n                 \"when\": \"editorTextFocus && editorLangId == rust\"\n             }"}, {"sha": "72bef70611f3c25191abac8893f7e36799025ffe", "filename": "code/src/main.ts", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/code%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/code%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fsrc%2Fmain.ts?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -34,6 +34,16 @@ export function activate(context: vscode.ExtensionContext) {\n     ))\n \n     registerCommand('libsyntax-rust.syntaxTree', () => openDoc(uris.syntaxTree))\n+    registerCommand('libsyntax-rust.extendSelection', () => {\n+        let editor = vscode.window.activeTextEditor\n+        let file = activeSyntax()\n+        if (editor == null || file == null) return\n+        editor.selections = editor.selections.map((s) => {\n+            let range = file.extendSelection(s)\n+            if (range == null) return null\n+            return new vscode.Selection(range.start, range.end)\n+        })\n+    })\n }\n \n export function deactivate() { }\n@@ -49,6 +59,11 @@ export class Syntax {\n \n     syntaxTree(): string { return this.imp.syntaxTree() }\n     highlight(): Array<[number, number, string]> { return this.imp.highlight() }\n+    extendSelection(range: vscode.Range): vscode.Range {\n+        let range_ = fromVsRange(this.doc, range);\n+        let extRange = this.imp.extendSelection(range_[0], range_[1]);\n+        return toVsRange(this.doc, extRange);\n+    }\n }\n \n "}, {"sha": "92abd3289ee70a9c3876bfd3e3057dbeab801803", "filename": "libeditor/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/libeditor%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/libeditor%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/libeditor%2FCargo.toml?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -6,4 +6,3 @@ publish = false\n \n [dependencies]\n libsyntax2 = { path = \"../\" }\n-text_unit = \"0.1.2\""}, {"sha": "16d4bc0844b941227a5da443481337f7a8f58ec9", "filename": "libeditor/src/extend_selection.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/libeditor%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/libeditor%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/libeditor%2Fsrc%2Fextend_selection.rs?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -0,0 +1,36 @@\n+use libsyntax2::{\n+    TextRange, SyntaxNodeRef,\n+    SyntaxKind::WHITESPACE,\n+    algo::{find_leaf_at_offset, find_covering_node, ancestors},\n+};\n+\n+\n+pub(crate) fn extend_selection(root: SyntaxNodeRef, range: TextRange) -> Option<TextRange> {\n+    if range.is_empty() {\n+        let offset = range.start();\n+        let mut leaves = find_leaf_at_offset(root, offset);\n+        if let Some(leaf) = leaves.clone().find(|node| node.kind() != WHITESPACE) {\n+            return Some(leaf.range());\n+        }\n+        let ws = leaves.next()?;\n+//        let ws_suffix = file.text().slice(\n+//            TextRange::from_to(offset, ws.range().end())\n+//        );\n+//        if ws.text().contains(\"\\n\") && !ws_suffix.contains(\"\\n\") {\n+//            if let Some(line_end) = file.text()\n+//                .slice(TextSuffix::from(ws.range().end()))\n+//                .find(\"\\n\")\n+//            {\n+//                let range = TextRange::from_len(ws.range().end(), line_end);\n+//                return Some(find_covering_node(file.root(), range).range());\n+//            }\n+//        }\n+        return Some(ws.range());\n+    };\n+    let node = find_covering_node(root, range);\n+\n+    match ancestors(node).skip_while(|n| n.range() == range).next() {\n+        None => None,\n+        Some(parent) => Some(parent.range()),\n+    }\n+}"}, {"sha": "a0c003fb50b46782505f7120f314dbcbaf79aa34", "filename": "libeditor/src/lib.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/libeditor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/libeditor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/libeditor%2Fsrc%2Flib.rs?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -1,12 +1,13 @@\n extern crate libsyntax2;\n-extern crate text_unit;\n+\n+mod extend_selection;\n \n use libsyntax2::{\n     SyntaxNodeRef,\n     algo::walk,\n     SyntaxKind::*,\n };\n-use text_unit::TextRange;\n+pub use libsyntax2::{TextRange, TextUnit};\n \n pub struct File {\n     inner: libsyntax2::File\n@@ -71,6 +72,11 @@ impl File {\n             .collect();\n         res // NLL :-(\n     }\n+\n+    pub fn extend_selection(&self, range: TextRange) -> Option<TextRange> {\n+        let syntax = self.inner.syntax();\n+        extend_selection::extend_selection(syntax.as_ref(), range)\n+    }\n }\n \n \n@@ -96,3 +102,22 @@ impl<'f> Declaration<'f> {\n         self.0.range()\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_extend_selection() {\n+        let text = r#\"fn foo() {\n+    1 + 1\n+}\n+\"#;\n+        let file = File::new(text);\n+        let range = TextRange::offset_len(18.into(), 0.into());\n+        let range = file.extend_selection(range).unwrap();\n+        assert_eq!(range, TextRange::from_to(17.into(), 18.into()));\n+        let range = file.extend_selection(range).unwrap();\n+        assert_eq!(range, TextRange::from_to(15.into(), 20.into()));\n+    }\n+}"}, {"sha": "d2de70fd4c78d8f977afd2ca8fda63a257e2a533", "filename": "src/algo/mod.rs", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/src%2Falgo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/src%2Falgo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Falgo%2Fmod.rs?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -1 +1,123 @@\n pub mod walk;\n+\n+use {SyntaxNodeRef, TextUnit, TextRange};\n+\n+pub fn find_leaf_at_offset(node: SyntaxNodeRef, offset: TextUnit) -> LeafAtOffset {\n+    let range = node.range();\n+    assert!(\n+        contains_offset_nonstrict(range, offset),\n+        \"Bad offset: range {:?} offset {:?}\", range, offset\n+    );\n+    if range.is_empty() {\n+        return LeafAtOffset::None;\n+    }\n+\n+    if node.is_leaf() {\n+        return LeafAtOffset::Single(node);\n+    }\n+\n+    let mut children = node.children()\n+        .filter(|child| {\n+            let child_range = child.range();\n+            !child_range.is_empty() && contains_offset_nonstrict(child_range, offset)\n+        });\n+\n+    let left = children.next().unwrap();\n+    let right = children.next();\n+    assert!(children.next().is_none());\n+    return if let Some(right) = right {\n+        match (find_leaf_at_offset(left, offset), find_leaf_at_offset(right, offset)) {\n+            (LeafAtOffset::Single(left), LeafAtOffset::Single(right)) =>\n+                LeafAtOffset::Between(left, right),\n+            _ => unreachable!()\n+        }\n+    } else {\n+        find_leaf_at_offset(left, offset)\n+    };\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub enum LeafAtOffset<'a> {\n+    None,\n+    Single(SyntaxNodeRef<'a>),\n+    Between(SyntaxNodeRef<'a>, SyntaxNodeRef<'a>)\n+}\n+\n+impl<'a> LeafAtOffset<'a> {\n+    pub fn right_biased(self) -> Option<SyntaxNodeRef<'a>> {\n+        match self {\n+            LeafAtOffset::None => None,\n+            LeafAtOffset::Single(node) => Some(node),\n+            LeafAtOffset::Between(_, right) => Some(right)\n+        }\n+    }\n+\n+    pub fn left_biased(self) -> Option<SyntaxNodeRef<'a>> {\n+        match self {\n+            LeafAtOffset::None => None,\n+            LeafAtOffset::Single(node) => Some(node),\n+            LeafAtOffset::Between(left, _) => Some(left)\n+        }\n+    }\n+}\n+\n+impl<'f> Iterator for LeafAtOffset<'f> {\n+    type Item = SyntaxNodeRef<'f>;\n+\n+    fn next(&mut self) -> Option<SyntaxNodeRef<'f>> {\n+        match *self {\n+            LeafAtOffset::None => None,\n+            LeafAtOffset::Single(node) => { *self = LeafAtOffset::None; Some(node) }\n+            LeafAtOffset::Between(left, right) => { *self = LeafAtOffset::Single(right); Some(left) }\n+        }\n+    }\n+}\n+\n+\n+pub fn find_covering_node(root: SyntaxNodeRef, range: TextRange) -> SyntaxNodeRef {\n+    assert!(is_subrange(root.range(), range));\n+    let (left, right) = match (\n+        find_leaf_at_offset(root, range.start()).right_biased(),\n+        find_leaf_at_offset(root, range.end()).left_biased()\n+    ) {\n+        (Some(l), Some(r)) => (l, r),\n+        _ => return root\n+    };\n+\n+    common_ancestor(left, right)\n+}\n+\n+fn common_ancestor<'a>(n1: SyntaxNodeRef<'a>, n2: SyntaxNodeRef<'a>) -> SyntaxNodeRef<'a> {\n+    for p in ancestors(n1) {\n+        if ancestors(n2).any(|a| a == p) {\n+            return p;\n+        }\n+    }\n+    panic!(\"Can't find common ancestor of {:?} and {:?}\", n1, n2)\n+}\n+\n+pub fn ancestors<'a>(node: SyntaxNodeRef<'a>) -> impl Iterator<Item=SyntaxNodeRef<'a>> {\n+    Ancestors(Some(node))\n+}\n+\n+#[derive(Debug)]\n+struct Ancestors<'a>(Option<SyntaxNodeRef<'a>>);\n+\n+impl<'a> Iterator for Ancestors<'a> {\n+    type Item = SyntaxNodeRef<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.take().map(|n| {\n+            self.0 = n.parent();\n+            n\n+        })\n+    }\n+}\n+\n+fn contains_offset_nonstrict(range: TextRange, offset: TextUnit) -> bool {\n+    range.start() <= offset && offset <= range.end()\n+}\n+\n+fn is_subrange(range: TextRange, subrange: TextRange) -> bool {\n+    range.start() <= subrange.start() && subrange.end() <= range.end()\n+}"}, {"sha": "46404f537678f69584d09d93f438c7c16abae9a7", "filename": "src/algo/search.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/src%2Falgo%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/src%2Falgo%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Falgo%2Fsearch.rs?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -0,0 +1,136 @@\n+use {Node, NodeType, TextUnit, TextRange};\n+use ::visitor::{visitor, process_subtree_bottom_up};\n+\n+pub fn child_of_type(node: Node, ty: NodeType) -> Option<Node> {\n+    node.children().find(|n| n.ty() == ty)\n+}\n+\n+pub fn children_of_type<'f>(node: Node<'f>, ty: NodeType) -> Box<Iterator<Item=Node<'f>> + 'f> {\n+    Box::new(node.children().filter(move |n| n.ty() == ty))\n+}\n+\n+pub fn subtree<'f>(node: Node<'f>) -> Box<Iterator<Item=Node<'f>> + 'f> {\n+    Box::new(node.children().flat_map(subtree).chain(::std::iter::once(node)))\n+}\n+\n+pub fn descendants_of_type<'f>(node: Node<'f>, ty: NodeType) -> Vec<Node<'f>> {\n+    process_subtree_bottom_up(\n+        node,\n+        visitor(Vec::new())\n+            .visit_nodes(&[ty], |node, nodes| nodes.push(node))\n+    )\n+}\n+\n+pub fn child_of_type_exn(node: Node, ty: NodeType) -> Node {\n+    child_of_type(node, ty).unwrap_or_else(|| {\n+        panic!(\"No child of type {:?} for {:?}\\\n+                ----\\\n+                {}\\\n+                ----\", ty, node.ty(), node.text())\n+    })\n+}\n+\n+\n+pub fn ancestors(node: Node) -> Ancestors {\n+    Ancestors(Some(node))\n+}\n+\n+pub struct Ancestors<'f>(Option<Node<'f>>);\n+\n+impl<'f> Iterator for Ancestors<'f> {\n+    type Item = Node<'f>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let current = self.0;\n+        self.0 = current.and_then(|n| n.parent());\n+        current\n+    }\n+}\n+\n+pub fn is_leaf(node: Node) -> bool {\n+    node.children().next().is_none() && !node.range().is_empty()\n+}\n+\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum Direction {\n+    Left, Right\n+}\n+\n+pub fn sibling(node: Node, dir: Direction) -> Option<Node> {\n+    let (parent, idx) = child_position(node)?;\n+    let idx = match dir {\n+        Direction::Left => idx.checked_sub(1)?,\n+        Direction::Right => idx + 1,\n+    };\n+    parent.children().nth(idx)\n+}\n+\n+pub mod ast {\n+    use {Node, AstNode, TextUnit, AstChildren};\n+    use visitor::{visitor, process_subtree_bottom_up};\n+    use super::{ancestors, find_leaf_at_offset, LeafAtOffset};\n+\n+    pub fn ancestor<'f, T: AstNode<'f>>(node: Node<'f>) -> Option<T> {\n+        ancestors(node)\n+            .filter_map(T::wrap)\n+            .next()\n+    }\n+\n+    pub fn ancestor_exn<'f, T: AstNode<'f>>(node: Node<'f>) -> T {\n+        ancestor(node).unwrap()\n+    }\n+\n+    pub fn children_of_type<'f, N: AstNode<'f>>(node: Node<'f>) -> AstChildren<N> {\n+        AstChildren::new(node.children())\n+    }\n+\n+    pub fn descendants_of_type<'f, N: AstNode<'f>>(node: Node<'f>) -> Vec<N> {\n+        process_subtree_bottom_up(\n+            node,\n+            visitor(Vec::new())\n+                .visit::<N, _>(|node, acc| acc.push(node))\n+        )\n+    }\n+\n+    pub fn node_at_offset<'f, T: AstNode<'f>>(node: Node<'f>, offset: TextUnit) -> Option<T> {\n+        match find_leaf_at_offset(node, offset) {\n+            LeafAtOffset::None => None,\n+            LeafAtOffset::Single(node) => ancestor(node),\n+            LeafAtOffset::Between(left, right) => ancestor(left).or_else(|| ancestor(right)),\n+        }\n+    }\n+}\n+\n+pub mod traversal {\n+    use {Node};\n+\n+    pub fn bottom_up<'f, F: FnMut(Node<'f>)>(node: Node<'f>, mut f: F)\n+    {\n+        go(node, &mut f);\n+\n+        fn go<'f, F: FnMut(Node<'f>)>(node: Node<'f>, f: &mut F) {\n+            for child in node.children() {\n+                go(child, f)\n+            }\n+            f(node);\n+        }\n+    }\n+}\n+\n+fn child_position(child: Node) -> Option<(Node, usize)> {\n+    child.parent()\n+        .map(|parent| {\n+            (parent, parent.children().position(|n| n == child).unwrap())\n+        })\n+}\n+\n+fn common_ancestor<'f>(n1: Node<'f>, n2: Node<'f>) -> Node<'f> {\n+    for p in ancestors(n1) {\n+        if ancestors(n2).any(|a| a == p) {\n+            return p;\n+        }\n+    }\n+    panic!(\"Can't find common ancestor of {:?} and {:?}\", n1, n2)\n+}\n+"}, {"sha": "4c97b1beac1cf5eeb104bb469b7b05b290afe873", "filename": "src/parser_impl/event.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/src%2Fparser_impl%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/src%2Fparser_impl%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser_impl%2Fevent.rs?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -13,6 +13,7 @@ use {\n     SyntaxKind::{self, TOMBSTONE},\n };\n \n+\n /// `Parser` produces a flat list of `Event`s.\n /// They are converted to a tree-structure in\n /// a separate pass, via `TreeBuilder`."}, {"sha": "07607ec2d58271bbd917edcae5bdfdc22040abce", "filename": "src/yellow/syntax.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/src%2Fyellow%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a/src%2Fyellow%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fyellow%2Fsyntax.rs?ref=2fb854ccdae6f1f12b60441e5c3b283bdc81fb0a", "patch": "@@ -115,6 +115,10 @@ impl<R: TreeRoot> SyntaxNode<R> {\n         })\n     }\n \n+    pub fn is_leaf(&self) -> bool {\n+        self.first_child().is_none()\n+    }\n+\n     fn red(&self) -> &RedNode {\n         unsafe { self.red.as_ref() }\n     }"}]}