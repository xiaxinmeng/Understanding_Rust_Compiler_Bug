{"sha": "16f778ad207650c0c9f4e049953f5dda2c48ec12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2Zjc3OGFkMjA3NjUwYzBjOWY0ZTA0OTk1M2Y1ZGRhMmM0OGVjMTI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-15T02:13:59Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-15T02:13:59Z"}, "message": "Rename next_block to block and reorganize Frame fields.", "tree": {"sha": "bef46fa81c2fdda365f856a2bbea34804c23e71e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bef46fa81c2fdda365f856a2bbea34804c23e71e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16f778ad207650c0c9f4e049953f5dda2c48ec12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16f778ad207650c0c9f4e049953f5dda2c48ec12", "html_url": "https://github.com/rust-lang/rust/commit/16f778ad207650c0c9f4e049953f5dda2c48ec12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16f778ad207650c0c9f4e049953f5dda2c48ec12/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "269f70007f28cf63aada3a6547f968ea68cb7040", "url": "https://api.github.com/repos/rust-lang/rust/commits/269f70007f28cf63aada3a6547f968ea68cb7040", "html_url": "https://github.com/rust-lang/rust/commit/269f70007f28cf63aada3a6547f968ea68cb7040"}], "stats": {"total": 57, "additions": 35, "deletions": 22}, "files": [{"sha": "2d6cf22d589585b6feacba0712bd8cea2b9e2468", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16f778ad207650c0c9f4e049953f5dda2c48ec12/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f778ad207650c0c9f4e049953f5dda2c48ec12/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=16f778ad207650c0c9f4e049953f5dda2c48ec12", "patch": "@@ -90,7 +90,7 @@ fn interpret_start_points<'a, 'tcx>(\n \n fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n     let frame = ecx.stack().last().expect(\"stackframe was empty\");\n-    let block = &frame.mir.basic_blocks()[frame.next_block];\n+    let block = &frame.mir.basic_blocks()[frame.block];\n     let span = if frame.stmt < block.statements.len() {\n         block.statements[frame.stmt].source_info.span\n     } else {"}, {"sha": "8b69fc6c2483c420a2e521756190ce7c88593de0", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/16f778ad207650c0c9f4e049953f5dda2c48ec12/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f778ad207650c0c9f4e049953f5dda2c48ec12/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=16f778ad207650c0c9f4e049953f5dda2c48ec12", "patch": "@@ -42,7 +42,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The virtual memory system.\n     memory: Memory<'tcx>,\n \n-    /// Precomputed statics, constants and promoteds\n+    /// Precomputed statics, constants and promoteds.\n     statics: HashMap<ConstantId<'tcx>, Pointer>,\n \n     /// The virtual call stack.\n@@ -51,20 +51,25 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n \n /// A stack frame.\n pub struct Frame<'a, 'tcx: 'a> {\n-    /// The def_id of the current function\n-    pub def_id: DefId,\n+    ////////////////////////////////////////////////////////////////////////////////\n+    // Function and callsite information\n+    ////////////////////////////////////////////////////////////////////////////////\n \n-    /// The span of the call site\n-    pub span: codemap::Span,\n+    /// The MIR for the function called on this frame.\n+    pub mir: CachedMir<'a, 'tcx>,\n+\n+    /// The def_id of the current function.\n+    pub def_id: DefId,\n \n-    /// type substitutions for the current function invocation\n+    /// type substitutions for the current function invocation.\n     pub substs: &'tcx Substs<'tcx>,\n \n-    /// The MIR for the function called on this frame.\n-    pub mir: CachedMir<'a, 'tcx>,\n+    /// The span of the call site.\n+    pub span: codemap::Span,\n \n-    /// The block that is currently executed (or will be executed after the above call stacks return)\n-    pub next_block: mir::BasicBlock,\n+    ////////////////////////////////////////////////////////////////////////////////\n+    // Return pointer and local allocations\n+    ////////////////////////////////////////////////////////////////////////////////\n \n     /// A pointer for writing the return value of the current call if it's not a diverging call.\n     pub return_ptr: Option<Pointer>,\n@@ -80,7 +85,15 @@ pub struct Frame<'a, 'tcx: 'a> {\n     /// The offset of the first temporary in `self.locals`.\n     pub temp_offset: usize,\n \n-    /// The index of the currently evaluated statment\n+    ////////////////////////////////////////////////////////////////////////////////\n+    // Current position within the function\n+    ////////////////////////////////////////////////////////////////////////////////\n+\n+    /// The block that is currently executed (or will be executed after the above call stacks\n+    /// return).\n+    pub block: mir::BasicBlock,\n+\n+    /// The index of the currently evaluated statment.\n     pub stmt: usize,\n }\n \n@@ -349,7 +362,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         self.stack.push(Frame {\n             mir: mir.clone(),\n-            next_block: mir::START_BLOCK,\n+            block: mir::START_BLOCK,\n             return_ptr: return_ptr,\n             locals: locals,\n             var_offset: num_args,\n@@ -374,13 +387,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Return => self.pop_stack_frame(),\n \n             Goto { target } => {\n-                self.frame_mut().next_block = target;\n+                self.frame_mut().block = target;\n             },\n \n             If { ref cond, targets: (then_target, else_target) } => {\n                 let cond_ptr = self.eval_operand(cond)?;\n                 let cond_val = self.memory.read_bool(cond_ptr)?;\n-                self.frame_mut().next_block = if cond_val { then_target } else { else_target };\n+                self.frame_mut().block = if cond_val { then_target } else { else_target };\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n@@ -403,7 +416,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n \n-                self.frame_mut().next_block = target_block;\n+                self.frame_mut().block = target_block;\n             }\n \n             Switch { ref discr, ref targets, adt_def } => {\n@@ -415,7 +428,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 match matching {\n                     Some(i) => {\n-                        self.frame_mut().next_block = targets[i];\n+                        self.frame_mut().block = targets[i];\n                     },\n                     None => return Err(EvalError::InvalidDiscriminant),\n                 }\n@@ -424,7 +437,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Call { ref func, ref args, ref destination, .. } => {\n                 let mut return_ptr = None;\n                 if let Some((ref lv, target)) = *destination {\n-                    self.frame_mut().next_block = target;\n+                    self.frame_mut().block = target;\n                     return_ptr = Some(self.eval_lvalue(lv)?.to_ptr());\n                 }\n \n@@ -451,14 +464,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.eval_lvalue(location)?.to_ptr();\n                 let ty = self.lvalue_ty(location);\n                 self.drop(ptr, ty)?;\n-                self.frame_mut().next_block = target;\n+                self.frame_mut().block = target;\n             }\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let actual_ptr = self.eval_operand(cond)?;\n                 let actual = self.memory.read_bool(actual_ptr)?;\n                 if actual == expected {\n-                    self.frame_mut().next_block = target;\n+                    self.frame_mut().block = target;\n                 } else {\n                     panic!(\"unimplemented: jump to {:?} and print {:?}\", cleanup, msg);\n                 }"}, {"sha": "e92ddd1faa2df97beb0b13ddd901c438e8acb458", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16f778ad207650c0c9f4e049953f5dda2c48ec12/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f778ad207650c0c9f4e049953f5dda2c48ec12/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=16f778ad207650c0c9f4e049953f5dda2c48ec12", "patch": "@@ -37,7 +37,7 @@ impl<'ecx, 'a, 'tcx> Stepper<'ecx, 'a, 'tcx> {\n         trace!(\"{:?}\", terminator.kind);\n         self.ecx.eval_terminator(terminator)?;\n         if !self.ecx.stack.is_empty() {\n-            trace!(\"// {:?}\", self.ecx.frame().next_block);\n+            trace!(\"// {:?}\", self.ecx.frame().block);\n         }\n         Ok(())\n     }\n@@ -48,7 +48,7 @@ impl<'ecx, 'a, 'tcx> Stepper<'ecx, 'a, 'tcx> {\n             return Ok(false);\n         }\n \n-        let block = self.ecx.frame().next_block;\n+        let block = self.ecx.frame().block;\n         let stmt = self.ecx.frame().stmt;\n         let mir = self.ecx.mir();\n         let basic_block = &mir.basic_blocks()[block];"}]}