{"sha": "f27272d60f193c6d27cc283f48c5be0e41562814", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNzI3MmQ2MGYxOTNjNmQyN2NjMjgzZjQ4YzViZTBlNDE1NjI4MTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-10-29T22:06:13Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-10-31T17:30:32Z"}, "message": "librustc: Implement `|A| -> B` syntax for closures and make bare `fn`\nwork", "tree": {"sha": "6647a01e6d2a80a05213cedf75b651d7accc9828", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6647a01e6d2a80a05213cedf75b651d7accc9828"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f27272d60f193c6d27cc283f48c5be0e41562814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f27272d60f193c6d27cc283f48c5be0e41562814", "html_url": "https://github.com/rust-lang/rust/commit/f27272d60f193c6d27cc283f48c5be0e41562814", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f27272d60f193c6d27cc283f48c5be0e41562814/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e976de32dc590f759e6c0c72d286844ca373e775", "url": "https://api.github.com/repos/rust-lang/rust/commits/e976de32dc590f759e6c0c72d286844ca373e775", "html_url": "https://github.com/rust-lang/rust/commit/e976de32dc590f759e6c0c72d286844ca373e775"}], "stats": {"total": 377, "additions": 320, "deletions": 57}, "files": [{"sha": "ab1ca420afab15b850f6ee0bf9353688864f7de6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -308,10 +308,11 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                       ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n                       -> ~str {\n-        let mut s = ~\"extern \";\n-\n-        s.push_str(abis.to_str());\n-        s.push_char(' ');\n+        let mut s = if abis.is_rust() {\n+            ~\"\"\n+        } else {\n+            format!(\"extern {} \", abis.to_str())\n+        };\n \n         match purity {\n             ast::impure_fn => {}\n@@ -331,16 +332,16 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n           _ => { }\n         }\n \n-        push_sig_to_str(cx, &mut s, sig);\n+        push_sig_to_str(cx, &mut s, '(', ')', sig);\n \n         return s;\n     }\n-    fn closure_to_str(cx: ctxt, cty: &ty::ClosureTy) -> ~str\n-    {\n+    fn closure_to_str(cx: ctxt, cty: &ty::ClosureTy) -> ~str {\n         let is_proc =\n             (cty.sigil, cty.onceness) == (ast::OwnedSigil, ast::Once);\n+        let is_borrowed_closure = cty.sigil == ast::BorrowedSigil;\n \n-        let mut s = if is_proc {\n+        let mut s = if is_proc || is_borrowed_closure {\n             ~\"\"\n         } else {\n             cty.sigil.to_str()\n@@ -374,23 +375,42 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                 }\n             };\n \n-            s.push_str(\"fn\");\n+            if !is_borrowed_closure {\n+                s.push_str(\"fn\");\n+            }\n         }\n \n-        if !cty.bounds.is_empty() {\n-            s.push_str(\":\");\n-        }\n-        s.push_str(cty.bounds.repr(cx));\n+        if !is_borrowed_closure {\n+            // Print bounds before `fn` if this is not a borrowed closure.\n+            if !cty.bounds.is_empty() {\n+                s.push_str(\":\");\n+                s.push_str(cty.bounds.repr(cx));\n+            }\n+\n+            push_sig_to_str(cx, &mut s, '(', ')', &cty.sig);\n+        } else {\n+            // Print bounds after the signature if this is a borrowed closure.\n+            push_sig_to_str(cx, &mut s, '|', '|', &cty.sig);\n \n-        push_sig_to_str(cx, &mut s, &cty.sig);\n+            if is_borrowed_closure {\n+                if !cty.bounds.is_empty() {\n+                    s.push_str(\":\");\n+                    s.push_str(cty.bounds.repr(cx));\n+                }\n+            }\n+        }\n \n         return s;\n     }\n-    fn push_sig_to_str(cx: ctxt, s: &mut ~str, sig: &ty::FnSig) {\n-        s.push_char('(');\n+    fn push_sig_to_str(cx: ctxt,\n+                       s: &mut ~str,\n+                       bra: char,\n+                       ket: char,\n+                       sig: &ty::FnSig) {\n+        s.push_char(bra);\n         let strs = sig.inputs.map(|a| fn_input_to_str(cx, *a));\n         s.push_str(strs.connect(\", \"));\n-        s.push_char(')');\n+        s.push_char(ket);\n         if ty::get(sig.output).sty != ty_nil {\n             s.push_str(\" -> \");\n             if ty::type_is_bot(sig.output) {"}, {"sha": "56254704e28d566fb7c37eccfb36267468747c59", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 155, "deletions": 31, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -561,6 +561,45 @@ impl Parser {\n         }\n     }\n \n+    // Expect and consume a `|`. If `||` is seen, replace it with a single\n+    // `|` and continue. If a `|` is not seen, signal an error.\n+    fn expect_or(&self) {\n+        match *self.token {\n+            token::BINOP(token::OR) => self.bump(),\n+            token::OROR => {\n+                self.replace_token(token::BINOP(token::OR),\n+                                   self.span.lo + BytePos(1),\n+                                   self.span.hi)\n+            }\n+            _ => {\n+                let found_token = self.token_to_str(&token::BINOP(token::OR));\n+                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                                   found_token,\n+                                   self.this_token_to_str()))\n+            }\n+        }\n+    }\n+\n+    // Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n+    fn parse_seq_to_before_or<T>(&self,\n+                                 sep: &token::Token,\n+                                 f: &fn(&Parser) -> T)\n+                                 -> ~[T] {\n+        let mut first = true;\n+        let mut vector = ~[];\n+        while *self.token != token::BINOP(token::OR) &&\n+                *self.token != token::OROR {\n+            if first {\n+                first = false\n+            } else {\n+                self.expect(sep)\n+            }\n+\n+            vector.push(f(self))\n+        }\n+        vector\n+    }\n+\n     // expect and consume a GT. if a >> is seen, replace it\n     // with a single > and continue. If a GT is not seen,\n     // signal an error.\n@@ -761,11 +800,33 @@ impl Parser {\n         get_ident_interner().get(id.name)\n     }\n \n-    // is this one of the keywords that signals a closure type?\n-    pub fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n-        token::is_keyword(keywords::Unsafe, tok) ||\n-            token::is_keyword(keywords::Once, tok) ||\n-            token::is_keyword(keywords::Fn, tok)\n+    // Is the current token one of the keywords that signals a bare function\n+    // type?\n+    pub fn token_is_bare_fn_keyword(&self) -> bool {\n+        if token::is_keyword(keywords::Fn, self.token) {\n+            return true\n+        }\n+\n+        if token::is_keyword(keywords::Unsafe, self.token) ||\n+            token::is_keyword(keywords::Once, self.token) {\n+            return self.look_ahead(1, |t| token::is_keyword(keywords::Fn, t))\n+        }\n+\n+        false\n+    }\n+\n+    // Is the current token one of the keywords that signals a closure type?\n+    pub fn token_is_closure_keyword(&self) -> bool {\n+        token::is_keyword(keywords::Unsafe, self.token) ||\n+            token::is_keyword(keywords::Once, self.token)\n+    }\n+\n+    // Is the current token one of the keywords that signals an old-style\n+    // closure type (with explicit sigil)?\n+    pub fn token_is_old_style_closure_keyword(&self) -> bool {\n+        token::is_keyword(keywords::Unsafe, self.token) ||\n+            token::is_keyword(keywords::Once, self.token) ||\n+            token::is_keyword(keywords::Fn, self.token)\n     }\n \n     pub fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n@@ -786,15 +847,15 @@ impl Parser {\n     pub fn parse_ty_bare_fn(&self) -> ty_ {\n         /*\n \n-        extern \"ABI\" [unsafe] fn <'lt> (S) -> T\n-               ^~~~^ ^~~~~~~^    ^~~~^ ^~^    ^\n-                 |     |           |    |     |\n-                 |     |           |    |   Return type\n-                 |     |           |  Argument types\n-                 |     |       Lifetimes\n-                 |     |\n-                 |   Purity\n-                ABI\n+        [extern \"ABI\"] [unsafe] fn <'lt> (S) -> T\n+                ^~~~^  ^~~~~~~^    ^~~~^ ^~^    ^\n+                  |      |           |    |     |\n+                  |      |           |    |   Return type\n+                  |      |           |  Argument types\n+                  |      |       Lifetimes\n+                  |      |\n+                  |    Purity\n+                 ABI\n \n         */\n \n@@ -828,8 +889,8 @@ impl Parser {\n \n     // parse a ty_closure type\n     pub fn parse_ty_closure(&self,\n-                            sigil: ast::Sigil,\n-                            region: Option<ast::Lifetime>)\n+                            opt_sigil: Option<ast::Sigil>,\n+                            mut region: Option<ast::Lifetime>)\n                             -> ty_ {\n         /*\n \n@@ -852,10 +913,58 @@ impl Parser {\n \n         let purity = self.parse_unsafety();\n         let onceness = parse_onceness(self);\n-        self.expect_keyword(keywords::Fn);\n-        let bounds = self.parse_optional_ty_param_bounds();\n \n-        let (decl, lifetimes) = self.parse_ty_fn_decl();\n+        let (sigil, decl, lifetimes, bounds) = match opt_sigil {\n+            Some(sigil) => {\n+                // Old-style closure syntax (`fn(A)->B`).\n+                self.expect_keyword(keywords::Fn);\n+                let bounds = self.parse_optional_ty_param_bounds();\n+                let (decl, lifetimes) = self.parse_ty_fn_decl();\n+                (sigil, decl, lifetimes, bounds)\n+            }\n+            None => {\n+                // New-style closure syntax (`<'lt>|A|:K -> B`).\n+                let lifetimes = if self.eat(&token::LT) {\n+                    let lifetimes = self.parse_lifetimes();\n+                    self.expect_gt();\n+\n+                    // Re-parse the region here. What a hack.\n+                    if region.is_some() {\n+                        self.span_err(*self.last_span,\n+                                      \"lifetime declarations must precede \\\n+                                       the lifetime associated with a \\\n+                                       closure\");\n+                    }\n+                    region = self.parse_opt_lifetime();\n+\n+                    lifetimes\n+                } else {\n+                    opt_vec::Empty\n+                };\n+\n+                let inputs = if self.eat(&token::OROR) {\n+                    ~[]\n+                } else {\n+                    self.expect_or();\n+                    let inputs = self.parse_seq_to_before_or(\n+                        &token::COMMA,\n+                        |p| p.parse_arg_general(false));\n+                    self.expect_or();\n+                    inputs\n+                };\n+\n+                let bounds = self.parse_optional_ty_param_bounds();\n+\n+                let (return_style, output) = self.parse_ret_ty();\n+                let decl = ast::fn_decl {\n+                    inputs: inputs,\n+                    output: output,\n+                    cf: return_style,\n+                };\n+\n+                (BorrowedSigil, decl, lifetimes, bounds)\n+            }\n+        };\n \n         return ty_closure(@TyClosure {\n             sigil: sigil,\n@@ -1120,13 +1229,23 @@ impl Parser {\n             // BORROWED POINTER\n             self.bump();\n             self.parse_borrowed_pointee()\n-        } else if self.eat_keyword(keywords::Extern) {\n-            // EXTERN FUNCTION\n+        } else if self.is_keyword(keywords::Extern) ||\n+                self.token_is_bare_fn_keyword() {\n+            // BARE FUNCTION\n             self.parse_ty_bare_fn()\n-        } else if self.token_is_closure_keyword(self.token) {\n+        } else if self.token_is_closure_keyword() ||\n+                *self.token == token::BINOP(token::OR) ||\n+                *self.token == token::OROR ||\n+                *self.token == token::LT ||\n+                self.token_is_lifetime(self.token) {\n             // CLOSURE\n-            let result = self.parse_ty_closure(ast::BorrowedSigil, None);\n-            self.obsolete(*self.last_span, ObsoleteBareFnType);\n+            //\n+            // XXX(pcwalton): Eventually `token::LT` will not unambiguously\n+            // introduce a closure, once procs can have lifetime bounds. We\n+            // will need to refactor the grammar a little bit at that point.\n+\n+            let lifetime = self.parse_opt_lifetime();\n+            let result = self.parse_ty_closure(None, lifetime);\n             result\n         } else if self.eat_keyword(keywords::Typeof) {\n             // TYPEOF\n@@ -1161,12 +1280,12 @@ impl Parser {\n         match *self.token {\n             token::LIFETIME(*) => {\n                 let lifetime = self.parse_lifetime();\n-                return self.parse_ty_closure(sigil, Some(lifetime));\n+                return self.parse_ty_closure(Some(sigil), Some(lifetime));\n             }\n \n             token::IDENT(*) => {\n-                if self.token_is_closure_keyword(self.token) {\n-                    return self.parse_ty_closure(sigil, None);\n+                if self.token_is_old_style_closure_keyword() {\n+                    return self.parse_ty_closure(Some(sigil), None);\n                 }\n             }\n             _ => {}\n@@ -1187,8 +1306,8 @@ impl Parser {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();\n \n-        if self.token_is_closure_keyword(self.token) {\n-            return self.parse_ty_closure(BorrowedSigil, opt_lifetime);\n+        if self.token_is_old_style_closure_keyword() {\n+            return self.parse_ty_closure(Some(BorrowedSigil), opt_lifetime);\n         }\n \n         let mt = self.parse_mt();\n@@ -4390,8 +4509,13 @@ impl Parser {\n         }\n     }\n \n-    // parse a string as an ABI spec on an extern type or module\n+    // Parses a string as an ABI spec on an extern type or module. Consumes\n+    // the `extern` keyword, if one is found.\n     fn parse_opt_abis(&self) -> Option<AbiSet> {\n+        if !self.eat_keyword(keywords::Extern) {\n+            return None\n+        }\n+\n         match *self.token {\n             token::LIT_STR(s)\n             | token::LIT_STR_RAW(s, _) => {\n@@ -4467,7 +4591,7 @@ impl Parser {\n             });\n         }\n         // either a view item or an item:\n-        if self.eat_keyword(keywords::Extern) {\n+        if self.is_keyword(keywords::Extern) {\n             let opt_abis = self.parse_opt_abis();\n \n             if self.eat_keyword(keywords::Fn) {"}, {"sha": "0eb1045efe95fd1464816db9d680e65b4f52da9d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -2015,20 +2015,39 @@ pub fn print_ty_fn(s: @ps,\n     // function prints the sigil in the wrong place.  That should be fixed.\n     if opt_sigil == Some(ast::OwnedSigil) && onceness == ast::Once {\n         word(s.s, \"proc\");\n-    } else {\n+    } else if opt_sigil == Some(ast::BorrowedSigil) {\n         print_extern_opt_abis(s, opt_abis);\n+        for lifetime in opt_region.iter() {\n+            print_lifetime(s, lifetime);\n+        }\n+        print_purity(s, purity);\n+        print_onceness(s, onceness);\n+    } else {\n+        print_opt_abis_and_extern_if_nondefault(s, opt_abis);\n         print_opt_sigil(s, opt_sigil);\n         print_opt_lifetime(s, opt_region);\n         print_purity(s, purity);\n         print_onceness(s, onceness);\n         word(s.s, \"fn\");\n     }\n+\n     match id { Some(id) => { word(s.s, \" \"); print_ident(s, id); } _ => () }\n-    do opt_bounds.as_ref().map |bounds| { print_bounds(s, bounds, true); };\n+\n+    if opt_sigil != Some(ast::BorrowedSigil) {\n+        do opt_bounds.as_ref().map |bounds| {\n+            print_bounds(s, bounds, true);\n+        };\n+    }\n+\n     match generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n \n-    popen(s);\n+    if opt_sigil == Some(ast::BorrowedSigil) {\n+        word(s.s, \"|\");\n+    } else {\n+        popen(s);\n+    }\n+\n     // It is unfortunate to duplicate the commasep logic, but we want the\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n@@ -2041,7 +2060,14 @@ pub fn print_ty_fn(s: @ps,\n         print_arg(s, arg);\n     }\n     end(s);\n-    pclose(s);\n+\n+    if opt_sigil == Some(ast::BorrowedSigil) {\n+        word(s.s, \"|\");\n+\n+        opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n+    } else {\n+        pclose(s);\n+    }\n \n     maybe_print_comment(s, decl.output.span.lo);\n \n@@ -2274,6 +2300,17 @@ pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n     }\n }\n \n+pub fn print_opt_abis_and_extern_if_nondefault(s: @ps,\n+                                               opt_abis: Option<AbiSet>) {\n+    match opt_abis {\n+        Some(abis) if !abis.is_rust() => {\n+            word_nbsp(s, \"extern\");\n+            word_nbsp(s, abis.to_str());\n+        }\n+        Some(_) | None => {}\n+    };\n+}\n+\n pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n     match opt_abis {\n         Some(abis) => {"}, {"sha": "3e38ce9ab358bef650dce605e5f8ea43dcfefdf5", "filename": "src/test/compile-fail/block-coerce-no-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -19,5 +19,5 @@ fn main() {\n     }\n \n     f(g);\n-    //~^ ERROR mismatched types: expected `extern \"Rust\" fn(extern \"Rust\" fn(extern \"Rust\" fn()))`\n+    //~^ ERROR mismatched types: expected `fn(fn(fn()))`\n }"}, {"sha": "3da709942e0e65724cb0f115914dbc999194a9cd", "filename": "src/test/compile-fail/closure-reform-bad.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -0,0 +1,13 @@\n+/* Any copyright is dedicated to the Public Domain.\n+ * http://creativecommons.org/publicdomain/zero/1.0/ */\n+\n+fn call_bare(f: fn(&str)) {\n+    f(\"Hello \");\n+}\n+\n+fn main() {\n+    let string = \"world!\";\n+    let f: |&str| = |s| println(s + string);\n+    call_bare(f)    //~ ERROR mismatched types\n+}\n+"}, {"sha": "5169652a6c06940c2351525c7c5af988638989d3", "filename": "src/test/pretty/closure-reform-pretty.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -0,0 +1,17 @@\n+// Any copyright is dedicated to the Public Domain.\n+// http://creativecommons.org/publicdomain/zero/1.0/\n+\n+// pp-exact\n+\n+fn call_it(f: proc(~str) -> ~str) { }\n+\n+fn call_this(f: |&str|: Send) { }\n+\n+fn call_that(f: <'a>|&'a int, &'a int|: -> int) { }\n+\n+fn call_extern(f: fn() -> int) { }\n+\n+fn call_abid_extern(f: extern \"C\" fn() -> int) { }\n+\n+pub fn main() { }\n+"}, {"sha": "d3d6f1c0e355b09f1b3309961422bdd68b77f031", "filename": "src/test/pretty/disamb-stmt-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -14,7 +14,7 @@\n // preserved.  They are needed to disambiguate `{return n+1}; - 0` from\n // `({return n+1}-0)`.\n \n-fn id(f: &fn() -> int) -> int { f() }\n+fn id(f: || -> int) -> int { f() }\n \n fn wsucc(_n: int) -> int { (do id || { 1 }) - 0 }\n fn main() { }"}, {"sha": "1fb2359da53acc16a8a4a84f9cde49de9d85ac19", "filename": "src/test/pretty/do1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fpretty%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fpretty%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdo1.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -10,6 +10,6 @@\n \n // pp-exact\n \n-fn f(f: &fn(int)) { f(10) }\n+fn f(f: |int|) { f(10) }\n \n fn main() { do f |i| { assert!(i == 10) } }"}, {"sha": "27e56fb6074a1a6d62583e3853994e7a24c26dd4", "filename": "src/test/pretty/fn-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fpretty%2Ffn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Fpretty%2Ffn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffn-types.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -10,7 +10,7 @@\n \n // pp-exact\n \n-fn from_foreign_fn(_x: extern \"Rust\" fn()) { }\n-fn from_stack_closure(_x: &fn()) { }\n+fn from_foreign_fn(_x: fn()) { }\n+fn from_stack_closure(_x: ||) { }\n fn from_unique_closure(_x: ~fn()) { }\n fn main() { }"}, {"sha": "18ca64d0f2762c94519eb4da484b91e002584c2d", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -1,11 +1,42 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n+use std::cast;\n+\n fn call_it(f: proc(~str) -> ~str) {\n     println(f(~\"Fred\"))\n }\n \n+fn call_a_thunk(f: ||) {\n+    f();\n+}\n+\n+fn call_this(f: |&str|:Send) {\n+    f(\"Hello!\");\n+}\n+\n+fn call_that(f: <'a>|&'a int, &'a int|: -> int) {\n+    let (ten, forty_two) = (10, 42);\n+    println!(\"Your lucky number is {}\", f(&ten, &forty_two));\n+}\n+\n+fn call_cramped(f:||->uint,g:<'a>||->&'a uint) {\n+    let number = f();\n+    let other_number = *g();\n+    println!(\"Ticket {} wins an all-expenses-paid trip to Mountain View\", number + other_number);\n+}\n+\n+fn call_bare(f: fn(&str)) {\n+    f(\"Hello world!\")\n+}\n+\n+fn call_bare_again(f: extern \"Rust\" fn(&str)) {\n+    f(\"Goodbye world!\")\n+}\n+\n pub fn main() {\n+    // Procs\n+\n     let greeting = ~\"Hi \";\n     do call_it |s| {\n         greeting + s\n@@ -23,5 +54,26 @@ pub fn main() {\n     call_it(proc(s: ~str) -> ~str {\n         greeting + s\n     });\n+\n+    // Closures\n+\n+    call_a_thunk(|| println(\"Hello world!\"));\n+\n+    call_this(|s| println(s));\n+\n+    call_that(|x, y| *x + *y);\n+\n+    let z = 100;\n+    call_that(|x, y| *x + *y - z);\n+\n+    call_cramped(|| 1, || unsafe {\n+        cast::transmute(&100)\n+    });\n+\n+    // External functions\n+\n+    call_bare(println);\n+\n+    call_bare_again(println);\n }\n "}]}