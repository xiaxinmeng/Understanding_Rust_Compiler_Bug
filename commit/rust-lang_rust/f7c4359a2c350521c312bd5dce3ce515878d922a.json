{"sha": "f7c4359a2c350521c312bd5dce3ce515878d922a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YzQzNTlhMmMzNTA1MjFjMzEyYmQ1ZGNlM2NlNTE1ODc4ZDkyMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-04T14:10:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-04T14:10:56Z"}, "message": "auto merge of #8237 : blake2-ppc/rust/faster-utf8, r=brson\n\nUse unchecked vec indexing since the vector bounds are checked by the\r\nloop. Iterators are not easy to use in this case since we skip 1-4 bytes\r\neach lap. This part of the commit speeds up is_utf8 for ASCII input.\r\n\r\nCheck codepoint ranges by checking the byte ranges manually instead of\r\ncomputing a full decoding for multibyte encodings. This is easy to read\r\nand corresponds to the UTF-8 syntax in the RFC.\r\n\r\nNo changes to what we accept. A comment notes that surrogate halves are\r\naccepted.\r\n\r\nBefore:\r\n\r\n\ttest str::bench::is_utf8_100_ascii ... bench: 165 ns/iter (+/- 3)\r\n\ttest str::bench::is_utf8_100_multibyte ... bench: 218 ns/iter (+/- 5)\r\n\r\nAfter:\r\n\ttest str::bench::is_utf8_100_ascii ... bench: 130 ns/iter (+/- 1)\r\n\ttest str::bench::is_utf8_100_multibyte ... bench: 156 ns/iter (+/- 3)\r\n\r\nAn improvement upon the previous pull #8133", "tree": {"sha": "e42481e6e166a20dd151cb5fdfe3086be959def9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e42481e6e166a20dd151cb5fdfe3086be959def9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7c4359a2c350521c312bd5dce3ce515878d922a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c4359a2c350521c312bd5dce3ce515878d922a", "html_url": "https://github.com/rust-lang/rust/commit/f7c4359a2c350521c312bd5dce3ce515878d922a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7c4359a2c350521c312bd5dce3ce515878d922a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cf69d5bf8fa6424eca5b1589e90db5a19f16330", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf69d5bf8fa6424eca5b1589e90db5a19f16330", "html_url": "https://github.com/rust-lang/rust/commit/5cf69d5bf8fa6424eca5b1589e90db5a19f16330"}, {"sha": "0504d7e57bf536dabbb738b5b0d268a266d30659", "url": "https://api.github.com/repos/rust-lang/rust/commits/0504d7e57bf536dabbb738b5b0d268a266d30659", "html_url": "https://github.com/rust-lang/rust/commit/0504d7e57bf536dabbb738b5b0d268a266d30659"}], "stats": {"total": 102, "additions": 67, "deletions": 35}, "files": [{"sha": "5c6895fea43c956e435948ed333596e6f57af8b2", "filename": "src/libstd/str.rs", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f7c4359a2c350521c312bd5dce3ce515878d922a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c4359a2c350521c312bd5dce3ce515878d922a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f7c4359a2c350521c312bd5dce3ce515878d922a", "patch": "@@ -564,51 +564,63 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n Section: Misc\n */\n \n-// Return the initial codepoint accumulator for the first byte.\n-// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-// for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte(\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as uint)\n-)\n-\n-// return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte(\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n-)\n-\n /// Determines if a vector of bytes contains valid UTF-8\n pub fn is_utf8(v: &[u8]) -> bool {\n     let mut i = 0u;\n     let total = v.len();\n+    fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n+        unsafe { *xs.unsafe_ref(i) }\n+    }\n     while i < total {\n-        if v[i] < 128u8 {\n+        let v_i = unsafe_get(v, i);\n+        if v_i < 128u8 {\n             i += 1u;\n         } else {\n-            let w = utf8_char_width(v[i]);\n+            let w = utf8_char_width(v_i);\n             if w == 0u { return false; }\n \n             let nexti = i + w;\n             if nexti > total { return false; }\n-            // 1. Make sure the correct number of continuation bytes are present\n-            // 2. Check codepoint ranges (deny overlong encodings)\n-            //    2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n-            //    3-byte encoding is for codepoints  \\u0800 to  \\uffff\n-            //    4-byte encoding is for codepoints \\u10000 to \\u10ffff\n-\n-            //    2-byte encodings are correct if the width and continuation match up\n-            if v[i + 1] & 192u8 != TAG_CONT_U8 { return false; }\n-            if w > 2 {\n-                let mut ch;\n-                ch = utf8_first_byte!(v[i], w);\n-                ch = utf8_acc_cont_byte!(ch, v[i + 1]);\n-                if v[i + 2] & 192u8 != TAG_CONT_U8 { return false; }\n-                ch = utf8_acc_cont_byte!(ch, v[i + 2]);\n-                if w == 3 && ch < MAX_TWO_B { return false; }\n-                if w > 3 {\n-                    if v[i + 3] & 192u8 != TAG_CONT_U8 { return false; }\n-                    ch = utf8_acc_cont_byte!(ch, v[i + 3]);\n-                    if ch < MAX_THREE_B || ch >= MAX_UNICODE { return false; }\n-                }\n+\n+            // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n+            //        first  C2 80        last DF BF\n+            // 3-byte encoding is for codepoints  \\u0800 to  \\uffff\n+            //        first  E0 A0 80     last EF BF BF\n+            // 4-byte encoding is for codepoints \\u10000 to \\u10ffff\n+            //        first  F0 90 80 80  last F4 8F BF BF\n+            //\n+            // Use the UTF-8 syntax from the RFC\n+            //\n+            // https://tools.ietf.org/html/rfc3629\n+            // UTF8-1      = %x00-7F\n+            // UTF8-2      = %xC2-DF UTF8-tail\n+            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n+            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n+            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n+            //               %xF4 %x80-8F 2( UTF8-tail )\n+            // UTF8-tail   = %x80-BF\n+            // --\n+            // This code allows surrogate pairs: \\uD800 to \\uDFFF -> ED A0 80 to ED BF BF\n+            match w {\n+                2 => if unsafe_get(v, i + 1) & 192u8 != TAG_CONT_U8 {\n+                    return false\n+                },\n+                3 => match (v_i,\n+                            unsafe_get(v, i + 1),\n+                            unsafe_get(v, i + 2) & 192u8) {\n+                    (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) => (),\n+                    (0xE1 .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => (),\n+                    _ => return false,\n+                },\n+                _ => match (v_i,\n+                            unsafe_get(v, i + 1),\n+                            unsafe_get(v, i + 2) & 192u8,\n+                            unsafe_get(v, i + 3) & 192u8) {\n+                    (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n+                    (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n+                    (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => (),\n+                    _ => return false,\n+                },\n             }\n \n             i = nexti;\n@@ -756,6 +768,18 @@ pub struct CharRange {\n     next: uint\n }\n \n+// Return the initial codepoint accumulator for the first byte.\n+// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+// for width 3, and 3 bits for width 4\n+macro_rules! utf8_first_byte(\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as uint)\n+)\n+\n+// return the value of $ch updated with continuation byte $byte\n+macro_rules! utf8_acc_cont_byte(\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n+)\n+\n // UTF-8 tags and ranges\n priv static TAG_CONT_U8: u8 = 128u8;\n priv static TAG_CONT: uint = 128u;\n@@ -2845,13 +2869,21 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_is_utf8_deny_overlong() {\n+    fn test_is_utf8() {\n         assert!(!is_utf8([0xc0, 0x80]));\n         assert!(!is_utf8([0xc0, 0xae]));\n         assert!(!is_utf8([0xe0, 0x80, 0x80]));\n         assert!(!is_utf8([0xe0, 0x80, 0xaf]));\n         assert!(!is_utf8([0xe0, 0x81, 0x81]));\n         assert!(!is_utf8([0xf0, 0x82, 0x82, 0xac]));\n+        assert!(!is_utf8([0xf4, 0x90, 0x80, 0x80]));\n+\n+        assert!(is_utf8([0xC2, 0x80]));\n+        assert!(is_utf8([0xDF, 0xBF]));\n+        assert!(is_utf8([0xE0, 0xA0, 0x80]));\n+        assert!(is_utf8([0xEF, 0xBF, 0xBF]));\n+        assert!(is_utf8([0xF0, 0x90, 0x80, 0x80]));\n+        assert!(is_utf8([0xF4, 0x8F, 0xBF, 0xBF]));\n     }\n \n "}]}