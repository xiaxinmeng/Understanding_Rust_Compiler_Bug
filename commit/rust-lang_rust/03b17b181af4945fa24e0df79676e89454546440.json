{"sha": "03b17b181af4945fa24e0df79676e89454546440", "node_id": "C_kwDOAAsO6NoAKDAzYjE3YjE4MWFmNDk0NWZhMjRlMGRmNzk2NzZlODk0NTQ1NDY0NDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-08T06:34:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-08T06:34:18Z"}, "message": "Auto merge of #93762 - matthiaskrgr:rollup-vdjpfmz, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #86497 (Add {floor,ceil}_char_boundary methods to str)\n - #92695 (Add `#[no_coverage]` tests for nested functions)\n - #93521 (Fix hover effects in sidebar)\n - #93568 (Include all contents of first line of scraped item in Rustdoc)\n - #93569 (rustdoc: correct unclosed HTML tags as generics)\n - #93672 (update comment wrt const param defaults)\n - #93715 (Fix horizontal trim for block doc comments)\n - #93721 (rustdoc: Special-case macro lookups less)\n - #93728 (Add in ValuePair::Term)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1bbcda7840eb78db9ff11ab6efcb3e05844e242f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bbcda7840eb78db9ff11ab6efcb3e05844e242f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b17b181af4945fa24e0df79676e89454546440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b17b181af4945fa24e0df79676e89454546440", "html_url": "https://github.com/rust-lang/rust/commit/03b17b181af4945fa24e0df79676e89454546440", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b17b181af4945fa24e0df79676e89454546440/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a8dbdb1e2d9f44e7971d9a70b41d4d86db0112f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a8dbdb1e2d9f44e7971d9a70b41d4d86db0112f", "html_url": "https://github.com/rust-lang/rust/commit/2a8dbdb1e2d9f44e7971d9a70b41d4d86db0112f"}, {"sha": "25ce315c7604e6617bd8b5868b45c9a3bd4867af", "url": "https://api.github.com/repos/rust-lang/rust/commits/25ce315c7604e6617bd8b5868b45c9a3bd4867af", "html_url": "https://github.com/rust-lang/rust/commit/25ce315c7604e6617bd8b5868b45c9a3bd4867af"}], "stats": {"total": 924, "additions": 748, "deletions": 176}, "files": [{"sha": "f51b0086dc8b6d6be5b784c677f93c067505428c", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -43,15 +43,16 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         if i != 0 || j != lines.len() { Some((i, j)) } else { None }\n     }\n \n-    fn get_horizontal_trim(lines: &[&str], kind: CommentKind) -> Option<usize> {\n+    fn get_horizontal_trim<'a>(lines: &'a [&str], kind: CommentKind) -> Option<String> {\n         let mut i = usize::MAX;\n         let mut first = true;\n \n         // In case we have doc comments like `/**` or `/*!`, we want to remove stars if they are\n         // present. However, we first need to strip the empty lines so they don't get in the middle\n         // when we try to compute the \"horizontal trim\".\n         let lines = if kind == CommentKind::Block {\n-            let mut i = 0;\n+            // Whatever happens, we skip the first line.\n+            let mut i = if lines[0].trim_start().starts_with('*') { 0 } else { 1 };\n             let mut j = lines.len();\n \n             while i < j && lines[i].trim().is_empty() {\n@@ -84,7 +85,7 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n                 return None;\n             }\n         }\n-        Some(i)\n+        if lines.is_empty() { None } else { Some(lines[0][..i].into()) }\n     }\n \n     let data_s = data.as_str();\n@@ -102,8 +103,13 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n             changes = true;\n             // remove a \"[ \\t]*\\*\" block from each line, if possible\n             for line in lines.iter_mut() {\n-                if horizontal + 1 < line.len() {\n-                    *line = &line[horizontal + 1..];\n+                if let Some(tmp) = line.strip_prefix(&horizontal) {\n+                    *line = tmp;\n+                    if kind == CommentKind::Block\n+                        && (*line == \"*\" || line.starts_with(\"* \") || line.starts_with(\"**\"))\n+                    {\n+                        *line = &line[1..];\n+                    }\n                 }\n             }\n         }"}, {"sha": "11d50603a1011fb84f483c82731bce45664789d8", "filename": "compiler/rustc_ast/src/util/comments/tests.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -24,7 +24,7 @@ fn test_block_doc_comment_3() {\n     create_default_session_globals_then(|| {\n         let comment = \"\\n let a: *i32;\\n *a = 5;\\n\";\n         let stripped = beautify_doc_string(Symbol::intern(comment), CommentKind::Block);\n-        assert_eq!(stripped.as_str(), \" let a: *i32;\\n *a = 5;\");\n+        assert_eq!(stripped.as_str(), \"let a: *i32;\\n*a = 5;\");\n     })\n }\n \n@@ -41,3 +41,21 @@ fn test_line_doc_comment() {\n         assert_eq!(stripped.as_str(), \"!test\");\n     })\n }\n+\n+#[test]\n+fn test_doc_blocks() {\n+    create_default_session_globals_then(|| {\n+        let stripped =\n+            beautify_doc_string(Symbol::intern(\" # Returns\\n     *\\n     \"), CommentKind::Block);\n+        assert_eq!(stripped.as_str(), \" # Returns\\n\\n\");\n+\n+        let stripped = beautify_doc_string(\n+            Symbol::intern(\"\\n     * # Returns\\n     *\\n     \"),\n+            CommentKind::Block,\n+        );\n+        assert_eq!(stripped.as_str(), \" # Returns\\n\\n\");\n+\n+        let stripped = beautify_doc_string(Symbol::intern(\"\\n *     a\\n \"), CommentKind::Block);\n+        assert_eq!(stripped.as_str(), \"     a\\n\");\n+    })\n+}"}, {"sha": "0ca7988ca152f6c48059a6c494fec820493bb688", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -134,7 +134,7 @@ fn inject_impl_of_structural_trait(\n \n     // Create the type of `self`.\n     //\n-    // in addition, remove defaults from type params (impls cannot have them).\n+    // in addition, remove defaults from generic params (impls cannot have them).\n     let self_params: Vec<_> = generics\n         .params\n         .iter_mut()"}, {"sha": "6515f948dd3bc873ff8e446a14c33eeda6c94489", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -268,7 +268,10 @@ impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n-        TypeTrace { cause: cause.clone(), values: Types(ExpectedFound::new(a_is_expected, a, b)) }\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Terms(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+        }\n     }\n }\n \n@@ -292,27 +295,22 @@ impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n-        TypeTrace { cause: cause.clone(), values: Consts(ExpectedFound::new(a_is_expected, a, b)) }\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Terms(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+        }\n     }\n }\n \n impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n     fn to_trace(\n-        tcx: TyCtxt<'tcx>,\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n-        match (a, b) {\n-            (ty::Term::Ty(a), ty::Term::Ty(b)) => {\n-                ToTrace::to_trace(tcx, cause, a_is_expected, a, b)\n-            }\n-            (ty::Term::Const(a), ty::Term::Const(b)) => {\n-                ToTrace::to_trace(tcx, cause, a_is_expected, a, b)\n-            }\n-            (_, _) => todo!(),\n-        }\n+        TypeTrace { cause: cause.clone(), values: Terms(ExpectedFound::new(a_is_expected, a, b)) }\n     }\n }\n \n@@ -358,7 +356,7 @@ impl<'tcx> ToTrace<'tcx> for ty::ProjectionTy<'tcx> {\n         let b_ty = tcx.mk_projection(b.item_def_id, b.substs);\n         TypeTrace {\n             cause: cause.clone(),\n-            values: Types(ExpectedFound::new(a_is_expected, a_ty, b_ty)),\n+            values: Terms(ExpectedFound::new(a_is_expected, a_ty.into(), b_ty.into())),\n         }\n     }\n }"}, {"sha": "6fdfc8e39f10dd4eea6027b111f824400b0c0808", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -1582,18 +1582,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             None => (None, Mismatch::Fixed(\"type\"), false),\n             Some(values) => {\n                 let (is_simple_error, exp_found) = match values {\n-                    ValuePairs::Types(exp_found) => {\n-                        let is_simple_err =\n-                            exp_found.expected.is_simple_text() && exp_found.found.is_simple_text();\n-                        OpaqueTypesVisitor::visit_expected_found(\n-                            self.tcx,\n-                            exp_found.expected,\n-                            exp_found.found,\n-                            span,\n-                        )\n-                        .report(diag);\n+                    ValuePairs::Terms(infer::ExpectedFound {\n+                        expected: ty::Term::Ty(expected),\n+                        found: ty::Term::Ty(found),\n+                    }) => {\n+                        let is_simple_err = expected.is_simple_text() && found.is_simple_text();\n+                        OpaqueTypesVisitor::visit_expected_found(self.tcx, expected, found, span)\n+                            .report(diag);\n \n-                        (is_simple_err, Mismatch::Variable(exp_found))\n+                        (\n+                            is_simple_err,\n+                            Mismatch::Variable(infer::ExpectedFound { expected, found }),\n+                        )\n                     }\n                     ValuePairs::TraitRefs(_) => (false, Mismatch::Fixed(\"trait\")),\n                     _ => (false, Mismatch::Fixed(\"type\")),\n@@ -1624,7 +1624,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 };\n                 if let Some((sp, msg)) = secondary_span {\n                     if swap_secondary_and_primary {\n-                        let terr = if let Some(infer::ValuePairs::Types(infer::ExpectedFound {\n+                        let terr = if let Some(infer::ValuePairs::Terms(infer::ExpectedFound {\n                             expected,\n                             ..\n                         })) = values\n@@ -2036,9 +2036,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             FailureCode::Error0308(failure_str) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str);\n-                if let ValuePairs::Types(ty::error::ExpectedFound { expected, found }) =\n-                    trace.values\n-                {\n+                if let Some((expected, found)) = trace.values.ty() {\n                     match (expected.kind(), found.kind()) {\n                         (ty::Tuple(_), ty::Tuple(_)) => {}\n                         // If a tuple of length one was expected and the found expression has\n@@ -2148,9 +2146,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         values: ValuePairs<'tcx>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         match values {\n-            infer::Types(exp_found) => self.expected_found_str_ty(exp_found),\n             infer::Regions(exp_found) => self.expected_found_str(exp_found),\n-            infer::Consts(exp_found) => self.expected_found_str(exp_found),\n+            infer::Terms(exp_found) => self.expected_found_str_term(exp_found),\n             infer::TraitRefs(exp_found) => {\n                 let pretty_exp_found = ty::error::ExpectedFound {\n                     expected: exp_found.expected.print_only_trait_path(),\n@@ -2178,16 +2175,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str_ty(\n+    fn expected_found_str_term(\n         &self,\n-        exp_found: ty::error::ExpectedFound<Ty<'tcx>>,\n+        exp_found: ty::error::ExpectedFound<ty::Term<'tcx>>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n \n-        Some(self.cmp(exp_found.expected, exp_found.found))\n+        Some(match (exp_found.expected, exp_found.found) {\n+            (ty::Term::Ty(expected), ty::Term::Ty(found)) => self.cmp(expected, found),\n+            (expected, found) => (\n+                DiagnosticStyledString::highlighted(expected.to_string()),\n+                DiagnosticStyledString::highlighted(found.to_string()),\n+            ),\n+        })\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\"."}, {"sha": "a79ed20730b5cf014eff50d71b7ccc3ac8c528f8", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -2,7 +2,7 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::infer::{SubregionOrigin, Subtype, ValuePairs};\n+use crate::infer::{SubregionOrigin, Subtype};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -34,16 +34,16 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         {\n             if let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) = (&sup_origin, &sub_origin) {\n                 if let (\n-                    ValuePairs::Types(sub_expected_found),\n-                    ValuePairs::Types(sup_expected_found),\n+                    sub_expected_found @ Some((sub_expected, sub_found)),\n+                    sup_expected_found @ Some(_),\n                     CompareImplMethodObligation { trait_item_def_id, .. },\n-                ) = (&sub_trace.values, &sup_trace.values, sub_trace.cause.code())\n+                ) = (&sub_trace.values.ty(), &sup_trace.values.ty(), sub_trace.cause.code())\n                 {\n                     if sup_expected_found == sub_expected_found {\n                         self.emit_err(\n                             var_origin.span(),\n-                            sub_expected_found.expected,\n-                            sub_expected_found.found,\n+                            sub_expected,\n+                            sub_found,\n                             *trait_item_def_id,\n                         );\n                         return Some(ErrorReported);"}, {"sha": "08320a0ff1d4229aaec90255cca58204cbdf6d27", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -366,13 +366,26 @@ pub struct InferCtxt<'a, 'tcx> {\n /// See the `error_reporting` module for more details.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable)]\n pub enum ValuePairs<'tcx> {\n-    Types(ExpectedFound<Ty<'tcx>>),\n     Regions(ExpectedFound<ty::Region<'tcx>>),\n-    Consts(ExpectedFound<&'tcx ty::Const<'tcx>>),\n+    Terms(ExpectedFound<ty::Term<'tcx>>),\n     TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n     PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n }\n \n+impl<'tcx> ValuePairs<'tcx> {\n+    pub fn ty(&self) -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n+        if let ValuePairs::Terms(ExpectedFound {\n+            expected: ty::Term::Ty(expected),\n+            found: ty::Term::Ty(found),\n+        }) = self\n+        {\n+            Some((expected, found))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n@@ -1817,7 +1830,10 @@ impl<'tcx> TypeTrace<'tcx> {\n         a: Ty<'tcx>,\n         b: Ty<'tcx>,\n     ) -> TypeTrace<'tcx> {\n-        TypeTrace { cause: cause.clone(), values: Types(ExpectedFound::new(a_is_expected, a, b)) }\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Terms(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+        }\n     }\n \n     pub fn consts(\n@@ -1826,7 +1842,10 @@ impl<'tcx> TypeTrace<'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> TypeTrace<'tcx> {\n-        TypeTrace { cause: cause.clone(), values: Consts(ExpectedFound::new(a_is_expected, a, b)) }\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Terms(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+        }\n     }\n }\n "}, {"sha": "2cb2ac8666120badcc5549f629bef290ac9ce684", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -1382,26 +1382,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     normalized_ty,\n                     data.term,\n                 ) {\n-                    values = Some(match (normalized_ty, data.term) {\n-                        (ty::Term::Ty(normalized_ty), ty::Term::Ty(ty)) => {\n-                            infer::ValuePairs::Types(ExpectedFound::new(\n-                                is_normalized_ty_expected,\n-                                normalized_ty,\n-                                ty,\n-                            ))\n-                        }\n-                        (ty::Term::Const(normalized_ct), ty::Term::Const(ct)) => {\n-                            infer::ValuePairs::Consts(ExpectedFound::new(\n-                                is_normalized_ty_expected,\n-                                normalized_ct,\n-                                ct,\n-                            ))\n-                        }\n-                        (_, _) => span_bug!(\n-                            obligation.cause.span,\n-                            \"found const or type where other expected\"\n-                        ),\n-                    });\n+                    values = Some(infer::ValuePairs::Terms(ExpectedFound::new(\n+                        is_normalized_ty_expected,\n+                        normalized_ty,\n+                        data.term,\n+                    )));\n                     err_buf = error;\n                     err = &err_buf;\n                 }"}, {"sha": "5bb528458c59e07941570607ad8e0fcabb32d45f", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -377,9 +377,9 @@ fn compare_predicate_entailment<'tcx>(\n                 &mut diag,\n                 &cause,\n                 trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n-                Some(infer::ValuePairs::Types(ExpectedFound {\n-                    expected: trait_fty,\n-                    found: impl_fty,\n+                Some(infer::ValuePairs::Terms(ExpectedFound {\n+                    expected: trait_fty.into(),\n+                    found: impl_fty.into(),\n                 })),\n                 &terr,\n                 false,\n@@ -1068,9 +1068,9 @@ crate fn compare_const_impl<'tcx>(\n                 &mut diag,\n                 &cause,\n                 trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n-                Some(infer::ValuePairs::Types(ExpectedFound {\n-                    expected: trait_ty,\n-                    found: impl_ty,\n+                Some(infer::ValuePairs::Terms(ExpectedFound {\n+                    expected: trait_ty.into(),\n+                    found: impl_ty.into(),\n                 })),\n                 &terr,\n                 false,"}, {"sha": "cbb86265233b0bdcc4578ffb210396b135d1f405", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -29,6 +29,7 @@\n #![feature(binary_heap_as_slice)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n+#![feature(round_char_boundary)]\n #![feature(slice_group_by)]\n #![feature(slice_partition_dedup)]\n #![feature(string_remove_matches)]"}, {"sha": "6b8be2506b64e5bc8d179eaae03798c003ce42f9", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -2272,3 +2272,95 @@ fn utf8_char_counts() {\n         }\n     }\n }\n+\n+#[test]\n+fn floor_char_boundary() {\n+    fn check_many(s: &str, arg: impl IntoIterator<Item = usize>, ret: usize) {\n+        for idx in arg {\n+            assert_eq!(\n+                s.floor_char_boundary(idx),\n+                ret,\n+                \"{:?}.floor_char_boundary({:?}) != {:?}\",\n+                s,\n+                idx,\n+                ret\n+            );\n+        }\n+    }\n+\n+    // edge case\n+    check_many(\"\", [0, 1, isize::MAX as usize, usize::MAX], 0);\n+\n+    // basic check\n+    check_many(\"x\", [0], 0);\n+    check_many(\"x\", [1, isize::MAX as usize, usize::MAX], 1);\n+\n+    // 1-byte chars\n+    check_many(\"jp\", [0], 0);\n+    check_many(\"jp\", [1], 1);\n+    check_many(\"jp\", 2..4, 2);\n+\n+    // 2-byte chars\n+    check_many(\"\u0135\u01a5\", 0..2, 0);\n+    check_many(\"\u0135\u01a5\", 2..4, 2);\n+    check_many(\"\u0135\u01a5\", 4..6, 4);\n+\n+    // 3-byte chars\n+    check_many(\"\u65e5\u672c\", 0..3, 0);\n+    check_many(\"\u65e5\u672c\", 3..6, 3);\n+    check_many(\"\u65e5\u672c\", 6..8, 6);\n+\n+    // 4-byte chars\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 0..4, 0);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 4..8, 4);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 8..10, 8);\n+}\n+\n+#[test]\n+fn ceil_char_boundary() {\n+    fn check_many(s: &str, arg: impl IntoIterator<Item = usize>, ret: usize) {\n+        for idx in arg {\n+            assert_eq!(\n+                s.ceil_char_boundary(idx),\n+                ret,\n+                \"{:?}.ceil_char_boundary({:?}) != {:?}\",\n+                s,\n+                idx,\n+                ret\n+            );\n+        }\n+    }\n+\n+    // edge case\n+    check_many(\"\", [0], 0);\n+\n+    // basic check\n+    check_many(\"x\", [0], 0);\n+    check_many(\"x\", [1], 1);\n+\n+    // 1-byte chars\n+    check_many(\"jp\", [0], 0);\n+    check_many(\"jp\", [1], 1);\n+    check_many(\"jp\", [2], 2);\n+\n+    // 2-byte chars\n+    check_many(\"\u0135\u01a5\", 0..=0, 0);\n+    check_many(\"\u0135\u01a5\", 1..=2, 2);\n+    check_many(\"\u0135\u01a5\", 3..=4, 4);\n+\n+    // 3-byte chars\n+    check_many(\"\u65e5\u672c\", 0..=0, 0);\n+    check_many(\"\u65e5\u672c\", 1..=3, 3);\n+    check_many(\"\u65e5\u672c\", 4..=6, 6);\n+\n+    // 4-byte chars\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 0..=0, 0);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 1..=4, 4);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 5..=8, 8);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn ceil_char_boundary_above_len_panic() {\n+    let _ = \"x\".ceil_char_boundary(2);\n+}"}, {"sha": "864a253299f6e28b00a58691006b3ccc2f84ada4", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -809,6 +809,11 @@ impl u8 {\n     pub fn escape_ascii(&self) -> ascii::EscapeDefault {\n         ascii::escape_default(*self)\n     }\n+\n+    pub(crate) fn is_utf8_char_boundary(self) -> bool {\n+        // This is bit magic equivalent to: b < 128 || b >= 192\n+        (self as i8) >= -0x40\n+    }\n }\n \n #[lang = \"u16\"]"}, {"sha": "09709dc3cf6dfbd187f2ecfe020ad0a6a07fbe33", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -76,15 +76,14 @@ use iter::MatchIndicesInternal;\n use iter::SplitInternal;\n use iter::{MatchesInternal, SplitNInternal};\n \n-use validations::truncate_to_char_boundary;\n-\n #[inline(never)]\n #[cold]\n #[track_caller]\n fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     const MAX_DISPLAY_LENGTH: usize = 256;\n-    let (truncated, s_trunc) = truncate_to_char_boundary(s, MAX_DISPLAY_LENGTH);\n-    let ellipsis = if truncated { \"[...]\" } else { \"\" };\n+    let trunc_len = s.floor_char_boundary(MAX_DISPLAY_LENGTH);\n+    let s_trunc = &s[..trunc_len];\n+    let ellipsis = if trunc_len < s.len() { \"[...]\" } else { \"\" };\n \n     // 1. out of bounds\n     if begin > s.len() || end > s.len() {\n@@ -105,10 +104,7 @@ fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     // 3. character boundary\n     let index = if !s.is_char_boundary(begin) { begin } else { end };\n     // find the character\n-    let mut char_start = index;\n-    while !s.is_char_boundary(char_start) {\n-        char_start -= 1;\n-    }\n+    let char_start = s.floor_char_boundary(index);\n     // `char_start` must be less than len and a char boundary\n     let ch = s[char_start..].chars().next().unwrap();\n     let char_range = char_start..char_start + ch.len_utf8();\n@@ -215,8 +211,80 @@ impl str {\n             // code on higher opt-levels. See PR #84751 for more details.\n             None => index == self.len(),\n \n-            // This is bit magic equivalent to: b < 128 || b >= 192\n-            Some(&b) => (b as i8) >= -0x40,\n+            Some(&b) => b.is_utf8_char_boundary(),\n+        }\n+    }\n+\n+    /// Finds the closest `x` not exceeding `index` where `is_char_boundary(x)` is `true`.\n+    ///\n+    /// This method can help you truncate a string so that it's still valid UTF-8, but doesn't\n+    /// exceed a given number of bytes. Note that this is done purely at the character level\n+    /// and can still visually split graphemes, even though the underlying characters aren't\n+    /// split. For example, the emoji \ud83e\uddd1\u200d\ud83d\udd2c (scientist) could be split so that the string only\n+    /// includes \ud83e\uddd1 (person) instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(round_char_boundary)]\n+    /// let s = \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\ud83d\udc9a\ud83d\udc99\ud83d\udc9c\";\n+    /// assert_eq!(s.len(), 26);\n+    /// assert!(!s.is_char_boundary(13));\n+    ///\n+    /// let closest = s.floor_char_boundary(13);\n+    /// assert_eq!(closest, 10);\n+    /// assert_eq!(&s[..closest], \"\u2764\ufe0f\ud83e\udde1\");\n+    /// ```\n+    #[unstable(feature = \"round_char_boundary\", issue = \"93743\")]\n+    #[inline]\n+    pub fn floor_char_boundary(&self, index: usize) -> usize {\n+        if index >= self.len() {\n+            self.len()\n+        } else {\n+            let lower_bound = index.saturating_sub(3);\n+            let new_index = self.as_bytes()[lower_bound..=index]\n+                .iter()\n+                .rposition(|b| b.is_utf8_char_boundary());\n+\n+            // SAFETY: we know that the character boundary will be within four bytes\n+            unsafe { lower_bound + new_index.unwrap_unchecked() }\n+        }\n+    }\n+\n+    /// Finds the closest `x` not below `index` where `is_char_boundary(x)` is `true`.\n+    ///\n+    /// This method is the natural complement to [`floor_char_boundary`]. See that method\n+    /// for more details.\n+    ///\n+    /// [`floor_char_boundary`]: str::floor_char_boundary\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index > self.len()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(round_char_boundary)]\n+    /// let s = \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\ud83d\udc9a\ud83d\udc99\ud83d\udc9c\";\n+    /// assert_eq!(s.len(), 26);\n+    /// assert!(!s.is_char_boundary(13));\n+    ///\n+    /// let closest = s.ceil_char_boundary(13);\n+    /// assert_eq!(closest, 14);\n+    /// assert_eq!(&s[..closest], \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\");\n+    /// ```\n+    #[unstable(feature = \"round_char_boundary\", issue = \"93743\")]\n+    #[inline]\n+    pub fn ceil_char_boundary(&self, index: usize) -> usize {\n+        if index > self.len() {\n+            slice_error_fail(self, index, index)\n+        } else {\n+            let upper_bound = Ord::min(index + 4, self.len());\n+            self.as_bytes()[index..upper_bound]\n+                .iter()\n+                .position(|b| b.is_utf8_char_boundary())\n+                .map_or(upper_bound, |pos| pos + index)\n         }\n     }\n "}, {"sha": "0d3dc856be577c44669176a29cb182c6cdc95316", "filename": "library/core/src/str/validations.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -273,16 +273,3 @@ pub const fn utf8_char_width(b: u8) -> usize {\n \n /// Mask of the value bits of a continuation byte.\n const CONT_MASK: u8 = 0b0011_1111;\n-\n-// truncate `&str` to length at most equal to `max`\n-// return `true` if it were truncated, and the new str.\n-pub(super) fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n-    if max >= s.len() {\n-        (false, s)\n-    } else {\n-        while !s.is_char_boundary(max) {\n-            max -= 1;\n-        }\n-        (true, &s[..max])\n-    }\n-}"}, {"sha": "6d94c70eadee6455d27aa344e8d37439326c8f5a", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -463,9 +463,6 @@ nav.sub {\n .location a:first-of-type {\n \tfont-weight: 500;\n }\n-.location a:hover {\n-\ttext-decoration: underline;\n-}\n \n .block {\n \tpadding: 0;\n@@ -476,10 +473,11 @@ nav.sub {\n \tlist-style: none;\n }\n \n-.block a {\n+.block a,\n+h2.location a {\n \tdisplay: block;\n-\tpadding: 0.3em;\n-\tmargin-left: -0.3em;\n+\tpadding: 0.3rem;\n+\tmargin-left: -0.3rem;\n \n \ttext-overflow: ellipsis;\n \toverflow: hidden;\n@@ -494,8 +492,8 @@ nav.sub {\n \tfont-weight: 500;\n \tpadding: 0;\n \tmargin: 0;\n-\tmargin-top: 1rem;\n-\tmargin-bottom: 1rem;\n+\tmargin-top: 0.7rem;\n+\tmargin-bottom: 0.7rem;\n }\n \n .sidebar h3 {\n@@ -1812,10 +1810,7 @@ details.rustdoc-toggle[open] > summary.hideme::after {\n \n \t.mobile-topbar .location {\n \t\tborder: none;\n-\t\tmargin: 0;\n-\t\tmargin-left: auto;\n-\t\tpadding: 0.3em;\n-\t\tpadding-right: 0.6em;\n+\t\tmargin: auto 0.5em auto auto;\n \t\ttext-overflow: ellipsis;\n \t\toverflow: hidden;\n \t\twhite-space: nowrap;"}, {"sha": "e402b3583f3996db04ceac724326a98bc2f2a20d", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -91,7 +91,8 @@ pre, .rustdoc.source .example-wrap {\n \tbackground-color: #5c6773;\n }\n \n-.sidebar .current {\n+.sidebar .current,\n+.sidebar a:hover {\n \tbackground-color: transparent;\n \tcolor: #ffb44c;\n }\n@@ -104,15 +105,6 @@ pre, .rustdoc.source .example-wrap {\n \tcolor: #ff7733;\n }\n \n-.sidebar-elems .location a {\n-\tcolor: #fff;\n-}\n-\n-.block a:hover {\n-\tbackground: transparent;\n-\tcolor: #ffb44c;\n-}\n-\n .line-numbers span { color: #5c6773; }\n .line-numbers .line-highlighted {\n \tcolor: #708090;\n@@ -220,6 +212,10 @@ pre.rust a,\n .in-band a {\n \tcolor: #c5c5c5;\n }\n+.sidebar h2 a,\n+.sidebar h3 a {\n+\tcolor: white;\n+}\n .search-results a {\n \tcolor: #0096cf;\n }"}, {"sha": "0a56055b8cbf67367ff32262c74aefe88b8f29ea", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -61,18 +61,15 @@ pre, .rustdoc.source .example-wrap {\n \tbackground-color: rgba(32, 34, 37, .6);\n }\n \n-.sidebar .current {\n-\tbackground-color: #333;\n+.sidebar .current,\n+.sidebar a:hover {\n+\tbackground: #444;\n }\n \n .source .sidebar {\n \tbackground-color: #565656;\n }\n \n-.block a:hover {\n-\tbackground: #444;\n-}\n-\n .line-numbers span { color: #3B91E2; }\n .line-numbers .line-highlighted {\n \tbackground-color: #0a042f !important;"}, {"sha": "dc1715b2a78f33116cc183b8fef0b3683d224dd8", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -63,18 +63,15 @@ pre, .rustdoc.source .example-wrap {\n \tbackground-color: rgba(36, 37, 39, 0.6);\n }\n \n-.sidebar .current {\n+.sidebar .current,\n+.sidebar a:hover {\n \tbackground-color: #fff;\n }\n \n .source .sidebar {\n \tbackground-color: #f1f1f1;\n }\n \n-.block a:hover {\n-\tbackground: #F5F5F5;\n-}\n-\n .line-numbers span { color: #c67e2d; }\n .line-numbers .line-highlighted {\n \tbackground-color: #FDFFD3 !important;"}, {"sha": "68028604fa463d36ad980268ec5462f71214b891", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -5,6 +5,7 @@\n #![feature(rustc_private)]\n #![feature(array_methods)]\n #![feature(assert_matches)]\n+#![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(box_syntax)]"}, {"sha": "8621fe6ba1b93a0a19a5bd90ff8edf4791e56d54", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -2,10 +2,8 @@\n //!\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n-use rustc_ast as ast;\n use rustc_data_structures::{fx::FxHashMap, stable_set::FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_expand::base::SyntaxExtensionKind;\n use rustc_hir::def::{\n     DefKind,\n     Namespace::{self, *},\n@@ -14,7 +12,6 @@ use rustc_hir::def::{\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n-use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -486,23 +483,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'a str,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n-        let path = ast::Path::from_ident(Ident::from_str(path_str));\n         self.cx.enter_resolver(|resolver| {\n-            // FIXME(jynelson): does this really need 3 separate lookups?\n-            if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-                &path,\n-                None,\n-                &ParentScope::module(resolver.graph_root(), resolver),\n-                false,\n-                false,\n-            ) {\n-                if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                    return Ok(res.try_into().unwrap());\n-                }\n-            }\n-            if let Some(&res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Ok(res.try_into().unwrap());\n-            }\n+            // NOTE: this needs 2 separate lookups because `resolve_str_path_error` doesn't take\n+            // lexical scope into account (it ignores all macros not defined at the mod-level)\n             debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n             if let Ok((_, res)) =\n                 resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n@@ -512,6 +495,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     return Ok(res);\n                 }\n             }\n+            if let Some(&res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n+                return Ok(res.try_into().unwrap());\n+            }\n             Err(ResolutionFailure::NotResolved {\n                 module_id,\n                 partial_res: None,"}, {"sha": "9caadef3dec7c92c371a3600fed3c9fc4eeaaadd", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -38,7 +38,7 @@ fn drop_tag(\n     tags: &mut Vec<(String, Range<usize>)>,\n     tag_name: String,\n     range: Range<usize>,\n-    f: &impl Fn(&str, &Range<usize>),\n+    f: &impl Fn(&str, &Range<usize>, bool),\n ) {\n     let tag_name_low = tag_name.to_lowercase();\n     if let Some(pos) = tags.iter().rposition(|(t, _)| t.to_lowercase() == tag_name_low) {\n@@ -59,14 +59,42 @@ fn drop_tag(\n             // `tags` is used as a queue, meaning that everything after `pos` is included inside it.\n             // So `<h2><h3></h2>` will look like `[\"h2\", \"h3\"]`. So when closing `h2`, we will still\n             // have `h3`, meaning the tag wasn't closed as it should have.\n-            f(&format!(\"unclosed HTML tag `{}`\", last_tag_name), &last_tag_span);\n+            f(&format!(\"unclosed HTML tag `{}`\", last_tag_name), &last_tag_span, true);\n         }\n         // Remove the `tag_name` that was originally closed\n         tags.pop();\n     } else {\n         // It can happen for example in this case: `<h2></script></h2>` (the `h2` tag isn't required\n         // but it helps for the visualization).\n-        f(&format!(\"unopened HTML tag `{}`\", tag_name), &range);\n+        f(&format!(\"unopened HTML tag `{}`\", tag_name), &range, false);\n+    }\n+}\n+\n+fn extract_path_backwards(text: &str, end_pos: usize) -> Option<usize> {\n+    use rustc_lexer::{is_id_continue, is_id_start};\n+    let mut current_pos = end_pos;\n+    loop {\n+        if current_pos >= 2 && text[..current_pos].ends_with(\"::\") {\n+            current_pos -= 2;\n+        }\n+        let new_pos = text[..current_pos]\n+            .char_indices()\n+            .rev()\n+            .take_while(|(_, c)| is_id_start(*c) || is_id_continue(*c))\n+            .reduce(|_accum, item| item)\n+            .and_then(|(new_pos, c)| is_id_start(c).then_some(new_pos));\n+        if let Some(new_pos) = new_pos {\n+            if current_pos != new_pos {\n+                current_pos = new_pos;\n+                continue;\n+            }\n+        }\n+        break;\n+    }\n+    if current_pos == end_pos {\n+        return None;\n+    } else {\n+        return Some(current_pos);\n     }\n }\n \n@@ -76,7 +104,7 @@ fn extract_html_tag(\n     range: &Range<usize>,\n     start_pos: usize,\n     iter: &mut Peekable<CharIndices<'_>>,\n-    f: &impl Fn(&str, &Range<usize>),\n+    f: &impl Fn(&str, &Range<usize>, bool),\n ) {\n     let mut tag_name = String::new();\n     let mut is_closing = false;\n@@ -140,7 +168,7 @@ fn extract_tags(\n     text: &str,\n     range: Range<usize>,\n     is_in_comment: &mut Option<Range<usize>>,\n-    f: &impl Fn(&str, &Range<usize>),\n+    f: &impl Fn(&str, &Range<usize>, bool),\n ) {\n     let mut iter = text.char_indices().peekable();\n \n@@ -178,14 +206,42 @@ impl<'a, 'tcx> DocVisitor for InvalidHtmlTagsLinter<'a, 'tcx> {\n         };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n         if !dox.is_empty() {\n-            let report_diag = |msg: &str, range: &Range<usize>| {\n+            let report_diag = |msg: &str, range: &Range<usize>, is_open_tag: bool| {\n                 let sp = match super::source_span_for_markdown_range(tcx, &dox, range, &item.attrs)\n                 {\n                     Some(sp) => sp,\n                     None => item.attr_span(tcx),\n                 };\n                 tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, |lint| {\n-                    lint.build(msg).emit()\n+                    use rustc_lint_defs::Applicability;\n+                    let mut diag = lint.build(msg);\n+                    // If a tag looks like `<this>`, it might actually be a generic.\n+                    // We don't try to detect stuff `<like, this>` because that's not valid HTML,\n+                    // and we don't try to detect stuff `<like this>` because that's not valid Rust.\n+                    if let Some(Some(generics_start)) = (is_open_tag\n+                        && dox[..range.end].ends_with(\">\"))\n+                    .then(|| extract_path_backwards(&dox, range.start))\n+                    {\n+                        let generics_sp = match super::source_span_for_markdown_range(\n+                            tcx,\n+                            &dox,\n+                            &(generics_start..range.end),\n+                            &item.attrs,\n+                        ) {\n+                            Some(sp) => sp,\n+                            None => item.attr_span(tcx),\n+                        };\n+                        // multipart form is chosen here because ``Vec<i32>`` would be confusing.\n+                        diag.multipart_suggestion(\n+                            \"try marking as source code\",\n+                            vec![\n+                                (generics_sp.shrink_to_lo(), String::from(\"`\")),\n+                                (generics_sp.shrink_to_hi(), String::from(\"`\")),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    diag.emit()\n                 });\n             };\n \n@@ -210,11 +266,11 @@ impl<'a, 'tcx> DocVisitor for InvalidHtmlTagsLinter<'a, 'tcx> {\n                 let t = t.to_lowercase();\n                 !ALLOWED_UNCLOSED.contains(&t.as_str())\n             }) {\n-                report_diag(&format!(\"unclosed HTML tag `{}`\", tag), range);\n+                report_diag(&format!(\"unclosed HTML tag `{}`\", tag), range, true);\n             }\n \n             if let Some(range) = is_in_comment {\n-                report_diag(\"Unclosed HTML comment\", &range);\n+                report_diag(\"Unclosed HTML comment\", &range, false);\n             }\n         }\n "}, {"sha": "16882cf83d09cdd058873d0cb5688ce9b7e981de", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -196,7 +196,8 @@ where\n                 return;\n             }\n \n-            let file = tcx.sess.source_map().lookup_char_pos(span.lo()).file;\n+            let source_map = tcx.sess.source_map();\n+            let file = source_map.lookup_char_pos(span.lo()).file;\n             let file_path = match file.name.clone() {\n                 FileName::Real(real_filename) => real_filename.into_local_path(),\n                 _ => None,\n@@ -217,6 +218,8 @@ where\n                 let fn_entries = self.calls.entry(fn_key).or_default();\n \n                 trace!(\"Including expr: {:?}\", span);\n+                let enclosing_item_span =\n+                    source_map.span_extend_to_prev_char(enclosing_item_span, '\\n', false);\n                 let location = CallLocation::new(span, enclosing_item_span, &file);\n                 fn_entries.entry(abs_path).or_insert_with(mk_call_data).locations.push(location);\n             }"}, {"sha": "83a9204136f7c15d82a676c84c9c461e55e297db", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.no_cov_crate.txt", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -6,8 +6,8 @@\n     6|       |    println!(\"called but not covered\");\n     7|       |}\n     8|       |\n-    9|       |#[no_coverage]\n-   10|       |fn do_not_add_coverage_2() {\n+    9|       |fn do_not_add_coverage_2() {\n+   10|       |    #![no_coverage]\n    11|       |    println!(\"called but not covered\");\n    12|       |}\n    13|       |\n@@ -28,10 +28,60 @@\n    28|      0|    println!(\"not called but covered\");\n    29|      0|}\n    30|       |\n-   31|      1|fn main() {\n-   32|      1|    do_not_add_coverage_1();\n-   33|      1|    do_not_add_coverage_2();\n-   34|      1|    add_coverage_1();\n-   35|      1|    add_coverage_2();\n-   36|      1|}\n+   31|       |// FIXME: These test-cases illustrate confusing results of nested functions.\n+   32|       |// See https://github.com/rust-lang/rust/issues/93319\n+   33|       |mod nested_fns {\n+   34|       |    #[no_coverage]\n+   35|       |    pub fn outer_not_covered(is_true: bool) {\n+   36|      1|        fn inner(is_true: bool) {\n+   37|      1|            if is_true {\n+   38|      1|                println!(\"called and covered\");\n+   39|      1|            } else {\n+   40|      0|                println!(\"absolutely not covered\");\n+   41|      0|            }\n+   42|      1|        }\n+   43|       |        println!(\"called but not covered\");\n+   44|       |        inner(is_true);\n+   45|       |    }\n+   46|       |\n+   47|      1|    pub fn outer(is_true: bool) {\n+   48|      1|        println!(\"called and covered\");\n+   49|      1|        inner_not_covered(is_true);\n+   50|      1|\n+   51|      1|        #[no_coverage]\n+   52|      1|        fn inner_not_covered(is_true: bool) {\n+   53|      1|            if is_true {\n+   54|      1|                println!(\"called but not covered\");\n+   55|      1|            } else {\n+   56|      1|                println!(\"absolutely not covered\");\n+   57|      1|            }\n+   58|      1|        }\n+   59|      1|    }\n+   60|       |\n+   61|      1|    pub fn outer_both_covered(is_true: bool) {\n+   62|      1|        println!(\"called and covered\");\n+   63|      1|        inner(is_true);\n+   64|      1|\n+   65|      1|        fn inner(is_true: bool) {\n+   66|      1|            if is_true {\n+   67|      1|                println!(\"called and covered\");\n+   68|      1|            } else {\n+   69|      0|                println!(\"absolutely not covered\");\n+   70|      0|            }\n+   71|      1|        }\n+   72|      1|    }\n+   73|       |}\n+   74|       |\n+   75|      1|fn main() {\n+   76|      1|    let is_true = std::env::args().len() == 1;\n+   77|      1|\n+   78|      1|    do_not_add_coverage_1();\n+   79|      1|    do_not_add_coverage_2();\n+   80|      1|    add_coverage_1();\n+   81|      1|    add_coverage_2();\n+   82|      1|\n+   83|      1|    nested_fns::outer_not_covered(is_true);\n+   84|      1|    nested_fns::outer(is_true);\n+   85|      1|    nested_fns::outer_both_covered(is_true);\n+   86|      1|}\n "}, {"sha": "0bfbdda2cab037cd1d748d9cb7b063710db15c10", "filename": "src/test/run-make-fulldeps/coverage/no_cov_crate.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -6,8 +6,8 @@ fn do_not_add_coverage_1() {\n     println!(\"called but not covered\");\n }\n \n-#[no_coverage]\n fn do_not_add_coverage_2() {\n+    #![no_coverage]\n     println!(\"called but not covered\");\n }\n \n@@ -28,9 +28,59 @@ fn add_coverage_not_called() {\n     println!(\"not called but covered\");\n }\n \n+// FIXME: These test-cases illustrate confusing results of nested functions.\n+// See https://github.com/rust-lang/rust/issues/93319\n+mod nested_fns {\n+    #[no_coverage]\n+    pub fn outer_not_covered(is_true: bool) {\n+        fn inner(is_true: bool) {\n+            if is_true {\n+                println!(\"called and covered\");\n+            } else {\n+                println!(\"absolutely not covered\");\n+            }\n+        }\n+        println!(\"called but not covered\");\n+        inner(is_true);\n+    }\n+\n+    pub fn outer(is_true: bool) {\n+        println!(\"called and covered\");\n+        inner_not_covered(is_true);\n+\n+        #[no_coverage]\n+        fn inner_not_covered(is_true: bool) {\n+            if is_true {\n+                println!(\"called but not covered\");\n+            } else {\n+                println!(\"absolutely not covered\");\n+            }\n+        }\n+    }\n+\n+    pub fn outer_both_covered(is_true: bool) {\n+        println!(\"called and covered\");\n+        inner(is_true);\n+\n+        fn inner(is_true: bool) {\n+            if is_true {\n+                println!(\"called and covered\");\n+            } else {\n+                println!(\"absolutely not covered\");\n+            }\n+        }\n+    }\n+}\n+\n fn main() {\n+    let is_true = std::env::args().len() == 1;\n+\n     do_not_add_coverage_1();\n     do_not_add_coverage_2();\n     add_coverage_1();\n     add_coverage_2();\n+\n+    nested_fns::outer_not_covered(is_true);\n+    nested_fns::outer(is_true);\n+    nested_fns::outer_both_covered(is_true);\n }"}, {"sha": "dce8b83eefe4efd68139f03ed800a171f42f9303", "filename": "src/test/run-make/rustdoc-scrape-examples-whitespace/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2FMakefile?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,5 @@\n+deps := ex\n+\n+-include ../rustdoc-scrape-examples-multiple/scrape.mk\n+\n+all: scrape"}, {"sha": "44ff689dfc876e4e2f2f0aa08d9c4568f2c5b042", "filename": "src/test/run-make/rustdoc-scrape-examples-whitespace/examples/ex.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2Fexamples%2Fex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2Fexamples%2Fex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2Fexamples%2Fex.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,8 @@\n+struct Foo;\n+impl Foo {\n+  fn bar() { foobar::ok(); }\n+}\n+\n+fn main() {\n+  Foo::bar();\n+}"}, {"sha": "28c34716c2f3b9d27b2cebdc6e5951d336b3e02a", "filename": "src/test/run-make/rustdoc-scrape-examples-whitespace/src/lib.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-scrape-examples-whitespace%2Fsrc%2Flib.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,3 @@\n+// @has foobar/fn.ok.html '//*[@class=\"docblock scraped-example-list\"]//code' '  '\n+\n+pub fn ok() {}"}, {"sha": "2e44dd32d45b4164791938cbad7c0db3f1ecc9a6", "filename": "src/test/rustdoc-gui/mobile.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-gui%2Fmobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-gui%2Fmobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fmobile.goml?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -11,7 +11,7 @@ assert-css: (\".main-heading\", {\n   \"flex-direction\": \"column\"\n })\n \n-assert-property: (\".mobile-topbar h2.location\", {\"offsetHeight\": 45})\n+assert-property: (\".mobile-topbar h2.location\", {\"offsetHeight\": 48})\n \n // Note: We can't use assert-text here because the 'Since' is set by CSS and\n // is therefore not part of the DOM."}, {"sha": "9581aa74b0f643eafeaa9c3c3f9bcf2bdf2717e2", "filename": "src/test/rustdoc-gui/sidebar-mobile.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -39,4 +39,4 @@ assert-position: (\"#method\\.must_use\", {\"y\": 45})\n // Check that the bottom-most item on the sidebar menu can be scrolled fully into view.\n click: \".sidebar-menu-toggle\"\n scroll-to: \".block.keyword li:nth-child(1)\"\n-assert-position: (\".block.keyword li:nth-child(1)\", {\"y\": 542.234375})\n+compare-elements-position-near: (\".block.keyword li:nth-child(1)\", \".mobile-topbar\", {\"y\": 543})"}, {"sha": "877cc61b66f24dd65c502d3daf254b60e0321459", "filename": "src/test/rustdoc-gui/sidebar.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -77,7 +77,7 @@ assert-text: (\"#functions + .item-table .item-left > a\", \"foo\")\n \n // Links to trait implementations in the sidebar should not wrap even if they are long.\n goto: file://|DOC_PATH|/lib2/struct.HasALongTraitWithParams.html\n-assert-property: (\".sidebar-links a\", {\"offsetHeight\": 29})\n+assert-property: (\".sidebar-links a\", {\"offsetHeight\": 30})\n \n // Test that clicking on of the \"In <module>\" headings in the sidebar links to the\n // appropriate anchor in index.html."}, {"sha": "d4142511e4373e8a12c252f6cc8bb4d546470851", "filename": "src/test/rustdoc-gui/type-declation-overflow.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-gui%2Ftype-declation-overflow.goml", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-gui%2Ftype-declation-overflow.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ftype-declation-overflow.goml?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -32,6 +32,6 @@ assert-property: (\".item-decl pre\", {\"scrollWidth\": \"950\"})\n size: (600, 600)\n goto: file://|DOC_PATH|/lib2/too_long/struct.SuperIncrediblyLongLongLongLongLongLongLongGigaGigaGigaMegaLongLongLongStructName.html\n // It shouldn't have an overflow in the topbar either.\n-assert-property: (\".mobile-topbar .location\", {\"scrollWidth\": \"986\"})\n-assert-property: (\".mobile-topbar .location\", {\"clientWidth\": \"504\"})\n+assert-property: (\".mobile-topbar .location\", {\"scrollWidth\": \"493\"})\n+assert-property: (\".mobile-topbar .location\", {\"clientWidth\": \"493\"})\n assert-css: (\".mobile-topbar .location\", {\"overflow-x\": \"hidden\"})"}, {"sha": "c60dfa3f9518e0998a3a3016af866fedc4645b37", "filename": "src/test/rustdoc-ui/block-doc-comment.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fblock-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fblock-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fblock-doc-comment.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// compile-flags:--test\n+\n+// This test ensures that no code block is detected in the doc comments.\n+\n+pub mod Wormhole {\n+    /** # Returns\n+     *\n+     */\n+    pub fn foofoo() {}\n+    /**\n+     * # Returns\n+     *\n+     */\n+    pub fn barbar() {}\n+}"}, {"sha": "e5c27bebbdb23760134f4ddd98b349116b3c04e6", "filename": "src/test/rustdoc-ui/block-doc-comment.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fblock-doc-comment.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fblock-doc-comment.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fblock-doc-comment.stdout?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,5 @@\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n+"}, {"sha": "a14e4bdf1d706195de9551a46c704051349072e8", "filename": "src/test/rustdoc-ui/intra-doc/macro-rules.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fmacro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fmacro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fmacro-rules.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+#![allow(rustdoc::private_intra_doc_links)]\n+\n+macro_rules! foo {\n+    () => {};\n+}\n+\n+/// [foo!]\n+pub fn baz() {}"}, {"sha": "744b3071f1b8118c248a744890fe757d4c270bc4", "filename": "src/test/rustdoc-ui/suggestions/html-as-generics-no-suggestions.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics-no-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics-no-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics-no-suggestions.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,38 @@\n+#![deny(rustdoc::invalid_html_tags)]\n+\n+/// This Vec<32> thing!\n+// Numbers aren't valid HTML tags, so no error.\n+pub struct ConstGeneric;\n+\n+/// This Vec<i32, i32> thing!\n+// HTML tags cannot contain commas, so no error.\n+pub struct MultipleGenerics;\n+\n+/// This Vec<i32 class=\"test\"> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+// HTML attributes shouldn't be treated as Rust syntax, so no suggestions.\n+pub struct TagWithAttributes;\n+\n+/// This Vec<i32></i32> thing!\n+// There should be no error, and no suggestion, since the tags are balanced.\n+pub struct DoNotWarnOnMatchingTags;\n+\n+/// This Vec</i32> thing!\n+//~^ERROR unopened HTML tag `i32`\n+// This should produce an error, but no suggestion.\n+pub struct EndTagsAreNotValidRustSyntax;\n+\n+/// This 123<i32> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+// This should produce an error, but no suggestion.\n+pub struct NumbersAreNotPaths;\n+\n+/// This Vec:<i32> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+// This should produce an error, but no suggestion.\n+pub struct InvalidTurbofish;\n+\n+/// This [link](https://rust-lang.org)<i32> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+// This should produce an error, but no suggestion.\n+pub struct BareTurbofish;"}, {"sha": "832b8b2cac79ade3733a693eaaf048363e75c3d8", "filename": "src/test/rustdoc-ui/suggestions/html-as-generics-no-suggestions.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics-no-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics-no-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics-no-suggestions.stderr?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,38 @@\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics-no-suggestions.rs:11:13\n+   |\n+LL | /// This Vec<i32 class=\"test\"> thing!\n+   |             ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/html-as-generics-no-suggestions.rs:1:9\n+   |\n+LL | #![deny(rustdoc::invalid_html_tags)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unopened HTML tag `i32`\n+  --> $DIR/html-as-generics-no-suggestions.rs:20:13\n+   |\n+LL | /// This Vec</i32> thing!\n+   |             ^^^^^^\n+\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics-no-suggestions.rs:25:13\n+   |\n+LL | /// This 123<i32> thing!\n+   |             ^^^^^\n+\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics-no-suggestions.rs:30:14\n+   |\n+LL | /// This Vec:<i32> thing!\n+   |              ^^^^^\n+\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics-no-suggestions.rs:35:39\n+   |\n+LL | /// This [link](https://rust-lang.org)<i32> thing!\n+   |                                       ^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "c0a0de24c5263c05542464a1467834a2c86fb895", "filename": "src/test/rustdoc-ui/suggestions/html-as-generics.fixed", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.fixed?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,32 @@\n+// run-rustfix\n+#![deny(rustdoc::invalid_html_tags)]\n+\n+/// This `Vec<i32>` thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct Generic;\n+\n+/// This `vec::Vec<i32>` thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct GenericPath;\n+\n+/// This `i32<i32>` thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct PathsCanContainTrailingNumbers;\n+\n+/// This `Vec::<i32>` thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct Turbofish;\n+\n+/// This [link](https://rust-lang.org)`::<i32>` thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct BareTurbofish;\n+\n+/// This <span>`Vec::<i32>`</span> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct Nested;"}, {"sha": "0b6009b0e59c3574047aff463e452f54e18d06d8", "filename": "src/test/rustdoc-ui/suggestions/html-as-generics.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,32 @@\n+// run-rustfix\n+#![deny(rustdoc::invalid_html_tags)]\n+\n+/// This Vec<i32> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct Generic;\n+\n+/// This vec::Vec<i32> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct GenericPath;\n+\n+/// This i32<i32> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct PathsCanContainTrailingNumbers;\n+\n+/// This Vec::<i32> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct Turbofish;\n+\n+/// This [link](https://rust-lang.org)::<i32> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct BareTurbofish;\n+\n+/// This <span>Vec::<i32></span> thing!\n+//~^ERROR unclosed HTML tag `i32`\n+//~|HELP try marking as source\n+pub struct Nested;"}, {"sha": "df54b71264ebcb770eae2b5aed806e6140e3a6ee", "filename": "src/test/rustdoc-ui/suggestions/html-as-generics.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fsuggestions%2Fhtml-as-generics.stderr?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -0,0 +1,73 @@\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics.rs:4:13\n+   |\n+LL | /// This Vec<i32> thing!\n+   |             ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/html-as-generics.rs:2:9\n+   |\n+LL | #![deny(rustdoc::invalid_html_tags)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try marking as source code\n+   |\n+LL | /// This `Vec<i32>` thing!\n+   |          +        +\n+\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics.rs:9:18\n+   |\n+LL | /// This vec::Vec<i32> thing!\n+   |                  ^^^^^\n+   |\n+help: try marking as source code\n+   |\n+LL | /// This `vec::Vec<i32>` thing!\n+   |          +             +\n+\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics.rs:14:13\n+   |\n+LL | /// This i32<i32> thing!\n+   |             ^^^^^\n+   |\n+help: try marking as source code\n+   |\n+LL | /// This `i32<i32>` thing!\n+   |          +        +\n+\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics.rs:19:15\n+   |\n+LL | /// This Vec::<i32> thing!\n+   |               ^^^^^\n+   |\n+help: try marking as source code\n+   |\n+LL | /// This `Vec::<i32>` thing!\n+   |          +          +\n+\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics.rs:24:41\n+   |\n+LL | /// This [link](https://rust-lang.org)::<i32> thing!\n+   |                                         ^^^^^\n+   |\n+help: try marking as source code\n+   |\n+LL | /// This [link](https://rust-lang.org)`::<i32>` thing!\n+   |                                       +       +\n+\n+error: unclosed HTML tag `i32`\n+  --> $DIR/html-as-generics.rs:29:21\n+   |\n+LL | /// This <span>Vec::<i32></span> thing!\n+   |                     ^^^^^\n+   |\n+help: try marking as source code\n+   |\n+LL | /// This <span>`Vec::<i32>`</span> thing!\n+   |                +          +\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "ea28d84f1ffdfe63fd0b41bad05a8c29205c822e", "filename": "src/test/rustdoc/strip-block-doc-comments-stars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b17b181af4945fa24e0df79676e89454546440/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.rs?ref=03b17b181af4945fa24e0df79676e89454546440", "patch": "@@ -1,6 +1,6 @@\n #![crate_name = \"foo\"]\n \n-// The goal of this test is to answer that it won't be generated as a list because\n+// The goal of this test is to ensure that it won't be generated as a list because\n // block doc comments can have their lines starting with a star.\n \n // @has foo/fn.foo.html"}]}