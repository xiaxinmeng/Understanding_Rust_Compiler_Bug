{"sha": "80b861bed17ba2ce001911f78a5316f56466642f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYjg2MWJlZDE3YmEyY2UwMDE5MTFmNzhhNTMxNmY1NjQ2NjY0MmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-12T23:47:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-12T23:47:27Z"}, "message": "Auto merge of #64873 - popzxc:prettify-test-time, r=wesleywiser\n\nEnhance report-time option\n\n## Short overview\n\nThis PR is a follow-up to a previously closed #64714 PR.\n\n## Changes introduced by this PR\n\n* `libtest` now retrieves the type of the test within `TestDesc` (available types are: `UnitTest`, `IntegrationTest`, `DocTest`, `Unknown`).\n* `--report-time` subcommand of the `libtest` now supports colored output (disabled by default).\n* Colorized output depends on the threshold values. Default values (proposed by @wesleywiser):\n  - For unit-tests: 50ms warn/100ms critical,\n  - For integration-tests: 500ms warn/1000ms critical,\n  - For doctests: same as for integration tests,\n  - For unknown tests: `TEST_WARN_TIMEOUT_S` warn/ `TEST_WARN_TIMEOUT_S * 2` critical (it will only applied single-threaded mode, because otherwise test will be interrupted after reaching `TEST_WARN_TIMEOUT_S`).\n  - These values can be overrided by setting environment variables (since those thresholds are somewhat constant for every project, it's more flexible to use environment variables than command line arguments).\n* New optional flag `--ensure-test-time` for `libtest`. With this flag applied, exectuion time limit excesss will cause test failure.\n\n## What have not been done\n\nThere was a comment that it would be nice to have an entry in the Cargo book about it.\n\nHowever, changes introduced by this PR (and #64663 in which `report-time` flag was added) aren't related directly to `cargo`, it's more about `libtest` itself.\nI'm considering that [The Unstable Book](https://doc.rust-lang.org/unstable-book/) is more appropriate place, but not sure if I'm right (and if so, how exactly it should be described).\n\nAs one possible option, this PR may be merged without denoting it in the documentation, and in the next PR adding support of this feature to the `cargo` itself, I'll add a note in the Cargo book.\n\n## Scope of this PR\n\nLogical scope of this PR is `libtest` only. However, to get test types, I had to modify also `libsyntax_ext` and `librustdoc` for them to provide information about test type.\n\n## Rationale\n\nRationale for colored output was submitted in #64714\n\nProviding the information about kind of test was also proposed in #64714, and as an additional benefit this information may be useful for the tools using `libtest` (e.g. `cargo`).\n\nAdding flag to treat time limits excess seems logical to me, so projects that do care about test execution time won't have to invent a wheel.\n\n## Backward compatibility\n\nAll the changes are completely backward compatible.\n\n## Demo\n\n![rustc_enhanced_time](https://user-images.githubusercontent.com/12111581/65818381-c04f6800-e219-11e9-9875-322463abe24f.gif)\n\nr? @wesleywiser", "tree": {"sha": "ca78bef6ffbeb270e8b91b56080ff52697f73fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca78bef6ffbeb270e8b91b56080ff52697f73fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80b861bed17ba2ce001911f78a5316f56466642f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80b861bed17ba2ce001911f78a5316f56466642f", "html_url": "https://github.com/rust-lang/rust/commit/80b861bed17ba2ce001911f78a5316f56466642f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80b861bed17ba2ce001911f78a5316f56466642f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1721c9685b1ee69f1e17b3a8b09145b10fdfbe4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1721c9685b1ee69f1e17b3a8b09145b10fdfbe4a", "html_url": "https://github.com/rust-lang/rust/commit/1721c9685b1ee69f1e17b3a8b09145b10fdfbe4a"}, {"sha": "15f571bbd3ce370d925d21f1ab281aee993e4860", "url": "https://api.github.com/repos/rust-lang/rust/commits/15f571bbd3ce370d925d21f1ab281aee993e4860", "html_url": "https://github.com/rust-lang/rust/commit/15f571bbd3ce370d925d21f1ab281aee993e4860"}], "stats": {"total": 835, "additions": 718, "deletions": 117}, "files": [{"sha": "ed4e9c6b56842cef485f063c14092500e23c58f5", "filename": "src/doc/unstable-book/src/compiler-flags/report-time.md", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -0,0 +1,80 @@\n+# `report-time`\n+\n+The tracking issue for this feature is: [#64888]\n+\n+[#64888]: https://github.com/rust-lang/rust/issues/64888\n+\n+------------------------\n+\n+The `report-time` feature adds a possibility to report execution time of the\n+tests generated via `libtest`.\n+\n+This is unstable feature, so you have to provide `-Zunstable-options` to get\n+this feature working.\n+\n+Sample usage command:\n+\n+```sh\n+./test_executable -Zunstable-options --report-time\n+```\n+\n+Available options:\n+\n+```sh\n+--report-time [plain|colored]\n+                Show execution time of each test. Awailable values:\n+                plain = do not colorize the execution time (default);\n+                colored = colorize output according to the `color`\n+                parameter value;\n+                Threshold values for colorized output can be\n+                configured via\n+                `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION`\n+                and\n+                `RUST_TEST_TIME_DOCTEST` environment variables.\n+                Expected format of environment variable is\n+                `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+                Not available for --format=terse\n+--ensure-time \n+                Treat excess of the test execution time limit as\n+                error.\n+                Threshold values for this option can be configured via\n+                `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION`\n+                and\n+                `RUST_TEST_TIME_DOCTEST` environment variables.\n+                Expected format of environment variable is\n+                `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+                `CRITICAL_TIME` here means the limit that should not be\n+                exceeded by test.\n+```\n+\n+Example of the environment variable format:\n+\n+```sh\n+RUST_TEST_TIME_UNIT=100,200\n+```\n+\n+where 100 stands for warn time, and 200 stands for critical time.\n+\n+## Examples\n+\n+```sh\n+cargo test --tests -- -Zunstable-options --report-time\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n+     Running target/debug/deps/example-27fb188025bec02c\n+\n+running 3 tests\n+test tests::unit_test_quick ... ok <0.000s>\n+test tests::unit_test_warn ... ok <0.055s>\n+test tests::unit_test_critical ... ok <0.110s>\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+\n+     Running target/debug/deps/tests-cedb06f6526d15d9\n+\n+running 3 tests\n+test unit_test_quick ... ok <0.000s>\n+test unit_test_warn ... ok <0.550s>\n+test unit_test_critical ... ok <1.100s>\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+```"}, {"sha": "05e6f36c958690079010c918040608b9a069c31c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -705,6 +705,7 @@ impl Tester for Collector {\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n                 allow_fail: config.allow_fail,\n+                test_type: testing::TestType::DocTest,\n             },\n             testfn: testing::DynTestFn(box move || {\n                 let res = run_test("}, {"sha": "d4638c45473b1afc9d83b218dd2d7ab4b26ba992", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -106,6 +106,11 @@ pub fn expand_test_or_bench(\n         cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\", sp), cx.ident_of(name, sp)])\n     };\n \n+    // creates test::TestType::$name\n+    let test_type_path = |name| {\n+        cx.path(sp, vec![test_id, cx.ident_of(\"TestType\", sp), cx.ident_of(name, sp)])\n+    };\n+\n     // creates $name: $expr\n     let field = |name, expr| cx.field_imm(sp, cx.ident_of(name, sp), expr);\n \n@@ -181,6 +186,17 @@ pub fn expand_test_or_bench(\n                             cx.expr_path(should_panic_path(\"YesWithMessage\")),\n                             vec![cx.expr_str(sp, sym)]),\n                     }),\n+                    // test_type: ...\n+                    field(\"test_type\", match test_type(cx) {\n+                        // test::TestType::UnitTest\n+                        TestType::UnitTest => cx.expr_path(test_type_path(\"UnitTest\")),\n+                        // test::TestType::IntegrationTest\n+                        TestType::IntegrationTest => cx.expr_path(\n+                            test_type_path(\"IntegrationTest\")\n+                        ),\n+                        // test::TestPath::Unknown\n+                        TestType::Unknown => cx.expr_path(test_type_path(\"Unknown\")),\n+                    }),\n                 // },\n                 ])),\n                 // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n@@ -261,6 +277,34 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n     }\n }\n \n+enum TestType {\n+    UnitTest,\n+    IntegrationTest,\n+    Unknown,\n+}\n+\n+/// Attempts to determine the type of test.\n+/// Since doctests are created without macro expanding, only possible variants here\n+/// are `UnitTest`, `IntegrationTest` or `Unknown`.\n+fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n+    // Root path from context contains the topmost sources directory of the crate.\n+    // I.e., for `project` with sources in `src` and tests in `tests` folders\n+    // (no matter how many nested folders lie inside),\n+    // there will be two different root paths: `/project/src` and `/project/tests`.\n+    let crate_path = cx.root_path.as_path();\n+\n+    if crate_path.ends_with(\"src\") {\n+        // `/src` folder contains unit-tests.\n+        TestType::UnitTest\n+    } else if crate_path.ends_with(\"tests\") {\n+        // `/tests` folder contains integration tests.\n+        TestType::IntegrationTest\n+    } else {\n+        // Crate layout doesn't match expected one, test type is unknown.\n+        TestType::Unknown\n+    }\n+}\n+\n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let ref sd = cx.parse_sess.span_diagnostic;"}, {"sha": "dcd733620bf90282cc50c5c835359450d1997bf8", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -94,6 +94,15 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 self.write_event(\"test\", desc.name.as_slice(), \"failed\", exec_time, stdout, None)\n             }\n \n+            TrTimedFail => self.write_event(\n+                \"test\",\n+                desc.name.as_slice(),\n+                \"failed\",\n+                exec_time,\n+                stdout,\n+                Some(r#\"\"reason\": \"time limit exceeded\"\"#),\n+            ),\n+\n             TrFailedMsg(ref m) => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),"}, {"sha": "2935b4c99cec42c68f76e5c1c0acc1cd6a1f3d58", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 84, "deletions": 50, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -3,6 +3,7 @@ use super::*;\n pub(crate) struct PrettyFormatter<T> {\n     out: OutputLocation<T>,\n     use_color: bool,\n+    time_options: Option<TestTimeOptions>,\n \n     /// Number of columns to fill when aligning names\n     max_name_len: usize,\n@@ -16,12 +17,14 @@ impl<T: Write> PrettyFormatter<T> {\n         use_color: bool,\n         max_name_len: usize,\n         is_multithreaded: bool,\n+        time_options: Option<TestTimeOptions>,\n     ) -> Self {\n         PrettyFormatter {\n             out,\n             use_color,\n             max_name_len,\n             is_multithreaded,\n+            time_options\n         }\n     }\n \n@@ -30,20 +33,24 @@ impl<T: Write> PrettyFormatter<T> {\n         &self.out\n     }\n \n-    pub fn write_ok(&mut self, exec_time: Option<&TestExecTime>) -> io::Result<()> {\n-        self.write_short_result(\"ok\", term::color::GREEN, exec_time)\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ok\", term::color::GREEN)\n     }\n \n-    pub fn write_failed(&mut self, exec_time: Option<&TestExecTime>) -> io::Result<()> {\n-        self.write_short_result(\"FAILED\", term::color::RED, exec_time)\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED\", term::color::RED)\n     }\n \n-    pub fn write_ignored(&mut self, exec_time: Option<&TestExecTime>) -> io::Result<()> {\n-        self.write_short_result(\"ignored\", term::color::YELLOW, exec_time)\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ignored\", term::color::YELLOW)\n     }\n \n-    pub fn write_allowed_fail(&mut self, exec_time: Option<&TestExecTime>) -> io::Result<()> {\n-        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW, exec_time)\n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_time_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED (time limit exceeded)\", term::color::RED)\n     }\n \n     pub fn write_bench(&mut self) -> io::Result<()> {\n@@ -54,13 +61,8 @@ impl<T: Write> PrettyFormatter<T> {\n         &mut self,\n         result: &str,\n         color: term::color::Color,\n-        exec_time: Option<&TestExecTime>,\n     ) -> io::Result<()> {\n-        self.write_pretty(result, color)?;\n-        if let Some(exec_time) = exec_time {\n-            self.write_plain(format!(\" {}\", exec_time))?;\n-        }\n-        self.write_plain(\"\\n\")\n+        self.write_pretty(result, color)\n     }\n \n     pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n@@ -88,12 +90,48 @@ impl<T: Write> PrettyFormatter<T> {\n         self.out.flush()\n     }\n \n-    pub fn write_successes(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n-        self.write_plain(\"\\nsuccesses:\\n\")?;\n-        let mut successes = Vec::new();\n+    fn write_time(\n+        &mut self,\n+        desc: &TestDesc,\n+        exec_time: Option<&TestExecTime>\n+    ) -> io::Result<()> {\n+        if let (Some(opts), Some(time)) = (self.time_options, exec_time) {\n+            let time_str = format!(\" <{}>\", time);\n+\n+            let color = if opts.colored {\n+                if opts.is_critical(desc, time) {\n+                    Some(term::color::RED)\n+                } else if opts.is_warn(desc, time) {\n+                    Some(term::color::YELLOW)\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n+\n+            match color {\n+                Some(color) => self.write_pretty(&time_str, color)?,\n+                None => self.write_plain(&time_str)?\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn write_results(\n+        &mut self,\n+        inputs: &Vec<(TestDesc, Vec<u8>)>,\n+        results_type: &str\n+    ) -> io::Result<()> {\n+        let results_out_str = format!(\"\\n{}:\\n\", results_type);\n+\n+        self.write_plain(&results_out_str)?;\n+\n+        let mut results = Vec::new();\n         let mut stdouts = String::new();\n-        for &(ref f, ref stdout) in &state.not_failures {\n-            successes.push(f.name.to_string());\n+        for &(ref f, ref stdout) in inputs {\n+            results.push(f.name.to_string());\n             if !stdout.is_empty() {\n                 stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n@@ -106,38 +144,24 @@ impl<T: Write> PrettyFormatter<T> {\n             self.write_plain(&stdouts)?;\n         }\n \n-        self.write_plain(\"\\nsuccesses:\\n\")?;\n-        successes.sort();\n-        for name in &successes {\n+        self.write_plain(&results_out_str)?;\n+        results.sort();\n+        for name in &results {\n             self.write_plain(&format!(\"    {}\\n\", name))?;\n         }\n         Ok(())\n     }\n \n+    pub fn write_successes(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_results(&state.not_failures, \"successes\")\n+    }\n+\n     pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n-        self.write_plain(\"\\nfailures:\\n\")?;\n-        let mut failures = Vec::new();\n-        let mut fail_out = String::new();\n-        for &(ref f, ref stdout) in &state.failures {\n-            failures.push(f.name.to_string());\n-            if !stdout.is_empty() {\n-                fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n-                let output = String::from_utf8_lossy(stdout);\n-                fail_out.push_str(&output);\n-                fail_out.push_str(\"\\n\");\n-            }\n-        }\n-        if !fail_out.is_empty() {\n-            self.write_plain(\"\\n\")?;\n-            self.write_plain(&fail_out)?;\n-        }\n+        self.write_results(&state.failures, \"failures\")\n+    }\n \n-        self.write_plain(\"\\nfailures:\\n\")?;\n-        failures.sort();\n-        for name in &failures {\n-            self.write_plain(&format!(\"    {}\\n\", name))?;\n-        }\n-        Ok(())\n+    pub fn write_time_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_results(&state.time_failures, \"failures (time limit exceeded)\")\n     }\n \n     fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n@@ -179,15 +203,19 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         }\n \n         match *result {\n-            TrOk => self.write_ok(exec_time),\n-            TrFailed | TrFailedMsg(_) => self.write_failed(exec_time),\n-            TrIgnored => self.write_ignored(exec_time),\n-            TrAllowedFail => self.write_allowed_fail(exec_time),\n+            TrOk => self.write_ok()?,\n+            TrFailed | TrFailedMsg(_) => self.write_failed()?,\n+            TrIgnored => self.write_ignored()?,\n+            TrAllowedFail => self.write_allowed_fail()?,\n             TrBench(ref bs) => {\n                 self.write_bench()?;\n-                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+                self.write_plain(&format!(\": {}\", fmt_bench_samples(bs)))?;\n             }\n+            TrTimedFail => self.write_time_failed()?,\n         }\n+\n+        self.write_time(desc, exec_time)?;\n+        self.write_plain(\"\\n\")\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n@@ -207,7 +235,13 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         }\n         let success = state.failed == 0;\n         if !success {\n-            self.write_failures(state)?;\n+            if !state.failures.is_empty() {\n+                self.write_failures(state)?;\n+            }\n+\n+            if !state.time_failures.is_empty() {\n+                self.write_time_failures(state)?;\n+            }\n         }\n \n         self.write_plain(\"\\ntest result: \")?;"}, {"sha": "8914e7b6b5685e32fc4fd77a736b88f82a75f59c", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -180,7 +180,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n     ) -> io::Result<()> {\n         match *result {\n             TrOk => self.write_ok(),\n-            TrFailed | TrFailedMsg(_) => self.write_failed(),\n+            TrFailed | TrFailedMsg(_) | TrTimedFail => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n             TrAllowedFail => self.write_allowed_fail(),\n             TrBench(ref bs) => {"}, {"sha": "5a77413b2cbbf8feec1cefe1785681a0684687ba", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 378, "deletions": 60, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -56,6 +56,7 @@ use std::panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo};\n use std::path::PathBuf;\n use std::process;\n use std::process::{ExitStatus, Command, Termination};\n+use std::str::FromStr;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n@@ -75,13 +76,54 @@ const SECONDARY_TEST_INVOKER_VAR: &'static str = \"__RUST_TEST_INVOKE\";\n const TR_OK: i32 = 50;\n const TR_FAILED: i32 = 51;\n \n+/// This small module contains constants used by `report-time` option.\n+/// Those constants values will be used if corresponding environment variables are not set.\n+///\n+/// To override values for unit-tests, use a constant `RUST_TEST_TIME_UNIT`,\n+/// To override values for integration tests, use a constant `RUST_TEST_TIME_INTEGRATION`,\n+/// To override values for doctests, use a constant `RUST_TEST_TIME_DOCTEST`.\n+///\n+/// Example of the expected format is `RUST_TEST_TIME_xxx=100,200`, where 100 means\n+/// warn time, and 200 means critical time.\n+pub mod time_constants {\n+    use std::time::Duration;\n+    use super::TEST_WARN_TIMEOUT_S;\n+\n+    /// Environment variable for overriding default threshold for unit-tests.\n+    pub const UNIT_ENV_NAME: &str = \"RUST_TEST_TIME_UNIT\";\n+\n+    // Unit tests are supposed to be really quick.\n+    pub const UNIT_WARN: Duration = Duration::from_millis(50);\n+    pub const UNIT_CRITICAL: Duration = Duration::from_millis(100);\n+\n+    /// Environment variable for overriding default threshold for unit-tests.\n+    pub const INTEGRATION_ENV_NAME: &str = \"RUST_TEST_TIME_INTEGRATION\";\n+\n+    // Integration tests may have a lot of work, so they can take longer to execute.\n+    pub const INTEGRATION_WARN: Duration = Duration::from_millis(500);\n+    pub const INTEGRATION_CRITICAL: Duration = Duration::from_millis(1000);\n+\n+    /// Environment variable for overriding default threshold for unit-tests.\n+    pub const DOCTEST_ENV_NAME: &str = \"RUST_TEST_TIME_DOCTEST\";\n+\n+    // Doctests are similar to integration tests, because they can include a lot of\n+    // initialization code.\n+    pub const DOCTEST_WARN: Duration = INTEGRATION_WARN;\n+    pub const DOCTEST_CRITICAL: Duration = INTEGRATION_CRITICAL;\n+\n+    // Do not suppose anything about unknown tests, base limits on the\n+    // `TEST_WARN_TIMEOUT_S` constant.\n+    pub const UNKNOWN_WARN: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S);\n+    pub const UNKNOWN_CRITICAL: Duration = Duration::from_secs(TEST_WARN_TIMEOUT_S * 2);\n+}\n+\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use crate::{\n         assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n         Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, RunStrategy,\n         ShouldPanic, StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n-        TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n+        TestOpts, TestTimeOptions, TestType, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n     };\n }\n \n@@ -97,6 +139,21 @@ pub enum Concurrent {\n     No,\n }\n \n+/// Type of the test according to the [rust book](https://doc.rust-lang.org/cargo/guide/tests.html)\n+/// conventions.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum TestType {\n+    /// Unit-tests are expected to be in the `src` folder of the crate.\n+    UnitTest,\n+    /// Integration-style tests are expected to be in the `tests` folder of the crate.\n+    IntegrationTest,\n+    /// Doctests are created by the `librustdoc` manually, so it's a different type of test.\n+    DocTest,\n+    /// Tests for the sources that don't follow the project layout convention\n+    /// (e.g. tests in raw `main.rs` compiled by calling `rustc --test` directly).\n+    Unknown,\n+}\n+\n // The name of a test. By convention this follows the rules for rust\n // paths; i.e., it should be a series of identifiers separated by double\n // colons. This way if some test runner wants to arrange the tests\n@@ -232,6 +289,7 @@ pub struct TestDesc {\n     pub ignore: bool,\n     pub should_panic: ShouldPanic,\n     pub allow_fail: bool,\n+    pub test_type: TestType,\n }\n \n #[derive(Debug)]\n@@ -403,6 +461,141 @@ pub enum RunIgnored {\n     Only,\n }\n \n+/// Structure denoting time limits for test execution.\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n+pub struct TimeThreshold {\n+    pub warn: Duration,\n+    pub critical: Duration,\n+}\n+\n+impl TimeThreshold {\n+    /// Creates a new `TimeThreshold` instance with provided durations.\n+    pub fn new(warn: Duration, critical: Duration) -> Self {\n+        Self {\n+            warn,\n+            critical,\n+        }\n+    }\n+\n+    /// Attempts to create a `TimeThreshold` instance with values obtained\n+    /// from the environment variable, and returns `None` if the variable\n+    /// is not set.\n+    /// Environment variable format is expected to match `\\d+,\\d+`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if variable with provided name is set but contains inappropriate\n+    /// value.\n+    pub fn from_env_var(env_var_name: &str) -> Option<Self> {\n+        let durations_str = env::var(env_var_name).ok()?;\n+\n+        // Split string into 2 substrings by comma and try to parse numbers.\n+        let mut durations = durations_str\n+            .splitn(2, ',')\n+            .map(|v| {\n+                u64::from_str(v).unwrap_or_else(|_| {\n+                    panic!(\n+                        \"Duration value in variable {} is expected to be a number, but got {}\",\n+                        env_var_name, v\n+                    )\n+                })\n+            });\n+\n+        // Callback to be called if the environment variable has unexpected structure.\n+        let panic_on_incorrect_value = || {\n+            panic!(\n+                \"Duration variable {} expected to have 2 numbers separated by comma, but got {}\",\n+                env_var_name, durations_str\n+            );\n+        };\n+\n+        let (warn, critical) = (\n+            durations.next().unwrap_or_else(panic_on_incorrect_value),\n+            durations.next().unwrap_or_else(panic_on_incorrect_value)\n+        );\n+\n+        if warn > critical {\n+            panic!(\"Test execution warn time should be less or equal to the critical time\");\n+        }\n+\n+        Some(Self::new(Duration::from_millis(warn), Duration::from_millis(critical)))\n+    }\n+}\n+\n+/// Structure with parameters for calculating test execution time.\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]\n+pub struct TestTimeOptions {\n+    /// Denotes if the test critical execution time limit excess should be considered\n+    /// a test failure.\n+    pub error_on_excess: bool,\n+    pub colored: bool,\n+    pub unit_threshold: TimeThreshold,\n+    pub integration_threshold: TimeThreshold,\n+    pub doctest_threshold: TimeThreshold,\n+}\n+\n+impl TestTimeOptions {\n+    pub fn new_from_env(error_on_excess: bool, colored: bool) -> Self {\n+        let unit_threshold =\n+            TimeThreshold::from_env_var(time_constants::UNIT_ENV_NAME)\n+                .unwrap_or_else(Self::default_unit);\n+\n+        let integration_threshold =\n+            TimeThreshold::from_env_var(time_constants::INTEGRATION_ENV_NAME)\n+                .unwrap_or_else(Self::default_integration);\n+\n+        let doctest_threshold =\n+            TimeThreshold::from_env_var(time_constants::DOCTEST_ENV_NAME)\n+                .unwrap_or_else(Self::default_doctest);\n+\n+        Self {\n+            error_on_excess,\n+            colored,\n+            unit_threshold,\n+            integration_threshold,\n+            doctest_threshold,\n+        }\n+    }\n+\n+    pub fn is_warn(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n+        exec_time.0 >= self.warn_time(test)\n+    }\n+\n+    pub fn is_critical(&self, test: &TestDesc, exec_time: &TestExecTime) -> bool {\n+        exec_time.0 >= self.critical_time(test)\n+    }\n+\n+    fn warn_time(&self, test: &TestDesc) -> Duration {\n+        match test.test_type {\n+            TestType::UnitTest => self.unit_threshold.warn,\n+            TestType::IntegrationTest => self.integration_threshold.warn,\n+            TestType::DocTest => self.doctest_threshold.warn,\n+            TestType::Unknown => time_constants::UNKNOWN_WARN,\n+        }\n+    }\n+\n+    fn critical_time(&self, test: &TestDesc) -> Duration {\n+        match test.test_type {\n+            TestType::UnitTest => self.unit_threshold.critical,\n+            TestType::IntegrationTest => self.integration_threshold.critical,\n+            TestType::DocTest => self.doctest_threshold.critical,\n+            TestType::Unknown => time_constants::UNKNOWN_CRITICAL,\n+        }\n+    }\n+\n+    fn default_unit() -> TimeThreshold {\n+        TimeThreshold::new(time_constants::UNIT_WARN, time_constants::UNIT_CRITICAL)\n+    }\n+\n+    fn default_integration() -> TimeThreshold {\n+        TimeThreshold::new(time_constants::INTEGRATION_WARN, time_constants::INTEGRATION_CRITICAL)\n+    }\n+\n+    fn default_doctest() -> TimeThreshold {\n+        TimeThreshold::new(time_constants::DOCTEST_WARN, time_constants::DOCTEST_CRITICAL)\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n@@ -418,12 +611,14 @@ pub struct TestOpts {\n     pub format: OutputFormat,\n     pub test_threads: Option<usize>,\n     pub skip: Vec<String>,\n-    pub report_time: bool,\n+    pub time_options: Option<TestTimeOptions>,\n     pub options: Options,\n }\n \n /// Result of parsing the options.\n pub type OptRes = Result<TestOpts, String>;\n+/// Result of parsing the option part.\n+type OptPartRes<T> = Result<Option<T>, String>;\n \n fn optgroups() -> getopts::Options {\n     let mut opts = getopts::Options::new();\n@@ -502,10 +697,35 @@ fn optgroups() -> getopts::Options {\n             unstable-options = Allow use of experimental features\",\n             \"unstable-options\",\n         )\n-        .optflag(\n+        .optflagopt(\n             \"\",\n             \"report-time\",\n-            \"Show execution time of each test. Not available for --format=terse\"\n+            \"Show execution time of each test. Awailable values:\n+            plain   = do not colorize the execution time (default);\n+            colored = colorize output according to the `color` parameter value;\n+\n+            Threshold values for colorized output can be configured via\n+            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n+            `RUST_TEST_TIME_DOCTEST` environment variables.\n+\n+            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+\n+            Not available for --format=terse\",\n+            \"plain|colored\"\n+        )\n+        .optflag(\n+            \"\",\n+            \"ensure-time\",\n+            \"Treat excess of the test execution time limit as error.\n+\n+            Threshold values for this option can be configured via\n+            `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION` and\n+            `RUST_TEST_TIME_DOCTEST` environment variables.\n+\n+            Expected format of environment variable is `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+\n+            `CRITICAL_TIME` here means the limit that should not be exceeded by test.\n+            \"\n         );\n     return opts;\n }\n@@ -554,6 +774,45 @@ fn is_nightly() -> bool {\n     bootstrap || !disable_unstable_features\n }\n \n+// Gets the option value and checks if unstable features are enabled.\n+macro_rules! unstable_optflag {\n+    ($matches:ident, $allow_unstable:ident, $option_name:literal) => {{\n+        let opt = $matches.opt_present($option_name);\n+        if !$allow_unstable && opt {\n+            return Some(Err(format!(\n+                \"The \\\"{}\\\" flag is only accepted on the nightly compiler\",\n+                $option_name\n+            )));\n+        }\n+\n+        opt\n+    }};\n+}\n+\n+// Gets the CLI options assotiated with `report-time` feature.\n+fn get_time_options(\n+    matches: &getopts::Matches,\n+    allow_unstable: bool)\n+-> Option<OptPartRes<TestTimeOptions>> {\n+    let report_time = unstable_optflag!(matches, allow_unstable, \"report-time\");\n+    let colored_opt_str = matches.opt_str(\"report-time\");\n+    let mut report_time_colored = report_time && colored_opt_str == Some(\"colored\".into());\n+    let ensure_test_time = unstable_optflag!(matches, allow_unstable, \"ensure-time\");\n+\n+    // If `ensure-test-time` option is provided, time output is enforced,\n+    // so user won't be confused if any of tests will silently fail.\n+    let options = if report_time || ensure_test_time {\n+        if ensure_test_time && !report_time {\n+            report_time_colored = true;\n+        }\n+        Some(TestTimeOptions::new_from_env(ensure_test_time, report_time_colored))\n+    } else {\n+        None\n+    };\n+\n+    Some(Ok(options))\n+}\n+\n // Parses command line arguments into test options\n pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let mut allow_unstable = false;\n@@ -592,26 +851,9 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         None\n     };\n \n-    let exclude_should_panic = matches.opt_present(\"exclude-should-panic\");\n-    if !allow_unstable && exclude_should_panic {\n-        return Some(Err(\n-            \"The \\\"exclude-should-panic\\\" flag is only accepted on the nightly compiler\".into(),\n-        ));\n-    }\n+    let exclude_should_panic = unstable_optflag!(matches, allow_unstable, \"exclude-should-panic\");\n \n-    let include_ignored = matches.opt_present(\"include-ignored\");\n-    if !allow_unstable && include_ignored {\n-        return Some(Err(\n-            \"The \\\"include-ignored\\\" flag is only accepted on the nightly compiler\".into(),\n-        ));\n-    }\n-\n-    let report_time = matches.opt_present(\"report-time\");\n-    if !allow_unstable && report_time {\n-        return Some(Err(\n-            \"The \\\"report-time\\\" flag is only accepted on the nightly compiler\".into(),\n-        ));\n-    }\n+    let include_ignored = unstable_optflag!(matches, allow_unstable, \"include-ignored\");\n \n     let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n         (true, true) => {\n@@ -641,6 +883,12 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         };\n     }\n \n+    let time_options = match get_time_options(&matches, allow_unstable) {\n+        Some(Ok(val)) => val,\n+        Some(Err(e)) => return Some(Err(e)),\n+        None => panic!(\"Unexpected output from `get_time_options`\"),\n+    };\n+\n     let test_threads = match matches.opt_str(\"test-threads\") {\n         Some(n_str) => match n_str.parse::<usize>() {\n             Ok(0) => return Some(Err(\"argument for --test-threads must not be 0\".to_string())),\n@@ -706,27 +954,28 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         format,\n         test_threads,\n         skip: matches.opt_strs(\"skip\"),\n-        report_time,\n+        time_options,\n         options: Options::new().display_output(matches.opt_present(\"show-output\")),\n     };\n \n     Some(Ok(test_opts))\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq)]\n pub struct BenchSamples {\n     ns_iter_summ: stats::Summary,\n     mb_s: usize,\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq)]\n pub enum TestResult {\n     TrOk,\n     TrFailed,\n     TrFailedMsg(String),\n     TrIgnored,\n     TrAllowedFail,\n     TrBench(BenchSamples),\n+    TrTimedFail,\n }\n \n unsafe impl Send for TestResult {}\n@@ -774,6 +1023,7 @@ struct ConsoleTestState {\n     metrics: MetricMap,\n     failures: Vec<(TestDesc, Vec<u8>)>,\n     not_failures: Vec<(TestDesc, Vec<u8>)>,\n+    time_failures: Vec<(TestDesc, Vec<u8>)>,\n     options: Options,\n }\n \n@@ -796,6 +1046,7 @@ impl ConsoleTestState {\n             metrics: MetricMap::new(),\n             failures: Vec::new(),\n             not_failures: Vec::new(),\n+            time_failures: Vec::new(),\n             options: opts.options,\n         })\n     }\n@@ -831,11 +1082,12 @@ impl ConsoleTestState {\n                 TrIgnored => \"ignored\".to_owned(),\n                 TrAllowedFail => \"failed (allowed)\".to_owned(),\n                 TrBench(ref bs) => fmt_bench_samples(bs),\n+                TrTimedFail => \"failed (time limit exceeded)\".to_owned(),\n             },\n             test.name,\n         ))?;\n         if let Some(exec_time) = exec_time {\n-            self.write_log(|| format!(\" {}\", exec_time))?;\n+            self.write_log(|| format!(\" <{}>\", exec_time))?;\n         }\n         self.write_log(|| \"\\n\")\n     }\n@@ -993,6 +1245,10 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                         stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n                         st.failures.push((test, stdout));\n                     }\n+                    TrTimedFail => {\n+                        st.failed += 1;\n+                        st.time_failures.push((test, stdout));\n+                    }\n                 }\n                 Ok(())\n             }\n@@ -1018,6 +1274,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n             use_color(opts),\n             max_name_len,\n             is_multithreaded,\n+            opts.time_options,\n         )),\n         OutputFormat::Terse => Box::new(TerseFormatter::new(\n             output,\n@@ -1487,22 +1744,35 @@ pub fn run_test(\n         return;\n     }\n \n+    struct TestRunOpts {\n+        pub strategy: RunStrategy,\n+        pub nocapture: bool,\n+        pub concurrency: Concurrent,\n+        pub time: Option<TestTimeOptions>,\n+    }\n+\n     fn run_test_inner(\n         desc: TestDesc,\n-        nocapture: bool,\n-        report_time: bool,\n-        strategy: RunStrategy,\n         monitor_ch: Sender<MonitorMsg>,\n         testfn: Box<dyn FnOnce() + Send>,\n-        concurrency: Concurrent,\n+        opts: TestRunOpts,\n     ) {\n+        let concurrency = opts.concurrency;\n         let name = desc.name.clone();\n \n         let runtest = move || {\n-            match strategy {\n+            match opts.strategy {\n                 RunStrategy::InProcess =>\n-                    run_test_in_process(desc, nocapture, report_time, testfn, monitor_ch),\n-                RunStrategy::SpawnPrimary => spawn_test_subprocess(desc, report_time, monitor_ch),\n+                    run_test_in_process(\n+                        desc,\n+                        opts.nocapture,\n+                        opts.time.is_some(),\n+                        testfn,\n+                        monitor_ch,\n+                        opts.time\n+                    ),\n+                RunStrategy::SpawnPrimary =>\n+                    spawn_test_subprocess(desc, opts.time.is_some(), monitor_ch, opts.time),\n             }\n         };\n \n@@ -1518,6 +1788,13 @@ pub fn run_test(\n         }\n     }\n \n+    let test_run_opts = TestRunOpts {\n+        strategy,\n+        nocapture: opts.nocapture,\n+        concurrency,\n+        time: opts.time_options\n+    };\n+\n     match testfn {\n         DynBenchFn(bencher) => {\n             // Benchmarks aren't expected to panic, so we run them all in-process.\n@@ -1538,22 +1815,16 @@ pub fn run_test(\n             };\n             run_test_inner(\n                 desc,\n-                opts.nocapture,\n-                opts.report_time,\n-                strategy,\n                 monitor_ch,\n                 Box::new(move || __rust_begin_short_backtrace(f)),\n-                concurrency\n+                test_run_opts,\n             );\n         }\n         StaticTestFn(f) => run_test_inner(\n             desc,\n-            opts.nocapture,\n-            opts.report_time,\n-            strategy,\n             monitor_ch,\n             Box::new(move || __rust_begin_short_backtrace(f)),\n-            concurrency,\n+            test_run_opts,\n         ),\n     }\n }\n@@ -1564,10 +1835,13 @@ fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n     f()\n }\n \n-fn calc_result<'a>(desc: &TestDesc,\n-                   task_result: Result<(), &'a (dyn Any + 'static + Send)>)\n--> TestResult {\n-    match (&desc.should_panic, task_result) {\n+fn calc_result<'a>(\n+    desc: &TestDesc,\n+    task_result: Result<(), &'a (dyn Any + 'static + Send)>,\n+    time_opts: &Option<TestTimeOptions>,\n+    exec_time: &Option<TestExecTime>\n+) -> TestResult {\n+    let result = match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n             if err\n@@ -1589,23 +1863,59 @@ fn calc_result<'a>(desc: &TestDesc,\n         (&ShouldPanic::Yes, Ok(())) => TrFailedMsg(\"test did not panic as expected\".to_string()),\n         _ if desc.allow_fail => TrAllowedFail,\n         _ => TrFailed,\n+    };\n+\n+    // If test is already failed (or allowed to fail), do not change the result.\n+    if result != TrOk {\n+        return result;\n     }\n+\n+    // Check if test is failed due to timeout.\n+    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n+        if opts.error_on_excess && opts.is_critical(desc, time) {\n+            return TrTimedFail;\n+        }\n+    }\n+\n+    result\n }\n \n-fn get_result_from_exit_code(desc: &TestDesc, code: i32) -> TestResult {\n-    match (desc.allow_fail, code) {\n+fn get_result_from_exit_code(\n+    desc: &TestDesc,\n+    code: i32,\n+    time_opts: &Option<TestTimeOptions>,\n+    exec_time: &Option<TestExecTime>,\n+) -> TestResult {\n+    let result = match (desc.allow_fail, code) {\n         (_, TR_OK) => TrOk,\n         (true, TR_FAILED) => TrAllowedFail,\n         (false, TR_FAILED) => TrFailed,\n         (_, _) => TrFailedMsg(format!(\"got unexpected return code {}\", code)),\n+    };\n+\n+    // If test is already failed (or allowed to fail), do not change the result.\n+    if result != TrOk {\n+        return result;\n     }\n+\n+    // Check if test is failed due to timeout.\n+    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n+        if opts.error_on_excess && opts.is_critical(desc, time) {\n+            return TrTimedFail;\n+        }\n+    }\n+\n+    result\n }\n \n-fn run_test_in_process(desc: TestDesc,\n-                       nocapture: bool,\n-                       report_time: bool,\n-                       testfn: Box<dyn FnOnce() + Send>,\n-                       monitor_ch: Sender<MonitorMsg>) {\n+fn run_test_in_process(\n+    desc: TestDesc,\n+    nocapture: bool,\n+    report_time: bool,\n+    testfn: Box<dyn FnOnce() + Send>,\n+    monitor_ch: Sender<MonitorMsg>,\n+    time_opts: Option<TestTimeOptions>,\n+) {\n     // Buffer for capturing standard I/O\n     let data = Arc::new(Mutex::new(Vec::new()));\n \n@@ -1635,14 +1945,19 @@ fn run_test_in_process(desc: TestDesc,\n     }\n \n     let test_result = match result {\n-        Ok(()) => calc_result(&desc, Ok(())),\n-        Err(e) => calc_result(&desc, Err(e.as_ref())),\n+        Ok(()) => calc_result(&desc, Ok(()), &time_opts, &exec_time),\n+        Err(e) => calc_result(&desc, Err(e.as_ref()), &time_opts, &exec_time),\n     };\n     let stdout = data.lock().unwrap().to_vec();\n     monitor_ch.send((desc.clone(), test_result, exec_time, stdout)).unwrap();\n }\n \n-fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<MonitorMsg>) {\n+fn spawn_test_subprocess(\n+    desc: TestDesc,\n+    report_time: bool,\n+    monitor_ch: Sender<MonitorMsg>,\n+    time_opts: Option<TestTimeOptions>,\n+) {\n     let (result, test_output, exec_time) = (|| {\n         let args = env::args().collect::<Vec<_>>();\n         let current_exe = &args[0];\n@@ -1673,7 +1988,7 @@ fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<M\n \n         let result = match (|| -> Result<TestResult, String> {\n             let exit_code = get_exit_code(status)?;\n-            Ok(get_result_from_exit_code(&desc, exit_code))\n+            Ok(get_result_from_exit_code(&desc, exit_code, &time_opts, &exec_time))\n         })() {\n             Ok(r) => r,\n             Err(e) => {\n@@ -1688,12 +2003,15 @@ fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<M\n     monitor_ch.send((desc.clone(), result, exec_time, test_output)).unwrap();\n }\n \n-fn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box<dyn FnOnce() + Send>) -> ! {\n+fn run_test_in_spawned_subprocess(\n+    desc: TestDesc,\n+    testfn: Box<dyn FnOnce() + Send>,\n+) -> ! {\n     let builtin_panic_hook = panic::take_hook();\n     let record_result = Arc::new(move |panic_info: Option<&'_ PanicInfo<'_>>| {\n         let test_result = match panic_info {\n-            Some(info) => calc_result(&desc, Err(info.payload())),\n-            None => calc_result(&desc, Ok(())),\n+            Some(info) => calc_result(&desc, Err(info.payload()), &None, &None),\n+            None => calc_result(&desc, Ok(()), &None, &None),\n         };\n \n         // We don't support serializing TrFailedMsg, so just"}, {"sha": "aab8d012fdf687f584f586cf0ff2d833c921393e", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -115,7 +115,7 @@ pub trait Stats {\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n-#[derive(Clone, PartialEq, Copy)]\n+#[derive(Debug, Clone, PartialEq, Copy)]\n #[allow(missing_docs)]\n pub struct Summary {\n     pub sum: f64,"}, {"sha": "880d02a28ff06e9ff5da36ae9c08f37d3dbc53d0", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 120, "deletions": 5, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b861bed17ba2ce001911f78a5316f56466642f/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=80b861bed17ba2ce001911f78a5316f56466642f", "patch": "@@ -2,10 +2,11 @@ use super::*;\n \n use crate::test::{\n     filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored, RunStrategy,\n-    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailedMsg,\n-    TrIgnored, TrOk,\n+    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TestTimeOptions,\n+    TestType, TrFailedMsg, TrIgnored, TrOk,\n };\n use std::sync::mpsc::channel;\n+use std::time::Duration;\n \n impl TestOpts {\n     fn new() -> TestOpts {\n@@ -23,7 +24,7 @@ impl TestOpts {\n             format: OutputFormat::Pretty,\n             test_threads: None,\n             skip: vec![],\n-            report_time: false,\n+            time_options: None,\n             options: Options::new(),\n         }\n     }\n@@ -37,6 +38,7 @@ fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n                 allow_fail: false,\n+                test_type: TestType::Unknown,\n             },\n             testfn: DynTestFn(Box::new(move || {})),\n         },\n@@ -46,6 +48,7 @@ fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n                 ignore: false,\n                 should_panic: ShouldPanic::No,\n                 allow_fail: false,\n+                test_type: TestType::Unknown,\n             },\n             testfn: DynTestFn(Box::new(move || {})),\n         },\n@@ -63,6 +66,7 @@ pub fn do_not_run_ignored_tests() {\n             ignore: true,\n             should_panic: ShouldPanic::No,\n             allow_fail: false,\n+            test_type: TestType::Unknown,\n         },\n         testfn: DynTestFn(Box::new(f)),\n     };\n@@ -81,6 +85,7 @@ pub fn ignored_tests_result_in_ignored() {\n             ignore: true,\n             should_panic: ShouldPanic::No,\n             allow_fail: false,\n+            test_type: TestType::Unknown,\n         },\n         testfn: DynTestFn(Box::new(f)),\n     };\n@@ -101,6 +106,7 @@ fn test_should_panic() {\n             ignore: false,\n             should_panic: ShouldPanic::Yes,\n             allow_fail: false,\n+            test_type: TestType::Unknown,\n         },\n         testfn: DynTestFn(Box::new(f)),\n     };\n@@ -121,6 +127,7 @@ fn test_should_panic_good_message() {\n             ignore: false,\n             should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n             allow_fail: false,\n+            test_type: TestType::Unknown,\n         },\n         testfn: DynTestFn(Box::new(f)),\n     };\n@@ -143,6 +150,7 @@ fn test_should_panic_bad_message() {\n             ignore: false,\n             should_panic: ShouldPanic::YesWithMessage(expected),\n             allow_fail: false,\n+            test_type: TestType::Unknown,\n         },\n         testfn: DynTestFn(Box::new(f)),\n     };\n@@ -161,6 +169,7 @@ fn test_should_panic_but_succeeds() {\n             ignore: false,\n             should_panic: ShouldPanic::Yes,\n             allow_fail: false,\n+            test_type: TestType::Unknown,\n         },\n         testfn: DynTestFn(Box::new(f)),\n     };\n@@ -178,11 +187,18 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n             ignore: false,\n             should_panic: ShouldPanic::No,\n             allow_fail: false,\n+            test_type: TestType::Unknown,\n         },\n         testfn: DynTestFn(Box::new(f)),\n     };\n+    let time_options = if report_time {\n+        Some(TestTimeOptions::default())\n+    } else {\n+        None\n+    };\n+\n     let test_opts = TestOpts {\n-        report_time,\n+        time_options,\n         ..TestOpts::new()\n     };\n     let (tx, rx) = channel();\n@@ -203,6 +219,97 @@ fn test_should_report_time() {\n     assert!(exec_time.is_some());\n }\n \n+fn time_test_failure_template(test_type: TestType) -> TestResult {\n+    fn f() {}\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+            test_type\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    // `Default` will initialize all the thresholds to 0 milliseconds.\n+    let mut time_options = TestTimeOptions::default();\n+    time_options.error_on_excess = true;\n+\n+    let test_opts = TestOpts {\n+        time_options: Some(time_options),\n+        ..TestOpts::new()\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    let (_, result, _, _) = rx.recv().unwrap();\n+\n+    result\n+}\n+\n+#[test]\n+fn test_error_on_exceed() {\n+    let types = [TestType::UnitTest, TestType::IntegrationTest, TestType::DocTest];\n+\n+    for test_type in types.into_iter() {\n+        let result = time_test_failure_template(*test_type);\n+\n+        assert_eq!(result, TestResult::TrTimedFail);\n+    }\n+\n+    // Check that for unknown tests thresholds aren't applied.\n+    let result = time_test_failure_template(TestType::Unknown);\n+    assert_eq!(result, TestResult::TrOk);\n+}\n+\n+fn typed_test_desc(test_type: TestType) -> TestDesc {\n+    TestDesc {\n+        name: StaticTestName(\"whatever\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+        test_type\n+    }\n+}\n+\n+fn test_exec_time(millis: u64) -> TestExecTime {\n+    TestExecTime(Duration::from_millis(millis))\n+}\n+\n+#[test]\n+fn test_time_options_threshold() {\n+    let unit = TimeThreshold::new(Duration::from_millis(50), Duration::from_millis(100));\n+    let integration = TimeThreshold::new(Duration::from_millis(500), Duration::from_millis(1000));\n+    let doc = TimeThreshold::new(Duration::from_millis(5000), Duration::from_millis(10000));\n+\n+    let options = TestTimeOptions {\n+        error_on_excess: false,\n+        colored: false,\n+        unit_threshold: unit.clone(),\n+        integration_threshold: integration.clone(),\n+        doctest_threshold: doc.clone(),\n+    };\n+\n+    let test_vector = [\n+        (TestType::UnitTest, unit.warn.as_millis() - 1, false, false),\n+        (TestType::UnitTest, unit.warn.as_millis(), true, false),\n+        (TestType::UnitTest, unit.critical.as_millis(), true, true),\n+        (TestType::IntegrationTest, integration.warn.as_millis() - 1, false, false),\n+        (TestType::IntegrationTest, integration.warn.as_millis(), true, false),\n+        (TestType::IntegrationTest, integration.critical.as_millis(), true, true),\n+        (TestType::DocTest, doc.warn.as_millis() - 1, false, false),\n+        (TestType::DocTest, doc.warn.as_millis(), true, false),\n+        (TestType::DocTest, doc.critical.as_millis(), true, true),\n+    ];\n+\n+    for (test_type, time, expected_warn, expected_critical) in test_vector.into_iter() {\n+        let test_desc = typed_test_desc(*test_type);\n+        let exec_time = test_exec_time(*time as u64);\n+\n+        assert_eq!(options.is_warn(&test_desc, &exec_time), *expected_warn);\n+        assert_eq!(options.is_critical(&test_desc, &exec_time), *expected_critical);\n+    }\n+}\n+\n #[test]\n fn parse_ignored_flag() {\n     let args = vec![\n@@ -284,6 +391,7 @@ pub fn exclude_should_panic_option() {\n             ignore: false,\n             should_panic: ShouldPanic::Yes,\n             allow_fail: false,\n+            test_type: TestType::Unknown,\n         },\n         testfn: DynTestFn(Box::new(move || {})),\n     });\n@@ -305,6 +413,7 @@ pub fn exact_filter_match() {\n                     ignore: false,\n                     should_panic: ShouldPanic::No,\n                     allow_fail: false,\n+                    test_type: TestType::Unknown,\n                 },\n                 testfn: DynTestFn(Box::new(move || {})),\n             })\n@@ -416,6 +525,7 @@ pub fn sort_tests() {\n                     ignore: false,\n                     should_panic: ShouldPanic::No,\n                     allow_fail: false,\n+                    test_type: TestType::Unknown,\n                 },\n                 testfn: DynTestFn(Box::new(testfn)),\n             };\n@@ -492,6 +602,7 @@ pub fn test_bench_no_iter() {\n         ignore: false,\n         should_panic: ShouldPanic::No,\n         allow_fail: false,\n+        test_type: TestType::Unknown,\n     };\n \n     crate::bench::benchmark(desc, tx, true, f);\n@@ -511,6 +622,7 @@ pub fn test_bench_iter() {\n         ignore: false,\n         should_panic: ShouldPanic::No,\n         allow_fail: false,\n+        test_type: TestType::Unknown,\n     };\n \n     crate::bench::benchmark(desc, tx, true, f);\n@@ -524,16 +636,18 @@ fn should_sort_failures_before_printing_them() {\n         ignore: false,\n         should_panic: ShouldPanic::No,\n         allow_fail: false,\n+        test_type: TestType::Unknown,\n     };\n \n     let test_b = TestDesc {\n         name: StaticTestName(\"b\"),\n         ignore: false,\n         should_panic: ShouldPanic::No,\n         allow_fail: false,\n+        test_type: TestType::Unknown,\n     };\n \n-    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false);\n+    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false, None);\n \n     let st = ConsoleTestState {\n         log_out: None,\n@@ -548,6 +662,7 @@ fn should_sort_failures_before_printing_them() {\n         failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n         options: Options::new(),\n         not_failures: Vec::new(),\n+        time_failures: Vec::new(),\n     };\n \n     out.write_failures(&st).unwrap();"}]}