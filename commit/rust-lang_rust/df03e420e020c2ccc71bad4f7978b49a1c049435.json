{"sha": "df03e420e020c2ccc71bad4f7978b49a1c049435", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMDNlNDIwZTAyMGMyY2NjNzFiYWQ0Zjc5NzhiNDlhMWMwNDk0MzU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-08T00:44:16Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-10T10:16:06Z"}, "message": "resolve: Track whole parent scope in the visitors\n\nInstead of tracking current module and other components separately.\n(`ParentScope` includes the module as a component.)", "tree": {"sha": "f0b2ad3399cdb9b069b6124531d528c13ca0fa9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0b2ad3399cdb9b069b6124531d528c13ca0fa9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df03e420e020c2ccc71bad4f7978b49a1c049435", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df03e420e020c2ccc71bad4f7978b49a1c049435", "html_url": "https://github.com/rust-lang/rust/commit/df03e420e020c2ccc71bad4f7978b49a1c049435", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df03e420e020c2ccc71bad4f7978b49a1c049435/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "html_url": "https://github.com/rust-lang/rust/commit/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57"}], "stats": {"total": 174, "additions": 78, "deletions": 96}, "files": [{"sha": "9f6f36e0aa419c9dfaa08b79da3787f9fd587e70", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 40, "deletions": 57, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/df03e420e020c2ccc71bad4f7978b49a1c049435/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df03e420e020c2ccc71bad4f7978b49a1c049435/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=df03e420e020c2ccc71bad4f7978b49a1c049435", "patch": "@@ -332,7 +332,8 @@ impl<'a> Resolver<'a> {\n \n impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, parent_scope: &ParentScope<'a>) {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item) {\n+        let parent_scope = &self.parent_scope.clone();\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n         let ident = item.ident.gensym_if_underscore();\n@@ -439,7 +440,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                 self.module_map.insert(def_id, module);\n \n                 // Descend into the module.\n-                self.current_module = module;\n+                self.parent_scope.module = module;\n             }\n \n             // Handled in `rustc_metadata::{native_libs,link_args}`\n@@ -563,7 +564,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                                              expansion,\n                                              item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n-                self.current_module = module;\n+                self.parent_scope.module = module;\n             }\n \n             ItemKind::MacroDef(..) | ItemKind::Mac(_) => unreachable!(),\n@@ -605,7 +606,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expn_id: ExpnId) {\n+    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem) {\n         let (res, ns) = match item.node {\n             ForeignItemKind::Fn(..) => {\n                 (Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id)), ValueNS)\n@@ -618,27 +619,23 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n             }\n             ForeignItemKind::Macro(_) => unreachable!(),\n         };\n-        let parent = self.current_module;\n-        let parent_scope = &ParentScope {\n-            module: self.current_module,\n-            expansion: self.expansion,\n-            legacy: self.current_legacy_scope,\n-            derives: Vec::new(),\n-        };\n-        let vis = self.resolver.resolve_visibility(&item.vis, parent_scope);\n-        self.define(parent, item.ident, ns, (res, vis, item.span, expn_id));\n+        let parent = self.parent_scope.module;\n+        let expansion = self.parent_scope.expansion;\n+        let vis = self.resolver.resolve_visibility(&item.vis, &self.parent_scope);\n+        self.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, expn_id: ExpnId) {\n-        let parent = self.current_module;\n+    fn build_reduced_graph_for_block(&mut self, block: &Block) {\n+        let parent = self.parent_scope.module;\n+        let expansion = self.parent_scope.expansion;\n         if self.block_needs_anonymous_module(block) {\n             let module = self.new_module(parent,\n                                          ModuleKind::Block(block.id),\n                                          parent.normal_ancestor_id,\n-                                         expn_id,\n+                                         expansion,\n                                          block.span);\n             self.block_map.insert(block.id, module);\n-            self.current_module = module; // Descend into the block.\n+            self.parent_scope.module = module; // Descend into the block.\n         }\n     }\n }\n@@ -827,7 +824,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n             if attr.check_name(sym::macro_use) {\n-                if self.current_module.parent.is_some() {\n+                if self.parent_scope.module.parent.is_some() {\n                     span_err!(self.session, item.span, E0468,\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n@@ -933,9 +930,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b> {\n     pub resolver: &'a mut Resolver<'b>,\n-    pub current_module: Module<'b>,\n-    pub current_legacy_scope: LegacyScope<'b>,\n-    pub expansion: ExpnId,\n+    pub parent_scope: ParentScope<'b>,\n }\n \n impl<'b> Deref for BuildReducedGraphVisitor<'_, 'b> {\n@@ -955,11 +950,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.current_module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n \n         let invocation_data = self.arenas.alloc_invocation_data(InvocationData {\n-            module: self.current_module,\n-            parent_legacy_scope: self.current_legacy_scope,\n+            module: self.parent_scope.module,\n+            parent_legacy_scope: self.parent_scope.legacy,\n             output_legacy_scope: Cell::new(None),\n         });\n         let old_invocation_data = self.invocations.insert(invoc_id, invocation_data);\n@@ -988,38 +983,32 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        let parent_scope = &ParentScope {\n-            module: self.current_module,\n-            expansion: self.expansion,\n-            legacy: self.current_legacy_scope,\n-            derives: Vec::new(),\n-        };\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.current_legacy_scope = self.resolver.define_macro(item, parent_scope);\n+                self.parent_scope.legacy = self.resolver.define_macro(item, &self.parent_scope);\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(item.id));\n+                self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(item.id));\n                 return\n             }\n             ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n             _ => false,\n         };\n \n-        let orig_current_module = self.current_module;\n-        let orig_current_legacy_scope = self.current_legacy_scope;\n-        self.build_reduced_graph_for_item(item, parent_scope);\n+        let orig_current_module = self.parent_scope.module;\n+        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        self.build_reduced_graph_for_item(item);\n         visit::walk_item(self, item);\n-        self.current_module = orig_current_module;\n+        self.parent_scope.module = orig_current_module;\n         if !macro_use {\n-            self.current_legacy_scope = orig_current_legacy_scope;\n+            self.parent_scope.legacy = orig_current_legacy_scope;\n         }\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n+            self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1031,21 +1020,21 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n             return;\n         }\n \n-        self.build_reduced_graph_for_foreign_item(foreign_item, self.expansion);\n+        self.build_reduced_graph_for_foreign_item(foreign_item);\n         visit::walk_foreign_item(self, foreign_item);\n     }\n \n     fn visit_block(&mut self, block: &'a Block) {\n-        let orig_current_module = self.current_module;\n-        let orig_current_legacy_scope = self.current_legacy_scope;\n-        self.build_reduced_graph_for_block(block, self.expansion);\n+        let orig_current_module = self.parent_scope.module;\n+        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        self.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n-        self.current_module = orig_current_module;\n-        self.current_legacy_scope = orig_current_legacy_scope;\n+        self.parent_scope.module = orig_current_module;\n+        self.parent_scope.legacy = orig_current_legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &'a TraitItem) {\n-        let parent = self.current_module;\n+        let parent = self.parent_scope.module;\n \n         if let TraitItemKind::Macro(_) = item.node {\n             self.visit_invoc(item.id);\n@@ -1067,11 +1056,12 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         };\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident, ns, (res, vis, item.span, self.expansion));\n+        let expansion = self.parent_scope.expansion;\n+        self.resolver.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n \n-        self.current_module = parent.parent.unwrap(); // nearest normal ancestor\n+        self.parent_scope.module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);\n-        self.current_module = parent;\n+        self.parent_scope.module = parent;\n     }\n \n     fn visit_token(&mut self, t: Token) {\n@@ -1086,15 +1076,8 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            let parent_scope = ParentScope {\n-                module: self.current_module.nearest_item_scope(),\n-                expansion: self.expansion,\n-                legacy: self.current_legacy_scope,\n-                // Let's hope discerning built-in attributes from derive helpers is not necessary\n-                derives: Vec::new(),\n-            };\n-            parent_scope.module.builtin_attrs.borrow_mut().push((\n-                attr.path.segments[0].ident, parent_scope\n+            self.parent_scope.module.builtin_attrs.borrow_mut().push((\n+                attr.path.segments[0].ident, self.parent_scope.clone()\n             ));\n         }\n         visit::walk_attribute(self, attr);"}, {"sha": "efc02f1c0579d603501567e35fe752c94114ad10", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/df03e420e020c2ccc71bad4f7978b49a1c049435/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df03e420e020c2ccc71bad4f7978b49a1c049435/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=df03e420e020c2ccc71bad4f7978b49a1c049435", "patch": "@@ -72,7 +72,7 @@ struct LateResolutionVisitor<'a, 'b> {\n     resolver: &'b mut Resolver<'a>,\n \n     /// The module that represents the current item scope.\n-    current_module: Module<'a>,\n+    parent_scope: ParentScope<'a>,\n \n     /// The current set of local scopes for types and values.\n     /// FIXME #4948: Reuse ribs to avoid allocation.\n@@ -290,10 +290,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n \n impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n+        // During late resolution we only track the module component of the parent scope,\n+        // although it may be useful to track other components as well for diagnostics.\n+        let parent_scope = resolver.dummy_parent_scope();\n         let graph_root = resolver.graph_root;\n         LateResolutionVisitor {\n             resolver,\n-            current_module: graph_root,\n+            parent_scope,\n             ribs: PerNS {\n                 value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n                 type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n@@ -309,18 +312,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn parent_scope(&self) -> ParentScope<'a> {\n-        ParentScope { module: self.current_module, ..self.dummy_parent_scope() }\n-    }\n-\n     fn resolve_ident_in_lexical_scope(&mut self,\n                                       ident: Ident,\n                                       ns: Namespace,\n                                       record_used_id: Option<NodeId>,\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         self.resolver.resolve_ident_in_lexical_scope(\n-            ident, ns, &self.parent_scope(), record_used_id, path_span, &self.ribs[ns]\n+            ident, ns, &self.parent_scope, record_used_id, path_span, &self.ribs[ns]\n         )\n     }\n \n@@ -333,7 +332,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n         self.resolver.resolve_path_with_ribs(\n-            path, opt_ns, &self.parent_scope(), record_used, path_span, crate_lint, &self.ribs\n+            path, opt_ns, &self.parent_scope, record_used, path_span, crate_lint, &self.ribs\n         )\n     }\n \n@@ -342,7 +341,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     // We maintain a list of value ribs and type ribs.\n     //\n     // Simultaneously, we keep track of the current position in the module\n-    // graph in the `current_module` pointer. When we go to resolve a name in\n+    // graph in the `parent_scope.module` pointer. When we go to resolve a name in\n     // the value or type namespaces, we first look through all the ribs and\n     // then query the module graph. When we resolve a name in the module\n     // namespace, we can skip all the ribs (since nested modules are not\n@@ -362,14 +361,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let module = self.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n-            let orig_module = replace(&mut self.current_module, module);\n+            let orig_module = replace(&mut self.parent_scope.module, module);\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n             self.finalize_current_module_macro_resolutions(module);\n             let ret = f(self);\n \n-            self.current_module = orig_module;\n+            self.parent_scope.module = orig_module;\n             self.ribs[ValueNS].pop();\n             self.ribs[TypeNS].pop();\n             ret\n@@ -803,7 +802,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                 debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n                                 for impl_item in impl_items {\n                                     this.resolver.resolve_visibility(\n-                                        &impl_item.vis, &this.parent_scope()\n+                                        &impl_item.vis, &this.parent_scope\n                                     );\n                                     // We also need a new scope for the impl item type parameters.\n                                     let generic_params = HasGenericParams(&impl_item.generics,\n@@ -879,12 +878,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            let parent_scope = &self.parent_scope();\n-            if self.resolve_ident_in_module(\n+            if self.resolver.resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                parent_scope,\n+                &self.parent_scope,\n                 false,\n                 span,\n             ).is_err() {\n@@ -1024,15 +1022,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     fn resolve_block(&mut self, block: &Block) {\n         debug!(\"(resolving block) entering block\");\n         // Move down in the graph, if there's an anonymous module rooted here.\n-        let orig_module = self.current_module;\n+        let orig_module = self.parent_scope.module;\n         let anonymous_module = self.block_map.get(&block.id).cloned(); // clones a reference\n \n         let mut num_macro_definition_ribs = 0;\n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.current_module = anonymous_module;\n+            self.parent_scope.module = anonymous_module;\n             self.finalize_current_module_macro_resolutions(anonymous_module);\n         } else {\n             self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n@@ -1053,7 +1051,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n \n         // Move back up.\n-        self.current_module = orig_module;\n+        self.parent_scope.module = orig_module;\n         for _ in 0 .. num_macro_definition_ribs {\n             self.ribs[ValueNS].pop();\n             self.label_ribs.pop();\n@@ -1234,7 +1232,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n-            let def_id = this.current_module.normal_ancestor_id;\n+            let def_id = this.parent_scope.module.normal_ancestor_id;\n             let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n             let better = res.is_some();\n             this.use_injections.push(UseError { err, candidates, node_id, better });\n@@ -1261,7 +1259,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                         if let Some((ctor_res, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_res) &&\n-                               self.is_accessible_from(ctor_vis, self.current_module) {\n+                               self.is_accessible_from(ctor_vis, self.parent_scope.module) {\n                                 let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n                                 self.session.buffer_lint(lint, id, span,\n                                     \"private struct constructors are not usable through \\\n@@ -1360,9 +1358,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         if qself.is_none() {\n             let path_seg = |seg: &Segment| PathSegment::from_ident(seg.ident);\n             let path = Path { segments: path.iter().map(path_seg).collect(), span };\n-            let parent_scope = &self.parent_scope();\n-            if let Ok((_, res)) =\n-                    self.resolve_macro_path(&path, None, parent_scope, false, false) {\n+            if let Ok((_, res)) = self.resolver.resolve_macro_path(\n+                &path, None, &self.parent_scope, false, false\n+            ) {\n                 return Some(PartialRes::new(res));\n             }\n         }\n@@ -1693,12 +1691,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            let parent_scope = &self.parent_scope();\n-            if self.resolve_ident_in_module(\n+            if self.resolver.resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                parent_scope,\n+                &self.parent_scope,\n                 false,\n                 module.span,\n             ).is_ok() {\n@@ -1708,7 +1705,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n \n         ident.span = ident.span.modern();\n-        let mut search_module = self.current_module;\n+        let mut search_module = self.parent_scope.module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n             search_module = unwrap_or!(\n@@ -1755,12 +1752,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 ).is_none() {\n                     continue\n                 }\n-                let parent_scope = &self.parent_scope();\n-                if self.resolve_ident_in_module_unadjusted(\n+                if self.resolver.resolve_ident_in_module_unadjusted(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     ns,\n-                    parent_scope,\n+                    &self.parent_scope,\n                     false,\n                     module.span,\n                 ).is_ok() {\n@@ -1796,7 +1792,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n-        let module = late_resolution_visitor.current_module;\n+        let module = late_resolution_visitor.parent_scope.module;\n         late_resolution_visitor.finalize_current_module_macro_resolutions(module);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.unused_labels.iter() {"}, {"sha": "28ab53bc2f0b2ac6e4e8b4d489c5cd9ddf4f35a5", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df03e420e020c2ccc71bad4f7978b49a1c049435/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df03e420e020c2ccc71bad4f7978b49a1c049435/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=df03e420e020c2ccc71bad4f7978b49a1c049435", "patch": "@@ -430,7 +430,8 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n                 if let Some((ctor_def, ctor_vis))\n                         = self.struct_constructors.get(&def_id).cloned() {\n-                    let accessible_ctor = self.is_accessible_from(ctor_vis, self.current_module);\n+                    let accessible_ctor =\n+                        self.is_accessible_from(ctor_vis, self.parent_scope.module);\n                     if is_expected(ctor_def) && !accessible_ctor {\n                         err.span_label(\n                             span,\n@@ -505,12 +506,11 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            let parent_scope = &self.parent_scope();\n-            if let Ok(binding) = self.resolve_ident_in_module(\n+            if let Ok(binding) = self.resolver.resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     ns,\n-                    parent_scope,\n+                    &self.parent_scope,\n                     false,\n                     module.span,\n                 ) {"}, {"sha": "914125b7cae3e36a4780d88a24950739a04e398b", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df03e420e020c2ccc71bad4f7978b49a1c049435/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df03e420e020c2ccc71bad4f7978b49a1c049435/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=df03e420e020c2ccc71bad4f7978b49a1c049435", "patch": "@@ -175,12 +175,15 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n-            current_module: invocation.module,\n-            current_legacy_scope: invocation.parent_legacy_scope,\n-            expansion: expn_id,\n+            parent_scope: ParentScope {\n+                module: invocation.module,\n+                expansion: expn_id,\n+                legacy: invocation.parent_legacy_scope,\n+                derives: Vec::new(),\n+            },\n         };\n         fragment.visit_with(&mut visitor);\n-        invocation.output_legacy_scope.set(Some(visitor.current_legacy_scope));\n+        invocation.output_legacy_scope.set(Some(visitor.parent_scope.legacy));\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {"}]}