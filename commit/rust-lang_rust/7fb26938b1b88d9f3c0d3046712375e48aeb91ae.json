{"sha": "7fb26938b1b88d9f3c0d3046712375e48aeb91ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYjI2OTM4YjFiODhkOWYzYzBkMzA0NjcxMjM3NWU0OGFlYjkxYWU=", "commit": {"author": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2020-07-06T14:33:24Z"}, "committer": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2020-07-06T14:35:33Z"}, "message": "Add VecDeque::range* methods\n\nThis patch adds `VecDeque::range` and `VecDeque::range_mut` to provide\niterators over a sub-range of a `VecDeque`. This behavior can be\nemulated with `skip` and `take`, but directly providing a `Range` is\nmore ergonomic. This also partially makes up for `VecDeque`'s lack of\n`SliceIndex` support.", "tree": {"sha": "eed02e1d354c7be90e2cf61d66c28c6bbd950907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eed02e1d354c7be90e2cf61d66c28c6bbd950907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fb26938b1b88d9f3c0d3046712375e48aeb91ae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRMIcpUBeYB4tqnGeM8sexUWnBjGAUCXwM3TAAKCRA8sexUWnBj\nGKuPAQC6w2lLFTyQZHVEasmcRl+Hg1VEupYo8h2rQBoZVOjJcQEA2Vh7Osn7AL92\nESkRK6E9Z7lBZ79cruqC7NIcXhoqKgo=\n=H59h\n-----END PGP SIGNATURE-----", "payload": "tree eed02e1d354c7be90e2cf61d66c28c6bbd950907\nparent 0c03aee8b81185d65b5821518661c30ecdb42de5\nauthor Jon Gjengset <jon@thesquareplanet.com> 1594046004 -0400\ncommitter Jon Gjengset <jon@thesquareplanet.com> 1594046133 -0400\n\nAdd VecDeque::range* methods\n\nThis patch adds `VecDeque::range` and `VecDeque::range_mut` to provide\niterators over a sub-range of a `VecDeque`. This behavior can be\nemulated with `skip` and `take`, but directly providing a `Range` is\nmore ergonomic. This also partially makes up for `VecDeque`'s lack of\n`SliceIndex` support.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb26938b1b88d9f3c0d3046712375e48aeb91ae", "html_url": "https://github.com/rust-lang/rust/commit/7fb26938b1b88d9f3c0d3046712375e48aeb91ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fb26938b1b88d9f3c0d3046712375e48aeb91ae/comments", "author": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c03aee8b81185d65b5821518661c30ecdb42de5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c03aee8b81185d65b5821518661c30ecdb42de5", "html_url": "https://github.com/rust-lang/rust/commit/0c03aee8b81185d65b5821518661c30ecdb42de5"}], "stats": {"total": 171, "additions": 158, "deletions": 13}, "files": [{"sha": "08ab6a69ce85cc19d61e965b49f91916ecb44fc4", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 99, "deletions": 13, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7fb26938b1b88d9f3c0d3046712375e48aeb91ae/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb26938b1b88d9f3c0d3046712375e48aeb91ae/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=7fb26938b1b88d9f3c0d3046712375e48aeb91ae", "patch": "@@ -1084,6 +1084,104 @@ impl<T> VecDeque<T> {\n         self.tail == self.head\n     }\n \n+    fn range_start_end<R>(&self, range: R) -> (usize, usize)\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let len = self.len();\n+        let start = match range.start_bound() {\n+            Included(&n) => n,\n+            Excluded(&n) => n + 1,\n+            Unbounded => 0,\n+        };\n+        let end = match range.end_bound() {\n+            Included(&n) => n + 1,\n+            Excluded(&n) => n,\n+            Unbounded => len,\n+        };\n+        assert!(start <= end, \"lower bound was too large\");\n+        assert!(end <= len, \"upper bound was too large\");\n+        (start, end)\n+    }\n+\n+    /// Creates an iterator that covers the specified range in the `VecDeque`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let range = v.iter_rage(2..).copied().collect::<VecDeque<_>>();\n+    /// assert_eq!(range, [3]);\n+    ///\n+    /// // A full range covers all contents\n+    /// let all = v.range(..);\n+    /// assert_eq!(all.len(), 3);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"deque_range\", issue = \"none\")]\n+    pub fn range<R>(&self, range: R) -> Iter<'_, T>\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let (start, end) = self.range_start_end(range);\n+        let tail = self.wrap_add(self.tail, start);\n+        let head = self.wrap_add(self.tail, end);\n+        Iter {\n+            tail,\n+            head,\n+            // The shared reference we have in &self is maintained in the '_ of Iter.\n+            ring: unsafe { self.buffer_as_slice() },\n+        }\n+    }\n+\n+    /// Creates an iterator that covers the specified mutable range in the `VecDeque`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+    /// for v in v.range_mut(2..) {\n+    ///   *v *= 2;\n+    /// }\n+    /// assert_eq!(v, vec![1, 2, 6]);\n+    ///\n+    /// // A full range covers all contents\n+    /// for v in v.range_mut(..) {\n+    ///   *v *= 2;\n+    /// }\n+    /// assert_eq!(v, vec![2, 4, 12]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"deque_range\", issue = \"none\")]\n+    pub fn range_mut<R>(&mut self, range: R) -> IterMut<'_, T>\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let (start, end) = self.range_start_end(range);\n+        let tail = self.wrap_add(self.tail, start);\n+        let head = self.wrap_add(self.tail, end);\n+        IterMut {\n+            tail,\n+            head,\n+            // The shared reference we have in &mut self is maintained in the '_ of IterMut.\n+            ring: unsafe { self.buffer_as_mut_slice() },\n+        }\n+    }\n+\n     /// Creates a draining iterator that removes the specified range in the\n     /// `VecDeque` and yields the removed items.\n     ///\n@@ -1129,19 +1227,7 @@ impl<T> VecDeque<T> {\n         // When finished, the remaining data will be copied back to cover the hole,\n         // and the head/tail values will be restored correctly.\n         //\n-        let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded => len,\n-        };\n-        assert!(start <= end, \"drain lower bound was too large\");\n-        assert!(end <= len, \"drain upper bound was too large\");\n+        let (start, end) = self.range_start_end(range);\n \n         // The deque's elements are parted into three segments:\n         // * self.tail  -> drain_tail"}, {"sha": "4473ce8719e130974186e352843d145695a9f784", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7fb26938b1b88d9f3c0d3046712375e48aeb91ae/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb26938b1b88d9f3c0d3046712375e48aeb91ae/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=7fb26938b1b88d9f3c0d3046712375e48aeb91ae", "patch": "@@ -246,6 +246,65 @@ fn test_remove() {\n     }\n }\n \n+#[test]\n+fn test_range() {\n+    let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+    let cap = tester.capacity();\n+    for len in 0..=cap {\n+        for tail in 0..=cap {\n+            for start in 0..=len {\n+                for end in drain_start..=len {\n+                    tester.tail = tail;\n+                    tester.head = tail;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+\n+                    // Check that we iterate over the correct values\n+                    let range: VecDeque<_> = tester.range(start..end).copied().collect();\n+                    let expected: VecDeque<_> = (start..end).collect();\n+                    assert_eq!(range, expected);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_range_mut() {\n+    let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+    let cap = tester.capacity();\n+    for len in 0..=cap {\n+        for tail in 0..=cap {\n+            for start in 0..=len {\n+                for end in drain_start..=len {\n+                    tester.tail = tail;\n+                    tester.head = tail;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+\n+                    let head_was = tester.head;\n+                    let tail_was = tester.tail;\n+\n+                    // Check that we iterate over the correct values\n+                    let range: VecDeque<_> = tester.range_mut(start..end).copied().collect();\n+                    let expected: VecDeque<_> = (start..end).collect();\n+                    assert_eq!(range, expected);\n+\n+                    // We shouldn't have changed the capacity or made the\n+                    // head or tail out of bounds\n+                    assert_eq!(tester.capacity(), cap);\n+                    assert_eq!(tester.tail, tail_was);\n+                    assert_eq!(tester.head, head_was);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_drain() {\n     let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);"}]}