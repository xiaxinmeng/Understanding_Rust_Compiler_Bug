{"sha": "7d70434a1e0ba68753b7d1e83f594dea6d23dd51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNzA0MzRhMWUwYmE2ODc1M2I3ZDFlODNmNTk0ZGVhNmQyM2RkNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-24T20:51:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-24T20:51:19Z"}, "message": "auto merge of #13720 : aturon/rust/walk_dir-perf, r=alexcrichton\n\nThe `walk_dir` iterator was simulating a queue using a vector (in particular, using `shift`),\r\nleading to O(n^2) performance. Since the order was not well-specified (see issue #13411),\r\nthe simplest fix is to use the vector as a stack (and thus yield a depth-first traversal).\r\nThis patch does exactly that, and adds a test checking for depth-first behavior.\r\n\r\nNote that the underlying `readdir` function does not specify any particular order, nor\r\ndoes the system call it uses.\r\n\r\nCloses #13411.", "tree": {"sha": "579de48360e79cc80ca660e005648378be60a19a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/579de48360e79cc80ca660e005648378be60a19a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d70434a1e0ba68753b7d1e83f594dea6d23dd51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d70434a1e0ba68753b7d1e83f594dea6d23dd51", "html_url": "https://github.com/rust-lang/rust/commit/7d70434a1e0ba68753b7d1e83f594dea6d23dd51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d70434a1e0ba68753b7d1e83f594dea6d23dd51/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3485d90728fe8dc076c6362211bf1f62830c97d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3485d90728fe8dc076c6362211bf1f62830c97d8", "html_url": "https://github.com/rust-lang/rust/commit/3485d90728fe8dc076c6362211bf1f62830c97d8"}, {"sha": "b536d2bb763d478dbf96c035dbd5b68b5ff639b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b536d2bb763d478dbf96c035dbd5b68b5ff639b9", "html_url": "https://github.com/rust-lang/rust/commit/b536d2bb763d478dbf96c035dbd5b68b5ff639b9"}], "stats": {"total": 31, "additions": 29, "deletions": 2}, "files": [{"sha": "a9c493c284dd344787de21971bf0bcb47c60833e", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7d70434a1e0ba68753b7d1e83f594dea6d23dd51/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70434a1e0ba68753b7d1e83f594dea6d23dd51/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=7d70434a1e0ba68753b7d1e83f594dea6d23dd51", "patch": "@@ -491,7 +491,8 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n \n /// Returns an iterator which will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n-/// perform iteration in a top-down order.\n+/// perform iteration in some top-down order.  The contents of unreadable\n+/// subdirectories are ignored.\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     Ok(Directories { stack: try!(readdir(path)) })\n }\n@@ -503,7 +504,7 @@ pub struct Directories {\n \n impl Iterator<Path> for Directories {\n     fn next(&mut self) -> Option<Path> {\n-        match self.stack.shift() {\n+        match self.stack.pop() {\n             Some(path) => {\n                 if path.is_dir() {\n                     match readdir(&path) {\n@@ -970,6 +971,32 @@ mod test {\n         check!(rmdir(dir));\n     })\n \n+    iotest!(fn file_test_walk_dir() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"walk_dir\");\n+        check!(mkdir(dir, io::UserRWX));\n+\n+        let dir1 = &dir.join(\"01/02/03\");\n+        check!(mkdir_recursive(dir1, io::UserRWX));\n+        check!(File::create(&dir1.join(\"04\")));\n+\n+        let dir2 = &dir.join(\"11/12/13\");\n+        check!(mkdir_recursive(dir2, io::UserRWX));\n+        check!(File::create(&dir2.join(\"14\")));\n+\n+        let mut files = check!(walk_dir(dir));\n+        let mut cur = [0u8, .. 2];\n+        for f in files {\n+            let stem = f.filestem_str().unwrap();\n+            let root = stem[0] - ('0' as u8);\n+            let name = stem[1] - ('0' as u8);\n+            assert!(cur[root as uint] < name);\n+            cur[root as uint] = name;\n+        }\n+\n+        check!(rmdir_recursive(dir));\n+    })\n+\n     iotest!(fn recursive_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1/d2\");"}]}