{"sha": "900869371e13cead086f4f9809419daa6a63cfaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMDg2OTM3MWUxM2NlYWQwODZmNGY5ODA5NDE5ZGFhNmE2M2NmYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-24T12:16:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-24T12:16:47Z"}, "message": "Auto merge of #74710 - JohnTitor:rollup-bdz4oee, r=JohnTitor\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #74361 (Improve doc theme logo display)\n - #74504 (Add right border bar to Dark and Light theme)\n - #74572 (Internally unify rustc_deprecated and deprecated)\n - #74601 (Clean up E0724 explanation)\n - #74623 (polymorphize GlobalAlloc::Function)\n - #74665 (Don't ICE on unconstrained anonymous lifetimes inside associated types.)\n - #74666 (More BTreeMap test cases, some exposing undefined behaviour)\n - #74669 (Fix typo)\n - #74677 (Remove needless unsafety from BTreeMap::drain_filter)\n - #74680 (Add missing backticks in diagnostics note)\n - #74694 (Clean up E0727 explanation)\n - #74703 (Fix ICE while building MIR with type errors)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3539d0414fb1dd51e6525cfd37351142b4caf4ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3539d0414fb1dd51e6525cfd37351142b4caf4ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/900869371e13cead086f4f9809419daa6a63cfaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/900869371e13cead086f4f9809419daa6a63cfaf", "html_url": "https://github.com/rust-lang/rust/commit/900869371e13cead086f4f9809419daa6a63cfaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/900869371e13cead086f4f9809419daa6a63cfaf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0820e54a8ad7795d7b555b37994f43cfe62356d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0820e54a8ad7795d7b555b37994f43cfe62356d4", "html_url": "https://github.com/rust-lang/rust/commit/0820e54a8ad7795d7b555b37994f43cfe62356d4"}, {"sha": "01b069db67f7f7d4d75e8bf492446e0ce9f7a6a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b069db67f7f7d4d75e8bf492446e0ce9f7a6a8", "html_url": "https://github.com/rust-lang/rust/commit/01b069db67f7f7d4d75e8bf492446e0ce9f7a6a8"}], "stats": {"total": 745, "additions": 443, "deletions": 302}, "files": [{"sha": "24d1f61fa68c48dd773ec161e2d1f98356b4f4bd", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -1672,19 +1672,12 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n         edge.reborrow().next_kv().ok().map(|kv| kv.into_kv())\n     }\n \n-    unsafe fn next_kv(\n-        &mut self,\n-    ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n-        let edge = self.cur_leaf_edge.as_ref()?;\n-        unsafe { ptr::read(edge).next_kv().ok() }\n-    }\n-\n     /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n     pub(super) fn next<F>(&mut self, pred: &mut F) -> Option<(K, V)>\n     where\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        while let Some(mut kv) = unsafe { self.next_kv() } {\n+        while let Ok(mut kv) = self.cur_leaf_edge.take()?.next_kv() {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;"}, {"sha": "f9f81716e357c243b3c7ec9add10b11f6dabff5e", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 126, "deletions": 12, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -3,6 +3,7 @@ use std::collections::BTreeMap;\n use std::convert::TryFrom;\n use std::fmt::Debug;\n use std::iter::FromIterator;\n+use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n@@ -25,6 +26,20 @@ const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_CAPACITY + 1;\n \n+// Gather all references from a mutable iterator and make sure Miri notices if\n+// using them is dangerous.\n+fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>) {\n+    // Gather all those references.\n+    let mut refs: Vec<&mut T> = iter.collect();\n+    // Use them all. Twice, to be sure we got all interleavings.\n+    for r in refs.iter_mut() {\n+        mem::swap(dummy, r);\n+    }\n+    for r in refs {\n+        mem::swap(dummy, r);\n+    }\n+}\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n@@ -268,7 +283,14 @@ fn test_iter_mut_mutation() {\n }\n \n #[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n fn test_values_mut() {\n+    let mut a: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    test_all_refs(&mut 13, a.values_mut());\n+}\n+\n+#[test]\n+fn test_values_mut_mutation() {\n     let mut a = BTreeMap::new();\n     a.insert(1, String::from(\"hello\"));\n     a.insert(2, String::from(\"goodbye\"));\n@@ -281,6 +303,36 @@ fn test_values_mut() {\n     assert_eq!(values, [String::from(\"hello!\"), String::from(\"goodbye!\")]);\n }\n \n+#[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n+fn test_iter_entering_root_twice() {\n+    let mut map: BTreeMap<_, _> = (0..2).map(|i| (i, i)).collect();\n+    let mut it = map.iter_mut();\n+    let front = it.next().unwrap();\n+    let back = it.next_back().unwrap();\n+    assert_eq!(front, (&0, &mut 0));\n+    assert_eq!(back, (&1, &mut 1));\n+    *front.1 = 24;\n+    *back.1 = 42;\n+    assert_eq!(front, (&0, &mut 24));\n+    assert_eq!(back, (&1, &mut 42));\n+}\n+\n+#[test]\n+#[cfg_attr(miri, ignore)] // FIXME: fails in Miri <https://github.com/rust-lang/rust/issues/73915>\n+fn test_iter_descending_to_same_node_twice() {\n+    let mut map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i)).collect();\n+    let mut it = map.iter_mut();\n+    // Descend into first child.\n+    let front = it.next().unwrap();\n+    // Descend into first child again, after running through second child.\n+    while it.next_back().is_some() {}\n+    // Check immutable access.\n+    assert_eq!(front, (&0, &mut 0));\n+    // Perform mutable access.\n+    *front.1 = 42;\n+}\n+\n #[test]\n fn test_iter_mixed() {\n     // Miri is too slow\n@@ -835,18 +887,16 @@ mod test_drain_filter {\n             }\n         }\n \n-        let mut map = BTreeMap::new();\n-        map.insert(0, D);\n-        map.insert(4, D);\n-        map.insert(8, D);\n+        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n+        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n \n         catch_unwind(move || {\n             drop(map.drain_filter(|i, _| {\n                 PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n                 true\n             }))\n         })\n-        .ok();\n+        .unwrap_err();\n \n         assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n         assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n@@ -864,10 +914,8 @@ mod test_drain_filter {\n             }\n         }\n \n-        let mut map = BTreeMap::new();\n-        map.insert(0, D);\n-        map.insert(4, D);\n-        map.insert(8, D);\n+        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n+        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n \n         catch_unwind(AssertUnwindSafe(|| {\n             drop(map.drain_filter(|i, _| {\n@@ -878,7 +926,45 @@ mod test_drain_filter {\n                 }\n             }))\n         }))\n-        .ok();\n+        .unwrap_err();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+        assert_eq!(map.first_entry().unwrap().key(), &4);\n+        assert_eq!(map.last_entry().unwrap().key(), &8);\n+    }\n+\n+    // Same as above, but attempt to use the iterator again after the panic in the predicate\n+    #[test]\n+    fn pred_panic_reuse() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n+        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n+\n+        {\n+            let mut it = map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                match i {\n+                    0 => true,\n+                    _ => panic!(),\n+                }\n+            });\n+            catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n+            // Iterator behaviour after a panic is explicitly unspecified,\n+            // so this is just the current implementation:\n+            let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+            assert!(matches!(result, Ok(None)));\n+        }\n \n         assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n         assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n@@ -1283,6 +1369,34 @@ fn test_split_off_empty_left() {\n     assert!(right.into_iter().eq(data));\n }\n \n+// In a tree with 3 levels, if all but a part of the first leaf node is split off,\n+// make sure fix_top eliminates both top levels.\n+#[test]\n+fn test_split_off_tiny_left_height_2() {\n+    let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    let right = left.split_off(&1);\n+    assert_eq!(left.len(), 1);\n+    assert_eq!(right.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(*left.first_key_value().unwrap().0, 0);\n+    assert_eq!(*right.first_key_value().unwrap().0, 1);\n+}\n+\n+// In a tree with 3 levels, if only part of the last leaf node is split off,\n+// make sure fix_top eliminates both top levels.\n+#[test]\n+fn test_split_off_tiny_right_height_2() {\n+    let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+    let last = MIN_INSERTS_HEIGHT_2 - 1;\n+    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    assert_eq!(*left.last_key_value().unwrap().0, last);\n+    let right = left.split_off(&last);\n+    assert_eq!(left.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(right.len(), 1);\n+    assert_eq!(*left.last_key_value().unwrap().0, last - 1);\n+    assert_eq!(*right.last_key_value().unwrap().0, last);\n+}\n+\n #[test]\n fn test_split_off_large_random_sorted() {\n     // Miri is too slow\n@@ -1319,7 +1433,7 @@ fn test_into_iter_drop_leak_height_0() {\n     map.insert(\"d\", D);\n     map.insert(\"e\", D);\n \n-    catch_unwind(move || drop(map.into_iter())).ok();\n+    catch_unwind(move || drop(map.into_iter())).unwrap_err();\n \n     assert_eq!(DROPS.load(Ordering::SeqCst), 5);\n }\n@@ -1343,7 +1457,7 @@ fn test_into_iter_drop_leak_height_1() {\n         DROPS.store(0, Ordering::SeqCst);\n         PANIC_POINT.store(panic_point, Ordering::SeqCst);\n         let map: BTreeMap<_, _> = (0..size).map(|i| (i, D)).collect();\n-        catch_unwind(move || drop(map.into_iter())).ok();\n+        catch_unwind(move || drop(map.into_iter())).unwrap_err();\n         assert_eq!(DROPS.load(Ordering::SeqCst), size);\n     }\n }"}, {"sha": "9f34aee1947cd8e8dcd1fdd2899dffc43641d821", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -32,7 +32,7 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     /// * `steps_between(&a, &b) == Some(n)` only if `a <= b`\n     ///   * Corollary: `steps_between(&a, &b) == Some(0)` if and only if `a == b`\n     ///   * Note that `a <= b` does _not_ imply `steps_between(&a, &b) != None`;\n-    ///     this is the case wheen it would require more than `usize::MAX` steps to get to `b`\n+    ///     this is the case when it would require more than `usize::MAX` steps to get to `b`\n     /// * `steps_between(&a, &b) == None` if `a > b`\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n "}, {"sha": "4f08aa451875f78f5dcc72d566e7593ea7fceeed", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -59,7 +59,7 @@\n #[rustc_on_unimplemented(\n     on(\n         Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n     ),\n     message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n     label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n@@ -141,7 +141,7 @@ pub trait Fn<Args>: FnMut<Args> {\n #[rustc_on_unimplemented(\n     on(\n         Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n     ),\n     message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n     label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n@@ -215,7 +215,7 @@ pub trait FnMut<Args>: FnOnce<Args> {\n #[rustc_on_unimplemented(\n     on(\n         Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n     ),\n     message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n     label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\""}, {"sha": "1e088b52dcc35b5fffb03d09cde40843b6801e81", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 55, "deletions": 111, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -124,13 +124,11 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n ///\n /// - `#[stable]`\n /// - `#[unstable]`\n-/// - `#[rustc_deprecated]`\n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: Symbol,\n-    pub rustc_depr: Option<RustcDeprecation>,\n }\n \n /// Represents the `#[rustc_const_unstable]` and `#[rustc_const_stable]` attributes.\n@@ -163,15 +161,6 @@ impl StabilityLevel {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n-#[derive(HashStable_Generic)]\n-pub struct RustcDeprecation {\n-    pub since: Symbol,\n-    pub reason: Symbol,\n-    /// A text snippet used to completely replace any use of the deprecated item in an expression.\n-    pub suggestion: Option<Symbol>,\n-}\n-\n /// Checks if `attrs` contains an attribute like `#![feature(feature_name)]`.\n /// This will not perform any \"sanity checks\" on the form of the attributes.\n pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool {\n@@ -205,15 +194,13 @@ where\n     use StabilityLevel::*;\n \n     let mut stab: Option<Stability> = None;\n-    let mut rustc_depr: Option<RustcDeprecation> = None;\n     let mut const_stab: Option<ConstStability> = None;\n     let mut promotable = false;\n     let mut allow_const_fn_ptr = false;\n     let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n         if ![\n-            sym::rustc_deprecated,\n             sym::rustc_const_unstable,\n             sym::rustc_const_stable,\n             sym::unstable,\n@@ -258,76 +245,8 @@ where\n                 }\n             };\n \n-            macro_rules! get_meta {\n-                ($($name:ident),+) => {\n-                    $(\n-                        let mut $name = None;\n-                    )+\n-                    for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty() {\n-                                $(\n-                                    sym::$name => if !get(mi, &mut $name) { continue 'outer },\n-                                )+\n-                                _ => {\n-                                    let expected = &[ $( stringify!($name) ),+ ];\n-                                    handle_errors(\n-                                        sess,\n-                                        mi.span,\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            expected,\n-                                        ),\n-                                    );\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(\n-                                sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(\n-                                    \"unsupported literal\",\n-                                    false,\n-                                ),\n-                            );\n-                            continue 'outer\n-                        }\n-                    }\n-                }\n-            }\n-\n             let meta_name = meta.name_or_empty();\n             match meta_name {\n-                sym::rustc_deprecated => {\n-                    if rustc_depr.is_some() {\n-                        struct_span_err!(\n-                            diagnostic,\n-                            item_sp,\n-                            E0540,\n-                            \"multiple rustc_deprecated attributes\"\n-                        )\n-                        .emit();\n-                        continue 'outer;\n-                    }\n-\n-                    get_meta!(since, reason, suggestion);\n-\n-                    match (since, reason) {\n-                        (Some(since), Some(reason)) => {\n-                            rustc_depr = Some(RustcDeprecation { since, reason, suggestion })\n-                        }\n-                        (None, _) => {\n-                            handle_errors(sess, attr.span, AttrError::MissingSince);\n-                            continue;\n-                        }\n-                        _ => {\n-                            struct_span_err!(diagnostic, attr.span, E0543, \"missing 'reason'\")\n-                                .emit();\n-                            continue;\n-                        }\n-                    }\n-                }\n                 sym::rustc_const_unstable | sym::unstable => {\n                     if meta_name == sym::unstable && stab.is_some() {\n                         handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n@@ -429,7 +348,7 @@ where\n                         (Some(feature), reason, Some(_)) => {\n                             let level = Unstable { reason, issue: issue_num, is_soft };\n                             if sym::unstable == meta_name {\n-                                stab = Some(Stability { level, feature, rustc_depr: None });\n+                                stab = Some(Stability { level, feature });\n                             } else {\n                                 const_stab = Some(ConstStability {\n                                     level,\n@@ -501,7 +420,7 @@ where\n                         (Some(feature), Some(since)) => {\n                             let level = Stable { since };\n                             if sym::stable == meta_name {\n-                                stab = Some(Stability { level, feature, rustc_depr: None });\n+                                stab = Some(Stability { level, feature });\n                             } else {\n                                 const_stab = Some(ConstStability {\n                                     level,\n@@ -526,22 +445,6 @@ where\n         }\n     }\n \n-    // Merge the deprecation info into the stability info\n-    if let Some(rustc_depr) = rustc_depr {\n-        if let Some(ref mut stab) = stab {\n-            stab.rustc_depr = Some(rustc_depr);\n-        } else {\n-            struct_span_err!(\n-                diagnostic,\n-                item_sp,\n-                E0549,\n-                \"rustc_deprecated attribute must be paired with \\\n-                       either stable or unstable attribute\"\n-            )\n-            .emit();\n-        }\n-    }\n-\n     // Merge the const-unstable info into the stability info\n     if promotable || allow_const_fn_ptr {\n         if let Some(ref mut stab) = const_stab {\n@@ -714,7 +617,16 @@ pub fn eval_condition(\n #[derive(RustcEncodable, RustcDecodable, Clone, HashStable_Generic)]\n pub struct Deprecation {\n     pub since: Option<Symbol>,\n+    /// The note to issue a reason.\n     pub note: Option<Symbol>,\n+    /// A text snippet used to completely replace any use of the deprecated item in an expression.\n+    ///\n+    /// This is currently unstable.\n+    pub suggestion: Option<Symbol>,\n+\n+    /// Whether to treat the since attribute as being a Rust version identifier\n+    /// (rather than an opaque string).\n+    pub is_since_rustc_version: bool,\n }\n \n /// Finds the deprecation attribute. `None` if none exists.\n@@ -738,7 +650,7 @@ where\n     let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n-        if !attr.check_name(sym::deprecated) {\n+        if !(attr.check_name(sym::deprecated) || attr.check_name(sym::rustc_deprecated)) {\n             continue;\n         }\n \n@@ -751,11 +663,12 @@ where\n             Some(meta) => meta,\n             None => continue,\n         };\n-        depr = match &meta.kind {\n-            MetaItemKind::Word => Some(Deprecation { since: None, note: None }),\n-            MetaItemKind::NameValue(..) => {\n-                meta.value_str().map(|note| Deprecation { since: None, note: Some(note) })\n-            }\n+        let mut since = None;\n+        let mut note = None;\n+        let mut suggestion = None;\n+        match &meta.kind {\n+            MetaItemKind::Word => {}\n+            MetaItemKind::NameValue(..) => note = meta.value_str(),\n             MetaItemKind::List(list) => {\n                 let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                     if item.is_some() {\n@@ -789,8 +702,6 @@ where\n                     }\n                 };\n \n-                let mut since = None;\n-                let mut note = None;\n                 for meta in list {\n                     match meta {\n                         NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n@@ -799,18 +710,32 @@ where\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::note => {\n+                            sym::note if attr.check_name(sym::deprecated) => {\n+                                if !get(mi, &mut note) {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            sym::reason if attr.check_name(sym::rustc_deprecated) => {\n                                 if !get(mi, &mut note) {\n                                     continue 'outer;\n                                 }\n                             }\n+                            sym::suggestion if attr.check_name(sym::rustc_deprecated) => {\n+                                if !get(mi, &mut suggestion) {\n+                                    continue 'outer;\n+                                }\n+                            }\n                             _ => {\n                                 handle_errors(\n                                     sess,\n                                     meta.span(),\n                                     AttrError::UnknownMetaItem(\n                                         pprust::path_to_string(&mi.path),\n-                                        &[\"since\", \"note\"],\n+                                        if attr.check_name(sym::deprecated) {\n+                                            &[\"since\", \"note\"]\n+                                        } else {\n+                                            &[\"since\", \"reason\", \"suggestion\"]\n+                                        },\n                                     ),\n                                 );\n                                 continue 'outer;\n@@ -829,10 +754,29 @@ where\n                         }\n                     }\n                 }\n+            }\n+        }\n+\n+        if suggestion.is_some() && attr.check_name(sym::deprecated) {\n+            unreachable!(\"only allowed on rustc_deprecated\")\n+        }\n \n-                Some(Deprecation { since, note })\n+        if attr.check_name(sym::rustc_deprecated) {\n+            if since.is_none() {\n+                handle_errors(sess, attr.span, AttrError::MissingSince);\n+                continue;\n             }\n-        };\n+\n+            if note.is_none() {\n+                struct_span_err!(diagnostic, attr.span, E0543, \"missing 'reason'\").emit();\n+                continue;\n+            }\n+        }\n+\n+        mark_used(&attr);\n+\n+        let is_since_rustc_version = attr.check_name(sym::rustc_deprecated);\n+        depr = Some(Deprecation { since, note, suggestion, is_since_rustc_version });\n     }\n \n     depr"}, {"sha": "2a50d4a46d279436ade2897007f8615097f59b7a", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -257,7 +257,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         (value, AddressSpace::DATA)\n                     }\n                     GlobalAlloc::Function(fn_instance) => (\n-                        self.get_fn_addr(fn_instance),\n+                        self.get_fn_addr(fn_instance.polymorphize(self.tcx)),\n                         self.data_layout().instruction_address_space,\n                     ),\n                     GlobalAlloc::Static(def_id) => {"}, {"sha": "4e5e77f80c28a1208c4f0121777816cd98cbf24f", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -589,7 +589,7 @@ E0771: include_str!(\"./error_codes/E0771.md\"),\n     E0521, // borrowed data escapes outside of closure\n     E0523,\n //  E0526, // shuffle indices are not constant\n-    E0540, // multiple rustc_deprecated attributes\n+//  E0540, // multiple rustc_deprecated attributes\n     E0542, // missing 'since'\n     E0543, // missing 'reason'\n     E0544, // multiple stability levels"}, {"sha": "e8f84d0fc7d508deb202e5b1515149806bc83546", "filename": "src/librustc_error_codes/error_codes/E0724.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -1,4 +1,5 @@\n-`#[ffi_returns_twice]` was used on non-foreign function.\n+`#[ffi_returns_twice]` was used on something other than a foreign function\n+declaration.\n \n Erroneous code example:\n "}, {"sha": "386daea0c57e3dfd4c6204c957b1572621221b32", "filename": "src/librustc_error_codes/error_codes/E0727.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -1,6 +1,6 @@\n A `yield` clause was used in an `async` context.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0727,edition2018\n #![feature(generators)]"}, {"sha": "5f7ff54fd31c3ee5a3e329752aa59e6e19e96ad4", "filename": "src/librustc_middle/middle/stability.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -5,7 +5,7 @@ pub use self::StabilityLevel::*;\n \n use crate::ty::{self, TyCtxt};\n use rustc_ast::ast::CRATE_NODE_ID;\n-use rustc_attr::{self as attr, ConstStability, Deprecation, RustcDeprecation, Stability};\n+use rustc_attr::{self as attr, ConstStability, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::GateIssue;\n@@ -130,14 +130,26 @@ pub fn report_unstable(\n \n /// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n /// deprecated (i.e., whether X is not greater than the current rustc version).\n-pub fn deprecation_in_effect(since: &str) -> bool {\n+pub fn deprecation_in_effect(is_since_rustc_version: bool, since: Option<&str>) -> bool {\n+    let since = if let Some(since) = since {\n+        if is_since_rustc_version {\n+            since\n+        } else {\n+            // We assume that the deprecation is in effect if it's not a\n+            // rustc version.\n+            return true;\n+        }\n+    } else {\n+        // If since attribute is not set, then we're definitely in effect.\n+        return true;\n+    };\n     fn parse_version(ver: &str) -> Vec<u32> {\n         // We ignore non-integer components of the version (e.g., \"nightly\").\n         ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n     }\n \n     if let Some(rustc) = option_env!(\"CFG_RELEASE\") {\n-        let since: Vec<u32> = parse_version(since);\n+        let since: Vec<u32> = parse_version(&since);\n         let rustc: Vec<u32> = parse_version(rustc);\n         // We simply treat invalid `since` attributes as relating to a previous\n         // Rust version, thus always displaying the warning.\n@@ -167,31 +179,27 @@ pub fn deprecation_suggestion(\n     }\n }\n \n-fn deprecation_message_common(message: String, reason: Option<Symbol>) -> String {\n-    match reason {\n-        Some(reason) => format!(\"{}: {}\", message, reason),\n-        None => message,\n-    }\n-}\n-\n pub fn deprecation_message(depr: &Deprecation, path: &str) -> (String, &'static Lint) {\n-    let message = format!(\"use of deprecated item '{}'\", path);\n-    (deprecation_message_common(message, depr.note), DEPRECATED)\n-}\n-\n-pub fn rustc_deprecation_message(depr: &RustcDeprecation, path: &str) -> (String, &'static Lint) {\n-    let (message, lint) = if deprecation_in_effect(&depr.since.as_str()) {\n+    let (message, lint) = if deprecation_in_effect(\n+        depr.is_since_rustc_version,\n+        depr.since.map(Symbol::as_str).as_deref(),\n+    ) {\n         (format!(\"use of deprecated item '{}'\", path), DEPRECATED)\n     } else {\n         (\n             format!(\n                 \"use of item '{}' that will be deprecated in future version {}\",\n-                path, depr.since\n+                path,\n+                depr.since.unwrap()\n             ),\n             DEPRECATED_IN_FUTURE,\n         )\n     };\n-    (deprecation_message_common(message, Some(depr.reason)), lint)\n+    let message = match depr.note {\n+        Some(reason) => format!(\"{}: {}\", message, reason),\n+        None => message,\n+    };\n+    (message, lint)\n }\n \n pub fn early_report_deprecation(\n@@ -289,10 +297,23 @@ impl<'tcx> TyCtxt<'tcx> {\n                     .lookup_deprecation_entry(parent_def_id.to_def_id())\n                     .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n-                if !skip {\n+                // #[deprecated] doesn't emit a notice if we're not on the\n+                // topmost deprecation. For example, if a struct is deprecated,\n+                // the use of a field won't be linted.\n+                //\n+                // #[rustc_deprecated] however wants to emit down the whole\n+                // hierarchy.\n+                if !skip || depr_entry.attr.is_since_rustc_version {\n                     let (message, lint) =\n                         deprecation_message(&depr_entry.attr, &self.def_path_str(def_id));\n-                    late_report_deprecation(self, &message, None, lint, span, id);\n+                    late_report_deprecation(\n+                        self,\n+                        &message,\n+                        depr_entry.attr.suggestion,\n+                        lint,\n+                        span,\n+                        id,\n+                    );\n                 }\n             };\n         }\n@@ -310,16 +331,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             def_id, span, stability\n         );\n \n-        if let Some(id) = id {\n-            if let Some(stability) = stability {\n-                if let Some(depr) = &stability.rustc_depr {\n-                    let (message, lint) =\n-                        rustc_deprecation_message(depr, &self.def_path_str(def_id));\n-                    late_report_deprecation(self, &message, depr.suggestion, lint, span, id);\n-                }\n-            }\n-        }\n-\n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !def_id.is_local();\n         if !cross_crate {"}, {"sha": "a5c87bc963f49bd84232eccadbd88c8789c6be01", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -509,11 +509,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         let mut ty = self.typeck_results.node_type(pat.hir_id);\n \n-        if let ty::Error(_) = ty.kind {\n-            // Avoid ICEs (e.g., #50577 and #50585).\n-            return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n-        }\n-\n         let kind = match pat.kind {\n             hir::PatKind::Wild => PatKind::Wild,\n "}, {"sha": "830af8d31e7a6a3b48baa76f6f72ffb05624c9a6", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -59,20 +59,50 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     ) where\n         F: FnOnce(&mut Self),\n     {\n+        debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n+        let mut did_error = false;\n         if !self.tcx.features().staged_api {\n-            self.forbid_staged_api_attrs(hir_id, attrs, item_sp, kind, visit_children);\n-            return;\n+            did_error = self.forbid_staged_api_attrs(hir_id, attrs);\n         }\n \n-        // This crate explicitly wants staged API.\n+        let depr = if did_error {\n+            None\n+        } else {\n+            attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp)\n+        };\n+        let mut is_deprecated = false;\n+        if let Some(depr) = &depr {\n+            is_deprecated = true;\n \n-        debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n-        if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-            self.tcx.sess.span_err(\n-                item_sp,\n-                \"`#[deprecated]` cannot be used in staged API; \\\n-                                             use `#[rustc_deprecated]` instead\",\n+            if kind == AnnotationKind::Prohibited {\n+                self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n+            }\n+\n+            // `Deprecation` is just two pointers, no need to intern it\n+            let depr_entry = DeprecationEntry::local(depr.clone(), hir_id);\n+            self.index.depr_map.insert(hir_id, depr_entry);\n+        } else if let Some(parent_depr) = self.parent_depr.clone() {\n+            is_deprecated = true;\n+            info!(\"tagging child {:?} as deprecated from parent\", hir_id);\n+            self.index.depr_map.insert(hir_id, parent_depr);\n+        }\n+\n+        if self.tcx.features().staged_api {\n+            if let Some(..) = attrs.iter().find(|a| a.check_name(sym::deprecated)) {\n+                self.tcx.sess.span_err(\n+                    item_sp,\n+                    \"`#[deprecated]` cannot be used in staged API; \\\n+                                                use `#[rustc_deprecated]` instead\",\n+                );\n+            }\n+        } else {\n+            self.recurse_with_stability_attrs(\n+                depr.map(|d| DeprecationEntry::local(d, hir_id)),\n+                None,\n+                None,\n+                visit_children,\n             );\n+            return;\n         }\n \n         let (stab, const_stab) = attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n@@ -92,33 +122,34 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        let stab = stab.map(|mut stab| {\n+        if depr.as_ref().map_or(false, |d| d.is_since_rustc_version) {\n+            if stab.is_none() {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    item_sp,\n+                    E0549,\n+                    \"rustc_deprecated attribute must be paired with \\\n+                    either stable or unstable attribute\"\n+                )\n+                .emit();\n+            }\n+        }\n+\n+        let stab = stab.map(|stab| {\n             // Error if prohibited, or can't inherit anything from a container.\n             if kind == AnnotationKind::Prohibited\n-                || (kind == AnnotationKind::Container\n-                    && stab.level.is_stable()\n-                    && stab.rustc_depr.is_none())\n+                || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n                 self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n-            // If parent is deprecated and we're not, inherit this by merging\n-            // deprecated_since and its reason.\n-            if let Some(parent_stab) = self.parent_stab {\n-                if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n-                    stab.rustc_depr = parent_stab.rustc_depr\n-                }\n-            }\n-\n             let stab = self.tcx.intern_stability(stab);\n \n             // Check if deprecated_since < stable_since. If it is,\n             // this is *almost surely* an accident.\n-            if let (\n-                &Some(attr::RustcDeprecation { since: dep_since, .. }),\n-                &attr::Stable { since: stab_since },\n-            ) = (&stab.rustc_depr, &stab.level)\n+            if let (&Some(dep_since), &attr::Stable { since: stab_since }) =\n+                (&depr.as_ref().and_then(|d| d.since), &stab.level)\n             {\n                 // Explicit version of iter::order::lt to handle parse errors properly\n                 for (dep_v, stab_v) in\n@@ -163,19 +194,29 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        self.recurse_with_stability_attrs(stab, const_stab, visit_children);\n+        self.recurse_with_stability_attrs(\n+            depr.map(|d| DeprecationEntry::local(d, hir_id)),\n+            stab,\n+            const_stab,\n+            visit_children,\n+        );\n     }\n \n     fn recurse_with_stability_attrs(\n         &mut self,\n+        depr: Option<DeprecationEntry>,\n         stab: Option<&'tcx Stability>,\n         const_stab: Option<&'tcx ConstStability>,\n         f: impl FnOnce(&mut Self),\n     ) {\n         // These will be `Some` if this item changes the corresponding stability attribute.\n+        let mut replaced_parent_depr = None;\n         let mut replaced_parent_stab = None;\n         let mut replaced_parent_const_stab = None;\n \n+        if let Some(depr) = depr {\n+            replaced_parent_depr = Some(replace(&mut self.parent_depr, Some(depr)));\n+        }\n         if let Some(stab) = stab {\n             replaced_parent_stab = Some(replace(&mut self.parent_stab, Some(stab)));\n         }\n@@ -186,6 +227,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         f(self);\n \n+        if let Some(orig_parent_depr) = replaced_parent_depr {\n+            self.parent_depr = orig_parent_depr;\n+        }\n         if let Some(orig_parent_stab) = replaced_parent_stab {\n             self.parent_stab = orig_parent_stab;\n         }\n@@ -194,14 +238,8 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n     }\n \n-    fn forbid_staged_api_attrs(\n-        &mut self,\n-        hir_id: HirId,\n-        attrs: &[Attribute],\n-        item_sp: Span,\n-        kind: AnnotationKind,\n-        visit_children: impl FnOnce(&mut Self),\n-    ) {\n+    // returns true if an error occurred, used to suppress some spurious errors\n+    fn forbid_staged_api_attrs(&mut self, hir_id: HirId, attrs: &[Attribute]) -> bool {\n         // Emit errors for non-staged-api crates.\n         let unstable_attrs = [\n             sym::unstable,\n@@ -210,6 +248,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             sym::rustc_const_unstable,\n             sym::rustc_const_stable,\n         ];\n+        let mut has_error = false;\n         for attr in attrs {\n             let name = attr.name_or_empty();\n             if unstable_attrs.contains(&name) {\n@@ -221,6 +260,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                     \"stability attributes may not be used outside of the standard library\",\n                 )\n                 .emit();\n+                has_error = true;\n             }\n         }\n \n@@ -232,24 +272,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        if let Some(depr) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-            if kind == AnnotationKind::Prohibited {\n-                self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n-            }\n-\n-            // `Deprecation` is just two pointers, no need to intern it\n-            let depr_entry = DeprecationEntry::local(depr, hir_id);\n-            self.index.depr_map.insert(hir_id, depr_entry.clone());\n-\n-            let orig_parent_depr = replace(&mut self.parent_depr, Some(depr_entry));\n-            visit_children(self);\n-            self.parent_depr = orig_parent_depr;\n-        } else if let Some(parent_depr) = self.parent_depr.clone() {\n-            self.index.depr_map.insert(hir_id, parent_depr);\n-            visit_children(self);\n-        } else {\n-            visit_children(self);\n-        }\n+        has_error\n     }\n }\n \n@@ -454,7 +477,6 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n                     is_soft: false,\n                 },\n                 feature: sym::rustc_private,\n-                rustc_depr: None,\n             });\n             annotator.parent_stab = Some(stability);\n         }"}, {"sha": "fee7cb4836e3d6a61e11901540979b02f4e33b23", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -1017,22 +1017,17 @@ impl<'a> Resolver<'a> {\n                     );\n                 }\n             }\n-            if let Some(depr) = &stability.rustc_depr {\n-                let path = pprust::path_to_string(path);\n-                let (message, lint) = stability::rustc_deprecation_message(depr, &path);\n-                stability::early_report_deprecation(\n-                    &mut self.lint_buffer,\n-                    &message,\n-                    depr.suggestion,\n-                    lint,\n-                    span,\n-                );\n-            }\n         }\n         if let Some(depr) = &ext.deprecation {\n             let path = pprust::path_to_string(&path);\n             let (message, lint) = stability::deprecation_message(depr, &path);\n-            stability::early_report_deprecation(&mut self.lint_buffer, &message, None, lint, span);\n+            stability::early_report_deprecation(\n+                &mut self.lint_buffer,\n+                &message,\n+                depr.suggestion,\n+                lint,\n+                span,\n+            );\n         }\n     }\n "}, {"sha": "e6d59d30e2f585331ba3bff358cf7e50acd16602", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -1485,28 +1485,33 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n                 for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n                     let br_name = match *br {\n-                        ty::BrNamed(_, name) => name,\n-                        _ => {\n-                            span_bug!(\n-                                binding.span,\n-                                \"anonymous bound region {:?} in binding but not trait ref\",\n-                                br\n-                            );\n-                        }\n+                        ty::BrNamed(_, name) => format!(\"lifetime `{}`\", name),\n+                        _ => \"an anonymous lifetime\".to_string(),\n                     };\n                     // FIXME: point at the type params that don't have appropriate lifetimes:\n                     // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n                     //                         ----  ----     ^^^^^^^\n-                    struct_span_err!(\n+                    let mut err = struct_span_err!(\n                         tcx.sess,\n                         binding.span,\n                         E0582,\n-                        \"binding for associated type `{}` references lifetime `{}`, \\\n+                        \"binding for associated type `{}` references {}, \\\n                          which does not appear in the trait input types\",\n                         binding.item_name,\n                         br_name\n-                    )\n-                    .emit();\n+                    );\n+\n+                    if let ty::BrAnon(_) = *br {\n+                        // The only way for an anonymous lifetime to wind up\n+                        // in the return type but **also** be unconstrained is\n+                        // if it only appears in \"associated types\" in the\n+                        // input. See #62200 for an example. In this case,\n+                        // though we can easily give a hint that ought to be\n+                        // relevant.\n+                        err.note(\"lifetimes appearing in an associated type are not considered constrained\");\n+                    }\n+\n+                    err.emit();\n                 }\n             }\n         }"}, {"sha": "94d95115dcdbcaed7bfd447b6cc22331da063d87", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -2353,10 +2353,6 @@ impl Clean<Stability> for attr::Stability {\n                 attr::Stable { ref since } => since.to_string(),\n                 _ => String::new(),\n             },\n-            deprecation: self.rustc_depr.as_ref().map(|d| Deprecation {\n-                note: Some(d.reason.to_string()).filter(|r| !r.is_empty()),\n-                since: Some(d.since.to_string()).filter(|d| !d.is_empty()),\n-            }),\n             unstable_reason: match self.level {\n                 attr::Unstable { reason: Some(ref reason), .. } => Some(reason.to_string()),\n                 _ => None,\n@@ -2374,6 +2370,7 @@ impl Clean<Deprecation> for attr::Deprecation {\n         Deprecation {\n             since: self.since.map(|s| s.to_string()).filter(|s| !s.is_empty()),\n             note: self.note.map(|n| n.to_string()).filter(|n| !n.is_empty()),\n+            is_since_rustc_version: self.is_since_rustc_version,\n         }\n     }\n }"}, {"sha": "071834c59d65ec749aafa5f8b4a72113638b74d7", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -195,7 +195,8 @@ impl Item {\n                 classes.push(\"unstable\");\n             }\n \n-            if s.deprecation.is_some() {\n+            // FIXME: what about non-staged API items that are deprecated?\n+            if self.deprecation.is_some() {\n                 classes.push(\"deprecated\");\n             }\n \n@@ -216,14 +217,6 @@ impl Item {\n         ItemType::from(self)\n     }\n \n-    /// Returns the info in the item's `#[deprecated]` or `#[rustc_deprecated]` attributes.\n-    ///\n-    /// If the item is not deprecated, returns `None`.\n-    pub fn deprecation(&self) -> Option<&Deprecation> {\n-        self.deprecation\n-            .as_ref()\n-            .or_else(|| self.stability.as_ref().and_then(|s| s.deprecation.as_ref()))\n-    }\n     pub fn is_default(&self) -> bool {\n         match self.inner {\n             ItemEnum::MethodItem(ref meth) => {\n@@ -1528,7 +1521,6 @@ pub struct Stability {\n     pub level: stability::StabilityLevel,\n     pub feature: Option<String>,\n     pub since: String,\n-    pub deprecation: Option<Deprecation>,\n     pub unstable_reason: Option<String>,\n     pub issue: Option<NonZeroU32>,\n }\n@@ -1537,6 +1529,7 @@ pub struct Stability {\n pub struct Deprecation {\n     pub since: Option<String>,\n     pub note: Option<String>,\n+    pub is_since_rustc_version: bool,\n }\n \n /// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or"}, {"sha": "f7050cf377722622eee91859903f82a04b0cf5d0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -2216,16 +2216,10 @@ fn stability_tags(item: &clean::Item) -> String {\n     }\n \n     // The trailing space after each tag is to space it properly against the rest of the docs.\n-    if item.deprecation().is_some() {\n+    if let Some(depr) = &item.deprecation {\n         let mut message = \"Deprecated\";\n-        if let Some(ref stab) = item.stability {\n-            if let Some(ref depr) = stab.deprecation {\n-                if let Some(ref since) = depr.since {\n-                    if !stability::deprecation_in_effect(&since) {\n-                        message = \"Deprecation planned\";\n-                    }\n-                }\n-            }\n+        if !stability::deprecation_in_effect(depr.is_since_rustc_version, depr.since.as_deref()) {\n+            message = \"Deprecation planned\";\n         }\n         tags += &tag_html(\"deprecated\", message);\n     }\n@@ -2254,23 +2248,18 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     let mut stability = vec![];\n     let error_codes = cx.shared.codes;\n \n-    if let Some(Deprecation { note, since }) = &item.deprecation() {\n+    if let Some(Deprecation { ref note, ref since, is_since_rustc_version }) = item.deprecation {\n         // We display deprecation messages for #[deprecated] and #[rustc_deprecated]\n         // but only display the future-deprecation messages for #[rustc_deprecated].\n         let mut message = if let Some(since) = since {\n-            format!(\"Deprecated since {}\", Escape(since))\n+            if !stability::deprecation_in_effect(is_since_rustc_version, Some(since)) {\n+                format!(\"Deprecating in {}\", Escape(&since))\n+            } else {\n+                format!(\"Deprecated since {}\", Escape(&since))\n+            }\n         } else {\n             String::from(\"Deprecated\")\n         };\n-        if let Some(ref stab) = item.stability {\n-            if let Some(ref depr) = stab.deprecation {\n-                if let Some(ref since) = depr.since {\n-                    if !stability::deprecation_in_effect(&since) {\n-                        message = format!(\"Deprecating in {}\", Escape(&since));\n-                    }\n-                }\n-            }\n-        }\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();"}, {"sha": "41fe8e0fafb413185b7fa4e0043758435b2539d4", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -62,6 +62,10 @@ pre {\n \tbackground-color: #14191f;\n }\n \n+.logo-container > img {\n+\tfilter: drop-shadow(0 0 5px #fff);\n+}\n+\n /* Improve the scrollbar display on firefox */\n * {\n \tscrollbar-color: #5c6773 transparent;\n@@ -322,7 +326,7 @@ a.test-arrow:hover {\n \n :target > code, :target > .in-band {\n \tbackground: rgba(255, 236, 164, 0.06);\n-\tborder-right: 3px solid #ffb44c;\n+\tborder-right: 3px solid rgba(255, 180, 76, 0.85);\n }\n \n pre.compile_fail {"}, {"sha": "b3b586ba362fa475b9f7c5c392bcf126305527c8", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -34,6 +34,10 @@ pre {\n \tbackground-color: #505050;\n }\n \n+.logo-container > img {\n+\tfilter: drop-shadow(0 0 5px #fff);\n+}\n+\n /* Improve the scrollbar display on firefox */\n * {\n \tscrollbar-color: rgb(64, 65, 67) #717171;\n@@ -270,6 +274,7 @@ a.test-arrow:hover{\n \n :target > code, :target > .in-band {\n \tbackground-color: #494a3d;\n+\tborder-right: 3px solid #bb7410;\n }\n \n pre.compile_fail {"}, {"sha": "b0c5715604baab86ea5d29eab697f5b3b6a0701f", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -45,6 +45,10 @@ pre {\n \tscrollbar-color: rgba(36, 37, 39, 0.6) #d9d9d9;\n }\n \n+.logo-container > img {\n+\tfilter: drop-shadow(0 0 5px #aaa);\n+}\n+\n /* Improve the scrollbar display on webkit-based browsers */\n ::-webkit-scrollbar-track {\n \tbackground-color: #ecebeb;\n@@ -265,6 +269,7 @@ a.test-arrow:hover{\n \n :target > code, :target > .in-band {\n \tbackground: #FDFFD3;\n+\tborder-right: 3px solid #ffb44c;\n }\n \n pre.compile_fail {"}, {"sha": "9d18690e96049a189cf6190449d3d1060b762e8e", "filename": "src/test/ui/associated-types/issue-62200.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -0,0 +1,15 @@\n+struct S {}\n+\n+trait T<'a> {\n+    type A;\n+}\n+\n+impl T<'_> for S {\n+    type A = u32;\n+}\n+\n+fn foo(x: impl Fn(<S as T<'_>>::A) -> <S as T<'_>>::A) {}\n+//~^ ERROR binding for associated type `Output` references an anonymous lifetime\n+//~^^ NOTE lifetimes appearing in an associated type are not considered constrained\n+\n+fn main() {}"}, {"sha": "f14cd81fdfe1f43583bb1b429d07437e93894eff", "filename": "src/test/ui/associated-types/issue-62200.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-62200.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -0,0 +1,11 @@\n+error[E0582]: binding for associated type `Output` references an anonymous lifetime, which does not appear in the trait input types\n+  --> $DIR/issue-62200.rs:11:39\n+   |\n+LL | fn foo(x: impl Fn(<S as T<'_>>::A) -> <S as T<'_>>::A) {}\n+   |                                       ^^^^^^^^^^^^^^^\n+   |\n+   = note: lifetimes appearing in an associated type are not considered constrained\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0582`."}, {"sha": "687dd97ca6cefc438a6fc33af03dec17016cf954", "filename": "src/test/ui/closure-expected.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fclosure-expected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fclosure-expected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -5,7 +5,7 @@ LL |     let y = x.or_else(4);\n    |                       ^ expected an `FnOnce<()>` closure, found `{integer}`\n    |\n    = help: the trait `std::ops::FnOnce<()>` is not implemented for `{integer}`\n-   = note: wrap the `{integer}` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `{integer}` in a closure with no arguments: `|| { /* code */ }`\n \n error: aborting due to previous error\n "}, {"sha": "2cb15f84f6973922f4cb0087658df1268d93c75d", "filename": "src/test/ui/extern/extern-wrong-value-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fextern%2Fextern-wrong-value-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fextern%2Fextern-wrong-value-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-wrong-value-type.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -8,7 +8,7 @@ LL |     is_fn(f);\n    |           ^ expected an `Fn<()>` closure, found `extern \"C\" fn() {f}`\n    |\n    = help: the trait `std::ops::Fn<()>` is not implemented for `extern \"C\" fn() {f}`\n-   = note: wrap the `extern \"C\" fn() {f}` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `extern \"C\" fn() {f}` in a closure with no arguments: `|| { /* code */ }`\n \n error: aborting due to previous error\n "}, {"sha": "2fe266b8018ebe81496836921d1c805ff29111fd", "filename": "src/test/ui/generic-associated-types/issue-68642-broken-llvm-ir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -16,7 +16,7 @@ LL |     type F<'a>: Fn() -> u32;\n LL |     type F<'a> = Self;\n    |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`\n    |\n-   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }`\n help: consider restricting type parameter `T`\n    |\n LL | impl<T: std::ops::Fn<()>> Fun for T {"}, {"sha": "e335523778b4703157e040e24be84d36b5ac1a1e", "filename": "src/test/ui/generic-associated-types/issue-68643-broken-mir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -16,7 +16,7 @@ LL |     type F<'a>: Fn() -> u32;\n LL |     type F<'a> = Self;\n    |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`\n    |\n-   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }`\n help: consider restricting type parameter `T`\n    |\n LL | impl<T: std::ops::Fn<()>> Fun for T {"}, {"sha": "d7a5bb0ebe5439130f9f5d22eaa43fb6cfb94db6", "filename": "src/test/ui/generic-associated-types/issue-68644-codegen-selection.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -16,7 +16,7 @@ LL |     type F<'a>: Fn() -> u32;\n LL |     type F<'a> = Self;\n    |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`\n    |\n-   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }`\n help: consider restricting type parameter `T`\n    |\n LL | impl<T: std::ops::Fn<()>> Fun for T {"}, {"sha": "0670625aa2f1b0abc59e65808aa6760cad20d1a5", "filename": "src/test/ui/generic-associated-types/issue-68645-codegen-fulfillment.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -16,7 +16,7 @@ LL |     type F<'a>: Fn() -> u32;\n LL |     type F<'a> = Self;\n    |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`\n    |\n-   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `T` in a closure with no arguments: `|| { /* code */ }`\n help: consider restricting type parameter `T`\n    |\n LL | impl<T: std::ops::Fn<()>> Fun for T {"}, {"sha": "2e4f3e675c3b1bcd6b50bd44c70dbf64044faf2e", "filename": "src/test/ui/issue-74047.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fissue-74047.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fissue-74047.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-74047.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+\n+use std::convert::{TryFrom, TryInto};\n+use std::io;\n+\n+pub struct MyStream;\n+pub struct OtherStream;\n+\n+pub async fn connect() -> io::Result<MyStream> {\n+    let stream: MyStream = OtherStream.try_into()?;\n+    Ok(stream)\n+}\n+\n+impl TryFrom<OtherStream> for MyStream {}\n+//~^ ERROR: missing\n+\n+fn main() {}"}, {"sha": "6f477c77cedbd406f3125d8e09bf8532c20ffc4d", "filename": "src/test/ui/issue-74047.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fissue-74047.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fissue-74047.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-74047.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -0,0 +1,12 @@\n+error[E0046]: not all trait items implemented, missing: `Error`, `try_from`\n+  --> $DIR/issue-74047.rs:14:1\n+   |\n+LL | impl TryFrom<OtherStream> for MyStream {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `Error`, `try_from` in implementation\n+   |\n+   = help: implement the missing item: `type Error = Type;`\n+   = help: implement the missing item: `fn try_from(_: T) -> std::result::Result<Self, <Self as std::convert::TryFrom<T>>::Error> { todo!() }`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0046`."}, {"sha": "132880aab11e360feff89af057f3bd162f284eb4", "filename": "src/test/ui/issues/issue-22034.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fissues%2Fissue-22034.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fissues%2Fissue-22034.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22034.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -5,7 +5,7 @@ LL |         &mut *(ptr as *mut dyn Fn())\n    |                ^^^ expected an `Fn<()>` closure, found `()`\n    |\n    = help: the trait `std::ops::Fn<()>` is not implemented for `()`\n-   = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n    = note: required for the cast to the object type `dyn std::ops::Fn()`\n \n error: aborting due to previous error"}, {"sha": "0d3af7a89c2aac2936426d8992c880c9dbd2511c", "filename": "src/test/ui/polymorphization/promoted-function.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fpolymorphization%2Fpromoted-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fpolymorphization%2Fpromoted-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fpromoted-function.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+fn fop<T>() {}\n+\n+fn bar<T>() -> &'static fn() {\n+    &(fop::<T> as fn())\n+}\n+pub const FN: &'static fn() = &(fop::<i32> as fn());\n+\n+fn main() {\n+    bar::<u32>();\n+    bar::<i32>();\n+    (FN)();\n+}"}, {"sha": "f9b4eed0497c4d83af83f6a2b6743ee8cd22a481", "filename": "src/test/ui/rfcs/rfc-2396-target_feature-11/fn-traits.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -8,7 +8,7 @@ LL |     call(foo);\n    |          ^^^ expected an `Fn<()>` closure, found `fn() {foo}`\n    |\n    = help: the trait `std::ops::Fn<()>` is not implemented for `fn() {foo}`\n-   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }`\n    = note: `#[target_feature]` functions do not implement the `Fn` traits\n \n error[E0277]: expected a `std::ops::FnMut<()>` closure, found `fn() {foo}`\n@@ -21,7 +21,7 @@ LL |     call_mut(foo);\n    |              ^^^ expected an `FnMut<()>` closure, found `fn() {foo}`\n    |\n    = help: the trait `std::ops::FnMut<()>` is not implemented for `fn() {foo}`\n-   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }`\n    = note: `#[target_feature]` functions do not implement the `Fn` traits\n \n error[E0277]: expected a `std::ops::FnOnce<()>` closure, found `fn() {foo}`\n@@ -34,7 +34,7 @@ LL |     call_once(foo);\n    |               ^^^ expected an `FnOnce<()>` closure, found `fn() {foo}`\n    |\n    = help: the trait `std::ops::FnOnce<()>` is not implemented for `fn() {foo}`\n-   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }`\n    = note: `#[target_feature]` functions do not implement the `Fn` traits\n \n error[E0277]: expected a `std::ops::Fn<()>` closure, found `unsafe fn() {foo_unsafe}`\n@@ -47,7 +47,7 @@ LL |     call(foo_unsafe);\n    |          ^^^^^^^^^^ expected an `Fn<()>` closure, found `unsafe fn() {foo_unsafe}`\n    |\n    = help: the trait `std::ops::Fn<()>` is not implemented for `unsafe fn() {foo_unsafe}`\n-   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }`\n    = note: `#[target_feature]` functions do not implement the `Fn` traits\n \n error[E0277]: expected a `std::ops::FnMut<()>` closure, found `unsafe fn() {foo_unsafe}`\n@@ -60,7 +60,7 @@ LL |     call_mut(foo_unsafe);\n    |              ^^^^^^^^^^ expected an `FnMut<()>` closure, found `unsafe fn() {foo_unsafe}`\n    |\n    = help: the trait `std::ops::FnMut<()>` is not implemented for `unsafe fn() {foo_unsafe}`\n-   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }`\n    = note: `#[target_feature]` functions do not implement the `Fn` traits\n \n error[E0277]: expected a `std::ops::FnOnce<()>` closure, found `unsafe fn() {foo_unsafe}`\n@@ -73,7 +73,7 @@ LL |     call_once(foo_unsafe);\n    |               ^^^^^^^^^^ expected an `FnOnce<()>` closure, found `unsafe fn() {foo_unsafe}`\n    |\n    = help: the trait `std::ops::FnOnce<()>` is not implemented for `unsafe fn() {foo_unsafe}`\n-   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }\n+   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }`\n    = note: `#[target_feature]` functions do not implement the `Fn` traits\n \n error: aborting due to 6 previous errors"}, {"sha": "80d7ae6dc637d78723cdc17ab762f4d7945bc324", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.rs?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -62,7 +62,7 @@ fn multiple3() { }\n #[rustc_deprecated(since = \"b\", reason = \"text\")]\n #[rustc_const_unstable(feature = \"c\", issue = \"none\")]\n #[rustc_const_unstable(feature = \"d\", issue = \"none\")] //~ ERROR multiple stability levels\n-pub const fn multiple4() { } //~ ERROR multiple rustc_deprecated attributes [E0540]\n+pub const fn multiple4() { } //~ ERROR multiple deprecated attributes\n //~^ ERROR Invalid stability or deprecation version found\n \n #[rustc_deprecated(since = \"a\", reason = \"text\")]"}, {"sha": "134c657c62015b51be3739ec0fa7ba2d048d14a1", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900869371e13cead086f4f9809419daa6a63cfaf/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr?ref=900869371e13cead086f4f9809419daa6a63cfaf", "patch": "@@ -82,7 +82,7 @@ error[E0544]: multiple stability levels\n LL | #[stable(feature = \"a\", since = \"b\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0540]: multiple rustc_deprecated attributes\n+error[E0550]: multiple deprecated attributes\n   --> $DIR/stability-attribute-sanity.rs:65:1\n    |\n LL | pub const fn multiple4() { }\n@@ -108,5 +108,5 @@ LL | fn deprecated_without_unstable_or_stable() { }\n \n error: aborting due to 18 previous errors\n \n-Some errors have detailed explanations: E0539, E0541.\n+Some errors have detailed explanations: E0539, E0541, E0550.\n For more information about an error, try `rustc --explain E0539`."}]}