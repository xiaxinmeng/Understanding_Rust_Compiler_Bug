{"sha": "6d42574b7a22831de97a6ca458f22d011561be56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNDI1NzRiN2EyMjgzMWRlOTdhNmNhNDU4ZjIyZDAxMTU2MWJlNTY=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-06T18:57:42Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Prefixed const methods with \"const\" instead of \"c\"", "tree": {"sha": "04055e1def3968b6087041fb8eefd5c150da619f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04055e1def3968b6087041fb8eefd5c150da619f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d42574b7a22831de97a6ca458f22d011561be56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d42574b7a22831de97a6ca458f22d011561be56", "html_url": "https://github.com/rust-lang/rust/commit/6d42574b7a22831de97a6ca458f22d011561be56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d42574b7a22831de97a6ca458f22d011561be56/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "730b13ab51b0885cb8a750036e9429e6c2a193f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/730b13ab51b0885cb8a750036e9429e6c2a193f1", "html_url": "https://github.com/rust-lang/rust/commit/730b13ab51b0885cb8a750036e9429e6c2a193f1"}], "stats": {"total": 424, "additions": 212, "deletions": 212}, "files": [{"sha": "edd1ff59a01e5eb3922adceea9a313835314c912", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -244,7 +244,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                                   self.layout.align,\n                                   bx.pointercast(llscratch, cx.i8p()),\n                                   scratch_align,\n-                                  cx.c_usize(self.layout.size.bytes()),\n+                                  cx.const_usize(self.layout.size.bytes()),\n                                   MemFlags::empty());\n \n                 bx.lifetime_end(llscratch, scratch_size);"}, {"sha": "fcf2ea8f8fa23921678461419a9b7550de749f51", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -110,7 +110,7 @@ pub fn codegen_inline_asm(\n         let kind = llvm::LLVMGetMDKindIDInContext(bx.cx().llcx,\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: &'ll Value = bx.cx().c_i32(ia.ctxt.outer().as_u32() as i32);\n+        let val: &'ll Value = bx.cx().const_i32(ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bx.cx().llcx, &val, 1));"}, {"sha": "9eaafb1c21d3ed0acf1fe18eca78a8b06f3f083a", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -442,17 +442,17 @@ impl CommonWriteMethods for CodegenContext<'ll> {\n         common::val_ty(v)\n     }\n \n-    fn c_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n-        common::c_bytes_in_context(llcx, bytes)\n+    fn const_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+        common::const_bytes_in_context(llcx, bytes)\n     }\n \n-    fn c_struct_in_context(\n+    fn const_struct_in_context(\n         &self,\n         llcx: &'a llvm::Context,\n         elts: &[&'a Value],\n         packed: bool,\n     ) -> &'a Value {\n-        common::c_struct_in_context(llcx, elts, packed)\n+        common::const_struct_in_context(llcx, elts, packed)\n     }\n }\n \n@@ -926,7 +926,7 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n                         llcx: &llvm::Context,\n                         llmod: &llvm::Module,\n                         bitcode: Option<&[u8]>) {\n-    let llconst = cgcx.c_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n+    let llconst = cgcx.const_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n         cgcx.val_ty(llconst),\n@@ -946,7 +946,7 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n \n-    let llconst = cgcx.c_bytes_in_context(llcx, &[]);\n+    let llconst = cgcx.const_bytes_in_context(llcx, &[]);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n         cgcx.val_ty(llconst),"}, {"sha": "6d75d64124b8398f7263bb05397f94b1b761ca26", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -198,7 +198,7 @@ pub fn unsized_info(\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n-            cx.c_usize(len.unwrap_usize(cx.tcx))\n+            cx.const_usize(len.unwrap_usize(cx.tcx))\n         }\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n@@ -460,7 +460,7 @@ pub fn memcpy_ty<'a, 'll: 'a, 'tcx: 'll>(\n         return;\n     }\n \n-    call_memcpy(bx, dst, dst_align, src, src_align, bx.cx().c_usize(size), flags);\n+    call_memcpy(bx, dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n }\n \n pub fn call_memset(\n@@ -474,7 +474,7 @@ pub fn call_memset(\n     let ptr_width = &bx.cx().sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = bx.cx().get_intrinsic(&intrinsic_key);\n-    let volatile = bx.cx().c_bool(volatile);\n+    let volatile = bx.cx().const_bool(volatile);\n     bx.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n@@ -649,8 +649,8 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     DeflateEncoder::new(&mut compressed, Compression::fast())\n         .write_all(&metadata.raw_data).unwrap();\n \n-    let llmeta = llvm_module.c_bytes_in_context(metadata_llcx, &compressed);\n-    let llconst = llvm_module.c_struct_in_context(metadata_llcx, &[llmeta], false);\n+    let llmeta = llvm_module.const_bytes_in_context(metadata_llcx, &compressed);\n+    let llconst = llvm_module.const_struct_in_context(metadata_llcx, &[llmeta], false);\n     let name = exported_symbols::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n@@ -1151,7 +1151,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if !cx.used_statics.borrow().is_empty() {\n                 let name = const_cstr!(\"llvm.used\");\n                 let section = const_cstr!(\"llvm.metadata\");\n-                let array = cx.c_array(&cx.ptr_to(cx.i8()), &*cx.used_statics.borrow());\n+                let array = cx.const_array(&cx.ptr_to(cx.i8()), &*cx.used_statics.borrow());\n \n                 unsafe {\n                     let g = llvm::LLVMAddGlobal(cx.llmod,"}, {"sha": "ef7f29ac7ddc8d23e6fccef94ee94bb983b6bdd3", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -530,8 +530,8 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe {\n             let llty = self.cx.val_ty(load);\n             let v = [\n-                self.cx.c_uint_big(llty, range.start),\n-                self.cx.c_uint_big(llty, range.end)\n+                self.cx.const_uint_big(llty, range.start),\n+                self.cx.const_uint_big(llty, range.end)\n             ];\n \n             llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n@@ -578,7 +578,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 // *always* point to a metadata value of the integer 1.\n                 //\n                 // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n-                let one = self.cx.c_i32(1);\n+                let one = self.cx.const_i32(1);\n                 let node = llvm::LLVMMDNodeInContext(self.cx.llcx, &one, 1);\n                 llvm::LLVMSetMetadata(store, llvm::MD_nontemporal as c_uint, node);\n             }\n@@ -862,9 +862,9 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe {\n             let elt_ty = self.cx.val_ty(elt);\n             let undef = llvm::LLVMGetUndef(&self.cx().vector(elt_ty, num_elts as u64));\n-            let vec = self.insert_element(undef, elt, self.cx.c_i32(0));\n+            let vec = self.insert_element(undef, elt, self.cx.const_i32(0));\n             let vec_i32_ty = &self.cx().vector(&self.cx().i32(), num_elts as u64);\n-            self.shuffle_vector(vec, undef, self.cx().c_null(vec_i32_ty))\n+            self.shuffle_vector(vec, undef, self.cx().const_null(vec_i32_ty))\n         }\n     }\n \n@@ -1228,7 +1228,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n \n         let ptr = self.pointercast(ptr, self.cx.i8p());\n-        self.call(lifetime_intrinsic, &[self.cx.c_u64(size), ptr], None);\n+        self.call(lifetime_intrinsic, &[self.cx.const_u64(size), ptr], None);\n     }\n \n     fn call(&self, llfn: &'ll Value, args: &[&'ll Value],"}, {"sha": "db4d732ff142720c4d43d614dcefa4082f8a360d", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -204,71 +204,71 @@ impl Backend for CodegenCx<'ll, 'tcx> {\n impl<'ll, 'tcx: 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n \n     // LLVM constant constructors.\n-    fn c_null(&self, t: &'ll Type) -> &'ll Value {\n+    fn const_null(&self, t: &'ll Type) -> &'ll Value {\n         unsafe {\n             llvm::LLVMConstNull(t)\n         }\n     }\n \n-    fn c_undef(&self, t: &'ll Type) -> &'ll Value {\n+    fn const_undef(&self, t: &'ll Type) -> &'ll Value {\n         unsafe {\n             llvm::LLVMGetUndef(t)\n         }\n     }\n \n-    fn c_int(&self, t: &'ll Type, i: i64) -> &'ll Value {\n+    fn const_int(&self, t: &'ll Type, i: i64) -> &'ll Value {\n         unsafe {\n             llvm::LLVMConstInt(t, i as u64, True)\n         }\n     }\n \n-    fn c_uint(&self, t: &'ll Type, i: u64) -> &'ll Value {\n+    fn const_uint(&self, t: &'ll Type, i: u64) -> &'ll Value {\n         unsafe {\n             llvm::LLVMConstInt(t, i, False)\n         }\n     }\n \n-    fn c_uint_big(&self, t: &'ll Type, u: u128) -> &'ll Value {\n+    fn const_uint_big(&self, t: &'ll Type, u: u128) -> &'ll Value {\n         unsafe {\n             let words = [u as u64, (u >> 64) as u64];\n             llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n         }\n     }\n \n-    fn c_bool(&self, val: bool) -> &'ll Value {\n-        &self.c_uint(&self.i1(), val as u64)\n+    fn const_bool(&self, val: bool) -> &'ll Value {\n+        &self.const_uint(&self.i1(), val as u64)\n     }\n \n-    fn c_i32(&self, i: i32) -> &'ll Value {\n-        &self.c_int(&self.i32(), i as i64)\n+    fn const_i32(&self, i: i32) -> &'ll Value {\n+        &self.const_int(&self.i32(), i as i64)\n     }\n \n-    fn c_u32(&self, i: u32) -> &'ll Value {\n-        &self.c_uint(&self.i32(), i as u64)\n+    fn const_u32(&self, i: u32) -> &'ll Value {\n+        &self.const_uint(&self.i32(), i as u64)\n     }\n \n-    fn c_u64(&self, i: u64) -> &'ll Value {\n-        &self.c_uint(&self.i64(), i)\n+    fn const_u64(&self, i: u64) -> &'ll Value {\n+        &self.const_uint(&self.i64(), i)\n     }\n \n-    fn c_usize(&self, i: u64) -> &'ll Value {\n+    fn const_usize(&self, i: u64) -> &'ll Value {\n         let bit_size = self.data_layout().pointer_size.bits();\n         if bit_size < 64 {\n             // make sure it doesn't overflow\n             assert!(i < (1<<bit_size));\n         }\n \n-        &self.c_uint(&self.isize_ty, i)\n+        &self.const_uint(&self.isize_ty, i)\n     }\n \n-    fn c_u8(&self, i: u8) -> &'ll Value {\n-        &self.c_uint(&self.i8(), i as u64)\n+    fn const_u8(&self, i: u8) -> &'ll Value {\n+        &self.const_uint(&self.i8(), i as u64)\n     }\n \n \n     // This is a 'c-like' raw string, which differs from\n     // our boxed-and-length-annotated strings.\n-    fn c_cstr(\n+    fn const_cstr(\n         &self,\n         s: LocalInternedString,\n         null_terminated: bool,\n@@ -297,45 +297,45 @@ impl<'ll, 'tcx: 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n \n     // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n     // you will be kicked off fast isel. See issue #4352 for an example of this.\n-    fn c_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n+    fn const_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n         let len = s.len();\n-        let cs = consts::ptrcast(&self.c_cstr(s, false),\n+        let cs = consts::ptrcast(&self.const_cstr(s, false),\n             &self.ptr_to(&self.layout_of(&self.tcx.mk_str()).llvm_type(&self)));\n-        &self.c_fat_ptr(cs, &self.c_usize(len as u64))\n+        &self.const_fat_ptr(cs, &self.const_usize(len as u64))\n     }\n \n-    fn c_fat_ptr(\n+    fn const_fat_ptr(\n         &self,\n         ptr: &'ll Value,\n         meta: &'ll Value\n     ) -> &'ll Value {\n         assert_eq!(abi::FAT_PTR_ADDR, 0);\n         assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        &self.c_struct(&[ptr, meta], false)\n+        &self.const_struct(&[ptr, meta], false)\n     }\n \n-    fn c_struct(\n+    fn const_struct(\n         &self,\n         elts: &[&'ll Value],\n         packed: bool\n     ) -> &'ll Value {\n-        &self.c_struct_in_context(&self.llcx, elts, packed)\n+        &self.const_struct_in_context(&self.llcx, elts, packed)\n     }\n \n-    fn c_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n+    fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n         }\n     }\n \n-    fn c_vector(&self, elts: &[&'ll Value]) -> &'ll Value {\n+    fn const_vector(&self, elts: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n         }\n     }\n \n-    fn c_bytes(&self, bytes: &[u8]) -> &'ll Value {\n-        &self.c_bytes_in_context(&self.llcx, bytes)\n+    fn const_bytes(&self, bytes: &[u8]) -> &'ll Value {\n+        &self.const_bytes_in_context(&self.llcx, bytes)\n     }\n \n     fn const_get_elt(&self, v: &'ll Value, idx: u64) -> &'ll Value {\n@@ -406,14 +406,14 @@ pub fn val_ty(v: &'ll Value) -> &'ll Type {\n     }\n }\n \n-pub fn c_bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+pub fn const_bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n         return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n     }\n }\n \n-pub fn c_struct_in_context(\n+pub fn const_struct_in_context(\n     llcx: &'a llvm::Context,\n     elts: &[&'a Value],\n     packed: bool,\n@@ -430,17 +430,17 @@ impl<'ll, 'tcx: 'll> CommonWriteMethods for CodegenCx<'ll, 'tcx> {\n         val_ty(v)\n     }\n \n-    fn c_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n-        c_bytes_in_context(llcx, bytes)\n+    fn const_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+        const_bytes_in_context(llcx, bytes)\n     }\n \n-    fn c_struct_in_context(\n+    fn const_struct_in_context(\n         &self,\n         llcx: &'a llvm::Context,\n         elts: &[&'a Value],\n         packed: bool,\n     ) -> &'a Value {\n-        c_struct_in_context(llcx, elts, packed)\n+        const_struct_in_context(llcx, elts, packed)\n     }\n }\n \n@@ -511,9 +511,9 @@ pub fn shift_mask_val(\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n             let val = bx.cx().int_width(llty) - 1;\n             if invert {\n-                bx.cx.c_int(mask_llty, !val as i64)\n+                bx.cx.const_int(mask_llty, !val as i64)\n             } else {\n-                bx.cx.c_uint(mask_llty, val)\n+                bx.cx.const_uint(mask_llty, val)\n             }\n         },\n         TypeKind::Vector => {"}, {"sha": "f7e4d80d109e92eaec2fbf2094b80a27e84f1378", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -29,7 +29,7 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &Builder) {\n         let gdb_debug_scripts_section = get_or_insert_gdb_debug_scripts_section_global(bx.cx());\n         // Load just the first byte as that's all that's necessary to force\n         // LLVM to keep around the reference to the global.\n-        let indices = [bx.cx().c_i32(0), bx.cx().c_i32(0)];\n+        let indices = [bx.cx().const_i32(0), bx.cx().const_i32(0)];\n         let element = bx.inbounds_gep(gdb_debug_scripts_section, &indices);\n         let volative_load_instruction = bx.volatile_load(element);\n         unsafe {\n@@ -63,7 +63,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n                 bug!(\"symbol `{}` is already defined\", section_var_name)\n             });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n-            llvm::LLVMSetInitializer(section_var, cx.c_bytes(section_contents));\n+            llvm::LLVMSetInitializer(section_var, cx.const_bytes(section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n             llvm::LLVMRustSetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);"}, {"sha": "14b263380eb45ad69a7f6d29b6d0e834ef93e929", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -1811,7 +1811,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n                     member_description.offset.bits(),\n                     match member_description.discriminant {\n                         None => None,\n-                        Some(value) => Some(cx.c_u64(value)),\n+                        Some(value) => Some(cx.const_u64(value)),\n                     },\n                     member_description.flags,\n                     member_description.type_metadata))"}, {"sha": "fa2514b0ce895c4d157be9ea6fcaf5cf4a116418", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -33,8 +33,8 @@ pub fn size_and_align_of_dst(\n         let (size, align) = bx.cx().size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, info, size, align);\n-        let size = bx.cx().c_usize(size.bytes());\n-        let align = bx.cx().c_usize(align.abi());\n+        let size = bx.cx().const_usize(size.bytes());\n+        let align = bx.cx().const_usize(align.abi());\n         return (size, align);\n     }\n     match t.sty {\n@@ -48,8 +48,8 @@ pub fn size_and_align_of_dst(\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let (size, align) = bx.cx().size_and_align_of(unit);\n-            (bx.mul(info.unwrap(), bx.cx().c_usize(size.bytes())),\n-             bx.cx().c_usize(align.abi()))\n+            (bx.mul(info.unwrap(), bx.cx().const_usize(size.bytes())),\n+             bx.cx().const_usize(align.abi()))\n         }\n         _ => {\n             let cx = bx.cx();\n@@ -65,8 +65,8 @@ pub fn size_and_align_of_dst(\n             let sized_align = layout.align.abi();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n-            let sized_size = cx.c_usize(sized_size);\n-            let sized_align = cx.c_usize(sized_align);\n+            let sized_size = cx.const_usize(sized_size);\n+            let sized_align = cx.const_usize(sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -97,7 +97,7 @@ pub fn size_and_align_of_dst(\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    cx.c_usize(std::cmp::max(sized_align, unsized_align) as u64)\n+                    cx.const_usize(std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bx.select(bx.icmp(IntPredicate::IntUGT, sized_align, unsized_align),\n                                sized_align,\n@@ -115,7 +115,7 @@ pub fn size_and_align_of_dst(\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bx.sub(align, bx.cx().c_usize(1));\n+            let addend = bx.sub(align, bx.cx().const_usize(1));\n             let size = bx.and(bx.add(size, addend), bx.neg(align));\n \n             (size, align)"}, {"sha": "04b2d18db9506289c73e4ae4ccdc2f875acb1b8d", "filename": "src/librustc_codegen_llvm/interfaces/common.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -13,36 +13,36 @@ use syntax::symbol::LocalInternedString;\n \n pub trait CommonMethods: Backend + CommonWriteMethods {\n     // Constant constructors\n-    fn c_null(&self, t: Self::Type) -> Self::Value;\n-    fn c_undef(&self, t: Self::Type) -> Self::Value;\n-    fn c_int(&self, t: Self::Type, i: i64) -> Self::Value;\n-    fn c_uint(&self, t: Self::Type, i: u64) -> Self::Value;\n-    fn c_uint_big(&self, t: Self::Type, u: u128) -> Self::Value;\n-    fn c_bool(&self, val: bool) -> Self::Value;\n-    fn c_i32(&self, i: i32) -> Self::Value;\n-    fn c_u32(&self, i: u32) -> Self::Value;\n-    fn c_u64(&self, i: u64) -> Self::Value;\n-    fn c_usize(&self, i: u64) -> Self::Value;\n-    fn c_u8(&self, i: u8) -> Self::Value;\n-    fn c_cstr(\n+    fn const_null(&self, t: Self::Type) -> Self::Value;\n+    fn const_undef(&self, t: Self::Type) -> Self::Value;\n+    fn const_int(&self, t: Self::Type, i: i64) -> Self::Value;\n+    fn const_uint(&self, t: Self::Type, i: u64) -> Self::Value;\n+    fn const_uint_big(&self, t: Self::Type, u: u128) -> Self::Value;\n+    fn const_bool(&self, val: bool) -> Self::Value;\n+    fn const_i32(&self, i: i32) -> Self::Value;\n+    fn const_u32(&self, i: u32) -> Self::Value;\n+    fn const_u64(&self, i: u64) -> Self::Value;\n+    fn const_usize(&self, i: u64) -> Self::Value;\n+    fn const_u8(&self, i: u8) -> Self::Value;\n+    fn const_cstr(\n         &self,\n         s: LocalInternedString,\n         null_terminated: bool,\n     ) -> Self::Value;\n-    fn c_str_slice(&self, s: LocalInternedString) -> Self::Value;\n-    fn c_fat_ptr(\n+    fn const_str_slice(&self, s: LocalInternedString) -> Self::Value;\n+    fn const_fat_ptr(\n         &self,\n         ptr: Self::Value,\n         meta: Self::Value\n     ) -> Self::Value;\n-    fn c_struct(\n+    fn const_struct(\n         &self,\n         elts: &[Self::Value],\n         packed: bool\n     ) -> Self::Value;\n-    fn c_array(&self, ty: Self::Type, elts: &[Self::Value]) -> Self::Value;\n-    fn c_vector(&self, elts: &[Self::Value]) -> Self::Value;\n-    fn c_bytes(&self, bytes: &[u8]) -> Self::Value;\n+    fn const_array(&self, ty: Self::Type, elts: &[Self::Value]) -> Self::Value;\n+    fn const_vector(&self, elts: &[Self::Value]) -> Self::Value;\n+    fn const_bytes(&self, bytes: &[u8]) -> Self::Value;\n \n     fn const_get_elt(&self, v: Self::Value, idx: u64) -> Self::Value;\n     fn const_get_real(&self, v: Self::Value) -> Option<(f64, bool)>;\n@@ -55,8 +55,8 @@ pub trait CommonMethods: Backend + CommonWriteMethods {\n \n pub trait CommonWriteMethods: Backend {\n         fn val_ty(&self, v: Self::Value) -> Self::Type;\n-        fn c_bytes_in_context(&self, llcx: Self::Context, bytes: &[u8]) -> Self::Value;\n-        fn c_struct_in_context(\n+        fn const_bytes_in_context(&self, llcx: Self::Context, bytes: &[u8]) -> Self::Value;\n+        fn const_struct_in_context(\n             &self,\n             llcx: Self::Context,\n             elts: &[Self::Value],"}, {"sha": "be03dc5e143309eb2a7a5ae43582a03bb53102d1", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -127,11 +127,11 @@ pub fn codegen_intrinsic_call(\n         },\n         \"likely\" => {\n             let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bx.call(expect, &[args[0].immediate(), bx.cx().c_bool(true)], None)\n+            bx.call(expect, &[args[0].immediate(), bx.cx().const_bool(true)], None)\n         }\n         \"unlikely\" => {\n             let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bx.call(expect, &[args[0].immediate(), bx.cx().c_bool(false)], None)\n+            bx.call(expect, &[args[0].immediate(), bx.cx().const_bool(false)], None)\n         }\n         \"try\" => {\n             try_intrinsic(bx, cx,\n@@ -147,7 +147,7 @@ pub fn codegen_intrinsic_call(\n         }\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n-            cx.c_usize(cx.size_of(tp_ty).bytes())\n+            cx.const_usize(cx.size_of(tp_ty).bytes())\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -156,12 +156,12 @@ pub fn codegen_intrinsic_call(\n                     glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llsize\n             } else {\n-                cx.c_usize(cx.size_of(tp_ty).bytes())\n+                cx.const_usize(cx.size_of(tp_ty).bytes())\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            cx.c_usize(cx.align_of(tp_ty).abi())\n+            cx.const_usize(cx.align_of(tp_ty).abi())\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -170,20 +170,20 @@ pub fn codegen_intrinsic_call(\n                     glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llalign\n             } else {\n-                cx.c_usize(cx.align_of(tp_ty).abi())\n+                cx.const_usize(cx.align_of(tp_ty).abi())\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            cx.c_usize(cx.align_of(tp_ty).pref())\n+            cx.const_usize(cx.align_of(tp_ty).pref())\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n             let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n-            cx.c_str_slice(ty_name)\n+            cx.const_str_slice(ty_name)\n         }\n         \"type_id\" => {\n-            cx.c_u64(cx.tcx.type_id_hash(substs.type_at(0)))\n+            cx.const_u64(cx.tcx.type_id_hash(substs.type_at(0)))\n         }\n         \"init\" => {\n             let ty = substs.type_at(0);\n@@ -197,8 +197,8 @@ pub fn codegen_intrinsic_call(\n                     false,\n                     ty,\n                     llresult,\n-                    cx.c_u8(0),\n-                    cx.c_usize(1)\n+                    cx.const_u8(0),\n+                    cx.const_usize(1)\n                 );\n             }\n             return;\n@@ -210,7 +210,7 @@ pub fn codegen_intrinsic_call(\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            cx.c_bool(bx.cx().type_needs_drop(tp_ty))\n+            cx.const_bool(bx.cx().type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = args[0].immediate();\n@@ -287,9 +287,9 @@ pub fn codegen_intrinsic_call(\n             };\n             bx.call(expect, &[\n                 args[0].immediate(),\n-                cx.c_i32(rw),\n+                cx.const_i32(rw),\n                 args[1].immediate(),\n-                cx.c_i32(cache_type)\n+                cx.const_i32(cache_type)\n             ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n@@ -302,12 +302,12 @@ pub fn codegen_intrinsic_call(\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n-                            let y = cx.c_bool(false);\n+                            let y = cx.const_bool(false);\n                             let llfn = cx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n                             bx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n-                            let y = cx.c_bool(true);\n+                            let y = cx.const_bool(true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n                             let llfn = cx.get_intrinsic(llvm_name);\n                             bx.call(llfn, &[args[0].immediate(), y], None)\n@@ -388,7 +388,7 @@ pub fn codegen_intrinsic_call(\n                             } else {\n                                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n-                                let width = cx.c_uint(cx.ix(width), width);\n+                                let width = cx.const_uint(cx.ix(width), width);\n                                 let shift = bx.urem(raw_shift, width);\n                                 let inv_shift = bx.urem(bx.sub(width, raw_shift), width);\n                                 let shift1 = bx.shl(val, if is_left { shift } else { inv_shift });\n@@ -725,7 +725,7 @@ fn copy_intrinsic(\n ) -> &'ll Value {\n     let cx = bx.cx();\n     let (size, align) = cx.size_and_align_of(ty);\n-    let size = cx.c_usize(size.bytes());\n+    let size = cx.const_usize(size.bytes());\n     let align = align.abi();\n     let dst_ptr = bx.pointercast(dst, cx.i8p());\n     let src_ptr = bx.pointercast(src, cx.i8p());\n@@ -746,8 +746,8 @@ fn memset_intrinsic(\n ) -> &'ll Value {\n     let cx = bx.cx();\n     let (size, align) = cx.size_and_align_of(ty);\n-    let size = cx.c_usize(size.bytes());\n-    let align = cx.c_i32(align.abi() as i32);\n+    let size = cx.const_usize(size.bytes());\n+    let align = cx.const_i32(align.abi() as i32);\n     let dst = bx.pointercast(dst, cx.i8p());\n     call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n }\n@@ -763,7 +763,7 @@ fn try_intrinsic(\n     if bx.sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        bx.store(cx.c_null(cx.i8p()), dest, ptr_align);\n+        bx.store(cx.const_null(cx.i8p()), dest, ptr_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n@@ -844,7 +844,7 @@ fn codegen_msvc_try(\n         let slot = bx.alloca(i64p, \"slot\", ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n-        normal.ret(cx.c_i32(0));\n+        normal.ret(cx.const_i32(0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n@@ -854,19 +854,19 @@ fn codegen_msvc_try(\n             Some(did) => ::consts::get_static(cx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n-        let tok = catchpad.catch_pad(cs, &[tydesc, cx.c_i32(0), slot]);\n+        let tok = catchpad.catch_pad(cs, &[tydesc, cx.const_i32(0), slot]);\n         let addr = catchpad.load(slot, ptr_align);\n \n         let i64_align = bx.tcx().data_layout.i64_align;\n         let arg1 = catchpad.load(addr, i64_align);\n-        let val1 = cx.c_i32(1);\n+        let val1 = cx.const_i32(1);\n         let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n         catchpad.store(arg1, local_ptr, i64_align);\n         catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), i64_align);\n         catchpad.catch_ret(tok, caught.llbb());\n \n-        caught.ret(cx.c_i32(1));\n+        caught.ret(cx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -922,7 +922,7 @@ fn codegen_gnu_try(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let local_ptr = llvm::get_param(bx.llfn(), 2);\n         bx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n-        then.ret(cx.c_i32(0));\n+        then.ret(cx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n         //\n@@ -932,11 +932,11 @@ fn codegen_gnu_try(\n         // rust_try ignores the selector.\n         let lpad_ty = cx.struct_(&[cx.i8p(), cx.i32()], false);\n         let vals = catch.landing_pad(lpad_ty, bx.cx().eh_personality(), 1);\n-        catch.add_clause(vals, bx.cx().c_null(cx.i8p()));\n+        catch.add_clause(vals, bx.cx().const_null(cx.i8p()));\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         catch.store(ptr, catch.bitcast(local_ptr, cx.ptr_to(cx.i8p())), ptr_align);\n-        catch.ret(cx.c_i32(1));\n+        catch.ret(cx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -1125,18 +1125,18 @@ fn generic_simd_intrinsic(\n                                     arg_idx, total_len);\n                         None\n                     }\n-                    Some(idx) => Some(bx.cx().c_i32(idx as i32)),\n+                    Some(idx) => Some(bx.cx().const_i32(idx as i32)),\n                 }\n             })\n             .collect();\n         let indices = match indices {\n             Some(i) => i,\n-            None => return Ok(bx.cx().c_null(llret_ty))\n+            None => return Ok(bx.cx().const_null(llret_ty))\n         };\n \n         return Ok(bx.shuffle_vector(args[0].immediate(),\n                                     args[1].immediate(),\n-                                    bx.cx().c_vector(&indices)))\n+                                    bx.cx().const_vector(&indices)))\n     }\n \n     if name == \"simd_insert\" {\n@@ -1387,7 +1387,7 @@ fn generic_simd_intrinsic(\n \n         // Alignment of T, must be a constant integer value:\n         let alignment_ty = bx.cx().i32();\n-        let alignment = bx.cx().c_i32(bx.cx().align_of(in_elem).abi() as i32);\n+        let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n@@ -1487,7 +1487,7 @@ fn generic_simd_intrinsic(\n \n         // Alignment of T, must be a constant integer value:\n         let alignment_ty = bx.cx().i32();\n-        let alignment = bx.cx().c_i32(bx.cx().align_of(in_elem).abi() as i32);\n+        let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n@@ -1565,8 +1565,8 @@ fn generic_simd_intrinsic(\n                         } else {\n                             // unordered arithmetic reductions do not:\n                             match f.bit_width() {\n-                                32 => bx.cx().c_undef(bx.cx().f32()),\n-                                64 => bx.cx().c_undef(bx.cx().f64()),\n+                                32 => bx.cx().const_undef(bx.cx().f32()),\n+                                64 => bx.cx().const_undef(bx.cx().f64()),\n                                 v => {\n                                     return_error!(r#\"\n unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,"}, {"sha": "f3dc9ca0002215c83adfc93ba4ced6c4c7f453d7", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -364,17 +364,17 @@ impl CommonWriteMethods for ModuleLlvm<'ll> {\n         common::val_ty(v)\n     }\n \n-    fn c_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n-        common::c_bytes_in_context(llcx, bytes)\n+    fn const_bytes_in_context(&self, llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+        common::const_bytes_in_context(llcx, bytes)\n     }\n \n-    fn c_struct_in_context(\n+    fn const_struct_in_context(\n         &self,\n         llcx: &'a llvm::Context,\n         elts: &[&'a Value],\n         packed: bool,\n     ) -> &'a Value {\n-        common::c_struct_in_context(llcx, elts, packed)\n+        common::const_struct_in_context(llcx, elts, packed)\n     }\n }\n "}, {"sha": "7f76b9b1efa5499ce40dad2489b73170ad44d04a", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> VirtualIndex {\n         );\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(\n-            bx.inbounds_gep(llvtable, &[bx.cx().c_usize(self.0)]),\n+            bx.inbounds_gep(llvtable, &[bx.cx().const_usize(self.0)]),\n             ptr_align\n         );\n         bx.nonnull_metadata(ptr);\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> VirtualIndex {\n         let llvtable = bx.pointercast(llvtable, bx.cx().ptr_to(bx.cx().isize()));\n         let usize_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(\n-            bx.inbounds_gep(llvtable, &[bx.cx().c_usize(self.0)]),\n+            bx.inbounds_gep(llvtable, &[bx.cx().const_usize(self.0)]),\n             usize_align\n         );\n         // Vtable loads are invariant\n@@ -98,7 +98,7 @@ pub fn get_vtable(\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = cx.c_null(cx.i8p());\n+    let nullptr = cx.const_null(cx.i8p());\n \n     let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n     let methods = methods.iter().cloned().map(|opt_mth| {\n@@ -114,11 +114,11 @@ pub fn get_vtable(\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n         callee::get_fn(cx, monomorphize::resolve_drop_in_place(cx.tcx, ty)),\n-        cx.c_usize(size.bytes()),\n-        cx.c_usize(align.abi())\n+        cx.const_usize(size.bytes()),\n+        cx.const_usize(align.abi())\n     ].iter().cloned().chain(methods).collect();\n \n-    let vtable_const = cx.c_struct(&components, false);\n+    let vtable_const = cx.const_struct(&components, false);\n     let align = cx.data_layout().pointer_align;\n     let vtable = consts::addr_of(cx, vtable_const, align, Some(\"vtable\"));\n "}, {"sha": "27a0b9c5682bda59346ed2d9c6ba8916c1441865", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -171,7 +171,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     slot.storage_dead(&bx);\n \n                     if !bx.sess().target.target.options.custom_unwind_resume {\n-                        let mut lp = bx.cx().c_undef(self.landing_pad_type());\n+                        let mut lp = bx.cx().const_undef(self.landing_pad_type());\n                         lp = bx.insert_value(lp, lp0, 0);\n                         lp = bx.insert_value(lp, lp1, 1);\n                         bx.resume(lp);\n@@ -209,7 +209,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         }\n                     } else {\n                         let switch_llty = bx.cx().layout_of(switch_ty).immediate_llvm_type(bx.cx());\n-                        let llval = bx.cx().c_uint_big(switch_llty, values[0]);\n+                        let llval = bx.cx().const_uint_big(switch_llty, values[0]);\n                         let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                         bx.cond_br(cmp, lltrue, llfalse);\n                     }\n@@ -220,7 +220,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                            values.len());\n                     let switch_llty = bx.cx().layout_of(switch_ty).immediate_llvm_type(bx.cx());\n                     for (&value, target) in values.iter().zip(targets) {\n-                        let llval =bx.cx().c_uint_big(switch_llty, value);\n+                        let llval =bx.cx().const_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);\n                         bx.add_case(switch, llval, llbb)\n                     }\n@@ -346,7 +346,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 // Pass the condition through llvm.expect for branch hinting.\n                 let expect = bx.cx().get_intrinsic(&\"llvm.expect.i1\");\n-                let cond = bx.call(expect, &[cond, bx.cx().c_bool(expected)], None);\n+                let cond = bx.call(expect, &[cond, bx.cx().const_bool(expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n@@ -364,9 +364,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // Get the location information.\n                 let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                let filename = bx.cx().c_str_slice(filename);\n-                let line = bx.cx().c_u32(loc.line as u32);\n-                let col = bx.cx().c_u32(loc.col.to_usize() as u32 + 1);\n+                let filename = bx.cx().const_str_slice(filename);\n+                let line = bx.cx().const_u32(loc.line as u32);\n+                let col = bx.cx().const_u32(loc.col.to_usize() as u32 + 1);\n                 let align = tcx.data_layout.aggregate_align\n                     .max(tcx.data_layout.i32_align)\n                     .max(tcx.data_layout.pointer_align);\n@@ -377,7 +377,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let len = self.codegen_operand(&mut bx, len).immediate();\n                         let index = self.codegen_operand(&mut bx, index).immediate();\n \n-                        let file_line_col = bx.cx().c_struct(&[filename, line, col], false);\n+                        let file_line_col = bx.cx().const_struct(&[filename, line, col], false);\n                         let file_line_col = consts::addr_of(bx.cx(),\n                                                             file_line_col,\n                                                             align,\n@@ -388,8 +388,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     _ => {\n                         let str = msg.description();\n                         let msg_str = Symbol::intern(str).as_str();\n-                        let msg_str = bx.cx().c_str_slice(msg_str);\n-                        let msg_file_line_col = bx.cx().c_struct(\n+                        let msg_str = bx.cx().const_str_slice(msg_str);\n+                        let msg_file_line_col = bx.cx().const_struct(\n                             &[msg_str, filename, line, col],\n                             false\n                         );\n@@ -498,9 +498,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 {\n                     let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                     let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                    let filename = bx.cx.c_str_slice(filename);\n-                    let line = bx.cx.c_u32(loc.line as u32);\n-                    let col = bx.cx.c_u32(loc.col.to_usize() as u32 + 1);\n+                    let filename = bx.cx.const_str_slice(filename);\n+                    let line = bx.cx.const_u32(loc.line as u32);\n+                    let col = bx.cx.const_u32(loc.col.to_usize() as u32 + 1);\n                     let align = tcx.data_layout.aggregate_align\n                         .max(tcx.data_layout.i32_align)\n                         .max(tcx.data_layout.pointer_align);\n@@ -511,8 +511,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         if intrinsic == Some(\"init\") { \"zeroed\" } else { \"uninitialized\" }\n                     );\n                     let msg_str = Symbol::intern(&str).as_str();\n-                    let msg_str = bx.cx.c_str_slice(msg_str);\n-                    let msg_file_line_col = bx.cx.c_struct(\n+                    let msg_str = bx.cx.const_str_slice(msg_str);\n+                    let msg_file_line_col = bx.cx.const_struct(\n                         &[msg_str, filename, line, col],\n                         false,\n                     );\n@@ -560,7 +560,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            bx.cx().c_undef(bx.cx().ptr_to(fn_ty.ret.memory_ty(bx.cx())))\n+                            bx.cx().const_undef(bx.cx().ptr_to(fn_ty.ret.memory_ty(bx.cx())))\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -741,7 +741,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                       arg: &ArgType<'tcx, Ty<'tcx>>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(bx.cx().c_undef(ty.llvm_type(bx.cx())));\n+            llargs.push(bx.cx().const_undef(ty.llvm_type(bx.cx())));\n         }\n \n         if arg.is_ignore() {"}, {"sha": "d3640c1934268e25484e975c2aba2447a83eb657", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -40,11 +40,11 @@ pub fn scalar_to_llvm(\n     match cv {\n         Scalar::Bits { size: 0, .. } => {\n             assert_eq!(0, layout.value.size(cx).bytes());\n-            cx.c_undef(cx.ix(0))\n+            cx.const_undef(cx.ix(0))\n         },\n         Scalar::Bits { bits, size } => {\n             assert_eq!(size as u64, layout.value.size(cx).bytes());\n-            let llval = cx.c_uint_big(cx.ix(bitsize), bits);\n+            let llval = cx.const_uint_big(cx.ix(bitsize), bits);\n             if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n             } else {\n@@ -73,7 +73,7 @@ pub fn scalar_to_llvm(\n             };\n             let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n                 consts::bitcast(base_addr, cx.i8p()),\n-                &cx.c_usize(ptr.offset.bytes()),\n+                &cx.const_usize(ptr.offset.bytes()),\n                 1,\n             ) };\n             if layout.value != layout::Pointer {\n@@ -96,7 +96,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            llvals.push(cx.c_bytes(&alloc.bytes[next_offset..offset]));\n+            llvals.push(cx.const_bytes(&alloc.bytes[next_offset..offset]));\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n@@ -114,10 +114,10 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         next_offset = offset + pointer_size;\n     }\n     if alloc.bytes.len() >= next_offset {\n-        llvals.push(cx.c_bytes(&alloc.bytes[next_offset ..]));\n+        llvals.push(cx.const_bytes(&alloc.bytes[next_offset ..]));\n     }\n \n-    cx.c_struct(&llvals, true)\n+    cx.const_struct(&llvals, true)\n }\n \n pub fn codegen_static_initializer(\n@@ -207,7 +207,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         bug!(\"simd shuffle field {:?}\", field)\n                     }\n                 }).collect();\n-                let llval = bx.cx().c_struct(&values?, false);\n+                let llval = bx.cx().const_struct(&values?, false);\n                 Ok((llval, c.ty))\n             })\n             .unwrap_or_else(|_| {\n@@ -218,7 +218,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(&ty);\n                 let llty = bx.cx().layout_of(ty).llvm_type(bx.cx());\n-                (bx.cx().c_undef(llty), ty)\n+                (bx.cx().const_undef(llty), ty)\n             })\n     }\n }"}, {"sha": "b4880ed4888a7e4dd4bf512c809cc3a063da538f", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -419,8 +419,8 @@ fn create_funclets(\n                 // C++ personality function, but `catch (...)` has no type so\n                 // it's null. The 64 here is actually a bitfield which\n                 // represents that this is a catch-all block.\n-                let null = bx.cx().c_null(bx.cx().i8p());\n-                let sixty_four = bx.cx().c_i32(64);\n+                let null = bx.cx().const_null(bx.cx().i8p());\n+                let sixty_four = bx.cx().const_i32(64);\n                 cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                 cp_bx.br(llbb);\n             }"}, {"sha": "c2725acbf1234c020aed407e26cfe3665bb79fb7", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -72,7 +72,7 @@ impl OperandRef<'tcx, &'ll Value> {\n                    layout: TyLayout<'tcx>) -> OperandRef<'tcx, &'ll Value> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(cx.c_undef(layout.immediate_llvm_type(cx))),\n+            val: OperandValue::Immediate(cx.const_undef(layout.immediate_llvm_type(cx))),\n             layout\n         }\n     }\n@@ -166,7 +166,7 @@ impl OperandRef<'tcx, &'ll Value> {\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n-            let mut llpair = bx.cx().c_undef(llty);\n+            let mut llpair = bx.cx().const_undef(llty);\n             llpair = bx.insert_value(llpair, base::from_immediate(bx, a), 0);\n             llpair = bx.insert_value(llpair, base::from_immediate(bx, b), 1);\n             llpair\n@@ -231,7 +231,7 @@ impl OperandRef<'tcx, &'ll Value> {\n             // `#[repr(simd)]` types are also immediate.\n             (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n                 OperandValue::Immediate(\n-                    bx.extract_element(llval, bx.cx().c_usize(i as u64)))\n+                    bx.extract_element(llval, bx.cx().const_usize(i as u64)))\n             }\n \n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n@@ -462,7 +462,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // We've errored, so we don't have to produce working code.\n                         let layout = bx.cx().layout_of(ty);\n                         PlaceRef::new_sized(\n-                            bx.cx().c_undef(bx.cx().ptr_to(layout.llvm_type(bx.cx()))),\n+                            bx.cx().const_undef(bx.cx().ptr_to(layout.llvm_type(bx.cx()))),\n                             layout,\n                             layout.align,\n                         ).load(bx)"}, {"sha": "b0740008995ed7b75841305d8c81d5fd34a83e17", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -68,7 +68,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n         let llval = unsafe { LLVMConstInBoundsGEP(\n             consts::bitcast(base_addr, bx.cx().i8p()),\n-            &bx.cx().c_usize(offset.bytes()),\n+            &bx.cx().const_usize(offset.bytes()),\n             1,\n         )};\n         let llval = consts::bitcast(llval, bx.cx().ptr_to(layout.llvm_type(bx.cx())));\n@@ -102,7 +102,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 assert_eq!(count, 0);\n                 self.llextra.unwrap()\n             } else {\n-                cx.c_usize(count)\n+                cx.const_usize(count)\n             }\n         } else {\n             bug!(\"unexpected layout `{:#?}` in PlaceRef::len\", self.layout)\n@@ -247,7 +247,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n         let meta = self.llextra;\n \n-        let unaligned_offset = cx.c_usize(offset.bytes());\n+        let unaligned_offset = cx.const_usize(offset.bytes());\n \n         // Get the alignment of the field\n         let (_, unsized_align) = glue::size_and_align_of_dst(bx, field.ty, meta);\n@@ -258,7 +258,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bx.sub(unsized_align, cx.c_usize(1u64));\n+        let align_sub_1 = bx.sub(unsized_align, cx.const_usize(1u64));\n         let offset = bx.and(bx.add(unaligned_offset, align_sub_1),\n         bx.neg(unsized_align));\n \n@@ -288,14 +288,14 @@ impl PlaceRef<'tcx, &'ll Value> {\n     ) -> &'ll Value {\n         let cast_to = bx.cx().layout_of(cast_to).immediate_llvm_type(bx.cx());\n         if self.layout.abi.is_uninhabited() {\n-            return bx.cx().c_undef(cast_to);\n+            return bx.cx().const_undef(cast_to);\n         }\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = self.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(bx.cx().tcx, index).val);\n-                return bx.cx().c_uint_big(cast_to, discr_val);\n+                return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n             layout::Variants::Tagged { .. } |\n             layout::Variants::NicheFilling { .. } => {},\n@@ -327,22 +327,22 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n                         // HACK(eddyb) Using `c_null` as it works on all types.\n-                        bx.cx().c_null(niche_llty)\n+                        bx.cx().const_null(niche_llty)\n                     } else {\n-                        bx.cx().c_uint_big(niche_llty, niche_start)\n+                        bx.cx().const_uint_big(niche_llty, niche_start)\n                     };\n                     bx.select(bx.icmp(IntPredicate::IntEQ, lldiscr, niche_llval),\n-                        bx.cx().c_uint(cast_to, niche_variants.start().as_u32() as u64),\n-                        bx.cx().c_uint(cast_to, dataful_variant.as_u32() as u64))\n+                        bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64),\n+                        bx.cx().const_uint(cast_to, dataful_variant.as_u32() as u64))\n                 } else {\n                     // Rebase from niche values to discriminant values.\n                     let delta = niche_start.wrapping_sub(niche_variants.start().as_u32() as u128);\n-                    let lldiscr = bx.sub(lldiscr, bx.cx().c_uint_big(niche_llty, delta));\n+                    let lldiscr = bx.sub(lldiscr, bx.cx().const_uint_big(niche_llty, delta));\n                     let lldiscr_max =\n-                        bx.cx().c_uint(niche_llty, niche_variants.end().as_u32() as u64);\n+                        bx.cx().const_uint(niche_llty, niche_variants.end().as_u32() as u64);\n                     bx.select(bx.icmp(IntPredicate::IntULE, lldiscr, lldiscr_max),\n                         bx.intcast(lldiscr, cast_to, false),\n-                        bx.cx().c_uint(cast_to, dataful_variant.as_u32() as u64))\n+                        bx.cx().const_uint(cast_to, dataful_variant.as_u32() as u64))\n                 }\n             }\n         }\n@@ -364,7 +364,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n                     .val;\n                 bx.store(\n-                    bx.cx().c_uint_big(ptr.layout.llvm_type(bx.cx()), to),\n+                    bx.cx().const_uint_big(ptr.layout.llvm_type(bx.cx()), to),\n                     ptr.llval,\n                     ptr.align);\n             }\n@@ -380,10 +380,10 @@ impl PlaceRef<'tcx, &'ll Value> {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let llptr = bx.pointercast(self.llval, bx.cx().ptr_to(bx.cx().i8()));\n-                        let fill_byte = bx.cx().c_u8(0);\n+                        let fill_byte = bx.cx().const_u8(0);\n                         let (size, align) = self.layout.size_and_align();\n-                        let size = bx.cx().c_usize(size.bytes());\n-                        let align = bx.cx().c_u32(align.abi() as u32);\n+                        let size = bx.cx().const_usize(size.bytes());\n+                        let align = bx.cx().const_u32(align.abi() as u32);\n                         base::call_memset(bx, llptr, fill_byte, size, align, false);\n                     }\n \n@@ -395,9 +395,9 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {\n                         // HACK(eddyb) Using `c_null` as it works on all types.\n-                        bx.cx().c_null(niche_llty)\n+                        bx.cx().const_null(niche_llty)\n                     } else {\n-                        bx.cx().c_uint_big(niche_llty, niche_value)\n+                        bx.cx().const_uint_big(niche_llty, niche_value)\n                     };\n                     OperandValue::Immediate(niche_llval).store(bx, niche);\n                 }\n@@ -408,7 +408,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n     pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: &'ll Value)\n                          -> PlaceRef<'tcx, &'ll Value> {\n         PlaceRef {\n-            llval: bx.inbounds_gep(self.llval, &[bx.cx().c_usize(0), llindex]),\n+            llval: bx.inbounds_gep(self.llval, &[bx.cx().const_usize(0), llindex]),\n             llextra: None,\n             layout: self.layout.field(bx.cx(), 0),\n             align: self.align\n@@ -483,7 +483,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // so we generate an abort\n                         let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n-                        let llval = bx.cx().c_undef(bx.cx().ptr_to(layout.llvm_type(bx.cx())));\n+                        let llval = bx.cx().const_undef(bx.cx().ptr_to(layout.llvm_type(bx.cx())));\n                         PlaceRef::new_sized(llval, layout, layout.align)\n                     }\n                 }\n@@ -516,28 +516,28 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = bx.cx().c_usize(offset as u64);\n+                        let lloffset = bx.cx().const_usize(offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = bx.cx().c_usize(offset as u64);\n+                        let lloffset = bx.cx().const_usize(offset as u64);\n                         let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n-                            bx.cx().c_usize(from as u64));\n+                            bx.cx().const_usize(from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n                             .projection_ty(tcx, &projection.elem)\n                             .to_ty(bx.tcx());\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n-                                bx.cx().c_usize((from as u64) + (to as u64))));\n+                                bx.cx().const_usize((from as u64) + (to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new"}, {"sha": "4dcb0bec3f49fa42af762e9fd2a17f6fda981e4f", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42574b7a22831de97a6ca458f22d011561be56/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=6d42574b7a22831de97a6ca458f22d011561be56", "patch": "@@ -102,15 +102,15 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     return bx;\n                 }\n \n-                let start = dest.project_index(&bx, bx.cx().c_usize(0)).llval;\n+                let start = dest.project_index(&bx, bx.cx().const_usize(0)).llval;\n \n                 if let OperandValue::Immediate(v) = cg_elem.val {\n-                    let align = bx.cx().c_i32(dest.align.abi() as i32);\n-                    let size = bx.cx().c_usize(dest.layout.size.bytes());\n+                    let align = bx.cx().const_i32(dest.align.abi() as i32);\n+                    let size = bx.cx().const_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if bx.cx().is_const_integral(v) && bx.cx().const_to_uint(v) == 0 {\n-                        let fill = bx.cx().c_u8(0);\n+                        let fill = bx.cx().const_u8(0);\n                         base::call_memset(&bx, start, fill, size, align, false);\n                         return bx;\n                     }\n@@ -123,7 +123,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     }\n                 }\n \n-                let count = bx.cx().c_usize(count);\n+                let count = bx.cx().const_usize(count);\n                 let end = dest.project_index(&bx, count).llval;\n \n                 let header_bx = bx.build_sibling_block(\"repeat_loop_header\");\n@@ -139,7 +139,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 cg_elem.val.store(&body_bx,\n                     PlaceRef::new_sized(current, cg_elem.layout, dest.align));\n \n-                let next = body_bx.inbounds_gep(current, &[bx.cx().c_usize(1)]);\n+                let next = body_bx.inbounds_gep(current, &[bx.cx().const_usize(1)]);\n                 body_bx.br(header_bx.llbb());\n                 header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n \n@@ -291,7 +291,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         assert!(cast.is_llvm_immediate());\n                         let ll_t_out = cast.immediate_llvm_type(bx.cx());\n                         if operand.layout.abi.is_uninhabited() {\n-                            let val = OperandValue::Immediate(bx.cx().c_undef(ll_t_out));\n+                            let val = OperandValue::Immediate(bx.cx().const_undef(ll_t_out));\n                             return (bx, OperandRef {\n                                 val,\n                                 layout: cast,\n@@ -307,7 +307,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                     let discr_val = def\n                                         .discriminant_for_variant(bx.cx().tcx, index)\n                                         .val;\n-                                    let discr = bx.cx().c_uint_big(ll_t_out, discr_val);\n+                                    let discr = bx.cx().const_uint_big(ll_t_out, discr_val);\n                                     return (bx, OperandRef {\n                                         val: OperandValue::Immediate(discr),\n                                         layout: cast,\n@@ -338,7 +338,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                     base::call_assume(&bx, bx.icmp(\n                                         IntPredicate::IntULE,\n                                         llval,\n-                                        bx.cx().c_uint_big(ll_t_in, *scalar.valid_range.end())\n+                                        bx.cx().const_uint_big(ll_t_in, *scalar.valid_range.end())\n                                     ));\n                                 }\n                             }\n@@ -489,7 +489,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bx.cx().type_is_sized(ty));\n-                let val = bx.cx().c_usize(bx.cx().size_of(ty).bytes());\n+                let val = bx.cx().const_usize(bx.cx().size_of(ty).bytes());\n                 let tcx = bx.tcx();\n                 (bx, OperandRef {\n                     val: OperandValue::Immediate(val),\n@@ -500,8 +500,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n                 let (size, align) = bx.cx().size_and_align_of(content_ty);\n-                let llsize = bx.cx().c_usize(size.bytes());\n-                let llalign = bx.cx().c_usize(align.abi());\n+                let llsize = bx.cx().const_usize(size.bytes());\n+                let llalign = bx.cx().const_usize(align.abi());\n                 let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n                 let llty_ptr = box_layout.llvm_type(bx.cx());\n \n@@ -548,7 +548,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {\n                     let n = n.unwrap_usize(bx.cx().tcx);\n-                    return bx.cx().c_usize(n);\n+                    return bx.cx().const_usize(n);\n                 }\n             }\n         }\n@@ -606,7 +606,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::BinOp::Shr => common::build_unchecked_rshift(bx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_unit {\n-                bx.cx().c_bool(match op {\n+                bx.cx().const_bool(match op {\n                     mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n                     mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n                     _ => unreachable!()\n@@ -685,7 +685,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         // while the current crate doesn't use overflow checks.\n         if !bx.cx().check_overflow {\n             let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, bx.cx().c_bool(false));\n+            return OperandValue::Pair(val, bx.cx().const_bool(false));\n         }\n \n         let (val, of) = match op {\n@@ -709,7 +709,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 let invert_mask = common::shift_mask_val(&bx, lhs_llty, rhs_llty, true);\n                 let outer_bits = bx.and(rhs, invert_mask);\n \n-                let of = bx.icmp(IntPredicate::IntNE, outer_bits, bx.cx().c_null(rhs_llty));\n+                let of = bx.icmp(IntPredicate::IntNE, outer_bits, bx.cx().const_null(rhs_llty));\n                 let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n \n                 (val, of)\n@@ -838,9 +838,9 @@ fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n         use rustc_apfloat::Float;\n         const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n                                             << (Single::MAX_EXP - Single::PRECISION as i16);\n-        let max = bx.cx().c_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n+        let max = bx.cx().const_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bx.icmp(IntPredicate::IntUGE, x, max);\n-        let infinity_bits = bx.cx().c_u32(ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity_bits = bx.cx().const_u32(ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);\n         bx.select(overflow, infinity, bx.uitofp(x, float_ty))\n     } else {\n@@ -918,8 +918,8 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n \n     let float_bits_to_llval = |bits| {\n         let bits_llval = match bx.cx().float_width(float_ty) {\n-            32 => bx.cx().c_u32(bits as u32),\n-            64 => bx.cx().c_u64(bits as u64),\n+            32 => bx.cx().const_u32(bits as u32),\n+            64 => bx.cx().const_u64(bits as u64),\n             n => bug!(\"unsupported float width {}\", n),\n         };\n         consts::bitcast(bits_llval, float_ty)\n@@ -974,8 +974,8 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     // performed is ultimately up to the backend, but at least x86 does perform them.\n     let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n     let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n-    let int_max = bx.cx().c_uint_big(int_ty, int_max(signed, int_ty));\n-    let int_min = bx.cx().c_uint_big(int_ty, int_min(signed, int_ty) as u128);\n+    let int_max = bx.cx().const_uint_big(int_ty, int_max(signed, int_ty));\n+    let int_min = bx.cx().const_uint_big(int_ty, int_min(signed, int_ty) as u128);\n     let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n     let s1 = bx.select(greater, int_max, s0);\n \n@@ -984,7 +984,7 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     // Therefore we only need to execute this step for signed integer types.\n     if signed {\n         // LLVM has no isNaN predicate, so we use (x == x) instead\n-        bx.select(bx.fcmp(RealPredicate::RealOEQ, x, x), s1, bx.cx().c_uint(int_ty, 0))\n+        bx.select(bx.fcmp(RealPredicate::RealOEQ, x, x), s1, bx.cx().const_uint(int_ty, 0))\n     } else {\n         s1\n     }"}]}