{"sha": "ae50912875ea784edac821c290dbbdfbf44b38e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNTA5MTI4NzVlYTc4NGVkYWM4MjFjMjkwZGJiZGZiZjQ0YjM4ZTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T21:44:24Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T21:44:24Z"}, "message": "librustc: De-export rustc. rs=deexporting", "tree": {"sha": "1940b2173ba61b35c0bb13696b1c7f37c7ef729f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1940b2173ba61b35c0bb13696b1c7f37c7ef729f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae50912875ea784edac821c290dbbdfbf44b38e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae50912875ea784edac821c290dbbdfbf44b38e7", "html_url": "https://github.com/rust-lang/rust/commit/ae50912875ea784edac821c290dbbdfbf44b38e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae50912875ea784edac821c290dbbdfbf44b38e7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc9999c60992fd751f6224305bde84b7246b680b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9999c60992fd751f6224305bde84b7246b680b", "html_url": "https://github.com/rust-lang/rust/commit/cc9999c60992fd751f6224305bde84b7246b680b"}], "stats": {"total": 943, "additions": 415, "deletions": 528}, "files": [{"sha": "6510b1cbb1980fdd873d3dfcfdb40eaefed400e1", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -50,12 +50,8 @@ use syntax::visit;\n use syntax;\n use writer = std::ebml::writer;\n \n-export maps;\n-export encode_inlined_item;\n-export decode_inlined_item;\n-\n // Auxiliary maps of things to be encoded\n-type maps = {\n+pub type maps = {\n     mutbl_map: middle::borrowck::mutbl_map,\n     root_map: middle::borrowck::root_map,\n     last_use_map: middle::liveness::last_use_map,\n@@ -91,11 +87,11 @@ trait tr_intern {\n // ______________________________________________________________________\n // Top-level methods.\n \n-fn encode_inlined_item(ecx: @e::encode_ctxt,\n-                       ebml_w: writer::Encoder,\n-                       path: &[ast_map::path_elt],\n-                       ii: ast::inlined_item,\n-                       maps: maps) {\n+pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n+                           ebml_w: writer::Encoder,\n+                           path: &[ast_map::path_elt],\n+                           ii: ast::inlined_item,\n+                           maps: maps) {\n     debug!(\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n            ecx.tcx.sess.str_of(ii.ident()),\n@@ -114,11 +110,12 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n            ebml_w.writer.tell());\n }\n \n-fn decode_inlined_item(cdata: cstore::crate_metadata,\n-                       tcx: ty::ctxt,\n-                       maps: maps,\n-                       +path: ast_map::path,\n-                       par_doc: ebml::Doc) -> Option<ast::inlined_item> {\n+pub fn decode_inlined_item(cdata: cstore::crate_metadata,\n+                           tcx: ty::ctxt,\n+                           maps: maps,\n+                           +path: ast_map::path,\n+                           par_doc: ebml::Doc)\n+                        -> Option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     match par_doc.opt_child(c::tag_ast) {\n       None => None,"}, {"sha": "5b77228d1abe4ec6572711a0316d7a198d883a44", "filename": "src/librustc/middle/capture.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcapture.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -20,37 +20,27 @@ use std::map;\n use syntax::codemap::span;\n use syntax::{ast, ast_util};\n \n-export capture_mode;\n-export capture_var;\n-export capture_map;\n-export check_capture_clause;\n-export compute_capture_vars;\n-export cap_copy;\n-export cap_move;\n-export cap_drop;\n-export cap_ref;\n-\n-enum capture_mode {\n+pub enum capture_mode {\n     cap_copy, // Copy the value into the closure.\n     cap_move, // Move the value into the closure.\n     cap_drop, // Drop value after creating closure.\n     cap_ref,  // Reference directly from parent stack frame (block fn).\n }\n \n-type capture_var = {\n+pub type capture_var = {\n     def: ast::def,                       // Variable being accessed free\n     span: span,                          // Location of access or cap item\n     cap_item: Option<ast::capture_item>, // Capture item, if any\n     mode: capture_mode                   // How variable is being accessed\n };\n \n-type capture_map = map::HashMap<ast::def_id, capture_var>;\n+pub type capture_map = map::HashMap<ast::def_id, capture_var>;\n \n // checks the capture clause for a fn_expr() and issues warnings or\n // errors for any irregularities which we identify.\n-fn check_capture_clause(tcx: ty::ctxt,\n-                        fn_expr_id: ast::node_id,\n-                        cap_clause: ast::capture_clause) {\n+pub fn check_capture_clause(tcx: ty::ctxt,\n+                            fn_expr_id: ast::node_id,\n+                            cap_clause: ast::capture_clause) {\n     let freevars = freevars::get_freevars(tcx, fn_expr_id);\n     let seen_defs = map::HashMap();\n \n@@ -73,10 +63,11 @@ fn check_capture_clause(tcx: ty::ctxt,\n     }\n }\n \n-fn compute_capture_vars(tcx: ty::ctxt,\n-                        fn_expr_id: ast::node_id,\n-                        fn_proto: ast::Proto,\n-                        cap_clause: ast::capture_clause) -> ~[capture_var] {\n+pub fn compute_capture_vars(tcx: ty::ctxt,\n+                            fn_expr_id: ast::node_id,\n+                            fn_proto: ast::Proto,\n+                            cap_clause: ast::capture_clause)\n+                         -> ~[capture_var] {\n     let freevars = freevars::get_freevars(tcx, fn_expr_id);\n     let cap_map = map::HashMap();\n "}, {"sha": "a018c44c7b82b42b663ba5327453ba550479ecaa", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -22,9 +22,12 @@ use std::map::HashMap;\n use syntax::ast::*;\n use syntax::{visit, ast_util, ast_map};\n \n-fn check_crate(sess: Session, crate: @crate, ast_map: ast_map::map,\n-               def_map: resolve::DefMap,\n-                method_map: typeck::method_map, tcx: ty::ctxt) {\n+pub fn check_crate(sess: Session,\n+                   crate: @crate,\n+                   ast_map: ast_map::map,\n+                   def_map: resolve::DefMap,\n+                   method_map: typeck::method_map,\n+                   tcx: ty::ctxt) {\n     visit::visit_crate(*crate, false, visit::mk_vt(@visit::Visitor {\n         visit_item: |a,b,c| check_item(sess, ast_map, def_map, a, b, c),\n         visit_pat: check_pat,\n@@ -35,9 +38,12 @@ fn check_crate(sess: Session, crate: @crate, ast_map: ast_map::map,\n     sess.abort_if_errors();\n }\n \n-fn check_item(sess: Session, ast_map: ast_map::map,\n-              def_map: resolve::DefMap,\n-              it: @item, &&_is_const: bool, v: visit::vt<bool>) {\n+pub fn check_item(sess: Session,\n+                  ast_map: ast_map::map,\n+                  def_map: resolve::DefMap,\n+                  it: @item,\n+                  &&_is_const: bool,\n+                  v: visit::vt<bool>) {\n     match it.node {\n       item_const(_, ex) => {\n         (v.visit_expr)(ex, true, v);\n@@ -54,7 +60,7 @@ fn check_item(sess: Session, ast_map: ast_map::map,\n     }\n }\n \n-fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n+pub fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n@@ -75,9 +81,13 @@ fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     }\n }\n \n-fn check_expr(sess: Session, def_map: resolve::DefMap,\n-              method_map: typeck::method_map, tcx: ty::ctxt,\n-              e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n+pub fn check_expr(sess: Session,\n+                  def_map: resolve::DefMap,\n+                  method_map: typeck::method_map,\n+                  tcx: ty::ctxt,\n+                  e: @expr,\n+                  &&is_const: bool,\n+                  v: visit::vt<bool>) {\n     if is_const {\n         match e.node {\n           expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n@@ -194,9 +204,10 @@ fn check_expr(sess: Session, def_map: resolve::DefMap,\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n-fn check_item_recursion(sess: Session, ast_map: ast_map::map,\n-                        def_map: resolve::DefMap, it: @item) {\n-\n+pub fn check_item_recursion(sess: Session,\n+                            ast_map: ast_map::map,\n+                            def_map: resolve::DefMap,\n+                            it: @item) {\n     type env = {\n         root_it: @item,\n         sess: Session,"}, {"sha": "de3056639cc48e9c3701f949a1ae523c7b256093", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -14,9 +14,9 @@ use middle::ty;\n use syntax::ast::*;\n use syntax::visit;\n \n-type ctx = {in_loop: bool, can_ret: bool};\n+pub type ctx = {in_loop: bool, can_ret: bool};\n \n-fn check_crate(tcx: ty::ctxt, crate: @crate) {\n+pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(*crate,\n                        {in_loop: false, can_ret: true},\n                        visit::mk_vt(@visit::Visitor {"}, {"sha": "4587d3b7b07361aaadeebd66b6466d912650c311", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -31,12 +31,12 @@ use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n \n-struct MatchCheckCtxt {\n+pub struct MatchCheckCtxt {\n     tcx: ty::ctxt,\n     method_map: method_map,\n }\n \n-fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n+pub fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n     let cx = @MatchCheckCtxt { tcx: tcx, method_map: method_map };\n     visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |a,b,c| check_expr(cx, a, b, c),\n@@ -48,7 +48,7 @@ fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n+pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n     if !ty::expr_is_lval(cx.tcx, cx.method_map, expr) {\n         return false;\n     }\n@@ -62,7 +62,7 @@ fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n     }\n }\n \n-fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n+pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n@@ -108,7 +108,7 @@ fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: @MatchCheckCtxt, arms: ~[arm]) {\n+pub fn check_arms(cx: @MatchCheckCtxt, arms: ~[arm]) {\n     let mut seen = ~[];\n     for arms.each |arm| {\n         for arm.pats.each |pat| {\n@@ -124,14 +124,14 @@ fn check_arms(cx: @MatchCheckCtxt, arms: ~[arm]) {\n     }\n }\n \n-fn raw_pat(p: @pat) -> @pat {\n+pub fn raw_pat(p: @pat) -> @pat {\n     match p.node {\n       pat_ident(_, _, Some(s)) => { raw_pat(s) }\n       _ => { p }\n     }\n }\n \n-fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n+pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n     assert(!pats.is_empty());\n     let ext = match is_useful(cx, vec::map(pats, |p| ~[*p]), ~[wild()]) {\n       not_useful => return, // This is good, wildcard pattern isn't reachable\n@@ -171,39 +171,19 @@ fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n     cx.tcx.sess.span_err(sp, msg);\n }\n \n-type matrix = ~[~[@pat]];\n+pub type matrix = ~[~[@pat]];\n \n-enum useful { useful(ty::t, ctor), useful_, not_useful }\n+pub enum useful { useful(ty::t, ctor), useful_, not_useful }\n \n-enum ctor {\n+#[deriving_eq]\n+pub enum ctor {\n     single,\n     variant(def_id),\n     val(const_val),\n     range(const_val, const_val),\n     vec(uint)\n }\n \n-impl ctor : cmp::Eq {\n-    pure fn eq(&self, other: &ctor) -> bool {\n-        match ((*self), (*other)) {\n-            (single, single) => true,\n-            (variant(did_self), variant(did_other)) => did_self == did_other,\n-            (val(ref cv_self), val(ref cv_other)) =>\n-                (*cv_self) == (*cv_other),\n-            (range(ref cv0_self, ref cv1_self),\n-             range(ref cv0_other, ref cv1_other)) => {\n-                (*cv0_self) == (*cv0_other) && (*cv1_self) == (*cv1_other)\n-            }\n-            (vec(n_self), vec(n_other)) => n_self == n_other,\n-            (single, _) | (variant(_), _) | (val(_), _) |\n-            (range(*), _) | (vec(*), _) => {\n-                false\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &ctor) -> bool { !(*self).eq(other) }\n-}\n-\n // Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n //\n // Whether a vector `v` of patterns is 'useful' in relation to a set of such\n@@ -217,7 +197,7 @@ impl ctor : cmp::Eq {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n+pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n     let real_pat = match vec::find(m, |r| r[0].id != 0) {\n@@ -290,8 +270,13 @@ fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n     }\n }\n \n-fn is_useful_specialized(cx: @MatchCheckCtxt, m: matrix, +v: ~[@pat],\n-                         +ctor: ctor, arity: uint, lty: ty::t) -> useful {\n+pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n+                             m: matrix,\n+                             +v: ~[@pat],\n+                             +ctor: ctor,\n+                             arity: uint,\n+                             lty: ty::t)\n+                          -> useful {\n     let ms = vec::filter_map(m, |r| specialize(cx, copy *r,\n                                                ctor, arity, lty));\n     let could_be_useful = is_useful(\n@@ -302,7 +287,7 @@ fn is_useful_specialized(cx: @MatchCheckCtxt, m: matrix, +v: ~[@pat],\n     }\n }\n \n-fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n+pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match /*bad*/copy pat.node {\n       pat_wild => { None }\n@@ -339,7 +324,7 @@ fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     }\n }\n \n-fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n+pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n       pat_wild => { true }\n@@ -353,10 +338,10 @@ fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n     }\n }\n \n-fn missing_ctor(cx: @MatchCheckCtxt,\n-                m: matrix,\n-                left_ty: ty::t)\n-             -> Option<ctor> {\n+pub fn missing_ctor(cx: @MatchCheckCtxt,\n+                    m: matrix,\n+                    left_ty: ty::t)\n+                 -> Option<ctor> {\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n       ty::ty_rec(_) | ty::ty_struct(*) => {\n@@ -453,7 +438,7 @@ fn missing_ctor(cx: @MatchCheckCtxt,\n     }\n }\n \n-fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n+pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n     match /*bad*/copy ty::get(ty).sty {\n       ty::ty_tup(fs) => fs.len(),\n       ty::ty_rec(fs) => fs.len(),\n@@ -477,12 +462,16 @@ fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n     }\n }\n \n-fn wild() -> @pat {\n+pub fn wild() -> @pat {\n     @pat {id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n }\n \n-fn specialize(cx: @MatchCheckCtxt, +r: ~[@pat], ctor_id: ctor, arity: uint,\n-              left_ty: ty::t) -> Option<~[@pat]> {\n+pub fn specialize(cx: @MatchCheckCtxt,\n+                  +r: ~[@pat],\n+                  ctor_id: ctor,\n+                  arity: uint,\n+                  left_ty: ty::t)\n+               -> Option<~[@pat]> {\n     // Sad, but I can't get rid of this easily\n     let mut r0 = copy *raw_pat(r[0]);\n     match r0 {\n@@ -648,12 +637,15 @@ fn specialize(cx: @MatchCheckCtxt, +r: ~[@pat], ctor_id: ctor, arity: uint,\n     }\n }\n \n-fn default(cx: @MatchCheckCtxt, r: ~[@pat]) -> Option<~[@pat]> {\n+pub fn default(cx: @MatchCheckCtxt, r: ~[@pat]) -> Option<~[@pat]> {\n     if is_wild(cx, r[0]) { Some(vec::tail(r)) }\n     else { None }\n }\n \n-fn check_local(cx: @MatchCheckCtxt, loc: @local, &&s: (), v: visit::vt<()>) {\n+pub fn check_local(cx: @MatchCheckCtxt,\n+                   loc: @local,\n+                   &&s: (),\n+                   v: visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(cx, loc.node.pat) {\n         cx.tcx.sess.span_err(loc.node.pat.span,\n@@ -668,14 +660,14 @@ fn check_local(cx: @MatchCheckCtxt, loc: @local, &&s: (), v: visit::vt<()>) {\n     check_legality_of_move_bindings(cx, is_lvalue, false, [ loc.node.pat ]);\n }\n \n-fn check_fn(cx: @MatchCheckCtxt,\n-            kind: visit::fn_kind,\n-            decl: fn_decl,\n-            body: blk,\n-            sp: span,\n-            id: node_id,\n-            &&s: (),\n-            v: visit::vt<()>) {\n+pub fn check_fn(cx: @MatchCheckCtxt,\n+                kind: visit::fn_kind,\n+                decl: fn_decl,\n+                body: blk,\n+                sp: span,\n+                id: node_id,\n+                &&s: (),\n+                v: visit::vt<()>) {\n     visit::visit_fn(kind, decl, body, sp, id, s, v);\n     for decl.inputs.each |input| {\n         if is_refutable(cx, input.pat) {\n@@ -685,7 +677,7 @@ fn check_fn(cx: @MatchCheckCtxt,\n     }\n }\n \n-fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n+pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n     match cx.tcx.def_map.find(pat.id) {\n       Some(def_variant(enum_id, _)) => {\n         if vec::len(*ty::enum_variants(cx.tcx, enum_id)) != 1u {\n@@ -726,10 +718,10 @@ fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n \n // Legality of move bindings checking\n \n-fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n-                                   is_lvalue: bool,\n-                                   has_guard: bool,\n-                                   pats: &[@pat]) {\n+pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n+                                       is_lvalue: bool,\n+                                       has_guard: bool,\n+                                       pats: &[@pat]) {\n     let tcx = cx.tcx;\n     let def_map = tcx.def_map;\n     let mut by_ref_span = None;"}, {"sha": "022fbe7f306ab1dfae25a6aeab11cc6791b05909", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -53,13 +53,13 @@ use syntax::ast::*;\n //   - Non-constants: everything else.\n //\n \n-enum constness {\n+pub enum constness {\n     integral_const,\n     general_const,\n     non_const\n }\n \n-fn join(a: constness, b: constness) -> constness {\n+pub fn join(a: constness, b: constness) -> constness {\n     match (a, b) {\n       (integral_const, integral_const) => integral_const,\n       (integral_const, general_const)\n@@ -69,13 +69,14 @@ fn join(a: constness, b: constness) -> constness {\n     }\n }\n \n-fn join_all(cs: &[constness]) -> constness {\n+pub fn join_all(cs: &[constness]) -> constness {\n     vec::foldl(integral_const, cs, |a, b| join(a, *b))\n }\n \n-fn classify(e: @expr,\n-            def_map: resolve::DefMap,\n-            tcx: ty::ctxt) -> constness {\n+pub fn classify(e: @expr,\n+                def_map: resolve::DefMap,\n+                tcx: ty::ctxt)\n+             -> constness {\n     let did = ast_util::local_def(e.id);\n     match tcx.ccache.find(did) {\n       Some(x) => x,\n@@ -168,14 +169,16 @@ fn classify(e: @expr,\n     }\n }\n \n-fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n+pub fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n     match tcx.def_map.find(e.id) {\n         Some(ast::def_const(def_id)) => lookup_const_by_id(tcx, def_id),\n         _ => None\n     }\n }\n \n-fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::def_id) -> Option<@expr> {\n+pub fn lookup_const_by_id(tcx: ty::ctxt,\n+                          def_id: ast::def_id)\n+                       -> Option<@expr> {\n     if ast_util::is_local(def_id) {\n         match tcx.items.find(def_id.node) {\n             None => None,\n@@ -190,7 +193,7 @@ fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::def_id) -> Option<@expr> {\n     }\n }\n \n-fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n+pub fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n     match lookup_const(tcx, e) {\n         Some(rhs) => {\n             let ty = ty::expr_ty(tcx, rhs);\n@@ -204,9 +207,9 @@ fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n     }\n }\n \n-fn process_crate(crate: @ast::crate,\n-                 def_map: resolve::DefMap,\n-                 tcx: ty::ctxt) {\n+pub fn process_crate(crate: @ast::crate,\n+                     def_map: resolve::DefMap,\n+                     tcx: ty::ctxt) {\n     let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr_post: |e| { classify(e, def_map, tcx); },\n         .. *visit::default_simple_visitor()\n@@ -218,38 +221,24 @@ fn process_crate(crate: @ast::crate,\n \n // FIXME (#33): this doesn't handle big integer/float literals correctly\n // (nor does the rest of our literal handling).\n-enum const_val {\n+#[deriving_eq]\n+pub enum const_val {\n     const_float(f64),\n     const_int(i64),\n     const_uint(u64),\n     const_str(~str),\n     const_bool(bool)\n }\n \n-impl const_val : cmp::Eq {\n-    pure fn eq(&self, other: &const_val) -> bool {\n-        match ((*self), (*other)) {\n-            (const_float(a), const_float(b)) => a == b,\n-            (const_int(a), const_int(b)) => a == b,\n-            (const_uint(a), const_uint(b)) => a == b,\n-            (const_str(ref a), const_str(ref b)) => (*a) == (*b),\n-            (const_bool(a), const_bool(b)) => a == b,\n-            (const_float(_), _) | (const_int(_), _) | (const_uint(_), _) |\n-            (const_str(_), _) | (const_bool(_), _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &const_val) -> bool { !(*self).eq(other) }\n-}\n-\n-fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n+pub fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(ref r) => (/*bad*/copy *r),\n         Err(ref s) => fail (/*bad*/copy *s)\n     }\n }\n \n-fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n-    -> Result<const_val, ~str> {\n+pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n+                            -> Result<const_val, ~str> {\n     use middle::ty;\n     fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n     match e.node {\n@@ -409,7 +398,7 @@ fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n     }\n }\n \n-fn lit_to_const(lit: @lit) -> const_val {\n+pub fn lit_to_const(lit: @lit) -> const_val {\n     match lit.node {\n       lit_str(s) => const_str(/*bad*/copy *s),\n       lit_int(n, _) => const_int(n),\n@@ -423,7 +412,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n     }\n }\n \n-fn compare_const_vals(a: const_val, b: const_val) -> int {\n+pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n   match (a, b) {\n     (const_int(a), const_int(b)) => {\n         if a == b {\n@@ -474,15 +463,15 @@ fn compare_const_vals(a: const_val, b: const_val) -> int {\n   }\n }\n \n-fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> int {\n+pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> int {\n   compare_const_vals(eval_const_expr(tcx, a), eval_const_expr(tcx, b))\n }\n \n-fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> bool {\n+pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> bool {\n     compare_lit_exprs(tcx, a, b) == 0\n }\n \n-fn lit_eq(a: @lit, b: @lit) -> bool {\n+pub fn lit_eq(a: @lit, b: @lit) -> bool {\n     compare_const_vals(lit_to_const(a), lit_to_const(b)) == 0\n }\n "}, {"sha": "ba4aae75fbdb57953fbe494b81cf4e4539e595c4", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -23,23 +23,16 @@ use syntax::codemap::span;\n use syntax::print::pprust::path_to_str;\n use syntax::{ast, ast_util, visit};\n \n-export annotate_freevars;\n-export freevar_map;\n-export freevar_info;\n-export freevar_entry;\n-export get_freevars;\n-export has_freevars;\n-\n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n #[auto_encode]\n #[auto_decode]\n-struct freevar_entry {\n+pub struct freevar_entry {\n     def: ast::def, //< The variable being accessed free.\n     span: span     //< First span where it is accessed (there can be multiple)\n }\n-type freevar_info = @~[@freevar_entry];\n-type freevar_map = HashMap<ast::node_id, freevar_info>;\n+pub type freevar_info = @~[@freevar_entry];\n+pub type freevar_map = HashMap<ast::node_id, freevar_info>;\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n@@ -105,7 +98,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n+pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n    freevar_map {\n     let freevars = HashMap();\n \n@@ -124,13 +117,13 @@ fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n     return freevars;\n }\n \n-fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n+pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     match tcx.freevars.find(fid) {\n       None => fail ~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\",\n       Some(d) => return d\n     }\n }\n-fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n+pub fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n     return vec::len(*get_freevars(tcx, fid)) != 0u;\n }\n "}, {"sha": "f355677898423d9bd0c8149f72caa02484caa88a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -60,9 +60,9 @@ use syntax::{visit, ast_util};\n // primitives in the stdlib are explicitly annotated to only take sendable\n // types.\n \n-const try_adding: &str = \"Try adding a move\";\n+pub const try_adding: &str = \"Try adding a move\";\n \n-fn kind_to_str(k: Kind) -> ~str {\n+pub fn kind_to_str(k: Kind) -> ~str {\n     let mut kinds = ~[];\n \n     if ty::kind_lteq(kind_const(), k) {\n@@ -82,17 +82,19 @@ fn kind_to_str(k: Kind) -> ~str {\n     str::connect(kinds, ~\" \")\n }\n \n-type rval_map = HashMap<node_id, ()>;\n+pub type rval_map = HashMap<node_id, ()>;\n \n-type ctx = {tcx: ty::ctxt,\n-            method_map: typeck::method_map,\n-            last_use_map: liveness::last_use_map,\n-            current_item: node_id};\n+pub type ctx = {\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    last_use_map: liveness::last_use_map,\n+    current_item: node_id\n+};\n \n-fn check_crate(tcx: ty::ctxt,\n-               method_map: typeck::method_map,\n-               last_use_map: liveness::last_use_map,\n-               crate: @crate) {\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: typeck::method_map,\n+                   last_use_map: liveness::last_use_map,\n+                   crate: @crate) {\n     let ctx = {tcx: tcx,\n                method_map: method_map,\n                last_use_map: last_use_map,\n@@ -116,13 +118,17 @@ fn check_crate(tcx: ty::ctxt,\n // bool flag is only used for checking closures,\n // where it refers to whether a var is 'move' in the\n // capture clause\n-type check_fn = fn@(ctx, node_id, Option<@freevar_entry>,\n-                   bool, ty::t, sp: span);\n+pub type check_fn = fn@(ctx,\n+                        node_id,\n+                        Option<@freevar_entry>,\n+                        bool,\n+                        ty::t,\n+                        sp: span);\n \n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n+pub fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     fn check_for_uniq(cx: ctx, id: node_id, fv: Option<@freevar_entry>,\n                       is_move: bool, var_t: ty::t, sp: span) {\n         // all captured data must be sendable, regardless of whether it is\n@@ -191,9 +197,8 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n \n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n-fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n-            fn_id: node_id, cx: ctx, v: visit::vt<ctx>) {\n-\n+pub fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n+                fn_id: node_id, cx: ctx, v: visit::vt<ctx>) {\n     // Find the check function that enforces the appropriate bounds for this\n     // kind of function:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -237,7 +242,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n     visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n }\n \n-fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n+pub fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n     match b.node.expr {\n       Some(ex) => maybe_copy(cx, ex,\n          Some((\"Tail expressions in blocks must be copyable\",\n@@ -247,7 +252,7 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_block(b, cx, v);\n }\n \n-fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n+pub fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n     for vec::each(a.pats) |p| {\n         do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n             if mode == bind_by_value {\n@@ -260,7 +265,7 @@ fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_arm(a, cx, v);\n }\n \n-fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n+pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n     let id_to_use = match e.node {\n         expr_index(*)|expr_assign_op(*)|\n@@ -407,7 +412,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_expr(e, cx, v);\n }\n \n-fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n+pub fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n     match stmt.node {\n       stmt_decl(@spanned {node: decl_local(ref locals), _}, _) => {\n         for locals.each |local| {\n@@ -424,7 +429,7 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_stmt(stmt, cx, v);\n }\n \n-fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n+pub fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     match aty.node {\n       ty_path(_, id) => {\n         do option::iter(&cx.tcx.node_type_substs.find(id)) |ts| {\n@@ -440,8 +445,8 @@ fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_ty(aty, cx, v);\n }\n \n-fn check_bounds(cx: ctx, id: node_id, sp: span,\n-                ty: ty::t, bounds: ty::param_bounds) {\n+pub fn check_bounds(cx: ctx, id: node_id, sp: span,\n+                    ty: ty::t, bounds: ty::param_bounds) {\n     let kind = ty::type_kind(cx.tcx, ty);\n     let p_kind = ty::param_bounds_to_kind(bounds);\n     if !ty::kind_lteq(p_kind, kind) {\n@@ -466,11 +471,11 @@ fn check_bounds(cx: ctx, id: node_id, sp: span,\n     }\n }\n \n-fn maybe_copy(cx: ctx, ex: @expr, why: Option<(&str,&str)>) {\n+pub fn maybe_copy(cx: ctx, ex: @expr, why: Option<(&str,&str)>) {\n     check_copy_ex(cx, ex, true, why);\n }\n \n-fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n+pub fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n         match cx.tcx.def_map.get(ex.id) {\n@@ -484,8 +489,8 @@ fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     }\n }\n \n-fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n-                 why: Option<(&str,&str)>) {\n+pub fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n+                     why: Option<(&str,&str)>) {\n     if ty::expr_is_lval(cx.tcx, cx.method_map, ex) &&\n \n         // a reference to a constant like `none`... no need to warn\n@@ -515,7 +520,7 @@ fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n     }\n }\n \n-fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n+pub fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n     let msg = ~\"mutable variables cannot be implicitly captured; \\\n                use a capture clause\";\n     match def {\n@@ -537,8 +542,8 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n     }\n }\n \n-fn check_copy(cx: ctx, id: node_id, ty: ty::t, sp: span,\n-              implicit_copy: bool, why: Option<(&str,&str)>) {\n+pub fn check_copy(cx: ctx, id: node_id, ty: ty::t, sp: span,\n+                  implicit_copy: bool, why: Option<(&str,&str)>) {\n     let k = ty::type_kind(cx.tcx, ty);\n     if !ty::kind_can_be_copied(k) {\n         cx.tcx.sess.span_err(sp, ~\"copying a noncopyable value\");\n@@ -556,7 +561,7 @@ fn check_copy(cx: ctx, id: node_id, ty: ty::t, sp: span,\n     }\n }\n \n-fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n+pub fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n     if !ty::kind_can_be_sent(ty::type_kind(cx.tcx, ty)) {\n         cx.tcx.sess.span_err(sp, ~\"not a sendable value\");\n         false\n@@ -566,7 +571,7 @@ fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n }\n \n // note: also used from middle::typeck::regionck!\n-fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n+pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n     if !ty::kind_is_durable(ty::type_kind(tcx, ty)) {\n         match ty::get(ty).sty {\n           ty::ty_param(*) => {\n@@ -607,7 +612,7 @@ fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n ///\n /// (3) The type parameter is owned (and therefore does not contain\n /// borrowed ptrs).\n-fn check_cast_for_escaping_regions(\n+pub fn check_cast_for_escaping_regions(\n     cx: ctx,\n     source: @expr,\n     target: @expr) {\n@@ -652,7 +657,7 @@ fn check_cast_for_escaping_regions(\n }\n \n /// Ensures that values placed into a ~Trait are copyable and sendable.\n-fn check_kind_bounds_of_cast(cx: ctx, source: @expr, target: @expr) {\n+pub fn check_kind_bounds_of_cast(cx: ctx, source: @expr, target: @expr) {\n     let target_ty = ty::expr_ty(cx.tcx, target);\n     match ty::get(target_ty).sty {\n         ty::ty_trait(_, _, ty::vstore_uniq) => {"}, {"sha": "0f9fe013d6fb0c0fd61d79bd4a15165f207cd596", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -77,11 +77,11 @@ pub enum LangItem {\n     StrDupUniqFnLangItem,       // 33\n }\n \n-struct LanguageItems {\n+pub struct LanguageItems {\n     items: [ Option<def_id> * 34 ]\n }\n \n-impl LanguageItems {\n+pub impl LanguageItems {\n     static pub fn new() -> LanguageItems {\n         LanguageItems {\n             items: [ None, ..34 ]\n@@ -410,7 +410,9 @@ impl LanguageItemCollector {\n     }\n }\n \n-fn collect_language_items(crate: @crate, session: Session) -> LanguageItems {\n+pub fn collect_language_items(crate: @crate,\n+                              session: Session)\n+                           -> LanguageItems {\n     let mut items = LanguageItems::new();\n     let collector = LanguageItemCollector(crate, session, &mut items);\n     collector.collect();"}, {"sha": "ea8a40520e8a4dc50914ebb52e7db06fffbea2fb", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -42,15 +42,6 @@ use syntax::codemap::span;\n use syntax::print::pprust::{expr_to_str, mode_to_str, pat_to_str};\n use syntax::{ast, ast_util, visit};\n \n-export lint, ctypes, unused_imports, while_true, path_statement, old_vecs;\n-export unrecognized_lint, non_implicitly_copyable_typarams;\n-export vecs_implicitly_copyable, implicit_copies, legacy_modes;\n-export level, allow, warn, deny, forbid;\n-export lint_dict, get_lint_dict, level_to_str;\n-export get_lint_level, get_lint_settings_level;\n-export check_crate, build_settings_crate, mk_lint_settings;\n-export lint_settings;\n-\n /**\n  * A 'lint' check is a kind of miscellaneous constraint that a user _might_\n  * want to enforce, but might reasonably want to permit as well, on a\n@@ -72,7 +63,8 @@ export lint_settings;\n  * process.\n  */\n \n-enum lint {\n+#[deriving_eq]\n+pub enum lint {\n     ctypes,\n     unused_imports,\n     while_true,\n@@ -100,14 +92,7 @@ enum lint {\n     // dead_assignment\n }\n \n-impl lint : cmp::Eq {\n-    pure fn eq(&self, other: &lint) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &lint) -> bool { !(*self).eq(other) }\n-}\n-\n-fn level_to_str(lv: level) -> &static/str {\n+pub fn level_to_str(lv: level) -> &static/str {\n     match lv {\n       allow => \"allow\",\n       warn => \"warn\",\n@@ -116,7 +101,7 @@ fn level_to_str(lv: level) -> &static/str {\n     }\n }\n \n-enum level {\n+pub enum level {\n     allow, warn, deny, forbid\n }\n \n@@ -131,13 +116,13 @@ type lint_spec = @{lint: lint,\n                    desc: &static/str,\n                    default: level};\n \n-type lint_dict = HashMap<~str,lint_spec>;\n+pub type lint_dict = HashMap<~str,lint_spec>;\n \n /*\n   Pass names should not contain a '-', as the compiler normalizes\n   '-' to '_' in command-line flags\n  */\n-fn get_lint_dict() -> lint_dict {\n+pub fn get_lint_dict() -> lint_dict {\n     let v = ~[\n         (~\"ctypes\",\n          @{lint: ctypes,\n@@ -257,27 +242,28 @@ type lint_mode_map = HashMap<ast::node_id, lint_modes>;\n // settings_map maps node ids of items with non-default lint settings\n // to their settings; default_settings contains the settings for everything\n // not in the map.\n-type lint_settings = {\n+pub type lint_settings = {\n     default_settings: lint_modes,\n     settings_map: lint_mode_map\n };\n \n-fn mk_lint_settings() -> lint_settings {\n+pub fn mk_lint_settings() -> lint_settings {\n     {default_settings: smallintmap::mk(),\n      settings_map: HashMap()}\n }\n \n-fn get_lint_level(modes: lint_modes, lint: lint) -> level {\n+pub fn get_lint_level(modes: lint_modes, lint: lint) -> level {\n     match modes.find(lint as uint) {\n       Some(c) => c,\n       None => allow\n     }\n }\n \n-fn get_lint_settings_level(settings: lint_settings,\n-                              lint_mode: lint,\n-                              _expr_id: ast::node_id,\n-                              item_id: ast::node_id) -> level {\n+pub fn get_lint_settings_level(settings: lint_settings,\n+                               lint_mode: lint,\n+                               _expr_id: ast::node_id,\n+                               item_id: ast::node_id)\n+                            -> level {\n     match settings.settings_map.find(item_id) {\n       Some(modes) => get_lint_level(modes, lint_mode),\n       None => get_lint_level(settings.default_settings, lint_mode)\n@@ -405,8 +391,7 @@ fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n     }\n }\n \n-fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n-\n+pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n     let cx = ctxt_({dict: get_lint_dict(),\n                     curr: smallintmap::mk(),\n                     is_default: true,\n@@ -999,8 +984,7 @@ fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n     }\n }\n \n-fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n-\n+pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_item: |it|\n             check_item(it, tcx),"}, {"sha": "90bcdb54e19aebe1263115732518c5c03b17cb96", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -129,9 +129,6 @@ use syntax::visit::{fk_anon, fk_dtor, fk_fn_block, fk_item_fn, fk_method};\n use syntax::visit::{vt};\n use syntax::{visit, ast_util};\n \n-export check_crate;\n-export last_use_map;\n-\n // Maps from an expr id to a list of variable ids for which this expr\n // is the last use.  Typically, the expr is a path and the node id is\n // the local/argument/etc that the path refers to.  However, it also\n@@ -140,7 +137,7 @@ export last_use_map;\n //\n // Very subtle (#2633): borrowck will remove entries from this table\n // if it detects an outstanding loan (that is, the addr is taken).\n-type last_use_map = HashMap<node_id, @DVec<node_id>>;\n+pub type last_use_map = HashMap<node_id, @DVec<node_id>>;\n \n enum Variable = uint;\n enum LiveNode = uint;\n@@ -204,9 +201,9 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n     }\n }\n \n-fn check_crate(tcx: ty::ctxt,\n-               method_map: typeck::method_map,\n-               crate: @crate) -> last_use_map {\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: typeck::method_map,\n+                   crate: @crate) -> last_use_map {\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_fn: visit_fn,\n         visit_local: visit_local,"}, {"sha": "687e9cdc74dac19b9acd3717a170296a9b45efc9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -63,7 +63,7 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n \n #[deriving_eq]\n-enum categorization {\n+pub enum categorization {\n     cat_rvalue,                     // result of eval'ing some misc expr\n     cat_special(special_kind),      //\n     cat_local(ast::node_id),        // local variable\n@@ -101,7 +101,7 @@ pub enum comp_kind {\n \n // different kinds of expressions we might evaluate\n #[deriving_eq]\n-enum special_kind {\n+pub enum special_kind {\n     sk_method,\n     sk_static_item,\n     sk_implicit_self,   // old by-reference `self`\n@@ -114,7 +114,7 @@ enum special_kind {\n //\n // note: cmt stands for \"categorized mutable type\".\n #[deriving_eq]\n-struct cmt_ {\n+pub struct cmt_ {\n     id: ast::node_id,        // id of expr/pat producing this value\n     span: span,              // span of same expr/pat\n     cat: categorization,     // categorization of expr\n@@ -123,7 +123,7 @@ struct cmt_ {\n     ty: ty::t                // type of the expr\n }\n \n-type cmt = @cmt_;\n+pub type cmt = @cmt_;\n \n // a loan path is like a category, but it exists only when the data is\n // interior to the stack frame.  loan paths are used as the key to a\n@@ -139,12 +139,12 @@ pub enum loan_path {\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n-enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n+pub enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n \n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n-fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n+pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n       ty::ty_uniq(*) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n@@ -206,7 +206,7 @@ fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     }\n }\n \n-fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n+pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n     match opt_deref_kind(t) {\n       Some(k) => k,\n       None => {\n@@ -217,29 +217,27 @@ fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n     }\n }\n \n-fn cat_expr(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    expr: @ast::expr) -> cmt {\n-\n+pub fn cat_expr(tcx: ty::ctxt,\n+                method_map: typeck::method_map,\n+                expr: @ast::expr)\n+             -> cmt {\n     let mcx = &mem_categorization_ctxt {\n         tcx: tcx, method_map: method_map\n     };\n     return mcx.cat_expr(expr);\n }\n \n-fn cat_expr_unadjusted(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    expr: @ast::expr) -> cmt {\n-\n+pub fn cat_expr_unadjusted(tcx: ty::ctxt,\n+                           method_map: typeck::method_map,\n+                           expr: @ast::expr)\n+                        -> cmt {\n     let mcx = &mem_categorization_ctxt {\n         tcx: tcx, method_map: method_map\n     };\n     return mcx.cat_expr_unadjusted(expr);\n }\n \n-fn cat_expr_autoderefd(\n+pub fn cat_expr_autoderefd(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     expr: @ast::expr,\n@@ -251,7 +249,7 @@ fn cat_expr_autoderefd(\n     return mcx.cat_expr_autoderefd(expr, adj);\n }\n \n-fn cat_def(\n+pub fn cat_def(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     expr_id: ast::node_id,\n@@ -265,7 +263,7 @@ fn cat_def(\n     return mcx.cat_def(expr_id, expr_span, expr_ty, def);\n }\n \n-fn cat_variant<N: ast_node>(\n+pub fn cat_variant<N: ast_node>(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     arg: N,\n@@ -278,37 +276,37 @@ fn cat_variant<N: ast_node>(\n     return mcx.cat_variant(arg, enum_did, cmt);\n }\n \n-trait ast_node {\n+pub trait ast_node {\n     fn id() -> ast::node_id;\n     fn span() -> span;\n }\n \n-impl @ast::expr: ast_node {\n+pub impl @ast::expr: ast_node {\n     fn id() -> ast::node_id { self.id }\n     fn span() -> span { self.span }\n }\n \n-impl @ast::pat: ast_node {\n+pub impl @ast::pat: ast_node {\n     fn id() -> ast::node_id { self.id }\n     fn span() -> span { self.span }\n }\n \n-trait get_type_for_node {\n+pub trait get_type_for_node {\n     fn ty<N: ast_node>(node: N) -> ty::t;\n }\n \n-impl ty::ctxt: get_type_for_node {\n+pub impl ty::ctxt: get_type_for_node {\n     fn ty<N: ast_node>(node: N) -> ty::t {\n         ty::node_id_to_type(self, node.id())\n     }\n }\n \n-struct mem_categorization_ctxt {\n+pub struct mem_categorization_ctxt {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n }\n \n-impl &mem_categorization_ctxt {\n+pub impl &mem_categorization_ctxt {\n     fn cat_expr(expr: @ast::expr) -> cmt {\n         match self.tcx.adjustments.find(expr.id) {\n             None => {\n@@ -1043,10 +1041,11 @@ impl &mem_categorization_ctxt {\n /// The node_id here is the node of the expression that references the field.\n /// This function looks it up in the def map in case the type happens to be\n /// an enum to determine which variant is in use.\n-fn field_mutbl(tcx: ty::ctxt,\n-               base_ty: ty::t,\n-               f_name: ast::ident,\n-               node_id: ast::node_id) -> Option<ast::mutability> {\n+pub fn field_mutbl(tcx: ty::ctxt,\n+                   base_ty: ty::t,\n+                   f_name: ast::ident,\n+                   node_id: ast::node_id)\n+                -> Option<ast::mutability> {\n     // Need to refactor so that records/class fields can be treated uniformly.\n     match /*bad*/copy ty::get(base_ty).sty {\n       ty::ty_rec(fields) => {\n@@ -1089,7 +1088,7 @@ fn field_mutbl(tcx: ty::ctxt,\n     return None;\n }\n \n-impl categorization {\n+pub impl categorization {\n     fn derefs_through_mutable_box(&const self) -> bool {\n         match *self {\n             cat_deref(_, _, gc_ptr(ast::m_mutbl)) => {"}, {"sha": "056ab96008ae7bd5f43049d5705f523b5281f62f", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -22,24 +22,19 @@ use syntax::fold::*;\n use syntax::codemap::span;\n use std::map::HashMap;\n \n-export pat_binding_ids, pat_bindings, pat_id_map, PatIdMap;\n-export pat_is_variant_or_struct, pat_is_binding, pat_is_binding_or_wild;\n-export pat_is_const;\n-export arms_have_by_move_bindings;\n-\n-type PatIdMap = HashMap<ident, node_id>;\n+pub type PatIdMap = HashMap<ident, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n-fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n+pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n     let map = HashMap();\n     do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };\n     return map;\n }\n \n-fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n         pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n             match dm.find(pat.id) {\n@@ -51,7 +46,7 @@ fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n     }\n }\n \n-fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n+pub fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n     match pat.node {\n         pat_ident(_, _, None) => {\n             match dm.find(pat.id) {\n@@ -63,7 +58,7 @@ fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n     }\n }\n \n-fn pat_is_binding(dm: resolve::DefMap, pat: @pat) -> bool {\n+pub fn pat_is_binding(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n         pat_ident(*) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n@@ -73,15 +68,15 @@ fn pat_is_binding(dm: resolve::DefMap, pat: @pat) -> bool {\n     }\n }\n \n-fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n         pat_ident(*) => pat_is_binding(dm, pat),\n         pat_wild => true,\n         _ => false\n     }\n }\n \n-fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n+pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n                 it: fn(binding_mode, node_id, span, @path)) {\n     do walk_pat(pat) |p| {\n         match p.node {\n@@ -93,13 +88,13 @@ fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n     }\n }\n \n-fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[node_id] {\n+pub fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[node_id] {\n     let mut found = ~[];\n     pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| found.push(b_id) );\n     return found;\n }\n \n-fn arms_have_by_move_bindings(tcx: ty::ctxt, +arms: &[arm]) -> bool {\n+pub fn arms_have_by_move_bindings(tcx: ty::ctxt, +arms: &[arm]) -> bool {\n     for arms.each |arm| {\n         for arm.pats.each |pat| {\n             let mut found = false;"}, {"sha": "a7d89234030744ca89b00a0fe0c23b46a4b2a9f6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -34,7 +34,9 @@ use syntax::ast_util::{visibility_to_privacy};\n use syntax::codemap::span;\n use syntax::visit;\n \n-fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: &method_map,\n+                   crate: @ast::crate) {\n     let privileged_items = @DVec();\n     let legacy_exports = has_legacy_export_attr(crate.node.attrs);\n "}, {"sha": "698da4e666131d70d0f51bcc79353bb0c10b3da3", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 76, "deletions": 62, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -38,12 +38,14 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::{ast, visit};\n \n-type parent = Option<ast::node_id>;\n+pub type parent = Option<ast::node_id>;\n \n /* Records the parameter ID of a region name. */\n-type binding = {node_id: ast::node_id,\n-                name: ~str,\n-                br: ty::bound_region};\n+pub type binding = {\n+    node_id: ast::node_id,\n+    name: ~str,\n+    br: ty::bound_region\n+};\n \n /**\n Encodes the bounding lifetime for a given AST node:\n@@ -55,9 +57,9 @@ Encodes the bounding lifetime for a given AST node:\n - Variables and bindings are mapped to the block in which they are declared.\n \n */\n-type region_map = HashMap<ast::node_id, ast::node_id>;\n+pub type region_map = HashMap<ast::node_id, ast::node_id>;\n \n-struct ctxt {\n+pub struct ctxt {\n     sess: Session,\n     def_map: resolve::DefMap,\n \n@@ -109,8 +111,8 @@ struct ctxt {\n \n /// Returns true if `subscope` is equal to or is lexically nested inside\n /// `superscope` and false otherwise.\n-fn scope_contains(region_map: region_map, superscope: ast::node_id,\n-                  subscope: ast::node_id) -> bool {\n+pub fn scope_contains(region_map: region_map, superscope: ast::node_id,\n+                      subscope: ast::node_id) -> bool {\n     let mut subscope = subscope;\n     while superscope != subscope {\n         match region_map.find(subscope) {\n@@ -124,9 +126,9 @@ fn scope_contains(region_map: region_map, superscope: ast::node_id,\n /// Determines whether one region is a subregion of another.  This is\n /// intended to run *after inference* and sadly the logic is somewhat\n /// duplicated with the code in infer.rs.\n-fn is_subregion_of(region_map: region_map,\n-                   sub_region: ty::Region,\n-                   super_region: ty::Region) -> bool {\n+pub fn is_subregion_of(region_map: region_map,\n+                       sub_region: ty::Region,\n+                       super_region: ty::Region) -> bool {\n     sub_region == super_region ||\n         match (sub_region, super_region) {\n             (_, ty::re_static) => {\n@@ -147,8 +149,10 @@ fn is_subregion_of(region_map: region_map,\n /// Finds the nearest common ancestor (if any) of two scopes.  That\n /// is, finds the smallest scope which is greater than or equal to\n /// both `scope_a` and `scope_b`.\n-fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n-                           scope_b: ast::node_id) -> Option<ast::node_id> {\n+pub fn nearest_common_ancestor(region_map: region_map,\n+                               scope_a: ast::node_id,\n+                               scope_b: ast::node_id)\n+                            -> Option<ast::node_id> {\n \n     fn ancestors_of(region_map: region_map, scope: ast::node_id)\n                     -> ~[ast::node_id] {\n@@ -198,7 +202,7 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n }\n \n /// Extracts that current parent from cx, failing if there is none.\n-fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n+pub fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n     match cx.parent {\n       None => {\n         cx.sess.span_bug(span, ~\"crate should not be parent here\");\n@@ -210,14 +214,14 @@ fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n }\n \n /// Records the current parent (if any) as the parent of `child_id`.\n-fn record_parent(cx: ctxt, child_id: ast::node_id) {\n+pub fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     for cx.parent.each |parent_id| {\n         debug!(\"parent of node %d is node %d\", child_id, *parent_id);\n         cx.region_map.insert(child_id, *parent_id);\n     }\n }\n \n-fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Record the parent of this block.\n     record_parent(cx, blk.node.id);\n \n@@ -226,11 +230,11 @@ fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n-fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_arm(arm, cx, visitor);\n }\n \n-fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n     match pat.node {\n       ast::pat_ident(*) => {\n         let defn_opt = cx.def_map.find(pat.id);\n@@ -250,7 +254,7 @@ fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_pat(pat, cx, visitor);\n }\n \n-fn resolve_stmt(stmt: @ast::stmt, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_stmt(stmt: @ast::stmt, cx: ctxt, visitor: visit::vt<ctxt>) {\n     match stmt.node {\n       ast::stmt_decl(*) => {\n         visit::visit_stmt(stmt, cx, visitor);\n@@ -267,7 +271,7 @@ fn resolve_stmt(stmt: @ast::stmt, cx: ctxt, visitor: visit::vt<ctxt>) {\n     }\n }\n \n-fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, expr.id);\n \n     let mut new_cx = cx;\n@@ -308,21 +312,26 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_expr(expr, new_cx, visitor);\n }\n \n-fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_local(local: @ast::local,\n+                     cx: ctxt,\n+                     visitor: visit::vt<ctxt>) {\n     record_parent(cx, local.node.id);\n     visit::visit_local(local, cx, visitor);\n }\n \n-fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx: ctxt = ctxt {parent: None,.. cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n \n-fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n-              sp: span, id: ast::node_id, cx: ctxt,\n-              visitor: visit::vt<ctxt>) {\n-\n+pub fn resolve_fn(fk: visit::fn_kind,\n+                  decl: ast::fn_decl,\n+                  body: ast::blk,\n+                  sp: span,\n+                  id: ast::node_id,\n+                  cx: ctxt,\n+                  visitor: visit::vt<ctxt>) {\n     let fn_cx = match fk {\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n@@ -355,8 +364,10 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n     visit::visit_fn(fk, decl, body, sp, id, fn_cx, visitor);\n }\n \n-fn resolve_crate(sess: Session, def_map: resolve::DefMap,\n-                 crate: @ast::crate) -> region_map {\n+pub fn resolve_crate(sess: Session,\n+                     def_map: resolve::DefMap,\n+                     crate: @ast::crate)\n+                  -> region_map {\n     let cx: ctxt = ctxt {sess: sess,\n                          def_map: def_map,\n                          region_map: HashMap(),\n@@ -396,17 +407,17 @@ fn resolve_crate(sess: Session, def_map: resolve::DefMap,\n // a worklist.  We can then process the worklist, propagating indirect\n // dependencies until a fixed point is reached.\n \n-type region_paramd_items = HashMap<ast::node_id, region_variance>;\n+pub type region_paramd_items = HashMap<ast::node_id, region_variance>;\n \n #[deriving_eq]\n-struct region_dep {\n+pub struct region_dep {\n     ambient_variance: region_variance,\n     id: ast::node_id\n }\n \n-type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n+pub type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n \n-type determine_rp_ctxt_ = {\n+pub type determine_rp_ctxt_ = {\n     sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n@@ -426,12 +437,13 @@ type determine_rp_ctxt_ = {\n     mut ambient_variance: region_variance,\n };\n \n-enum determine_rp_ctxt {\n+pub enum determine_rp_ctxt {\n     determine_rp_ctxt_(@determine_rp_ctxt_)\n }\n \n-fn join_variance(++variance1: region_variance,\n-                 ++variance2: region_variance) -> region_variance{\n+pub fn join_variance(++variance1: region_variance,\n+                     ++variance2: region_variance)\n+                  -> region_variance {\n     match (variance1, variance2) {\n       (rv_invariant, _) => {rv_invariant}\n       (_, rv_invariant) => {rv_invariant}\n@@ -450,8 +462,9 @@ fn join_variance(++variance1: region_variance,\n /// appears in a co-variant position.  This implies that this\n /// occurrence of `r` is contra-variant with respect to the current\n /// item, and hence the function returns `rv_contravariant`.\n-fn add_variance(+ambient_variance: region_variance,\n-                +variance: region_variance) -> region_variance {\n+pub fn add_variance(+ambient_variance: region_variance,\n+                    +variance: region_variance)\n+                 -> region_variance {\n     match (ambient_variance, variance) {\n       (rv_invariant, _) => rv_invariant,\n       (_, rv_invariant) => rv_invariant,\n@@ -461,7 +474,7 @@ fn add_variance(+ambient_variance: region_variance,\n     }\n }\n \n-impl determine_rp_ctxt {\n+pub impl determine_rp_ctxt {\n     fn add_variance(variance: region_variance) -> region_variance {\n         add_variance(self.ambient_variance, variance)\n     }\n@@ -594,21 +607,21 @@ impl determine_rp_ctxt {\n     }\n }\n \n-fn determine_rp_in_item(item: @ast::item,\n-                        &&cx: determine_rp_ctxt,\n-                        visitor: visit::vt<determine_rp_ctxt>) {\n+pub fn determine_rp_in_item(item: @ast::item,\n+                            &&cx: determine_rp_ctxt,\n+                            visitor: visit::vt<determine_rp_ctxt>) {\n     do cx.with(item.id, true) {\n         visit::visit_item(item, cx, visitor);\n     }\n }\n \n-fn determine_rp_in_fn(fk: visit::fn_kind,\n-                      decl: ast::fn_decl,\n-                      body: ast::blk,\n-                      _sp: span,\n-                      _id: ast::node_id,\n-                      &&cx: determine_rp_ctxt,\n-                      visitor: visit::vt<determine_rp_ctxt>) {\n+pub fn determine_rp_in_fn(fk: visit::fn_kind,\n+                          decl: ast::fn_decl,\n+                          body: ast::blk,\n+                          _sp: span,\n+                          _id: ast::node_id,\n+                          &&cx: determine_rp_ctxt,\n+                          visitor: visit::vt<determine_rp_ctxt>) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.each |a| {\n@@ -621,18 +634,17 @@ fn determine_rp_in_fn(fk: visit::fn_kind,\n     }\n }\n \n-fn determine_rp_in_ty_method(ty_m: ast::ty_method,\n-                             &&cx: determine_rp_ctxt,\n-                             visitor: visit::vt<determine_rp_ctxt>) {\n+pub fn determine_rp_in_ty_method(ty_m: ast::ty_method,\n+                                 &&cx: determine_rp_ctxt,\n+                                 visitor: visit::vt<determine_rp_ctxt>) {\n     do cx.with(cx.item_id, false) {\n         visit::visit_ty_method(ty_m, cx, visitor);\n     }\n }\n \n-fn determine_rp_in_ty(ty: @ast::Ty,\n-                      &&cx: determine_rp_ctxt,\n-                      visitor: visit::vt<determine_rp_ctxt>) {\n-\n+pub fn determine_rp_in_ty(ty: @ast::Ty,\n+                          &&cx: determine_rp_ctxt,\n+                          visitor: visit::vt<determine_rp_ctxt>) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n@@ -762,9 +774,9 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n }\n \n-fn determine_rp_in_struct_field(cm: @ast::struct_field,\n-                                &&cx: determine_rp_ctxt,\n-                                visitor: visit::vt<determine_rp_ctxt>) {\n+pub fn determine_rp_in_struct_field(cm: @ast::struct_field,\n+                                    &&cx: determine_rp_ctxt,\n+                                    visitor: visit::vt<determine_rp_ctxt>) {\n     match cm.node.kind {\n       ast::named_field(_, ast::struct_mutable, _) => {\n         do cx.with_ambient_variance(rv_invariant) {\n@@ -778,10 +790,11 @@ fn determine_rp_in_struct_field(cm: @ast::struct_field,\n     }\n }\n \n-fn determine_rp_in_crate(sess: Session,\n-                         ast_map: ast_map::map,\n-                         def_map: resolve::DefMap,\n-                         crate: @ast::crate) -> region_paramd_items {\n+pub fn determine_rp_in_crate(sess: Session,\n+                             ast_map: ast_map::map,\n+                             def_map: resolve::DefMap,\n+                             crate: @ast::crate)\n+                          -> region_paramd_items {\n     let cx = determine_rp_ctxt_(@{sess: sess,\n                                   ast_map: ast_map,\n                                   def_map: def_map,\n@@ -842,3 +855,4 @@ fn determine_rp_in_crate(sess: Session,\n     // return final set\n     return cx.region_paramd_items;\n }\n+"}, {"sha": "68ba50bfac5b147f19d1e209edaa2fa322304d50", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 86, "deletions": 146, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -83,87 +83,59 @@ use std::map::HashMap;\n use str_eq = str::eq;\n \n // Definition mapping\n-type DefMap = HashMap<node_id,def>;\n+pub type DefMap = HashMap<node_id,def>;\n \n-struct binding_info {\n+pub struct binding_info {\n     span: span,\n     binding_mode: binding_mode,\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = HashMap<ident,binding_info>;\n+pub type BindingMap = HashMap<ident,binding_info>;\n \n // Implementation resolution\n //\n // XXX: This kind of duplicates information kept in ty::method. Maybe it\n // should go away.\n \n-type MethodInfo = {\n+pub type MethodInfo = {\n     did: def_id,\n     n_tps: uint,\n     ident: ident,\n     self_type: self_ty_\n };\n \n-type Impl = { did: def_id, ident: ident, methods: ~[@MethodInfo] };\n+pub type Impl = { did: def_id, ident: ident, methods: ~[@MethodInfo] };\n \n // Trait method resolution\n-type TraitMap = @HashMap<node_id,@DVec<def_id>>;\n+pub type TraitMap = @HashMap<node_id,@DVec<def_id>>;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-type ExportMap2 = HashMap<node_id, ~[Export2]>;\n+pub type ExportMap2 = HashMap<node_id, ~[Export2]>;\n \n-struct Export2 {\n+pub struct Export2 {\n     name: ~str,         // The name of the target.\n     def_id: def_id,     // The definition of the target.\n     reexport: bool,     // Whether this is a reexport.\n }\n \n-enum PatternBindingMode {\n+#[deriving_eq]\n+pub enum PatternBindingMode {\n     RefutableMode,\n     LocalIrrefutableMode,\n     ArgumentIrrefutableMode(mode)\n }\n \n-impl PatternBindingMode : cmp::Eq {\n-    pure fn eq(&self, other: &PatternBindingMode) -> bool {\n-        match (*self) {\n-            RefutableMode => {\n-                match *other {\n-                    RefutableMode => true,\n-                    _ => false\n-                }\n-            }\n-            LocalIrrefutableMode => {\n-                match *other {\n-                    LocalIrrefutableMode => true,\n-                    _ => false\n-                }\n-            }\n-            ArgumentIrrefutableMode(mode_a) => {\n-                match *other {\n-                    ArgumentIrrefutableMode(mode_b) => mode_a == mode_b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &PatternBindingMode) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n-\n-enum Namespace {\n+pub enum Namespace {\n     TypeNS,\n     ValueNS\n }\n \n /// A NamespaceResult represents the result of resolving an import in\n /// a particular namespace. The result is either definitely-resolved,\n /// definitely- unresolved, or unknown.\n-enum NamespaceResult {\n+pub enum NamespaceResult {\n     /// Means that resolve hasn't gathered enough information yet to determine\n     /// whether the name is bound in this namespace. (That is, it hasn't\n     /// resolved all `use` directives yet.)\n@@ -176,7 +148,7 @@ enum NamespaceResult {\n     BoundResult(@Module, @NameBindings)\n }\n \n-impl NamespaceResult {\n+pub impl NamespaceResult {\n     pure fn is_unknown() -> bool {\n         match self {\n             UnknownResult => true,\n@@ -185,69 +157,55 @@ impl NamespaceResult {\n     }\n }\n \n-enum NameDefinition {\n+pub enum NameDefinition {\n     NoNameDefinition,           //< The name was unbound.\n     ChildNameDefinition(def),   //< The name identifies an immediate child.\n     ImportNameDefinition(def)   //< The name identifies an import.\n \n }\n \n-enum Mutability {\n+#[deriving_eq]\n+pub enum Mutability {\n     Mutable,\n     Immutable\n }\n \n-impl Mutability : cmp::Eq {\n-    pure fn eq(&self, other: &Mutability) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Mutability) -> bool { !(*self).eq(other) }\n-}\n-\n-enum SelfBinding {\n+pub enum SelfBinding {\n     NoSelfBinding,\n     HasSelfBinding(node_id, bool /* is implicit */)\n }\n \n-enum CaptureClause {\n+pub enum CaptureClause {\n     NoCaptureClause,\n     HasCaptureClause(capture_clause)\n }\n \n-type ResolveVisitor = vt<()>;\n+pub type ResolveVisitor = vt<()>;\n \n-enum ImportDirectiveNS {\n+#[deriving_eq]\n+pub enum ImportDirectiveNS {\n     TypeNSOnly,\n     AnyNS\n }\n \n-impl ImportDirectiveNS : cmp::Eq {\n-    pure fn eq(&self, other: &ImportDirectiveNS) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &ImportDirectiveNS) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n /// Contains data for specific types of import directives.\n-enum ImportDirectiveSubclass {\n+pub enum ImportDirectiveSubclass {\n     SingleImport(ident /* target */, ident /* source */, ImportDirectiveNS),\n     GlobImport\n }\n \n /// The context that we thread through while building the reduced graph.\n-enum ReducedGraphParent {\n+pub enum ReducedGraphParent {\n     ModuleReducedGraphParent(@Module)\n }\n \n-enum ResolveResult<T> {\n+pub enum ResolveResult<T> {\n     Failed,         // Failed to resolve the name.\n     Indeterminate,  // Couldn't determine due to unresolved globs.\n     Success(T)      // Successfully resolved the import.\n }\n \n-impl<T> ResolveResult<T> {\n+pub impl<T> ResolveResult<T> {\n     fn failed() -> bool {\n         match self { Failed => true, _ => false }\n     }\n@@ -256,7 +214,7 @@ impl<T> ResolveResult<T> {\n     }\n }\n \n-enum TypeParameters/& {\n+pub enum TypeParameters/& {\n     NoTypeParameters,               //< No type parameters.\n     HasTypeParameters(&~[ty_param], //< Type parameters.\n                       node_id,      //< ID of the enclosing item\n@@ -282,7 +240,7 @@ enum TypeParameters/& {\n // The rib kind controls the translation of argument or local definitions\n // (`def_arg` or `def_local`) to upvars (`def_upvar`).\n \n-enum RibKind {\n+pub enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n \n@@ -305,7 +263,7 @@ enum RibKind {\n }\n \n // Methods can be required or provided. Required methods only occur in traits.\n-enum MethodSort {\n+pub enum MethodSort {\n     Required,\n     Provided(node_id)\n }\n@@ -317,76 +275,54 @@ enum MethodSort {\n // XXX: The X-ray flag is kind of questionable in the first place. It might\n // be better to introduce an expr_xray_path instead.\n \n-enum XrayFlag {\n+#[deriving_eq]\n+pub enum XrayFlag {\n     NoXray,     //< Private items cannot be accessed.\n     Xray        //< Private items can be accessed.\n }\n \n-enum UseLexicalScopeFlag {\n+pub enum UseLexicalScopeFlag {\n     DontUseLexicalScope,\n     UseLexicalScope\n }\n \n-enum SearchThroughModulesFlag {\n+pub enum SearchThroughModulesFlag {\n     DontSearchThroughModules,\n     SearchThroughModules\n }\n \n-enum ModulePrefixResult {\n+pub enum ModulePrefixResult {\n     NoPrefixFound,\n     PrefixFound(@Module, uint)\n }\n \n-impl XrayFlag : cmp::Eq {\n-    pure fn eq(&self, other: &XrayFlag) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &XrayFlag) -> bool { !(*self).eq(other) }\n-}\n-\n-enum AllowCapturingSelfFlag {\n+#[deriving_eq]\n+pub enum AllowCapturingSelfFlag {\n     AllowCapturingSelf,         //< The \"self\" definition can be captured.\n     DontAllowCapturingSelf,     //< The \"self\" definition cannot be captured.\n }\n \n-impl AllowCapturingSelfFlag : cmp::Eq {\n-    pure fn eq(&self, other: &AllowCapturingSelfFlag) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &AllowCapturingSelfFlag) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n-enum BareIdentifierPatternResolution {\n+pub enum BareIdentifierPatternResolution {\n     FoundStructOrEnumVariant(def),\n     FoundConst(def),\n     BareIdentifierPatternUnresolved\n }\n \n // Specifies how duplicates should be handled when adding a child item if\n // another item exists with the same name in some namespace.\n-enum DuplicateCheckingMode {\n+#[deriving_eq]\n+pub enum DuplicateCheckingMode {\n     ForbidDuplicateModules,\n     ForbidDuplicateTypes,\n     ForbidDuplicateValues,\n     ForbidDuplicateTypesAndValues,\n     OverwriteDuplicates\n }\n \n-impl DuplicateCheckingMode : cmp::Eq {\n-    pure fn eq(&self, other: &DuplicateCheckingMode) -> bool {\n-        ((*self) as uint) == (*other as uint)\n-    }\n-    pure fn ne(&self, other: &DuplicateCheckingMode) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n // Returns the namespace associated with the given duplicate checking mode,\n // or fails for OverwriteDuplicates. This is used for error messages.\n-fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode) ->\n-        Namespace {\n+pub fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode)\n+                                          -> Namespace {\n     match mode {\n         ForbidDuplicateModules | ForbidDuplicateTypes |\n         ForbidDuplicateTypesAndValues => TypeNS,\n@@ -396,12 +332,12 @@ fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode) ->\n }\n \n /// One local scope.\n-struct Rib {\n+pub struct Rib {\n     bindings: HashMap<ident,def_like>,\n     kind: RibKind,\n }\n \n-fn Rib(kind: RibKind) -> Rib {\n+pub fn Rib(kind: RibKind) -> Rib {\n     Rib {\n         bindings: HashMap(),\n         kind: kind\n@@ -410,17 +346,18 @@ fn Rib(kind: RibKind) -> Rib {\n \n \n /// One import directive.\n-struct ImportDirective {\n+pub struct ImportDirective {\n     privacy: Privacy,\n     module_path: @DVec<ident>,\n     subclass: @ImportDirectiveSubclass,\n     span: span,\n }\n \n-fn ImportDirective(privacy: Privacy,\n-                   module_path: @DVec<ident>,\n-                   subclass: @ImportDirectiveSubclass,\n-                   span: span) -> ImportDirective {\n+pub fn ImportDirective(privacy: Privacy,\n+                       module_path: @DVec<ident>,\n+                       subclass: @ImportDirectiveSubclass,\n+                       span: span)\n+                    -> ImportDirective {\n     ImportDirective {\n         privacy: privacy,\n         module_path: module_path,\n@@ -430,20 +367,20 @@ fn ImportDirective(privacy: Privacy,\n }\n \n /// The item that an import resolves to.\n-struct Target {\n+pub struct Target {\n     target_module: @Module,\n     bindings: @NameBindings,\n }\n \n-fn Target(target_module: @Module, bindings: @NameBindings) -> Target {\n+pub fn Target(target_module: @Module, bindings: @NameBindings) -> Target {\n     Target {\n         target_module: target_module,\n         bindings: bindings\n     }\n }\n \n /// An ImportResolution represents a particular `use` directive.\n-struct ImportResolution {\n+pub struct ImportResolution {\n     /// The privacy of this `use` directive (whether it's `use` or\n     /// `pub use`.\n     privacy: Privacy,\n@@ -463,7 +400,7 @@ struct ImportResolution {\n     mut used: bool,\n }\n \n-fn ImportResolution(privacy: Privacy, span: span) -> ImportResolution {\n+pub fn ImportResolution(privacy: Privacy, span: span) -> ImportResolution {\n     ImportResolution {\n         privacy: privacy,\n         span: span,\n@@ -474,7 +411,7 @@ fn ImportResolution(privacy: Privacy, span: span) -> ImportResolution {\n     }\n }\n \n-impl ImportResolution {\n+pub impl ImportResolution {\n     fn target_for_namespace(namespace: Namespace) -> Option<Target> {\n         match namespace {\n             TypeNS      => return copy self.type_target,\n@@ -484,22 +421,22 @@ impl ImportResolution {\n }\n \n /// The link from a module up to its nearest parent node.\n-enum ParentLink {\n+pub enum ParentLink {\n     NoParentLink,\n     ModuleParentLink(@Module, ident),\n     BlockParentLink(@Module, node_id)\n }\n \n /// The type of module this is.\n-enum ModuleKind {\n+pub enum ModuleKind {\n     NormalModuleKind,\n     ExternModuleKind,\n     TraitModuleKind,\n     AnonymousModuleKind,\n }\n \n /// One node in the tree of modules.\n-struct Module {\n+pub struct Module {\n     parent_link: ParentLink,\n     mut def_id: Option<def_id>,\n     kind: ModuleKind,\n@@ -549,10 +486,11 @@ struct Module {\n     mut resolved_import_count: uint,\n }\n \n-fn Module(parent_link: ParentLink,\n-          def_id: Option<def_id>,\n-          kind: ModuleKind,\n-          legacy_exports: bool) -> Module {\n+pub fn Module(parent_link: ParentLink,\n+              def_id: Option<def_id>,\n+              kind: ModuleKind,\n+              legacy_exports: bool)\n+           -> Module {\n     Module {\n         parent_link: parent_link,\n         def_id: def_id,\n@@ -568,13 +506,13 @@ fn Module(parent_link: ParentLink,\n     }\n }\n \n-impl Module {\n+pub impl Module {\n     fn all_imports_resolved() -> bool {\n         return self.imports.len() == self.resolved_import_count;\n     }\n }\n \n-fn unused_import_lint_level(session: Session) -> level {\n+pub fn unused_import_lint_level(session: Session) -> level {\n     for session.opts.lint_opts.each |lint_option_pair| {\n         let (lint_type, lint_level) = *lint_option_pair;\n         if lint_type == unused_imports {\n@@ -585,21 +523,21 @@ fn unused_import_lint_level(session: Session) -> level {\n }\n \n // Records a possibly-private type definition.\n-struct TypeNsDef {\n+pub struct TypeNsDef {\n     mut privacy: Privacy,\n     mut module_def: Option<@Module>,\n     mut type_def: Option<def>\n }\n \n // Records a possibly-private value definition.\n-struct ValueNsDef {\n+pub struct ValueNsDef {\n     privacy: Privacy,\n     def: def,\n }\n \n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n-struct NameBindings {\n+pub struct NameBindings {\n     mut type_def: Option<TypeNsDef>,    //< Meaning in type namespace.\n     mut value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n \n@@ -609,8 +547,7 @@ struct NameBindings {\n     mut value_span: Option<span>,\n }\n \n-impl NameBindings {\n-\n+pub impl NameBindings {\n     /// Creates a new module in this set of name bindings.\n     fn define_module(privacy: Privacy,\n                      parent_link: ParentLink,\n@@ -758,7 +695,7 @@ impl NameBindings {\n     }\n }\n \n-fn NameBindings() -> NameBindings {\n+pub fn NameBindings() -> NameBindings {\n     NameBindings {\n         type_def: None,\n         value_def: None,\n@@ -767,21 +704,20 @@ fn NameBindings() -> NameBindings {\n     }\n }\n \n-\n /// Interns the names of the primitive types.\n-struct PrimitiveTypeTable {\n+pub struct PrimitiveTypeTable {\n     primitive_types: HashMap<ident,prim_ty>,\n }\n \n-impl PrimitiveTypeTable {\n+pub impl PrimitiveTypeTable {\n     fn intern(intr: @ident_interner, string: @~str,\n               primitive_type: prim_ty) {\n         let ident = intr.intern(string);\n         self.primitive_types.insert(ident, primitive_type);\n     }\n }\n \n-fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n+pub fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n     let table = PrimitiveTypeTable {\n         primitive_types: HashMap()\n     };\n@@ -807,15 +743,17 @@ fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n }\n \n \n-fn namespace_to_str(ns: Namespace) -> ~str {\n+pub fn namespace_to_str(ns: Namespace) -> ~str {\n     match ns {\n         TypeNS  => ~\"type\",\n         ValueNS => ~\"value\",\n     }\n }\n \n-fn Resolver(session: Session, lang_items: LanguageItems,\n-            crate: @crate) -> Resolver {\n+pub fn Resolver(session: Session,\n+                lang_items: LanguageItems,\n+                crate: @crate)\n+             -> Resolver {\n     let graph_root = @NameBindings();\n \n     (*graph_root).define_module(Public,\n@@ -874,7 +812,7 @@ fn Resolver(session: Session, lang_items: LanguageItems,\n }\n \n /// The main resolver class.\n-struct Resolver {\n+pub struct Resolver {\n     session: Session,\n     lang_items: LanguageItems,\n     crate: @crate,\n@@ -932,8 +870,7 @@ struct Resolver {\n     trait_map: TraitMap,\n }\n \n-impl Resolver {\n-\n+pub impl Resolver {\n     /// The main name resolution procedure.\n     fn resolve(@self, this: @Resolver) {\n         self.build_reduced_graph(this);\n@@ -5576,11 +5513,14 @@ impl Resolver {\n }\n \n /// Entry point to crate resolution.\n-fn resolve_crate(session: Session, lang_items: LanguageItems, crate: @crate)\n-              -> { def_map: DefMap,\n-                   exp_map2: ExportMap2,\n-                   trait_map: TraitMap } {\n-\n+pub fn resolve_crate(session: Session,\n+                     lang_items: LanguageItems,\n+                     crate: @crate)\n+                  -> {\n+                    def_map: DefMap,\n+                    exp_map2: ExportMap2,\n+                    trait_map: TraitMap\n+                  } {\n     let resolver = @Resolver(session, lang_items, crate);\n     resolver.resolve(resolver);\n     return {"}, {"sha": "4580a621f9954137e498358519082fcd7643e936", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -171,14 +171,16 @@ fn md_from_metadata<T>(val: debug_metadata) -> T {\n     }\n }\n \n-fn cached_metadata<T: Copy>(cache: metadata_cache, mdtag: int,\n-                           eq: fn(md: T) -> bool) -> Option<T> {\n+fn cached_metadata<T: Copy>(cache: metadata_cache,\n+                            mdtag: int,\n+                            eq_fn: fn(md: T) -> bool)\n+                         -> Option<T> {\n     unsafe {\n         if cache.contains_key(mdtag) {\n             let items = cache.get(mdtag);\n             for items.each |item| {\n                 let md: T = md_from_metadata::<T>(*item);\n-                if eq(md) {\n+                if eq_fn(md) {\n                     return option::Some(md);\n                 }\n             }"}, {"sha": "15830e48a07aef28886187b08f63dac357b42175", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -1272,12 +1272,12 @@ fn trans_unary_datum(bcx: block,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n         let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n-        let {bcx, box, body} =\n+        let {bcx, box: bx, body} =\n             base::malloc_general(bcx, contents_ty, heap);\n-        add_clean_free(bcx, box, heap);\n+        add_clean_free(bcx, bx, heap);\n         let bcx = trans_into(bcx, contents, SaveIn(body));\n-        revoke_clean(bcx, box);\n-        return immediate_rvalue_bcx(bcx, box, box_ty);\n+        revoke_clean(bcx, bx);\n+        return immediate_rvalue_bcx(bcx, bx, box_ty);\n     }\n }\n "}, {"sha": "1608bc35c268f878d7aa5df7091b221ea9361ae8", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -81,11 +81,11 @@ pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n \n-    let {bcx, box, body} =\n+    let {bcx, box: bx, body} =\n         base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n     Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n-    return rslt(bcx, box);\n+    return rslt(bcx, bx);\n }\n pub fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n                       fill: ValueRef, alloc: ValueRef) -> Result {\n@@ -243,7 +243,7 @@ pub fn trans_slice_vstore(bcx: block,\n \n pub fn trans_lit_str(bcx: block,\n                      lit_expr: @ast::expr,\n-                     lit_str: @~str,\n+                     str_lit: @~str,\n                      dest: Dest)\n                   -> block {\n     //!\n@@ -261,9 +261,9 @@ pub fn trans_lit_str(bcx: block,\n         Ignore => bcx,\n         SaveIn(lldest) => {\n             unsafe {\n-                let bytes = lit_str.len() + 1; // count null-terminator too\n+                let bytes = str_lit.len() + 1; // count null-terminator too\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n-                let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *lit_str);\n+                let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *str_lit);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr,\n                                                         T_ptr(T_i8()));\n                 Store(bcx,"}, {"sha": "c8dc3e702beaeb947cc11edc22555787cf37f9ff", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -20,16 +20,6 @@ use util::ppaux;\n use std::map::HashMap;\n use syntax::ast;\n \n-export type_of;\n-export type_of_dtor;\n-export type_of_explicit_arg;\n-export type_of_explicit_args;\n-export type_of_fn_from_ty;\n-export type_of_fn;\n-export type_of_glue_fn;\n-export type_of_non_gc_box;\n-export type_of_rooted;\n-\n pub fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n     let llty = type_of(ccx, arg.ty);\n     match ty::resolved_mode(ccx.tcx, arg.mode) {"}, {"sha": "738665abb2590156791a1f7149b676a4dbd4ee78", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ae50912875ea784edac821c290dbbdfbf44b38e7/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=ae50912875ea784edac821c290dbbdfbf44b38e7", "patch": "@@ -78,41 +78,25 @@ pub mod middle {\n         pub mod machine;\n     }\n     pub mod ty;\n-    #[legacy_exports]\n     pub mod resolve;\n     #[path = \"typeck/mod.rs\"]\n     pub mod typeck;\n-    #[legacy_exports]\n     pub mod check_loop;\n-    #[legacy_exports]\n     pub mod check_match;\n-    #[legacy_exports]\n     pub mod check_const;\n-    #[legacy_exports]\n     pub mod lint;\n     #[path = \"borrowck/mod.rs\"]\n     pub mod borrowck;\n-    #[legacy_exports]\n     pub mod mem_categorization;\n-    #[legacy_exports]\n     pub mod liveness;\n-    #[legacy_exports]\n     pub mod kind;\n-    #[legacy_exports]\n     pub mod freevars;\n-    #[legacy_exports]\n     pub mod capture;\n-    #[legacy_exports]\n     pub mod pat_util;\n-    #[legacy_exports]\n     pub mod region;\n-    #[legacy_exports]\n     pub mod const_eval;\n-    #[legacy_exports]\n     pub mod astencode;\n-    #[legacy_exports]\n     pub mod lang_items;\n-    #[legacy_exports]\n     pub mod privacy;\n     pub mod mode;\n }"}]}