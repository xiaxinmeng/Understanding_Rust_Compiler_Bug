{"sha": "e702b75b0049a353b477b47ebb6d4d5a97de9d82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MDJiNzViMDA0OWEzNTNiNDc3YjQ3ZWJiNmQ0ZDVhOTdkZTlkODI=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-06-07T02:36:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-07T02:36:32Z"}, "message": "Rollup merge of #42409 - bjorn3:patch-3, r=frewsxcv\n\nBetter docs\n\nWorking on more doc improvements\n\nEdit: done for today", "tree": {"sha": "4f7a96f195157195511367b218ee4255730e673f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f7a96f195157195511367b218ee4255730e673f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e702b75b0049a353b477b47ebb6d4d5a97de9d82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e702b75b0049a353b477b47ebb6d4d5a97de9d82", "html_url": "https://github.com/rust-lang/rust/commit/e702b75b0049a353b477b47ebb6d4d5a97de9d82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e702b75b0049a353b477b47ebb6d4d5a97de9d82/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76242aebb9d47558124c991a6faf0eb706d35703", "url": "https://api.github.com/repos/rust-lang/rust/commits/76242aebb9d47558124c991a6faf0eb706d35703", "html_url": "https://github.com/rust-lang/rust/commit/76242aebb9d47558124c991a6faf0eb706d35703"}, {"sha": "949b2a3f847292a12172a67c9be3cc3b73f2d5c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/949b2a3f847292a12172a67c9be3cc3b73f2d5c0", "html_url": "https://github.com/rust-lang/rust/commit/949b2a3f847292a12172a67c9be3cc3b73f2d5c0"}], "stats": {"total": 228, "additions": 118, "deletions": 110}, "files": [{"sha": "c500d770cef0583b2a6e2fe6e9070eb5854845a0", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=e702b75b0049a353b477b47ebb6d4d5a97de9d82", "patch": "@@ -17,11 +17,11 @@ use hir;\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum CtorKind {\n-    // Constructor function automatically created by a tuple struct/variant.\n+    /// Constructor function automatically created by a tuple struct/variant.\n     Fn,\n-    // Constructor constant automatically created by a unit struct/variant.\n+    /// Constructor constant automatically created by a unit struct/variant.\n     Const,\n-    // Unusable name in value namespace created by a struct variant.\n+    /// Unusable name in value namespace created by a struct variant.\n     Fictive,\n }\n \n@@ -109,17 +109,21 @@ impl PathResolution {\n     }\n }\n \n-// Definition mapping\n+/// Definition mapping\n pub type DefMap = NodeMap<PathResolution>;\n-// This is the replacement export map. It maps a module to all of the exports\n-// within.\n+\n+/// This is the replacement export map. It maps a module to all of the exports\n+/// within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n-    pub ident: ast::Ident, // The name of the target.\n-    pub def: Def, // The definition of the target.\n-    pub span: Span, // The span of the target definition.\n+    /// The name of the target.\n+    pub ident: ast::Ident,\n+    /// The definition of the target.\n+    pub def: Def,\n+    /// The span of the target definition.\n+    pub span: Span,\n }\n \n impl CtorKind {\n@@ -160,6 +164,7 @@ impl Def {\n         }\n     }\n \n+    /// A human readable kind name\n     pub fn kind_name(&self) -> &'static str {\n         match *self {\n             Def::Fn(..) => \"function\","}, {"sha": "ce2baa738975b683b5cdc2d4aec1b458cc691f7e", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=e702b75b0049a353b477b47ebb6d4d5a97de9d82", "patch": "@@ -187,6 +187,7 @@ impl fmt::Debug for DefId {\n \n \n impl DefId {\n+    /// Make a local `DefId` with the given index.\n     pub fn local(index: DefIndex) -> DefId {\n         DefId { krate: LOCAL_CRATE, index: index }\n     }"}, {"sha": "a6ab67e04693d4f9805546a5c9abda0084a795ef", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e702b75b0049a353b477b47ebb6d4d5a97de9d82", "patch": "@@ -8,37 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Lowers the AST to the HIR.\n-//\n-// Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n-// much like a fold. Where lowering involves a bit more work things get more\n-// interesting and there are some invariants you should know about. These mostly\n-// concern spans and ids.\n-//\n-// Spans are assigned to AST nodes during parsing and then are modified during\n-// expansion to indicate the origin of a node and the process it went through\n-// being expanded. Ids are assigned to AST nodes just before lowering.\n-//\n-// For the simpler lowering steps, ids and spans should be preserved. Unlike\n-// expansion we do not preserve the process of lowering in the spans, so spans\n-// should not be modified here. When creating a new node (as opposed to\n-// 'folding' an existing one), then you create a new id using `next_id()`.\n-//\n-// You must ensure that ids are unique. That means that you should only use the\n-// id from an AST node in a single HIR node (you can assume that AST node ids\n-// are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n-// If you do, you must then set the new node's id to a fresh one.\n-//\n-// Spans are used for error messages and for tools to map semantics back to\n-// source code. It is therefore not as important with spans as ids to be strict\n-// about use (you can't break the compiler by screwing up a span). Obviously, a\n-// HIR node can only have a single span. But multiple nodes can have the same\n-// span and spans don't need to be kept in order, etc. Where code is preserved\n-// by lowering, it should have the same span as in the AST. Where HIR nodes are\n-// new it is probably best to give a span for the whole AST node being lowered.\n-// All nodes should have real spans, don't use dummy spans. Tools are likely to\n-// get confused if the spans from leaf AST nodes occur in multiple places\n-// in the HIR, especially for multiple identifiers.\n+//! Lowers the AST to the HIR.\n+//!\n+//! Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n+//! much like a fold. Where lowering involves a bit more work things get more\n+//! interesting and there are some invariants you should know about. These mostly\n+//! concern spans and ids.\n+//!\n+//! Spans are assigned to AST nodes during parsing and then are modified during\n+//! expansion to indicate the origin of a node and the process it went through\n+//! being expanded. Ids are assigned to AST nodes just before lowering.\n+//!\n+//! For the simpler lowering steps, ids and spans should be preserved. Unlike\n+//! expansion we do not preserve the process of lowering in the spans, so spans\n+//! should not be modified here. When creating a new node (as opposed to\n+//! 'folding' an existing one), then you create a new id using `next_id()`.\n+//!\n+//! You must ensure that ids are unique. That means that you should only use the\n+//! id from an AST node in a single HIR node (you can assume that AST node ids\n+//! are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n+//! If you do, you must then set the new node's id to a fresh one.\n+//!\n+//! Spans are used for error messages and for tools to map semantics back to\n+//! source code. It is therefore not as important with spans as ids to be strict\n+//! about use (you can't break the compiler by screwing up a span). Obviously, a\n+//! HIR node can only have a single span. But multiple nodes can have the same\n+//! span and spans don't need to be kept in order, etc. Where code is preserved\n+//! by lowering, it should have the same span as in the AST. Where HIR nodes are\n+//! new it is probably best to give a span for the whole AST node being lowered.\n+//! All nodes should have real spans, don't use dummy spans. Tools are likely to\n+//! get confused if the spans from leaf AST nodes occur in multiple places\n+//! in the HIR, especially for multiple identifiers.\n \n use hir;\n use hir::map::{Definitions, DefKey, REGULAR_SPACE};\n@@ -70,8 +70,10 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n+\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     sess: &'a Session,\n+\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n@@ -102,14 +104,14 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    // Resolve a hir path generated by the lowerer when expanding `for`, `if let`, etc.\n+    /// Resolve a hir path generated by the lowerer when expanding `for`, `if let`, etc.\n     fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n-    // Obtain the resolution for a node id\n+    /// Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n-    // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n-    // This should only return `None` during testing.\n+    /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n+    /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n }\n "}, {"sha": "81a8984e7530eb011811736a16c97eecff9661cc", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=e702b75b0049a353b477b47ebb6d4d5a97de9d82", "patch": "@@ -133,7 +133,6 @@ enum Node {\n     Region(ty::RegionKind),\n }\n \n-// type Edge = Constraint;\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n enum Edge<'tcx> {\n     Constraint(Constraint<'tcx>),"}, {"sha": "f62470fab723ec1ad4676cc069b1c81839ca83f6", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e702b75b0049a353b477b47ebb6d4d5a97de9d82/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=e702b75b0049a353b477b47ebb6d4d5a97de9d82", "patch": "@@ -35,31 +35,31 @@ use std::u32;\n \n mod graphviz;\n \n-// A constraint that influences the inference process.\n+/// A constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum Constraint<'tcx> {\n-    // One region variable is subregion of another\n+    /// One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n \n-    // Concrete region is subregion of region variable\n+    /// Concrete region is subregion of region variable\n     ConstrainRegSubVar(Region<'tcx>, RegionVid),\n \n-    // Region variable is subregion of concrete region. This does not\n-    // directly affect inference, but instead is checked after\n-    // inference is complete.\n+    /// Region variable is subregion of concrete region. This does not\n+    /// directly affect inference, but instead is checked after\n+    /// inference is complete.\n     ConstrainVarSubReg(RegionVid, Region<'tcx>),\n \n-    // A constraint where neither side is a variable. This does not\n-    // directly affect inference, but instead is checked after\n-    // inference is complete.\n+    /// A constraint where neither side is a variable. This does not\n+    /// directly affect inference, but instead is checked after\n+    /// inference is complete.\n     ConstrainRegSubReg(Region<'tcx>, Region<'tcx>),\n }\n \n-// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n-// associated type) must outlive the region `R`. `T` is known to\n-// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n-// `i`. Inference variables may be involved (but this verification\n-// step doesn't influence inference).\n+/// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+/// associated type) must outlive the region `R`. `T` is known to\n+/// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+/// `i`. Inference variables may be involved (but this verification\n+/// step doesn't influence inference).\n #[derive(Debug)]\n pub struct Verify<'tcx> {\n     kind: GenericKind<'tcx>,\n@@ -74,29 +74,29 @@ pub enum GenericKind<'tcx> {\n     Projection(ty::ProjectionTy<'tcx>),\n }\n \n-// When we introduce a verification step, we wish to test that a\n-// particular region (let's call it `'min`) meets some bound.\n-// The bound is described the by the following grammar:\n+/// When we introduce a verification step, we wish to test that a\n+/// particular region (let's call it `'min`) meets some bound.\n+/// The bound is described the by the following grammar:\n #[derive(Debug)]\n pub enum VerifyBound<'tcx> {\n-    // B = exists {R} --> some 'r in {R} must outlive 'min\n-    //\n-    // Put another way, the subject value is known to outlive all\n-    // regions in {R}, so if any of those outlives 'min, then the\n-    // bound is met.\n+    /// B = exists {R} --> some 'r in {R} must outlive 'min\n+    ///\n+    /// Put another way, the subject value is known to outlive all\n+    /// regions in {R}, so if any of those outlives 'min, then the\n+    /// bound is met.\n     AnyRegion(Vec<Region<'tcx>>),\n \n-    // B = forall {R} --> all 'r in {R} must outlive 'min\n-    //\n-    // Put another way, the subject value is known to outlive some\n-    // region in {R}, so if all of those outlives 'min, then the bound\n-    // is met.\n+    /// B = forall {R} --> all 'r in {R} must outlive 'min\n+    ///\n+    /// Put another way, the subject value is known to outlive some\n+    /// region in {R}, so if all of those outlives 'min, then the bound\n+    /// is met.\n     AllRegions(Vec<Region<'tcx>>),\n \n-    // B = exists {B} --> 'min must meet some bound b in {B}\n+    /// B = exists {B} --> 'min must meet some bound b in {B}\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n-    // B = forall {B} --> 'min must meet all bounds b in {B}\n+    /// B = forall {B} --> 'min must meet all bounds b in {B}\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n@@ -183,56 +183,57 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n-    // Constraints of the form `A <= B` introduced by the region\n-    // checker.  Here at least one of `A` and `B` must be a region\n-    // variable.\n+    /// Constraints of the form `A <= B` introduced by the region\n+    /// checker.  Here at least one of `A` and `B` must be a region\n+    /// variable.\n     constraints: RefCell<FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n \n-    // A \"verify\" is something that we need to verify after inference is\n-    // done, but which does not directly affect inference in any way.\n-    //\n-    // An example is a `A <= B` where neither `A` nor `B` are\n-    // inference variables.\n+    /// A \"verify\" is something that we need to verify after inference is\n+    /// done, but which does not directly affect inference in any way.\n+    ///\n+    /// An example is a `A <= B` where neither `A` nor `B` are\n+    /// inference variables.\n     verifys: RefCell<Vec<Verify<'tcx>>>,\n \n-    // A \"given\" is a relationship that is known to hold. In particular,\n-    // we often know from closure fn signatures that a particular free\n-    // region must be a subregion of a region variable:\n-    //\n-    //    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    //\n-    // In situations like this, `'b` is in fact a region variable\n-    // introduced by the call to `iter()`, and `'a` is a bound region\n-    // on the closure (as indicated by the `<'a>` prefix). If we are\n-    // naive, we wind up inferring that `'b` must be `'static`,\n-    // because we require that it be greater than `'a` and we do not\n-    // know what `'a` is precisely.\n-    //\n-    // This hashmap is used to avoid that naive scenario. Basically we\n-    // record the fact that `'a <= 'b` is implied by the fn signature,\n-    // and then ignore the constraint when solving equations. This is\n-    // a bit of a hack but seems to work.\n+    /// A \"given\" is a relationship that is known to hold. In particular,\n+    /// we often know from closure fn signatures that a particular free\n+    /// region must be a subregion of a region variable:\n+    ///\n+    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n+    ///\n+    /// In situations like this, `'b` is in fact a region variable\n+    /// introduced by the call to `iter()`, and `'a` is a bound region\n+    /// on the closure (as indicated by the `<'a>` prefix). If we are\n+    /// naive, we wind up inferring that `'b` must be `'static`,\n+    /// because we require that it be greater than `'a` and we do not\n+    /// know what `'a` is precisely.\n+    ///\n+    /// This hashmap is used to avoid that naive scenario. Basically we\n+    /// record the fact that `'a <= 'b` is implied by the fn signature,\n+    /// and then ignore the constraint when solving equations. This is\n+    /// a bit of a hack but seems to work.\n     givens: RefCell<FxHashSet<(Region<'tcx>, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n     skolemization_count: Cell<u32>,\n     bound_count: Cell<u32>,\n \n-    // The undo log records actions that might later be undone.\n-    //\n-    // Note: when the undo_log is empty, we are not actively\n-    // snapshotting. When the `start_snapshot()` method is called, we\n-    // push an OpenSnapshot entry onto the list to indicate that we\n-    // are now actively snapshotting. The reason for this is that\n-    // otherwise we end up adding entries for things like the lower\n-    // bound on a variable and so forth, which can never be rolled\n-    // back.\n+    /// The undo log records actions that might later be undone.\n+    ///\n+    /// Note: when the undo_log is empty, we are not actively\n+    /// snapshotting. When the `start_snapshot()` method is called, we\n+    /// push an OpenSnapshot entry onto the list to indicate that we\n+    /// are now actively snapshotting. The reason for this is that\n+    /// otherwise we end up adding entries for things like the lower\n+    /// bound on a variable and so forth, which can never be rolled\n+    /// back.\n     undo_log: RefCell<Vec<UndoLogEntry<'tcx>>>,\n+\n     unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n \n-    // This contains the results of inference.  It begins as an empty\n-    // option and only acquires a value after inference is complete.\n+    /// This contains the results of inference.  It begins as an empty\n+    /// option and only acquires a value after inference is complete.\n     values: RefCell<Option<Vec<VarValue<'tcx>>>>,\n }\n "}]}