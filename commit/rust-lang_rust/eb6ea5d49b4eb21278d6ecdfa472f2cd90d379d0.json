{"sha": "eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNmVhNWQ0OWI0ZWIyMTI3OGQ2ZWNkZmE0NzJmMmNkOTBkMzc5ZDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-01T17:27:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:29Z"}, "message": "Cleanup type resolution to use type folding infrastructure and not\nhave such a silly over-engineered interface.", "tree": {"sha": "dae6c8d72f9eed868b4db7a50dcce2927a41d552", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dae6c8d72f9eed868b4db7a50dcce2927a41d552"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "html_url": "https://github.com/rust-lang/rust/commit/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "html_url": "https://github.com/rust-lang/rust/commit/3efc9d2c55af6e58dd96c5814260bacc2b582ef3"}], "stats": {"total": 581, "additions": 155, "deletions": 426}, "files": [{"sha": "edb544aca6d99aeddf5cdbded4e6e0b15e734ba7", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "patch": "@@ -60,10 +60,9 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use super::{CoerceResult, resolve_type, Coercion};\n+use super::{CoerceResult, Coercion};\n use super::combine::{CombineFields, Combine};\n use super::sub::Sub;\n-use super::resolve::try_resolve_tvar_shallow;\n \n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n@@ -197,18 +196,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     pub fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n         F: FnOnce(&ty::sty<'tcx>) -> T,\n     {\n-        match resolve_type(self.get_ref().infcx, None,\n-                           a, try_resolve_tvar_shallow) {\n-            Ok(t) => {\n-                f(&t.sty)\n-            }\n-            Err(e) => {\n-                self.get_ref().infcx.tcx.sess.span_bug(\n-                    self.get_ref().trace.origin.span(),\n-                    format!(\"failed to resolve even without \\\n-                             any force options: {}\", e).as_slice());\n-            }\n-        }\n+        f(&self.get_ref().infcx.shallow_resolve(a).sty)\n     }\n \n     // ~T -> &T or &mut T -> &T (including where T = [U] or str)"}, {"sha": "0c70d2081196db3e87cc4d977171e63ea4ef4631", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "patch": "@@ -19,13 +19,6 @@ pub use self::TypeOrigin::*;\n pub use self::ValuePairs::*;\n pub use self::fixup_err::*;\n pub use middle::ty::IntVarValue;\n-pub use self::resolve::resolve_and_force_all_but_regions;\n-pub use self::resolve::{force_all, not_regions};\n-pub use self::resolve::{force_ivar};\n-pub use self::resolve::{force_tvar, force_rvar};\n-pub use self::resolve::{resolve_ivar, resolve_all};\n-pub use self::resolve::{resolve_nested_tvar};\n-pub use self::resolve::{resolve_rvar};\n pub use self::skolemize::TypeSkolemizer;\n \n use middle::subst;\n@@ -47,7 +40,6 @@ use util::ppaux::{trait_ref_to_string, Repr};\n use self::coercion::Coerce;\n use self::combine::{Combine, CombineFields};\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::resolve::{resolver};\n use self::equate::Equate;\n use self::sub::Sub;\n use self::lub::Lub;\n@@ -453,22 +445,6 @@ pub fn mk_coercety<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     })\n }\n \n-// See comment on the type `resolve_state` below\n-pub fn resolve_type<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                              span: Option<Span>,\n-                              a: Ty<'tcx>,\n-                              modes: uint)\n-                              -> fres<Ty<'tcx>> {\n-    let mut resolver = resolver(cx, modes, span);\n-    cx.commit_unconditionally(|| resolver.resolve_type_chk(a))\n-}\n-\n-pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n-                      -> fres<ty::Region> {\n-    let mut resolver = resolver(cx, modes, None);\n-    resolver.resolve_region_chk(r)\n-}\n-\n trait then<'tcx> {\n     fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n         T: Clone,\n@@ -835,20 +811,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref_to_string(self.tcx, &t)\n     }\n \n-    pub fn contains_unbound_type_variables(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match resolve_type(self,\n-                           None,\n-                           typ, resolve_nested_tvar | resolve_ivar) {\n-          Ok(new_type) => new_type,\n-          Err(_) => typ\n-        }\n-    }\n-\n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n+                // Not entirely obvious: if `typ` is a type variable,\n+                // it can be resolved to an int/float variable, which\n+                // can then be recursively resolved, hence the\n+                // recursion. Note though that we prevent type\n+                // variables from unifying to other type variables\n+                // directly (though they may be embedded\n+                // structurally), and we prevent cycles in any case,\n+                // so this recursion should always be of very limited\n+                // depth.\n                 self.type_variables.borrow()\n                     .probe(v)\n+                    .map(|t| self.shallow_resolve(t))\n                     .unwrap_or(typ)\n             }\n \n@@ -869,10 +846,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_if_possible<T:TypeFoldable<'tcx>>(&self, value: &T) -> T {\n-        let mut r = resolve::DeepTypeResolver::new(self);\n+        /*!\n+         * Where possible, replaces type/int/float variables in\n+         * `value` with their final value. Note that region variables\n+         * are unaffected. If a type variable has not been unified, it\n+         * is left as is.  This is an idempotent operation that does\n+         * not affect inference state in any way and so you can do it\n+         * at will.\n+         */\n+\n+        let mut r = resolve::OpportunisticTypeResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n+    pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> fres<T> {\n+        /*!\n+         * Attempts to resolve all type/region variables in\n+         * `value`. Region inference must have been run already (e.g.,\n+         * by calling `resolve_regions_and_report_errors`).  If some\n+         * variable was never unified, an `Err` results.\n+         *\n+         * This method is idempotent, but it not typically not invoked\n+         * except during the writeback phase.\n+         */\n+\n+        resolve::fully_resolve(self, value)\n+    }\n+\n     // [Note-Type-error-reporting]\n     // An invariant is that anytime the expected or actual type is ty_err (the special\n     // error type, meaning that an error occurred when typechecking this expression),"}, {"sha": "12400de31ed9e5a3ad886bd845920214239a22a4", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 71, "deletions": 251, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "patch": "@@ -8,288 +8,108 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Resolution is the process of removing type variables and replacing\n-// them with their inferred values.  Unfortunately our inference has\n-// become fairly complex and so there are a number of options to\n-// control *just how much* you want to resolve and how you want to do\n-// it.\n-//\n-// # Controlling the scope of resolution\n-//\n-// The options resolve_* determine what kinds of variables get\n-// resolved.  Generally resolution starts with a top-level type\n-// variable; we will always resolve this.  However, once we have\n-// resolved that variable, we may end up with a type that still\n-// contains type variables.  For example, if we resolve `<T0>` we may\n-// end up with something like `[<T1>]`.  If the option\n-// `resolve_nested_tvar` is passed, we will then go and recursively\n-// resolve `<T1>`.\n-//\n-// The options `resolve_rvar` controls whether we resolve region\n-// variables. The options `resolve_fvar` and `resolve_ivar` control\n-// whether we resolve floating point and integral variables,\n-// respectively.\n-//\n-// # What do if things are unconstrained\n-//\n-// Sometimes we will encounter a variable that has no constraints, and\n-// therefore cannot sensibly be mapped to any particular result.  By\n-// default, we will leave such variables as is (so you will get back a\n-// variable in your result).  The options force_* will cause the\n-// resolution to fail in this case instead, except for the case of\n-// integral variables, which resolve to `int` if forced.\n-//\n-// # resolve_all and force_all\n-//\n-// The options are a bit set, so you can use the *_all to resolve or\n-// force all kinds of variables (including those we may add in the\n-// future).  If you want to resolve everything but one type, you are\n-// probably better off writing `resolve_all - resolve_ivar`.\n-\n-#![allow(non_upper_case_globals)]\n-\n-use super::{fixup_err, fres, InferCtxt};\n-use super::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n-\n-use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n-use middle::ty::{IntType, UintType};\n+use super::{InferCtxt, fixup_err, fres, unresolved_ty, unresolved_int_ty, unresolved_float_ty};\n use middle::ty::{mod, Ty};\n-use middle::ty_fold;\n-use syntax::codemap::Span;\n-use util::ppaux::{Repr, ty_to_string};\n+use middle::ty_fold::{mod, TypeFoldable};\n+use util::ppaux::Repr;\n \n-pub const resolve_nested_tvar: uint = 0b0000000001;\n-pub const resolve_rvar: uint        = 0b0000000010;\n-pub const resolve_ivar: uint        = 0b0000000100;\n-pub const resolve_fvar: uint        = 0b0000001000;\n-pub const resolve_all: uint         = 0b0000001111;\n-pub const force_tvar: uint          = 0b0000100000;\n-pub const force_rvar: uint          = 0b0001000000;\n-pub const force_ivar: uint          = 0b0010000000;\n-pub const force_fvar: uint          = 0b0100000000;\n-pub const force_all: uint           = 0b0111100000;\n-\n-pub const not_regions: uint         = !(force_rvar | resolve_rvar);\n-\n-pub const try_resolve_tvar_shallow: uint = 0;\n-pub const resolve_and_force_all_but_regions: uint =\n-    (resolve_all | force_all) & not_regions;\n+///////////////////////////////////////////////////////////////////////////\n+// OPPORTUNISTIC TYPE RESOLVER\n \n-pub struct ResolveState<'a, 'tcx: 'a> {\n+/// The opportunistic type resolver can be used at any time. It simply replaces\n+/// type variables that have been unified with the things they have\n+/// been unified with (similar to `shallow_resolve`, but deep). This is\n+/// useful for printing messages etc but also required at various\n+/// points for correctness.\n+pub struct OpportunisticTypeResolver<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    modes: uint,\n-    err: Option<fixup_err>,\n-    type_depth: uint,\n }\n \n-pub fn resolver<'a, 'tcx>(infcx: &'a InferCtxt<'a, 'tcx>,\n-                          modes: uint,\n-                          _: Option<Span>)\n-                          -> ResolveState<'a, 'tcx> {\n-    ResolveState {\n-        infcx: infcx,\n-        modes: modes,\n-        err: None,\n-        type_depth: 0,\n+impl<'a, 'tcx> OpportunisticTypeResolver<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> OpportunisticTypeResolver<'a, 'tcx> {\n+        OpportunisticTypeResolver { infcx: infcx }\n     }\n }\n \n-impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        self.resolve_type(t)\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        self.resolve_region(r)\n-    }\n-}\n-\n-impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n-    pub fn should(&mut self, mode: uint) -> bool {\n-        (self.modes & mode) == mode\n-    }\n-\n-    pub fn resolve_type_chk(&mut self, typ: Ty<'tcx>) -> fres<Ty<'tcx>> {\n-        self.err = None;\n-\n-        debug!(\"Resolving {} (modes={:x})\",\n-               ty_to_string(self.infcx.tcx, typ),\n-               self.modes);\n-\n-        // n.b. This is a hokey mess because the current fold doesn't\n-        // allow us to pass back errors in any useful way.\n-\n-        let rty = self.resolve_type(typ);\n-        match self.err {\n-            None => {\n-                debug!(\"Resolved {} to {} (modes={:x})\",\n-                       ty_to_string(self.infcx.tcx, typ),\n-                       ty_to_string(self.infcx.tcx, rty),\n-                       self.modes);\n-                return Ok(rty);\n-            }\n-            Some(e) => {\n-                return Err(e);\n-            }\n-        }\n-    }\n-\n-    pub fn resolve_region_chk(&mut self,\n-                              orig: ty::Region)\n-                              -> fres<ty::Region> {\n-        self.err = None;\n-        let resolved = self.resolve_region(orig);\n-        match self.err {\n-          None => Ok(resolved),\n-          Some(e) => Err(e)\n-        }\n-    }\n-\n-    pub fn resolve_type(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"resolve_type({})\", typ.repr(self.infcx.tcx));\n-\n-        if !ty::type_needs_infer(typ) {\n-            return typ;\n-        }\n-\n-        if self.type_depth > 0 && !self.should(resolve_nested_tvar) {\n-            return typ;\n-        }\n-\n-        match typ.sty {\n-            ty::ty_infer(TyVar(vid)) => {\n-                self.resolve_ty_var(vid)\n-            }\n-            ty::ty_infer(IntVar(vid)) => {\n-                self.resolve_int_var(vid)\n-            }\n-            ty::ty_infer(FloatVar(vid)) => {\n-                self.resolve_float_var(vid)\n-            }\n-            _ => {\n-                if self.modes & resolve_all == 0 {\n-                    // if we are only resolving top-level type\n-                    // variables, and this is not a top-level type\n-                    // variable, then shortcircuit for efficiency\n-                    typ\n-                } else {\n-                    self.type_depth += 1;\n-                    let result = ty_fold::super_fold_ty(self, typ);\n-                    self.type_depth -= 1;\n-                    result\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n-        debug!(\"Resolve_region({})\", orig.repr(self.infcx.tcx));\n-        match orig {\n-          ty::ReInfer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n-          _ => orig\n-        }\n-    }\n-\n-    pub fn resolve_region_var(&mut self, rid: RegionVid) -> ty::Region {\n-        if !self.should(resolve_rvar) {\n-            return ty::ReInfer(ty::ReVar(rid));\n-        }\n-        self.infcx.region_vars.resolve_var(rid)\n-    }\n-\n-    pub fn resolve_ty_var(&mut self, vid: TyVid) -> Ty<'tcx> {\n-        let tcx = self.infcx.tcx;\n-        let tv = self.infcx.type_variables.borrow();\n-        match tv.probe(vid) {\n-            Some(t) => {\n-                self.resolve_type(t)\n-            }\n-            None => {\n-                if self.should(force_tvar) {\n-                    self.err = Some(unresolved_ty(vid));\n-                }\n-                ty::mk_var(tcx, vid)\n-            }\n-        }\n-    }\n-\n-    pub fn resolve_int_var(&mut self, vid: IntVid) -> Ty<'tcx> {\n-        if !self.should(resolve_ivar) {\n-            return ty::mk_int_var(self.infcx.tcx, vid);\n-        }\n-\n-        let tcx = self.infcx.tcx;\n-        let table = &self.infcx.int_unification_table;\n-        let node = table.borrow_mut().get(tcx, vid);\n-        match node.value {\n-          Some(IntType(t)) => ty::mk_mach_int(t),\n-          Some(UintType(t)) => ty::mk_mach_uint(t),\n-          None => {\n-            if self.should(force_ivar) {\n-                // As a last resort, emit an error.\n-                self.err = Some(unresolved_int_ty(vid));\n-            }\n-            ty::mk_int_var(self.infcx.tcx, vid)\n-          }\n-        }\n-    }\n-\n-    pub fn resolve_float_var(&mut self, vid: FloatVid) -> Ty<'tcx> {\n-        if !self.should(resolve_fvar) {\n-            return ty::mk_float_var(self.infcx.tcx, vid);\n-        }\n-\n-        let tcx = self.infcx.tcx;\n-        let table = &self.infcx.float_unification_table;\n-        let node = table.borrow_mut().get(tcx, vid);\n-        match node.value {\n-          Some(t) => ty::mk_mach_float(t),\n-          None => {\n-            if self.should(force_fvar) {\n-                // As a last resort, emit an error.\n-                self.err = Some(unresolved_float_ty(vid));\n-            }\n-            ty::mk_float_var(self.infcx.tcx, vid)\n-          }\n+        if !ty::type_has_ty_infer(t) {\n+            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+        } else {\n+            let t0 = self.infcx.shallow_resolve(t);\n+            ty_fold::super_fold_ty(self, t0)\n         }\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-/// DEEP TYPE RESOLVER\n-///\n-/// This kind of resolver can be used at any time. It simply replaces\n-/// type variables that have been unified with the things they have\n-/// been unified with (similar to `shallow_resolve`, but deep). This is\n-/// useful for printing messages etc but also required at various\n-/// points for correctness.\n-pub struct DeepTypeResolver<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+// FULL TYPE RESOLUTION\n+\n+/// Full type resolution replaces all type and region variables with\n+/// their concrete results. If any variable cannot be replaced (never unified, etc)\n+/// then an `Err` result is returned.\n+pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> fres<T>\n+    where T : TypeFoldable<'tcx>\n+{\n+    let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n+    let result = value.fold_with(&mut full_resolver);\n+    match full_resolver.err {\n+        None => Ok(result),\n+        Some(e) => Err(e),\n+    }\n }\n \n-impl<'a, 'tcx> DeepTypeResolver<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> DeepTypeResolver<'a, 'tcx> {\n-        DeepTypeResolver { infcx: infcx }\n-    }\n+// N.B. This type is not public because the protocol around checking the\n+// `err` field is not enforcable otherwise.\n+struct FullTypeResolver<'a, 'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    err: Option<fixup_err>,\n }\n \n-impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for DeepTypeResolver<'a, 'tcx> {\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_has_ty_infer(t) {\n+        if !ty::type_needs_infer(t) {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n-            let t0 = self.infcx.shallow_resolve(t);\n-            ty_fold::super_fold_ty(self, t0)\n+            let t = self.infcx.shallow_resolve(t);\n+            match t.sty {\n+                ty::ty_infer(ty::TyVar(vid)) => {\n+                    self.err = Some(unresolved_ty(vid));\n+                    ty::mk_err()\n+                }\n+                ty::ty_infer(ty::IntVar(vid)) => {\n+                    self.err = Some(unresolved_int_ty(vid));\n+                    ty::mk_err()\n+                }\n+                ty::ty_infer(ty::FloatVar(vid)) => {\n+                    self.err = Some(unresolved_float_ty(vid));\n+                    ty::mk_err()\n+                }\n+                ty::ty_infer(_) => {\n+                    self.infcx.tcx.sess.bug(\n+                        format!(\"Unexpected type in full type resolver: {}\",\n+                                t.repr(self.infcx.tcx))[]);\n+                }\n+                _ => {\n+                    ty_fold::super_fold_ty(self, t)\n+                }\n+            }\n         }\n     }\n-}\n \n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+          ty::ReInfer(ty::ReVar(rid)) => self.infcx.region_vars.resolve_var(rid),\n+          _ => r,\n+        }\n+    }\n+}\n "}, {"sha": "b31683219f1cdcb7b49bd0a04e8fbeaccc71a46d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::def;\n-use middle::infer::{mod, resolve};\n+use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::subst::{Subst, Substs};\n use middle::ty::{mod, Ty};\n@@ -143,11 +143,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ast::PatRegion(ref inner) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n \n-            let mutbl = infer::resolve_type(\n-                fcx.infcx(), Some(pat.span),\n-                expected, resolve::try_resolve_tvar_shallow)\n-                .ok()\n-                .and_then(|t| ty::deref(t, true))\n+            let mutbl =\n+                ty::deref(fcx.infcx().shallow_resolve(expected), true)\n                 .map_or(ast::MutImmutable, |mt| mt.mutbl);\n \n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n@@ -214,23 +211,21 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                       inner: &ast::Pat) -> bool {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n-    match infer::resolve_type(\n-        fcx.infcx(), Some(span),\n-        expected, resolve::try_resolve_tvar_shallow) {\n-        Ok(t) if pat_is_binding(&tcx.def_map, inner) => {\n-            ty::deref(t, true).map_or(true, |mt| match mt.ty.sty {\n-                ty::ty_trait(_) => {\n-                    // This is \"x = SomeTrait\" being reduced from\n-                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    span_err!(tcx.sess, span, E0033,\n-                        \"type `{}` cannot be dereferenced\",\n-                        fcx.infcx().ty_to_string(t));\n-                    false\n-                }\n-                _ => true\n-            })\n-        }\n-        _ => true\n+    if pat_is_binding(&tcx.def_map, inner) {\n+        let expected = fcx.infcx().shallow_resolve(expected);\n+        ty::deref(expected, true).map_or(true, |mt| match mt.ty.sty {\n+            ty::ty_trait(_) => {\n+                // This is \"x = SomeTrait\" being reduced from\n+                // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+                span_err!(tcx.sess, span, E0033,\n+                          \"type `{}` cannot be dereferenced\",\n+                          fcx.infcx().ty_to_string(expected));\n+                false\n+            }\n+            _ => true\n+        })\n+    } else {\n+        true\n     }\n }\n "}, {"sha": "9af9eaf75f5a516927815c585297fde3b24c6ea2", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "patch": "@@ -12,8 +12,6 @@\n use check::FnCtxt;\n use middle::ty::{mod, Ty};\n use middle::infer;\n-use middle::infer::resolve_type;\n-use middle::infer::resolve::try_resolve_tvar_shallow;\n \n use std::result::Result::{Err, Ok};\n use syntax::ast;\n@@ -63,12 +61,7 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),\n            expr_ty.repr(fcx.ccx.tcx));\n-    let expected = if ty::type_needs_infer(expected) {\n-        resolve_type(fcx.infcx(),\n-                     None,\n-                     expected,\n-                     try_resolve_tvar_shallow).unwrap_or(expected)\n-    } else { expected };\n+    let expected = fcx.infcx().resolve_type_vars_if_possible(&expected);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       Ok(()) => { /* ok */ }\n       Err(ref err) => {"}, {"sha": "ad6ba0a1d55710fb53814b889e6e4477fe3935ad", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "patch": "@@ -124,8 +124,6 @@ use middle::region::CodeExtent;\n use middle::traits;\n use middle::ty::{ReScope};\n use middle::ty::{mod, Ty, MethodCall};\n-use middle::infer::resolve_and_force_all_but_regions;\n-use middle::infer::resolve_type;\n use middle::infer;\n use middle::pat_util;\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap};\n@@ -307,11 +305,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// of b will be `&<R0>.int` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match resolve_type(self.fcx.infcx(), None, unresolved_ty,\n-                           resolve_and_force_all_but_regions) {\n-            Ok(t) => t,\n-            Err(_) => ty::mk_err()\n-        }\n+        self.fcx.infcx().resolve_type_vars_if_possible(&unresolved_ty)\n     }\n \n     /// Try to resolve the type for the given node."}, {"sha": "b73381966e8dcb931ee0a080fa80be7cb7b00f6b", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "patch": "@@ -19,8 +19,6 @@ use middle::def;\n use middle::pat_util;\n use middle::ty::{mod, Ty, MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n-use middle::infer::{force_all, resolve_all, resolve_region};\n-use middle::infer::resolve_type;\n use middle::infer;\n use write_substs_to_tcx;\n use write_ty_to_tcx;\n@@ -337,8 +335,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn resolve<T:ResolveIn<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n-        t.resolve_in(&mut Resolver::new(self.fcx, reason))\n+    fn resolve<T:TypeFoldable<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n+        t.fold_with(&mut Resolver::new(self.fcx, reason))\n     }\n }\n \n@@ -375,19 +373,6 @@ impl ResolveReason {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Convenience methods for resolving different kinds of things.\n-\n-trait ResolveIn<'tcx> {\n-    fn resolve_in<'a>(&self, resolver: &mut Resolver<'a, 'tcx>) -> Self;\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> ResolveIn<'tcx> for T {\n-    fn resolve_in<'a>(&self, resolver: &mut Resolver<'a, 'tcx>) -> T {\n-        self.fold_with(resolver)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n@@ -465,21 +450,19 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_infer(t) {\n-            return t;\n-        }\n-\n-        match resolve_type(self.infcx, None, t, resolve_all | force_all) {\n+        match self.infcx.fully_resolve(&t) {\n             Ok(t) => t,\n             Err(e) => {\n+                debug!(\"Resolver::fold_ty: input type `{}` not fully resolvable\",\n+                       t.repr(self.tcx));\n                 self.report_error(e);\n                 ty::mk_err()\n             }\n         }\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match resolve_region(self.infcx, r, resolve_all | force_all) {\n+        match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n             Err(e) => {\n                 self.report_error(e);"}, {"sha": "8ed0ac98e1eaed2b9d462715f23da659f0785895", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 22, "deletions": 66, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=eb6ea5d49b4eb21278d6ecdfa472f2cd90d379d0", "patch": "@@ -26,12 +26,13 @@ use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n-use middle::ty::{type_is_ty_var};\n+use middle::ty::{ty_closure};\n+use middle::subst::Subst;\n use middle::ty;\n use CrateCtxt;\n use middle::infer::combine::Combine;\n use middle::infer::InferCtxt;\n-use middle::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n+use middle::infer::{new_infer_ctxt};\n use std::collections::{HashSet};\n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -52,80 +53,35 @@ mod orphan;\n mod overlap;\n mod unsafety;\n \n-fn get_base_type<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n-                           span: Span,\n-                           original_type: Ty<'tcx>)\n-                           -> Option<Ty<'tcx>> {\n-    let resolved_type = match resolve_type(inference_context,\n-                                           Some(span),\n-                                           original_type,\n-                                           resolve_ivar) {\n-        Ok(resulting_type) if !type_is_ty_var(resulting_type) => resulting_type,\n-        _ => {\n-            inference_context.tcx.sess.span_fatal(span,\n-                                                  \"the type of this value must be known in order \\\n-                                                   to determine the base type\");\n-        }\n-    };\n-\n-    match resolved_type.sty {\n-        ty_enum(..) | ty_struct(..) | ty_unboxed_closure(..) => {\n-            debug!(\"(getting base type) found base type\");\n-            Some(resolved_type)\n+// Returns the def ID of the base type, if there is one.\n+fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n+                                  span: Span,\n+                                  ty: Ty<'tcx>)\n+                                  -> Option<DefId> {\n+    match ty.sty {\n+        ty_enum(def_id, _) |\n+        ty_struct(def_id, _) => {\n+            Some(def_id)\n         }\n \n-        _ if ty::type_is_trait(resolved_type) => {\n-            debug!(\"(getting base type) found base type (trait)\");\n-            Some(resolved_type)\n+        ty_trait(ref t) => {\n+            Some(t.principal.def_id)\n         }\n \n         ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n-        ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n+        ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {\n-            debug!(\"(getting base type) no base type; found {}\",\n-                   original_type.sty);\n             None\n         }\n-        ty_trait(..) => panic!(\"should have been caught\")\n-    }\n-}\n \n-// Returns the def ID of the base type, if there is one.\n-fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n-                                  span: Span,\n-                                  original_type: Ty<'tcx>)\n-                                  -> Option<DefId> {\n-    match get_base_type(inference_context, span, original_type) {\n-        None => None,\n-        Some(base_type) => {\n-            match base_type.sty {\n-                ty_enum(def_id, _) |\n-                ty_struct(def_id, _) |\n-                ty_unboxed_closure(def_id, _, _) => {\n-                    Some(def_id)\n-                }\n-                ty_ptr(ty::mt {ty, ..}) |\n-                ty_rptr(_, ty::mt {ty, ..}) |\n-                ty_uniq(ty) => {\n-                    match ty.sty {\n-                        ty_trait(box ty::TyTrait { ref principal, .. }) => {\n-                            Some(principal.def_id)\n-                        }\n-                        _ => {\n-                            panic!(\"get_base_type() returned a type that wasn't an \\\n-                                   enum, struct, or trait\");\n-                        }\n-                    }\n-                }\n-                ty_trait(box ty::TyTrait { ref principal, .. }) => {\n-                    Some(principal.def_id)\n-                }\n-                _ => {\n-                    panic!(\"get_base_type() returned a type that wasn't an \\\n-                           enum, struct, or trait\");\n-                }\n-            }\n+        ty_infer(..) | ty_unboxed_closure(..) => {\n+            // `ty` comes from a user declaration so we should only expect types\n+            // that the user can type\n+            inference_context.tcx.sess.span_bug(\n+                span,\n+                format!(\"coherence encountered unexpected type searching for base type: {}\",\n+                        ty.repr(inference_context.tcx))[]);\n         }\n     }\n }"}]}