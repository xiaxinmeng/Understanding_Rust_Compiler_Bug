{"sha": "3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMzIzYzFiMmQ3NTViODZiMTk4N2JiYTM0NTRiYjJmMGY5MmIxYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-18T11:07:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-18T11:07:27Z"}, "message": "auto merge of #6565 : osaut/rust/futures, r=thestinger\n\n* The example given in future.rs was corrected.\r\n\r\n* I have added a small section describing futures in tutorial on tasks. It is far from being complete as I am stil learning !\r\n\r\n(This is an updated version of PR 6537).", "tree": {"sha": "f40a70ca983986a7333a3764dd95887e208fef11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f40a70ca983986a7333a3764dd95887e208fef11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "html_url": "https://github.com/rust-lang/rust/commit/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb0e2f45ec5eb84ac3b30e7ce92fb70415d232d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb0e2f45ec5eb84ac3b30e7ce92fb70415d232d3", "html_url": "https://github.com/rust-lang/rust/commit/eb0e2f45ec5eb84ac3b30e7ce92fb70415d232d3"}, {"sha": "4b13895c2f43024b2b0986d4c2ddcb742926c3c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b13895c2f43024b2b0986d4c2ddcb742926c3c6", "html_url": "https://github.com/rust-lang/rust/commit/4b13895c2f43024b2b0986d4c2ddcb742926c3c6"}], "stats": {"total": 87, "additions": 68, "deletions": 19}, "files": [{"sha": "c9e0377dd132ca9d55f5aa13693924b50d827465", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "patch": "@@ -43,22 +43,24 @@ in the core and standard libraries, which are still under development\n and do not always present a consistent or complete interface.\n \n For your reference, these are the standard modules involved in Rust\n-concurrency at this writing.\n+concurrency at this writing:\n \n-* [`core::task`] - All code relating to tasks and task scheduling\n-* [`core::comm`] - The message passing interface\n-* [`core::pipes`] - The underlying messaging infrastructure\n-* [`std::comm`] - Additional messaging types based on `core::pipes`\n-* [`std::sync`] - More exotic synchronization tools, including locks\n+* [`core::task`] - All code relating to tasks and task scheduling,\n+* [`core::comm`] - The message passing interface,\n+* [`core::pipes`] - The underlying messaging infrastructure,\n+* [`std::comm`] - Additional messaging types based on `core::pipes`,\n+* [`std::sync`] - More exotic synchronization tools, including locks,\n * [`std::arc`] - The ARC (atomically reference counted) type,\n-  for safely sharing immutable data\n+  for safely sharing immutable data,\n+* [`std::future`] - A type representing values that may be computed concurrently and retrieved at a later time.\n \n [`core::task`]: core/task.html\n [`core::comm`]: core/comm.html\n [`core::pipes`]: core/pipes.html\n [`std::comm`]: std/comm.html\n [`std::sync`]: std/sync.html\n [`std::arc`]: std/arc.html\n+[`std::future`]: std/future.html\n \n # Basics\n \n@@ -70,7 +72,7 @@ closure in the new task.\n \n ~~~~\n # use core::io::println;\n-use core::task::spawn;\n+# use core::task::spawn;\n \n // Print something profound in a different task using a named function\n fn print_message() { println(\"I am running in a different task!\"); }\n@@ -145,8 +147,8 @@ endpoint. Consider the following example of calculating two results\n concurrently:\n \n ~~~~\n-use core::task::spawn;\n-use core::comm::{stream, Port, Chan};\n+# use core::task::spawn;\n+# use core::comm::{stream, Port, Chan};\n \n let (port, chan): (Port<int>, Chan<int>) = stream();\n \n@@ -233,7 +235,7 @@ Instead we can use a `SharedChan`, a type that allows a single\n \n ~~~\n # use core::task::spawn;\n-use core::comm::{stream, SharedChan};\n+# use core::comm::{stream, SharedChan};\n \n let (port, chan) = stream();\n let chan = SharedChan::new(chan);\n@@ -282,6 +284,51 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n+## Futures\n+With `std::future`, rust has a mechanism for requesting a computation and getting the result\n+later.\n+\n+The basic example below illustrates this.\n+~~~\n+# fn make_a_sandwich() {};\n+fn fib(n: uint) -> uint {\n+    // lengthy computation returning an uint\n+    12586269025\n+}\n+\n+let mut delayed_fib = std::future::spawn (|| fib(50) );\n+make_a_sandwich();\n+println(fmt!(\"fib(50) = %?\", delayed_fib.get()))\n+~~~\n+\n+The call to `future::spawn` returns immediately a `future` object regardless of how long it\n+takes to run `fib(50)`. You can then make yourself a sandwich while the computation of `fib` is\n+running. The result of the execution of the method is obtained by calling `get` on the future.\n+This call will block until the value is available (*i.e.* the computation is complete). Note that\n+the future needs to be mutable so that it can save the result for next time `get` is called.\n+\n+Here is another example showing how futures allow you to background computations. The workload will\n+be distributed on the available cores.\n+~~~\n+fn partial_sum(start: uint) -> f64 {\n+    let mut local_sum = 0f64;\n+    for uint::range(start*100000, (start+1)*100000) |num| {\n+        local_sum += (num as f64 + 1.0).pow(-2.0);\n+    }\n+    local_sum\n+}\n+\n+fn main() {\n+    let mut futures = vec::from_fn(1000, |ind| do std::future::spawn { partial_sum(ind) });\n+\n+    let mut final_res = 0f64;\n+    for futures.each_mut |ft|  {\n+        final_res += ft.get();\n+    }\n+    println(fmt!(\"\u03c0^2/6 is not far from : %?\", final_res));\n+}\n+~~~\n+\n # Handling task failure\n \n Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n@@ -363,8 +410,8 @@ either task fails, it kills the other one.\n ~~~\n # fn sleep_forever() { loop { task::yield() } }\n # do task::try {\n-do task::spawn {\n-    do task::spawn {\n+do spawn {\n+    do spawn {\n         fail!();  // All three tasks will fail.\n     }\n     sleep_forever();  // Will get woken up by force, then fail"}, {"sha": "ef9318e8d3de12ac9aafbe4a3256730ec3aeff95", "filename": "src/libstd/future.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,9 +15,11 @@\n  * # Example\n  *\n  * ~~~\n- * let delayed_fib = future::spawn {|| fib(5000) };\n+ * # fn fib(n: uint) -> uint {42};\n+ * # fn make_a_sandwich() {};\n+ * let mut delayed_fib = std::future::spawn (|| fib(5000) );\n  * make_a_sandwich();\n- * io::println(fmt!(\"fib(5000) = %?\", delayed_fib.get()))\n+ * println(fmt!(\"fib(5000) = %?\", delayed_fib.get()))\n  * ~~~\n  */\n \n@@ -51,7 +53,7 @@ priv enum FutureState<A> {\n /// Methods on the `future` type\n pub impl<A:Copy> Future<A> {\n     fn get(&mut self) -> A {\n-        //! Get the value of the future\n+        //! Get the value of the future.\n         *(self.get_ref())\n     }\n }\n@@ -87,7 +89,7 @@ pub impl<A> Future<A> {\n \n pub fn from_value<A>(val: A) -> Future<A> {\n     /*!\n-     * Create a future from a value\n+     * Create a future from a value.\n      *\n      * The value is immediately available and calling `get` later will\n      * not block.\n@@ -117,7 +119,7 @@ pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n     /*!\n      * Create a future from a function.\n      *\n-     * The first time that the value is requested it will be retreived by\n+     * The first time that the value is requested it will be retrieved by\n      * calling the function.  Note that this function is a local\n      * function. It is not spawned into another task.\n      */"}]}