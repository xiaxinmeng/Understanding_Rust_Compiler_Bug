{"sha": "1b732145ec569cd67e2a5d0cc4dd37d5cd60c961", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNzMyMTQ1ZWM1NjljZDY3ZTJhNWQwY2M0ZGQzN2Q1Y2Q2MGM5NjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-05T18:50:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-05T18:52:08Z"}, "message": "rustc: Implement simple trait inheritance.\n\nGeneric trait inheritance, cross-crate trait inheritance, and vtable-based\ntrait inheritance don't work yet.", "tree": {"sha": "f322c22432d6427d6665ea4f3c5615526d06fb5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f322c22432d6427d6665ea4f3c5615526d06fb5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961", "html_url": "https://github.com/rust-lang/rust/commit/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c56a7e5c25c2a411ba119f3a17bfa6db0b1722ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/c56a7e5c25c2a411ba119f3a17bfa6db0b1722ed", "html_url": "https://github.com/rust-lang/rust/commit/c56a7e5c25c2a411ba119f3a17bfa6db0b1722ed"}], "stats": {"total": 171, "additions": 136, "deletions": 35}, "files": [{"sha": "5f30346a28e8f90fff6f4d1d84b9655cf5ed040e", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=1b732145ec569cd67e2a5d0cc4dd37d5cd60c961", "patch": "@@ -4181,9 +4181,9 @@ impl Resolver {\n         }\n \n         return self.resolve_identifier(path.idents.last(),\n-                                    namespace,\n-                                    check_ribs,\n-                                    path.span);\n+                                       namespace,\n+                                       check_ribs,\n+                                       path.span);\n     }\n \n     fn resolve_identifier(identifier: ident,"}, {"sha": "e8926468b3a89261045166f358520c731b6e78c0", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 75, "deletions": 27, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1b732145ec569cd67e2a5d0cc4dd37d5cd60c961", "patch": "@@ -51,8 +51,8 @@ fn lookup_vtables(fcx: @fn_ctxt,\n             match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                match lookup_vtable(fcx, expr, *ty, i_ty, allow_unsafe,\n-                                    is_early) {\n+                match lookup_vtable_covariant(fcx, expr, *ty, i_ty,\n+                                              allow_unsafe, is_early) {\n                     Some(vtable) => result.push(vtable),\n                     None => {\n                         fcx.tcx().sess.span_fatal(\n@@ -91,28 +91,75 @@ fn relate_trait_tys(fcx: @fn_ctxt, expr: @ast::expr,\n     demand::suptype(fcx, expr.span, exp_trait_ty, act_trait_ty)\n }\n \n-/*\n-Look up the vtable to use when treating an item of type <t>\n-as if it has type <trait_ty>\n-*/\n-fn lookup_vtable(fcx: @fn_ctxt,\n-                 expr: @ast::expr,\n-                 ty: ty::t,\n-                 trait_ty: ty::t,\n-                 allow_unsafe: bool,\n-                 is_early: bool)\n-    -> Option<vtable_origin>\n-{\n+// Look up the vtable to use when treating an item of type `t` as if it has\n+// type `trait_ty`. This does allow subtraits.\n+fn lookup_vtable_covariant(fcx: @fn_ctxt,\n+                           expr: @ast::expr,\n+                           ty: ty::t,\n+                           trait_ty: ty::t,\n+                           allow_unsafe: bool,\n+                           is_early: bool)\n+                        -> Option<vtable_origin> {\n+    let worklist = dvec::DVec();\n+    worklist.push(trait_ty);\n+    while worklist.len() > 0 {\n+        let trait_ty = worklist.pop();\n+        let result = lookup_vtable_invariant(fcx, expr, ty, trait_ty,\n+                                             allow_unsafe, is_early);\n+        if result.is_some() {\n+            return result;\n+        }\n+\n+        // Add subtraits to the worklist, if applicable.\n+        match ty::get(trait_ty).sty {\n+            ty::ty_trait(trait_id, _, _) => {\n+                let table = fcx.ccx.coherence_info.supertrait_to_subtraits;\n+                match table.find(trait_id) {\n+                    None => {}\n+                    Some(subtraits) => {\n+                        for subtraits.each |subtrait_id| {\n+                            // XXX: This is wrong; subtraits should themselves\n+                            // have substs.\n+                            let substs =\n+                                { self_r: None, self_ty: None, tps: ~[] };\n+                            let trait_ty = ty::mk_trait(fcx.ccx.tcx,\n+                                                        *subtrait_id,\n+                                                        substs,\n+                                                        ty::vstore_box);\n+                            worklist.push(trait_ty);\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {\n+                fcx.ccx.tcx.sess.impossible_case(expr.span,\n+                                                 \"lookup_vtable_covariant: \\\n+                                                  non-trait in worklist\");\n+            }\n+        }\n+    }\n \n-    debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n+    return None;\n+}\n+\n+// Look up the vtable to use when treating an item of type `t` as if it has\n+// type `trait_ty`. This does not allow subtraits.\n+fn lookup_vtable_invariant(fcx: @fn_ctxt,\n+                           expr: @ast::expr,\n+                           ty: ty::t,\n+                           trait_ty: ty::t,\n+                           allow_unsafe: bool,\n+                           is_early: bool)\n+                        -> Option<vtable_origin> {\n+    debug!(\"lookup_vtable_invariant(ty=%s, trait_ty=%s)\",\n            fcx.infcx().ty_to_str(ty), fcx.inh.infcx.ty_to_str(trait_ty));\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n     let (trait_id, trait_substs) = match ty::get(trait_ty).sty {\n         ty::ty_trait(did, substs, _) => (did, substs),\n         _ => tcx.sess.impossible_case(expr.span,\n-                                      \"lookup_vtable: \\\n+                                      \"lookup_vtable_invariant: \\\n                                        don't know how to handle a non-trait\")\n     };\n     let ty = match fixup_ty(fcx, expr, ty, is_early) {\n@@ -150,7 +197,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                             }\n                             _ => tcx.sess.impossible_case(\n                                 expr.span,\n-                                \"lookup_vtable: in loop, \\\n+                                \"lookup_vtable_invariant: in loop, \\\n                                  don't know how to handle a non-trait ity\")\n                         }\n                         n_bound += 1u;\n@@ -462,24 +509,25 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n         let target_ty = fcx.expr_ty(ex);\n         match ty::get(target_ty).sty {\n           ty::ty_trait(*) => {\n-            /*\n-            Look up vtables for the type we're casting to,\n-            passing in the source and target type\n-            */\n+            // Look up vtables for the type we're casting to, passing in the\n+            // source and target type.\n+            //\n+            // XXX: This is invariant and shouldn't be. --pcw\n+\n             let ty = fcx.expr_ty(src);\n-            let vtable_opt = lookup_vtable(fcx, ex, ty, target_ty, true,\n-                                           is_early);\n+            let vtable_opt = lookup_vtable_invariant(fcx, ex, ty, target_ty,\n+                                                     true, is_early);\n             match vtable_opt {\n                 None => {\n                     // Try the new-style boxed trait; \"@int as @Trait\".\n                     let mut err = false;\n                     let ty = structurally_resolved_type(fcx, ex.span, ty);\n                     match ty::get(ty).sty {\n                         ty::ty_box(boxed_ty) => {\n-                            let vtable_opt = lookup_vtable(fcx, ex,\n-                                                           boxed_ty.ty,\n-                                                           target_ty, true,\n-                                                           is_early);\n+                            let vtable_opt =\n+                                lookup_vtable_invariant(fcx, ex, boxed_ty.ty,\n+                                                        target_ty, true,\n+                                                        is_early);\n                             match vtable_opt {\n                                 Some(vtable) => {\n                                     /*"}, {"sha": "89cd696eb6fbdbdce4e9767213706d421f5af5cb", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1b732145ec569cd67e2a5d0cc4dd37d5cd60c961", "patch": "@@ -126,12 +126,16 @@ struct CoherenceInfo {\n     // Contains implementations of methods associated with a trait. For these,\n     // the associated trait must be imported at the call site.\n     extension_methods: HashMap<def_id,@DVec<@Impl>>,\n+\n+    // A mapping from a supertrait to its subtraits.\n+    supertrait_to_subtraits: HashMap<def_id,@DVec<def_id>>\n }\n \n fn CoherenceInfo() -> CoherenceInfo {\n     CoherenceInfo {\n         inherent_methods: HashMap(),\n-        extension_methods: HashMap()\n+        extension_methods: HashMap(),\n+        supertrait_to_subtraits: HashMap()\n     }\n }\n \n@@ -161,7 +165,6 @@ struct CoherenceChecker {\n }\n \n impl CoherenceChecker {\n-\n     // Create a mapping containing a MethodInfo for every provided\n     // method in every trait.\n     fn build_provided_methods_map(crate: @crate) {\n@@ -225,9 +228,9 @@ impl CoherenceChecker {\n     }\n \n     fn check_coherence(crate: @crate) {\n-\n-        // Check implementations. This populates the tables containing the\n-        // inherent methods and extension methods.\n+        // Check implementations and traits. This populates the tables\n+        // containing the inherent methods and extension methods. It also\n+        // builds up the trait inheritance table.\n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n                 debug!(\"(checking coherence) item '%s'\",\n@@ -240,6 +243,9 @@ impl CoherenceChecker {\n                     item_class(struct_def, _) => {\n                         self.check_implementation(item, struct_def.traits);\n                     }\n+                    item_trait(_, supertraits, _) => {\n+                        self.register_inherited_trait(item, supertraits);\n+                    }\n                     _ => {\n                         // Nothing to do.\n                     }\n@@ -324,6 +330,27 @@ impl CoherenceChecker {\n         }\n     }\n \n+    fn register_inherited_trait(item: @item, supertraits: ~[@trait_ref]) {\n+        // XXX: This is wrong. We need to support substitutions; e.g.\n+        // trait Foo : Bar<int>.\n+        let supertrait_to_subtraits =\n+            self.crate_context.coherence_info.supertrait_to_subtraits;\n+        let subtrait_id = local_def(item.id);\n+        for supertraits.each |supertrait| {\n+            let supertrait_id = self.trait_ref_to_trait_def_id(*supertrait);\n+            match supertrait_to_subtraits.find(supertrait_id) {\n+                None => {\n+                    let new_vec = @dvec::DVec();\n+                    new_vec.push(subtrait_id);\n+                    supertrait_to_subtraits.insert(supertrait_id, new_vec);\n+                }\n+                Some(existing_vec) => {\n+                    existing_vec.push(subtrait_id);\n+                }\n+            }\n+        }\n+    }\n+\n     fn add_inherent_method(base_def_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.inherent_methods"}, {"sha": "fcd4cf1de6b365f377f5a7b68b20838497f6ec6c", "filename": "src/test/run-pass/trait-inheritance-simple.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b732145ec569cd67e2a5d0cc4dd37d5cd60c961/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs?ref=1b732145ec569cd67e2a5d0cc4dd37d5cd60c961", "patch": "@@ -0,0 +1,26 @@\n+trait Foo {\n+    fn f();\n+}\n+\n+trait Bar : Foo {\n+    fn g();\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl A : Bar {\n+    fn g() { io::println(\"in g\"); }\n+    fn f() { io::println(\"in f\"); }\n+}\n+\n+fn h<T:Foo>(a: &T) {\n+    a.f();\n+}\n+\n+fn main() {\n+    let a = A { x: 3 };\n+    h(&a);\n+}\n+"}]}