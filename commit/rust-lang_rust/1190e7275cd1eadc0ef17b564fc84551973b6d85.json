{"sha": "1190e7275cd1eadc0ef17b564fc84551973b6d85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTBlNzI3NWNkMWVhZGMwZWYxN2I1NjRmYzg0NTUxOTczYjZkODU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-23T21:49:26Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:32Z"}, "message": "Cache head constructor in PatStack\n\nSince the constructor is recomputed a lot, caching is worth it.", "tree": {"sha": "b674e3939f92a0a7a30afe68c1069271b6d7d5ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b674e3939f92a0a7a30afe68c1069271b6d7d5ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1190e7275cd1eadc0ef17b564fc84551973b6d85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1190e7275cd1eadc0ef17b564fc84551973b6d85", "html_url": "https://github.com/rust-lang/rust/commit/1190e7275cd1eadc0ef17b564fc84551973b6d85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1190e7275cd1eadc0ef17b564fc84551973b6d85/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "833089fbc9d800813686d4d9b228c0dfe2aabd7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/833089fbc9d800813686d4d9b228c0dfe2aabd7b", "html_url": "https://github.com/rust-lang/rust/commit/833089fbc9d800813686d4d9b228c0dfe2aabd7b"}], "stats": {"total": 131, "additions": 63, "deletions": 68}, "files": [{"sha": "0866892265bd907824a725c8f7dd4472fc5d44ed", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1190e7275cd1eadc0ef17b564fc84551973b6d85/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1190e7275cd1eadc0ef17b564fc84551973b6d85/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=1190e7275cd1eadc0ef17b564fc84551973b6d85", "patch": "@@ -9,6 +9,7 @@\n #![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(bool_to_option)]\n+#![feature(once_cell)]\n #![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "30529ef5e1bb87d30d641a9d58038c2f6fa081c6", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/1190e7275cd1eadc0ef17b564fc84551973b6d85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1190e7275cd1eadc0ef17b564fc84551973b6d85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=1190e7275cd1eadc0ef17b564fc84551973b6d85", "patch": "@@ -295,6 +295,7 @@ use self::WitnessPreference::*;\n \n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::OnceCell;\n use rustc_index::vec::Idx;\n \n use super::{compare_const_vals, PatternFoldable, PatternFolder};\n@@ -346,32 +347,40 @@ impl<'tcx> Pat<'tcx> {\n \n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n-#[derive(Debug, Clone, PartialEq)]\n-crate struct PatStack<'p, 'tcx>(SmallVec<[&'p Pat<'tcx>; 2]>);\n+#[derive(Debug, Clone)]\n+crate struct PatStack<'p, 'tcx> {\n+    pats: SmallVec<[&'p Pat<'tcx>; 2]>,\n+    /// Cache for the constructor of the head\n+    head_ctor: OnceCell<Constructor<'tcx>>,\n+}\n \n impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     crate fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n-        PatStack(smallvec![pat])\n+        Self::from_vec(smallvec![pat])\n     }\n \n     fn from_vec(vec: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n-        PatStack(vec)\n+        PatStack { pats: vec, head_ctor: OnceCell::new() }\n     }\n \n     fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n+        self.pats.is_empty()\n     }\n \n     fn len(&self) -> usize {\n-        self.0.len()\n+        self.pats.len()\n     }\n \n     fn head(&self) -> &'p Pat<'tcx> {\n-        self.0[0]\n+        self.pats[0]\n+    }\n+\n+    fn head_ctor<'a>(&'a self, cx: &MatchCheckCtxt<'p, 'tcx>) -> &'a Constructor<'tcx> {\n+        self.head_ctor.get_or_init(|| pat_constructor(cx, self.head()))\n     }\n \n     fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n-        self.0.iter().copied()\n+        self.pats.iter().copied()\n     }\n \n     // If the first pattern is an or-pattern, expand this pattern. Otherwise, return `None`.\n@@ -383,7 +392,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n                 pats.iter()\n                     .map(|pat| {\n                         let mut new_patstack = PatStack::from_pattern(pat);\n-                        new_patstack.0.extend_from_slice(&self.0[1..]);\n+                        new_patstack.pats.extend_from_slice(&self.pats[1..]);\n                         new_patstack\n                     })\n                     .collect(),\n@@ -414,16 +423,13 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         is_my_head_ctor: bool,\n     ) -> Option<PatStack<'p, 'tcx>> {\n         // We return `None` if `ctor` is not covered by `self.head()`. If `ctor` is known to be\n-        // derived from `self.head()`, then we don't need to check; otherwise, we compute the\n-        // constructor of `self.head()` and check for constructor inclusion.\n+        // derived from `self.head()`, then we don't need to check; otherwise, we check for\n+        // constructor inclusion.\n         // Note that this shortcut is also necessary for correctness: a pattern should always be\n         // specializable with its own constructor, even in cases where we refuse to inspect values like\n         // opaque constants.\n-        if !is_my_head_ctor {\n-            let head_ctor = pat_constructor(cx.tcx, cx.param_env, self.head());\n-            if !ctor.is_covered_by(cx, &head_ctor, self.head().ty) {\n-                return None;\n-            }\n+        if !is_my_head_ctor && !ctor.is_covered_by(cx, self.head_ctor(cx), self.head().ty) {\n+            return None;\n         }\n         let new_fields = ctor_wild_subpatterns.replace_with_pattern_arguments(self.head());\n \n@@ -437,13 +443,19 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n \n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        Some(new_fields.push_on_patstack(&self.0[1..]))\n+        Some(new_fields.push_on_patstack(&self.pats[1..]))\n     }\n }\n \n impl<'p, 'tcx> Default for PatStack<'p, 'tcx> {\n     fn default() -> Self {\n-        PatStack(smallvec![])\n+        Self::from_vec(smallvec![])\n+    }\n+}\n+\n+impl<'p, 'tcx> PartialEq for PatStack<'p, 'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.pats == other.pats\n     }\n }\n \n@@ -452,7 +464,7 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n     where\n         T: IntoIterator<Item = &'p Pat<'tcx>>,\n     {\n-        PatStack(iter.into_iter().collect())\n+        Self::from_vec(iter.into_iter().collect())\n     }\n }\n \n@@ -570,6 +582,14 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         self.patterns.iter().map(|r| r.head())\n     }\n \n+    /// Iterate over the first constructor of each row\n+    fn head_ctors<'a>(\n+        &'a self,\n+        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n+    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'a> + Captures<'p> {\n+        self.patterns.iter().map(move |r| r.head_ctor(cx))\n+    }\n+\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n@@ -906,10 +926,7 @@ impl Slice {\n             _ => return smallvec![Slice(self)],\n         };\n \n-        let head_ctors = matrix\n-            .heads()\n-            .map(|p| pat_constructor(cx.tcx, cx.param_env, p))\n-            .filter(|c| !c.is_wildcard());\n+        let head_ctors = matrix.head_ctors(cx).filter(|c| !c.is_wildcard());\n \n         let mut max_prefix_len = self_prefix;\n         let mut max_suffix_len = self_suffix;\n@@ -1120,7 +1137,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// `hir_id` is `None` when we're evaluating the wildcard pattern. In that case we do not want\n     /// to lint for overlapping ranges.\n     fn split<'p>(\n-        self,\n+        &self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         pcx: PatCtxt<'tcx>,\n         matrix: &Matrix<'p, 'tcx>,\n@@ -1138,7 +1155,7 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             Slice(slice @ Slice { kind: VarLen(..), .. }) => slice.split(cx, matrix),\n             // Any other constructor can be used unchanged.\n-            _ => smallvec![self],\n+            _ => smallvec![self.clone()],\n         }\n     }\n \n@@ -1991,25 +2008,9 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn from_pat(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        pat: &Pat<'tcx>,\n-    ) -> Option<IntRange<'tcx>> {\n-        // This MUST be kept in sync with `pat_constructor`.\n-        match *pat.kind {\n-            PatKind::Constant { value } => Self::from_const(tcx, param_env, value, pat.span),\n-            PatKind::Range(PatRange { lo, hi, end }) => {\n-                let ty = lo.ty;\n-                Self::from_range(\n-                    tcx,\n-                    lo.eval_bits(tcx, param_env, lo.ty),\n-                    hi.eval_bits(tcx, param_env, hi.ty),\n-                    ty,\n-                    &end,\n-                    pat.span,\n-                )\n-            }\n+    fn from_ctor<'a>(ctor: &'a Constructor<'tcx>) -> Option<&'a IntRange<'tcx>> {\n+        match ctor {\n+            IntRange(range) => Some(range),\n             _ => None,\n         }\n     }\n@@ -2145,7 +2146,7 @@ impl<'tcx> IntRange<'tcx> {\n     /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n     /// merging operation depicted above.)\n     fn split<'p>(\n-        self,\n+        &self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         pcx: PatCtxt<'tcx>,\n         matrix: &Matrix<'p, 'tcx>,\n@@ -2176,15 +2177,13 @@ impl<'tcx> IntRange<'tcx> {\n         // Collect the span and range of all the intersecting ranges to lint on likely\n         // incorrect range patterns. (#63987)\n         let mut overlaps = vec![];\n+        let row_len = matrix.patterns.get(0).map(|r| r.len()).unwrap_or(0);\n         // `borders` is the set of borders between equivalence classes: each equivalence\n         // class lies between 2 borders.\n         let row_borders = matrix\n-            .patterns\n-            .iter()\n-            .flat_map(|row| {\n-                IntRange::from_pat(cx.tcx, cx.param_env, row.head()).map(|r| (r, row.len()))\n-            })\n-            .flat_map(|(range, row_len)| {\n+            .head_ctors(cx)\n+            .filter_map(|ctor| IntRange::from_ctor(ctor))\n+            .filter_map(|range| {\n                 let intersection = self.intersection(cx.tcx, &range);\n                 let should_lint = self.suspicious_intersection(&range);\n                 if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n@@ -2229,7 +2228,7 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     fn lint_overlapping_patterns(\n-        self,\n+        &self,\n         tcx: TyCtxt<'tcx>,\n         hir_id: Option<HirId>,\n         ty: Ty<'tcx>,\n@@ -2412,7 +2411,7 @@ crate fn is_useful<'p, 'tcx>(\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n-    let constructor = pat_constructor(cx.tcx, cx.param_env, v.head());\n+    let constructor = v.head_ctor(cx);\n     let ret = if !constructor.is_wildcard() {\n         debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n         constructor\n@@ -2435,11 +2434,8 @@ crate fn is_useful<'p, 'tcx>(\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n-        let used_ctors: Vec<Constructor<'_>> = matrix\n-            .heads()\n-            .map(|p| pat_constructor(cx.tcx, cx.param_env, p))\n-            .filter(|c| !c.is_wildcard())\n-            .collect();\n+        let used_ctors: Vec<Constructor<'_>> =\n+            matrix.head_ctors(cx).cloned().filter(|c| !c.is_wildcard()).collect();\n         debug!(\"is_useful_used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n@@ -2563,12 +2559,10 @@ fn is_useful_specialized<'p, 'tcx>(\n \n /// Determines the constructor that the given pattern can be specialized to.\n /// Returns `None` in case of a catch-all, which can't be specialized.\n-fn pat_constructor<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    pat: &Pat<'tcx>,\n+fn pat_constructor<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    pat: &'p Pat<'tcx>,\n ) -> Constructor<'tcx> {\n-    // This MUST be kept in sync with `IntRange::from_pat`.\n     match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n         PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n@@ -2577,7 +2571,7 @@ fn pat_constructor<'tcx>(\n             Variant(adt_def.variants[variant_index].def_id)\n         }\n         PatKind::Constant { value } => {\n-            if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n+            if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value, pat.span) {\n                 IntRange(int_range)\n             } else {\n                 match value.ty.kind() {\n@@ -2593,9 +2587,9 @@ fn pat_constructor<'tcx>(\n         PatKind::Range(PatRange { lo, hi, end }) => {\n             let ty = lo.ty;\n             if let Some(int_range) = IntRange::from_range(\n-                tcx,\n-                lo.eval_bits(tcx, param_env, lo.ty),\n-                hi.eval_bits(tcx, param_env, hi.ty),\n+                cx.tcx,\n+                lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n+                hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n                 ty,\n                 &end,\n                 pat.span,\n@@ -2608,7 +2602,7 @@ fn pat_constructor<'tcx>(\n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let array_len = match pat.ty.kind() {\n-                ty::Array(_, length) => Some(length.eval_usize(tcx, param_env)),\n+                ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env)),\n                 ty::Slice(_) => None,\n                 _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n             };"}]}