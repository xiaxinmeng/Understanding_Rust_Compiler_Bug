{"sha": "42344af71381b7f45de3570e322eaaee59d83229", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMzQ0YWY3MTM4MWI3ZjQ1ZGUzNTcwZTMyMmVhYWVlNTlkODMyMjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-06T01:04:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-02T00:43:54Z"}, "message": "Correct handling of if/match, and make explicit computation of\ncommon supertypes.\n\nThis was breaking with the change to regions because of the\n(now incorrect) assumpton that our inference code makes,\nwhich is that if a <: b succeeds, there is no need to compute\nthe LUB/GLB.", "tree": {"sha": "8e7394020b153333d63a3e2dc7abfaa54e3fccf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e7394020b153333d63a3e2dc7abfaa54e3fccf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42344af71381b7f45de3570e322eaaee59d83229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42344af71381b7f45de3570e322eaaee59d83229", "html_url": "https://github.com/rust-lang/rust/commit/42344af71381b7f45de3570e322eaaee59d83229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42344af71381b7f45de3570e322eaaee59d83229/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e6d5e152ee30c306afccfe9ede105acc6a0a278", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e6d5e152ee30c306afccfe9ede105acc6a0a278", "html_url": "https://github.com/rust-lang/rust/commit/9e6d5e152ee30c306afccfe9ede105acc6a0a278"}], "stats": {"total": 385, "additions": 265, "deletions": 120}, "files": [{"sha": "45867ae77e0807f61ad3fe4b786ef41ddca87844", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -30,8 +30,8 @@ pub fn check_match(fcx: @mut FnCtxt,\n                    arms: &[ast::arm]) {\n     let tcx = fcx.ccx.tcx;\n \n-    let pattern_ty = fcx.infcx().next_ty_var();\n-    check_expr_has_type(fcx, discrim, pattern_ty);\n+    let discrim_ty = fcx.infcx().next_ty_var();\n+    check_expr_has_type(fcx, discrim, discrim_ty);\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n@@ -41,13 +41,20 @@ pub fn check_match(fcx: @mut FnCtxt,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n         };\n \n-        for arm.pats.iter().advance |p| { check_pat(&pcx, *p, pattern_ty);}\n+        for arm.pats.iter().advance |p| { check_pat(&pcx, *p, discrim_ty);}\n     }\n \n+    // The result of the match is the common supertype of all the\n+    // arms. Start out the value as bottom, since it's the, well,\n+    // bottom the type lattice, and we'll be moving up the lattice as\n+    // we process each arm. (Note that any match with 0 arms is matching\n+    // on any empty type and is therefore unreachable; should the flow\n+    // of execution reach it, we will fail, so bottom is an appropriate\n+    // type in that case)\n+    let mut result_ty = ty::mk_bot();\n+\n     // Now typecheck the blocks.\n-    let mut result_ty = fcx.infcx().next_ty_var();\n-    let mut arm_non_bot = false;\n-    let mut saw_err = false;\n+    let mut saw_err = ty::type_is_error(discrim_ty);\n     for arms.iter().advance |arm| {\n         let mut guard_err = false;\n         let mut guard_bot = false;\n@@ -74,18 +81,22 @@ pub fn check_match(fcx: @mut FnCtxt,\n         else if guard_bot {\n             fcx.write_bot(arm.body.node.id);\n         }\n-        else if !ty::type_is_bot(bty) {\n-            arm_non_bot = true; // If the match *may* evaluate to a non-_|_\n-                                // expr, the whole thing is non-_|_\n-        }\n-        demand::suptype(fcx, arm.body.span, result_ty, bty);\n+\n+        result_ty =\n+            infer::common_supertype(\n+                fcx.infcx(),\n+                infer::MatchExpression(expr.span),\n+                true, // result_ty is \"expected\" here\n+                result_ty,\n+                bty);\n     }\n+\n     if saw_err {\n         result_ty = ty::mk_err();\n-    }\n-    else if !arm_non_bot {\n+    } else if ty::type_is_bot(discrim_ty) {\n         result_ty = ty::mk_bot();\n     }\n+\n     fcx.write_ty(expr.id, result_ty);\n }\n \n@@ -647,3 +658,4 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n \n #[deriving(Eq)]\n enum PointerKind { Managed, Send, Borrowed }\n+"}, {"sha": "98db885ba4227d0eb17989fa594f8fac1cc1d6a3", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 64, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -848,7 +848,7 @@ impl FnCtxt {\n \n     pub fn mk_subty(&self,\n                     a_is_expected: bool,\n-                    origin: infer::SubtypeOrigin,\n+                    origin: infer::TypeOrigin,\n                     sub: ty::t,\n                     sup: ty::t)\n                     -> Result<(), ty::type_err> {\n@@ -886,7 +886,7 @@ impl FnCtxt {\n \n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n-                   origin: infer::SubtypeOrigin,\n+                   origin: infer::TypeOrigin,\n                    sub: ty::t,\n                    sup: ty::t)\n                    -> Result<(), ty::type_err> {\n@@ -1436,27 +1436,42 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @mut FnCtxt,\n-                       thn: &ast::blk,\n-                       elsopt: Option<@ast::expr>,\n+                       cond_expr: @ast::expr,\n+                       then_blk: &ast::blk,\n+                       opt_else_expr: Option<@ast::expr>,\n                        id: ast::node_id,\n-                       _sp: span) {\n-        let if_t =\n-            match elsopt {\n-                Some(els) => {\n-                    let if_t = fcx.infcx().next_ty_var();\n-                    check_block(fcx, thn);\n-                    let thn_t = fcx.node_ty(thn.node.id);\n-                    demand::suptype(fcx, thn.span, if_t, thn_t);\n-                    check_expr_has_type(fcx, els, if_t);\n-                    if_t\n-                }\n-                None => {\n-                    check_block_no_value(fcx, thn);\n-                    ty::mk_nil()\n-                }\n-            };\n+                       sp: span,\n+                       expected: Option<ty::t>) {\n+        check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n+\n+        let branches_ty = match opt_else_expr {\n+            Some(else_expr) => {\n+                check_block_with_expected(fcx, then_blk, expected);\n+                let then_ty = fcx.node_ty(then_blk.node.id);\n+                check_expr_with_opt_hint(fcx, else_expr, expected);\n+                let else_ty = fcx.expr_ty(else_expr);\n+                infer::common_supertype(fcx.infcx(),\n+                                        infer::IfExpression(sp),\n+                                        true,\n+                                        then_ty,\n+                                        else_ty)\n+            }\n+            None => {\n+                check_block_no_value(fcx, then_blk);\n+                ty::mk_nil()\n+            }\n+        };\n \n-        fcx.write_ty(id, if_t);\n+        let cond_ty = fcx.expr_ty(cond_expr);\n+        let if_ty = if ty::type_is_error(cond_ty) {\n+            ty::mk_err()\n+        } else if ty::type_is_bot(cond_ty) {\n+            ty::mk_bot()\n+        } else {\n+            branches_ty\n+        };\n+\n+        fcx.write_ty(id, if_ty);\n     }\n \n     fn lookup_op_method(fcx: @mut FnCtxt,\n@@ -2501,25 +2516,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::expr_if(cond, ref thn, elsopt) => {\n-        check_expr_has_type(fcx, cond, ty::mk_bool());\n-        check_then_else(fcx, thn, elsopt, id, expr.span);\n-        let cond_ty = fcx.expr_ty(cond);\n-        let then_ty = fcx.node_ty(thn.node.id);\n-        let else_is_bot = elsopt.map_default(false, |els| {\n-              ty::type_is_bot(fcx.expr_ty(*els))});\n-        if ty::type_is_error(cond_ty) || ty::type_is_error(then_ty) {\n-            fcx.write_error(id);\n-        }\n-        else if elsopt.map_default(false, |els| {\n-            ty::type_is_error(fcx.expr_ty(*els)) }) {\n-            fcx.write_error(id);\n-        }\n-        else if ty::type_is_bot(cond_ty) ||\n-            (ty::type_is_bot(then_ty) && else_is_bot) {\n-            fcx.write_bot(id);\n-        }\n-          // Other cases were handled by check_then_else\n+      ast::expr_if(cond, ref then_blk, opt_else_expr) => {\n+        check_then_else(fcx, cond, then_blk, opt_else_expr,\n+                        id, expr.span, expected);\n       }\n       ast::expr_while(cond, ref body) => {\n         check_expr_has_type(fcx, cond, ty::mk_bool());\n@@ -2547,30 +2546,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_match(discrim, ref arms) => {\n         _match::check_match(fcx, expr, discrim, *arms);\n-        let discrim_ty = fcx.expr_ty(discrim);\n-        let arm_tys = arms.map(|a| fcx.node_ty(a.body.node.id));\n-        if ty::type_is_error(discrim_ty) ||\n-            arm_tys.iter().any_(|t| ty::type_is_error(*t)) {\n-            fcx.write_error(id);\n-        }\n-        // keep in mind that `all` returns true in the empty vec case,\n-        // which is what we want\n-        else if ty::type_is_bot(discrim_ty) ||\n-            arm_tys.iter().all(|t| ty::type_is_bot(*t)) {\n-            fcx.write_bot(id);\n-        }\n-        else {\n-            // Find the first non-_|_ arm.\n-            // We know there's at least one because we already checked\n-            // for n=0 as well as all arms being _|_ in the previous\n-            // `if`.\n-            for arm_tys.iter().advance |arm_ty| {\n-                if !ty::type_is_bot(*arm_ty) {\n-                    fcx.write_ty(id, *arm_ty);\n-                    break;\n-                }\n-            }\n-        }\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,"}, {"sha": "f03f01732291ffc19b33c544f08783cfc28f957e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -65,7 +65,7 @@ use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{InferCtxtMethods};\n use middle::typeck::infer::{InferCtxt, cres, ures};\n-use middle::typeck::infer::{SubtypeOrigin, SubtypeTrace};\n+use middle::typeck::infer::{TypeOrigin, TypeTrace};\n use util::common::indent;\n \n use std::result::{iter_vec2, map_vec2};\n@@ -80,7 +80,7 @@ pub trait Combine {\n     fn infcx(&self) -> @mut InferCtxt;\n     fn tag(&self) -> ~str;\n     fn a_is_expected(&self) -> bool;\n-    fn trace(&self) -> SubtypeTrace;\n+    fn trace(&self) -> TypeTrace;\n \n     fn sub(&self) -> Sub;\n     fn lub(&self) -> Lub;\n@@ -122,7 +122,7 @@ pub trait Combine {\n pub struct CombineFields {\n     infcx: @mut InferCtxt,\n     a_is_expected: bool,\n-    trace: SubtypeTrace,\n+    trace: TypeTrace,\n }\n \n pub fn expected_found<C:Combine,T>("}, {"sha": "7217f2979474606414fc159354de6943a383b61f", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -22,7 +22,7 @@ rise to a patricular error.\n The basis of the system are the \"origin\" types. An \"origin\" is the\n reason that a constraint or inference variable arose. There are\n different \"origin\" enums for different kinds of constraints/variables\n-(e.g., `SubtypeOrigin`, `RegionVariableOrigin`). An origin always has\n+(e.g., `TypeOrigin`, `RegionVariableOrigin`). An origin always has\n a span, but also more information so that we can generate a meaningful\n error message.\n \n@@ -40,7 +40,7 @@ store and later report what gave rise to the conflicting constraints.\n # Subtype Trace\n \n Determing whether `T1 <: T2` often involves a number of subtypes and\n-subconstraints along the way. A \"SubtypeTrace\" is an extended version\n+subconstraints along the way. A \"TypeTrace\" is an extended version\n of an origin that traces the types and other values that were being\n compared. It is not necessarily comprehensive (in fact, at the time of\n this writing it only tracks the root values being compared) but I'd\n@@ -64,8 +64,8 @@ use middle::ty;\n use middle::ty::Region;\n use middle::typeck::infer;\n use middle::typeck::infer::InferCtxt;\n-use middle::typeck::infer::SubtypeTrace;\n-use middle::typeck::infer::SubtypeOrigin;\n+use middle::typeck::infer::TypeTrace;\n+use middle::typeck::infer::TypeOrigin;\n use middle::typeck::infer::SubregionOrigin;\n use middle::typeck::infer::RegionVariableOrigin;\n use middle::typeck::infer::Types;\n@@ -108,8 +108,8 @@ impl InferCtxt {\n         }\n     }\n \n-    fn report_and_explain_type_error(@mut self,\n-                                     trace: SubtypeTrace,\n+    pub fn report_and_explain_type_error(@mut self,\n+                                     trace: TypeTrace,\n                                      terr: &ty::type_err) {\n         let tcx = self.tcx;\n \n@@ -125,7 +125,9 @@ impl InferCtxt {\n             infer::MethodCompatCheck(_) => \"method not compatible with trait\",\n             infer::ExprAssignable(_) => \"mismatched types\",\n             infer::RelateTraitRefs(_) => \"mismatched traits\",\n-            infer::RelateSelfType(_) => \"mismatched types\"\n+            infer::RelateSelfType(_) => \"mismatched types\",\n+            infer::MatchExpression(_) => \"match arms have incompatible types\",\n+            infer::IfExpression(_) => \"if and else have incompatible types\",\n         };\n \n         self.tcx.sess.span_err(\n@@ -179,7 +181,7 @@ impl InferCtxt {\n                                sup: Region) {\n         match origin {\n             infer::Subtype(trace) => {\n-                let terr = ty::terr_regions_does_not_outlive(sub, sup);\n+                let terr = ty::terr_regions_does_not_outlive(sup, sub);\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n             infer::Reborrow(span) => {"}, {"sha": "fefbf2336c29fe254cbd9b3401cccec1a071de00", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -18,7 +18,7 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n-use middle::typeck::infer::{SubtypeTrace, Subtype};\n+use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n use syntax::ast;\n@@ -38,7 +38,7 @@ impl Combine for Glb {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn trace(&self) -> SubtypeTrace { self.trace }\n+    fn trace(&self) -> TypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }"}, {"sha": "efb1dc200b521a9045d1111c00abfd9b3e378aa4", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -19,7 +19,7 @@ use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n-use middle::typeck::infer::{SubtypeTrace, Subtype};\n+use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::isr_alist;\n use util::common::indent;\n use util::ppaux::mt_to_str;\n@@ -45,7 +45,7 @@ impl Combine for Lub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn trace(&self) -> SubtypeTrace { self.trace }\n+    fn trace(&self) -> TypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }"}, {"sha": "f8563b4eb3d267f8227375e82c63cee5fe54ced8", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -260,6 +260,7 @@ use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n use middle::typeck::infer::region_inference::{RegionVarBindings};\n use middle::typeck::infer::resolve::{resolver};\n use middle::typeck::infer::sub::Sub;\n+use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::isr_alist;\n@@ -324,7 +325,7 @@ pub struct InferCtxt {\n /// Why did we require that the two types be related?\n ///\n /// See `error_reporting.rs` for more details\n-pub enum SubtypeOrigin {\n+pub enum TypeOrigin {\n     // Not yet categorized in a better way\n     Misc(span),\n \n@@ -339,6 +340,12 @@ pub enum SubtypeOrigin {\n \n     // Relating trait refs when resolving vtables\n     RelateSelfType(span),\n+\n+    // Computing common supertype in a match expression\n+    MatchExpression(span),\n+\n+    // Computing common supertype in an if expression\n+    IfExpression(span),\n }\n \n /// See `error_reporting.rs` for more details\n@@ -351,8 +358,8 @@ pub enum ValuePairs {\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n-pub struct SubtypeTrace {\n-    origin: SubtypeOrigin,\n+pub struct TypeTrace {\n+    origin: TypeOrigin,\n     values: ValuePairs,\n }\n \n@@ -361,7 +368,7 @@ pub struct SubtypeTrace {\n /// See `error_reporting.rs` for more details\n pub enum SubregionOrigin {\n     // Arose from a subtyping relation\n-    Subtype(SubtypeTrace),\n+    Subtype(TypeTrace),\n \n     // Invocation of closure must be within its lifetime\n     InvokeClosure(span),\n@@ -425,7 +432,7 @@ pub enum RegionVariableOrigin {\n     Autoref(span),\n \n     // Regions created as part of an automatic coercion\n-    Coercion(SubtypeTrace),\n+    Coercion(TypeTrace),\n \n     // Region variables created for bound regions\n     // in a function or method that is called\n@@ -487,16 +494,47 @@ pub fn new_infer_ctxt(tcx: ty::ctxt) -> @mut InferCtxt {\n     }\n }\n \n+pub fn common_supertype(cx: @mut InferCtxt,\n+                        origin: TypeOrigin,\n+                        a_is_expected: bool,\n+                        a: ty::t,\n+                        b: ty::t)\n+                        -> ty::t {\n+    /*!\n+     * Computes the least upper-bound of `a` and `b`. If this is\n+     * not possible, reports an error and returns ty::err.\n+     */\n+\n+    debug!(\"common_supertype(%s, %s)\", a.inf_str(cx), b.inf_str(cx));\n+\n+    let trace = TypeTrace {\n+        origin: origin,\n+        values: Types(expected_found(a_is_expected, a, b))\n+    };\n+\n+    let result = do cx.commit {\n+        cx.lub(a_is_expected, trace).tys(a, b)\n+    };\n+\n+    match result {\n+        Ok(t) => t,\n+        Err(ref err) => {\n+            cx.report_and_explain_type_error(trace, err);\n+            ty::mk_err()\n+        }\n+    }\n+}\n+\n pub fn mk_subty(cx: @mut InferCtxt,\n                 a_is_expected: bool,\n-                origin: SubtypeOrigin,\n+                origin: TypeOrigin,\n                 a: ty::t,\n                 b: ty::t)\n              -> ures {\n     debug!(\"mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            let trace = SubtypeTrace {\n+            let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n@@ -509,7 +547,7 @@ pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            let trace = SubtypeTrace {\n+            let trace = TypeTrace {\n                 origin: Misc(codemap::dummy_sp()),\n                 values: Types(expected_found(true, a, b))\n             };\n@@ -531,14 +569,14 @@ pub fn mk_subr(cx: @mut InferCtxt,\n \n pub fn mk_eqty(cx: @mut InferCtxt,\n                a_is_expected: bool,\n-               origin: SubtypeOrigin,\n+               origin: TypeOrigin,\n                a: ty::t,\n                b: ty::t)\n             -> ures {\n     debug!(\"mk_eqty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            let trace = SubtypeTrace {\n+            let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n@@ -550,7 +588,7 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n \n pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n                          a_is_expected: bool,\n-                         origin: SubtypeOrigin,\n+                         origin: TypeOrigin,\n                          a: @ty::TraitRef,\n                          b: @ty::TraitRef)\n     -> ures\n@@ -559,7 +597,7 @@ pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n            a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            let trace = SubtypeTrace {\n+            let trace = TypeTrace {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a, b))\n             };\n@@ -581,14 +619,14 @@ fn expected_found<T>(a_is_expected: bool,\n \n pub fn mk_coercety(cx: @mut InferCtxt,\n                    a_is_expected: bool,\n-                   origin: SubtypeOrigin,\n+                   origin: TypeOrigin,\n                    a: ty::t,\n                    b: ty::t)\n                 -> CoerceResult {\n     debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            let trace = SubtypeTrace {\n+            let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n@@ -601,7 +639,7 @@ pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            let trace = SubtypeTrace {\n+            let trace = TypeTrace {\n                 origin: Misc(codemap::dummy_sp()),\n                 values: Types(expected_found(true, a, b))\n             };\n@@ -690,17 +728,21 @@ struct Snapshot {\n impl InferCtxt {\n     pub fn combine_fields(@mut self,\n                           a_is_expected: bool,\n-                          trace: SubtypeTrace)\n+                          trace: TypeTrace)\n                           -> CombineFields {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn sub(@mut self, a_is_expected: bool, trace: SubtypeTrace) -> Sub {\n+    pub fn sub(@mut self, a_is_expected: bool, trace: TypeTrace) -> Sub {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n+    pub fn lub(@mut self, a_is_expected: bool, trace: TypeTrace) -> Lub {\n+        Lub(self.combine_fields(a_is_expected, trace))\n+    }\n+\n     pub fn in_snapshot(&self) -> bool {\n         self.region_vars.in_snapshot()\n     }\n@@ -946,7 +988,7 @@ impl InferCtxt {\n     }\n \n     pub fn replace_bound_regions_with_fresh_regions(&mut self,\n-                                                    trace: SubtypeTrace,\n+                                                    trace: TypeTrace,\n                                                     fsig: &ty::FnSig)\n                                                     -> (ty::FnSig, isr_alist) {\n         let(isr, _, fn_sig) =\n@@ -972,38 +1014,42 @@ pub fn fold_regions_in_sig(\n     }\n }\n \n-impl SubtypeTrace {\n+impl TypeTrace {\n     pub fn span(&self) -> span {\n         self.origin.span()\n     }\n }\n \n-impl Repr for SubtypeTrace {\n+impl Repr for TypeTrace {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"SubtypeTrace(%s)\", self.origin.repr(tcx))\n+        fmt!(\"TypeTrace(%s)\", self.origin.repr(tcx))\n     }\n }\n \n-impl SubtypeOrigin {\n+impl TypeOrigin {\n     pub fn span(&self) -> span {\n         match *self {\n             MethodCompatCheck(span) => span,\n             ExprAssignable(expr) => expr.span,\n             Misc(span) => span,\n             RelateTraitRefs(span) => span,\n             RelateSelfType(span) => span,\n+            MatchExpression(span) => span,\n+            IfExpression(span) => span,\n         }\n     }\n }\n \n-impl Repr for SubtypeOrigin {\n+impl Repr for TypeOrigin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             MethodCompatCheck(a) => fmt!(\"MethodCompatCheck(%s)\", a.repr(tcx)),\n             ExprAssignable(a) => fmt!(\"ExprAssignable(%s)\", a.repr(tcx)),\n             Misc(a) => fmt!(\"Misc(%s)\", a.repr(tcx)),\n             RelateTraitRefs(a) => fmt!(\"RelateTraitRefs(%s)\", a.repr(tcx)),\n             RelateSelfType(a) => fmt!(\"RelateSelfType(%s)\", a.repr(tcx)),\n+            MatchExpression(a) => fmt!(\"MatchExpression(%s)\", a.repr(tcx)),\n+            IfExpression(a) => fmt!(\"IfExpression(%s)\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "c674cbc0f63cd1e8de0b5a7c16124b6d9333684a", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -1528,6 +1528,8 @@ impl RegionVarBindings {\n                 loop;\n             }\n \n+            debug!(\"ConcreteFailure: !(sub <= sup): sub=%?, sup=%?\",\n+                   sub, sup);\n             errors.push(ConcreteFailure(origin, sub, sup));\n         }\n     }"}, {"sha": "72178500b54ed2ac41ff76e43a16963fb7f7d302", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -20,7 +20,7 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::{SubtypeTrace, Subtype};\n+use middle::typeck::infer::{TypeTrace, Subtype};\n use util::common::{indent, indenter};\n use util::ppaux::bound_region_to_str;\n \n@@ -37,7 +37,7 @@ impl Combine for Sub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn trace(&self) -> SubtypeTrace { self.trace }\n+    fn trace(&self) -> TypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }"}, {"sha": "1c6dd0ef9f65717d6c4b62891fa839c01eb89b0b", "filename": "src/test/compile-fail/if-branch-types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:mismatched types\n-\n-fn main() { let x = if true { 10i } else { 10u }; }\n+fn main() {\n+    let x = if true { 10i } else { 10u };\n+    //~^ ERROR if and else have incompatible types: expected `int` but found `uint`\n+}"}, {"sha": "358c61921470fcb917925ca81451a13b31d35073", "filename": "src/test/compile-fail/lub-if.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly consider the type of `match` to be the LUB\n+// of the various arms, particularly in the case where regions are\n+// involved.\n+\n+pub fn opt_str0<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    if maybestr.is_none() {\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = *maybestr.get_ref();\n+        s\n+    }\n+}\n+\n+pub fn opt_str1<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    if maybestr.is_some() {\n+        let s: &'a str = *maybestr.get_ref();\n+        s\n+    } else {\n+        \"(none)\"\n+    }\n+}\n+\n+pub fn opt_str2<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+    if maybestr.is_none() { //~ ERROR mismatched types\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = *maybestr.get_ref();\n+        s\n+    }\n+}\n+\n+pub fn opt_str3<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+    if maybestr.is_some() {  //~ ERROR mismatched types\n+        let s: &'a str = *maybestr.get_ref();\n+        s\n+    } else {\n+        \"(none)\"\n+    }\n+}\n+\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "2a61b72997d1f9cc855faceb3f871e1fed152c3f", "filename": "src/test/compile-fail/lub-match.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/42344af71381b7f45de3570e322eaaee59d83229/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42344af71381b7f45de3570e322eaaee59d83229/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=42344af71381b7f45de3570e322eaaee59d83229", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly consider the type of `match` to be the LUB\n+// of the various arms, particularly in the case where regions are\n+// involved.\n+\n+pub fn opt_str0<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    match *maybestr {\n+        Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+        None => \"(none)\",\n+    }\n+}\n+\n+pub fn opt_str1<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    match *maybestr {\n+        None => \"(none)\",\n+        Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+    }\n+}\n+\n+pub fn opt_str2<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+    match *maybestr { //~ ERROR mismatched types\n+        None => \"(none)\",\n+        Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+    }\n+}\n+\n+pub fn opt_str3<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+    match *maybestr { //~ ERROR mismatched types\n+        Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+        None => \"(none)\",\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}]}