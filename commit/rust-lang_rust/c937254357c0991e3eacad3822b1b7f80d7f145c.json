{"sha": "c937254357c0991e3eacad3822b1b7f80d7f145c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MzcyNTQzNTdjMDk5MWUzZWFjYWQzODIyYjFiN2Y4MGQ3ZjE0NWM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-15T19:57:33Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-02-21T19:00:47Z"}, "message": "Start the port of the reference to mdBook\n\nThis only really moves the files, there's a lot more work coming\nin the next commits.\n\nPart of #39588.", "tree": {"sha": "a81b1ac3a85043d16b66b856dd1d2385c2fd3c92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a81b1ac3a85043d16b66b856dd1d2385c2fd3c92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c937254357c0991e3eacad3822b1b7f80d7f145c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c937254357c0991e3eacad3822b1b7f80d7f145c", "html_url": "https://github.com/rust-lang/rust/commit/c937254357c0991e3eacad3822b1b7f80d7f145c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c937254357c0991e3eacad3822b1b7f80d7f145c/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a1ce4020c480e455ec902e3616843a3dd5fe489", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a1ce4020c480e455ec902e3616843a3dd5fe489", "html_url": "https://github.com/rust-lang/rust/commit/8a1ce4020c480e455ec902e3616843a3dd5fe489"}], "stats": {"total": 4094, "additions": 4090, "deletions": 4}, "files": [{"sha": "f4a667141665ba1c99e2db836bccc2342b6a85cb", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -115,10 +115,6 @@ pub fn standalone(build: &Build, target: &str) {\n            .arg(\"-o\").arg(&out)\n            .arg(&path);\n \n-        if filename == \"reference.md\" {\n-           cmd.arg(\"--html-in-header\").arg(&full_toc);\n-        }\n-\n         if filename == \"not_found.md\" {\n             cmd.arg(\"--markdown-no-toc\")\n                .arg(\"--markdown-css\")"}, {"sha": "36738b81c189e4c1dd37be066f039e920b916d6a", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -568,6 +568,15 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          })\n          .default(build.config.docs)\n          .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n+    rules.doc(\"doc-reference\", \"src/doc/reference\")\n+         .dep(move |s| {\n+             s.name(\"tool-rustbook\")\n+              .host(&build.config.build)\n+              .target(&build.config.build)\n+              .stage(0)\n+         })\n+         .default(build.config.docs)\n+         .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n     rules.doc(\"doc-standalone\", \"src/doc\")\n          .dep(move |s| {\n              s.name(\"rustc\")"}, {"sha": "7585238efedfc33acdd9494b0269951aaf3909ec", "filename": "src/doc/reference/.gitignore", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2F.gitignore?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1 @@\n+book"}, {"sha": "a07e195a7184fefa83fecbddb79c39e1f15b99e6", "filename": "src/doc/reference/src/SUMMARY.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2FSUMMARY.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,58 @@\n+# The Rust Reference\n+\n+[Introduction](introduction.md)\n+\n+- [Notation](notation.md)\n+    - [Unicode productions](unicode-productions.md)\n+    - [String table productions](string-table-productions.md)\n+\n+- [Lexical structure](lexical-structure.md)\n+    - [Input format](input-format.md)\n+    - [Identifiers](identifiers.md)\n+    - [Comments](comments.md)\n+    - [Whitespace](whitespace.md)\n+    - [Tokens](tokens.md)\n+    - [Paths](paths.md)\n+\n+- [Macros](macros.md)\n+    - [Macros By Example](macros-by-example.md)\n+    - [Procedrual Macros](procedural-macros.md)\n+\n+- [Crates and source files](crates-and-source-files.md)\n+\n+- [Items and attributes](items-and-attributes.md)\n+    - [Items](items.md)\n+    - [Visibility and Privacy](visibility-and-privacy.md)\n+    - [Attributes](attributes.md)\n+\n+- [Statements and expressions](statements-and-expressions.md)\n+    - [Statements](statements.md)\n+    - [Expressions](expressions.md)\n+\n+- [Type system](type-system.md)\n+    - [Types](types.md)\n+    - [Subtyping](subtyping.md)\n+    - [Type coercions](type-coercions.md)\n+\n+- [Special traits](special-traits.md)\n+    - [The Copy trait](the-copy-trait.md)\n+    - [The Sized trait](the-sized-trait.md)\n+    - [The Drop trait](the-drop-trait.md)\n+    - [The Deref trait](the-deref-trait.md)\n+    - [The Send trait](the-send-trait.md)\n+    - [The Sync trait](the-sync-trait.md)\n+\n+- [Memory model](memory-model.md)\n+    - [Memory allocation and lifetime](memory-allocation-and-lifetime.md)\n+    - [Memory ownership](memory-ownership.md)\n+    - [Variables](variables.md)\n+\n+- [Linkage](linkage.md)\n+\n+- [Unsafety](unsafety.md)\n+    - [Unsafe functions](unsafe-functions.md)\n+    - [Unsafe blocks](unsafe-blocks.md)\n+    - [Behavior considered undefined](behavior-considered-undefined.md)\n+    - [Behavior not considered unsafe](behavior-not-considered-unsafe.md)\n+\n+[Appendix: Influences](influences.md)"}, {"sha": "4a839676ed340f568a64dfd584594d65a28c59d7", "filename": "src/doc/reference/src/attributes.md", "status": "added", "additions": 629, "deletions": 0, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fattributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fattributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fattributes.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,629 @@\n+# Attributes\n+\n+Any item declaration may have an _attribute_ applied to it. Attributes in Rust\n+are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334\n+(C#). An attribute is a general, free-form metadatum that is interpreted\n+according to name, convention, and language and compiler version. Attributes\n+may appear as any of:\n+\n+* A single identifier, the attribute name\n+* An identifier followed by the equals sign '=' and a literal, providing a\n+  key/value pair\n+* An identifier followed by a parenthesized list of sub-attribute arguments\n+\n+Attributes with a bang (\"!\") after the hash (\"#\") apply to the item that the\n+attribute is declared within. Attributes that do not have a bang after the hash\n+apply to the item that follows the attribute.\n+\n+An example of attributes:\n+\n+```{.rust}\n+// General metadata applied to the enclosing module or crate.\n+#![crate_type = \"lib\"]\n+\n+// A function marked as a unit test\n+#[test]\n+fn test_foo() {\n+    /* ... */\n+}\n+\n+// A conditionally-compiled module\n+#[cfg(target_os=\"linux\")]\n+mod bar {\n+    /* ... */\n+}\n+\n+// A lint attribute used to suppress a warning/error\n+#[allow(non_camel_case_types)]\n+type int8_t = i8;\n+```\n+\n+> **Note:** At some point in the future, the compiler will distinguish between\n+> language-reserved and user-available attributes. Until then, there is\n+> effectively no difference between an attribute handled by a loadable syntax\n+> extension and the compiler.\n+\n+## Crate-only attributes\n+\n+- `crate_name` - specify the crate's crate name.\n+- `crate_type` - see [linkage](#linkage).\n+- `feature` - see [compiler features](#compiler-features).\n+- `no_builtins` - disable optimizing certain code patterns to invocations of\n+                  library functions that are assumed to exist\n+- `no_main` - disable emitting the `main` symbol. Useful when some other\n+   object being linked to defines `main`.\n+- `no_start` - disable linking to the `native` crate, which specifies the\n+  \"start\" language item.\n+- `no_std` - disable linking to the `std` crate.\n+- `plugin` - load a list of named crates as compiler plugins, e.g.\n+             `#![plugin(foo, bar)]`. Optional arguments for each plugin,\n+             i.e. `#![plugin(foo(... args ...))]`, are provided to the plugin's\n+             registrar function.  The `plugin` feature gate is required to use\n+             this attribute.\n+- `recursion_limit` - Sets the maximum depth for potentially\n+                      infinitely-recursive compile-time operations like\n+                      auto-dereference or macro expansion. The default is\n+                      `#![recursion_limit=\"64\"]`.\n+\n+### Module-only attributes\n+\n+- `no_implicit_prelude` - disable injecting `use std::prelude::*` in this\n+  module.\n+- `path` - specifies the file to load the module from. `#[path=\"foo.rs\"] mod\n+  bar;` is equivalent to `mod bar { /* contents of foo.rs */ }`. The path is\n+  taken relative to the directory that the current module is in.\n+\n+## Function-only attributes\n+\n+- `main` - indicates that this function should be passed to the entry point,\n+  rather than the function in the crate root named `main`.\n+- `plugin_registrar` - mark this function as the registration point for\n+  [compiler plugins][plugin], such as loadable syntax extensions.\n+- `start` - indicates that this function should be used as the entry point,\n+  overriding the \"start\" language item. See the \"start\" [language\n+  item](#language-items) for more details.\n+- `test` - indicates that this function is a test function, to only be compiled\n+  in case of `--test`.\n+- `should_panic` - indicates that this test function should panic, inverting the success condition.\n+- `cold` - The function is unlikely to be executed, so optimize it (and calls\n+  to it) differently.\n+- `naked` - The function utilizes a custom ABI or custom inline ASM that requires\n+  epilogue and prologue to be skipped.\n+\n+## Static-only attributes\n+\n+- `thread_local` - on a `static mut`, this signals that the value of this\n+  static may change depending on the current thread. The exact consequences of\n+  this are implementation-defined.\n+\n+## FFI attributes\n+\n+On an `extern` block, the following attributes are interpreted:\n+\n+- `link_args` - specify arguments to the linker, rather than just the library\n+  name and type. This is feature gated and the exact behavior is\n+  implementation-defined (due to variety of linker invocation syntax).\n+- `link` - indicate that a native library should be linked to for the\n+  declarations in this block to be linked correctly. `link` supports an optional\n+  `kind` key with three possible values: `dylib`, `static`, and `framework`. See\n+  [external blocks](#external-blocks) for more about external blocks. Two\n+  examples: `#[link(name = \"readline\")]` and\n+  `#[link(name = \"CoreFoundation\", kind = \"framework\")]`.\n+- `linked_from` - indicates what native library this block of FFI items is\n+  coming from. This attribute is of the form `#[linked_from = \"foo\"]` where\n+  `foo` is the name of a library in either `#[link]` or a `-l` flag. This\n+  attribute is currently required to export symbols from a Rust dynamic library\n+  on Windows, and it is feature gated behind the `linked_from` feature.\n+\n+On declarations inside an `extern` block, the following attributes are\n+interpreted:\n+\n+- `link_name` - the name of the symbol that this function or static should be\n+  imported as.\n+- `linkage` - on a static, this specifies the [linkage\n+  type](http://llvm.org/docs/LangRef.html#linkage-types).\n+\n+On `enum`s:\n+\n+- `repr` - on C-like enums, this sets the underlying type used for\n+  representation. Takes one argument, which is the primitive\n+  type this enum should be represented for, or `C`, which specifies that it\n+  should be the default `enum` size of the C ABI for that platform. Note that\n+  enum representation in C is undefined, and this may be incorrect when the C\n+  code is compiled with certain flags.\n+\n+On `struct`s:\n+\n+- `repr` - specifies the representation to use for this struct. Takes a list\n+  of options. The currently accepted ones are `C` and `packed`, which may be\n+  combined. `C` will use a C ABI compatible struct layout, and `packed` will\n+  remove any padding between fields (note that this is very fragile and may\n+  break platforms which require aligned access).\n+\n+## Macro-related attributes\n+\n+- `macro_use` on a `mod` \u2014 macros defined in this module will be visible in the\n+  module's parent, after this module has been included.\n+\n+- `macro_use` on an `extern crate` \u2014 load macros from this crate.  An optional\n+  list of names `#[macro_use(foo, bar)]` restricts the import to just those\n+  macros named.  The `extern crate` must appear at the crate root, not inside\n+  `mod`, which ensures proper function of the [`$crate` macro\n+  variable](book/macros.html#The%20variable%20%24crate).\n+\n+- `macro_reexport` on an `extern crate` \u2014 re-export the named macros.\n+\n+- `macro_export` - export a macro for cross-crate usage.\n+\n+- `no_link` on an `extern crate` \u2014 even if we load this crate for macros, don't\n+  link it into the output.\n+\n+See the [macros section of the\n+book](book/macros.html#Scoping%20and%20macro%20import%2Fexport) for more information on\n+macro scope.\n+\n+## Miscellaneous attributes\n+\n+- `deprecated` - mark the item as deprecated; the full attribute is \n+  `#[deprecated(since = \"crate version\", note = \"...\")`, where both arguments \n+  are optional.\n+- `export_name` - on statics and functions, this determines the name of the\n+  exported symbol.\n+- `link_section` - on statics and functions, this specifies the section of the\n+  object file that this item's contents will be placed into.\n+- `no_mangle` - on any item, do not apply the standard name mangling. Set the\n+  symbol for this item to its identifier.\n+- `simd` - on certain tuple structs, derive the arithmetic operators, which\n+  lower to the target's SIMD instructions, if any; the `simd` feature gate\n+  is necessary to use this attribute.\n+- `unsafe_destructor_blind_to_params` - on `Drop::drop` method, asserts that the\n+  destructor code (and all potential specializations of that code) will\n+  never attempt to read from nor write to any references with lifetimes\n+  that come in via generic parameters. This is a constraint we cannot\n+  currently express via the type system, and therefore we rely on the\n+  programmer to assert that it holds. Adding this to a Drop impl causes\n+  the associated destructor to be considered \"uninteresting\" by the\n+  Drop-Check rule, and thus it can help sidestep data ordering\n+  constraints that would otherwise be introduced by the Drop-Check\n+  rule. Such sidestepping of the constraints, if done incorrectly, can\n+  lead to undefined behavior (in the form of reading or writing to data\n+  outside of its dynamic extent), and thus this attribute has the word\n+  \"unsafe\" in its name. To use this, the\n+  `unsafe_destructor_blind_to_params` feature gate must be enabled.\n+- `doc` - Doc comments such as `/// foo` are equivalent to `#[doc = \"foo\"]`.\n+- `rustc_on_unimplemented` - Write a custom note to be shown along with the error\n+   when the trait is found to be unimplemented on a type.\n+   You may use format arguments like `{T}`, `{A}` to correspond to the\n+   types at the point of use corresponding to the type parameters of the\n+   trait of the same name. `{Self}` will be replaced with the type that is supposed\n+   to implement the trait but doesn't. To use this, the `on_unimplemented` feature gate\n+   must be enabled.\n+- `must_use` - on structs and enums, will warn if a value of this type isn't used or\n+   assigned to a variable. You may also include an optional message by using\n+   `#[must_use = \"message\"]` which will be given alongside the warning.\n+\n+### Conditional compilation\n+\n+Sometimes one wants to have different compiler outputs from the same code,\n+depending on build target, such as targeted operating system, or to enable\n+release builds.\n+\n+Configuration options are boolean (on or off) and are named either with a\n+single identifier (e.g. `foo`) or an identifier and a string (e.g. `foo = \"bar\"`;\n+the quotes are required and spaces around the `=` are unimportant). Note that\n+similarly-named options, such as `foo`, `foo=\"bar\"` and `foo=\"baz\"` may each be set\n+or unset independently.\n+\n+Configuration options are either provided by the compiler or passed in on the\n+command line using `--cfg` (e.g. `rustc main.rs --cfg foo --cfg 'bar=\"baz\"'`).\n+Rust code then checks for their presence using the `#[cfg(...)]` attribute:\n+\n+```\n+// The function is only included in the build when compiling for OSX\n+#[cfg(target_os = \"macos\")]\n+fn macos_only() {\n+  // ...\n+}\n+\n+// This function is only included when either foo or bar is defined\n+#[cfg(any(foo, bar))]\n+fn needs_foo_or_bar() {\n+  // ...\n+}\n+\n+// This function is only included when compiling for a unixish OS with a 32-bit\n+// architecture\n+#[cfg(all(unix, target_pointer_width = \"32\"))]\n+fn on_32bit_unix() {\n+  // ...\n+}\n+\n+// This function is only included when foo is not defined\n+#[cfg(not(foo))]\n+fn needs_not_foo() {\n+  // ...\n+}\n+```\n+\n+This illustrates some conditional compilation can be achieved using the\n+`#[cfg(...)]` attribute. `any`, `all` and `not` can be used to assemble\n+arbitrarily complex configurations through nesting.\n+\n+The following configurations must be defined by the implementation:\n+\n+* `target_arch = \"...\"` - Target CPU architecture, such as `\"x86\"`,\n+  `\"x86_64\"` `\"mips\"`, `\"powerpc\"`, `\"powerpc64\"`, `\"arm\"`, or\n+  `\"aarch64\"`. This value is closely related to the first element of\n+  the platform target triple, though it is not identical.\n+* `target_os = \"...\"` - Operating system of the target, examples\n+  include `\"windows\"`, `\"macos\"`, `\"ios\"`, `\"linux\"`, `\"android\"`,\n+  `\"freebsd\"`, `\"dragonfly\"`, `\"bitrig\"` , `\"openbsd\"` or\n+  `\"netbsd\"`. This value is closely related to the second and third\n+  element of the platform target triple, though it is not identical.\n+* `target_family = \"...\"` - Operating system family of the target, e. g.\n+  `\"unix\"` or `\"windows\"`. The value of this configuration option is defined\n+  as a configuration itself, like `unix` or `windows`.\n+* `unix` - See `target_family`.\n+* `windows` - See `target_family`.\n+* `target_env = \"..\"` - Further disambiguates the target platform with\n+  information about the ABI/libc. Presently this value is either\n+  `\"gnu\"`, `\"msvc\"`, `\"musl\"`, or the empty string. For historical\n+  reasons this value has only been defined as non-empty when needed\n+  for disambiguation. Thus on many GNU platforms this value will be\n+  empty. This value is closely related to the fourth element of the\n+  platform target triple, though it is not identical. For example,\n+  embedded ABIs such as `gnueabihf` will simply define `target_env` as\n+  `\"gnu\"`.\n+* `target_endian = \"...\"` - Endianness of the target CPU, either `\"little\"` or\n+  `\"big\"`.\n+* `target_pointer_width = \"...\"` - Target pointer width in bits. This is set\n+  to `\"32\"` for targets with 32-bit pointers, and likewise set to `\"64\"` for\n+  64-bit pointers.\n+* `target_has_atomic = \"...\"` - Set of integer sizes on which the target can perform\n+  atomic operations. Values are `\"8\"`, `\"16\"`, `\"32\"`, `\"64\"` and `\"ptr\"`.\n+* `target_vendor = \"...\"` - Vendor of the target, for example `apple`, `pc`, or\n+  simply `\"unknown\"`.\n+* `test` - Enabled when compiling the test harness (using the `--test` flag).\n+* `debug_assertions` - Enabled by default when compiling without optimizations.\n+  This can be used to enable extra debugging code in development but not in\n+  production.  For example, it controls the behavior of the standard library's\n+  `debug_assert!` macro.\n+\n+You can also set another attribute based on a `cfg` variable with `cfg_attr`:\n+\n+```rust,ignore\n+#[cfg_attr(a, b)]\n+```\n+\n+This is the same as `#[b]` if `a` is set by `cfg`, and nothing otherwise.\n+\n+Lastly, configuration options can be used in expressions by invoking the `cfg!`\n+macro: `cfg!(a)` evaluates to `true` if `a` is set, and `false` otherwise.\n+\n+### Lint check attributes\n+\n+A lint check names a potentially undesirable coding pattern, such as\n+unreachable code or omitted documentation, for the static entity to which the\n+attribute applies.\n+\n+For any lint check `C`:\n+\n+* `allow(C)` overrides the check for `C` so that violations will go\n+   unreported,\n+* `deny(C)` signals an error after encountering a violation of `C`,\n+* `forbid(C)` is the same as `deny(C)`, but also forbids changing the lint\n+   level afterwards,\n+* `warn(C)` warns about violations of `C` but continues compilation.\n+\n+The lint checks supported by the compiler can be found via `rustc -W help`,\n+along with their default settings.  [Compiler\n+plugins](book/compiler-plugins.html#lint-plugins) can provide additional lint checks.\n+\n+```{.ignore}\n+pub mod m1 {\n+    // Missing documentation is ignored here\n+    #[allow(missing_docs)]\n+    pub fn undocumented_one() -> i32 { 1 }\n+\n+    // Missing documentation signals a warning here\n+    #[warn(missing_docs)]\n+    pub fn undocumented_too() -> i32 { 2 }\n+\n+    // Missing documentation signals an error here\n+    #[deny(missing_docs)]\n+    pub fn undocumented_end() -> i32 { 3 }\n+}\n+```\n+\n+This example shows how one can use `allow` and `warn` to toggle a particular\n+check on and off:\n+\n+```{.ignore}\n+#[warn(missing_docs)]\n+pub mod m2{\n+    #[allow(missing_docs)]\n+    pub mod nested {\n+        // Missing documentation is ignored here\n+        pub fn undocumented_one() -> i32 { 1 }\n+\n+        // Missing documentation signals a warning here,\n+        // despite the allow above.\n+        #[warn(missing_docs)]\n+        pub fn undocumented_two() -> i32 { 2 }\n+    }\n+\n+    // Missing documentation signals a warning here\n+    pub fn undocumented_too() -> i32 { 3 }\n+}\n+```\n+\n+This example shows how one can use `forbid` to disallow uses of `allow` for\n+that lint check:\n+\n+```{.ignore}\n+#[forbid(missing_docs)]\n+pub mod m3 {\n+    // Attempting to toggle warning signals an error here\n+    #[allow(missing_docs)]\n+    /// Returns 2.\n+    pub fn undocumented_too() -> i32 { 2 }\n+}\n+```\n+\n+### Language items\n+\n+Some primitive Rust operations are defined in Rust code, rather than being\n+implemented directly in C or assembly language. The definitions of these\n+operations have to be easy for the compiler to find. The `lang` attribute\n+makes it possible to declare these operations. For example, the `str` module\n+in the Rust standard library defines the string equality function:\n+\n+```{.ignore}\n+#[lang = \"str_eq\"]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    // details elided\n+}\n+```\n+\n+The name `str_eq` has a special meaning to the Rust compiler, and the presence\n+of this definition means that it will use this definition when generating calls\n+to the string equality function.\n+\n+The set of language items is currently considered unstable. A complete\n+list of the built-in language items will be added in the future.\n+\n+### Inline attributes\n+\n+The inline attribute suggests that the compiler should place a copy of\n+the function or static in the caller, rather than generating code to\n+call the function or access the static where it is defined.\n+\n+The compiler automatically inlines functions based on internal heuristics.\n+Incorrectly inlining functions can actually make the program slower, so it\n+should be used with care.\n+\n+`#[inline]` and `#[inline(always)]` always cause the function to be serialized\n+into the crate metadata to allow cross-crate inlining.\n+\n+There are three different types of inline attributes:\n+\n+* `#[inline]` hints the compiler to perform an inline expansion.\n+* `#[inline(always)]` asks the compiler to always perform an inline expansion.\n+* `#[inline(never)]` asks the compiler to never perform an inline expansion.\n+\n+### `derive`\n+\n+The `derive` attribute allows certain traits to be automatically implemented\n+for data structures. For example, the following will create an `impl` for the\n+`PartialEq` and `Clone` traits for `Foo`, the type parameter `T` will be given\n+the `PartialEq` or `Clone` constraints for the appropriate `impl`:\n+\n+```\n+#[derive(PartialEq, Clone)]\n+struct Foo<T> {\n+    a: i32,\n+    b: T,\n+}\n+```\n+\n+The generated `impl` for `PartialEq` is equivalent to\n+\n+```\n+# struct Foo<T> { a: i32, b: T }\n+impl<T: PartialEq> PartialEq for Foo<T> {\n+    fn eq(&self, other: &Foo<T>) -> bool {\n+        self.a == other.a && self.b == other.b\n+    }\n+\n+    fn ne(&self, other: &Foo<T>) -> bool {\n+        self.a != other.a || self.b != other.b\n+    }\n+}\n+```\n+\n+You can implement `derive` for your own type through [procedural\n+macros](#procedural-macros).\n+\n+### Compiler Features\n+\n+Certain aspects of Rust may be implemented in the compiler, but they're not\n+necessarily ready for every-day use. These features are often of \"prototype\n+quality\" or \"almost production ready\", but may not be stable enough to be\n+considered a full-fledged language feature.\n+\n+For this reason, Rust recognizes a special crate-level attribute of the form:\n+\n+```{.ignore}\n+#![feature(feature1, feature2, feature3)]\n+```\n+\n+This directive informs the compiler that the feature list: `feature1`,\n+`feature2`, and `feature3` should all be enabled. This is only recognized at a\n+crate-level, not at a module-level. Without this directive, all features are\n+considered off, and using the features will result in a compiler error.\n+\n+The currently implemented features of the reference compiler are:\n+\n+* `advanced_slice_patterns` - See the [match expressions](#match-expressions)\n+                              section for discussion; the exact semantics of\n+                              slice patterns are subject to change, so some types\n+                              are still unstable.\n+\n+* `slice_patterns` - OK, actually, slice patterns are just scary and\n+                     completely unstable.\n+\n+* `asm` - The `asm!` macro provides a means for inline assembly. This is often\n+          useful, but the exact syntax for this feature along with its\n+          semantics are likely to change, so this macro usage must be opted\n+          into.\n+\n+* `associated_consts` - Allows constants to be defined in `impl` and `trait`\n+                        blocks, so that they can be associated with a type or\n+                        trait in a similar manner to methods and associated\n+                        types.\n+\n+* `box_patterns` - Allows `box` patterns, the exact semantics of which\n+                   is subject to change.\n+\n+* `box_syntax` - Allows use of `box` expressions, the exact semantics of which\n+                 is subject to change.\n+\n+* `cfg_target_vendor` - Allows conditional compilation using the `target_vendor`\n+                        matcher which is subject to change.\n+\n+* `cfg_target_has_atomic` - Allows conditional compilation using the `target_has_atomic`\n+                            matcher which is subject to change.\n+\n+* `concat_idents` - Allows use of the `concat_idents` macro, which is in many\n+                    ways insufficient for concatenating identifiers, and may be\n+                    removed entirely for something more wholesome.\n+\n+* `custom_attribute` - Allows the usage of attributes unknown to the compiler\n+                       so that new attributes can be added in a backwards compatible\n+                       manner (RFC 572).\n+\n+* `custom_derive` - Allows the use of `#[derive(Foo,Bar)]` as sugar for\n+                    `#[derive_Foo] #[derive_Bar]`, which can be user-defined syntax\n+                    extensions.\n+\n+* `inclusive_range_syntax` - Allows use of the `a...b` and `...b` syntax for inclusive ranges.\n+\n+* `inclusive_range` - Allows use of the types that represent desugared inclusive ranges.\n+\n+* `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n+                 are inherently unstable and no promise about them is made.\n+\n+* `lang_items` - Allows use of the `#[lang]` attribute. Like `intrinsics`,\n+                 lang items are inherently unstable and no promise about them\n+                 is made.\n+\n+* `link_args` - This attribute is used to specify custom flags to the linker,\n+                but usage is strongly discouraged. The compiler's usage of the\n+                system linker is not guaranteed to continue in the future, and\n+                if the system linker is not used then specifying custom flags\n+                doesn't have much meaning.\n+\n+* `link_llvm_intrinsics` - Allows linking to LLVM intrinsics via\n+                           `#[link_name=\"llvm.*\"]`.\n+\n+* `linkage` - Allows use of the `linkage` attribute, which is not portable.\n+\n+* `log_syntax` - Allows use of the `log_syntax` macro attribute, which is a\n+                 nasty hack that will certainly be removed.\n+\n+* `main` - Allows use of the `#[main]` attribute, which changes the entry point\n+           into a Rust program. This capability is subject to change.\n+\n+* `macro_reexport` - Allows macros to be re-exported from one crate after being imported\n+                     from another. This feature was originally designed with the sole\n+                     use case of the Rust standard library in mind, and is subject to\n+                     change.\n+\n+* `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n+                       but the implementation is a little rough around the\n+                       edges, so this can be seen as an experimental feature\n+                       for now until the specification of identifiers is fully\n+                       fleshed out.\n+\n+* `no_std` - Allows the `#![no_std]` crate attribute, which disables the implicit\n+             `extern crate std`. This typically requires use of the unstable APIs\n+             behind the libstd \"facade\", such as libcore and libcollections. It\n+             may also cause problems when using syntax extensions, including\n+             `#[derive]`.\n+\n+* `on_unimplemented` - Allows the `#[rustc_on_unimplemented]` attribute, which allows\n+                       trait definitions to add specialized notes to error messages\n+                       when an implementation was expected but not found.\n+\n+* `optin_builtin_traits` - Allows the definition of default and negative trait\n+                           implementations. Experimental.\n+\n+* `plugin` - Usage of [compiler plugins][plugin] for custom lints or syntax extensions.\n+             These depend on compiler internals and are subject to change.\n+\n+* `plugin_registrar` - Indicates that a crate provides [compiler plugins][plugin].\n+\n+* `quote` - Allows use of the `quote_*!` family of macros, which are\n+            implemented very poorly and will likely change significantly\n+            with a proper implementation.\n+\n+* `rustc_attrs` - Gates internal `#[rustc_*]` attributes which may be\n+                  for internal use only or have meaning added to them in the future.\n+\n+* `rustc_diagnostic_macros`- A mysterious feature, used in the implementation\n+                             of rustc, not meant for mortals.\n+\n+* `simd` - Allows use of the `#[simd]` attribute, which is overly simple and\n+           not the SIMD interface we want to expose in the long term.\n+\n+* `simd_ffi` - Allows use of SIMD vectors in signatures for foreign functions.\n+               The SIMD interface is subject to change.\n+\n+* `start` - Allows use of the `#[start]` attribute, which changes the entry point\n+            into a Rust program. This capability, especially the signature for the\n+            annotated function, is subject to change.\n+\n+* `thread_local` - The usage of the `#[thread_local]` attribute is experimental\n+                   and should be seen as unstable. This attribute is used to\n+                   declare a `static` as being unique per-thread leveraging\n+                   LLVM's implementation which works in concert with the kernel\n+                   loader and dynamic linker. This is not necessarily available\n+                   on all platforms, and usage of it is discouraged.\n+\n+* `trace_macros` - Allows use of the `trace_macros` macro, which is a nasty\n+                   hack that will certainly be removed.\n+\n+* `unboxed_closures` - Rust's new closure design, which is currently a work in\n+                       progress feature with many known bugs.\n+\n+* `allow_internal_unstable` - Allows `macro_rules!` macros to be tagged with the\n+                              `#[allow_internal_unstable]` attribute, designed\n+                              to allow `std` macros to call\n+                              `#[unstable]`/feature-gated functionality\n+                              internally without imposing on callers\n+                              (i.e. making them behave like function calls in\n+                              terms of encapsulation).\n+\n+* `default_type_parameter_fallback` - Allows type parameter defaults to\n+                                      influence type inference.\n+\n+* `stmt_expr_attributes` - Allows attributes on expressions.\n+\n+* `type_ascription` - Allows type ascription expressions `expr: Type`.\n+\n+* `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n+                     (e.g. `extern \"vectorcall\" func fn_();`)\n+\n+* `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n+                 (e.g. `extern \"sysv64\" func fn_();`)\n+\n+If a feature is promoted to a language feature, then all existing programs will\n+start to receive compilation warnings about `#![feature]` directives which enabled\n+the new feature (because the directive is no longer necessary). However, if a\n+feature is decided to be removed from the language, errors will be issued (if\n+there isn't a parser error first). The directive in this case is no longer\n+necessary, and it's likely that existing code will break if the feature isn't\n+removed.\n+\n+If an unknown feature is found in a directive, it results in a compiler error.\n+An unknown feature is one which has never been recognized by the compiler."}, {"sha": "b617ee3d78fa717a2de6a0266ff5e10adc0f0121", "filename": "src/doc/reference/src/behavior-considered-undefined.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-considered-undefined.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-considered-undefined.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-considered-undefined.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,35 @@\n+## Behavior considered undefined\n+\n+The following is a list of behavior which is forbidden in all Rust code,\n+including within `unsafe` blocks and `unsafe` functions. Type checking provides\n+the guarantee that these issues are never caused by safe code.\n+\n+* Data races\n+* Dereferencing a null/dangling raw pointer\n+* Reads of [undef](http://llvm.org/docs/LangRef.html#undefined-values)\n+  (uninitialized) memory\n+* Breaking the [pointer aliasing\n+  rules](http://llvm.org/docs/LangRef.html#pointer-aliasing-rules)\n+  with raw pointers (a subset of the rules used by C)\n+* `&mut T` and `&T` follow LLVM\u2019s scoped [noalias] model, except if the `&T`\n+  contains an `UnsafeCell<U>`. Unsafe code must not violate these aliasing\n+  guarantees.\n+* Mutating non-mutable data (that is, data reached through a shared reference or\n+  data owned by a `let` binding), unless that data is contained within an `UnsafeCell<U>`.\n+* Invoking undefined behavior via compiler intrinsics:\n+  * Indexing outside of the bounds of an object with `std::ptr::offset`\n+    (`offset` intrinsic), with\n+    the exception of one byte past the end which is permitted.\n+  * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n+    intrinsics) on overlapping buffers\n+* Invalid values in primitive types, even in private fields/locals:\n+  * Dangling/null references or boxes\n+  * A value other than `false` (0) or `true` (1) in a `bool`\n+  * A discriminant in an `enum` not included in the type definition\n+  * A value in a `char` which is a surrogate or above `char::MAX`\n+  * Non-UTF-8 byte sequences in a `str`\n+* Unwinding into Rust from foreign code or unwinding from Rust into foreign\n+  code. Rust's failure system is not compatible with exception handling in\n+  other languages. Unwinding must be caught and handled at FFI boundaries.\n+\n+[noalias]: http://llvm.org/docs/LangRef.html#noalias"}, {"sha": "e16103372f552ac37eaac0a3159abfaaf316e401", "filename": "src/doc/reference/src/behavior-not-considered-unsafe.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-not-considered-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-not-considered-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fbehavior-not-considered-unsafe.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,15 @@\n+## Behavior not considered unsafe\n+\n+This is a list of behavior not considered *unsafe* in Rust terms, but that may\n+be undesired.\n+\n+* Deadlocks\n+* Leaks of memory and other resources\n+* Exiting without calling destructors\n+* Integer overflow\n+  - Overflow is considered \"unexpected\" behavior and is always user-error,\n+    unless the `wrapping` primitives are used. In non-optimized builds, the compiler\n+    will insert debug checks that panic on overflow, but in optimized builds overflow\n+    instead results in wrapped values. See [RFC 560] for the rationale and more details.\n+\n+[RFC 560]: https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md"}, {"sha": "bb8c8f793fc13149713c012300eb557cc1df2d86", "filename": "src/doc/reference/src/comments.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fcomments.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,18 @@\n+# Comments\n+\n+Comments in Rust code follow the general C++ style of line (`//`) and\n+block (`/* ... */`) comment forms. Nested block comments are supported.\n+\n+Line comments beginning with exactly _three_ slashes (`///`), and block\n+comments (`/** ... */`), are interpreted as a special syntax for `doc`\n+[attributes](#attributes). That is, they are equivalent to writing\n+`#[doc=\"...\"]` around the body of the comment, i.e., `/// Foo` turns into\n+`#[doc=\"Foo\"]`.\n+\n+Line comments beginning with `//!` and block comments `/*! ... */` are\n+doc comments that apply to the parent of the comment, rather than the item\n+that follows.  That is, they are equivalent to writing `#![doc=\"...\"]` around\n+the body of the comment. `//!` comments are usually used to document\n+modules that occupy a source file.\n+\n+Non-doc comments are interpreted as a form of whitespace."}, {"sha": "dbb7098f7f140342a9e01aa851d040eb9ee86a09", "filename": "src/doc/reference/src/crates-and-source-files.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fcrates-and-source-files.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fcrates-and-source-files.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fcrates-and-source-files.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,68 @@\n+# Crates and source files\n+\n+Although Rust, like any other language, can be implemented by an interpreter as\n+well as a compiler, the only existing implementation is a compiler,\n+and the language has\n+always been designed to be compiled. For these reasons, this section assumes a\n+compiler.\n+\n+Rust's semantics obey a *phase distinction* between compile-time and\n+run-time.[^phase-distinction] Semantic rules that have a *static\n+interpretation* govern the success or failure of compilation, while\n+semantic rules\n+that have a *dynamic interpretation* govern the behavior of the program at\n+run-time.\n+\n+[^phase-distinction]: This distinction would also exist in an interpreter.\n+    Static checks like syntactic analysis, type checking, and lints should\n+    happen before the program is executed regardless of when it is executed.\n+\n+The compilation model centers on artifacts called _crates_. Each compilation\n+processes a single crate in source form, and if successful, produces a single\n+crate in binary form: either an executable or some sort of\n+library.[^cratesourcefile]\n+\n+[^cratesourcefile]: A crate is somewhat analogous to an *assembly* in the\n+    ECMA-335 CLI model, a *library* in the SML/NJ Compilation Manager, a *unit*\n+    in the Owens and Flatt module system, or a *configuration* in Mesa.\n+\n+A _crate_ is a unit of compilation and linking, as well as versioning,\n+distribution and runtime loading. A crate contains a _tree_ of nested\n+[module](#modules) scopes. The top level of this tree is a module that is\n+anonymous (from the point of view of paths within the module) and any item\n+within a crate has a canonical [module path](#paths) denoting its location\n+within the crate's module tree.\n+\n+The Rust compiler is always invoked with a single source file as input, and\n+always produces a single output crate. The processing of that source file may\n+result in other source files being loaded as modules. Source files have the\n+extension `.rs`.\n+\n+A Rust source file describes a module, the name and location of which &mdash;\n+in the module tree of the current crate &mdash; are defined from outside the\n+source file: either by an explicit `mod_item` in a referencing source file, or\n+by the name of the crate itself. Every source file is a module, but not every\n+module needs its own source file: [module definitions](#modules) can be nested\n+within one file.\n+\n+Each source file contains a sequence of zero or more `item` definitions, and\n+may optionally begin with any number of [attributes](#items-and-attributes)\n+that apply to the containing module, most of which influence the behavior of\n+the compiler. The anonymous crate module can have additional attributes that\n+apply to the crate as a whole.\n+\n+```no_run\n+// Specify the crate name.\n+#![crate_name = \"projx\"]\n+\n+// Specify the type of output artifact.\n+#![crate_type = \"lib\"]\n+\n+// Turn on a warning.\n+// This can be done in any module, not just the anonymous crate module.\n+#![warn(non_camel_case_types)]\n+```\n+\n+A crate that contains a `main` function can be compiled to an executable. If a\n+`main` function is present, its return type must be `()`\n+(\"[unit](#tuple-types)\") and it must take no arguments."}, {"sha": "d729799a15321b7af4820bcb5c02a93c5d6c8d14", "filename": "src/doc/reference/src/expressions.md", "status": "added", "additions": 855, "deletions": 0, "changes": 855, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fexpressions.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,855 @@\n+# Expressions\n+\n+An expression may have two roles: it always produces a *value*, and it may have\n+*effects* (otherwise known as \"side effects\"). An expression *evaluates to* a\n+value, and has effects during *evaluation*. Many expressions contain\n+sub-expressions (operands). The meaning of each kind of expression dictates\n+several things:\n+\n+* Whether or not to evaluate the sub-expressions when evaluating the expression\n+* The order in which to evaluate the sub-expressions\n+* How to combine the sub-expressions' values to obtain the value of the expression\n+\n+In this way, the structure of expressions dictates the structure of execution.\n+Blocks are just another kind of expression, so blocks, statements, expressions,\n+and blocks again can recursively nest inside each other to an arbitrary depth.\n+\n+### Lvalues, rvalues and temporaries\n+\n+Expressions are divided into two main categories: _lvalues_ and _rvalues_.\n+Likewise within each expression, sub-expressions may occur in _lvalue context_\n+or _rvalue context_. The evaluation of an expression depends both on its own\n+category and the context it occurs within.\n+\n+An lvalue is an expression that represents a memory location. These expressions\n+are [paths](#path-expressions) (which refer to local variables, function and\n+method arguments, or static variables), dereferences (`*expr`), [indexing\n+expressions](#index-expressions) (`expr[expr]`), and [field\n+references](#field-expressions) (`expr.f`). All other expressions are rvalues.\n+\n+The left operand of an [assignment](#assignment-expressions) or\n+[compound-assignment](#compound-assignment-expressions) expression is\n+an lvalue context, as is the single operand of a unary\n+[borrow](#unary-operator-expressions). The discriminant or subject of\n+a [match expression](#match-expressions) may be an lvalue context, if\n+ref bindings are made, but is otherwise an rvalue context. All other\n+expression contexts are rvalue contexts.\n+\n+When an lvalue is evaluated in an _lvalue context_, it denotes a memory\n+location; when evaluated in an _rvalue context_, it denotes the value held _in_\n+that memory location.\n+\n+#### Temporary lifetimes\n+\n+When an rvalue is used in an lvalue context, a temporary un-named\n+lvalue is created and used instead. The lifetime of temporary values\n+is typically the innermost enclosing statement; the tail expression of\n+a block is considered part of the statement that encloses the block.\n+\n+When a temporary rvalue is being created that is assigned into a `let`\n+declaration, however, the temporary is created with the lifetime of\n+the enclosing block instead, as using the enclosing statement (the\n+`let` declaration) would be a guaranteed error (since a pointer to the\n+temporary would be stored into a variable, but the temporary would be\n+freed before the variable could be used). The compiler uses simple\n+syntactic rules to decide which values are being assigned into a `let`\n+binding, and therefore deserve a longer temporary lifetime.\n+\n+Here are some examples:\n+\n+- `let x = foo(&temp())`. The expression `temp()` is an rvalue. As it\n+  is being borrowed, a temporary is created which will be freed after\n+  the innermost enclosing statement (the `let` declaration, in this case).\n+- `let x = temp().foo()`. This is the same as the previous example,\n+  except that the value of `temp()` is being borrowed via autoref on a\n+  method-call. Here we are assuming that `foo()` is an `&self` method\n+  defined in some trait, say `Foo`. In other words, the expression\n+  `temp().foo()` is equivalent to `Foo::foo(&temp())`.\n+- `let x = &temp()`. Here, the same temporary is being assigned into\n+  `x`, rather than being passed as a parameter, and hence the\n+  temporary's lifetime is considered to be the enclosing block.\n+- `let x = SomeStruct { foo: &temp() }`. As in the previous case, the\n+  temporary is assigned into a struct which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let x = [ &temp() ]`. As in the previous case, the\n+  temporary is assigned into an array which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let ref x = temp()`. In this case, the temporary is created using a ref binding,\n+  but the result is the same: the lifetime is extended to the enclosing block.\n+\n+### Moved and copied types\n+\n+When a [local variable](#variables) is used as an\n+[rvalue](#lvalues-rvalues-and-temporaries), the variable will be copied\n+if its type implements `Copy`. All others are moved.\n+\n+## Literal expressions\n+\n+A _literal expression_ consists of one of the [literal](#literals) forms\n+described earlier. It directly describes a number, character, string, boolean\n+value, or the unit value.\n+\n+```{.literals}\n+();        // unit type\n+\"hello\";   // string type\n+'5';       // character type\n+5;         // integer type\n+```\n+\n+## Path expressions\n+\n+A [path](#paths) used as an expression context denotes either a local variable\n+or an item. Path expressions are [lvalues](#lvalues-rvalues-and-temporaries).\n+\n+## Tuple expressions\n+\n+Tuples are written by enclosing zero or more comma-separated expressions in\n+parentheses. They are used to create [tuple-typed](#tuple-types) values.\n+\n+```{.tuple}\n+(0.0, 4.5);\n+(\"a\", 4usize, true);\n+```\n+\n+You can disambiguate a single-element tuple from a value in parentheses with a\n+comma:\n+\n+```\n+(0,); // single-element tuple\n+(0); // zero in parentheses\n+```\n+\n+## Struct expressions\n+\n+There are several forms of struct expressions. A _struct expression_\n+consists of the [path](#paths) of a [struct item](#structs), followed by\n+a brace-enclosed list of zero or more comma-separated name-value pairs,\n+providing the field values of a new instance of the struct. A field name\n+can be any identifier, and is separated from its value expression by a colon.\n+The location denoted by a struct field is mutable if and only if the\n+enclosing struct is mutable.\n+\n+A _tuple struct expression_ consists of the [path](#paths) of a [struct\n+item](#structs), followed by a parenthesized list of one or more\n+comma-separated expressions (in other words, the path of a struct item\n+followed by a tuple expression). The struct item must be a tuple struct\n+item.\n+\n+A _unit-like struct expression_ consists only of the [path](#paths) of a\n+[struct item](#structs).\n+\n+The following are examples of struct expressions:\n+\n+```\n+# struct Point { x: f64, y: f64 }\n+# struct NothingInMe { }\n+# struct TuplePoint(f64, f64);\n+# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n+# struct Cookie; fn some_fn<T>(t: T) {}\n+Point {x: 10.0, y: 20.0};\n+NothingInMe {};\n+TuplePoint(10.0, 20.0);\n+let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n+some_fn::<Cookie>(Cookie);\n+```\n+\n+A struct expression forms a new value of the named struct type. Note\n+that for a given *unit-like* struct type, this will always be the same\n+value.\n+\n+A struct expression can terminate with the syntax `..` followed by an\n+expression to denote a functional update. The expression following `..` (the\n+base) must have the same struct type as the new struct type being formed.\n+The entire expression denotes the result of constructing a new struct (with\n+the same type as the base expression) with the given values for the fields that\n+were explicitly specified and the values in the base expression for all other\n+fields.\n+\n+```\n+# struct Point3d { x: i32, y: i32, z: i32 }\n+let base = Point3d {x: 1, y: 2, z: 3};\n+Point3d {y: 0, z: 10, .. base};\n+```\n+\n+#### Struct field init shorthand\n+\n+When initializing a data structure (struct, enum, union) with named fields,\n+it is allowed to write `fieldname` as a shorthand for `fieldname: fieldname`.\n+This allows a compact syntax with less duplication.\n+\n+Example:\n+\n+```\n+# struct Point3d { x: i32, y: i32, z: i32 }\n+# let x = 0;\n+# let y_value = 0;\n+# let z = 0;\n+Point3d { x: x, y: y_value, z: z };\n+Point3d { x, y: y_value, z };\n+```\n+\n+## Block expressions\n+\n+A _block expression_ is similar to a module in terms of the declarations that\n+are possible. Each block conceptually introduces a new namespace scope. Use\n+items can bring new names into scopes and declared items are in scope for only\n+the block itself.\n+\n+A block will execute each statement sequentially, and then execute the\n+expression (if given). If the block ends in a statement, its value is `()`:\n+\n+```\n+let x: () = { println!(\"Hello.\"); };\n+```\n+\n+If it ends in an expression, its value and type are that of the expression:\n+\n+```\n+let x: i32 = { println!(\"Hello.\"); 5 };\n+\n+assert_eq!(5, x);\n+```\n+\n+## Method-call expressions\n+\n+A _method call_ consists of an expression followed by a single dot, an\n+identifier, and a parenthesized expression-list. Method calls are resolved to\n+methods on specific traits, either statically dispatching to a method if the\n+exact `self`-type of the left-hand-side is known, or dynamically dispatching if\n+the left-hand-side expression is an indirect [trait object](#trait-objects).\n+\n+## Field expressions\n+\n+A _field expression_ consists of an expression followed by a single dot and an\n+identifier, when not immediately followed by a parenthesized expression-list\n+(the latter is a [method call expression](#method-call-expressions)). A field\n+expression denotes a field of a [struct](#struct-types).\n+\n+```{.ignore .field}\n+mystruct.myfield;\n+foo().x;\n+(Struct {a: 10, b: 20}).a;\n+```\n+\n+A field access is an [lvalue](#lvalues-rvalues-and-temporaries) referring to\n+the value of that field. When the type providing the field inherits mutability,\n+it can be [assigned](#assignment-expressions) to.\n+\n+Also, if the type of the expression to the left of the dot is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the field access possible. In cases of ambiguity, we prefer\n+fewer autoderefs to more.\n+\n+## Array expressions\n+\n+An [array](#array-and-slice-types) _expression_ is written by enclosing zero\n+or more comma-separated expressions of uniform type in square brackets.\n+\n+In the `[expr ';' expr]` form, the expression after the `';'` must be a\n+constant expression that can be evaluated at compile time, such as a\n+[literal](#literals) or a [static item](#static-items).\n+\n+```\n+[1, 2, 3, 4];\n+[\"a\", \"b\", \"c\", \"d\"];\n+[0; 128];              // array with 128 zeros\n+[0u8, 0u8, 0u8, 0u8];\n+```\n+\n+## Index expressions\n+\n+[Array](#array-and-slice-types)-typed expressions can be indexed by\n+writing a square-bracket-enclosed expression (the index) after them. When the\n+array is mutable, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can\n+be assigned to.\n+\n+Indices are zero-based, and may be of any integral type. Vector access is\n+bounds-checked at compile-time for constant arrays being accessed with a constant index value.\n+Otherwise a check will be performed at run-time that will put the thread in a _panicked state_ if it fails.\n+\n+```{should-fail}\n+([1, 2, 3, 4])[0];\n+\n+let x = ([\"a\", \"b\"])[10]; // compiler error: const index-expr is out of bounds\n+\n+let n = 10;\n+let y = ([\"a\", \"b\"])[n]; // panics\n+\n+let arr = [\"a\", \"b\"];\n+arr[10]; // panics\n+```\n+\n+Also, if the type of the expression to the left of the brackets is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the indexing possible. In cases of ambiguity, we prefer fewer\n+autoderefs to more.\n+\n+## Range expressions\n+\n+The `..` operator will construct an object of one of the `std::ops::Range` variants.\n+\n+```\n+1..2;   // std::ops::Range\n+3..;    // std::ops::RangeFrom\n+..4;    // std::ops::RangeTo\n+..;     // std::ops::RangeFull\n+```\n+\n+The following expressions are equivalent.\n+\n+```\n+let x = std::ops::Range {start: 0, end: 10};\n+let y = 0..10;\n+\n+assert_eq!(x, y);\n+```\n+\n+Similarly, the `...` operator will construct an object of one of the\n+`std::ops::RangeInclusive` variants.\n+\n+```\n+# #![feature(inclusive_range_syntax)]\n+1...2;   // std::ops::RangeInclusive\n+...4;    // std::ops::RangeToInclusive\n+```\n+\n+The following expressions are equivalent.\n+\n+```\n+# #![feature(inclusive_range_syntax, inclusive_range)]\n+let x = std::ops::RangeInclusive::NonEmpty {start: 0, end: 10};\n+let y = 0...10;\n+\n+assert_eq!(x, y);\n+```\n+\n+## Unary operator expressions\n+\n+Rust defines the following unary operators. With the exception of `?`, they are\n+all written as prefix operators, before the expression they apply to.\n+\n+* `-`\n+  : Negation. Signed integer types and floating-point types support negation. It\n+    is an error to apply negation to unsigned types; for example, the compiler\n+    rejects `-1u32`.\n+* `*`\n+  : Dereference. When applied to a [pointer](#pointer-types) it denotes the\n+    pointed-to location. For pointers to mutable locations, the resulting\n+    [lvalue](#lvalues-rvalues-and-temporaries) can be assigned to.\n+    On non-pointer types, it calls the `deref` method of the `std::ops::Deref`\n+    trait, or the `deref_mut` method of the `std::ops::DerefMut` trait (if\n+    implemented by the type and required for an outer expression that will or\n+    could mutate the dereference), and produces the result of dereferencing the\n+    `&` or `&mut` borrowed pointer returned from the overload method.\n+* `!`\n+  : Logical negation. On the boolean type, this flips between `true` and\n+    `false`. On integer types, this inverts the individual bits in the\n+    two's complement representation of the value.\n+* `&` and `&mut`\n+  : Borrowing. When applied to an lvalue, these operators produce a\n+    reference (pointer) to the lvalue. The lvalue is also placed into\n+    a borrowed state for the duration of the reference. For a shared\n+    borrow (`&`), this implies that the lvalue may not be mutated, but\n+    it may be read or shared again. For a mutable borrow (`&mut`), the\n+    lvalue may not be accessed in any way until the borrow expires.\n+    If the `&` or `&mut` operators are applied to an rvalue, a\n+    temporary value is created; the lifetime of this temporary value\n+    is defined by [syntactic rules](#temporary-lifetimes).\n+* `?`\n+  : Propagating errors if applied to `Err(_)` and unwrapping if\n+    applied to `Ok(_)`. Only works on the `Result<T, E>` type,\n+    and written in postfix notation.\n+\n+## Binary operator expressions\n+\n+Binary operators expressions are given in terms of [operator\n+precedence](#operator-precedence).\n+\n+### Arithmetic operators\n+\n+Binary arithmetic expressions are syntactic sugar for calls to built-in traits,\n+defined in the `std::ops` module of the `std` library. This means that\n+arithmetic operators can be overridden for user-defined types. The default\n+meaning of the operators on standard types is given here.\n+\n+* `+`\n+  : Addition and array/string concatenation.\n+    Calls the `add` method on the `std::ops::Add` trait.\n+* `-`\n+  : Subtraction.\n+    Calls the `sub` method on the `std::ops::Sub` trait.\n+* `*`\n+  : Multiplication.\n+    Calls the `mul` method on the `std::ops::Mul` trait.\n+* `/`\n+  : Quotient.\n+    Calls the `div` method on the `std::ops::Div` trait.\n+* `%`\n+  : Remainder.\n+    Calls the `rem` method on the `std::ops::Rem` trait.\n+\n+### Bitwise operators\n+\n+Like the [arithmetic operators](#arithmetic-operators), bitwise operators are\n+syntactic sugar for calls to methods of built-in traits. This means that\n+bitwise operators can be overridden for user-defined types. The default\n+meaning of the operators on standard types is given here. Bitwise `&`, `|` and\n+`^` applied to boolean arguments are equivalent to logical `&&`, `||` and `!=`\n+evaluated in non-lazy fashion.\n+\n+* `&`\n+  : Bitwise AND.\n+    Calls the `bitand` method of the `std::ops::BitAnd` trait.\n+* `|`\n+  : Bitwise inclusive OR.\n+    Calls the `bitor` method of the `std::ops::BitOr` trait.\n+* `^`\n+  : Bitwise exclusive OR.\n+    Calls the `bitxor` method of the `std::ops::BitXor` trait.\n+* `<<`\n+  : Left shift.\n+    Calls the `shl` method of the `std::ops::Shl` trait.\n+* `>>`\n+  : Right shift (arithmetic).\n+    Calls the `shr` method of the `std::ops::Shr` trait.\n+\n+### Lazy boolean operators\n+\n+The operators `||` and `&&` may be applied to operands of boolean type. The\n+`||` operator denotes logical 'or', and the `&&` operator denotes logical\n+'and'. They differ from `|` and `&` in that the right-hand operand is only\n+evaluated when the left-hand operand does not already determine the result of\n+the expression. That is, `||` only evaluates its right-hand operand when the\n+left-hand operand evaluates to `false`, and `&&` only when it evaluates to\n+`true`.\n+\n+### Comparison operators\n+\n+Comparison operators are, like the [arithmetic\n+operators](#arithmetic-operators), and [bitwise operators](#bitwise-operators),\n+syntactic sugar for calls to built-in traits. This means that comparison\n+operators can be overridden for user-defined types. The default meaning of the\n+operators on standard types is given here.\n+\n+* `==`\n+  : Equal to.\n+    Calls the `eq` method on the `std::cmp::PartialEq` trait.\n+* `!=`\n+  : Unequal to.\n+    Calls the `ne` method on the `std::cmp::PartialEq` trait.\n+* `<`\n+  : Less than.\n+    Calls the `lt` method on the `std::cmp::PartialOrd` trait.\n+* `>`\n+  : Greater than.\n+    Calls the `gt` method on the `std::cmp::PartialOrd` trait.\n+* `<=`\n+  : Less than or equal.\n+    Calls the `le` method on the `std::cmp::PartialOrd` trait.\n+* `>=`\n+  : Greater than or equal.\n+    Calls the `ge` method on the `std::cmp::PartialOrd` trait.\n+\n+### Type cast expressions\n+\n+A type cast expression is denoted with the binary operator `as`.\n+\n+Executing an `as` expression casts the value on the left-hand side to the type\n+on the right-hand side.\n+\n+An example of an `as` expression:\n+\n+```\n+# fn sum(values: &[f64]) -> f64 { 0.0 }\n+# fn len(values: &[f64]) -> i32 { 0 }\n+\n+fn average(values: &[f64]) -> f64 {\n+    let sum: f64 = sum(values);\n+    let size: f64 = len(values) as f64;\n+    sum / size\n+}\n+```\n+\n+Some of the conversions which can be done through the `as` operator\n+can also be done implicitly at various points in the program, such as\n+argument passing and assignment to a `let` binding with an explicit\n+type. Implicit conversions are limited to \"harmless\" conversions that\n+do not lose information and which have minimal or no risk of\n+surprising side-effects on the dynamic execution semantics.\n+\n+### Assignment expressions\n+\n+An _assignment expression_ consists of an\n+[lvalue](#lvalues-rvalues-and-temporaries) expression followed by an equals\n+sign (`=`) and an [rvalue](#lvalues-rvalues-and-temporaries) expression.\n+\n+Evaluating an assignment expression [either copies or\n+moves](#moved-and-copied-types) its right-hand operand to its left-hand\n+operand.\n+\n+```\n+# let mut x = 0;\n+# let y = 0;\n+x = y;\n+```\n+\n+### Compound assignment expressions\n+\n+The `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, and `>>` operators may be\n+composed with the `=` operator. The expression `lval OP= val` is equivalent to\n+`lval = lval OP val`. For example, `x = x + 1` may be written as `x += 1`.\n+\n+Any such expression always has the [`unit`](#tuple-types) type.\n+\n+### Operator precedence\n+\n+The precedence of Rust binary operators is ordered as follows, going from\n+strong to weak:\n+\n+```{.text .precedence}\n+as :\n+* / %\n++ -\n+<< >>\n+&\n+^\n+|\n+== != < > <= >=\n+&&\n+||\n+.. ...\n+<-\n+=\n+```\n+\n+Operators at the same precedence level are evaluated left-to-right. [Unary\n+operators](#unary-operator-expressions) have the same precedence level and are\n+stronger than any of the binary operators.\n+\n+## Grouped expressions\n+\n+An expression enclosed in parentheses evaluates to the result of the enclosed\n+expression. Parentheses can be used to explicitly specify evaluation order\n+within an expression.\n+\n+An example of a parenthesized expression:\n+\n+```\n+let x: i32 = (2 + 3) * 4;\n+```\n+\n+\n+## Call expressions\n+\n+A _call expression_ invokes a function, providing zero or more input variables\n+and an optional location to move the function's output into. If the function\n+eventually returns, then the expression completes.\n+\n+Some examples of call expressions:\n+\n+```\n+# fn add(x: i32, y: i32) -> i32 { 0 }\n+\n+let x: i32 = add(1i32, 2i32);\n+let pi: Result<f32, _> = \"3.14\".parse();\n+```\n+\n+## Lambda expressions\n+\n+A _lambda expression_ (sometimes called an \"anonymous function expression\")\n+defines a function and denotes it as a value, in a single expression. A lambda\n+expression is a pipe-symbol-delimited (`|`) list of identifiers followed by an\n+expression.\n+\n+A lambda expression denotes a function that maps a list of parameters\n+(`ident_list`) onto the expression that follows the `ident_list`. The\n+identifiers in the `ident_list` are the parameters to the function. These\n+parameters' types need not be specified, as the compiler infers them from\n+context.\n+\n+Lambda expressions are most useful when passing functions as arguments to other\n+functions, as an abbreviation for defining and capturing a separate function.\n+\n+Significantly, lambda expressions _capture their environment_, which regular\n+[function definitions](#functions) do not. The exact type of capture depends\n+on the [function type](#function-types) inferred for the lambda expression. In\n+the simplest and least-expensive form (analogous to a ```|| { }``` expression),\n+the lambda expression captures its environment by reference, effectively\n+borrowing pointers to all outer variables mentioned inside the function.\n+Alternately, the compiler may infer that a lambda expression should copy or\n+move values (depending on their type) from the environment into the lambda\n+expression's captured environment. A lambda can be forced to capture its\n+environment by moving values by prefixing it with the `move` keyword.\n+\n+In this example, we define a function `ten_times` that takes a higher-order\n+function argument, and we then call it with a lambda expression as an argument,\n+followed by a lambda expression that moves values from its environment.\n+\n+```\n+fn ten_times<F>(f: F) where F: Fn(i32) {\n+    for index in 0..10 {\n+        f(index);\n+    }\n+}\n+\n+ten_times(|j| println!(\"hello, {}\", j));\n+\n+let word = \"konnichiwa\".to_owned();\n+ten_times(move |j| println!(\"{}, {}\", word, j));\n+```\n+\n+## Infinite loops\n+\n+A `loop` expression denotes an infinite loop.\n+\n+A `loop` expression may optionally have a _label_. The label is written as\n+a lifetime preceding the loop expression, as in `'foo: loop{ }`. If a\n+label is present, then labeled `break` and `continue` expressions nested\n+within this loop may exit out of this loop or return control to its head.\n+See [break expressions](#break-expressions) and [continue\n+expressions](#continue-expressions).\n+\n+## `break` expressions\n+\n+A `break` expression has an optional _label_. If the label is absent, then\n+executing a `break` expression immediately terminates the innermost loop\n+enclosing it. It is only permitted in the body of a loop. If the label is\n+present, then `break 'foo` terminates the loop with label `'foo`, which need not\n+be the innermost label enclosing the `break` expression, but must enclose it.\n+\n+## `continue` expressions\n+\n+A `continue` expression has an optional _label_. If the label is absent, then\n+executing a `continue` expression immediately terminates the current iteration\n+of the innermost loop enclosing it, returning control to the loop *head*. In\n+the case of a `while` loop, the head is the conditional expression controlling\n+the loop. In the case of a `for` loop, the head is the call-expression\n+controlling the loop. If the label is present, then `continue 'foo` returns\n+control to the head of the loop with label `'foo`, which need not be the\n+innermost label enclosing the `continue` expression, but must enclose it.\n+\n+A `continue` expression is only permitted in the body of a loop.\n+\n+## `while` loops\n+\n+A `while` loop begins by evaluating the boolean loop conditional expression.\n+If the loop conditional expression evaluates to `true`, the loop body block\n+executes and control returns to the loop conditional expression. If the loop\n+conditional expression evaluates to `false`, the `while` expression completes.\n+\n+An example:\n+\n+```\n+let mut i = 0;\n+\n+while i < 10 {\n+    println!(\"hello\");\n+    i = i + 1;\n+}\n+```\n+\n+Like `loop` expressions, `while` loops can be controlled with `break` or\n+`continue`, and may optionally have a _label_. See [infinite\n+loops](#infinite-loops), [break expressions](#break-expressions), and\n+[continue expressions](#continue-expressions) for more information.\n+\n+## `for` expressions\n+\n+A `for` expression is a syntactic construct for looping over elements provided\n+by an implementation of `std::iter::IntoIterator`.\n+\n+An example of a `for` loop over the contents of an array:\n+\n+```\n+# type Foo = i32;\n+# fn bar(f: &Foo) { }\n+# let a = 0;\n+# let b = 0;\n+# let c = 0;\n+\n+let v: &[Foo] = &[a, b, c];\n+\n+for e in v {\n+    bar(e);\n+}\n+```\n+\n+An example of a for loop over a series of integers:\n+\n+```\n+# fn bar(b:usize) { }\n+for i in 0..256 {\n+    bar(i);\n+}\n+```\n+\n+Like `loop` expressions, `for` loops can be controlled with `break` or\n+`continue`, and may optionally have a _label_. See [infinite\n+loops](#infinite-loops), [break expressions](#break-expressions), and\n+[continue expressions](#continue-expressions) for more information.\n+\n+## `if` expressions\n+\n+An `if` expression is a conditional branch in program control. The form of an\n+`if` expression is a condition expression, followed by a consequent block, any\n+number of `else if` conditions and blocks, and an optional trailing `else`\n+block. The condition expressions must have type `bool`. If a condition\n+expression evaluates to `true`, the consequent block is executed and any\n+subsequent `else if` or `else` block is skipped. If a condition expression\n+evaluates to `false`, the consequent block is skipped and any subsequent `else\n+if` condition is evaluated. If all `if` and `else if` conditions evaluate to\n+`false` then any `else` block is executed.\n+\n+## `match` expressions\n+\n+A `match` expression branches on a *pattern*. The exact form of matching that\n+occurs depends on the pattern. Patterns consist of some combination of\n+literals, destructured arrays or enum constructors, structs and tuples,\n+variable binding specifications, wildcards (`..`), and placeholders (`_`). A\n+`match` expression has a *head expression*, which is the value to compare to\n+the patterns. The type of the patterns must equal the type of the head\n+expression.\n+\n+In a pattern whose head expression has an `enum` type, a placeholder (`_`)\n+stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n+fields of a particular variant.\n+\n+A `match` behaves differently depending on whether or not the head expression\n+is an [lvalue or an rvalue](#lvalues-rvalues-and-temporaries). If the head\n+expression is an rvalue, it is first evaluated into a temporary location, and\n+the resulting value is sequentially compared to the patterns in the arms until\n+a match is found. The first arm with a matching pattern is chosen as the branch\n+target of the `match`, any variables bound by the pattern are assigned to local\n+variables in the arm's block, and control enters the block.\n+\n+When the head expression is an lvalue, the match does not allocate a temporary\n+location (however, a by-value binding may copy or move from the lvalue). When\n+possible, it is preferable to match on lvalues, as the lifetime of these\n+matches inherits the lifetime of the lvalue, rather than being restricted to\n+the inside of the match.\n+\n+An example of a `match` expression:\n+\n+```\n+let x = 1;\n+\n+match x {\n+    1 => println!(\"one\"),\n+    2 => println!(\"two\"),\n+    3 => println!(\"three\"),\n+    4 => println!(\"four\"),\n+    5 => println!(\"five\"),\n+    _ => println!(\"something else\"),\n+}\n+```\n+\n+Patterns that bind variables default to binding to a copy or move of the\n+matched value (depending on the matched value's type). This can be changed to\n+bind to a reference by using the `ref` keyword, or to a mutable reference using\n+`ref mut`.\n+\n+Subpatterns can also be bound to variables by the use of the syntax `variable @\n+subpattern`. For example:\n+\n+```\n+let x = 1;\n+\n+match x {\n+    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n+}\n+```\n+\n+Patterns can also dereference pointers by using the `&`, `&mut` and `box`\n+symbols, as appropriate. For example, these two matches on `x: &i32` are\n+equivalent:\n+\n+```\n+# let x = &3;\n+let y = match *x { 0 => \"zero\", _ => \"some\" };\n+let z = match x { &0 => \"zero\", _ => \"some\" };\n+\n+assert_eq!(y, z);\n+```\n+\n+Multiple match patterns may be joined with the `|` operator. A range of values\n+may be specified with `...`. For example:\n+\n+```\n+# let x = 2;\n+\n+let message = match x {\n+    0 | 1  => \"not many\",\n+    2 ... 9 => \"a few\",\n+    _      => \"lots\"\n+};\n+```\n+\n+Range patterns only work on scalar types (like integers and characters; not\n+like arrays and structs, which have sub-components). A range pattern may not\n+be a sub-range of another range pattern inside the same `match`.\n+\n+Finally, match patterns can accept *pattern guards* to further refine the\n+criteria for matching a case. Pattern guards appear after the pattern and\n+consist of a bool-typed expression following the `if` keyword. A pattern guard\n+may refer to the variables bound within the pattern they follow.\n+\n+```\n+# let maybe_digit = Some(0);\n+# fn process_digit(i: i32) { }\n+# fn process_other(i: i32) { }\n+\n+let message = match maybe_digit {\n+    Some(x) if x < 10 => process_digit(x),\n+    Some(x) => process_other(x),\n+    None => panic!(),\n+};\n+```\n+\n+## `if let` expressions\n+\n+An `if let` expression is semantically identical to an `if` expression but in\n+place of a condition expression it expects a `let` statement with a refutable\n+pattern. If the value of the expression on the right hand side of the `let`\n+statement matches the pattern, the corresponding block will execute, otherwise\n+flow proceeds to the first `else` block that follows.\n+\n+```\n+let dish = (\"Ham\", \"Eggs\");\n+\n+// this body will be skipped because the pattern is refuted\n+if let (\"Bacon\", b) = dish {\n+    println!(\"Bacon is served with {}\", b);\n+}\n+\n+// this body will execute\n+if let (\"Ham\", b) = dish {\n+    println!(\"Ham is served with {}\", b);\n+}\n+```\n+\n+## `while let` loops\n+\n+A `while let` loop is semantically identical to a `while` loop but in place of\n+a condition expression it expects `let` statement with a refutable pattern. If\n+the value of the expression on the right hand side of the `let` statement\n+matches the pattern, the loop body block executes and control returns to the\n+pattern matching statement. Otherwise, the while expression completes.\n+\n+## `return` expressions\n+\n+Return expressions are denoted with the keyword `return`. Evaluating a `return`\n+expression moves its argument into the designated output location for the\n+current function call, destroys the current function activation frame, and\n+transfers control to the caller frame.\n+\n+An example of a `return` expression:\n+\n+```\n+fn max(a: i32, b: i32) -> i32 {\n+    if a > b {\n+        return a;\n+    }\n+    return b;\n+}\n+```"}, {"sha": "ea129cd15f02662e98bdb08f0c25bc099212f332", "filename": "src/doc/reference/src/identifiers.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fidentifiers.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fidentifiers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fidentifiers.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,23 @@\n+# Identifiers\n+\n+An identifier is any nonempty Unicode[^non_ascii_idents] string of the following form:\n+\n+[^non_ascii_idents]: Non-ASCII characters in identifiers are currently feature\n+  gated. This is expected to improve soon.\n+\n+Either\n+\n+   * The first character has property `XID_start`\n+   * The remaining characters have property `XID_continue`\n+\n+Or\n+\n+   * The first character is `_`\n+   * The identifier is more than one character, `_` alone is not an identifier\n+   * The remaining characters have property `XID_continue`\n+\n+that does _not_ occur in the set of [keywords][keywords].\n+\n+> **Note**: `XID_start` and `XID_continue` as character properties cover the\n+> character ranges used to form the more familiar C and Java language-family\n+> identifiers."}, {"sha": "a4d014ab9426fa5c5650d6882944d6bdb509d634", "filename": "src/doc/reference/src/influences.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Finfluences.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Finfluences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Finfluences.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,22 @@\n+# Influences\n+\n+Rust is not a particularly original language, with design elements coming from\n+a wide range of sources. Some of these are listed below (including elements\n+that have since been removed):\n+\n+* SML, OCaml: algebraic data types, pattern matching, type inference,\n+  semicolon statement separation\n+* C++: references, RAII, smart pointers, move semantics, monomorphization,\n+  memory model\n+* ML Kit, Cyclone: region based memory management\n+* Haskell (GHC): typeclasses, type families\n+* Newsqueak, Alef, Limbo: channels, concurrency\n+* Erlang: message passing, thread failure, ~~linked thread failure~~,\n+  ~~lightweight concurrency~~\n+* Swift: optional bindings\n+* Scheme: hygienic macros\n+* C#: attributes\n+* Ruby: ~~block syntax~~\n+* NIL, Hermes: ~~typestate~~\n+* [Unicode Annex #31](http://www.unicode.org/reports/tr31/): identifier and\n+  pattern syntax"}, {"sha": "0dbba4be92a0522043716ef02cc9be1f4f9f1384", "filename": "src/doc/reference/src/input-format.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Finput-format.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Finput-format.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Finput-format.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,10 @@\n+# Input format\n+\n+Rust input is interpreted as a sequence of Unicode code points encoded in UTF-8.\n+Most Rust grammar rules are defined in terms of printable ASCII-range\n+code points, but a small number are defined in terms of Unicode properties or\n+explicit code point lists. [^inputformat]\n+\n+[^inputformat]: Substitute definitions for the special Unicode productions are\n+  provided to the grammar verifier, restricted to ASCII range, when verifying the\n+  grammar in this document."}, {"sha": "043c62dace38b3d3214ce1a1f0764c465b489682", "filename": "src/doc/reference/src/introduction.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fintroduction.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fintroduction.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fintroduction.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,31 @@\n+# Introduction\n+\n+This document is the primary reference for the Rust programming language. It\n+provides three kinds of material:\n+\n+  - Chapters that informally describe each language construct and their use.\n+  - Chapters that informally describe the memory model, concurrency model,\n+    runtime services, linkage model and debugging facilities.\n+  - Appendix chapters providing rationale and references to languages that\n+    influenced the design.\n+\n+This document does not serve as an introduction to the language. Background\n+familiarity with the language is assumed. A separate [book] is available to\n+help acquire such background familiarity.\n+\n+This document also does not serve as a reference to the [standard] library\n+included in the language distribution. Those libraries are documented\n+separately by extracting documentation attributes from their source code. Many\n+of the features that one might expect to be language features are library\n+features in Rust, so what you're looking for may be there, not here.\n+\n+Finally, this document is not normative. It may include details that are\n+specific to `rustc` itself, and should not be taken as a specification for\n+the Rust language. We intend to produce such a document someday, but this\n+is what we have for now.\n+\n+You may also be interested in the [grammar].\n+\n+[book]: book/index.html\n+[standard]: std/index.html\n+[grammar]: grammar.html"}, {"sha": "8c3441ec2bb3e3091931de55e13301d9cc9d3f98", "filename": "src/doc/reference/src/items-and-attributes.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fitems-and-attributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fitems-and-attributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fitems-and-attributes.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,4 @@\n+# Items and attributes\n+\n+Crates contain [items](#items), each of which may have some number of\n+[attributes](#attributes) attached to it."}, {"sha": "0b4421de2a9653d63d105d59d418cc9369e55964", "filename": "src/doc/reference/src/items.md", "status": "added", "additions": 678, "deletions": 0, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fitems.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fitems.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fitems.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,678 @@\n+# Items\n+\n+An _item_ is a component of a crate. Items are organized within a crate by a\n+nested set of [modules](#modules). Every crate has a single \"outermost\"\n+anonymous module; all further items within the crate have [paths](#paths)\n+within the module tree of the crate.\n+\n+Items are entirely determined at compile-time, generally remain fixed during\n+execution, and may reside in read-only memory.\n+\n+There are several kinds of item:\n+\n+* [`extern crate` declarations](#extern-crate-declarations)\n+* [`use` declarations](#use-declarations)\n+* [modules](#modules)\n+* [function definitions](#functions)\n+* [`extern` blocks](#external-blocks)\n+* [type definitions](grammar.html#type-definitions)\n+* [struct definitions](#structs)\n+* [enumeration definitions](#enumerations)\n+* [constant items](#constant-items)\n+* [static items](#static-items)\n+* [trait definitions](#traits)\n+* [implementations](#implementations)\n+\n+Some items form an implicit scope for the declaration of sub-items. In other\n+words, within a function or module, declarations of items can (in many cases)\n+be mixed with the statements, control blocks, and similar artifacts that\n+otherwise compose the item body. The meaning of these scoped items is the same\n+as if the item was declared outside the scope &mdash; it is still a static item\n+&mdash; except that the item's *path name* within the module namespace is\n+qualified by the name of the enclosing item, or is private to the enclosing\n+item (in the case of functions). The grammar specifies the exact locations in\n+which sub-item declarations may appear.\n+\n+## Type Parameters\n+\n+All items except modules, constants and statics may be *parameterized* by type.\n+Type parameters are given as a comma-separated list of identifiers enclosed in\n+angle brackets (`<...>`), after the name of the item and before its definition.\n+The type parameters of an item are considered \"part of the name\", not part of\n+the type of the item. A referencing [path](#paths) must (in principle) provide\n+type arguments as a list of comma-separated types enclosed within angle\n+brackets, in order to refer to the type-parameterized item. In practice, the\n+type-inference system can usually infer such argument types from context. There\n+are no general type-parametric types, only type-parametric items. That is, Rust\n+has no notion of type abstraction: there are no higher-ranked (or \"forall\") types\n+abstracted over other types, though higher-ranked types do exist for lifetimes.\n+\n+## Modules\n+\n+A module is a container for zero or more [items](#items).\n+\n+A _module item_ is a module, surrounded in braces, named, and prefixed with the\n+keyword `mod`. A module item introduces a new, named module into the tree of\n+modules making up a crate. Modules can nest arbitrarily.\n+\n+An example of a module:\n+\n+```\n+mod math {\n+    type Complex = (f64, f64);\n+    fn sin(f: f64) -> f64 {\n+        /* ... */\n+# panic!();\n+    }\n+    fn cos(f: f64) -> f64 {\n+        /* ... */\n+# panic!();\n+    }\n+    fn tan(f: f64) -> f64 {\n+        /* ... */\n+# panic!();\n+    }\n+}\n+```\n+\n+Modules and types share the same namespace. Declaring a named type with\n+the same name as a module in scope is forbidden: that is, a type definition,\n+trait, struct, enumeration, or type parameter can't shadow the name of a module\n+in scope, or vice versa.\n+\n+A module without a body is loaded from an external file, by default with the\n+same name as the module, plus the `.rs` extension. When a nested submodule is\n+loaded from an external file, it is loaded from a subdirectory path that\n+mirrors the module hierarchy.\n+\n+```{.ignore}\n+// Load the `vec` module from `vec.rs`\n+mod vec;\n+\n+mod thread {\n+    // Load the `local_data` module from `thread/local_data.rs`\n+    // or `thread/local_data/mod.rs`.\n+    mod local_data;\n+}\n+```\n+\n+The directories and files used for loading external file modules can be\n+influenced with the `path` attribute.\n+\n+```{.ignore}\n+#[path = \"thread_files\"]\n+mod thread {\n+    // Load the `local_data` module from `thread_files/tls.rs`\n+    #[path = \"tls.rs\"]\n+    mod local_data;\n+}\n+```\n+\n+### Extern crate declarations\n+\n+An _`extern crate` declaration_ specifies a dependency on an external crate.\n+The external crate is then bound into the declaring scope as the `ident`\n+provided in the `extern_crate_decl`.\n+\n+The external crate is resolved to a specific `soname` at compile time, and a\n+runtime linkage requirement to that `soname` is passed to the linker for\n+loading at runtime. The `soname` is resolved at compile time by scanning the\n+compiler's library path and matching the optional `crateid` provided against\n+the `crateid` attributes that were declared on the external crate when it was\n+compiled. If no `crateid` is provided, a default `name` attribute is assumed,\n+equal to the `ident` given in the `extern_crate_decl`.\n+\n+Three examples of `extern crate` declarations:\n+\n+```{.ignore}\n+extern crate pcre;\n+\n+extern crate std; // equivalent to: extern crate std as std;\n+\n+extern crate std as ruststd; // linking to 'std' under another name\n+```\n+\n+When naming Rust crates, hyphens are disallowed. However, Cargo packages may\n+make use of them. In such case, when `Cargo.toml` doesn't specify a crate name,\n+Cargo will transparently replace `-` with `_` (Refer to [RFC 940] for more\n+details).\n+\n+Here is an example:\n+\n+```{.ignore}\n+// Importing the Cargo package hello-world\n+extern crate hello_world; // hyphen replaced with an underscore\n+```\n+\n+[RFC 940]: https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md\n+\n+### Use declarations\n+\n+A _use declaration_ creates one or more local name bindings synonymous with\n+some other [path](#paths). Usually a `use` declaration is used to shorten the\n+path required to refer to a module item. These declarations may appear in\n+[modules](#modules) and [blocks](grammar.html#block-expressions), usually at the top.\n+\n+> **Note**: Unlike in many languages,\n+> `use` declarations in Rust do *not* declare linkage dependency with external crates.\n+> Rather, [`extern crate` declarations](#extern-crate-declarations) declare linkage dependencies.\n+\n+Use declarations support a number of convenient shortcuts:\n+\n+* Rebinding the target name as a new local name, using the syntax `use p::q::r as x;`\n+* Simultaneously binding a list of paths differing only in their final element,\n+  using the glob-like brace syntax `use a::b::{c,d,e,f};`\n+* Binding all paths matching a given prefix, using the asterisk wildcard syntax\n+  `use a::b::*;`\n+* Simultaneously binding a list of paths differing only in their final element\n+  and their immediate parent module, using the `self` keyword, such as\n+  `use a::b::{self, c, d};`\n+\n+An example of `use` declarations:\n+\n+```rust\n+use std::option::Option::{Some, None};\n+use std::collections::hash_map::{self, HashMap};\n+\n+fn foo<T>(_: T){}\n+fn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n+\n+fn main() {\n+    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n+    // std::option::Option::None]);'\n+    foo(vec![Some(1.0f64), None]);\n+\n+    // Both `hash_map` and `HashMap` are in scope.\n+    let map1 = HashMap::new();\n+    let map2 = hash_map::HashMap::new();\n+    bar(map1, map2);\n+}\n+```\n+\n+Like items, `use` declarations are private to the containing module, by\n+default. Also like items, a `use` declaration can be public, if qualified by\n+the `pub` keyword. Such a `use` declaration serves to _re-export_ a name. A\n+public `use` declaration can therefore _redirect_ some public name to a\n+different target definition: even a definition with a private canonical path,\n+inside a different module. If a sequence of such redirections form a cycle or\n+cannot be resolved unambiguously, they represent a compile-time error.\n+\n+An example of re-exporting:\n+\n+```\n+# fn main() { }\n+mod quux {\n+    pub use quux::foo::{bar, baz};\n+\n+    pub mod foo {\n+        pub fn bar() { }\n+        pub fn baz() { }\n+    }\n+}\n+```\n+\n+In this example, the module `quux` re-exports two public names defined in\n+`foo`.\n+\n+Also note that the paths contained in `use` items are relative to the crate\n+root. So, in the previous example, the `use` refers to `quux::foo::{bar,\n+baz}`, and not simply to `foo::{bar, baz}`. This also means that top-level\n+module declarations should be at the crate root if direct usage of the declared\n+modules within `use` items is desired. It is also possible to use `self` and\n+`super` at the beginning of a `use` item to refer to the current and direct\n+parent modules respectively. All rules regarding accessing declared modules in\n+`use` declarations apply to both module declarations and `extern crate`\n+declarations.\n+\n+An example of what will and will not work for `use` items:\n+\n+```\n+# #![allow(unused_imports)]\n+use foo::baz::foobaz;    // good: foo is at the root of the crate\n+\n+mod foo {\n+\n+    mod example {\n+        pub mod iter {}\n+    }\n+\n+    use foo::example::iter; // good: foo is at crate root\n+//  use example::iter;      // bad:  example is not at the crate root\n+    use self::baz::foobaz;  // good: self refers to module 'foo'\n+    use foo::bar::foobar;   // good: foo is at crate root\n+\n+    pub mod bar {\n+        pub fn foobar() { }\n+    }\n+\n+    pub mod baz {\n+        use super::bar::foobar; // good: super refers to module 'foo'\n+        pub fn foobaz() { }\n+    }\n+}\n+\n+fn main() {}\n+```\n+\n+## Functions\n+\n+A _function item_ defines a sequence of [statements](#statements) and a\n+final [expression](#expressions), along with a name and a set of\n+parameters. Other than a name, all these are optional.\n+Functions are declared with the keyword `fn`. Functions may declare a\n+set of *input* [*variables*](#variables) as parameters, through which the caller\n+passes arguments into the function, and the *output* [*type*](#types)\n+of the value the function will return to its caller on completion.\n+\n+A function may also be copied into a first-class *value*, in which case the\n+value has the corresponding [*function type*](#function-types), and can be used\n+otherwise exactly as a function item (with a minor additional cost of calling\n+the function indirectly).\n+\n+Every control path in a function logically ends with a `return` expression or a\n+diverging expression. If the outermost block of a function has a\n+value-producing expression in its final-expression position, that expression is\n+interpreted as an implicit `return` expression applied to the final-expression.\n+\n+An example of a function:\n+\n+```\n+fn add(x: i32, y: i32) -> i32 {\n+    x + y\n+}\n+```\n+\n+As with `let` bindings, function arguments are irrefutable patterns, so any\n+pattern that is valid in a let binding is also valid as an argument.\n+\n+```\n+fn first((value, _): (i32, i32)) -> i32 { value }\n+```\n+\n+\n+### Generic functions\n+\n+A _generic function_ allows one or more _parameterized types_ to appear in its\n+signature. Each type parameter must be explicitly declared in an\n+angle-bracket-enclosed and comma-separated list, following the function name.\n+\n+```rust,ignore\n+// foo is generic over A and B\n+\n+fn foo<A, B>(x: A, y: B) {\n+```\n+\n+Inside the function signature and body, the name of the type parameter can be\n+used as a type name. [Trait](#traits) bounds can be specified for type parameters\n+to allow methods with that trait to be called on values of that type. This is\n+specified using the `where` syntax:\n+\n+```rust,ignore\n+fn foo<T>(x: T) where T: Debug {\n+```\n+\n+When a generic function is referenced, its type is instantiated based on the\n+context of the reference. For example, calling the `foo` function here:\n+\n+```\n+use std::fmt::Debug;\n+\n+fn foo<T>(x: &[T]) where T: Debug {\n+    // details elided\n+    # ()\n+}\n+\n+foo(&[1, 2]);\n+```\n+\n+will instantiate type parameter `T` with `i32`.\n+\n+The type parameters can also be explicitly supplied in a trailing\n+[path](#paths) component after the function name. This might be necessary if\n+there is not sufficient context to determine the type parameters. For example,\n+`mem::size_of::<u32>() == 4`.\n+\n+### Diverging functions\n+\n+A special kind of function can be declared with a `!` character where the\n+output type would normally be. For example:\n+\n+```\n+fn my_err(s: &str) -> ! {\n+    println!(\"{}\", s);\n+    panic!();\n+}\n+```\n+\n+We call such functions \"diverging\" because they never return a value to the\n+caller. Every control path in a diverging function must end with a `panic!()` or\n+a call to another diverging function on every control path. The `!` annotation\n+does *not* denote a type.\n+\n+It might be necessary to declare a diverging function because as mentioned\n+previously, the typechecker checks that every control path in a function ends\n+with a [`return`](#return-expressions) or diverging expression. So, if `my_err`\n+were declared without the `!` annotation, the following code would not\n+typecheck:\n+\n+```\n+# fn my_err(s: &str) -> ! { panic!() }\n+\n+fn f(i: i32) -> i32 {\n+    if i == 42 {\n+        return 42;\n+    }\n+    else {\n+        my_err(\"Bad number!\");\n+    }\n+}\n+```\n+\n+This will not compile without the `!` annotation on `my_err`, since the `else`\n+branch of the conditional in `f` does not return an `i32`, as required by the\n+signature of `f`. Adding the `!` annotation to `my_err` informs the\n+typechecker that, should control ever enter `my_err`, no further type judgments\n+about `f` need to hold, since control will never resume in any context that\n+relies on those judgments. Thus the return type on `f` only needs to reflect\n+the `if` branch of the conditional.\n+\n+### Extern functions\n+\n+Extern functions are part of Rust's foreign function interface, providing the\n+opposite functionality to [external blocks](#external-blocks). Whereas\n+external blocks allow Rust code to call foreign code, extern functions with\n+bodies defined in Rust code _can be called by foreign code_. They are defined\n+in the same way as any other Rust function, except that they have the `extern`\n+modifier.\n+\n+```\n+// Declares an extern fn, the ABI defaults to \"C\"\n+extern fn new_i32() -> i32 { 0 }\n+\n+// Declares an extern fn with \"stdcall\" ABI\n+extern \"stdcall\" fn new_i32_stdcall() -> i32 { 0 }\n+```\n+\n+Unlike normal functions, extern fns have type `extern \"ABI\" fn()`. This is the\n+same type as the functions declared in an extern block.\n+\n+```\n+# extern fn new_i32() -> i32 { 0 }\n+let fptr: extern \"C\" fn() -> i32 = new_i32;\n+```\n+\n+Extern functions may be called directly from Rust code as Rust uses large,\n+contiguous stack segments like C.\n+\n+## Type aliases\n+\n+A _type alias_ defines a new name for an existing [type](#types). Type\n+aliases are declared with the keyword `type`. Every value has a single,\n+specific type, but may implement several different traits, or be compatible with\n+several different type constraints.\n+\n+For example, the following defines the type `Point` as a synonym for the type\n+`(u8, u8)`, the type of pairs of unsigned 8 bit integers:\n+\n+```\n+type Point = (u8, u8);\n+let p: Point = (41, 68);\n+```\n+\n+Currently a type alias to an enum type cannot be used to qualify the\n+constructors:\n+\n+```\n+enum E { A }\n+type F = E;\n+let _: F = E::A;  // OK\n+// let _: F = F::A;  // Doesn't work\n+```\n+\n+## Structs\n+\n+A _struct_ is a nominal [struct type](#struct-types) defined with the\n+keyword `struct`.\n+\n+An example of a `struct` item and its use:\n+\n+```\n+struct Point {x: i32, y: i32}\n+let p = Point {x: 10, y: 11};\n+let px: i32 = p.x;\n+```\n+\n+A _tuple struct_ is a nominal [tuple type](#tuple-types), also defined with\n+the keyword `struct`. For example:\n+\n+```\n+struct Point(i32, i32);\n+let p = Point(10, 11);\n+let px: i32 = match p { Point(x, _) => x };\n+```\n+\n+A _unit-like struct_ is a struct without any fields, defined by leaving off\n+the list of fields entirely. Such a struct implicitly defines a constant of\n+its type with the same name. For example:\n+\n+```\n+struct Cookie;\n+let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n+```\n+\n+is equivalent to\n+\n+```\n+struct Cookie {}\n+const Cookie: Cookie = Cookie {};\n+let c = [Cookie, Cookie {}, Cookie, Cookie {}];\n+```\n+\n+The precise memory layout of a struct is not specified. One can specify a\n+particular layout using the [`repr` attribute](#ffi-attributes).\n+\n+## Enumerations\n+\n+An _enumeration_ is a simultaneous definition of a nominal [enumerated\n+type](#enumerated-types) as well as a set of *constructors*, that can be used\n+to create or pattern-match values of the corresponding enumerated type.\n+\n+Enumerations are declared with the keyword `enum`.\n+\n+An example of an `enum` item and its use:\n+\n+```\n+enum Animal {\n+    Dog,\n+    Cat,\n+}\n+\n+let mut a: Animal = Animal::Dog;\n+a = Animal::Cat;\n+```\n+\n+Enumeration constructors can have either named or unnamed fields:\n+\n+```rust\n+enum Animal {\n+    Dog (String, f64),\n+    Cat { name: String, weight: f64 },\n+}\n+\n+let mut a: Animal = Animal::Dog(\"Cocoa\".to_string(), 37.2);\n+a = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n+```\n+\n+In this example, `Cat` is a _struct-like enum variant_,\n+whereas `Dog` is simply called an enum variant.\n+\n+Each enum value has a _discriminant_ which is an integer associated to it. You\n+can specify it explicitly:\n+\n+```\n+enum Foo {\n+    Bar = 123,\n+}\n+```\n+\n+The right hand side of the specification is interpreted as an `isize` value,\n+but the compiler is allowed to use a smaller type in the actual memory layout.\n+The [`repr` attribute](#ffi-attributes) can be added in order to change\n+the type of the right hand side and specify the memory layout.\n+\n+If a discriminant isn't specified, they start at zero, and add one for each\n+variant, in order.\n+\n+You can cast an enum to get its discriminant:\n+\n+```\n+# enum Foo { Bar = 123 }\n+let x = Foo::Bar as u32; // x is now 123u32\n+```\n+\n+This only works as long as none of the variants have data attached. If\n+it were `Bar(i32)`, this is disallowed.\n+\n+## Constant items\n+\n+A *constant item* is a named _constant value_ which is not associated with a\n+specific memory location in the program. Constants are essentially inlined\n+wherever they are used, meaning that they are copied directly into the relevant\n+context when used. References to the same constant are not necessarily\n+guaranteed to refer to the same memory address.\n+\n+Constant values must not have destructors, and otherwise permit most forms of\n+data. Constants may refer to the address of other constants, in which case the\n+address will have elided lifetimes where applicable, otherwise \u2013 in most cases \u2013\n+defaulting to the `static` lifetime. (See below on [static lifetime elision].)\n+The compiler is, however, still at liberty to translate the constant many times,\n+so the address referred to may not be stable.\n+\n+[static lifetime elision]: #static-lifetime-elision\n+\n+Constants must be explicitly typed. The type may be `bool`, `char`, a number, or\n+a type derived from those primitive types. The derived types are references with\n+the `static` lifetime, fixed-size arrays, tuples, enum variants, and structs.\n+\n+```rust\n+const BIT1: u32 = 1 << 0;\n+const BIT2: u32 = 1 << 1;\n+\n+const BITS: [u32; 2] = [BIT1, BIT2];\n+const STRING: &'static str = \"bitstring\";\n+\n+struct BitsNStrings<'a> {\n+    mybits: [u32; 2],\n+    mystring: &'a str,\n+}\n+\n+const BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n+    mybits: BITS,\n+    mystring: STRING,\n+};\n+```\n+\n+## Static items\n+\n+A *static item* is similar to a *constant*, except that it represents a precise\n+memory location in the program. A static is never \"inlined\" at the usage site,\n+and all references to it refer to the same memory location. Static items have\n+the `static` lifetime, which outlives all other lifetimes in a Rust program.\n+Static items may be placed in read-only memory if they do not contain any\n+interior mutability.\n+\n+Statics may contain interior mutability through the `UnsafeCell` language item.\n+All access to a static is safe, but there are a number of restrictions on\n+statics:\n+\n+* Statics may not contain any destructors.\n+* The types of static values must ascribe to `Sync` to allow thread-safe access.\n+* Statics may not refer to other statics by value, only by reference.\n+* Constants cannot refer to statics.\n+\n+Constants should in general be preferred over statics, unless large amounts of\n+data are being stored, or single-address and mutability properties are required.\n+\n+### Mutable statics\n+\n+If a static item is declared with the `mut` keyword, then it is allowed to\n+be modified by the program. One of Rust's goals is to make concurrency bugs\n+hard to run into, and this is obviously a very large source of race conditions\n+or other bugs. For this reason, an `unsafe` block is required when either\n+reading or writing a mutable static variable. Care should be taken to ensure\n+that modifications to a mutable static are safe with respect to other threads\n+running in the same process.\n+\n+Mutable statics are still very useful, however. They can be used with C\n+libraries and can also be bound from C libraries (in an `extern` block).\n+\n+```rust\n+# fn atomic_add(_: &mut u32, _: u32) -> u32 { 2 }\n+\n+static mut LEVELS: u32 = 0;\n+\n+// This violates the idea of no shared state, and this doesn't internally\n+// protect against races, so this function is `unsafe`\n+unsafe fn bump_levels_unsafe1() -> u32 {\n+    let ret = LEVELS;\n+    LEVELS += 1;\n+    return ret;\n+}\n+\n+// Assuming that we have an atomic_add function which returns the old value,\n+// this function is \"safe\" but the meaning of the return value may not be what\n+// callers expect, so it's still marked as `unsafe`\n+unsafe fn bump_levels_unsafe2() -> u32 {\n+    return atomic_add(&mut LEVELS, 1);\n+}\n+```\n+\n+Mutable statics have the same restrictions as normal statics, except that the\n+type of the value is not required to ascribe to `Sync`.\n+\n+### `'static` lifetime elision\n+\n+[Unstable] Both constant and static declarations of reference types have\n+*implicit* `'static` lifetimes unless an explicit lifetime is specified. As\n+such, the constant declarations involving `'static` above may be written\n+without the lifetimes. Returning to our previous example:\n+\n+```rust\n+# #![feature(static_in_const)]\n+const BIT1: u32 = 1 << 0;\n+const BIT2: u32 = 1 << 1;\n+\n+const BITS: [u32; 2] = [BIT1, BIT2];\n+const STRING: &str = \"bitstring\";\n+\n+struct BitsNStrings<'a> {\n+    mybits: [u32; 2],\n+    mystring: &'a str,\n+}\n+\n+const BITS_N_STRINGS: BitsNStrings = BitsNStrings {\n+    mybits: BITS,\n+    mystring: STRING,\n+};\n+```\n+\n+Note that if the `static` or `const` items include function or closure\n+references, which themselves include references, the compiler will first try the\n+standard elision rules ([see discussion in the nomicon][elision-nomicon]). If it\n+is unable to resolve the lifetimes by its usual rules, it will default to using\n+the `'static` lifetime. By way of example:\n+\n+[elision-nomicon]: https://doc.rust-lang.org/nomicon/lifetime-elision.html\n+\n+```rust,ignore\n+// Resolved as `fn<'a>(&'a str) -> &'a str`.\n+const RESOLVED_SINGLE: fn(&str) -> &str = ..\n+\n+// Resolved as `Fn<'a, 'b, 'c>(&'a Foo, &'b Bar, &'c Baz) -> usize`.\n+const RESOLVED_MULTIPLE: Fn(&Foo, &Bar, &Baz) -> usize = ..\n+\n+// There is insufficient information to bound the return reference lifetime\n+// relative to the argument lifetimes, so the signature is resolved as\n+// `Fn(&'static Foo, &'static Bar) -> &'static Baz`.\n+const RESOLVED_STATIC: Fn(&Foo, &Bar) -> &Baz = ..\n+```"}, {"sha": "5e1388e0d5a2bc153ef206cf0edbbeb0431cc7d7", "filename": "src/doc/reference/src/lexical-structure.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Flexical-structure.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Flexical-structure.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Flexical-structure.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1 @@\n+# Lexical structure"}, {"sha": "8ba9e9143ae8101e0d44308db470c0933b57733a", "filename": "src/doc/reference/src/linkage.md", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Flinkage.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Flinkage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Flinkage.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,125 @@\n+# Linkage\n+\n+The Rust compiler supports various methods to link crates together both\n+statically and dynamically. This section will explore the various methods to\n+link Rust crates together, and more information about native libraries can be\n+found in the [FFI section of the book][ffi].\n+\n+In one session of compilation, the compiler can generate multiple artifacts\n+through the usage of either command line flags or the `crate_type` attribute.\n+If one or more command line flags are specified, all `crate_type` attributes will\n+be ignored in favor of only building the artifacts specified by command line.\n+\n+* `--crate-type=bin`, `#[crate_type = \"bin\"]` - A runnable executable will be\n+  produced. This requires that there is a `main` function in the crate which\n+  will be run when the program begins executing. This will link in all Rust and\n+  native dependencies, producing a distributable binary.\n+\n+* `--crate-type=lib`, `#[crate_type = \"lib\"]` - A Rust library will be produced.\n+  This is an ambiguous concept as to what exactly is produced because a library\n+  can manifest itself in several forms. The purpose of this generic `lib` option\n+  is to generate the \"compiler recommended\" style of library. The output library\n+  will always be usable by rustc, but the actual type of library may change from\n+  time-to-time. The remaining output types are all different flavors of\n+  libraries, and the `lib` type can be seen as an alias for one of them (but the\n+  actual one is compiler-defined).\n+\n+* `--crate-type=dylib`, `#[crate_type = \"dylib\"]` - A dynamic Rust library will\n+  be produced. This is different from the `lib` output type in that this forces\n+  dynamic library generation. The resulting dynamic library can be used as a\n+  dependency for other libraries and/or executables. This output type will\n+  create `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\n+  windows.\n+\n+* `--crate-type=staticlib`, `#[crate_type = \"staticlib\"]` - A static system\n+  library will be produced. This is different from other library outputs in that\n+  the Rust compiler will never attempt to link to `staticlib` outputs. The\n+  purpose of this output type is to create a static library containing all of\n+  the local crate's code along with all upstream dependencies. The static\n+  library is actually a `*.a` archive on linux and osx and a `*.lib` file on\n+  windows. This format is recommended for use in situations such as linking\n+  Rust code into an existing non-Rust application because it will not have\n+  dynamic dependencies on other Rust code.\n+\n+* `--crate-type=cdylib`, `#[crate_type = \"cdylib\"]` - A dynamic system\n+  library will be produced.  This is used when compiling Rust code as\n+  a dynamic library to be loaded from another language.  This output type will\n+  create `*.so` files on Linux, `*.dylib` files on OSX, and `*.dll` files on\n+  Windows.\n+\n+* `--crate-type=rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be\n+  produced. This is used as an intermediate artifact and can be thought of as a\n+  \"static Rust library\". These `rlib` files, unlike `staticlib` files, are\n+  interpreted by the Rust compiler in future linkage. This essentially means\n+  that `rustc` will look for metadata in `rlib` files like it looks for metadata\n+  in dynamic libraries. This form of output is used to produce statically linked\n+  executables as well as `staticlib` outputs.\n+\n+* `--crate-type=proc-macro`, `#[crate_type = \"proc-macro\"]` - The output\n+  produced is not specified, but if a `-L` path is provided to it then the\n+  compiler will recognize the output artifacts as a macro and it can be loaded\n+  for a program. If a crate is compiled with the `proc-macro` crate type it\n+  will forbid exporting any items in the crate other than those functions\n+  tagged `#[proc_macro_derive]` and those functions must also be placed at the\n+  crate root. Finally, the compiler will automatically set the\n+  `cfg(proc_macro)` annotation whenever any crate type of a compilation is the\n+  `proc-macro` crate type.\n+\n+Note that these outputs are stackable in the sense that if multiple are\n+specified, then the compiler will produce each form of output at once without\n+having to recompile. However, this only applies for outputs specified by the\n+same method. If only `crate_type` attributes are specified, then they will all\n+be built, but if one or more `--crate-type` command line flags are specified,\n+then only those outputs will be built.\n+\n+With all these different kinds of outputs, if crate A depends on crate B, then\n+the compiler could find B in various different forms throughout the system. The\n+only forms looked for by the compiler, however, are the `rlib` format and the\n+dynamic library format. With these two options for a dependent library, the\n+compiler must at some point make a choice between these two formats. With this\n+in mind, the compiler follows these rules when determining what format of\n+dependencies will be used:\n+\n+1. If a static library is being produced, all upstream dependencies are\n+   required to be available in `rlib` formats. This requirement stems from the\n+   reason that a dynamic library cannot be converted into a static format.\n+\n+   Note that it is impossible to link in native dynamic dependencies to a static\n+   library, and in this case warnings will be printed about all unlinked native\n+   dynamic dependencies.\n+\n+2. If an `rlib` file is being produced, then there are no restrictions on what\n+   format the upstream dependencies are available in. It is simply required that\n+   all upstream dependencies be available for reading metadata from.\n+\n+   The reason for this is that `rlib` files do not contain any of their upstream\n+   dependencies. It wouldn't be very efficient for all `rlib` files to contain a\n+   copy of `libstd.rlib`!\n+\n+3. If an executable is being produced and the `-C prefer-dynamic` flag is not\n+   specified, then dependencies are first attempted to be found in the `rlib`\n+   format. If some dependencies are not available in an rlib format, then\n+   dynamic linking is attempted (see below).\n+\n+4. If a dynamic library or an executable that is being dynamically linked is\n+   being produced, then the compiler will attempt to reconcile the available\n+   dependencies in either the rlib or dylib format to create a final product.\n+\n+   A major goal of the compiler is to ensure that a library never appears more\n+   than once in any artifact. For example, if dynamic libraries B and C were\n+   each statically linked to library A, then a crate could not link to B and C\n+   together because there would be two copies of A. The compiler allows mixing\n+   the rlib and dylib formats, but this restriction must be satisfied.\n+\n+   The compiler currently implements no method of hinting what format a library\n+   should be linked with. When dynamically linking, the compiler will attempt to\n+   maximize dynamic dependencies while still allowing some dependencies to be\n+   linked in via an rlib.\n+\n+   For most situations, having all libraries available as a dylib is recommended\n+   if dynamically linking. For other situations, the compiler will emit a\n+   warning if it is unable to determine which formats to link each library with.\n+\n+In general, `--crate-type=bin` or `--crate-type=lib` should be sufficient for\n+all compilation needs, and the other options are just available if more\n+fine-grained control is desired over the output format of a Rust crate."}, {"sha": "916e6c891abf98f2ba72bcb97af9ab425fc0068b", "filename": "src/doc/reference/src/macros-by-example.md", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmacros-by-example.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmacros-by-example.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmacros-by-example.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,78 @@\n+# Macros By Example\n+\n+`macro_rules` allows users to define syntax extension in a declarative way.  We\n+call such extensions \"macros by example\" or simply \"macros\".\n+\n+Currently, macros can expand to expressions, statements, items, or patterns.\n+\n+(A `sep_token` is any token other than `*` and `+`. A `non_special_token` is\n+any token other than a delimiter or `$`.)\n+\n+The macro expander looks up macro invocations by name, and tries each macro\n+rule in turn. It transcribes the first successful match. Matching and\n+transcription are closely related to each other, and we will describe them\n+together.\n+\n+The macro expander matches and transcribes every token that does not begin with\n+a `$` literally, including delimiters. For parsing reasons, delimiters must be\n+balanced, but they are otherwise not special.\n+\n+In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the Rust\n+syntax named by _designator_. Valid designators are:\n+\n+* `item`: an [item](#items)\n+* `block`: a [block](#block-expressions)\n+* `stmt`: a [statement](#statements)\n+* `pat`: a [pattern](#match-expressions)\n+* `expr`: an [expression](#expressions)\n+* `ty`: a [type](#types)\n+* `ident`: an [identifier](#identifiers)\n+* `path`: a [path](#paths)\n+* `tt`: a token tree (a single [token](#tokens) or a sequence of token trees surrounded\n+  by matching `()`, `[]`, or `{}`)\n+* `meta`: the contents of an [attribute](#attributes)\n+\n+In the transcriber, the\n+designator is already known, and so only the name of a matched nonterminal comes\n+after the dollar sign.\n+\n+In both the matcher and transcriber, the Kleene star-like operator indicates\n+repetition. The Kleene star operator consists of `$` and parentheses, optionally\n+followed by a separator token, followed by `*` or `+`. `*` means zero or more\n+repetitions, `+` means at least one repetition. The parentheses are not matched or\n+transcribed. On the matcher side, a name is bound to _all_ of the names it\n+matches, in a structure that mimics the structure of the repetition encountered\n+on a successful match. The job of the transcriber is to sort that structure\n+out.\n+\n+The rules for transcription of these repetitions are called \"Macro By Example\".\n+Essentially, one \"layer\" of repetition is discharged at a time, and all of them\n+must be discharged by the time a name is transcribed. Therefore, `( $( $i:ident\n+),* ) => ( $i )` is an invalid macro, but `( $( $i:ident ),* ) => ( $( $i:ident\n+),*  )` is acceptable (if trivial).\n+\n+When Macro By Example encounters a repetition, it examines all of the `$`\n+_name_ s that occur in its body. At the \"current layer\", they all must repeat\n+the same number of times, so ` ( $( $i:ident ),* ; $( $j:ident ),* ) => ( $(\n+($i,$j) ),* )` is valid if given the argument `(a,b,c ; d,e,f)`, but not\n+`(a,b,c ; d,e)`. The repetition walks through the choices at that layer in\n+lockstep, so the former input transcribes to `(a,d), (b,e), (c,f)`.\n+\n+Nested repetitions are allowed.\n+\n+### Parsing limitations\n+\n+The parser used by the macro system is reasonably powerful, but the parsing of\n+Rust syntax is restricted in two ways:\n+\n+1. Macro definitions are required to include suitable separators after parsing\n+   expressions and other bits of the Rust grammar. This implies that\n+   a macro definition like `$i:expr [ , ]` is not legal, because `[` could be part\n+   of an expression. A macro definition like `$i:expr,` or `$i:expr;` would be legal,\n+   however, because `,` and `;` are legal separators. See [RFC 550] for more information.\n+2. The parser must have eliminated all ambiguity by the time it reaches a `$`\n+   _name_ `:` _designator_. This requirement most often affects name-designator\n+   pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n+   requiring a distinctive token in front can solve the problem.\n+\n+[RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md"}, {"sha": "93cf83dbd5a3e70df3557fb5fec4e49520a772a3", "filename": "src/doc/reference/src/macros.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmacros.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,13 @@\n+# Macros\n+\n+A number of minor features of Rust are not central enough to have their own\n+syntax, and yet are not implementable as functions. Instead, they are given\n+names, and invoked through a consistent syntax: `some_extension!(...)`.\n+\n+Users of `rustc` can define new macros in two ways:\n+\n+* [Macros](book/macros.html) define new syntax in a higher-level,\n+  declarative way.\n+* [Procedural Macros][procedural macros] can be used to implement custom derive.\n+\n+And one unstable way: [compiler plugins][plugin]."}, {"sha": "24addb1dd39d433306f0f729909b4f1dd0530c65", "filename": "src/doc/reference/src/memory-allocation-and-lifetime.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmemory-allocation-and-lifetime.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmemory-allocation-and-lifetime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmemory-allocation-and-lifetime.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,13 @@\n+# Memory allocation and lifetime\n+\n+The _items_ of a program are those functions, modules and types that have their\n+value calculated at compile-time and stored uniquely in the memory image of the\n+rust process. Items are neither dynamically allocated nor freed.\n+\n+The _heap_ is a general term that describes boxes.  The lifetime of an\n+allocation in the heap depends on the lifetime of the box values pointing to\n+it. Since box values may themselves be passed in and out of frames, or stored\n+in the heap, heap allocations may outlive the frame they are allocated within.\n+An allocation in the heap is guaranteed to reside at a single location in the\n+heap for the whole lifetime of the allocation - it will never be relocated as\n+a result of moving a box value."}, {"sha": "2798b0d165f7fdda4fa08d130b401987b07ac3f8", "filename": "src/doc/reference/src/memory-model.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmemory-model.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,24 @@\n+# Memory model\n+\n+A Rust program's memory consists of a static set of *items* and a *heap*.\n+Immutable portions of the heap may be safely shared between threads, mutable\n+portions may not be safely shared, but several mechanisms for effectively-safe\n+sharing of mutable values, built on unsafe code but enforcing a safe locking\n+discipline, exist in the standard library.\n+\n+Allocations in the stack consist of *variables*, and allocations in the heap\n+consist of *boxes*.\n+\n+## Memory allocation and lifetime\n+\n+The _items_ of a program are those functions, modules and types that have their\n+value calculated at compile-time and stored uniquely in the memory image of the\n+rust process. Items are neither dynamically allocated nor freed.\n+\n+The _heap_ is a general term that describes boxes.  The lifetime of an\n+allocation in the heap depends on the lifetime of the box values pointing to\n+it. Since box values may themselves be passed in and out of frames, or stored\n+in the heap, heap allocations may outlive the frame they are allocated within.\n+An allocation in the heap is guaranteed to reside at a single location in the\n+heap for the whole lifetime of the allocation - it will never be relocated as\n+a result of moving a box value."}, {"sha": "aed07ef2961a56205cd0831edff59d9e24ae1e25", "filename": "src/doc/reference/src/memory-ownership.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmemory-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fmemory-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fmemory-ownership.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,4 @@\n+## Memory ownership\n+\n+When a stack frame is exited, its local allocations are all released, and its\n+references to boxes are dropped."}, {"sha": "642bff440ad93a9265d03cbbf536b1677de922f9", "filename": "src/doc/reference/src/notation.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fnotation.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fnotation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fnotation.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1 @@\n+# Notation"}, {"sha": "3fa1b7d14319c0aca5d21b8114857b14a16010a8", "filename": "src/doc/reference/src/paths.md", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fpaths.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fpaths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fpaths.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,99 @@\n+# Paths\n+\n+A _path_ is a sequence of one or more path components _logically_ separated by\n+a namespace qualifier (`::`). If a path consists of only one component, it may\n+refer to either an [item](#items) or a [variable](#variables) in a local control\n+scope. If a path has multiple components, it refers to an item.\n+\n+Every item has a _canonical path_ within its crate, but the path naming an item\n+is only meaningful within a given crate. There is no global namespace across\n+crates; an item's canonical path merely identifies it within the crate.\n+\n+Two examples of simple paths consisting of only identifier components:\n+\n+```{.ignore}\n+x;\n+x::y::z;\n+```\n+\n+Path components are usually [identifiers](#identifiers), but they may\n+also include angle-bracket-enclosed lists of type arguments. In\n+[expression](#expressions) context, the type argument list is given\n+after a `::` namespace qualifier in order to disambiguate it from a\n+relational expression involving the less-than symbol (`<`). In type\n+expression context, the final namespace qualifier is omitted.\n+\n+Two examples of paths with type arguments:\n+\n+```\n+# struct HashMap<K, V>(K,V);\n+# fn f() {\n+# fn id<T>(t: T) -> T { t }\n+type T = HashMap<i32,String>; // Type arguments used in a type expression\n+let x  = id::<i32>(10);       // Type arguments used in a call expression\n+# }\n+```\n+\n+Paths can be denoted with various leading qualifiers to change the meaning of\n+how it is resolved:\n+\n+* Paths starting with `::` are considered to be global paths where the\n+  components of the path start being resolved from the crate root. Each\n+  identifier in the path must resolve to an item.\n+\n+```rust\n+mod a {\n+    pub fn foo() {}\n+}\n+mod b {\n+    pub fn foo() {\n+        ::a::foo(); // call a's foo function\n+    }\n+}\n+# fn main() {}\n+```\n+\n+* Paths starting with the keyword `super` begin resolution relative to the\n+  parent module. Each further identifier must resolve to an item.\n+\n+```rust\n+mod a {\n+    pub fn foo() {}\n+}\n+mod b {\n+    pub fn foo() {\n+        super::a::foo(); // call a's foo function\n+    }\n+}\n+# fn main() {}\n+```\n+\n+* Paths starting with the keyword `self` begin resolution relative to the\n+  current module. Each further identifier must resolve to an item.\n+\n+```rust\n+fn foo() {}\n+fn bar() {\n+    self::foo();\n+}\n+# fn main() {}\n+```\n+\n+Additionally keyword `super` may be repeated several times after the first\n+`super` or `self` to refer to ancestor modules.\n+\n+```rust\n+mod a {\n+    fn foo() {}\n+\n+    mod b {\n+        mod c {\n+            fn foo() {\n+                super::super::foo(); // call a's foo function\n+                self::super::super::foo(); // call a's foo function\n+            }\n+        }\n+    }\n+}\n+# fn main() {}\n+```"}, {"sha": "b04da6176eff222c4fe80944c96ba5aead84b895", "filename": "src/doc/reference/src/procedural-macros.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fprocedural-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fprocedural-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fprocedural-macros.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,21 @@\n+## Procedural Macros\n+\n+\"Procedural macros\" are the second way to implement a macro. For now, the only\n+thing they can be used for is to implement derive on your own types. See\n+[the book][procedural macros] for a tutorial.\n+\n+Procedural macros involve a few different parts of the language and its\n+standard libraries. First is the `proc_macro` crate, included with Rust,\n+that defines an interface for building a procedural macro. The\n+`#[proc_macro_derive(Foo)]` attribute is used to mark the deriving\n+function. This function must have the type signature:\n+\n+```rust,ignore\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Hello)]\n+pub fn hello_world(input: TokenStream) -> TokenStream\n+```\n+\n+Finally, procedural macros must be in their own crate, with the `proc-macro`\n+crate type."}, {"sha": "ae3eebe392d1dcfda0237a58a0b1ec2d608bf73a", "filename": "src/doc/reference/src/special-traits.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fspecial-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fspecial-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fspecial-traits.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,3 @@\n+# Special traits\n+\n+Several traits define special evaluation behavior."}, {"sha": "bb59108f17f321e83ebe25a4b699797ed9b2d86c", "filename": "src/doc/reference/src/statements-and-expressions.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fstatements-and-expressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fstatements-and-expressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fstatements-and-expressions.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,11 @@\n+# Statements and expressions\n+\n+Rust is _primarily_ an expression language. This means that most forms of\n+value-producing or effect-causing evaluation are directed by the uniform syntax\n+category of _expressions_. Each kind of expression can typically _nest_ within\n+each other kind of expression, and rules for evaluation of expressions involve\n+specifying both the value produced by the expression and the order in which its\n+sub-expressions are themselves evaluated.\n+\n+In contrast, statements in Rust serve _mostly_ to contain and explicitly\n+sequence expression evaluation."}, {"sha": "000e4d869cb0006dcf9c8a6591556c333874b40a", "filename": "src/doc/reference/src/statements.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fstatements.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,42 @@\n+# Statements\n+\n+A _statement_ is a component of a block, which is in turn a component of an\n+outer [expression](#expressions) or [function](#functions).\n+\n+Rust has two kinds of statement: [declaration\n+statements](#declaration-statements) and [expression\n+statements](#expression-statements).\n+\n+## Declaration statements\n+\n+A _declaration statement_ is one that introduces one or more *names* into the\n+enclosing statement block. The declared names may denote new variables or new\n+items.\n+\n+### Item declarations\n+\n+An _item declaration statement_ has a syntactic form identical to an\n+[item](#items) declaration within a module. Declaring an item &mdash; a\n+function, enumeration, struct, type, static, trait, implementation or module\n+&mdash; locally within a statement block is simply a way of restricting its\n+scope to a narrow region containing all of its uses; it is otherwise identical\n+in meaning to declaring the item outside the statement block.\n+\n+> **Note**: there is no implicit capture of the function's dynamic environment when\n+> declaring a function-local item.\n+\n+### `let` statements\n+\n+A _`let` statement_ introduces a new set of variables, given by a pattern. The\n+pattern may be followed by a type annotation, and/or an initializer expression.\n+When no type annotation is given, the compiler will infer the type, or signal\n+an error if insufficient type information is available for definite inference.\n+Any variables introduced by a variable declaration are visible from the point of\n+declaration until the end of the enclosing block scope.\n+\n+## Expression statements\n+\n+An _expression statement_ is one that evaluates an [expression](#expressions)\n+and ignores its result. The type of an expression statement `e;` is always\n+`()`, regardless of the type of `e`. As a rule, an expression statement's\n+purpose is to trigger the effects of evaluating its expression."}, {"sha": "29efc46a3ae009cb298c9f12cd81c77d979a5554", "filename": "src/doc/reference/src/string-table-productions.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fstring-table-productions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fstring-table-productions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fstring-table-productions.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,16 @@\n+# String table productions\n+\n+Some rules in the grammar &mdash; notably [unary\n+operators](#unary-operator-expressions), [binary\n+operators](#binary-operator-expressions), and [keywords][keywords] &mdash; are\n+given in a simplified form: as a listing of a table of unquoted, printable\n+whitespace-separated strings. These cases form a subset of the rules regarding\n+the [token](#tokens) rule, and are assumed to be the result of a\n+lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n+disjunction of all such string table entries.\n+\n+[keywords]: grammar.html#keywords\n+\n+When such a string enclosed in double-quotes (`\"`) occurs inside the grammar,\n+it is an implicit reference to a single member of such a string table\n+production. See [tokens](#tokens) for more information."}, {"sha": "a43b041a69338e584d7e4369e30f226375b73a6c", "filename": "src/doc/reference/src/subtyping.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fsubtyping.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,19 @@\n+# Subtyping\n+\n+Subtyping is implicit and can occur at any stage in type checking or\n+inference. Subtyping in Rust is very restricted and occurs only due to\n+variance with respect to lifetimes and between types with higher ranked\n+lifetimes. If we were to erase lifetimes from types, then the only subtyping\n+would be due to type equality.\n+\n+Consider the following example: string literals always have `'static`\n+lifetime. Nevertheless, we can assign `s` to `t`:\n+\n+```\n+fn bar<'a>() {\n+    let s: &'static str = \"hi\";\n+    let t: &'a str = s;\n+}\n+```\n+Since `'static` \"lives longer\" than `'a`, `&'static str` is a subtype of\n+`&'a str`."}, {"sha": "d593165e48d585a2bee9a78ec0689e36757e8825", "filename": "src/doc/reference/src/the-copy-trait.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-copy-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-copy-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-copy-trait.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,4 @@\n+# The `Copy` trait\n+\n+The `Copy` trait changes the semantics of a type implementing it. Values whose\n+type implements `Copy` are copied rather than moved upon assignment."}, {"sha": "a4d84ab83ea673261f4b8a7235278859d8a30998", "filename": "src/doc/reference/src/the-deref-trait.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-deref-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-deref-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-deref-trait.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,7 @@\n+# The `Deref` trait\n+\n+The `Deref<Target = U>` trait allows a type to implicitly implement all the methods\n+of the type `U`. When attempting to resolve a method call, the compiler will search\n+the top-level type for the implementation of the called method. If no such method is\n+found, `.deref()` is called and the compiler continues to search for the method\n+implementation in the returned type `U`."}, {"sha": "42bf6eb0f20148cdd0e06382df43a6b65285394a", "filename": "src/doc/reference/src/the-drop-trait.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-drop-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-drop-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-drop-trait.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,4 @@\n+# The `Drop` trait\n+\n+The `Drop` trait provides a destructor, to be run whenever a value of this type\n+is to be destroyed."}, {"sha": "9ec669289a5676d3213c01812d89a8a36c42025f", "filename": "src/doc/reference/src/the-send-trait.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-send-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-send-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-send-trait.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,4 @@\n+# The `Send` trait\n+\n+The `Send` trait indicates that a value of this type is safe to send from one\n+thread to another."}, {"sha": "a2aa17c95f295190fa1c6777daaa0c2c09c28759", "filename": "src/doc/reference/src/the-sized-trait.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-sized-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-sized-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-sized-trait.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,3 @@\n+# The `Sized` trait\n+\n+The `Sized` trait indicates that the size of this type is known at compile-time."}, {"sha": "fd9365134b29214b33d8100ef74da6ef70cc1ed9", "filename": "src/doc/reference/src/the-sync-trait.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-sync-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fthe-sync-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fthe-sync-trait.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,4 @@\n+# The `Sync` trait\n+\n+The `Sync` trait indicates that a value of this type is safe to share between\n+multiple threads."}, {"sha": "ae4007b0c99c5d3e65114c4c52c342ef18600117", "filename": "src/doc/reference/src/tokens.md", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftokens.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,305 @@\n+# Tokens\n+\n+Tokens are primitive productions in the grammar defined by regular\n+(non-recursive) languages. \"Simple\" tokens are given in [string table\n+production](#string-table-productions) form, and occur in the rest of the\n+grammar as double-quoted strings. Other tokens have exact rules given.\n+\n+## Literals\n+\n+A literal is an expression consisting of a single token, rather than a sequence\n+of tokens, that immediately and directly denotes the value it evaluates to,\n+rather than referring to it by name or some other evaluation rule. A literal is\n+a form of constant expression, so is evaluated (primarily) at compile time.\n+\n+### Examples\n+\n+#### Characters and strings\n+\n+|                                              | Example         | `#` sets   | Characters  | Escapes             |\n+|----------------------------------------------|-----------------|------------|-------------|---------------------|\n+| [Character](#character-literals)             | `'H'`           | `N/A`      | All Unicode | [Quote](#quote-escapes) & [Byte](#byte-escapes) & [Unicode](#unicode-escapes) |\n+| [String](#string-literals)                   | `\"hello\"`       | `N/A`      | All Unicode | [Quote](#quote-escapes) & [Byte](#byte-escapes) & [Unicode](#unicode-escapes) |\n+| [Raw](#raw-string-literals)                  | `r#\"hello\"#`    | `0...`     | All Unicode | `N/A`                                                      |\n+| [Byte](#byte-literals)                       | `b'H'`          | `N/A`      | All ASCII   | [Quote](#quote-escapes) & [Byte](#byte-escapes)                               |\n+| [Byte string](#byte-string-literals)         | `b\"hello\"`      | `N/A`      | All ASCII   | [Quote](#quote-escapes) & [Byte](#byte-escapes)                               |\n+| [Raw byte string](#raw-byte-string-literals) | `br#\"hello\"#`   | `0...`     | All ASCII   | `N/A`                                                      |\n+\n+#### Byte escapes\n+\n+|   | Name |\n+|---|------|\n+| `\\x7F` | 8-bit character code (exactly 2 digits) |\n+| `\\n` | Newline |\n+| `\\r` | Carriage return |\n+| `\\t` | Tab |\n+| `\\\\` | Backslash |\n+| `\\0` | Null |\n+\n+#### Unicode escapes\n+\n+|   | Name |\n+|---|------|\n+| `\\u{7FFF}` | 24-bit Unicode character code (up to 6 digits) |\n+\n+#### Quote escapes\n+\n+|   | Name |\n+|---|------|\n+| `\\'` | Single quote |\n+| `\\\"` | Double quote |\n+\n+#### Numbers\n+\n+| [Number literals](#number-literals)`*` | Example | Exponentiation | Suffixes |\n+|----------------------------------------|---------|----------------|----------|\n+| Decimal integer | `98_222` | `N/A` | Integer suffixes |\n+| Hex integer | `0xff` | `N/A` | Integer suffixes |\n+| Octal integer | `0o77` | `N/A` | Integer suffixes |\n+| Binary integer | `0b1111_0000` | `N/A` | Integer suffixes |\n+| Floating-point | `123.0E+77` | `Optional` | Floating-point suffixes |\n+\n+`*` All number literals allow `_` as a visual separator: `1_234.0E+18f64`\n+\n+#### Suffixes\n+\n+| Integer | Floating-point |\n+|---------|----------------|\n+| `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `isize`, `usize` | `f32`, `f64` |\n+\n+### Character and string literals\n+\n+#### Character literals\n+\n+A _character literal_ is a single Unicode character enclosed within two\n+`U+0027` (single-quote) characters, with the exception of `U+0027` itself,\n+which must be _escaped_ by a preceding `U+005C` character (`\\`).\n+\n+#### String literals\n+\n+A _string literal_ is a sequence of any Unicode characters enclosed within two\n+`U+0022` (double-quote) characters, with the exception of `U+0022` itself,\n+which must be _escaped_ by a preceding `U+005C` character (`\\`).\n+\n+Line-break characters are allowed in string literals. Normally they represent\n+themselves (i.e. no translation), but as a special exception, when an unescaped\n+`U+005C` character (`\\`) occurs immediately before the newline (`U+000A`), the\n+`U+005C` character, the newline, and all whitespace at the beginning of the\n+next line are ignored. Thus `a` and `b` are equal:\n+\n+```rust\n+let a = \"foobar\";\n+let b = \"foo\\\n+         bar\";\n+\n+assert_eq!(a,b);\n+```\n+\n+#### Character escapes\n+\n+Some additional _escapes_ are available in either character or non-raw string\n+literals. An escape starts with a `U+005C` (`\\`) and continues with one of the\n+following forms:\n+\n+* An _8-bit code point escape_ starts with `U+0078` (`x`) and is\n+  followed by exactly two _hex digits_. It denotes the Unicode code point\n+  equal to the provided hex value.\n+* A _24-bit code point escape_ starts with `U+0075` (`u`) and is followed\n+  by up to six _hex digits_ surrounded by braces `U+007B` (`{`) and `U+007D`\n+  (`}`). It denotes the Unicode code point equal to the provided hex value.\n+* A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n+  (`r`), or `U+0074` (`t`), denoting the Unicode values `U+000A` (LF),\n+  `U+000D` (CR) or `U+0009` (HT) respectively.\n+* The _null escape_ is the character `U+0030` (`0`) and denotes the Unicode\n+  value `U+0000` (NUL).\n+* The _backslash escape_ is the character `U+005C` (`\\`) which must be\n+  escaped in order to denote *itself*.\n+\n+#### Raw string literals\n+\n+Raw string literals do not process any escapes. They start with the character\n+`U+0072` (`r`), followed by zero or more of the character `U+0023` (`#`) and a\n+`U+0022` (double-quote) character. The _raw string body_ can contain any sequence\n+of Unicode characters and is terminated only by another `U+0022` (double-quote)\n+character, followed by the same number of `U+0023` (`#`) characters that preceded\n+the opening `U+0022` (double-quote) character.\n+\n+All Unicode characters contained in the raw string body represent themselves,\n+the characters `U+0022` (double-quote) (except when followed by at least as\n+many `U+0023` (`#`) characters as were used to start the raw string literal) or\n+`U+005C` (`\\`) do not have any special meaning.\n+\n+Examples for string literals:\n+\n+```\n+\"foo\"; r\"foo\";                     // foo\n+\"\\\"foo\\\"\"; r#\"\"foo\"\"#;             // \"foo\"\n+\n+\"foo #\\\"# bar\";\n+r##\"foo #\"# bar\"##;                // foo #\"# bar\n+\n+\"\\x52\"; \"R\"; r\"R\";                 // R\n+\"\\\\x52\"; r\"\\x52\";                  // \\x52\n+```\n+\n+### Byte and byte string literals\n+\n+#### Byte literals\n+\n+A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F`\n+range) or a single _escape_ preceded by the characters `U+0062` (`b`) and\n+`U+0027` (single-quote), and followed by the character `U+0027`. If the character\n+`U+0027` is present within the literal, it must be _escaped_ by a preceding\n+`U+005C` (`\\`) character. It is equivalent to a `u8` unsigned 8-bit integer\n+_number literal_.\n+\n+#### Byte string literals\n+\n+A non-raw _byte string literal_ is a sequence of ASCII characters and _escapes_,\n+preceded by the characters `U+0062` (`b`) and `U+0022` (double-quote), and\n+followed by the character `U+0022`. If the character `U+0022` is present within\n+the literal, it must be _escaped_ by a preceding `U+005C` (`\\`) character.\n+Alternatively, a byte string literal can be a _raw byte string literal_, defined\n+below. A byte string literal of length `n` is equivalent to a `&'static [u8; n]` borrowed fixed-sized array\n+of unsigned 8-bit integers.\n+\n+Some additional _escapes_ are available in either byte or non-raw byte string\n+literals. An escape starts with a `U+005C` (`\\`) and continues with one of the\n+following forms:\n+\n+* A _byte escape_ escape starts with `U+0078` (`x`) and is\n+  followed by exactly two _hex digits_. It denotes the byte\n+  equal to the provided hex value.\n+* A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n+  (`r`), or `U+0074` (`t`), denoting the bytes values `0x0A` (ASCII LF),\n+  `0x0D` (ASCII CR) or `0x09` (ASCII HT) respectively.\n+* The _null escape_ is the character `U+0030` (`0`) and denotes the byte\n+  value `0x00` (ASCII NUL).\n+* The _backslash escape_ is the character `U+005C` (`\\`) which must be\n+  escaped in order to denote its ASCII encoding `0x5C`.\n+\n+#### Raw byte string literals\n+\n+Raw byte string literals do not process any escapes. They start with the\n+character `U+0062` (`b`), followed by `U+0072` (`r`), followed by zero or more\n+of the character `U+0023` (`#`), and a `U+0022` (double-quote) character. The\n+_raw string body_ can contain any sequence of ASCII characters and is terminated\n+only by another `U+0022` (double-quote) character, followed by the same number of\n+`U+0023` (`#`) characters that preceded the opening `U+0022` (double-quote)\n+character. A raw byte string literal can not contain any non-ASCII byte.\n+\n+All characters contained in the raw string body represent their ASCII encoding,\n+the characters `U+0022` (double-quote) (except when followed by at least as\n+many `U+0023` (`#`) characters as were used to start the raw string literal) or\n+`U+005C` (`\\`) do not have any special meaning.\n+\n+Examples for byte string literals:\n+\n+```\n+b\"foo\"; br\"foo\";                     // foo\n+b\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n+\n+b\"foo #\\\"# bar\";\n+br##\"foo #\"# bar\"##;                 // foo #\"# bar\n+\n+b\"\\x52\"; b\"R\"; br\"R\";                // R\n+b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n+```\n+\n+### Number literals\n+\n+A _number literal_ is either an _integer literal_ or a _floating-point\n+literal_. The grammar for recognizing the two kinds of literals is mixed.\n+\n+#### Integer literals\n+\n+An _integer literal_ has one of four forms:\n+\n+* A _decimal literal_ starts with a *decimal digit* and continues with any\n+  mixture of *decimal digits* and _underscores_.\n+* A _hex literal_ starts with the character sequence `U+0030` `U+0078`\n+  (`0x`) and continues as any mixture of hex digits and underscores.\n+* An _octal literal_ starts with the character sequence `U+0030` `U+006F`\n+  (`0o`) and continues as any mixture of octal digits and underscores.\n+* A _binary literal_ starts with the character sequence `U+0030` `U+0062`\n+  (`0b`) and continues as any mixture of binary digits and underscores.\n+\n+Like any literal, an integer literal may be followed (immediately,\n+without any spaces) by an _integer suffix_, which forcibly sets the\n+type of the literal. The integer suffix must be the name of one of the\n+integral types: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`,\n+`isize`, or `usize`.\n+\n+The type of an _unsuffixed_ integer literal is determined by type inference:\n+\n+* If an integer type can be _uniquely_ determined from the surrounding\n+  program context, the unsuffixed integer literal has that type.\n+\n+* If the program context under-constrains the type, it defaults to the\n+  signed 32-bit integer `i32`.\n+\n+* If the program context over-constrains the type, it is considered a\n+  static type error.\n+\n+Examples of integer literals of various forms:\n+\n+```\n+123i32;                            // type i32\n+123u32;                            // type u32\n+123_u32;                           // type u32\n+0xff_u8;                           // type u8\n+0o70_i16;                          // type i16\n+0b1111_1111_1001_0000_i32;         // type i32\n+0usize;                            // type usize\n+```\n+\n+Note that the Rust syntax considers `-1i8` as an application of the [unary minus\n+operator](#unary-operator-expressions) to an integer literal `1i8`, rather than\n+a single integer literal.\n+\n+#### Floating-point literals\n+\n+A _floating-point literal_ has one of two forms:\n+\n+* A _decimal literal_ followed by a period character `U+002E` (`.`). This is\n+  optionally followed by another decimal literal, with an optional _exponent_.\n+* A single _decimal literal_ followed by an _exponent_.\n+\n+Like integer literals, a floating-point literal may be followed by a\n+suffix, so long as the pre-suffix part does not end with `U+002E` (`.`).\n+The suffix forcibly sets the type of the literal. There are two valid\n+_floating-point suffixes_, `f32` and `f64` (the 32-bit and 64-bit floating point\n+types), which explicitly determine the type of the literal.\n+\n+The type of an _unsuffixed_ floating-point literal is determined by\n+type inference:\n+\n+* If a floating-point type can be _uniquely_ determined from the\n+  surrounding program context, the unsuffixed floating-point literal\n+  has that type.\n+\n+* If the program context under-constrains the type, it defaults to `f64`.\n+\n+* If the program context over-constrains the type, it is considered a\n+  static type error.\n+\n+Examples of floating-point literals of various forms:\n+\n+```\n+123.0f64;        // type f64\n+0.1f64;          // type f64\n+0.1f32;          // type f32\n+12E+99_f64;      // type f64\n+let x: f64 = 2.; // type f64\n+```\n+\n+This last example is different because it is not possible to use the suffix\n+syntax with a floating point literal ending in a period. `2.f64` would attempt\n+to call a method named `f64` on `2`.\n+\n+The representation semantics of floating-point numbers are described in\n+[\"Machine Types\"](#machine-types).\n+\n+### Boolean literals\n+\n+The two values of the boolean type are written `true` and `false`."}, {"sha": "6301e5e83d748e2628401e0d33de625bd542655f", "filename": "src/doc/reference/src/type-coercions.md", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Ftype-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Ftype-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftype-coercions.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,145 @@\n+# Type coercions\n+\n+Coercions are defined in [RFC 401]. A coercion is implicit and has no syntax.\n+\n+[RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+\n+## Coercion sites\n+\n+A coercion can only occur at certain coercion sites in a program; these are\n+typically places where the desired type is explicit or can be derived by\n+propagation from explicit types (without type inference). Possible coercion\n+sites are:\n+\n+* `let` statements where an explicit type is given.\n+\n+   For example, `42` is coerced to have type `i8` in the following:\n+\n+   ```rust\n+   let _: i8 = 42;\n+   ```\n+\n+* `static` and `const` statements (similar to `let` statements).\n+\n+* Arguments for function calls\n+\n+  The value being coerced is the actual parameter, and it is coerced to\n+  the type of the formal parameter.\n+\n+  For example, `42` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn bar(_: i8) { }\n+\n+  fn main() {\n+      bar(42);\n+  }\n+  ```\n+\n+* Instantiations of struct or variant fields\n+\n+  For example, `42` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  struct Foo { x: i8 }\n+\n+  fn main() {\n+      Foo { x: 42 };\n+  }\n+  ```\n+\n+* Function results, either the final line of a block if it is not\n+  semicolon-terminated or any expression in a `return` statement\n+\n+  For example, `42` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn foo() -> i8 {\n+      42\n+  }\n+  ```\n+\n+If the expression in one of these coercion sites is a coercion-propagating\n+expression, then the relevant sub-expressions in that expression are also\n+coercion sites. Propagation recurses from these new coercion sites.\n+Propagating expressions and their relevant sub-expressions are:\n+\n+* Array literals, where the array has type `[U; n]`. Each sub-expression in\n+the array literal is a coercion site for coercion to type `U`.\n+\n+* Array literals with repeating syntax, where the array has type `[U; n]`. The\n+repeated sub-expression is a coercion site for coercion to type `U`.\n+\n+* Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\n+Each sub-expression is a coercion site to the respective type, e.g. the\n+zeroth sub-expression is a coercion site to type `U_0`.\n+\n+* Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then\n+the sub-expression is a coercion site to `U`.\n+\n+* Blocks: if a block has type `U`, then the last expression in the block (if\n+it is not semicolon-terminated) is a coercion site to `U`. This includes\n+blocks which are part of control flow statements, such as `if`/`else`, if\n+the block has a known type.\n+\n+## Coercion types\n+\n+Coercion is allowed between the following types:\n+\n+* `T` to `U` if `T` is a subtype of `U` (*reflexive case*)\n+\n+* `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n+(*transitive case*)\n+\n+    Note that this is not fully supported yet\n+\n+* `&mut T` to `&T`\n+\n+* `*mut T` to `*const T`\n+\n+* `&T` to `*const T`\n+\n+* `&mut T` to `*mut T`\n+\n+* `&T` to `&U` if `T` implements `Deref<Target = U>`. For example:\n+\n+  ```rust\n+  use std::ops::Deref;\n+\n+  struct CharContainer {\n+      value: char,\n+  }\n+\n+  impl Deref for CharContainer {\n+      type Target = char;\n+\n+      fn deref<'a>(&'a self) -> &'a char {\n+          &self.value\n+      }\n+  }\n+\n+  fn foo(arg: &char) {}\n+\n+  fn main() {\n+      let x = &mut CharContainer { value: 'y' };\n+      foo(x); //&mut CharContainer is coerced to &char.\n+  }\n+  ```\n+\n+* `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.\n+\n+* TyCtor(`T`) to TyCtor(coerce_inner(`T`)), where TyCtor(`T`) is one of\n+    - `&T`\n+    - `&mut T`\n+    - `*const T`\n+    - `*mut T`\n+    - `Box<T>`\n+\n+    and where\n+    - coerce_inner(`[T, ..n]`) = `[T]`\n+    - coerce_inner(`T`) = `U` where `T` is a concrete type which implements the\n+    trait `U`.\n+\n+    In the future, coerce_inner will be recursively extended to tuples and\n+    structs. In addition, coercions from sub-traits to super-traits will be\n+    added. See [RFC 401] for more details."}, {"sha": "bed7f128e570493bc6dd5cefa9a6a75a5bdfa23a", "filename": "src/doc/reference/src/type-system.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Ftype-system.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Ftype-system.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftype-system.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1 @@\n+# Type system"}, {"sha": "de38636504803eeda809bb7f8e8e6e260004920c", "filename": "src/doc/reference/src/types.md", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Ftypes.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,398 @@\n+# Types\n+\n+Every variable, item and value in a Rust program has a type. The _type_ of a\n+*value* defines the interpretation of the memory holding it.\n+\n+Built-in types and type-constructors are tightly integrated into the language,\n+in nontrivial ways that are not possible to emulate in user-defined types.\n+User-defined types have limited capabilities.\n+\n+## Primitive types\n+\n+The primitive types are the following:\n+\n+* The boolean type `bool` with values `true` and `false`.\n+* The machine types (integer and floating-point).\n+* The machine-dependent integer types.\n+* Arrays\n+* Tuples\n+* Slices\n+* Function pointers\n+\n+### Machine types\n+\n+The machine types are the following:\n+\n+* The unsigned word types `u8`, `u16`, `u32` and `u64`, with values drawn from\n+  the integer intervals [0, 2^8 - 1], [0, 2^16 - 1], [0, 2^32 - 1] and\n+  [0, 2^64 - 1] respectively.\n+\n+* The signed two's complement word types `i8`, `i16`, `i32` and `i64`, with\n+  values drawn from the integer intervals [-(2^(7)), 2^7 - 1],\n+  [-(2^(15)), 2^15 - 1], [-(2^(31)), 2^31 - 1], [-(2^(63)), 2^63 - 1]\n+  respectively.\n+\n+* The IEEE 754-2008 `binary32` and `binary64` floating-point types: `f32` and\n+  `f64`, respectively.\n+\n+### Machine-dependent integer types\n+\n+The `usize` type is an unsigned integer type with the same number of bits as the\n+platform's pointer type. It can represent every memory address in the process.\n+\n+The `isize` type is a signed integer type with the same number of bits as the\n+platform's pointer type. The theoretical upper bound on object and array size\n+is the maximum `isize` value. This ensures that `isize` can be used to calculate\n+differences between pointers into an object or array and can address every byte\n+within an object along with one byte past the end.\n+\n+## Textual types\n+\n+The types `char` and `str` hold textual data.\n+\n+A value of type `char` is a [Unicode scalar value](\n+http://www.unicode.org/glossary/#unicode_scalar_value) (i.e. a code point that\n+is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to\n+0xD7FF or 0xE000 to 0x10FFFF range. A `[char]` array is effectively an UCS-4 /\n+UTF-32 string.\n+\n+A value of type `str` is a Unicode string, represented as an array of 8-bit\n+unsigned bytes holding a sequence of UTF-8 code points. Since `str` is of\n+unknown size, it is not a _first-class_ type, but can only be instantiated\n+through a pointer type, such as `&str`.\n+\n+## Tuple types\n+\n+A tuple *type* is a heterogeneous product of other types, called the *elements*\n+of the tuple. It has no nominal name and is instead structurally typed.\n+\n+Tuple types and values are denoted by listing the types or values of their\n+elements, respectively, in a parenthesized, comma-separated list.\n+\n+Because tuple elements don't have a name, they can only be accessed by\n+pattern-matching or by using `N` directly as a field to access the\n+`N`th element.\n+\n+An example of a tuple type and its use:\n+\n+```\n+type Pair<'a> = (i32, &'a str);\n+let p: Pair<'static> = (10, \"ten\");\n+let (a, b) = p;\n+\n+assert_eq!(a, 10);\n+assert_eq!(b, \"ten\");\n+assert_eq!(p.0, 10);\n+assert_eq!(p.1, \"ten\");\n+```\n+\n+For historical reasons and convenience, the tuple type with no elements (`()`)\n+is often called \u2018unit\u2019 or \u2018the unit type\u2019.\n+\n+## Array, and Slice types\n+\n+Rust has two different types for a list of items:\n+\n+* `[T; N]`, an 'array'\n+* `&[T]`, a 'slice'\n+\n+An array has a fixed size, and can be allocated on either the stack or the\n+heap.\n+\n+A slice is a 'view' into an array. It doesn't own the data it points\n+to, it borrows it.\n+\n+Examples:\n+\n+```{rust}\n+// A stack-allocated array\n+let array: [i32; 3] = [1, 2, 3];\n+\n+// A heap-allocated array\n+let vector: Vec<i32> = vec![1, 2, 3];\n+\n+// A slice into an array\n+let slice: &[i32] = &vector[..];\n+```\n+\n+As you can see, the `vec!` macro allows you to create a `Vec<T>` easily. The\n+`vec!` macro is also part of the standard library, rather than the language.\n+\n+All in-bounds elements of arrays and slices are always initialized, and access\n+to an array or slice is always bounds-checked.\n+\n+## Struct types\n+\n+A `struct` *type* is a heterogeneous product of other types, called the\n+*fields* of the type.[^structtype]\n+\n+[^structtype]: `struct` types are analogous to `struct` types in C,\n+    the *record* types of the ML family,\n+    or the *struct* types of the Lisp family.\n+\n+New instances of a `struct` can be constructed with a [struct\n+expression](#struct-expressions).\n+\n+The memory layout of a `struct` is undefined by default to allow for compiler\n+optimizations like field reordering, but it can be fixed with the\n+`#[repr(...)]` attribute. In either case, fields may be given in any order in\n+a corresponding struct *expression*; the resulting `struct` value will always\n+have the same memory layout.\n+\n+The fields of a `struct` may be qualified by [visibility\n+modifiers](#visibility-and-privacy), to allow access to data in a\n+struct outside a module.\n+\n+A _tuple struct_ type is just like a struct type, except that the fields are\n+anonymous.\n+\n+A _unit-like struct_ type is like a struct type, except that it has no\n+fields. The one value constructed by the associated [struct\n+expression](#struct-expressions) is the only value that inhabits such a\n+type.\n+\n+## Enumerated types\n+\n+An *enumerated type* is a nominal, heterogeneous disjoint union type, denoted\n+by the name of an [`enum` item](#enumerations). [^enumtype]\n+\n+[^enumtype]: The `enum` type is analogous to a `data` constructor declaration in\n+             ML, or a *pick ADT* in Limbo.\n+\n+An [`enum` item](#enumerations) declares both the type and a number of *variant\n+constructors*, each of which is independently named and takes an optional tuple\n+of arguments.\n+\n+New instances of an `enum` can be constructed by calling one of the variant\n+constructors, in a [call expression](#call-expressions).\n+\n+Any `enum` value consumes as much memory as the largest variant constructor for\n+its corresponding `enum` type.\n+\n+Enum types cannot be denoted *structurally* as types, but must be denoted by\n+named reference to an [`enum` item](#enumerations).\n+\n+## Recursive types\n+\n+Nominal types &mdash; [enumerations](#enumerated-types) and\n+[structs](#struct-types) &mdash; may be recursive. That is, each `enum`\n+constructor or `struct` field may refer, directly or indirectly, to the\n+enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n+\n+* Recursive types must include a nominal type in the recursion\n+  (not mere [type definitions](grammar.html#type-definitions),\n+   or other structural types such as [arrays](#array-and-slice-types) or [tuples](#tuple-types)).\n+* A recursive `enum` item must have at least one non-recursive constructor\n+  (in order to give the recursion a basis case).\n+* The size of a recursive type must be finite;\n+  in other words the recursive fields of the type must be [pointer types](#pointer-types).\n+* Recursive type definitions can cross module boundaries, but not module *visibility* boundaries,\n+  or crate boundaries (in order to simplify the module system and type checker).\n+\n+An example of a *recursive* type and its use:\n+\n+```\n+enum List<T> {\n+    Nil,\n+    Cons(T, Box<List<T>>)\n+}\n+\n+let a: List<i32> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));\n+```\n+\n+## Pointer types\n+\n+All pointers in Rust are explicit first-class values. They can be copied,\n+stored into data structs, and returned from functions. There are two\n+varieties of pointer in Rust:\n+\n+* References (`&`)\n+  : These point to memory _owned by some other value_.\n+    A reference type is written `&type`,\n+    or `&'a type` when you need to specify an explicit lifetime.\n+    Copying a reference is a \"shallow\" operation:\n+    it involves only copying the pointer itself.\n+    Releasing a reference has no effect on the value it points to,\n+    but a reference of a temporary value will keep it alive during the scope\n+    of the reference itself.\n+\n+* Raw pointers (`*`)\n+  : Raw pointers are pointers without safety or liveness guarantees.\n+    Raw pointers are written as `*const T` or `*mut T`,\n+    for example `*const i32` means a raw pointer to a 32-bit integer.\n+    Copying or dropping a raw pointer has no effect on the lifecycle of any\n+    other value. Dereferencing a raw pointer or converting it to any other\n+    pointer type is an [`unsafe` operation](#unsafe-functions).\n+    Raw pointers are generally discouraged in Rust code;\n+    they exist to support interoperability with foreign code,\n+    and writing performance-critical or low-level functions.\n+\n+The standard library contains additional 'smart pointer' types beyond references\n+and raw pointers.\n+\n+## Function types\n+\n+The function type constructor `fn` forms new function types. A function type\n+consists of a possibly-empty set of function-type modifiers (such as `unsafe`\n+or `extern`), a sequence of input types and an output type.\n+\n+An example of a `fn` type:\n+\n+```\n+fn add(x: i32, y: i32) -> i32 {\n+    x + y\n+}\n+\n+let mut x = add(5,7);\n+\n+type Binop = fn(i32, i32) -> i32;\n+let bo: Binop = add;\n+x = bo(5,7);\n+```\n+\n+### Function types for specific items\n+\n+Internal to the compiler, there are also function types that are specific to a particular\n+function item. In the following snippet, for example, the internal types of the functions\n+`foo` and `bar` are different, despite the fact that they have the same signature:\n+\n+```\n+fn foo() { }\n+fn bar() { }\n+```\n+\n+The types of `foo` and `bar` can both be implicitly coerced to the fn\n+pointer type `fn()`. There is currently no syntax for unique fn types,\n+though the compiler will emit a type like `fn() {foo}` in error\n+messages to indicate \"the unique fn type for the function `foo`\".\n+\n+## Closure types\n+\n+A [lambda expression](#lambda-expressions) produces a closure value with\n+a unique, anonymous type that cannot be written out.\n+\n+Depending on the requirements of the closure, its type implements one or\n+more of the closure traits:\n+\n+* `FnOnce`\n+  : The closure can be called once. A closure called as `FnOnce`\n+    can move out values from its environment.\n+\n+* `FnMut`\n+  : The closure can be called multiple times as mutable. A closure called as\n+    `FnMut` can mutate values from its environment. `FnMut` inherits from\n+    `FnOnce` (i.e. anything implementing `FnMut` also implements `FnOnce`).\n+\n+* `Fn`\n+  : The closure can be called multiple times through a shared reference.\n+    A closure called as `Fn` can neither move out from nor mutate values\n+    from its environment. `Fn` inherits from `FnMut`, which itself\n+    inherits from `FnOnce`.\n+\n+\n+## Trait objects\n+\n+In Rust, a type like `&SomeTrait` or `Box<SomeTrait>` is called a _trait object_.\n+Each instance of a trait object includes:\n+\n+ - a pointer to an instance of a type `T` that implements `SomeTrait`\n+ - a _virtual method table_, often just called a _vtable_, which contains, for\n+   each method of `SomeTrait` that `T` implements, a pointer to `T`'s\n+   implementation (i.e. a function pointer).\n+\n+The purpose of trait objects is to permit \"late binding\" of methods. Calling a\n+method on a trait object results in virtual dispatch at runtime: that is, a\n+function pointer is loaded from the trait object vtable and invoked indirectly.\n+The actual implementation for each vtable entry can vary on an object-by-object\n+basis.\n+\n+Note that for a trait object to be instantiated, the trait must be\n+_object-safe_. Object safety rules are defined in [RFC 255].\n+\n+[RFC 255]: https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md\n+\n+Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T`\n+implements trait `R`, casting `E` to the corresponding pointer type `&R` or\n+`Box<R>` results in a value of the _trait object_ `R`. This result is\n+represented as a pair of pointers: the vtable pointer for the `T`\n+implementation of `R`, and the pointer value of `E`.\n+\n+An example of a trait object:\n+\n+```\n+trait Printable {\n+    fn stringify(&self) -> String;\n+}\n+\n+impl Printable for i32 {\n+    fn stringify(&self) -> String { self.to_string() }\n+}\n+\n+fn print(a: Box<Printable>) {\n+    println!(\"{}\", a.stringify());\n+}\n+\n+fn main() {\n+    print(Box::new(10) as Box<Printable>);\n+}\n+```\n+\n+In this example, the trait `Printable` occurs as a trait object in both the\n+type signature of `print`, and the cast expression in `main`.\n+\n+### Type parameters\n+\n+Within the body of an item that has type parameter declarations, the names of\n+its type parameters are types:\n+\n+```ignore\n+fn to_vec<A: Clone>(xs: &[A]) -> Vec<A> {\n+    if xs.is_empty() {\n+        return vec![];\n+    }\n+    let first: A = xs[0].clone();\n+    let mut rest: Vec<A> = to_vec(&xs[1..]);\n+    rest.insert(0, first);\n+    rest\n+}\n+```\n+\n+Here, `first` has type `A`, referring to `to_vec`'s `A` type parameter; and `rest`\n+has type `Vec<A>`, a vector with element type `A`.\n+\n+## Self types\n+\n+The special type `Self` has a meaning within traits and impls. In a trait definition, it refers\n+to an implicit type parameter representing the \"implementing\" type. In an impl,\n+it is an alias for the implementing type. For example, in:\n+\n+```\n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\n+\n+impl From<i32> for String {\n+    fn from(x: i32) -> Self {\n+        x.to_string()\n+    }\n+}\n+```\n+\n+The notation `Self` in the impl refers to the implementing type: `String`. In another\n+example:\n+\n+```\n+trait Printable {\n+    fn make_string(&self) -> String;\n+}\n+\n+impl Printable for String {\n+    fn make_string(&self) -> String {\n+        (*self).clone()\n+    }\n+}\n+```\n+\n+The notation `&self` is a shorthand for `self: &Self`. In this case,\n+in the impl, `Self` refers to the value of type `String` that is the\n+receiver for a call to the method `make_string`."}, {"sha": "3caf8c9cdac98b489ae1d815d8d05bf3e984ffa0", "filename": "src/doc/reference/src/unicode-productions.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Funicode-productions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Funicode-productions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funicode-productions.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,9 @@\n+# Unicode productions\n+\n+A few productions in Rust's grammar permit Unicode code points outside the\n+ASCII range. We define these productions in terms of character properties\n+specified in the Unicode standard, rather than in terms of ASCII-range code\n+points. The grammar has a [Special Unicode Productions][unicodeproductions]\n+section that lists these productions.\n+\n+[unicodeproductions]: grammar.html#special-unicode-productions"}, {"sha": "754278445d51e805675301399cdca2244191a4c7", "filename": "src/doc/reference/src/unsafe-blocks.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Funsafe-blocks.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Funsafe-blocks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funsafe-blocks.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,22 @@\n+# Unsafe blocks\n+\n+A block of code can be prefixed with the `unsafe` keyword, to permit calling\n+`unsafe` functions or dereferencing raw pointers within a safe function.\n+\n+When a programmer has sufficient conviction that a sequence of potentially\n+unsafe operations is actually safe, they can encapsulate that sequence (taken\n+as a whole) within an `unsafe` block. The compiler will consider uses of such\n+code safe, in the surrounding context.\n+\n+Unsafe blocks are used to wrap foreign libraries, make direct use of hardware\n+or implement features not directly present in the language. For example, Rust\n+provides the language features necessary to implement memory-safe concurrency\n+in the language but the implementation of threads and message passing is in the\n+standard library.\n+\n+Rust's type system is a conservative approximation of the dynamic safety\n+requirements, so in some cases there is a performance cost to using safe code.\n+For example, a doubly-linked list is not a tree structure and can only be\n+represented with reference-counted pointers in safe code. By using `unsafe`\n+blocks to represent the reverse links as raw pointers, it can be implemented\n+with only boxes."}, {"sha": "7a5064c08f41abf7bcefaa1ab20d7c1af3d5923f", "filename": "src/doc/reference/src/unsafe-functions.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Funsafe-functions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Funsafe-functions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funsafe-functions.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,5 @@\n+# Unsafe functions\n+\n+Unsafe functions are functions that are not safe in all contexts and/or for all\n+possible inputs. Such a function must be prefixed with the keyword `unsafe` and\n+can only be called from an `unsafe` block or another `unsafe` function."}, {"sha": "f4a9a1d12925abb0bafeda36f49049d0c0c881f4", "filename": "src/doc/reference/src/unsafety.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Funsafety.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,40 @@\n+# Unsafety\n+\n+Unsafe operations are those that potentially violate the memory-safety\n+guarantees of Rust's static semantics.\n+\n+The following language level features cannot be used in the safe subset of\n+Rust:\n+\n+- Dereferencing a [raw pointer](#pointer-types).\n+- Reading or writing a [mutable static variable](#mutable-statics).\n+- Calling an unsafe function (including an intrinsic or foreign function).\n+\n+## Unsafe functions\n+\n+Unsafe functions are functions that are not safe in all contexts and/or for all\n+possible inputs. Such a function must be prefixed with the keyword `unsafe` and\n+can only be called from an `unsafe` block or another `unsafe` function.\n+\n+## Unsafe blocks\n+\n+A block of code can be prefixed with the `unsafe` keyword, to permit calling\n+`unsafe` functions or dereferencing raw pointers within a safe function.\n+\n+When a programmer has sufficient conviction that a sequence of potentially\n+unsafe operations is actually safe, they can encapsulate that sequence (taken\n+as a whole) within an `unsafe` block. The compiler will consider uses of such\n+code safe, in the surrounding context.\n+\n+Unsafe blocks are used to wrap foreign libraries, make direct use of hardware\n+or implement features not directly present in the language. For example, Rust\n+provides the language features necessary to implement memory-safe concurrency\n+in the language but the implementation of threads and message passing is in the\n+standard library.\n+\n+Rust's type system is a conservative approximation of the dynamic safety\n+requirements, so in some cases there is a performance cost to using safe code.\n+For example, a doubly-linked list is not a tree structure and can only be\n+represented with reference-counted pointers in safe code. By using `unsafe`\n+blocks to represent the reverse links as raw pointers, it can be implemented\n+with only boxes."}, {"sha": "23a4197a0e0355553136ed93e45bd56442ab4a36", "filename": "src/doc/reference/src/variables.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fvariables.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fvariables.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fvariables.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,31 @@\n+# Variables\n+\n+A _variable_ is a component of a stack frame, either a named function parameter,\n+an anonymous [temporary](#lvalues-rvalues-and-temporaries), or a named local\n+variable.\n+\n+A _local variable_ (or *stack-local* allocation) holds a value directly,\n+allocated within the stack's memory. The value is a part of the stack frame.\n+\n+Local variables are immutable unless declared otherwise like: `let mut x = ...`.\n+\n+Function parameters are immutable unless declared with `mut`. The `mut` keyword\n+applies only to the following parameter (so `|mut x, y|` and `fn f(mut x:\n+Box<i32>, y: Box<i32>)` declare one mutable variable `x` and one immutable\n+variable `y`).\n+\n+Methods that take either `self` or `Box<Self>` can optionally place them in a\n+mutable variable by prefixing them with `mut` (similar to regular arguments):\n+\n+```\n+trait Changer: Sized {\n+    fn change(mut self) {}\n+    fn modify(mut self: Box<Self>) {}\n+}\n+```\n+\n+Local variables are not initialized when allocated; the entire frame worth of\n+local variables are allocated at once, on frame-entry, in an uninitialized\n+state. Subsequent statements within a function may or may not initialize the\n+local variables. Local variables can be used only after they have been\n+initialized; this is enforced by the compiler."}, {"sha": "50d3e7507d0ed365bd5c0d7638f7c39c073cc969", "filename": "src/doc/reference/src/visibility-and-privacy.md", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fvisibility-and-privacy.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fvisibility-and-privacy.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fvisibility-and-privacy.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,160 @@\n+# Visibility and Privacy\n+\n+These two terms are often used interchangeably, and what they are attempting to\n+convey is the answer to the question \"Can this item be used at this location?\"\n+\n+Rust's name resolution operates on a global hierarchy of namespaces. Each level\n+in the hierarchy can be thought of as some item. The items are one of those\n+mentioned above, but also include external crates. Declaring or defining a new\n+module can be thought of as inserting a new tree into the hierarchy at the\n+location of the definition.\n+\n+To control whether interfaces can be used across modules, Rust checks each use\n+of an item to see whether it should be allowed or not. This is where privacy\n+warnings are generated, or otherwise \"you used a private item of another module\n+and weren't allowed to.\"\n+\n+By default, everything in Rust is *private*, with two exceptions: Associated\n+items in a `pub` Trait are public by default; Enum variants\n+in a `pub` enum are also public by default. When an item is declared as `pub`,\n+it can be thought of as being accessible to the outside world. For example:\n+\n+```\n+# fn main() {}\n+// Declare a private struct\n+struct Foo;\n+\n+// Declare a public struct with a private field\n+pub struct Bar {\n+    field: i32,\n+}\n+\n+// Declare a public enum with two public variants\n+pub enum State {\n+    PubliclyAccessibleState,\n+    PubliclyAccessibleState2,\n+}\n+```\n+\n+With the notion of an item being either public or private, Rust allows item\n+accesses in two cases:\n+\n+1. If an item is public, then it can be used externally through any of its\n+   public ancestors.\n+2. If an item is private, it may be accessed by the current module and its\n+   descendants.\n+\n+These two cases are surprisingly powerful for creating module hierarchies\n+exposing public APIs while hiding internal implementation details. To help\n+explain, here's a few use cases and what they would entail:\n+\n+* A library developer needs to expose functionality to crates which link\n+  against their library. As a consequence of the first case, this means that\n+  anything which is usable externally must be `pub` from the root down to the\n+  destination item. Any private item in the chain will disallow external\n+  accesses.\n+\n+* A crate needs a global available \"helper module\" to itself, but it doesn't\n+  want to expose the helper module as a public API. To accomplish this, the\n+  root of the crate's hierarchy would have a private module which then\n+  internally has a \"public API\". Because the entire crate is a descendant of\n+  the root, then the entire local crate can access this private module through\n+  the second case.\n+\n+* When writing unit tests for a module, it's often a common idiom to have an\n+  immediate child of the module to-be-tested named `mod test`. This module\n+  could access any items of the parent module through the second case, meaning\n+  that internal implementation details could also be seamlessly tested from the\n+  child module.\n+\n+In the second case, it mentions that a private item \"can be accessed\" by the\n+current module and its descendants, but the exact meaning of accessing an item\n+depends on what the item is. Accessing a module, for example, would mean\n+looking inside of it (to import more items). On the other hand, accessing a\n+function would mean that it is invoked. Additionally, path expressions and\n+import statements are considered to access an item in the sense that the\n+import/expression is only valid if the destination is in the current visibility\n+scope.\n+\n+Here's an example of a program which exemplifies the three cases outlined\n+above:\n+\n+```\n+// This module is private, meaning that no external crate can access this\n+// module. Because it is private at the root of this current crate, however, any\n+// module in the crate may access any publicly visible item in this module.\n+mod crate_helper_module {\n+\n+    // This function can be used by anything in the current crate\n+    pub fn crate_helper() {}\n+\n+    // This function *cannot* be used by anything else in the crate. It is not\n+    // publicly visible outside of the `crate_helper_module`, so only this\n+    // current module and its descendants may access it.\n+    fn implementation_detail() {}\n+}\n+\n+// This function is \"public to the root\" meaning that it's available to external\n+// crates linking against this one.\n+pub fn public_api() {}\n+\n+// Similarly to 'public_api', this module is public so external crates may look\n+// inside of it.\n+pub mod submodule {\n+    use crate_helper_module;\n+\n+    pub fn my_method() {\n+        // Any item in the local crate may invoke the helper module's public\n+        // interface through a combination of the two rules above.\n+        crate_helper_module::crate_helper();\n+    }\n+\n+    // This function is hidden to any module which is not a descendant of\n+    // `submodule`\n+    fn my_implementation() {}\n+\n+    #[cfg(test)]\n+    mod test {\n+\n+        #[test]\n+        fn test_my_implementation() {\n+            // Because this module is a descendant of `submodule`, it's allowed\n+            // to access private items inside of `submodule` without a privacy\n+            // violation.\n+            super::my_implementation();\n+        }\n+    }\n+}\n+\n+# fn main() {}\n+```\n+\n+For a Rust program to pass the privacy checking pass, all paths must be valid\n+accesses given the two rules above. This includes all use statements,\n+expressions, types, etc.\n+\n+## Re-exporting and Visibility\n+\n+Rust allows publicly re-exporting items through a `pub use` directive. Because\n+this is a public directive, this allows the item to be used in the current\n+module through the rules above. It essentially allows public access into the\n+re-exported item. For example, this program is valid:\n+\n+```\n+pub use self::implementation::api;\n+\n+mod implementation {\n+    pub mod api {\n+        pub fn f() {}\n+    }\n+}\n+\n+# fn main() {}\n+```\n+\n+This means that any external crate referencing `implementation::api::f` would\n+receive a privacy violation, while the path `api::f` would be allowed.\n+\n+When re-exporting a private item, it can be thought of as allowing the \"privacy\n+chain\" being short-circuited through the reexport instead of passing through\n+the namespace hierarchy as it normally would."}, {"sha": "2fd162bcb2da8645fd775cdaf61f951af334f8b1", "filename": "src/doc/reference/src/whitespace.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fwhitespace.md", "raw_url": "https://github.com/rust-lang/rust/raw/c937254357c0991e3eacad3822b1b7f80d7f145c/src%2Fdoc%2Freference%2Fsrc%2Fwhitespace.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference%2Fsrc%2Fwhitespace.md?ref=c937254357c0991e3eacad3822b1b7f80d7f145c", "patch": "@@ -0,0 +1,22 @@\n+# Whitespace\n+\n+Whitespace is any non-empty string containing only characters that have the\n+`Pattern_White_Space` Unicode property, namely:\n+\n+- `U+0009` (horizontal tab, `'\\t'`)\n+- `U+000A` (line feed, `'\\n'`)\n+- `U+000B` (vertical tab)\n+- `U+000C` (form feed)\n+- `U+000D` (carriage return, `'\\r'`)\n+- `U+0020` (space, `' '`)\n+- `U+0085` (next line)\n+- `U+200E` (left-to-right mark)\n+- `U+200F` (right-to-left mark)\n+- `U+2028` (line separator)\n+- `U+2029` (paragraph separator)\n+\n+Rust is a \"free-form\" language, meaning that all forms of whitespace serve only\n+to separate _tokens_ in the grammar, and have no semantic significance.\n+\n+A Rust program has identical meaning if each whitespace element is replaced\n+with any other legal whitespace element, such as a single space character."}]}