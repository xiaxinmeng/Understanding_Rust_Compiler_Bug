{"sha": "3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYzUwNzNkYmI5ZTI4NGE2NGFlODgxNWJkYjU0ZDNiMWQ2YzQ4NGE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-05-11T21:32:13Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-05-29T21:02:40Z"}, "message": "Expand two-phase-borrows so that a case like this still compiles:\n\n```rust\nfn main() {\n    fn reuse<X>(_: &mut X) {}\n    let mut t = 2f64;\n    match t {\n        ref mut _b if { false } => { reuse(_b); }\n        _ => {}\n    }\n}\n```\n\nNote: The way this is currently written is confusing; when `autoref`\nis off, then the arm body bindings (introduced by\n`bind_matched_candidate_for_arm_body`) are *also* used for the guard.\n(Any attempt to fix this needs to still ensure that the bindings used\nby the guard are introduced before the guard is evaluated.)\n\n(Once we turn NLL on by default, we can presumably simplify all of\nthat.)", "tree": {"sha": "0e32581b8efd03bb5ccb8255c9a11c6e1e0d29ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e32581b8efd03bb5ccb8255c9a11c6e1e0d29ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "html_url": "https://github.com/rust-lang/rust/commit/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "638acd300fa42a2d0128378a37bffae2c11315ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/638acd300fa42a2d0128378a37bffae2c11315ad", "html_url": "https://github.com/rust-lang/rust/commit/638acd300fa42a2d0128378a37bffae2c11315ad"}], "stats": {"total": 262, "additions": 149, "deletions": 113}, "files": [{"sha": "5d0913e8eb479f865428cd4dc392cb89c593e028", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "patch": "@@ -53,14 +53,25 @@ impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n     }\n }\n \n+/// Every two-phase borrow has *exactly one* use (or else it is not a\n+/// proper two-phase borrow under our current definition. However, not\n+/// all uses are actually ones that activate the reservation.. In\n+/// particular, a shared borrow of a `&mut` does not activate the\n+/// reservation.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+crate enum TwoPhaseUse {\n+    MutActivate,\n+    SharedUse,\n+}\n+\n #[derive(Debug)]\n crate struct BorrowData<'tcx> {\n     /// Location where the borrow reservation starts.\n     /// In many cases, this will be equal to the activation location but not always.\n     crate reserve_location: Location,\n     /// Location where the borrow is activated. None if this is not a\n     /// 2-phase borrow.\n-    crate activation_location: Option<Location>,\n+    crate activation_location: Option<(TwoPhaseUse, Location)>,\n     /// What kind of borrow this is\n     crate kind: mir::BorrowKind,\n     /// The region for which this borrow is live\n@@ -215,17 +226,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                 Some(&borrow_index) => {\n                     let borrow_data = &mut self.idx_vec[borrow_index];\n \n-                    // Watch out: the use of TMP in the borrow\n-                    // itself doesn't count as an\n-                    // activation. =)\n+                    // Watch out: the use of TMP in the borrow itself\n+                    // doesn't count as an activation. =)\n                     if borrow_data.reserve_location == location && context == PlaceContext::Store {\n                         return;\n                     }\n \n                     if let Some(other_activation) = borrow_data.activation_location {\n                         span_bug!(\n                             self.mir.source_info(location).span,\n-                            \"found two activations for 2-phase borrow temporary {:?}: \\\n+                            \"found two uses for 2-phase borrow temporary {:?}: \\\n                              {:?} and {:?}\",\n                             temp,\n                             location,\n@@ -235,11 +245,25 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n \n                     // Otherwise, this is the unique later use\n                     // that we expect.\n-                    borrow_data.activation_location = Some(location);\n-                    self.activation_map\n-                        .entry(location)\n-                        .or_insert(Vec::new())\n-                        .push(borrow_index);\n+\n+                    let two_phase_use;\n+\n+                    match context {\n+                        // The use of TMP in a shared borrow does not\n+                        // count as an actual activation.\n+                        PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. } => {\n+                            two_phase_use = TwoPhaseUse::SharedUse;\n+                        }\n+                        _ => {\n+                            two_phase_use = TwoPhaseUse::MutActivate;\n+                            self.activation_map\n+                                .entry(location)\n+                                .or_insert(Vec::new())\n+                                .push(borrow_index);\n+                        }\n+                    }\n+\n+                    borrow_data.activation_location = Some((two_phase_use, location));\n                 }\n \n                 None => {}"}, {"sha": "4871d427d0767bc7bc6ebd2caddbb4ce8210f703", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "patch": "@@ -12,7 +12,7 @@\n /// allowed to be split into separate Reservation and\n /// Activation phases.\n use borrow_check::ArtificialField;\n-use borrow_check::borrow_set::{BorrowSet, BorrowData};\n+use borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseUse};\n use borrow_check::{Context, Overlap};\n use borrow_check::{ShallowOrDeep, Deep, Shallow};\n use dataflow::indexes::BorrowIndex;\n@@ -431,10 +431,13 @@ pub(super) fn is_active<'tcx>(\n ) -> bool {\n     debug!(\"is_active(borrow_data={:?}, location={:?})\", borrow_data, location);\n \n-    // If this is not a 2-phase borrow, it is always active.\n     let activation_location = match borrow_data.activation_location {\n-        Some(v) => v,\n+        // If this is not a 2-phase borrow, it is always active.\n         None => return true,\n+        // And if the unique 2-phase use is not an activation, then it is *never* active.\n+        Some((TwoPhaseUse::SharedUse, _)) => return false,\n+        // Otherwise, we derive info from the activation point `v`:\n+        Some((TwoPhaseUse::MutActivate, v)) => v,\n     };\n \n     // Otherwise, it is active for every location *except* in between"}, {"sha": "964841e7a9ed4c1d8ae29f0bdbeb54862e57a6e4", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "patch": "@@ -11,7 +11,7 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::ForGuard::{OutsideGuard, WithinGuard};\n+use build::ForGuard::{OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::expr::category::Category;\n use hair::*;\n use rustc::mir::*;\n@@ -88,10 +88,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::VarRef { id } => {\n                 let place = if this.is_bound_var_in_guard(id) {\n-                    let index = this.var_local_id(id, WithinGuard);\n                     if this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards() {\n+                        let index = this.var_local_id(id, RefWithinGuard);\n                         Place::Local(index).deref()\n                     } else {\n+                        let index = this.var_local_id(id, ValWithinGuard);\n                         Place::Local(index)\n                     }\n                 } else {"}, {"sha": "552066e67972155fa82dd004764429273b5adcbe", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 93, "deletions": 90, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "patch": "@@ -15,7 +15,7 @@\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use build::ForGuard::{self, OutsideGuard, WithinGuard};\n+use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::ty::{self, Ty};\n@@ -88,12 +88,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         let mut arm_blocks = ArmBlocks {\n             blocks: arms.iter()\n-                .map(|_| {\n-                    let arm_block = self.cfg.start_new_block();\n-                    arm_block\n-                })\n-                .collect(),\n-\n+                        .map(|_| self.cfg.start_new_block())\n+                        .collect(),\n         };\n \n         // Get the arm bodies and their scopes, while declaring bindings.\n@@ -110,9 +106,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().fold(0, |ac, c| ac + c.patterns.len());\n         let pre_binding_blocks: Vec<_> = (0..candidate_count + 1)\n-            .map(|_| self.cfg.start_new_block())\n-\n-            .collect();\n+            .map(|_| self.cfg.start_new_block()).collect();\n \n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n@@ -315,7 +309,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n \n         block.unit()\n     }\n@@ -956,22 +950,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //      (because all we have is the places associated with the\n         //      match input itself; it is up to us to create a place\n         //      holding a `&` or `&mut` that we can then borrow).\n-        //\n-        //    * Therefore, when the binding is by-reference, we\n-        //      *eagerly* introduce the binding for the arm body\n-        //      (`tmp2`) and then borrow it (`tmp1`).\n-        //\n-        //    * This is documented with \"NOTE tricky business\" below.\n-        //\n-        // FIXME The distinction in how `tmp2` is initialized is\n-        // currently encoded in a pretty awkward fashion; namely, by\n-        // passing a boolean to bind_matched_candidate_for_arm_body\n-        // indicating whether all of the by-ref bindings were already\n-        // initialized.\n-        //\n-        // * Also: pnkfelix thinks \"laziness\" is natural; but since\n-        //   MIR-borrowck did not complain with earlier (universally\n-        //   eager) MIR codegen, laziness might not be *necessary*.\n \n         let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n@@ -985,7 +963,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 debug!(\"Entering guard building context: {:?}\", guard_frame);\n                 self.guard_context.push(guard_frame);\n             } else {\n-                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n             }\n \n             // the block to branch to if the guard fails; if there is no\n@@ -999,14 +977,47 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             let false_edge_block = self.cfg.start_new_block();\n+\n+            // We want to ensure that the matched candidates are bound\n+            // after we have confirmed this candidate *and* any\n+            // associated guard; Binding them on `block` is too soon,\n+            // because that would be before we've checked the result\n+            // from the guard.\n+            //\n+            // But binding them on `arm_block` is *too late*, because\n+            // then all of the candidates for a single arm would be\n+            // bound in the same place, that would cause a case like:\n+            //\n+            // ```rust\n+            // match (30, 2) {\n+            //     (mut x, 1) | (2, mut x) if { true } => { ... }\n+            //     ...                                 // ^^^^^^^ (this is `arm_block`)\n+            // }\n+            // ```\n+            //\n+            // would yield a `arm_block` something like:\n+            //\n+            // ```\n+            // StorageLive(_4);        // _4 is `x`\n+            // _4 = &mut (_1.0: i32);  // this is handling `(mut x, 1)` case\n+            // _4 = &mut (_1.1: i32);  // this is handling `(2, mut x)` case\n+            // ```\n+            //\n+            // and that is clearly not correct.\n+            let post_guard_block = self.cfg.start_new_block();\n             self.cfg.terminate(block, source_info,\n-                               TerminatorKind::if_(self.hir.tcx(), cond, arm_block,\n-                                   false_edge_block));\n+                               TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block,\n+                                                   false_edge_block));\n \n-            let otherwise = self.cfg.start_new_block();\n             if autoref {\n-                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, true);\n+                self.bind_matched_candidate_for_arm_body(post_guard_block, &candidate.bindings);\n             }\n+\n+            self.cfg.terminate(post_guard_block, source_info,\n+                               TerminatorKind::Goto { target: arm_block });\n+\n+            let otherwise = self.cfg.start_new_block();\n+\n             self.cfg.terminate(false_edge_block, source_info,\n                                TerminatorKind::FalseEdges {\n                                    real_target: otherwise,\n@@ -1015,13 +1026,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                });\n             Some(otherwise)\n         } else {\n-            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+            // (Here, it is not too early to bind the matched\n+            // candidate on `block`, because there is no guard result\n+            // that we have to inspect before we bind them.)\n+            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n             self.cfg.terminate(block, candidate_source_info,\n                                TerminatorKind::Goto { target: arm_block });\n             None\n         }\n     }\n \n+    // Only called when all_pat_vars_are_implicit_refs_within_guards,\n+    // and thus all code/comments assume we are in that context.\n     fn bind_matched_candidate_for_guard(&mut self,\n                                         block: BasicBlock,\n                                         bindings: &[Binding<'tcx>]) {\n@@ -1034,81 +1050,66 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let re_empty = self.hir.tcx().types.re_empty;\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n-            let local_for_guard = self.storage_live_binding(\n-                block, binding.var_id, binding.span, WithinGuard);\n+\n+            // For each pattern ident P of type T, `ref_for_guard` is\n+            // a reference R: &T pointing to the location matched by\n+            // the pattern, and every occurrence of P within a guard\n+            // denotes *R.\n+            let ref_for_guard = self.storage_live_binding(\n+                block, binding.var_id, binding.span, RefWithinGuard);\n             // Question: Why schedule drops if bindings are all\n             // shared-&'s?  Answer: Because schedule_drop_for_binding\n             // also emits StorageDead's for those locals.\n-            self.schedule_drop_for_binding(binding.var_id, binding.span, WithinGuard);\n+            self.schedule_drop_for_binding(binding.var_id, binding.span, RefWithinGuard);\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_empty, BorrowKind::Shared, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(region, borrow_kind) => {\n-                    // NOTE tricky business: For `ref id` and `ref mut\n-                    // id` patterns, we want `id` within the guard to\n+                    // Tricky business: For `ref id` and `ref mut id`\n+                    // patterns, we want `id` within the guard to\n                     // correspond to a temp of type `& &T` or `& &mut\n-                    // T`, while within the arm body it will\n-                    // correspond to a temp of type `&T` or `&mut T`,\n-                    // as usual.\n-                    //\n-                    // But to inject the level of indirection, we need\n-                    // something to point to.\n+                    // T` (i.e. a \"borrow of a borrow\") that is\n+                    // implicitly dereferenced.\n                     //\n-                    // So:\n+                    // To borrow a borrow, we need that inner borrow\n+                    // to point to. So, create a temp for the inner\n+                    // borrow, and then take a reference to it.\n                     //\n-                    // 1. First set up the local for the arm body\n-                    //   (even though we have not yet evaluated the\n-                    //   guard itself),\n-                    //\n-                    // 2. Then setup the local for the guard, which is\n-                    //    just a reference to the local from step 1.\n-                    //\n-                    // Note that since we are setting up the local for\n-                    // the arm body a bit eagerly here (and likewise\n-                    // scheduling its drop code), we should *not* do\n-                    // it redundantly later on.\n-                    //\n-                    // While we could have kept track of this with a\n-                    // flag or collection of such bindings, the\n-                    // treatment of all of these cases is uniform, so\n-                    // we should be safe just avoiding the code\n-                    // without maintaining such state.)\n-                    let local_for_arm_body = self.storage_live_binding(\n-                        block, binding.var_id, binding.span, OutsideGuard);\n-                    self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n-\n-                    // rust-lang/rust#27282: this potentially mutable\n-                    // borrow may require a cast in the future to\n-                    // avoid conflicting with an implicit borrow of\n-                    // the whole match input; or maybe it just\n-                    // requires an extension of our two-phase borrows\n-                    // system. See discussion on rust-lang/rust#49870.\n+                    // Note: the temp created here is *not* the one\n+                    // used by the arm body itself. This eases\n+                    // observing two-phase borrow restrictions.\n+                    let val_for_guard = self.storage_live_binding(\n+                        block, binding.var_id, binding.span, ValWithinGuard);\n+                    self.schedule_drop_for_binding(binding.var_id, binding.span, ValWithinGuard);\n+\n+                    // rust-lang/rust#27282: We reuse the two-phase\n+                    // borrow infrastructure so that the mutable\n+                    // borrow (whose mutabilty is *unusable* within\n+                    // the guard) does not conflict with the implicit\n+                    // borrow of the whole match input. See additional\n+                    // discussion on rust-lang/rust#49870.\n+                    let borrow_kind = match borrow_kind {\n+                        BorrowKind::Shared | BorrowKind::Unique => borrow_kind,\n+                        BorrowKind::Mut { .. } => BorrowKind::Mut { allow_two_phase_borrow: true },\n+                    };\n                     let rvalue = Rvalue::Ref(region, borrow_kind, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &local_for_arm_body, rvalue);\n-                    let rvalue = Rvalue::Ref(region, BorrowKind::Shared, local_for_arm_body);\n-                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                    self.cfg.push_assign(block, source_info, &val_for_guard, rvalue);\n+                    let rvalue = Rvalue::Ref(region, BorrowKind::Shared, val_for_guard);\n+                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n             }\n         }\n     }\n \n     fn bind_matched_candidate_for_arm_body(&mut self,\n                                            block: BasicBlock,\n-                                           bindings: &[Binding<'tcx>],\n-                                           already_initialized_state_for_refs: bool) {\n-        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}, \\\n-                already_initialized_state_for_refs={:?})\",\n-               block, bindings, already_initialized_state_for_refs);\n+                                           bindings: &[Binding<'tcx>]) {\n+        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\", block, bindings);\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n-            if let BindingMode::ByRef(..) = binding.binding_mode {\n-                // See \"NOTE tricky business\" above\n-                if already_initialized_state_for_refs { continue; }\n-            }\n-\n             let source_info = self.source_info(binding.span);\n             let local = self.storage_live_binding(block, binding.var_id, binding.span,\n                                                   OutsideGuard);\n@@ -1145,17 +1146,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                var_id, name, var_ty, source_info, syntactic_scope);\n \n         let tcx = self.hir.tcx();\n-        let for_arm_body = self.local_decls.push(LocalDecl::<'tcx> {\n+        let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty.clone(),\n             name: Some(name),\n             source_info,\n             syntactic_scope,\n             internal: false,\n             is_user_variable: true,\n-        });\n+        };\n+        let for_arm_body = self.local_decls.push(local.clone());\n         let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n-            let for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n+            let val_for_guard =  self.local_decls.push(local);\n+            let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n                 mutability,\n                 ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n                 name: Some(name),\n@@ -1164,7 +1167,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 internal: false,\n                 is_user_variable: true,\n             });\n-            LocalsForNode::Two { for_guard, for_arm_body }\n+            LocalsForNode::Three { val_for_guard, ref_for_guard, for_arm_body }\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };"}, {"sha": "4822b9e4dfd81a6995dd728ef1ac31e1e2ab4778", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3bc5073dbb9e284a64ae8815bdb54d3b1d6c484a", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n #[derive(Debug)]\n enum LocalsForNode {\n     One(Local),\n-    Two { for_guard: Local, for_arm_body: Local },\n+    Three { val_for_guard: Local, ref_for_guard: Local, for_arm_body: Local },\n }\n \n #[derive(Debug)]\n@@ -325,24 +325,29 @@ struct GuardFrame {\n     locals: Vec<GuardFrameLocal>,\n }\n \n-/// ForGuard is isomorphic to a boolean flag. It indicates whether we are\n-/// talking about the temp for a local binding for a use within a guard expression,\n-/// or a temp for use outside of a guard expressions.\n+/// ForGuard indicates whether we are talking about:\n+///   1. the temp for a local binding used solely within guard expressions,\n+///   2. the temp that holds reference to (1.), which is actually what the\n+///      guard expressions see, or\n+///   3. the temp for use outside of guard expressions.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ForGuard {\n-    WithinGuard,\n+    ValWithinGuard,\n+    RefWithinGuard,\n     OutsideGuard,\n }\n \n impl LocalsForNode {\n     fn local_id(&self, for_guard: ForGuard) -> Local {\n         match (self, for_guard) {\n             (&LocalsForNode::One(local_id), ForGuard::OutsideGuard) |\n-            (&LocalsForNode::Two { for_guard: local_id, .. }, ForGuard::WithinGuard) |\n-            (&LocalsForNode::Two { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n+            (&LocalsForNode::Three { val_for_guard: local_id, .. }, ForGuard::ValWithinGuard) |\n+            (&LocalsForNode::Three { ref_for_guard: local_id, .. }, ForGuard::RefWithinGuard) |\n+            (&LocalsForNode::Three { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n                 local_id,\n \n-            (&LocalsForNode::One(_), ForGuard::WithinGuard) =>\n+            (&LocalsForNode::One(_), ForGuard::ValWithinGuard) |\n+            (&LocalsForNode::One(_), ForGuard::RefWithinGuard) =>\n                 bug!(\"anything with one local should never be within a guard.\"),\n         }\n     }"}]}