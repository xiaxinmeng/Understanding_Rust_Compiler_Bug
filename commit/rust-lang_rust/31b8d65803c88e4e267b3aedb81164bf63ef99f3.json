{"sha": "31b8d65803c88e4e267b3aedb81164bf63ef99f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYjhkNjU4MDNjODhlNGUyNjdiM2FlZGI4MTE2NGJmNjNlZjk5ZjM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-05T11:13:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-05T11:13:14Z"}, "message": "Rollup merge of #70806 - RalfJung:miri-assignment-check, r=eddyb\n\nfix Miri assignment sanity check\n\nThanks @eddyb for pointing me to the right APIs!\n\nr? @eddyb\nFixes https://github.com/rust-lang/rust/issues/70804", "tree": {"sha": "63d42c0cdf224a25a8bea5be1c6cfc2cc190555c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63d42c0cdf224a25a8bea5be1c6cfc2cc190555c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31b8d65803c88e4e267b3aedb81164bf63ef99f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeib1KCRBK7hj4Ov3rIwAAdHIIAKby4Ff1qSQCf2TcxRTDA9st\nABIwZEACiWtPhQrdYMMS8tPUbkUakFyHJ9UfA81xAHijwnTKLjnTxWUnHvlYVzyV\nzakLDfI1Uvmey0gEXiTfgGBKC4nWRpTXd4NgDd580iKpW8Fa16NueNAGKhbRQBSq\nLsZyx0txpUVHR2nKWh9Z6kNjmUSKHccNd4OArPdgNhoaq2x4r6ukm/LssxDxhpYy\nSnOMpWUZFeUcCfxNuTdbJFH2AXCkUTT4+YSRz8PQ+8aKMiVmUjb0negvtLHNO2IS\nAO/r2wC04uammSHXnXmnpsatfhJGu1+iYK/OvcbVLOptknZX5wxmteUzzcaWT1g=\n=sLLR\n-----END PGP SIGNATURE-----\n", "payload": "tree 63d42c0cdf224a25a8bea5be1c6cfc2cc190555c\nparent c185c4fe4740227100c869da44825ca6eb80be74\nparent e52a4519131bccc732f53ec13582016bb2b1d04a\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586085194 +0200\ncommitter GitHub <noreply@github.com> 1586085194 +0200\n\nRollup merge of #70806 - RalfJung:miri-assignment-check, r=eddyb\n\nfix Miri assignment sanity check\n\nThanks @eddyb for pointing me to the right APIs!\n\nr? @eddyb\nFixes https://github.com/rust-lang/rust/issues/70804\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31b8d65803c88e4e267b3aedb81164bf63ef99f3", "html_url": "https://github.com/rust-lang/rust/commit/31b8d65803c88e4e267b3aedb81164bf63ef99f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31b8d65803c88e4e267b3aedb81164bf63ef99f3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c185c4fe4740227100c869da44825ca6eb80be74", "url": "https://api.github.com/repos/rust-lang/rust/commits/c185c4fe4740227100c869da44825ca6eb80be74", "html_url": "https://github.com/rust-lang/rust/commit/c185c4fe4740227100c869da44825ca6eb80be74"}, {"sha": "e52a4519131bccc732f53ec13582016bb2b1d04a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e52a4519131bccc732f53ec13582016bb2b1d04a", "html_url": "https://github.com/rust-lang/rust/commit/e52a4519131bccc732f53ec13582016bb2b1d04a"}], "stats": {"total": 68, "additions": 49, "deletions": 19}, "files": [{"sha": "0b182d42287159f0875dac674eb5823ee2df5bf8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/31b8d65803c88e4e267b3aedb81164bf63ef99f3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b8d65803c88e4e267b3aedb81164bf63ef99f3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=31b8d65803c88e4e267b3aedb81164bf63ef99f3", "patch": "@@ -14,11 +14,11 @@ use rustc_middle::mir::interpret::{\n     sign_extend, truncate, AllocId, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n-use rustc_middle::ty::query::TyCtxtAt;\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, fold::BottomUpFolder, query::TyCtxtAt, subst::SubstsRef, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_target::abi::{Abi, Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n+use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n@@ -213,30 +213,50 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n /// Test if it is valid for a MIR assignment to assign `src`-typed place to `dest`-typed value.\n /// This test should be symmetric, as it is primarily about layout compatibility.\n pub(super) fn mir_assign_valid_types<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     src: TyAndLayout<'tcx>,\n     dest: TyAndLayout<'tcx>,\n ) -> bool {\n     if src.ty == dest.ty {\n         // Equal types, all is good.\n         return true;\n     }\n-    // Type-changing assignments can happen for (at least) two reasons:\n-    // - `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n-    // - Subtyping is used. While all normal lifetimes are erased, higher-ranked lifetime\n-    //   bounds are still around and can lead to type differences.\n-    // There is no good way to check the latter, so we compare layouts instead -- but only\n-    // for values with `Scalar`/`ScalarPair` abi.\n-    // FIXME: Do something more accurate, type-based.\n-    match &src.abi {\n-        Abi::Scalar(..) | Abi::ScalarPair(..) => src.layout == dest.layout,\n-        _ => false,\n+    if src.layout != dest.layout {\n+        // Layout differs, definitely not equal.\n+        // We do this here because Miri would *do the wrong thing* if we allowed layout-changing\n+        // assignments.\n+        return false;\n     }\n+\n+    // Type-changing assignments can happen for (at least) two reasons:\n+    // 1. `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n+    // 2. Subtyping is used. While all normal lifetimes are erased, higher-ranked types\n+    //    with their late-bound lifetimes are still around and can lead to type differences.\n+    // Normalize both of them away.\n+    let normalize = |ty: Ty<'tcx>| {\n+        ty.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            // Normalize all references to immutable.\n+            ty_op: |ty| match ty.kind {\n+                ty::Ref(_, pointee, _) => tcx.mk_imm_ref(tcx.lifetimes.re_erased, pointee),\n+                _ => ty,\n+            },\n+            // We just erase all late-bound lifetimes, but this is not fully correct (FIXME):\n+            // lifetimes in invariant positions could matter (e.g. through associated types).\n+            // We rely on the fact that layout was confirmed to be equal above.\n+            lt_op: |_| tcx.lifetimes.re_erased,\n+            // Leave consts unchanged.\n+            ct_op: |ct| ct,\n+        })\n+    };\n+    normalize(src.ty) == normalize(dest.ty)\n }\n \n /// Use the already known layout if given (but sanity check in debug mode),\n /// or compute the layout.\n #[cfg_attr(not(debug_assertions), inline(always))]\n pub(super) fn from_known_layout<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     known_layout: Option<TyAndLayout<'tcx>>,\n     compute: impl FnOnce() -> InterpResult<'tcx, TyAndLayout<'tcx>>,\n ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n@@ -246,7 +266,7 @@ pub(super) fn from_known_layout<'tcx>(\n             if cfg!(debug_assertions) {\n                 let check_layout = compute()?;\n                 assert!(\n-                    mir_assign_valid_types(check_layout, known_layout),\n+                    mir_assign_valid_types(tcx, check_layout, known_layout),\n                     \"expected type differs from actual type.\\nexpected: {:?}\\nactual: {:?}\",\n                     known_layout.ty,\n                     check_layout.ty,\n@@ -424,7 +444,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n-                let layout = from_known_layout(layout, || {\n+                let layout = from_known_layout(self.tcx.tcx, layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n                         self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);"}, {"sha": "03614b2803f65fe2e33091aeabe14e5f3dbff03d", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31b8d65803c88e4e267b3aedb81164bf63ef99f3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b8d65803c88e4e267b3aedb81164bf63ef99f3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=31b8d65803c88e4e267b3aedb81164bf63ef99f3", "patch": "@@ -529,7 +529,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Value(val_val) => val_val,\n         };\n         // Other cases need layout.\n-        let layout = from_known_layout(layout, || self.layout_of(val.ty))?;\n+        let layout = from_known_layout(self.tcx.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);"}, {"sha": "716c7c7d933677863efd504fc75d86d9acf8559b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31b8d65803c88e4e267b3aedb81164bf63ef99f3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b8d65803c88e4e267b3aedb81164bf63ef99f3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=31b8d65803c88e4e267b3aedb81164bf63ef99f3", "patch": "@@ -868,7 +868,7 @@ where\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n         assert!(\n-            mir_assign_valid_types(src.layout, dest.layout),\n+            mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout),\n             \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n             src.layout.ty,\n             dest.layout.ty,\n@@ -922,7 +922,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(src.layout, dest.layout) {\n+        if mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }"}, {"sha": "59d46ea66c9ca66d6719dd609ef31b83b5b8da28", "filename": "src/test/ui/consts/const-eval/issue-70804-fn-subtyping.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31b8d65803c88e4e267b3aedb81164bf63ef99f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-70804-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b8d65803c88e4e267b3aedb81164bf63ef99f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-70804-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-70804-fn-subtyping.rs?ref=31b8d65803c88e4e267b3aedb81164bf63ef99f3", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+#![feature(const_fn)]\n+\n+const fn nested(x: (for<'a> fn(&'a ()), String)) -> (fn(&'static ()), String) {\n+    x\n+}\n+\n+pub const TEST: (fn(&'static ()), String) = nested((|_x| (), String::new()));\n+\n+fn main() {}"}]}