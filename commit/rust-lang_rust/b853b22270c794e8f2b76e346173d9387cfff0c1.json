{"sha": "b853b22270c794e8f2b76e346173d9387cfff0c1", "node_id": "C_kwDOAAsO6NoAKGI4NTNiMjIyNzBjNzk0ZThmMmI3NmUzNDYxNzNkOTM4N2NmZmYwYzE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-01T04:54:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-01T04:54:38Z"}, "message": "Rollup merge of #107470 - kadiwa4:bootstrap_cleanup, r=albertlarsan68\n\nSmall bootstrap improvements\n\n- i/o-less check for `xz` availability\n- cache result of NixOS detection\n- load correct `bootstrap` module even when a package of that name is installed\n- no `-W semicolon_in_expressions_from_macros` \u2013\u00a0it is warn-by-default\n- one type per variable (making dynamic typing less confusing)\n- integrate python-side `--help` flag into the argument parser (makes `-hv` work as a short form of `--help --verbose`)\n\nI even checked that it works with Python 2.", "tree": {"sha": "84e6065258f4fbe5db20f6c42e07ddfc9c09b786", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84e6065258f4fbe5db20f6c42e07ddfc9c09b786"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b853b22270c794e8f2b76e346173d9387cfff0c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj2fCOCRBK7hj4Ov3rIwAAZcoIAJ8NvdbrVUuBqLRpjERT+lNi\nXNJFuNTmjTMa+tdXIxpOXisB7HVCoyDICzabC4nelmlAkoSq8EkqoK5TxsAq95uQ\nRm8miTyjLEXD2UQMjt60q8+uVL/4t0UdE9by9//zP3MJTEpepjP+oH4W1oputRbt\n9U6FgAM55oK2ekJ7m9bNKfHAQB3sTY410sSYX/JYRtiWuTvKKxK70kcgDbvQ7XTb\nzMiPNKWWqLmQdB9/XNQ4oW7v38eOP8dMCd1Ckzq3nGrZBJehG8y88PJ1kTy5b5dy\nVAFR7xxTmM7Zrx207V98h8rqJf66Pc4Z1SYg5ziXDTdKyfEHAc/kdxX/PFtXvrM=\n=i/o7\n-----END PGP SIGNATURE-----\n", "payload": "tree 84e6065258f4fbe5db20f6c42e07ddfc9c09b786\nparent 1dbb5efff35b98f8e11dab87d0a98136e6cf9390\nparent 043c634a9cbe6ee303eadd0a31b11203b9ef9386\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1675227278 +0100\ncommitter GitHub <noreply@github.com> 1675227278 +0100\n\nRollup merge of #107470 - kadiwa4:bootstrap_cleanup, r=albertlarsan68\n\nSmall bootstrap improvements\n\n- i/o-less check for `xz` availability\n- cache result of NixOS detection\n- load correct `bootstrap` module even when a package of that name is installed\n- no `-W semicolon_in_expressions_from_macros` \u2013\u00a0it is warn-by-default\n- one type per variable (making dynamic typing less confusing)\n- integrate python-side `--help` flag into the argument parser (makes `-hv` work as a short form of `--help --verbose`)\n\nI even checked that it works with Python 2.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b853b22270c794e8f2b76e346173d9387cfff0c1", "html_url": "https://github.com/rust-lang/rust/commit/b853b22270c794e8f2b76e346173d9387cfff0c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b853b22270c794e8f2b76e346173d9387cfff0c1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dbb5efff35b98f8e11dab87d0a98136e6cf9390", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dbb5efff35b98f8e11dab87d0a98136e6cf9390", "html_url": "https://github.com/rust-lang/rust/commit/1dbb5efff35b98f8e11dab87d0a98136e6cf9390"}, {"sha": "043c634a9cbe6ee303eadd0a31b11203b9ef9386", "url": "https://api.github.com/repos/rust-lang/rust/commits/043c634a9cbe6ee303eadd0a31b11203b9ef9386", "html_url": "https://github.com/rust-lang/rust/commit/043c634a9cbe6ee303eadd0a31b11203b9ef9386"}], "stats": {"total": 361, "additions": 190, "deletions": 171}, "files": [{"sha": "5b19a658fb5432c0d4983860fd449f19313ac2d3", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 111, "deletions": 115, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/b853b22270c794e8f2b76e346173d9387cfff0c1/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/b853b22270c794e8f2b76e346173d9387cfff0c1/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=b853b22270c794e8f2b76e346173d9387cfff0c1", "patch": "@@ -2,7 +2,6 @@\n import argparse\n import contextlib\n import datetime\n-import distutils.version\n import hashlib\n import json\n import os\n@@ -13,17 +12,17 @@\n import tarfile\n import tempfile\n \n-from time import time, sleep\n+from time import time\n \n-def support_xz():\n-    try:\n-        with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n-            temp_path = temp_file.name\n-        with tarfile.open(temp_path, \"w:xz\"):\n-            pass\n-        return True\n-    except tarfile.CompressionError:\n-        return False\n+try:\n+    import lzma\n+except ImportError:\n+    lzma = None\n+\n+if sys.platform == 'win32':\n+    EXE_SUFFIX = \".exe\"\n+else:\n+    EXE_SUFFIX = \"\"\n \n def get(base, url, path, checksums, verbose=False):\n     with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n@@ -61,7 +60,7 @@ def get(base, url, path, checksums, verbose=False):\n \n \n def download(path, url, probably_big, verbose):\n-    for _ in range(0, 4):\n+    for _ in range(4):\n         try:\n             _download(path, url, probably_big, verbose, True)\n             return\n@@ -395,17 +394,18 @@ class RustBuild(object):\n     def __init__(self):\n         self.checksums_sha256 = {}\n         self.stage0_compiler = None\n-        self._download_url = ''\n+        self.download_url = ''\n         self.build = ''\n         self.build_dir = ''\n         self.clean = False\n         self.config_toml = ''\n         self.rust_root = ''\n-        self.use_locked_deps = ''\n-        self.use_vendored_sources = ''\n+        self.use_locked_deps = False\n+        self.use_vendored_sources = False\n         self.verbose = False\n         self.git_version = None\n         self.nix_deps_dir = None\n+        self._should_fix_bins_and_dylibs = None\n \n     def download_toolchain(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n@@ -426,7 +426,7 @@ def download_toolchain(self):\n                  self.program_out_of_date(self.rustc_stamp(), key)):\n             if os.path.exists(bin_root):\n                 shutil.rmtree(bin_root)\n-            tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n+            tarball_suffix = '.tar.gz' if lzma is None else '.tar.xz'\n             filename = \"rust-std-{}-{}{}\".format(\n                 rustc_channel, self.build, tarball_suffix)\n             pattern = \"rust-std-{}\".format(self.build)\n@@ -437,15 +437,17 @@ def download_toolchain(self):\n             filename = \"cargo-{}-{}{}\".format(rustc_channel, self.build,\n                                             tarball_suffix)\n             self._download_component_helper(filename, \"cargo\", tarball_suffix)\n-            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(bin_root))\n-\n-            self.fix_bin_or_dylib(\"{}/bin/rustc\".format(bin_root))\n-            self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(bin_root))\n-            self.fix_bin_or_dylib(\"{}/libexec/rust-analyzer-proc-macro-srv\".format(bin_root))\n-            lib_dir = \"{}/lib\".format(bin_root)\n-            for lib in os.listdir(lib_dir):\n-                if lib.endswith(\".so\"):\n-                    self.fix_bin_or_dylib(os.path.join(lib_dir, lib))\n+            if self.should_fix_bins_and_dylibs():\n+                self.fix_bin_or_dylib(\"{}/bin/cargo\".format(bin_root))\n+\n+                self.fix_bin_or_dylib(\"{}/bin/rustc\".format(bin_root))\n+                self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(bin_root))\n+                self.fix_bin_or_dylib(\"{}/libexec/rust-analyzer-proc-macro-srv\".format(bin_root))\n+                lib_dir = \"{}/lib\".format(bin_root)\n+                for lib in os.listdir(lib_dir):\n+                    if lib.endswith(\".so\"):\n+                        self.fix_bin_or_dylib(os.path.join(lib_dir, lib))\n+\n             with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(key)\n \n@@ -458,60 +460,73 @@ def _download_component_helper(\n         if not os.path.exists(rustc_cache):\n             os.makedirs(rustc_cache)\n \n-        base = self._download_url\n-        url = \"dist/{}\".format(key)\n         tarball = os.path.join(rustc_cache, filename)\n         if not os.path.exists(tarball):\n             get(\n-                base,\n-                \"{}/{}\".format(url, filename),\n+                self.download_url,\n+                \"dist/{}/{}\".format(key, filename),\n                 tarball,\n                 self.checksums_sha256,\n                 verbose=self.verbose,\n             )\n         unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n \n-    def fix_bin_or_dylib(self, fname):\n-        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker,\n-        or the RPATH section, to fix the dynamic library search path\n-\n-        This method is only required on NixOS and uses the PatchELF utility to\n-        change the interpreter/RPATH of ELF executables.\n-\n-        Please see https://nixos.org/patchelf.html for more information\n+    def should_fix_bins_and_dylibs(self):\n+        \"\"\"Whether or not `fix_bin_or_dylib` needs to be run; can only be True\n+        on NixOS.\n         \"\"\"\n-        default_encoding = sys.getdefaultencoding()\n-        try:\n-            ostype = subprocess.check_output(\n-                ['uname', '-s']).strip().decode(default_encoding)\n-        except subprocess.CalledProcessError:\n-            return\n-        except OSError as reason:\n-            if getattr(reason, 'winerror', None) is not None:\n-                return\n-            raise reason\n+        if self._should_fix_bins_and_dylibs is not None:\n+            return self._should_fix_bins_and_dylibs\n \n-        if ostype != \"Linux\":\n-            return\n+        def get_answer():\n+            default_encoding = sys.getdefaultencoding()\n+            try:\n+                ostype = subprocess.check_output(\n+                    ['uname', '-s']).strip().decode(default_encoding)\n+            except subprocess.CalledProcessError:\n+                return False\n+            except OSError as reason:\n+                if getattr(reason, 'winerror', None) is not None:\n+                    return False\n+                raise reason\n+\n+            if ostype != \"Linux\":\n+                return False\n+\n+            # If the user has asked binaries to be patched for Nix, then\n+            # don't check for NixOS or `/lib`.\n+            if self.get_toml(\"patch-binaries-for-nix\", \"build\") == \"true\":\n+                return True\n \n-        # If the user has asked binaries to be patched for Nix, then\n-        # don't check for NixOS or `/lib`, just continue to the patching.\n-        if self.get_toml('patch-binaries-for-nix', 'build') != 'true':\n             # Use `/etc/os-release` instead of `/etc/NIXOS`.\n             # The latter one does not exist on NixOS when using tmpfs as root.\n             try:\n                 with open(\"/etc/os-release\", \"r\") as f:\n-                    if not any(l.strip() in [\"ID=nixos\", \"ID='nixos'\", 'ID=\"nixos\"'] for l in f):\n-                        return\n+                    if not any(l.strip() in (\"ID=nixos\", \"ID='nixos'\", 'ID=\"nixos\"') for l in f):\n+                        return False\n             except FileNotFoundError:\n-                return\n+                return False\n             if os.path.exists(\"/lib\"):\n-                return\n+                return False\n+\n+            return True\n+\n+        answer = self._should_fix_bins_and_dylibs = get_answer()\n+        if answer:\n+            print(\"info: You seem to be using Nix.\")\n+        return answer\n+\n+    def fix_bin_or_dylib(self, fname):\n+        \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+        or the RPATH section, to fix the dynamic library search path\n \n-        # At this point we're pretty sure the user is running NixOS or\n-        # using Nix\n-        nix_os_msg = \"info: you seem to be using Nix. Attempting to patch\"\n-        print(nix_os_msg, fname)\n+        This method is only required on NixOS and uses the PatchELF utility to\n+        change the interpreter/RPATH of ELF executables.\n+\n+        Please see https://nixos.org/patchelf.html for more information\n+        \"\"\"\n+        assert self._should_fix_bins_and_dylibs is True\n+        print(\"attempting to patch\", fname)\n \n         # Only build `.nix-deps` once.\n         nix_deps_dir = self.nix_deps_dir\n@@ -666,8 +681,7 @@ def program_config(self, program):\n         config = self.get_toml(program)\n         if config:\n             return os.path.expanduser(config)\n-        return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n-            program, self.exe_suffix()))\n+        return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(program, EXE_SUFFIX))\n \n     @staticmethod\n     def get_string(line):\n@@ -692,13 +706,6 @@ def get_string(line):\n             return line[start + 1:end]\n         return None\n \n-    @staticmethod\n-    def exe_suffix():\n-        \"\"\"Return a suffix for executables\"\"\"\n-        if sys.platform == 'win32':\n-            return '.exe'\n-        return ''\n-\n     def bootstrap_binary(self):\n         \"\"\"Return the path of the bootstrap binary\n \n@@ -710,7 +717,7 @@ def bootstrap_binary(self):\n         \"\"\"\n         return os.path.join(self.build_dir, \"bootstrap\", \"debug\", \"bootstrap\")\n \n-    def build_bootstrap(self, color):\n+    def build_bootstrap(self, color, verbose_count):\n         \"\"\"Build bootstrap\"\"\"\n         print(\"Building bootstrap\")\n         build_dir = os.path.join(self.build_dir, \"bootstrap\")\n@@ -757,7 +764,6 @@ def build_bootstrap(self, color):\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \" -C linker=\" + target_linker\n         env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes\"\n-        env[\"RUSTFLAGS\"] += \" -Wsemicolon_in_expressions_from_macros\"\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n             env[\"RUSTFLAGS\"] += \" -Dwarnings\"\n \n@@ -768,8 +774,7 @@ def build_bootstrap(self, color):\n                 self.cargo()))\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n                 os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n-        for _ in range(0, self.verbose):\n-            args.append(\"--verbose\")\n+        args.extend(\"--verbose\" for _ in range(verbose_count))\n         if self.use_locked_deps:\n             args.append(\"--locked\")\n         if self.use_vendored_sources:\n@@ -792,16 +797,7 @@ def build_triple(self):\n         so use `self.build` where possible.\n         \"\"\"\n         config = self.get_toml('build')\n-        if config:\n-            return config\n-        return default_build_triple(self.verbose)\n-\n-    def set_dist_environment(self, url):\n-        \"\"\"Set download URL for normal environment\"\"\"\n-        if 'RUSTUP_DIST_SERVER' in os.environ:\n-            self._download_url = os.environ['RUSTUP_DIST_SERVER']\n-        else:\n-            self._download_url = url\n+        return config or default_build_triple(self.verbose)\n \n     def check_vendored_status(self):\n         \"\"\"Check that vendoring is configured properly\"\"\"\n@@ -834,31 +830,25 @@ def check_vendored_status(self):\n             if os.path.exists(cargo_dir):\n                 shutil.rmtree(cargo_dir)\n \n-def bootstrap(help_triggered):\n-    \"\"\"Configure, fetch, build and run the initial bootstrap\"\"\"\n-\n-    # If the user is asking for help, let them know that the whole download-and-build\n-    # process has to happen before anything is printed out.\n-    if help_triggered:\n-        print(\"info: Downloading and building bootstrap before processing --help\")\n-        print(\"      command. See src/bootstrap/README.md for help with common\")\n-        print(\"      commands.\")\n-\n-    parser = argparse.ArgumentParser(description='Build rust')\n+def parse_args():\n+    \"\"\"Parse the command line arguments that the python script needs.\"\"\"\n+    parser = argparse.ArgumentParser(add_help=False)\n+    parser.add_argument('-h', '--help', action='store_true')\n     parser.add_argument('--config')\n     parser.add_argument('--build-dir')\n     parser.add_argument('--build')\n     parser.add_argument('--color', choices=['always', 'never', 'auto'])\n     parser.add_argument('--clean', action='store_true')\n     parser.add_argument('-v', '--verbose', action='count', default=0)\n \n-    args = [a for a in sys.argv if a != '-h' and a != '--help']\n-    args, _ = parser.parse_known_args(args)\n+    return parser.parse_known_args(sys.argv)[0]\n \n+def bootstrap(args):\n+    \"\"\"Configure, fetch, build and run the initial bootstrap\"\"\"\n     # Configure initial bootstrap\n     build = RustBuild()\n     build.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n-    build.verbose = args.verbose\n+    build.verbose = args.verbose != 0\n     build.clean = args.clean\n \n     # Read from `--config`, then `RUST_BOOTSTRAP_CONFIG`, then `./config.toml`,\n@@ -886,12 +876,12 @@ def bootstrap(help_triggered):\n         with open(include_path) as included_toml:\n             build.config_toml += os.linesep + included_toml.read()\n \n-    config_verbose = build.get_toml('verbose', 'build')\n-    if config_verbose is not None:\n-        build.verbose = max(build.verbose, int(config_verbose))\n+    verbose_count = args.verbose\n+    config_verbose_count = build.get_toml('verbose', 'build')\n+    if config_verbose_count is not None:\n+        verbose_count = max(args.verbose, int(config_verbose_count))\n \n     build.use_vendored_sources = build.get_toml('vendor', 'build') == 'true'\n-\n     build.use_locked_deps = build.get_toml('locked-deps', 'build') == 'true'\n \n     build.check_vendored_status()\n@@ -903,8 +893,7 @@ def bootstrap(help_triggered):\n         data = json.load(f)\n     build.checksums_sha256 = data[\"checksums_sha256\"]\n     build.stage0_compiler = Stage0Toolchain(data[\"compiler\"])\n-\n-    build.set_dist_environment(data[\"config\"][\"dist_server\"])\n+    build.download_url = os.getenv(\"RUSTUP_DIST_SERVER\") or data[\"config\"][\"dist_server\"]\n \n     build.build = args.build or build.build_triple()\n \n@@ -914,7 +903,7 @@ def bootstrap(help_triggered):\n     # Fetch/build the bootstrap\n     build.download_toolchain()\n     sys.stdout.flush()\n-    build.build_bootstrap(args.color)\n+    build.build_bootstrap(args.color, verbose_count)\n     sys.stdout.flush()\n \n     # Run the bootstrap\n@@ -932,25 +921,32 @@ def main():\n \n     # x.py help <cmd> ...\n     if len(sys.argv) > 1 and sys.argv[1] == 'help':\n-        sys.argv = [sys.argv[0], '-h'] + sys.argv[2:]\n+        sys.argv[1] = '-h'\n+\n+    args = parse_args()\n+    help_triggered = args.help or len(sys.argv) == 1\n \n-    help_triggered = (\n-        '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n+    # If the user is asking for help, let them know that the whole download-and-build\n+    # process has to happen before anything is printed out.\n+    if help_triggered:\n+        print(\n+            \"info: Downloading and building bootstrap before processing --help command.\\n\"\n+            \"      See src/bootstrap/README.md for help with common commands.\"\n+        )\n+\n+    exit_code = 0\n     try:\n-        bootstrap(help_triggered)\n-        if not help_triggered:\n-            print(\"Build completed successfully in {}\".format(\n-                format_build_time(time() - start_time)))\n+        bootstrap(args)\n     except (SystemExit, KeyboardInterrupt) as error:\n         if hasattr(error, 'code') and isinstance(error.code, int):\n             exit_code = error.code\n         else:\n             exit_code = 1\n             print(error)\n-        if not help_triggered:\n-            print(\"Build completed unsuccessfully in {}\".format(\n-                format_build_time(time() - start_time)))\n-        sys.exit(exit_code)\n+\n+    if not help_triggered:\n+        print(\"Build completed successfully in\", format_build_time(time() - start_time))\n+    sys.exit(exit_code)\n \n \n if __name__ == '__main__':"}, {"sha": "bd67978a7662ee1d61c9d572d6194c8b243276c0", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 77, "deletions": 55, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b853b22270c794e8f2b76e346173d9387cfff0c1/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b853b22270c794e8f2b76e346173d9387cfff0c1/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=b853b22270c794e8f2b76e346173d9387cfff0c1", "patch": "@@ -18,6 +18,8 @@ use crate::{\n     Config,\n };\n \n+static SHOULD_FIX_BINS_AND_DYLIBS: OnceCell<bool> = OnceCell::new();\n+\n /// Generic helpers that are useful anywhere in bootstrap.\n impl Config {\n     pub fn is_verbose(&self) -> bool {\n@@ -70,53 +72,61 @@ impl Config {\n         check_run(cmd, self.is_verbose())\n     }\n \n-    /// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n-    /// or the RPATH section, to fix the dynamic library search path\n-    ///\n-    /// This is only required on NixOS and uses the PatchELF utility to\n-    /// change the interpreter/RPATH of ELF executables.\n-    ///\n-    /// Please see https://nixos.org/patchelf.html for more information\n-    fn fix_bin_or_dylib(&self, fname: &Path) {\n-        // FIXME: cache NixOS detection?\n-        match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n-            Err(_) => return,\n-            Ok(output) if !output.status.success() => return,\n-            Ok(output) => {\n-                let mut s = output.stdout;\n-                if s.last() == Some(&b'\\n') {\n-                    s.pop();\n-                }\n-                if s != b\"Linux\" {\n-                    return;\n+    /// Whether or not `fix_bin_or_dylib` needs to be run; can only be true\n+    /// on NixOS\n+    fn should_fix_bins_and_dylibs(&self) -> bool {\n+        let val = *SHOULD_FIX_BINS_AND_DYLIBS.get_or_init(|| {\n+            match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n+                Err(_) => return false,\n+                Ok(output) if !output.status.success() => return false,\n+                Ok(output) => {\n+                    let mut os_name = output.stdout;\n+                    if os_name.last() == Some(&b'\\n') {\n+                        os_name.pop();\n+                    }\n+                    if os_name != b\"Linux\" {\n+                        return false;\n+                    }\n                 }\n             }\n-        }\n \n-        // If the user has asked binaries to be patched for Nix, then\n-        // don't check for NixOS or `/lib`, just continue to the patching.\n-        // NOTE: this intentionally comes after the Linux check:\n-        // - patchelf only works with ELF files, so no need to run it on Mac or Windows\n-        // - On other Unix systems, there is no stable syscall interface, so Nix doesn't manage the global libc.\n-        if !self.patch_binaries_for_nix {\n+            // If the user has asked binaries to be patched for Nix, then\n+            // don't check for NixOS or `/lib`.\n+            // NOTE: this intentionally comes after the Linux check:\n+            // - patchelf only works with ELF files, so no need to run it on Mac or Windows\n+            // - On other Unix systems, there is no stable syscall interface, so Nix doesn't manage the global libc.\n+            if self.patch_binaries_for_nix {\n+                return true;\n+            }\n+\n             // Use `/etc/os-release` instead of `/etc/NIXOS`.\n             // The latter one does not exist on NixOS when using tmpfs as root.\n-            const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n-            let os_release = match File::open(\"/etc/os-release\") {\n-                Err(e) if e.kind() == ErrorKind::NotFound => return,\n+            let is_nixos = match File::open(\"/etc/os-release\") {\n+                Err(e) if e.kind() == ErrorKind::NotFound => false,\n                 Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n-                Ok(f) => f,\n+                Ok(os_release) => BufReader::new(os_release).lines().any(|l| {\n+                    let l = l.expect(\"reading /etc/os-release\");\n+                    matches!(l.trim(), \"ID=nixos\" | \"ID='nixos'\" | \"ID=\\\"nixos\\\"\")\n+                }),\n             };\n-            if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n-                return;\n-            }\n-            if Path::new(\"/lib\").exists() {\n-                return;\n-            }\n+            is_nixos && !Path::new(\"/lib\").exists()\n+        });\n+        if val {\n+            println!(\"info: You seem to be using Nix.\");\n         }\n+        val\n+    }\n \n-        // At this point we're pretty sure the user is running NixOS or using Nix\n-        println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n+    /// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+    /// or the RPATH section, to fix the dynamic library search path\n+    ///\n+    /// This is only required on NixOS and uses the PatchELF utility to\n+    /// change the interpreter/RPATH of ELF executables.\n+    ///\n+    /// Please see https://nixos.org/patchelf.html for more information\n+    fn fix_bin_or_dylib(&self, fname: &Path) {\n+        assert_eq!(SHOULD_FIX_BINS_AND_DYLIBS.get(), Some(&true));\n+        println!(\"attempting to patch {}\", fname.display());\n \n         // Only build `.nix-deps` once.\n         static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n@@ -340,8 +350,10 @@ impl Config {\n             \"rustfmt\",\n         );\n \n-        self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustfmt\"));\n-        self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"cargo-fmt\"));\n+        if self.should_fix_bins_and_dylibs() {\n+            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustfmt\"));\n+            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"cargo-fmt\"));\n+        }\n \n         self.create(&rustfmt_stamp, &channel);\n         Some(rustfmt_path)\n@@ -370,16 +382,21 @@ impl Config {\n             let filename = format!(\"rust-src-{version}.tar.xz\");\n             self.download_ci_component(filename, \"rust-src\", commit);\n \n-            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n-            self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n-            self.fix_bin_or_dylib(&bin_root.join(\"libexec\").join(\"rust-analyzer-proc-macro-srv\"));\n-            let lib_dir = bin_root.join(\"lib\");\n-            for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n-                let lib = t!(lib);\n-                if lib.path().extension() == Some(OsStr::new(\"so\")) {\n-                    self.fix_bin_or_dylib(&lib.path());\n+            if self.should_fix_bins_and_dylibs() {\n+                self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n+                self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n+                self.fix_bin_or_dylib(\n+                    &bin_root.join(\"libexec\").join(\"rust-analyzer-proc-macro-srv\"),\n+                );\n+                let lib_dir = bin_root.join(\"lib\");\n+                for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n+                    let lib = t!(lib);\n+                    if lib.path().extension() == Some(OsStr::new(\"so\")) {\n+                        self.fix_bin_or_dylib(&lib.path());\n+                    }\n                 }\n             }\n+\n             t!(fs::write(rustc_stamp, commit));\n         }\n     }\n@@ -471,8 +488,10 @@ impl Config {\n         let key = format!(\"{}{}\", llvm_sha, self.llvm_assertions);\n         if program_out_of_date(&llvm_stamp, &key) && !self.dry_run() {\n             self.download_ci_llvm(&llvm_sha);\n-            for entry in t!(fs::read_dir(llvm_root.join(\"bin\"))) {\n-                self.fix_bin_or_dylib(&t!(entry).path());\n+            if self.should_fix_bins_and_dylibs() {\n+                for entry in t!(fs::read_dir(llvm_root.join(\"bin\"))) {\n+                    self.fix_bin_or_dylib(&t!(entry).path());\n+                }\n             }\n \n             // Update the timestamp of llvm-config to force rustc_llvm to be\n@@ -487,13 +506,16 @@ impl Config {\n             let llvm_config = llvm_root.join(\"bin\").join(exe(\"llvm-config\", self.build));\n             t!(filetime::set_file_times(&llvm_config, now, now));\n \n-            let llvm_lib = llvm_root.join(\"lib\");\n-            for entry in t!(fs::read_dir(&llvm_lib)) {\n-                let lib = t!(entry).path();\n-                if lib.extension().map_or(false, |ext| ext == \"so\") {\n-                    self.fix_bin_or_dylib(&lib);\n+            if self.should_fix_bins_and_dylibs() {\n+                let llvm_lib = llvm_root.join(\"lib\");\n+                for entry in t!(fs::read_dir(&llvm_lib)) {\n+                    let lib = t!(entry).path();\n+                    if lib.extension().map_or(false, |ext| ext == \"so\") {\n+                        self.fix_bin_or_dylib(&lib);\n+                    }\n                 }\n             }\n+\n             t!(fs::write(llvm_stamp, key));\n         }\n     }"}, {"sha": "5dee953a31899ff46fe3f459de48d8249ce2a4b2", "filename": "x.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b853b22270c794e8f2b76e346173d9387cfff0c1/x.py", "raw_url": "https://github.com/rust-lang/rust/raw/b853b22270c794e8f2b76e346173d9387cfff0c1/x.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/x.py?ref=b853b22270c794e8f2b76e346173d9387cfff0c1", "patch": "@@ -22,7 +22,8 @@\n             pass\n \n rust_dir = os.path.dirname(os.path.abspath(__file__))\n-sys.path.append(os.path.join(rust_dir, \"src\", \"bootstrap\"))\n+# For the import below, have Python search in src/bootstrap first.\n+sys.path.insert(0, os.path.join(rust_dir, \"src\", \"bootstrap\"))\n \n import bootstrap\n bootstrap.main()"}]}