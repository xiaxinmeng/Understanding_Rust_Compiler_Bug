{"sha": "629f6e8d68be06bf07f803db64be6a917a66b2cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyOWY2ZThkNjhiZTA2YmYwN2Y4MDNkYjY0YmU2YTkxN2E2NmIyY2Y=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-08T17:48:57Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:56Z"}, "message": "Implement KillHandle::kill() and friends (unkillable, atomically). Close #6377.", "tree": {"sha": "e9f346e4cd5fa667d1bb6195d579aa4fc4add55d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9f346e4cd5fa667d1bb6195d579aa4fc4add55d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/629f6e8d68be06bf07f803db64be6a917a66b2cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/629f6e8d68be06bf07f803db64be6a917a66b2cf", "html_url": "https://github.com/rust-lang/rust/commit/629f6e8d68be06bf07f803db64be6a917a66b2cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/629f6e8d68be06bf07f803db64be6a917a66b2cf/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a993205831f37e6f13f03e4d1bac62cc2dcd373", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a993205831f37e6f13f03e4d1bac62cc2dcd373", "html_url": "https://github.com/rust-lang/rust/commit/2a993205831f37e6f13f03e4d1bac62cc2dcd373"}], "stats": {"total": 264, "additions": 227, "deletions": 37}, "files": [{"sha": "929e69d61732658c372b1ddb8fa78fa31ba442be", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 150, "deletions": 2, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/629f6e8d68be06bf07f803db64be6a917a66b2cf/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f6e8d68be06bf07f803db64be6a917a66b2cf/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=629f6e8d68be06bf07f803db64be6a917a66b2cf", "patch": "@@ -10,15 +10,38 @@\n \n //! Task death: asynchronous killing, linked failure, exit code propagation.\n \n+use cast;\n use cell::Cell;\n use option::{Option, Some, None};\n use prelude::*;\n+use rt::task::Task;\n+use unstable::atomics::{AtomicUint, SeqCst};\n use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n use util;\n \n+static KILLED_MSG: &'static str = \"killed by linked failure\";\n+\n+// State values for the 'killed' and 'unkillable' atomic flags below.\n+static KILL_RUNNING:    uint = 0;\n+static KILL_KILLED:     uint = 1;\n+static KILL_UNKILLABLE: uint = 2;\n+\n // FIXME(#7544)(bblum): think about the cache efficiency of this\n struct KillHandleInner {\n-    // ((more fields to be added in a future commit))\n+    // Is the task running, blocked, or killed? Possible values:\n+    // * KILL_RUNNING    - Not unkillable, no kill pending.\n+    // * KILL_KILLED     - Kill pending.\n+    // * <ptr>           - A transmuted blocked ~Task pointer.\n+    // This flag is refcounted because it may also be referenced by a blocking\n+    // concurrency primitive, used to wake the task normally, whose reference\n+    // may outlive the handle's if the task is killed.\n+    killed: UnsafeAtomicRcBox<AtomicUint>,\n+    // Has the task deferred kill signals? This flag guards the above one.\n+    // Possible values:\n+    // * KILL_RUNNING    - Not unkillable, no kill pending.\n+    // * KILL_KILLED     - Kill pending.\n+    // * KILL_UNKILLABLE - Kill signals deferred.\n+    unkillable: AtomicUint,\n \n     // Shared state between task and children for exit code propagation. These\n     // are here so we can re-use the kill handle to implement watched children\n@@ -47,20 +70,73 @@ pub struct Death {\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n     on_exit:         Option<~fn(bool)>,\n+    // nesting level counter for task::unkillable calls (0 == killable).\n+    unkillable:      int,\n+    // nesting level counter for task::atomically calls (0 == can yield).\n+    wont_sleep:      int,\n }\n \n impl KillHandle {\n     pub fn new() -> KillHandle {\n         KillHandle(UnsafeAtomicRcBox::new(KillHandleInner {\n             // Linked failure fields\n-            // ((none yet))\n+            killed:     UnsafeAtomicRcBox::new(AtomicUint::new(KILL_RUNNING)),\n+            unkillable: AtomicUint::new(KILL_RUNNING),\n             // Exit code propagation fields\n             any_child_failed: false,\n             child_tombstones: None,\n             graveyard_lock:   LittleLock(),\n         }))\n     }\n \n+    // Will begin unwinding if a kill signal was received, unless already_failing.\n+    // This can't be used recursively, because a task which sees a KILLED\n+    // signal must fail immediately, which an already-unkillable task can't do.\n+    #[inline]\n+    pub fn inhibit_kill(&mut self, already_failing: bool) {\n+        let inner = unsafe { &mut *self.get() };\n+        // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n+        // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n+        match inner.unkillable.compare_and_swap(KILL_RUNNING, KILL_UNKILLABLE, SeqCst) {\n+            KILL_RUNNING    => { }, // normal case\n+            KILL_KILLED     => if !already_failing { fail!(KILLED_MSG) },\n+            _               => rtabort!(\"inhibit_kill: task already unkillable\"),\n+        }\n+    }\n+\n+    // Will begin unwinding if a kill signal was received, unless already_failing.\n+    #[inline]\n+    pub fn allow_kill(&mut self, already_failing: bool) {\n+        let inner = unsafe { &mut *self.get() };\n+        // Expect flag to contain UNKILLABLE. If KILLED, it should stay KILLED.\n+        // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n+        match inner.unkillable.compare_and_swap(KILL_UNKILLABLE, KILL_RUNNING, SeqCst) {\n+            KILL_UNKILLABLE => { }, // normal case\n+            KILL_KILLED     => if !already_failing { fail!(KILLED_MSG) },\n+            _               => rtabort!(\"allow_kill: task already killable\"),\n+        }\n+    }\n+\n+    // Send a kill signal to the handle's owning task. Returns the task itself\n+    // if it was blocked and needs punted awake. To be called by other tasks.\n+    pub fn kill(&mut self) -> Option<~Task> {\n+        let inner = unsafe { &mut *self.get() };\n+        if inner.unkillable.swap(KILL_KILLED, SeqCst) == KILL_RUNNING {\n+            // Got in. Allowed to try to punt the task awake.\n+            let flag = unsafe { &mut *inner.killed.get() };\n+            match flag.swap(KILL_KILLED, SeqCst) {\n+                // Task either not blocked or already taken care of.\n+                KILL_RUNNING | KILL_KILLED => None,\n+                // Got ownership of the blocked task.\n+                task_ptr => Some(unsafe { cast::transmute(task_ptr) }),\n+            }\n+        } else {\n+            // Otherwise it was either unkillable or already killed. Somebody\n+            // else was here first who will deal with the kill signal.\n+            None\n+        }\n+    }\n+\n     pub fn notify_immediate_failure(&mut self) {\n         // A benign data race may happen here if there are failing sibling\n         // tasks that were also spawned-watched. The refcount's write barriers\n@@ -123,6 +199,7 @@ impl KillHandle {\n         }\n \n         // NB: Takes a pthread mutex -- 'blk' not allowed to reschedule.\n+        #[inline]\n         fn add_lazy_tombstone(parent: &mut KillHandle,\n                               blk: &fn(Option<~fn() -> bool>) -> ~fn() -> bool) {\n \n@@ -144,6 +221,8 @@ impl Death {\n             kill_handle:     Some(KillHandle::new()),\n             watching_parent: None,\n             on_exit:         None,\n+            unkillable:      0,\n+            wont_sleep:      0,\n         }\n     }\n \n@@ -153,11 +232,22 @@ impl Death {\n             kill_handle:     Some(KillHandle::new()),\n             watching_parent: self.kill_handle.clone(),\n             on_exit:         None,\n+            unkillable:      0,\n+            wont_sleep:      0,\n         }\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n     pub fn collect_failure(&mut self, mut success: bool) {\n+        // This may run after the task has already failed, so even though the\n+        // task appears to need to be killed, the scheduler should not fail us\n+        // when we block to unwrap.\n+        // (XXX: Another less-elegant reason for doing this is so that the use\n+        // of the LittleLock in reparent_children_to doesn't need to access the\n+        // unkillable flag in the kill_handle, since we'll have removed it.)\n+        rtassert!(self.unkillable == 0);\n+        self.unkillable = 1;\n+\n         // Step 1. Decide if we need to collect child failures synchronously.\n         do self.on_exit.take_map |on_exit| {\n             if success {\n@@ -191,6 +281,64 @@ impl Death {\n                 parent_handle.notify_immediate_failure();\n             }\n         };\n+\n+        // Can't use allow_kill directly; that would require the kill handle.\n+        rtassert!(self.unkillable == 1);\n+        self.unkillable = 0;\n+    }\n+\n+    /// Enter a possibly-nested unkillable section of code.\n+    /// All calls must be paired with a subsequent call to allow_kill.\n+    #[inline]\n+    pub fn inhibit_kill(&mut self, already_failing: bool) {\n+        if self.unkillable == 0 {\n+            rtassert!(self.kill_handle.is_some());\n+            self.kill_handle.get_mut_ref().inhibit_kill(already_failing);\n+        }\n+        self.unkillable += 1;\n+    }\n+\n+    /// Exit a possibly-nested unkillable section of code.\n+    /// All calls must be paired with a preceding call to inhibit_kill.\n+    #[inline]\n+    pub fn allow_kill(&mut self, already_failing: bool) {\n+        rtassert!(self.unkillable != 0);\n+        self.unkillable -= 1;\n+        if self.unkillable == 0 {\n+            rtassert!(self.kill_handle.is_some());\n+            self.kill_handle.get_mut_ref().allow_kill(already_failing);\n+        }\n+    }\n+\n+    /// Enter a possibly-nested \"atomic\" section of code. Just for assertions.\n+    /// All calls must be paired with a subsequent call to allow_yield.\n+    #[inline]\n+    pub fn inhibit_yield(&mut self) {\n+        self.wont_sleep += 1;\n+    }\n+\n+    /// Exit a possibly-nested \"atomic\" section of code. Just for assertions.\n+    /// All calls must be paired with a preceding call to inhibit_yield.\n+    #[inline]\n+    pub fn allow_yield(&mut self) {\n+        rtassert!(self.wont_sleep != 0);\n+        self.wont_sleep -= 1;\n+    }\n+\n+    /// Ensure that the task is allowed to become descheduled.\n+    #[inline]\n+    pub fn assert_may_sleep(&self) {\n+        if self.wont_sleep != 0 {\n+            rtabort!(\"illegal atomic-sleep: can't deschedule inside atomically()\");\n+        }\n+    }\n+}\n+\n+impl Drop for Death {\n+    fn drop(&self) {\n+        // Mustn't be in an atomic or unkillable section at task death.\n+        rtassert!(self.unkillable == 0);\n+        rtassert!(self.wont_sleep == 0);\n     }\n }\n "}, {"sha": "f2c1d2ffd9db3403be8c21837f37d5cee0a67d32", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 77, "deletions": 35, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/629f6e8d68be06bf07f803db64be6a917a66b2cf/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f6e8d68be06bf07f803db64be6a917a66b2cf/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=629f6e8d68be06bf07f803db64be6a917a66b2cf", "patch": "@@ -42,7 +42,8 @@ use cmp::Eq;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use result::Result;\n use result;\n-use rt::{context, OldTaskContext};\n+use rt::{context, OldTaskContext, TaskContext};\n+use rt::local::Local;\n use task::rt::{task_id, sched_id};\n use unstable::finally::Finally;\n use util::replace;\n@@ -526,8 +527,6 @@ pub fn yield() {\n pub fn failing() -> bool {\n     //! True if the running task has failed\n \n-    use rt::{context, OldTaskContext};\n-    use rt::local::Local;\n     use rt::task::Task;\n \n     match context() {\n@@ -572,33 +571,59 @@ pub fn get_scheduler() -> Scheduler {\n  * ~~~\n  */\n pub unsafe fn unkillable<U>(f: &fn() -> U) -> U {\n-    if context() == OldTaskContext {\n-        let t = rt::rust_get_task();\n-        do (|| {\n-            rt::rust_task_inhibit_kill(t);\n-            f()\n-        }).finally {\n-            rt::rust_task_allow_kill(t);\n+    use rt::task::Task;\n+\n+    match context() {\n+        OldTaskContext => {\n+            let t = rt::rust_get_task();\n+            do (|| {\n+                rt::rust_task_inhibit_kill(t);\n+                f()\n+            }).finally {\n+                rt::rust_task_allow_kill(t);\n+            }\n+        }\n+        TaskContext => {\n+            // The inhibits/allows might fail and need to borrow the task.\n+            let t = Local::unsafe_borrow::<Task>();\n+            do (|| {\n+                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n+                f()\n+            }).finally {\n+                (*t).death.allow_kill((*t).unwinder.unwinding);\n+            }\n         }\n-    } else {\n-        // FIXME #6377\n-        f()\n+        // FIXME(#3095): This should be an rtabort as soon as the scheduler\n+        // no longer uses a workqueue implemented with an Exclusive.\n+        _ => f()\n     }\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n-    if context() == OldTaskContext {\n-        let t = rt::rust_get_task();\n-        do (|| {\n-            rt::rust_task_allow_kill(t);\n-            f()\n-        }).finally {\n-            rt::rust_task_inhibit_kill(t);\n+    use rt::task::Task;\n+\n+    match context() {\n+        OldTaskContext => {\n+            let t = rt::rust_get_task();\n+            do (|| {\n+                rt::rust_task_allow_kill(t);\n+                f()\n+            }).finally {\n+                rt::rust_task_inhibit_kill(t);\n+            }\n         }\n-    } else {\n-        // FIXME #6377\n-        f()\n+        TaskContext => {\n+            let t = Local::unsafe_borrow::<Task>();\n+            do (|| {\n+                (*t).death.allow_kill((*t).unwinder.unwinding);\n+                f()\n+            }).finally {\n+                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n+            }\n+        }\n+        // FIXME(#3095): As in unkillable().\n+        _ => f()\n     }\n }\n \n@@ -607,19 +632,36 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    if context() == OldTaskContext {\n-        let t = rt::rust_get_task();\n-        do (|| {\n-            rt::rust_task_inhibit_kill(t);\n-            rt::rust_task_inhibit_yield(t);\n-            f()\n-        }).finally {\n-            rt::rust_task_allow_yield(t);\n-            rt::rust_task_allow_kill(t);\n+    use rt::task::Task;\n+\n+    match context() {\n+        OldTaskContext => {\n+            let t = rt::rust_get_task();\n+            do (|| {\n+                rt::rust_task_inhibit_kill(t);\n+                rt::rust_task_inhibit_yield(t);\n+                f()\n+            }).finally {\n+                rt::rust_task_allow_yield(t);\n+                rt::rust_task_allow_kill(t);\n+            }\n+        }\n+        TaskContext => {\n+            let t = Local::unsafe_borrow::<Task>();\n+            do (|| {\n+                // It's important to inhibit kill after inhibiting yield, because\n+                // inhibit-kill might fail if we were already killed, and the\n+                // inhibit-yield must happen to match the finally's allow-yield.\n+                (*t).death.inhibit_yield();\n+                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n+                f()\n+            }).finally {\n+                (*t).death.allow_kill((*t).unwinder.unwinding);\n+                (*t).death.allow_yield();\n+            }\n         }\n-    } else {\n-        // FIXME #6377\n-        f()\n+        // FIXME(#3095): As in unkillable().\n+        _ => f()\n     }\n }\n "}]}