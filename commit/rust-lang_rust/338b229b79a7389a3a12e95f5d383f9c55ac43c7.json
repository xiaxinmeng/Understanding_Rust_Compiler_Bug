{"sha": "338b229b79a7389a3a12e95f5d383f9c55ac43c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzOGIyMjliNzlhNzM4OWEzYTEyZTk1ZjVkMzgzZjljNTVhYzQzYzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-23T10:02:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-23T10:02:59Z"}, "message": "Merge #4999\n\n4999: SSR: Allow matching of whole macro calls r=matklad a=davidlattimore\n\nMatching within macro calls is to come later and matching of macro calls within macro calls later still.\n\nCo-authored-by: David Lattimore <dml@google.com>", "tree": {"sha": "525a246b49f3acc66224f5cdeb7c8e361b719fd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/525a246b49f3acc66224f5cdeb7c8e361b719fd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/338b229b79a7389a3a12e95f5d383f9c55ac43c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe8dNTCRBK7hj4Ov3rIwAAdHIIAJdgLMFaw95xX6XnCU8SFCVn\nIdvz6Lr5iBxN0euuVyVGYUcmzrKoIheAcFaezleO1bz1DPYLne5AGa+u5RYKveu8\npvTigDsssJ2B9xkoBdSLD/aq4GKi7ASweGP7RVUhfdIkNlRmrLGrHOsJ2yYVScJd\np7N/LrOJ1mr8iikTmdllA54jOMEEipjwH+Qumhhsq1zO/LCT/bvKS4vW+/yqaram\nepWvnK3pTwm9pMrktJNMq4Md3yAWSSE5q+ZeKShqP7mZVNBBE1AltsKE0LMdpX/s\nSFkyYU33oDE0fcMvqATDfAQyON1YaCh2iTFG5qXhEbyZ+CRe5BXBYznUtqvfXn4=\n=QdVP\n-----END PGP SIGNATURE-----\n", "payload": "tree 525a246b49f3acc66224f5cdeb7c8e361b719fd6\nparent 98c3e4e887dcc5a8242c3e67c04a3cedbb1b9c58\nparent 467af611fb5b1add25b36a2127b172240bc141cf\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592906579 +0000\ncommitter GitHub <noreply@github.com> 1592906579 +0000\n\nMerge #4999\n\n4999: SSR: Allow matching of whole macro calls r=matklad a=davidlattimore\n\nMatching within macro calls is to come later and matching of macro calls within macro calls later still.\n\nCo-authored-by: David Lattimore <dml@google.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/338b229b79a7389a3a12e95f5d383f9c55ac43c7", "html_url": "https://github.com/rust-lang/rust/commit/338b229b79a7389a3a12e95f5d383f9c55ac43c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/338b229b79a7389a3a12e95f5d383f9c55ac43c7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98c3e4e887dcc5a8242c3e67c04a3cedbb1b9c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/98c3e4e887dcc5a8242c3e67c04a3cedbb1b9c58", "html_url": "https://github.com/rust-lang/rust/commit/98c3e4e887dcc5a8242c3e67c04a3cedbb1b9c58"}, {"sha": "467af611fb5b1add25b36a2127b172240bc141cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/467af611fb5b1add25b36a2127b172240bc141cf", "html_url": "https://github.com/rust-lang/rust/commit/467af611fb5b1add25b36a2127b172240bc141cf"}], "stats": {"total": 187, "additions": 174, "deletions": 13}, "files": [{"sha": "03f18c617fd25d613aee7a2dab8595ab1ec49a3d", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=338b229b79a7389a3a12e95f5d383f9c55ac43c7", "patch": "@@ -9,6 +9,7 @@ use ra_ssr::{MatchFinder, SsrError, SsrRule};\n // Search and replace with named wildcards that will match any expression, type, path, pattern or item.\n // The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n // A `$<name>` placeholder in the search pattern will match any AST node and `$<name>` will reference it in the replacement.\n+// Within a macro call, a placeholder will match up until whatever token follows the placeholder.\n // Available via the command `rust-analyzer.ssr`.\n //\n // ```rust"}, {"sha": "da26ee66941afc0b9740be72d8f7d869ddc89ffa", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=338b229b79a7389a3a12e95f5d383f9c55ac43c7", "patch": "@@ -91,14 +91,16 @@ impl<'db> MatchFinder<'db> {\n             if let Ok(mut m) = matching::get_match(false, rule, &code, restrict_range, &self.sema) {\n                 // Continue searching in each of our placeholders.\n                 for placeholder_value in m.placeholder_values.values_mut() {\n-                    // Don't search our placeholder if it's the entire matched node, otherwise we'd\n-                    // find the same match over and over until we got a stack overflow.\n-                    if placeholder_value.node != *code {\n-                        self.find_matches(\n-                            &placeholder_value.node,\n-                            restrict_range,\n-                            &mut placeholder_value.inner_matches,\n-                        );\n+                    if let Some(placeholder_node) = &placeholder_value.node {\n+                        // Don't search our placeholder if it's the entire matched node, otherwise we'd\n+                        // find the same match over and over until we got a stack overflow.\n+                        if placeholder_node != code {\n+                            self.find_matches(\n+                                placeholder_node,\n+                                restrict_range,\n+                                &mut placeholder_value.inner_matches,\n+                            );\n+                        }\n                     }\n                 }\n                 matches_out.matches.push(m);"}, {"sha": "bdaba9f1b617de3a086c0761187a017259d63030", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 101, "deletions": 4, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=338b229b79a7389a3a12e95f5d383f9c55ac43c7", "patch": "@@ -61,8 +61,9 @@ pub(crate) struct Var(pub String);\n /// Information about a placeholder bound in a match.\n #[derive(Debug)]\n pub(crate) struct PlaceholderMatch {\n-    /// The node that the placeholder matched to.\n-    pub(crate) node: SyntaxNode,\n+    /// The node that the placeholder matched to. If set, then we'll search for further matches\n+    /// within this node. It isn't set when we match tokens within a macro call's token tree.\n+    pub(crate) node: Option<SyntaxNode>,\n     pub(crate) range: FileRange,\n     /// More matches, found within `node`.\n     pub(crate) inner_matches: SsrMatches,\n@@ -195,6 +196,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n             SyntaxKind::RECORD_FIELD_LIST => {\n                 self.attempt_match_record_field_list(match_inputs, pattern, code)\n             }\n+            SyntaxKind::TOKEN_TREE => self.attempt_match_token_tree(match_inputs, pattern, code),\n             _ => self.attempt_match_node_children(match_inputs, pattern, code),\n         }\n     }\n@@ -340,6 +342,90 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         Ok(())\n     }\n \n+    /// Outside of token trees, a placeholder can only match a single AST node, whereas in a token\n+    /// tree it can match a sequence of tokens.\n+    fn attempt_match_token_tree(\n+        &mut self,\n+        match_inputs: &MatchInputs,\n+        pattern: &SyntaxNode,\n+        code: &ra_syntax::SyntaxNode,\n+    ) -> Result<(), MatchFailed> {\n+        let mut pattern = PatternIterator::new(pattern).peekable();\n+        let mut children = code.children_with_tokens();\n+        while let Some(child) = children.next() {\n+            if let Some(placeholder) = pattern.peek().and_then(|p| match_inputs.get_placeholder(p))\n+            {\n+                pattern.next();\n+                let next_pattern_token = pattern\n+                    .peek()\n+                    .and_then(|p| match p {\n+                        SyntaxElement::Token(t) => Some(t.clone()),\n+                        SyntaxElement::Node(n) => n.first_token(),\n+                    })\n+                    .map(|p| p.text().to_string());\n+                let first_matched_token = child.clone();\n+                let mut last_matched_token = child;\n+                // Read code tokens util we reach one equal to the next token from our pattern\n+                // or we reach the end of the token tree.\n+                while let Some(next) = children.next() {\n+                    match &next {\n+                        SyntaxElement::Token(t) => {\n+                            if Some(t.to_string()) == next_pattern_token {\n+                                pattern.next();\n+                                break;\n+                            }\n+                        }\n+                        SyntaxElement::Node(n) => {\n+                            if let Some(first_token) = n.first_token() {\n+                                if Some(first_token.to_string()) == next_pattern_token {\n+                                    if let Some(SyntaxElement::Node(p)) = pattern.next() {\n+                                        // We have a subtree that starts with the next token in our pattern.\n+                                        self.attempt_match_token_tree(match_inputs, &p, &n)?;\n+                                        break;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    };\n+                    last_matched_token = next;\n+                }\n+                if let Some(match_out) = &mut self.match_out {\n+                    match_out.placeholder_values.insert(\n+                        Var(placeholder.ident.to_string()),\n+                        PlaceholderMatch::from_range(FileRange {\n+                            file_id: self.sema.original_range(code).file_id,\n+                            range: first_matched_token\n+                                .text_range()\n+                                .cover(last_matched_token.text_range()),\n+                        }),\n+                    );\n+                }\n+                continue;\n+            }\n+            // Match literal (non-placeholder) tokens.\n+            match child {\n+                SyntaxElement::Token(token) => {\n+                    self.attempt_match_token(&mut pattern, &token)?;\n+                }\n+                SyntaxElement::Node(node) => match pattern.next() {\n+                    Some(SyntaxElement::Node(p)) => {\n+                        self.attempt_match_token_tree(match_inputs, &p, &node)?;\n+                    }\n+                    Some(SyntaxElement::Token(p)) => fail_match!(\n+                        \"Pattern has token '{}', code has subtree '{}'\",\n+                        p.text(),\n+                        node.text()\n+                    ),\n+                    None => fail_match!(\"Pattern has nothing, code has '{}'\", node.text()),\n+                },\n+            }\n+        }\n+        if let Some(p) = pattern.next() {\n+            fail_match!(\"Reached end of token tree in code, but pattern still has {:?}\", p);\n+        }\n+        Ok(())\n+    }\n+\n     fn next_non_trivial(&mut self, code_it: &mut SyntaxElementChildren) -> Option<SyntaxElement> {\n         loop {\n             let c = code_it.next();\n@@ -399,7 +485,11 @@ fn recording_match_fail_reasons() -> bool {\n \n impl PlaceholderMatch {\n     fn new(node: &SyntaxNode, range: FileRange) -> Self {\n-        Self { node: node.clone(), range, inner_matches: SsrMatches::default() }\n+        Self { node: Some(node.clone()), range, inner_matches: SsrMatches::default() }\n+    }\n+\n+    fn from_range(range: FileRange) -> Self {\n+        Self { node: None, range, inner_matches: SsrMatches::default() }\n     }\n }\n \n@@ -484,7 +574,14 @@ mod tests {\n         assert_eq!(matches.matches.len(), 1);\n         assert_eq!(matches.matches[0].matched_node.text(), \"foo(1+2)\");\n         assert_eq!(matches.matches[0].placeholder_values.len(), 1);\n-        assert_eq!(matches.matches[0].placeholder_values[&Var(\"x\".to_string())].node.text(), \"1+2\");\n+        assert_eq!(\n+            matches.matches[0].placeholder_values[&Var(\"x\".to_string())]\n+                .node\n+                .as_ref()\n+                .unwrap()\n+                .text(),\n+            \"1+2\"\n+        );\n \n         let edit = crate::replacing::matches_to_edit(&matches);\n         let mut after = input.to_string();"}, {"sha": "5dcde82a28a608b383fe2201154bc393fba36faf", "filename": "crates/ra_ssr/src/replacing.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Freplacing.rs?ref=338b229b79a7389a3a12e95f5d383f9c55ac43c7", "patch": "@@ -24,6 +24,7 @@ fn matches_to_edit_at_offset(matches: &SsrMatches, relative_start: TextSize) ->\n \n fn render_replace(match_info: &Match) -> String {\n     let mut out = String::new();\n+    let match_start = match_info.matched_node.text_range().start();\n     for r in &match_info.template.tokens {\n         match r {\n             PatternElement::Token(t) => out.push_str(t.text.as_str()),\n@@ -32,7 +33,14 @@ fn render_replace(match_info: &Match) -> String {\n                     match_info.placeholder_values.get(&Var(p.ident.to_string()))\n                 {\n                     let range = &placeholder_value.range.range;\n-                    let mut matched_text = placeholder_value.node.text().to_string();\n+                    let mut matched_text = if let Some(node) = &placeholder_value.node {\n+                        node.text().to_string()\n+                    } else {\n+                        let relative_range = range.checked_sub(match_start).unwrap();\n+                        match_info.matched_node.text().to_string()\n+                            [usize::from(relative_range.start())..usize::from(relative_range.end())]\n+                            .to_string()\n+                    };\n                     let edit =\n                         matches_to_edit_at_offset(&placeholder_value.inner_matches, range.start());\n                     edit.apply(&mut matched_text);"}, {"sha": "3ee1e74e9590366a3918ef78149743f8afe1f2f8", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338b229b79a7389a3a12e95f5d383f9c55ac43c7/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=338b229b79a7389a3a12e95f5d383f9c55ac43c7", "patch": "@@ -426,6 +426,45 @@ fn match_reordered_struct_instantiation() {\n     assert_no_match(\"Foo {a: 1, z: 9}\", \"fn f() {Foo {a: 1}}\");\n }\n \n+#[test]\n+fn match_macro_invocation() {\n+    assert_matches(\"foo!($a)\", \"fn() {foo(foo!(foo()))}\", &[\"foo!(foo())\"]);\n+    assert_matches(\"foo!(41, $a, 43)\", \"fn() {foo!(41, 42, 43)}\", &[\"foo!(41, 42, 43)\"]);\n+    assert_no_match(\"foo!(50, $a, 43)\", \"fn() {foo!(41, 42, 43}\");\n+    assert_no_match(\"foo!(41, $a, 50)\", \"fn() {foo!(41, 42, 43}\");\n+    assert_matches(\"foo!($a())\", \"fn() {foo!(bar())}\", &[\"foo!(bar())\"]);\n+}\n+\n+// When matching within a macro expansion, we only allow matches of nodes that originated from\n+// the macro call, not from the macro definition.\n+#[test]\n+fn no_match_expression_from_macro() {\n+    assert_no_match(\n+        \"$a.clone()\",\n+        r#\"\n+            macro_rules! m1 {\n+                () => {42.clone()}\n+            }\n+            fn f1() {m1!()}\n+            \"#,\n+    );\n+}\n+\n+// We definitely don't want to allow matching of an expression that part originates from the\n+// macro call `42` and part from the macro definition `.clone()`.\n+#[test]\n+fn no_match_split_expression() {\n+    assert_no_match(\n+        \"$a.clone()\",\n+        r#\"\n+            macro_rules! m1 {\n+                ($x:expr) => {$x.clone()}\n+            }\n+            fn f1() {m1!(42)}\n+            \"#,\n+    );\n+}\n+\n #[test]\n fn replace_function_call() {\n     assert_ssr_transform(\"foo() ==>> bar()\", \"fn f1() {foo(); foo();}\", \"fn f1() {bar(); bar();}\");\n@@ -467,6 +506,20 @@ fn replace_struct_init() {\n     );\n }\n \n+#[test]\n+fn replace_macro_invocations() {\n+    assert_ssr_transform(\n+        \"try!($a) ==>> $a?\",\n+        \"fn f1() -> Result<(), E> {bar(try!(foo()));}\",\n+        \"fn f1() -> Result<(), E> {bar(foo()?);}\",\n+    );\n+    assert_ssr_transform(\n+        \"foo!($a($b)) ==>> foo($b, $a)\",\n+        \"fn f1() {foo!(abc(def() + 2));}\",\n+        \"fn f1() {foo(def() + 2, abc);}\",\n+    );\n+}\n+\n #[test]\n fn replace_binary_op() {\n     assert_ssr_transform("}]}