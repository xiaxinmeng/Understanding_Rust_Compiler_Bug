{"sha": "08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ODg2NDk5Y2YwZjdmZWE1ZGUyY2M1NTVlYTdiZmU5Y2ViMGI0MGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-18T18:35:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-18T18:35:48Z"}, "message": "Auto merge of #31000 - bluss:efficient-clone-from-slice, r=dotdash\n\nRestore indexed formulation of clone_from_slice\n\nFor good codegen here, we need a lock step iteration where the loop\nbound is only checked once per iteration; .zip() unfortunately does not\noptimize this way.\n\nIf we use a counted loop, and make sure that llvm sees that the bounds\ncheck condition is the same as the loop bound condition, the bounds\nchecks are optimized out. For this reason we need to slice `from`\n(apparently) redundantly.\n\nThis commit restores the old formulation of clone_from_slice. In this\nshape, clone_from_slice will again optimize into calling memcpy where possible\n(for example for &[u8] or &[i32]).", "tree": {"sha": "b3bc6d9d23aaccc33df6bd43c9d212739025ff2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3bc6d9d23aaccc33df6bd43c9d212739025ff2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f", "html_url": "https://github.com/rust-lang/rust/commit/08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a09a604d361b00015ee0eaf30b3d332667711f11", "url": "https://api.github.com/repos/rust-lang/rust/commits/a09a604d361b00015ee0eaf30b3d332667711f11", "html_url": "https://github.com/rust-lang/rust/commit/a09a604d361b00015ee0eaf30b3d332667711f11"}, {"sha": "6a7bc47a8f1bf4441ca55e42aa50db6dda28181f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a7bc47a8f1bf4441ca55e42aa50db6dda28181f", "html_url": "https://github.com/rust-lang/rust/commit/6a7bc47a8f1bf4441ca55e42aa50db6dda28181f"}], "stats": {"total": 9, "additions": 7, "deletions": 2}, "files": [{"sha": "6107564b4aeff7344cdda938226e8e9904ff8d5b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=08886499cf0f7fea5de2cc555ea7bfe9ceb0b40f", "patch": "@@ -478,8 +478,13 @@ impl<T> SliceExt for [T] {\n     fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n         assert!(self.len() == src.len(),\n                 \"destination and source slices have different lengths\");\n-        for (dst, src) in self.iter_mut().zip(src) {\n-            dst.clone_from(src);\n+        // NOTE: We need to explicitly slice them to the same length\n+        // for bounds checking to be elided, and the optimizer will\n+        // generate memcpy for simple cases (for example T = u8).\n+        let len = self.len();\n+        let src = &src[..len];\n+        for i in 0..len {\n+            self[i].clone_from(&src[i]);\n         }\n     }\n }"}]}