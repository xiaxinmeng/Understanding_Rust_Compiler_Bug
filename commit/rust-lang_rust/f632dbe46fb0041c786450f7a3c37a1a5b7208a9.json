{"sha": "f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "node_id": "C_kwDOAAsO6NoAKGY2MzJkYmU0NmZiMDA0MWM3ODY0NTBmN2EzYzM3YTFhNWI3MjA4YTk", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-06T14:08:59Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-09T15:16:04Z"}, "message": "The `<*const T>::guaranteed_*` methods now return an option for the unknown case", "tree": {"sha": "b1e3c8d4f891e1336e44b177c3a3bedaf9d7d604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1e3c8d4f891e1336e44b177c3a3bedaf9d7d604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "html_url": "https://github.com/rust-lang/rust/commit/f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a594044533b5e309eab7ac6b71f4ba8a909af653", "url": "https://api.github.com/repos/rust-lang/rust/commits/a594044533b5e309eab7ac6b71f4ba8a909af653", "html_url": "https://github.com/rust-lang/rust/commit/a594044533b5e309eab7ac6b71f4ba8a909af653"}], "stats": {"total": 703, "additions": 119, "deletions": 584}, "files": [{"sha": "586c9489dd44b902f0865458fe39cd54522e63dc", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -819,20 +819,13 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         }\n \n-        sym::ptr_guaranteed_eq => {\n+        sym::ptr_guaranteed_cmp => {\n             intrinsic_args!(fx, args => (a, b); intrinsic);\n \n             let val = crate::num::codegen_ptr_binop(fx, BinOp::Eq, a, b);\n             ret.write_cvalue(fx, val);\n         }\n \n-        sym::ptr_guaranteed_ne => {\n-            intrinsic_args!(fx, args => (a, b); intrinsic);\n-\n-            let val = crate::num::codegen_ptr_binop(fx, BinOp::Ne, a, b);\n-            ret.write_cvalue(fx, val);\n-        }\n-\n         sym::caller_location => {\n             intrinsic_args!(fx, args => (); intrinsic);\n "}, {"sha": "8818bf9237ddf80cc5b60f65e67b8eda7adaf93a", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -555,14 +555,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 return;\n             }\n \n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+            sym::ptr_guaranteed_cmp => {\n                 let a = args[0].immediate();\n                 let b = args[1].immediate();\n-                if name == sym::ptr_guaranteed_eq {\n-                    bx.icmp(IntPredicate::IntEQ, a, b)\n-                } else {\n-                    bx.icmp(IntPredicate::IntNE, a, b)\n-                }\n+                bx.icmp(IntPredicate::IntEQ, a, b)\n             }\n \n             sym::ptr_offset_from | sym::ptr_offset_from_unsigned => {"}, {"sha": "e5acacd9188888f670ec6498d97aee5b7e8558e8", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -191,34 +191,35 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n-    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n+    /// See documentation on the `ptr_guaranteed_cmp` intrinsic.\n+    fn guaranteed_cmp(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, u8> {\n         Ok(match (a, b) {\n             // Comparisons between integers are always known.\n-            (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n-            // Equality with integers can never be known for sure.\n-            (Scalar::Int { .. }, Scalar::Ptr(..)) | (Scalar::Ptr(..), Scalar::Int { .. }) => false,\n-            // FIXME: return `true` for when both sides are the same pointer, *except* that\n-            // some things (like functions and vtables) do not have stable addresses\n-            // so we need to be careful around them (see e.g. #73722).\n-            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n-        })\n-    }\n-\n-    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n-        Ok(match (a, b) {\n-            // Comparisons between integers are always known.\n-            (Scalar::Int(_), Scalar::Int(_)) => a != b,\n+            (Scalar::Int { .. }, Scalar::Int { .. }) => {\n+                if a == b {\n+                    1\n+                } else {\n+                    0\n+                }\n+            }\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n             (Scalar::Int(int), ptr @ Scalar::Ptr(..))\n-            | (ptr @ Scalar::Ptr(..), Scalar::Int(int)) => {\n-                int.is_null() && !self.scalar_may_be_null(ptr)?\n+            | (ptr @ Scalar::Ptr(..), Scalar::Int(int))\n+                if int.is_null() && !self.scalar_may_be_null(ptr)? =>\n+            {\n+                0\n             }\n-            // FIXME: return `true` for at least some comparisons where we can reliably\n+            // Equality with integers can never be known for sure.\n+            (Scalar::Int { .. }, Scalar::Ptr(..)) | (Scalar::Ptr(..), Scalar::Int { .. }) => 2,\n+            // FIXME: return a `1` for when both sides are the same pointer, *except* that\n+            // some things (like functions and vtables) do not have stable addresses\n+            // so we need to be careful around them (see e.g. #73722).\n+            // FIXME: return `0` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items.\n-            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n+            (Scalar::Ptr(..), Scalar::Ptr(..)) => 2,\n         })\n     }\n }\n@@ -329,15 +330,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             throw_unsup_format!(\"intrinsic `{intrinsic_name}` is not supported at compile-time\");\n         };\n         match intrinsic_name {\n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+            sym::ptr_guaranteed_cmp => {\n                 let a = ecx.read_scalar(&args[0])?;\n                 let b = ecx.read_scalar(&args[1])?;\n-                let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n-                    ecx.guaranteed_eq(a, b)?\n-                } else {\n-                    ecx.guaranteed_ne(a, b)?\n-                };\n-                ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n+                let cmp = ecx.guaranteed_cmp(a, b)?;\n+                ecx.write_scalar(Scalar::from_u8(cmp), dest)?;\n             }\n             sym::const_allocate => {\n                 let size = ecx.read_scalar(&args[0])?.to_machine_usize(ecx)?;"}, {"sha": "a964fe8465eeceefb96a68077e1297f34b577195", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n         }\n \n         // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n-        // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n+        // equality at compile-time (see `ptr_guaranteed_cmp`).\n         // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n         // agree with runtime equality tests.\n         ty::FnPtr(_) | ty::RawPtr(_) => Err(ValTreeCreationError::NonSupportedType),"}, {"sha": "e32a6d5b9e189db3470dfed0e0f3e6be6658b942", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -1118,8 +1118,7 @@ symbols! {\n         profiler_builtins,\n         profiler_runtime,\n         ptr,\n-        ptr_guaranteed_eq,\n-        ptr_guaranteed_ne,\n+        ptr_guaranteed_cmp,\n         ptr_mask,\n         ptr_null,\n         ptr_null_mut,"}, {"sha": "4fa33da50c9e0b1e2e3dbc52dcf4646bd55ff4a9", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -95,8 +95,7 @@ pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n         | sym::type_id\n         | sym::likely\n         | sym::unlikely\n-        | sym::ptr_guaranteed_eq\n-        | sym::ptr_guaranteed_ne\n+        | sym::ptr_guaranteed_cmp\n         | sym::minnumf32\n         | sym::minnumf64\n         | sym::maxnumf32\n@@ -302,8 +301,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 (1, vec![param(0), param(0)], tcx.intern_tup(&[param(0), tcx.types.bool]))\n             }\n \n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.bool)\n+            sym::ptr_guaranteed_cmp => {\n+                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.u8)\n             }\n \n             sym::const_allocate => {"}, {"sha": "11c75e2c912412181236d55e5267154fef642fe9", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -2013,21 +2013,24 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from_unsigned<T>(ptr: *const T, base: *const T) -> usize;\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n+    /// Returns `2` if the result is unknown.\n+    /// Returns `1` if the pointers are guaranteed equal\n+    /// Returns `0` if the pointers are guaranteed inequal\n     ///\n     /// Note that, unlike most intrinsics, this is safe to call;\n     /// it does not require an `unsafe` block.\n     /// Therefore, implementations must not require the user to uphold\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_guaranteed_cmp<T>(ptr: *const T, other: *const T) -> u8;\n+\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(bootstrap)]\n     pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool;\n \n-    /// See documentation of `<*const T>::guaranteed_ne` for details.\n-    ///\n-    /// Note that, unlike most intrinsics, this is safe to call;\n-    /// it does not require an `unsafe` block.\n-    /// Therefore, implementations must not require the user to uphold\n-    /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(bootstrap)]\n     pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n \n     /// Allocates a block of memory at compile time.\n@@ -2213,6 +2216,16 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n     diff >= size\n }\n \n+#[cfg(bootstrap)]\n+pub const fn ptr_guaranteed_cmp(a: *const (), b: *const ()) -> u8 {\n+    match (ptr_guaranteed_eq(a, b), ptr_guaranteed_ne(a, b)) {\n+        (false, false) => 2,\n+        (true, false) => 1,\n+        (false, true) => 0,\n+        (true, true) => unreachable!(),\n+    }\n+}\n+\n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n /// and destination must *not* overlap.\n ///"}, {"sha": "fcdf69a7aaa40026e72ae3de3a8936ee54e86d7e", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -36,7 +36,10 @@ impl<T: ?Sized> *const T {\n     pub const fn is_null(self) -> bool {\n         // Compare via a cast to a thin pointer, so fat pointers are only\n         // considering their \"data\" part for null-ness.\n-        (self as *const u8).guaranteed_eq(null())\n+        match (self as *const u8).guaranteed_eq(null()) {\n+            None => false,\n+            Some(res) => res,\n+        }\n     }\n \n     /// Casts to a pointer of another type.\n@@ -770,20 +773,16 @@ impl<T: ?Sized> *const T {\n \n     /// Returns whether two pointers are guaranteed to be equal.\n     ///\n-    /// At runtime this function behaves like `self == other`.\n+    /// At runtime this function behaves like `Some(self == other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine equality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be equal.\n-    /// But when it returns `true`, the pointers are guaranteed to be equal.\n-    ///\n-    /// This function is the mirror of [`guaranteed_ne`], but not its inverse. There are pointer\n-    /// comparisons for which both functions return `false`.\n+    /// spuriously return `None` for pointers that later actually turn out to have its equality known.\n+    /// But when it returns `Some`, the pointers' equality is guaranteed to be known.\n     ///\n-    /// [`guaranteed_ne`]: #method.guaranteed_ne\n-    ///\n-    /// The return value may change depending on the compiler version and unsafe code must not\n+    /// The return value may change from `Some` to `None` and vice versa depending on the compiler\n+    /// version and unsafe code must not\n     /// rely on the result of this function for soundness. It is suggested to only use this function\n-    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// for performance optimizations where spurious `None` return values by this function do not\n     /// affect the outcome, but just the performance.\n     /// The consequences of using this method to make runtime and compile-time code behave\n     /// differently have not been explored. This method should not be used to introduce such\n@@ -792,29 +791,28 @@ impl<T: ?Sized> *const T {\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n-    pub const fn guaranteed_eq(self, other: *const T) -> bool\n+    pub const fn guaranteed_eq(self, other: *const T) -> Option<bool>\n     where\n         T: Sized,\n     {\n-        intrinsics::ptr_guaranteed_eq(self, other)\n+        match intrinsics::ptr_guaranteed_cmp(self as _, other as _) {\n+            2 => None,\n+            other => Some(other == 1),\n+        }\n     }\n \n-    /// Returns whether two pointers are guaranteed to be unequal.\n+    /// Returns whether two pointers are guaranteed to be inequal.\n     ///\n-    /// At runtime this function behaves like `self != other`.\n+    /// At runtime this function behaves like `Some(self == other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n-    /// it is not always possible to determine the inequality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be unequal.\n-    /// But when it returns `true`, the pointers are guaranteed to be unequal.\n+    /// it is not always possible to determine inequality of two pointers, so this function may\n+    /// spuriously return `None` for pointers that later actually turn out to have its inequality known.\n+    /// But when it returns `Some`, the pointers' inequality is guaranteed to be known.\n     ///\n-    /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n-    /// comparisons for which both functions return `false`.\n-    ///\n-    /// [`guaranteed_eq`]: #method.guaranteed_eq\n-    ///\n-    /// The return value may change depending on the compiler version and unsafe code must not\n+    /// The return value may change from `Some` to `None` and vice versa depending on the compiler\n+    /// version and unsafe code must not\n     /// rely on the result of this function for soundness. It is suggested to only use this function\n-    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// for performance optimizations where spurious `None` return values by this function do not\n     /// affect the outcome, but just the performance.\n     /// The consequences of using this method to make runtime and compile-time code behave\n     /// differently have not been explored. This method should not be used to introduce such\n@@ -823,11 +821,14 @@ impl<T: ?Sized> *const T {\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n-    pub const fn guaranteed_ne(self, other: *const T) -> bool\n+    pub const fn guaranteed_ne(self, other: *const T) -> Option<bool>\n     where\n         T: Sized,\n     {\n-        intrinsics::ptr_guaranteed_ne(self, other)\n+        match self.guaranteed_eq(other) {\n+            None => None,\n+            Some(eq) => Some(!eq),\n+        }\n     }\n \n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`)."}, {"sha": "460f3df5feeabed4151b054c5c87369e94718950", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -35,7 +35,10 @@ impl<T: ?Sized> *mut T {\n     pub const fn is_null(self) -> bool {\n         // Compare via a cast to a thin pointer, so fat pointers are only\n         // considering their \"data\" part for null-ness.\n-        (self as *mut u8).guaranteed_eq(null_mut())\n+        match (self as *mut u8).guaranteed_eq(null_mut()) {\n+            None => false,\n+            Some(res) => res,\n+        }\n     }\n \n     /// Casts to a pointer of another type.\n@@ -697,20 +700,16 @@ impl<T: ?Sized> *mut T {\n \n     /// Returns whether two pointers are guaranteed to be equal.\n     ///\n-    /// At runtime this function behaves like `self == other`.\n+    /// At runtime this function behaves like `Some(self == other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine equality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be equal.\n-    /// But when it returns `true`, the pointers are guaranteed to be equal.\n-    ///\n-    /// This function is the mirror of [`guaranteed_ne`], but not its inverse. There are pointer\n-    /// comparisons for which both functions return `false`.\n-    ///\n-    /// [`guaranteed_ne`]: #method.guaranteed_ne\n+    /// spuriously return `None` for pointers that later actually turn out to have its equality known.\n+    /// But when it returns `Some`, the pointers' equality is guaranteed to be known.\n     ///\n-    /// The return value may change depending on the compiler version and unsafe code might not\n+    /// The return value may change from `Some` to `None` and vice versa depending on the compiler\n+    /// version and unsafe code must not\n     /// rely on the result of this function for soundness. It is suggested to only use this function\n-    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// for performance optimizations where spurious `None` return values by this function do not\n     /// affect the outcome, but just the performance.\n     /// The consequences of using this method to make runtime and compile-time code behave\n     /// differently have not been explored. This method should not be used to introduce such\n@@ -719,29 +718,25 @@ impl<T: ?Sized> *mut T {\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n-    pub const fn guaranteed_eq(self, other: *mut T) -> bool\n+    pub const fn guaranteed_eq(self, other: *mut T) -> Option<bool>\n     where\n         T: Sized,\n     {\n-        intrinsics::ptr_guaranteed_eq(self as *const _, other as *const _)\n+        (self as *const T).guaranteed_eq(other as _)\n     }\n \n-    /// Returns whether two pointers are guaranteed to be unequal.\n+    /// Returns whether two pointers are guaranteed to be inequal.\n     ///\n-    /// At runtime this function behaves like `self != other`.\n+    /// At runtime this function behaves like `Some(self == other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n-    /// it is not always possible to determine the inequality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be unequal.\n-    /// But when it returns `true`, the pointers are guaranteed to be unequal.\n-    ///\n-    /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n-    /// comparisons for which both functions return `false`.\n-    ///\n-    /// [`guaranteed_eq`]: #method.guaranteed_eq\n+    /// it is not always possible to determine inequality of two pointers, so this function may\n+    /// spuriously return `None` for pointers that later actually turn out to have its inequality known.\n+    /// But when it returns `Some`, the pointers' inequality is guaranteed to be known.\n     ///\n-    /// The return value may change depending on the compiler version and unsafe code might not\n+    /// The return value may change from `Some` to `None` and vice versa depending on the compiler\n+    /// version and unsafe code must not\n     /// rely on the result of this function for soundness. It is suggested to only use this function\n-    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// for performance optimizations where spurious `None` return values by this function do not\n     /// affect the outcome, but just the performance.\n     /// The consequences of using this method to make runtime and compile-time code behave\n     /// differently have not been explored. This method should not be used to introduce such\n@@ -750,11 +745,11 @@ impl<T: ?Sized> *mut T {\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n-    pub const unsafe fn guaranteed_ne(self, other: *mut T) -> bool\n+    pub const fn guaranteed_ne(self, other: *mut T) -> Option<bool>\n     where\n         T: Sized,\n     {\n-        intrinsics::ptr_guaranteed_ne(self as *const _, other as *const _)\n+        (self as *const T).guaranteed_ne(other as _)\n     }\n \n     /// Calculates the distance between two pointers. The returned value is in"}, {"sha": "28536dc28a722fde154d3cffb445a3e73d3fd62c", "filename": "src/test/mir-opt/separate_const_switch.identity.ConstProp.diff", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a594044533b5e309eab7ac6b71f4ba8a909af653/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a594044533b5e309eab7ac6b71f4ba8a909af653/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff?ref=a594044533b5e309eab7ac6b71f4ba8a909af653", "patch": "@@ -1,146 +0,0 @@\n-- // MIR for `identity` before ConstProp\n-+ // MIR for `identity` after ConstProp\n-  \n-  fn identity(_1: Result<i32, i32>) -> Result<i32, i32> {\n-      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:+0:13: +0:14\n-      let mut _0: std::result::Result<i32, i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:+0:37: +0:53\n-      let mut _2: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-      let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, i32>, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-      let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n-      let mut _5: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-      let _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-      let mut _7: !;                       // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-      let mut _8: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-      scope 1 {\n-          debug residual => _6;            // in scope 1 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          scope 2 {\n-              scope 8 (inlined #[track_caller] <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n-                  debug residual => _8;    // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let _16: i32;            // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _17: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _18: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  scope 9 {\n-                      debug e => _16;      // in scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-                      scope 10 (inlined <i32 as From<i32>>::from) { // at $SRC_DIR/core/src/result.rs:LL:COL\n-                          debug t => _18;  // in scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                      }\n-                  }\n-              }\n-          }\n-      }\n-      scope 3 {\n-          debug val => _9;                 // in scope 3 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          scope 4 {\n-          }\n-      }\n-      scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n-          debug self => _4;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _10: isize;              // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let _11: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _12: i32;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let _13: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _14: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _15: i32;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          scope 6 {\n-              debug v => _11;              // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          }\n-          scope 7 {\n-              debug e => _13;              // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          }\n-      }\n-  \n-      bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n-          _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n-          _10 = discriminant(_4);          // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          switchInt(move _10) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-      }\n-  \n-      bb1: {\n-          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          _9 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          _2 = _9;                         // scope 4 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          Deinit(_0);                      // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-          ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-          discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n-          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n-          return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n-      }\n-  \n-      bb2: {\n-          unreachable;                     // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-      }\n-  \n-      bb3: {\n-          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          _6 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageLive(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          _8 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageLive(_16);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _16 = move ((_8 as Err).0: i32); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_17);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_18);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _18 = move _16;                  // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _17 = move _18;                  // scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-          StorageDead(_18);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_0);                      // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_0 as Err).0: i32) = move _17; // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_0) = 1;            // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_17);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_16);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n-          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n-          return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n-      }\n-  \n-      bb4: {\n-          StorageLive(_13);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _13 = move ((_4 as Err).0: i32); // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_14);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_15);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _15 = move _13;                  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_14);                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_14 as Err).0: i32) = move _15; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_14) = 1;           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_15);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_3);                      // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _14; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_3) = 1;            // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_14);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_13);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n--         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n--         switchInt(move _5) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-+         _5 = const 1_isize;              // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-+         switchInt(const 1_isize) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-      }\n-  \n-      bb5: {\n-          unreachable;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-      }\n-  \n-      bb6: {\n-          StorageLive(_11);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _11 = move ((_4 as Ok).0: i32);  // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_12);                // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _12 = move _11;                  // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_3);                      // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_3 as Continue).0: i32) = move _12; // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_3) = 0;            // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_12);                // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_11);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n--         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n--         switchInt(move _5) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-+         _5 = const 0_isize;              // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-+         switchInt(const 0_isize) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-      }\n-  }\n-  "}, {"sha": "df20f0ed36b6045d90742d06a0aac4db9bd1aba9", "filename": "src/test/mir-opt/separate_const_switch.identity.PreCodegen.after.mir", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a594044533b5e309eab7ac6b71f4ba8a909af653/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a594044533b5e309eab7ac6b71f4ba8a909af653/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir?ref=a594044533b5e309eab7ac6b71f4ba8a909af653", "patch": "@@ -1,124 +0,0 @@\n-// MIR for `identity` after PreCodegen\n-\n-fn identity(_1: Result<i32, i32>) -> Result<i32, i32> {\n-    debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:+0:13: +0:14\n-    let mut _0: std::result::Result<i32, i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:+0:37: +0:53\n-    let mut _2: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, i32>, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-    let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n-    let _5: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-    let mut _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-    let _7: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-    scope 1 {\n-        debug residual => _5;            // in scope 1 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        scope 2 {\n-            scope 8 (inlined #[track_caller] <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n-                debug residual => _6;    // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let _14: i32;            // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let mut _15: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let mut _16: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                scope 9 {\n-                    debug e => _14;      // in scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-                    scope 10 (inlined <i32 as From<i32>>::from) { // at $SRC_DIR/core/src/result.rs:LL:COL\n-                        debug t => _16;  // in scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    scope 3 {\n-        debug val => _7;                 // in scope 3 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-        scope 4 {\n-        }\n-    }\n-    scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n-        debug self => _4;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        let mut _8: isize;               // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        let _9: i32;                     // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        let mut _10: i32;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        let _11: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        let mut _12: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        let mut _13: i32;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        scope 6 {\n-            debug v => _9;               // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        }\n-        scope 7 {\n-            debug e => _11;              // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        }\n-    }\n-\n-    bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-        StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-        StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n-        _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n-        _8 = discriminant(_4);           // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        switchInt(move _8) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb1: {\n-        StorageLive(_11);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _11 = move ((_4 as Err).0: i32); // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageLive(_12);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageLive(_13);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _13 = move _11;                  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        Deinit(_12);                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        ((_12 as Err).0: i32) = move _13; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        discriminant(_12) = 1;           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_13);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        Deinit(_3);                      // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _12; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        discriminant(_3) = 1;            // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_12);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_11);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        StorageLive(_5);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        _5 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        StorageLive(_6);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        _6 = _5;                         // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        StorageLive(_14);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _14 = move ((_6 as Err).0: i32); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageLive(_15);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageLive(_16);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _16 = move _14;                  // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _15 = move _16;                  // scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-        StorageDead(_16);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-        Deinit(_0);                      // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-        ((_0 as Err).0: i32) = move _15; // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-        discriminant(_0) = 1;            // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_15);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_14);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_6);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        StorageDead(_5);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n-        StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n-        return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n-    }\n-\n-    bb2: {\n-        unreachable;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb3: {\n-        StorageLive(_9);                 // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _9 = move ((_4 as Ok).0: i32);   // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _10 = move _9;                   // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        Deinit(_3);                      // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        ((_3 as Continue).0: i32) = move _10; // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        discriminant(_3) = 0;            // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_9);                 // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        StorageLive(_7);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-        _7 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-        _2 = _7;                         // scope 4 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-        StorageDead(_7);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-        Deinit(_0);                      // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-        ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-        discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n-        StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n-        return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n-    }\n-}"}, {"sha": "28269165e1c27a672f7a863d855940195ee24102", "filename": "src/test/mir-opt/separate_const_switch.too_complex.ConstProp.diff", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a594044533b5e309eab7ac6b71f4ba8a909af653/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a594044533b5e309eab7ac6b71f4ba8a909af653/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff?ref=a594044533b5e309eab7ac6b71f4ba8a909af653", "patch": "@@ -1,103 +0,0 @@\n-- // MIR for `too_complex` before ConstProp\n-+ // MIR for `too_complex` after ConstProp\n-  \n-  fn too_complex(_1: Result<i32, usize>) -> Option<i32> {\n-      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:+0:16: +0:17\n-      let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:+0:42: +0:53\n-      let mut _2: std::ops::ControlFlow<usize, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-      let mut _3: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:+7:13: +7:18\n-      let _4: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-      let mut _5: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-      let _6: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:+8:17: +8:18\n-      let mut _7: usize;                   // in scope 0 at $DIR/separate_const_switch.rs:+8:42: +8:43\n-      let mut _8: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:+11:9: +11:33\n-      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-      let mut _10: i32;                    // in scope 0 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-      let _11: usize;                      // in scope 0 at $DIR/separate_const_switch.rs:+12:28: +12:29\n-      scope 1 {\n-          debug v => _4;                   // in scope 1 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-      }\n-      scope 2 {\n-          debug r => _6;                   // in scope 2 at $DIR/separate_const_switch.rs:+8:17: +8:18\n-      }\n-      scope 3 {\n-          debug v => _9;                   // in scope 3 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-      }\n-      scope 4 {\n-          debug r => _11;                  // in scope 4 at $DIR/separate_const_switch.rs:+12:28: +12:29\n-      }\n-  \n-      bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-          _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:+6:15: +6:16\n-          switchInt(move _3) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+6:9: +6:16\n-      }\n-  \n-      bb1: {\n-          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+8:17: +8:18\n-          _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:+8:17: +8:18\n-          StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:+8:42: +8:43\n-          _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:+8:42: +8:43\n-          Deinit(_2);                      // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n-          ((_2 as Break).0: usize) = move _7; // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n-          discriminant(_2) = 1;            // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n-          StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:+8:43: +8:44\n-          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n--         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n--         switchInt(move _8) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n-+         _8 = const 1_isize;              // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-+         switchInt(const 1_isize) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n-      }\n-  \n-      bb2: {\n-          unreachable;                     // scope 0 at $DIR/separate_const_switch.rs:+6:15: +6:16\n-      }\n-  \n-      bb3: {\n-          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-          _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-          StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-          _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-          Deinit(_2);                      // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-          ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-          discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-          StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:+7:45: +7:46\n-          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+7:45: +7:46\n--         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n--         switchInt(move _8) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n-+         _8 = const 0_isize;              // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-+         switchInt(const 0_isize) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n-      }\n-  \n-      bb4: {\n-          StorageLive(_11);                // scope 0 at $DIR/separate_const_switch.rs:+12:28: +12:29\n-          _11 = ((_2 as Break).0: usize);  // scope 0 at $DIR/separate_const_switch.rs:+12:28: +12:29\n-          Deinit(_0);                      // scope 4 at $DIR/separate_const_switch.rs:+12:34: +12:38\n-          discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:+12:34: +12:38\n-          StorageDead(_11);                // scope 0 at $DIR/separate_const_switch.rs:+12:37: +12:38\n-          goto -> bb7;                     // scope 0 at $DIR/separate_const_switch.rs:+12:37: +12:38\n-      }\n-  \n-      bb5: {\n-          unreachable;                     // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-      }\n-  \n-      bb6: {\n-          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-          _9 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-          StorageLive(_10);                // scope 3 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-          _10 = _9;                        // scope 3 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-          Deinit(_0);                      // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-          ((_0 as Some).0: i32) = move _10; // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-          discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-          StorageDead(_10);                // scope 3 at $DIR/separate_const_switch.rs:+11:43: +11:44\n-          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n-          goto -> bb7;                     // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n-      }\n-  \n-      bb7: {\n-          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+14:1: +14:2\n-          return;                          // scope 0 at $DIR/separate_const_switch.rs:+14:2: +14:2\n-      }\n-  }\n-  "}, {"sha": "0ee070619e79d4315022f132eddb88af3894e8a1", "filename": "src/test/mir-opt/separate_const_switch.too_complex.PreCodegen.after.mir", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a594044533b5e309eab7ac6b71f4ba8a909af653/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a594044533b5e309eab7ac6b71f4ba8a909af653/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir?ref=a594044533b5e309eab7ac6b71f4ba8a909af653", "patch": "@@ -1,73 +0,0 @@\n-// MIR for `too_complex` after PreCodegen\n-\n-fn too_complex(_1: Result<i32, usize>) -> Option<i32> {\n-    debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:+0:16: +0:17\n-    let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:+0:42: +0:53\n-    let mut _2: std::ops::ControlFlow<usize, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-    let mut _3: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:+7:13: +7:18\n-    let _4: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-    let mut _5: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-    let _6: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:+8:17: +8:18\n-    let _7: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-    let mut _8: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-    let _9: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:+12:28: +12:29\n-    scope 1 {\n-        debug v => _4;                   // in scope 1 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-    }\n-    scope 2 {\n-        debug r => _6;                   // in scope 2 at $DIR/separate_const_switch.rs:+8:17: +8:18\n-    }\n-    scope 3 {\n-        debug v => _7;                   // in scope 3 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-    }\n-    scope 4 {\n-        debug r => _9;                   // in scope 4 at $DIR/separate_const_switch.rs:+12:28: +12:29\n-    }\n-\n-    bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-        _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:+6:15: +6:16\n-        switchInt(move _3) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+6:9: +6:16\n-    }\n-\n-    bb1: {\n-        StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+8:17: +8:18\n-        StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n-        StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+12:28: +12:29\n-        Deinit(_0);                      // scope 4 at $DIR/separate_const_switch.rs:+12:34: +12:38\n-        discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:+12:34: +12:38\n-        StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+12:37: +12:38\n-        goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+12:37: +12:38\n-    }\n-\n-    bb2: {\n-        unreachable;                     // scope 0 at $DIR/separate_const_switch.rs:+6:15: +6:16\n-    }\n-\n-    bb3: {\n-        StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-        _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-        StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-        _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-        Deinit(_2);                      // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-        ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-        discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-        StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:+7:45: +7:46\n-        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+7:45: +7:46\n-        StorageLive(_7);                 // scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-        _7 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-        StorageLive(_8);                 // scope 3 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-        _8 = _7;                         // scope 3 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-        Deinit(_0);                      // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-        ((_0 as Some).0: i32) = move _8; // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-        discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-        StorageDead(_8);                 // scope 3 at $DIR/separate_const_switch.rs:+11:43: +11:44\n-        StorageDead(_7);                 // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n-        goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n-    }\n-\n-    bb4: {\n-        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+14:1: +14:2\n-        return;                          // scope 0 at $DIR/separate_const_switch.rs:+14:2: +14:2\n-    }\n-}"}, {"sha": "83e10bf1213ea17ff075ab78e2628f623cf7561f", "filename": "src/test/ui/consts/miri_unleashed/slice_eq.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -4,14 +4,10 @@\n #![feature(const_raw_ptr_comparison)]\n \n const EMPTY_SLICE: &[i32] = &[];\n-const EMPTY_EQ: bool = EMPTY_SLICE.as_ptr().guaranteed_eq(&[] as *const _);\n-const EMPTY_EQ2: bool = EMPTY_SLICE.as_ptr().guaranteed_ne(&[] as *const _);\n-const EMPTY_NE: bool = EMPTY_SLICE.as_ptr().guaranteed_ne(&[1] as *const _);\n-const EMPTY_NE2: bool = EMPTY_SLICE.as_ptr().guaranteed_eq(&[1] as *const _);\n+const EMPTY_EQ: Option<bool> = EMPTY_SLICE.as_ptr().guaranteed_eq(&[] as *const _);\n+const EMPTY_EQ2: Option<bool> = EMPTY_SLICE.as_ptr().guaranteed_eq(&[1] as *const _);\n \n fn main() {\n-    assert!(!EMPTY_EQ);\n-    assert!(!EMPTY_EQ2);\n-    assert!(!EMPTY_NE);\n-    assert!(!EMPTY_NE2);\n+    assert!(EMPTY_EQ.is_none());\n+    assert!(EMPTY_EQ2.is_none());\n }"}, {"sha": "0a3c2d4bedcbd5f8122efbfe5a5eae0c7f7443aa", "filename": "src/test/ui/consts/ptr_comparisons.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -14,38 +14,30 @@ const FOO: &usize = &42;\n macro_rules! check {\n     (eq, $a:expr, $b:expr) => {\n         pub const _: () =\n-            assert!(std::intrinsics::ptr_guaranteed_eq($a as *const u8, $b as *const u8));\n+            assert!(std::intrinsics::ptr_guaranteed_cmp($a as *const u8, $b as *const u8) == 1);\n     };\n     (ne, $a:expr, $b:expr) => {\n         pub const _: () =\n-            assert!(std::intrinsics::ptr_guaranteed_ne($a as *const u8, $b as *const u8));\n+            assert!(std::intrinsics::ptr_guaranteed_cmp($a as *const u8, $b as *const u8) == 0);\n     };\n-    (!eq, $a:expr, $b:expr) => {\n+    (!, $a:expr, $b:expr) => {\n         pub const _: () =\n-            assert!(!std::intrinsics::ptr_guaranteed_eq($a as *const u8, $b as *const u8));\n-    };\n-    (!ne, $a:expr, $b:expr) => {\n-        pub const _: () =\n-            assert!(!std::intrinsics::ptr_guaranteed_ne($a as *const u8, $b as *const u8));\n+            assert!(std::intrinsics::ptr_guaranteed_cmp($a as *const u8, $b as *const u8) == 2);\n     };\n }\n \n check!(eq, 0, 0);\n check!(ne, 0, 1);\n-check!(!eq, 0, 1);\n-check!(!ne, 0, 0);\n check!(ne, FOO as *const _, 0);\n-check!(!eq, FOO as *const _, 0);\n+check!(ne, unsafe { (FOO as *const usize).offset(1) }, 0);\n+check!(ne, unsafe { (FOO as *const usize as *const u8).offset(3) }, 0);\n+\n // We want pointers to be equal to themselves, but aren't checking this yet because\n // there are some open questions (e.g. whether function pointers to the same function\n // compare equal, they don't necessarily at runtime).\n // The case tested here should work eventually, but does not work yet.\n-check!(!eq, FOO as *const _, FOO as *const _);\n-check!(ne, unsafe { (FOO as *const usize).offset(1) }, 0);\n-check!(!eq, unsafe { (FOO as *const usize).offset(1) }, 0);\n+check!(!, FOO as *const _, FOO as *const _);\n \n-check!(ne, unsafe { (FOO as *const usize as *const u8).offset(3) }, 0);\n-check!(!eq, unsafe { (FOO as *const usize as *const u8).offset(3) }, 0);\n \n ///////////////////////////////////////////////////////////////////////////////\n // If any of the below start compiling, make sure to add a `check` test for it."}, {"sha": "3de2aba5b05e1f1af758fdc770a5bac28d97754a", "filename": "src/test/ui/consts/ptr_comparisons.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f632dbe46fb0041c786450f7a3c37a1a5b7208a9/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr?ref=f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "patch": "@@ -7,19 +7,19 @@ LL |         unsafe { intrinsics::offset(self, count) }\n    |                  out-of-bounds pointer arithmetic: alloc3 has size $WORD, so pointer to $TWO_WORDS bytes starting at offset 0 is out-of-bounds\n    |                  inside `ptr::const_ptr::<impl *const usize>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/ptr_comparisons.rs:58:34\n+  ::: $DIR/ptr_comparisons.rs:50:34\n    |\n LL | const _: *const usize = unsafe { (FOO as *const usize).offset(2) };\n-   |                                  ------------------------------- inside `_` at $DIR/ptr_comparisons.rs:58:34\n+   |                                  ------------------------------- inside `_` at $DIR/ptr_comparisons.rs:50:34\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ptr_comparisons.rs:61:33\n+  --> $DIR/ptr_comparisons.rs:53:33\n    |\n LL |     unsafe { std::ptr::addr_of!((*(FOO as *const usize as *const [u8; 1000]))[999]) };\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: alloc3 has size $WORD, so pointer to 1000 bytes starting at offset 0 is out-of-bounds\n \n error: any use of this value will cause an error\n-  --> $DIR/ptr_comparisons.rs:65:27\n+  --> $DIR/ptr_comparisons.rs:57:27\n    |\n LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) + 4 };\n    | --------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -31,7 +31,7 @@ LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) +\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ptr_comparisons.rs:70:27\n+  --> $DIR/ptr_comparisons.rs:62:27\n    |\n LL | const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4 };\n    | --------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -46,7 +46,7 @@ error: aborting due to 4 previous errors\n For more information about this error, try `rustc --explain E0080`.\n Future incompatibility report: Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ptr_comparisons.rs:65:27\n+  --> $DIR/ptr_comparisons.rs:57:27\n    |\n LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) + 4 };\n    | --------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -59,7 +59,7 @@ LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) +\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ptr_comparisons.rs:70:27\n+  --> $DIR/ptr_comparisons.rs:62:27\n    |\n LL | const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4 };\n    | --------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}]}