{"sha": "9ef56a6ca85ba30494fe63020cde08c8e91f39d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZjU2YTZjYTg1YmEzMDQ5NGZlNjMwMjBjZGUwOGM4ZTkxZjM5ZDQ=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-08-23T02:07:46Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-08-23T18:14:15Z"}, "message": "Update the tutorial with the new macro system.", "tree": {"sha": "4b02c9c3256447eada71cddd1fd162a46b3114ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b02c9c3256447eada71cddd1fd162a46b3114ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ef56a6ca85ba30494fe63020cde08c8e91f39d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef56a6ca85ba30494fe63020cde08c8e91f39d4", "html_url": "https://github.com/rust-lang/rust/commit/9ef56a6ca85ba30494fe63020cde08c8e91f39d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ef56a6ca85ba30494fe63020cde08c8e91f39d4/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77e83d83a9a93188c3bb80ea2bb09f2e5fd2579f", "url": "https://api.github.com/repos/rust-lang/rust/commits/77e83d83a9a93188c3bb80ea2bb09f2e5fd2579f", "html_url": "https://github.com/rust-lang/rust/commit/77e83d83a9a93188c3bb80ea2bb09f2e5fd2579f"}], "stats": {"total": 163, "additions": 154, "deletions": 9}, "files": [{"sha": "60235b8347412b81f293205c60f0e02943f11ba2", "filename": "doc/tutorial.md", "status": "modified", "additions": 154, "deletions": 9, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/9ef56a6ca85ba30494fe63020cde08c8e91f39d4/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ef56a6ca85ba30494fe63020cde08c8e91f39d4/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=9ef56a6ca85ba30494fe63020cde08c8e91f39d4", "patch": "@@ -642,31 +642,31 @@ applies to the module or crate in which it appears.\n \n ## Syntax extensions\n \n-There are plans to support user-defined syntax (macros) in Rust. This\n-currently only exists in very limited form.\n-\n The compiler defines a few built-in syntax extensions. The most useful\n-one is `#fmt`, a printf-style text formatting macro that is expanded\n+one is `fmt!`, a sprintf-style text formatter that is expanded\n at compile time.\n \n ~~~~\n io::println(fmt!(\"%s is %d\", ~\"the answer\", 42));\n ~~~~\n \n-`#fmt` supports most of the directives that [printf][pf] supports, but\n+`fmt!` supports most of the directives that [printf][pf] supports, but\n will give you a compile-time error when the types of the directives\n don't match the types of the arguments.\n \n [pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n \n-All syntax extensions look like `#word`. Another built-in one is\n-`#env`, which will look up its argument as an environment variable at\n+All syntax extensions look like `extension_name!`. Another built-in one is\n+`env!`, which will look up its argument as an environment variable at\n compile-time.\n \n ~~~~\n io::println(env!(\"PATH\"));\n ~~~~\n \n+It is possible for the user to define new syntax extensions, within certain\n+limits. These are called [macros](#macros).\n+\n # Control structures\n \n ## Conditionals\n@@ -902,7 +902,7 @@ So except in code that needs to be really, really fast,\n you should feel free to scatter around debug logging statements, and\n leave them in.\n \n-Three macros that combine text-formatting (as with `#fmt`) and logging\n+Three macros that combine text-formatting (as with `fmt!`) and logging\n are available. These take a string and any number of format arguments,\n and will log the formatted string:\n \n@@ -912,7 +912,7 @@ warn!(\"only %d seconds remaining\", 10);\n error!(\"fatal: %s\", get_error_string());\n ~~~~\n \n-Because the macros `#debug`, `#warn`, and `#error` expand to calls to `log`,\n+Because the macros `debug!`, `warn!`, and `error!` expand to calls to `log`,\n their arguments are also lazily evaluated.\n \n # Functions\n@@ -2334,6 +2334,151 @@ This makes it possible to rebind a variable without actually mutating\n it, which is mostly useful for destructuring (which can rebind, but\n not assign).\n \n+# Macros\n+\n+Functions are the programmer's primary tool of abstraction, but there are\n+cases in which they are insufficient, because the programmer wants to\n+abstract over concepts not represented as values. Consider the following\n+example:\n+\n+~~~~\n+# enum t { special_a(uint), special_b(uint) };\n+# fn f() -> uint {\n+# let input_1 = special_a(0), input_2 = special_a(0);\n+match input_1 {\n+    special_a(x) => { return x; }\n+    _ => {}\n+}\n+// ...\n+match input_2 {\n+    special_b(x) => { return x; }\n+    _ => {}\n+}\n+# return 0u;\n+# }\n+~~~~\n+\n+This code could become tiresome if repeated many times. However, there is\n+no reasonable function that could be written to solve this problem. In such a\n+case, it's possible to define a macro to solve the problem. Macros are\n+lightweight custom syntax extensions, themselves defined using the\n+`macro_rules!` syntax extension:\n+\n+~~~~\n+# enum t { special_a(uint), special_b(uint) };\n+# fn f() -> uint {\n+# let input_1 = special_a(0), input_2 = special_a(0);\n+macro_rules! early_return(\n+    ($inp:expr $sp:ident) => ( //invoke it like `(input_5 special_e)`\n+        match $inp {\n+            $sp(x) => { return x; }\n+            _ => {}\n+        }\n+    );\n+);\n+// ...\n+early_return!(input_1 special_a);\n+// ...\n+early_return!(input_2 special_b);\n+# return 0;\n+# }\n+~~~~\n+\n+Macros are defined in pattern-matching style:\n+\n+## Invocation syntax\n+\n+On the left-hand-side of the `=>` is the macro invocation syntax. It is\n+free-form, excepting the following rules:\n+\n+1. It must be surrounded in parentheses.\n+2. `$` has special meaning.\n+3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n+forbidden.\n+\n+To take as an argument a fragment of Rust code, write `$` followed by a name\n+ (for use on the right-hand side), followed by a `:`, followed by the sort of\n+fragment to match (the most common ones are `ident`, `expr`, `ty`, `pat`, and\n+`block`). Anything not preceeded by a `$` is taken literally. The standard\n+rules of tokenization apply,\n+\n+So `($x:ident => (($e:expr)))`, though excessively fancy, would create a macro\n+that could be invoked like `my_macro!(i=>(( 2+2 )))`.\n+\n+## Transcription syntax\n+\n+The right-hand side of the `=>` follows the same rules as the left-hand side,\n+except that `$` need only be followed by the name of the syntactic fragment\n+to transcribe.\n+\n+## Multiplicity\n+\n+### Invocation\n+\n+Going back to the motivating example, suppose that we wanted each invocation\n+of `early_return` to potentially accept multiple \"special\" identifiers. The\n+syntax `$(...)*` accepts zero or more occurences of its contents, much like\n+the Kleene star operator in regular expressions. It also supports a separator\n+token (a comma-separated list could be written `$(...),*`), and `+` instead of\n+`*` to mean \"at least one\".\n+\n+~~~~\n+# enum t { special_a(uint),special_b(uint),special_c(uint),special_d(uint)};\n+# fn f() -> uint {\n+# let input_1 = special_a(0), input_2 = special_a(0);\n+macro_rules! early_return(\n+    ($inp:expr, [ $($sp:ident)|+ ]) => (\n+        match $inp {\n+            $(\n+                $sp(x) => { return x; }\n+            )+\n+            _ => {}\n+        }\n+    );\n+);\n+// ...\n+early_return!(input_1, [special_a|special_c|special_d]);\n+// ...\n+early_return!(input_2, [special_b]);\n+# return 0;\n+# }\n+~~~~\n+\n+### Transcription\n+\n+As the above example demonstrates, `$(...)*` is also valid on the right-hand\n+side of a macro definition. The behavior of Kleene star in transcription,\n+especially in cases where multiple stars are nested, and multiple different\n+names are involved, can seem somewhat magical and intuitive at first. The\n+system that interprets them is called \"Macro By Example\". The two rules to\n+keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n+of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n+`$name` must be under at least as many `$(...)*`s as it was matched against.\n+If it is under more, it'll will be repeated, as appropriate.\n+\n+## Parsing limitations\n+\n+The parser used by the macro system is reasonably powerful, but the parsing of\n+Rust syntax is restricted in two ways:\n+\n+1. The parser will always parse as much as possible. For example, if the comma\n+were omitted from the syntax of `early_return!` above, `input_1 [` would've\n+been interpreted as the beginning of an array index. In fact, invoking the\n+macro would have been impossible.\n+2. The parser must have eliminated all ambiguity by the time it reaches a\n+`$name:fragment_specifier`. This most often affects them when they occur in\n+the beginning of, or immediately after, a `$(...)*`; requiring a distinctive\n+token in front can solve the problem.\n+\n+## A final note\n+\n+Macros, as currently implemented, are not for the faint of heart. Even\n+ordinary syntax errors can be more difficult to debug when they occur inside\n+a macro, and errors caused by parse problems in generated code can be very\n+tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n+states, and using `--pretty expanded` as an argument to the compiler will\n+show the result of expansion.\n+\n # Traits\n \n Traits are Rust's take on value polymorphism\u2014the thing that"}]}