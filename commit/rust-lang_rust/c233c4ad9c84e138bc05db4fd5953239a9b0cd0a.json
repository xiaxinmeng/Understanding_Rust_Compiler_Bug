{"sha": "c233c4ad9c84e138bc05db4fd5953239a9b0cd0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMzNjNGFkOWM4NGUxMzhiYzA1ZGI0ZmQ1OTUzMjM5YTliMGNkMGE=", "commit": {"author": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2020-02-08T16:58:42Z"}, "committer": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2020-02-14T21:37:30Z"}, "message": "migrate more functions", "tree": {"sha": "906e70f940af7dcede88be8933cd04ce4b47cdcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/906e70f940af7dcede88be8933cd04ce4b47cdcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCXkcTGgAKCRAnUl7150IK\nUCfOAQCyY55Ps8uKGQkQCi6fTtfyyhnffqoCuOvx6OLBi6B18QEA+c60tXxw9yl2\nI5EQvp+/pT9/Sw86y03r/zdfFvJkPgI=\n=Xvbm\n-----END PGP SIGNATURE-----", "payload": "tree 906e70f940af7dcede88be8933cd04ce4b47cdcf\nparent f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b\nauthor Christian Poveda <git@christianpoveda.xyz> 1581181122 -0500\ncommitter Christian Poveda <git@christianpoveda.xyz> 1581716250 -0500\n\nmigrate more functions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a", "html_url": "https://github.com/rust-lang/rust/commit/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "html_url": "https://github.com/rust-lang/rust/commit/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b"}], "stats": {"total": 247, "additions": 136, "deletions": 111}, "files": [{"sha": "6b4ce45f752fe25d1fcecf43c3e3087ac676de1f", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=c233c4ad9c84e138bc05db4fd5953239a9b0cd0a", "patch": "@@ -208,33 +208,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n-            \"posix_memalign\" => {\n-                let ret = this.deref_operand(args[0])?;\n-                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n-                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n-                // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n-                if !align.is_power_of_two() {\n-                    throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                if align < this.pointer_size().bytes() {\n-                    throw_ub_format!(\n-                        \"posix_memalign: alignment must be at least the size of a pointer, but is {}\",\n-                        align,\n-                    );\n-                }\n-\n-                if size == 0 {\n-                    this.write_null(ret.into())?;\n-                } else {\n-                    let ptr = this.memory.allocate(\n-                        Size::from_bytes(size),\n-                        Align::from_bytes(align).unwrap(),\n-                        MiriMemoryKind::C.into(),\n-                    );\n-                    this.write_scalar(ptr, ret.into())?;\n-                }\n-                this.write_null(dest)?;\n-            }\n             \"free\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 this.free(ptr, MiriMemoryKind::C)?;\n@@ -319,53 +292,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(new_ptr, dest)?;\n             }\n \n-            \"syscall\" => {\n-                let sys_getrandom = this\n-                    .eval_path_scalar(&[\"libc\", \"SYS_getrandom\"])?\n-                    .expect(\"Failed to get libc::SYS_getrandom\")\n-                    .to_machine_usize(this)?;\n-\n-                let sys_statx = this\n-                    .eval_path_scalar(&[\"libc\", \"SYS_statx\"])?\n-                    .expect(\"Failed to get libc::SYS_statx\")\n-                    .to_machine_usize(this)?;\n-\n-                match this.read_scalar(args[0])?.to_machine_usize(this)? {\n-                    // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n-                    // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n-                    id if id == sys_getrandom => {\n-                        // The first argument is the syscall id,\n-                        // so skip over it.\n-                        linux_getrandom(this, &args[1..], dest)?;\n-                    }\n-                    id if id == sys_statx => {\n-                        // The first argument is the syscall id,\n-                        // so skip over it.\n-                        let result = this.statx(args[1], args[2], args[3], args[4], args[5])?;\n-                        this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n-                    }\n-                    id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n-                }\n-            }\n-\n-            \"getrandom\" => {\n-                linux_getrandom(this, args, dest)?;\n-            }\n-\n-            \"dlsym\" => {\n-                let _handle = this.read_scalar(args[0])?;\n-                let symbol = this.read_scalar(args[1])?.not_undef()?;\n-                let symbol_name = this.memory.read_c_str(symbol)?;\n-                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n-                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n-                if let Some(dlsym) = Dlsym::from_str(symbol_name)? {\n-                    let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n-                    this.write_scalar(Scalar::from(ptr), dest)?;\n-                } else {\n-                    this.write_null(dest)?;\n-                }\n-            }\n-\n             \"memcmp\" => {\n                 let left = this.read_scalar(args[0])?.not_undef()?;\n                 let right = this.read_scalar(args[1])?.not_undef()?;\n@@ -386,24 +312,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, Size::from_bits(32)), dest)?;\n             }\n \n-            \"memrchr\" => {\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let val = this.read_scalar(args[1])?.to_i32()? as u8;\n-                let num = this.read_scalar(args[2])?.to_machine_usize(this)?;\n-                if let Some(idx) = this\n-                    .memory\n-                    .read_bytes(ptr, Size::from_bytes(num))?\n-                    .iter()\n-                    .rev()\n-                    .position(|&c| c == val)\n-                {\n-                    let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), this)?;\n-                    this.write_scalar(new_ptr, dest)?;\n-                } else {\n-                    this.write_null(dest)?;\n-                }\n-            }\n-\n             \"memchr\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n@@ -728,21 +636,3 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         return Ok(None);\n     }\n }\n-\n-// Shims the linux 'getrandom()' syscall.\n-fn linux_getrandom<'tcx>(\n-    this: &mut MiriEvalContext<'_, 'tcx>,\n-    args: &[OpTy<'tcx, Tag>],\n-    dest: PlaceTy<'tcx, Tag>,\n-) -> InterpResult<'tcx> {\n-    let ptr = this.read_scalar(args[0])?.not_undef()?;\n-    let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n-\n-    // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n-    // neither of which have any effect on our current PRNG.\n-    let _flags = this.read_scalar(args[2])?.to_i32()?;\n-\n-    this.gen_random(ptr, len as usize)?;\n-    this.write_scalar(Scalar::from_uint(len, dest.layout.size), dest)?;\n-    Ok(())\n-}"}, {"sha": "f738bdd7e6e05dedd0975c56e23b746f458dd9f3", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=c233c4ad9c84e138bc05db4fd5953239a9b0cd0a", "patch": "@@ -2,7 +2,7 @@ mod linux;\n mod macos;\n \n use crate::*;\n-use rustc::ty::layout::Size;\n+use rustc::ty::layout::{Align, Size};\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -97,6 +97,66 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n+            \"posix_memalign\" => {\n+                let ret = this.deref_operand(args[0])?;\n+                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n+                if !align.is_power_of_two() {\n+                    throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                if align < this.pointer_size().bytes() {\n+                    throw_ub_format!(\n+                        \"posix_memalign: alignment must be at least the size of a pointer, but is {}\",\n+                        align,\n+                    );\n+                }\n+\n+                if size == 0 {\n+                    this.write_null(ret.into())?;\n+                } else {\n+                    let ptr = this.memory.allocate(\n+                        Size::from_bytes(size),\n+                        Align::from_bytes(align).unwrap(),\n+                        MiriMemoryKind::C.into(),\n+                    );\n+                    this.write_scalar(ptr, ret.into())?;\n+                }\n+                this.write_null(dest)?;\n+            }\n+\n+            \"dlsym\" => {\n+                let _handle = this.read_scalar(args[0])?;\n+                let symbol = this.read_scalar(args[1])?.not_undef()?;\n+                let symbol_name = this.memory.read_c_str(symbol)?;\n+                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n+                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n+                if let Some(dlsym) = Dlsym::from_str(symbol_name)? {\n+                    let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n+                    this.write_scalar(Scalar::from(ptr), dest)?;\n+                } else {\n+                    this.write_null(dest)?;\n+                }\n+            }\n+\n+            \"memrchr\" => {\n+                let ptr = this.read_scalar(args[0])?.not_undef()?;\n+                let val = this.read_scalar(args[1])?.to_i32()? as u8;\n+                let num = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                if let Some(idx) = this\n+                    .memory\n+                    .read_bytes(ptr, Size::from_bytes(num))?\n+                    .iter()\n+                    .rev()\n+                    .position(|&c| c == val)\n+                {\n+                    let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), this)?;\n+                    this.write_scalar(new_ptr, dest)?;\n+                } else {\n+                    this.write_null(dest)?;\n+                }\n+            }\n+\n             _ => {\n                 match this.tcx.sess.target.target.target_os.to_lowercase().as_str() {\n                     \"linux\" => linux::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest)?,\n@@ -109,3 +169,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n }\n+\n+// Shims the posix 'getrandom()' syscall.\n+fn getrandom<'tcx>(\n+    this: &mut MiriEvalContext<'_, 'tcx>,\n+    args: &[OpTy<'tcx, Tag>],\n+    dest: PlaceTy<'tcx, Tag>,\n+) -> InterpResult<'tcx> {\n+    let ptr = this.read_scalar(args[0])?.not_undef()?;\n+    let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+\n+    // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n+    // neither of which have any effect on our current PRNG.\n+    let _flags = this.read_scalar(args[2])?.to_i32()?;\n+\n+    this.gen_random(ptr, len as usize)?;\n+    this.write_scalar(Scalar::from_uint(len, dest.layout.size), dest)?;\n+    Ok(())\n+}"}, {"sha": "8d928b60ecbda76a813eaf81764e0fce8e6a84fd", "filename": "src/shims/foreign_items/posix/linux.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs?ref=c233c4ad9c84e138bc05db4fd5953239a9b0cd0a", "patch": "@@ -41,6 +41,40 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"pthread_getattr_np\" => {\n                 this.write_null(dest)?;\n             }\n+\n+            \"syscall\" => {\n+                let sys_getrandom = this\n+                    .eval_path_scalar(&[\"libc\", \"SYS_getrandom\"])?\n+                    .expect(\"Failed to get libc::SYS_getrandom\")\n+                    .to_machine_usize(this)?;\n+\n+                let sys_statx = this\n+                    .eval_path_scalar(&[\"libc\", \"SYS_statx\"])?\n+                    .expect(\"Failed to get libc::SYS_statx\")\n+                    .to_machine_usize(this)?;\n+\n+                match this.read_scalar(args[0])?.to_machine_usize(this)? {\n+                    // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n+                    // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n+                    id if id == sys_getrandom => {\n+                        // The first argument is the syscall id,\n+                        // so skip over it.\n+                        super::getrandom(this, &args[1..], dest)?;\n+                    }\n+                    id if id == sys_statx => {\n+                        // The first argument is the syscall id,\n+                        // so skip over it.\n+                        let result = this.statx(args[1], args[2], args[3], args[4], args[5])?;\n+                        this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+                    }\n+                    id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n+                }\n+            }\n+\n+            \"getrandom\" => {\n+                super::getrandom(this, args, dest)?;\n+            }\n+\n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         };\n "}, {"sha": "c4bfb98562dbd1c95473d878902f876058aac8ce", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c233c4ad9c84e138bc05db4fd5953239a9b0cd0a/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=c233c4ad9c84e138bc05db4fd5953239a9b0cd0a", "patch": "@@ -57,30 +57,53 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"pthread_attr_get_np\" => {\n                 this.write_null(dest)?;\n             }\n+\n             \"pthread_get_stackaddr_np\" => {\n                 let stack_addr = Scalar::from_uint(STACK_ADDR, dest.layout.size);\n                 this.write_scalar(stack_addr, dest)?;\n             }\n+\n             \"pthread_get_stacksize_np\" => {\n                 let stack_size = Scalar::from_uint(STACK_SIZE, dest.layout.size);\n                 this.write_scalar(stack_size, dest)?;\n             }\n+\n             \"_tlv_atexit\" => {\n                 // FIXME: register the destructor.\n             }\n+\n             \"_NSGetArgc\" => {\n                 this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n             }\n+\n             \"_NSGetArgv\" => {\n                 this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n+\n             \"SecRandomCopyBytes\" => {\n                 let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n                 this.gen_random(ptr, len as usize)?;\n                 this.write_null(dest)?;\n             }\n \n+            \"syscall\" => {\n+                let sys_getrandom = this\n+                    .eval_path_scalar(&[\"libc\", \"SYS_getrandom\"])?\n+                    .expect(\"Failed to get libc::SYS_getrandom\")\n+                    .to_machine_usize(this)?;\n+\n+                match this.read_scalar(args[0])?.to_machine_usize(this)? {\n+                    // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n+                    // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n+                    id if id == sys_getrandom => {\n+                        // The first argument is the syscall id,\n+                        // so skip over it.\n+                        super::getrandom(this, &args[1..], dest)?;\n+                    }\n+                    id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n+                }\n+            }\n \n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         };"}]}