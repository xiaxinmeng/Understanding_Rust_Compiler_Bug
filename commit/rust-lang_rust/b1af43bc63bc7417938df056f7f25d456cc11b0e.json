{"sha": "b1af43bc63bc7417938df056f7f25d456cc11b0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYWY0M2JjNjNiYzc0MTc5MzhkZjA1NmY3ZjI1ZDQ1NmNjMTFiMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-10T21:19:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-10T21:19:50Z"}, "message": "Auto merge of #76934 - camelid:rustdoc-allow-generic-params, r=jyn514\n\nAllow generic parameters in intra-doc links\n\nFixes #62834.\n\n---\n\nThe contents of the generics will be mostly ignored (except for warning\nif fully-qualified syntax is used, which is currently unsupported in\nintra-doc links - see issue #74563).\n\n* Allow links like `Vec<T>`, `Result<T, E>`, and `Option<Box<T>>`\n* Allow links like `Vec::<T>::new()`\n* Warn on\n  * Unbalanced angle brackets (e.g. `Vec<T` or `Vec<T>>`)\n  * Missing type to apply generics to (`<T>` or `<Box<T>>`)\n  * Use of fully-qualified syntax (`<Vec as IntoIterator>::into_iter`)\n  * Invalid path separator (`Vec:<T>:new`)\n  * Too many angle brackets (`Vec<<T>>`)\n  * Empty angle brackets (`Vec<>`)\n\nNote that this implementation *does* allow some constructs that aren't\nvalid in the actual Rust syntax, for example `Box::<T>new()`. That may\nnot be supported in rustdoc in the future; it is an implementation\ndetail.", "tree": {"sha": "cb2e27c8a5a4bbe28701e04801eeb50c2a829104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb2e27c8a5a4bbe28701e04801eeb50c2a829104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1af43bc63bc7417938df056f7f25d456cc11b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1af43bc63bc7417938df056f7f25d456cc11b0e", "html_url": "https://github.com/rust-lang/rust/commit/b1af43bc63bc7417938df056f7f25d456cc11b0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1af43bc63bc7417938df056f7f25d456cc11b0e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "790d19cd259e9ec656c6e0bb1446e980115ba46f", "url": "https://api.github.com/repos/rust-lang/rust/commits/790d19cd259e9ec656c6e0bb1446e980115ba46f", "html_url": "https://github.com/rust-lang/rust/commit/790d19cd259e9ec656c6e0bb1446e980115ba46f"}, {"sha": "e2424a2c1f4d5502b8900a1701c7a8a3a2a28bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2424a2c1f4d5502b8900a1701c7a8a3a2a28bf9", "html_url": "https://github.com/rust-lang/rust/commit/e2424a2c1f4d5502b8900a1701c7a8a3a2a28bf9"}], "stats": {"total": 461, "additions": 441, "deletions": 20}, "files": [{"sha": "1acb44f6d22f3b80873d463932845a8fe2dd9631", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -92,7 +92,7 @@ rustc_queries! {\n         /// Computes the `DefId` of the corresponding const parameter in case the `key` is a\n         /// const argument and returns `None` otherwise.\n         ///\n-        /// ```rust\n+        /// ```ignore (incomplete)\n         /// let a = foo::<7>();\n         /// //            ^ Calling `opt_const_param_of` for this argument,\n         ///\n@@ -162,10 +162,12 @@ rustc_queries! {\n         /// Specifically this is the bounds written on the trait's type\n         /// definition, or those after the `impl` keyword\n         ///\n+        /// ```ignore (incomplete)\n         /// type X: Bound + 'lt\n-        ///         ^^^^^^^^^^^\n+        /// //      ^^^^^^^^^^^\n         /// impl Debug + Display\n-        ///      ^^^^^^^^^^^^^^^\n+        /// //   ^^^^^^^^^^^^^^^\n+        /// ```\n         ///\n         /// `key` is the `DefId` of the associated type or opaque type.\n         ///\n@@ -176,18 +178,22 @@ rustc_queries! {\n \n         /// Elaborated version of the predicates from `explicit_item_bounds`.\n         ///\n-        /// Example for\n+        /// For example:\n         ///\n+        /// ```\n         /// trait MyTrait {\n-        ///     type MyAType: Eq + ?Sized`\n+        ///     type MyAType: Eq + ?Sized;\n         /// }\n+        /// ```\n         ///\n         /// `explicit_item_bounds` returns `[<Self as MyTrait>::MyAType: Eq]`,\n         /// and `item_bounds` returns\n+        /// ```text\n         /// [\n         ///     <Self as Trait>::MyAType: Eq,\n         ///     <Self as Trait>::MyAType: PartialEq<<Self as Trait>::MyAType>\n         /// ]\n+        /// ```\n         ///\n         /// Bounds from the parent (e.g. with nested impl trait) are not included.\n         query item_bounds(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {"}, {"sha": "9cb20a0afdc6e551630d5f37279a65dc3b0a1d0b", "filename": "library/core/src/option.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -141,6 +141,9 @@\n //! ```\n //!\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`Box<U>`]: ../../std/boxed/struct.Box.html\n+//! [`num::NonZero*`]: crate::num\n+//! [`ptr::NonNull<U>`]: crate::ptr::NonNull\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "a3fa525be1db0efa94421f9d9926d4eeadbde16a", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -8,5 +8,5 @@\n - [Linking to items by name](linking-to-items-by-name.md)\n - [Lints](lints.md)\n - [Passes](passes.md)\n-- [Advanced Features](advanced-features.md)\n+- [Advanced features](advanced-features.md)\n - [Unstable features](unstable-features.md)"}, {"sha": "5128ff13b7a799329b59678d3fa4b2cc0cc395b5", "filename": "src/doc/rustdoc/src/advanced-features.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -1,4 +1,4 @@\n-# Advanced Features\n+# Advanced features\n \n The features listed on this page fall outside the rest of the main categories.\n "}, {"sha": "76e04398530fef59d2efafaa06f2bce779cba98a", "filename": "src/doc/rustdoc/src/linking-to-items-by-name.md", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Fdoc%2Frustdoc%2Fsrc%2Flinking-to-items-by-name.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Fdoc%2Frustdoc%2Fsrc%2Flinking-to-items-by-name.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flinking-to-items-by-name.md?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -1,6 +1,7 @@\n # Linking to items by name\n \n-Rustdoc is capable of directly linking to other rustdoc pages in Markdown documentation using the path of item as a link.\n+Rustdoc is capable of directly linking to other rustdoc pages using the path of\n+the item as a link.\n \n For example, in the following code all of the links will link to the rustdoc page for `Bar`:\n \n@@ -19,15 +20,26 @@ pub struct Foo3;\n /// This struct is also not [`Bar`]\n pub struct Foo4;\n \n+/// This struct *is* [`Bar`]!\n pub struct Bar;\n ```\n \n-You can refer to anything in scope, and use paths, including `Self`, `self`, `super`, and `crate`. You may also use `foo()` and `foo!()` to refer to methods/functions and macros respectively. Backticks around the link will be stripped.\n+Backticks around the link will be stripped, so ``[`Option`]`` will correctly\n+link to `Option`.\n+\n+You can refer to anything in scope, and use paths, including `Self`, `self`,\n+`super`, and `crate`. You may also use `foo()` and `foo!()` to refer to methods/functions and macros, respectively.\n+\n+You can also refer to items with generic parameters like `Vec<T>`. The link will\n+resolve as if you had written ``[`Vec<T>`](Vec)``. Fully-qualified syntax (for example,\n+`<Vec as IntoIterator>::into_iter()`) is [not yet supported][fqs-issue], however.\n+\n+[fqs-issue]: https://github.com/rust-lang/rust/issues/74563\n \n ```rust,edition2018\n use std::sync::mpsc::Receiver;\n \n-/// This is an version of [`Receiver`], with support for [`std::future`].\n+/// This is a version of [`Receiver<T>`] with support for [`std::future`].\n ///\n /// You can obtain a [`std::future::Future`] by calling [`Self::recv()`].\n pub struct AsyncReceiver<T> {\n@@ -44,13 +56,15 @@ impl<T> AsyncReceiver<T> {\n You can also link to sections using URL fragment specifiers:\n \n ```rust\n-/// This is a special implementation of [positional parameters]\n+/// This is a special implementation of [positional parameters].\n ///\n /// [positional parameters]: std::fmt#formatting-parameters\n struct MySpecialFormatter;\n ```\n \n-Paths in Rust have three namespaces: type, value, and macro. Items from these namespaces are allowed to overlap. In case of ambiguity, rustdoc will warn about the ambiguity and ask you to disambiguate, which can be done by using a prefix like  `struct@`, `enum@`, `type@`, `trait@`, `union@`, `const@`, `static@`, `value@`, `function@`, `mod@`, `fn@`, `module@`, `method@`, `prim@`, `primitive@`, `macro@`, or `derive@`:\n+Paths in Rust have three namespaces: type, value, and macro. Item names must be\n+unique within their namespace, but can overlap with items outside of their\n+namespace. In case of ambiguity, rustdoc will warn about the ambiguity and ask you to disambiguate, which can be done by using a prefix like `struct@`, `enum@`, `type@`, `trait@`, `union@`, `const@`, `static@`, `value@`, `fn@`, `function@`, `mod@`, `module@`, `method@`, `prim@`, `primitive@`, `macro@`, or `derive@`:\n \n ```rust\n /// See also: [`Foo`](struct@Foo)\n@@ -62,4 +76,19 @@ struct Foo {}\n fn Foo() {}\n ```\n \n-Note: Because of how `macro_rules` macros are scoped in Rust, the intra-doc links of a `macro_rules` macro will be resolved relative to the crate root, as opposed to the module it is defined in.\n+You can also disambiguate for functions by adding `()` after the function name,\n+or for macros by adding `!` after the macro name:\n+\n+```rust\n+/// See also: [`Foo`](struct@Foo)\n+struct Bar;\n+\n+/// This is different from [`Foo()`]\n+struct Foo {}\n+\n+fn Foo() {}\n+```\n+\n+Note: Because of how `macro_rules!` macros are scoped in Rust, the intra-doc links of a `macro_rules!` macro will be resolved [relative to the crate root][#72243], as opposed to the module it is defined in.\n+\n+[#72243]: https://github.com/rust-lang/rust/issues/72243"}, {"sha": "cb9099cd50bee2d0a290cf84907033cdd1c1de4f", "filename": "src/doc/rustdoc/src/lints.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -4,18 +4,18 @@\n can use them like any other lints by doing this:\n \n ```rust,ignore\n-#![allow(missing_docs)] // allowing the lint, no message\n-#![warn(missing_docs)] // warn if there is missing docs\n-#![deny(missing_docs)] // rustdoc will fail if there is missing docs\n+#![allow(missing_docs)] // allows the lint, no diagnostics will be reported\n+#![warn(missing_docs)] // warn if there are missing docs\n+#![deny(missing_docs)] // error if there are missing docs\n ```\n \n Here is the list of the lints provided by `rustdoc`:\n \n ## broken_intra_doc_links\n \n-This lint **warns by default**. This lint detects when an [intra-doc link] fails to get resolved. For example:\n+This lint **warns by default**. This lint detects when an [intra-doc link] fails to be resolved. For example:\n \n- [intra-doc link]: linking-to-items-by-name.html\n+[intra-doc link]: linking-to-items-by-name.md\n \n ```rust\n /// I want to link to [`Nonexistent`] but it doesn't exist!"}, {"sha": "12726d2bd9a3e048013f0b555cd4a64abb56ef65", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -3,11 +3,13 @@\n     html_playground_url = \"https://play.rust-lang.org/\"\n )]\n #![feature(rustc_private)]\n+#![feature(array_methods)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![feature(peekable_next_if)]\n #![feature(test)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]"}, {"sha": "fb79272768e875ed6d3746878b3c939dfc1ba33e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 202, "deletions": 1, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -23,6 +23,7 @@ use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n use std::cell::Cell;\n+use std::mem;\n use std::ops::Range;\n \n use crate::clean::*;\n@@ -65,10 +66,53 @@ enum ResolutionFailure<'a> {\n     NotResolved { module_id: DefId, partial_res: Option<Res>, unresolved: Cow<'a, str> },\n     /// should not ever happen\n     NoParentItem,\n+    /// This link has malformed generic parameters; e.g., the angle brackets are unbalanced.\n+    MalformedGenerics(MalformedGenerics),\n     /// used to communicate that this should be ignored, but shouldn't be reported to the user\n     Dummy,\n }\n \n+#[derive(Debug)]\n+enum MalformedGenerics {\n+    /// This link has unbalanced angle brackets.\n+    ///\n+    /// For example, `Vec<T` should trigger this, as should `Vec<T>>`.\n+    UnbalancedAngleBrackets,\n+    /// The generics are not attached to a type.\n+    ///\n+    /// For example, `<T>` should trigger this.\n+    ///\n+    /// This is detected by checking if the path is empty after the generics are stripped.\n+    MissingType,\n+    /// The link uses fully-qualified syntax, which is currently unsupported.\n+    ///\n+    /// For example, `<Vec as IntoIterator>::into_iter` should trigger this.\n+    ///\n+    /// This is detected by checking if ` as ` (the keyword `as` with spaces around it) is inside\n+    /// angle brackets.\n+    HasFullyQualifiedSyntax,\n+    /// The link has an invalid path separator.\n+    ///\n+    /// For example, `Vec:<T>:new()` should trigger this. Note that `Vec:new()` will **not**\n+    /// trigger this because it has no generics and thus [`strip_generics_from_path`] will not be\n+    /// called.\n+    ///\n+    /// Note that this will also **not** be triggered if the invalid path separator is inside angle\n+    /// brackets because rustdoc mostly ignores what's inside angle brackets (except for\n+    /// [`HasFullyQualifiedSyntax`](MalformedGenerics::HasFullyQualifiedSyntax)).\n+    ///\n+    /// This is detected by checking if there is a colon followed by a non-colon in the link.\n+    InvalidPathSeparator,\n+    /// The link has too many angle brackets.\n+    ///\n+    /// For example, `Vec<<T>>` should trigger this.\n+    TooManyAngleBrackets,\n+    /// The link has empty angle brackets.\n+    ///\n+    /// For example, `Vec<>` should trigger this.\n+    EmptyAngleBrackets,\n+}\n+\n impl ResolutionFailure<'a> {\n     // This resolved fully (not just partially) but is erroneous for some other reason\n     fn full_res(&self) -> Option<Res> {\n@@ -908,6 +952,7 @@ impl LinkCollector<'_, '_> {\n         let link_text;\n         let mut path_str;\n         let disambiguator;\n+        let stripped_path_string;\n         let (mut res, mut fragment) = {\n             path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n                 disambiguator = Some(d);\n@@ -918,7 +963,7 @@ impl LinkCollector<'_, '_> {\n             }\n             .trim();\n \n-            if path_str.contains(|ch: char| !(ch.is_alphanumeric() || ch == ':' || ch == '_')) {\n+            if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, \".contains(ch))) {\n                 return None;\n             }\n \n@@ -981,6 +1026,36 @@ impl LinkCollector<'_, '_> {\n                 module_id = DefId { krate, index: CRATE_DEF_INDEX };\n             }\n \n+            // Strip generics from the path.\n+            if path_str.contains(['<', '>'].as_slice()) {\n+                stripped_path_string = match strip_generics_from_path(path_str) {\n+                    Ok(path) => path,\n+                    Err(err_kind) => {\n+                        debug!(\"link has malformed generics: {}\", path_str);\n+                        resolution_failure(\n+                            self,\n+                            &item,\n+                            path_str,\n+                            disambiguator,\n+                            dox,\n+                            link_range,\n+                            smallvec![err_kind],\n+                        );\n+                        return None;\n+                    }\n+                };\n+                path_str = &stripped_path_string;\n+            }\n+\n+            // Sanity check to make sure we don't have any angle brackets after stripping generics.\n+            assert!(!path_str.contains(['<', '>'].as_slice()));\n+\n+            // The link is not an intra-doc link if it still contains commas or spaces after\n+            // stripping generics.\n+            if path_str.contains([',', ' '].as_slice()) {\n+                return None;\n+            }\n+\n             match self.resolve_with_disambiguator(\n                 disambiguator,\n                 item,\n@@ -1714,6 +1789,27 @@ fn resolution_failure(\n                         diag.level = rustc_errors::Level::Bug;\n                         \"all intra doc links should have a parent item\".to_owned()\n                     }\n+                    ResolutionFailure::MalformedGenerics(variant) => match variant {\n+                        MalformedGenerics::UnbalancedAngleBrackets => {\n+                            String::from(\"unbalanced angle brackets\")\n+                        }\n+                        MalformedGenerics::MissingType => {\n+                            String::from(\"missing type for generic parameters\")\n+                        }\n+                        MalformedGenerics::HasFullyQualifiedSyntax => {\n+                            diag.note(\"see https://github.com/rust-lang/rust/issues/74563 for more information\");\n+                            String::from(\"fully-qualified syntax is unsupported\")\n+                        }\n+                        MalformedGenerics::InvalidPathSeparator => {\n+                            String::from(\"has invalid path separator\")\n+                        }\n+                        MalformedGenerics::TooManyAngleBrackets => {\n+                            String::from(\"too many angle brackets\")\n+                        }\n+                        MalformedGenerics::EmptyAngleBrackets => {\n+                            String::from(\"empty angle brackets\")\n+                        }\n+                    },\n                 };\n                 if let Some(span) = sp {\n                     diag.span_label(span, &note);\n@@ -1904,3 +2000,108 @@ fn is_primitive(path_str: &str, ns: Namespace) -> Option<(&'static str, Res)> {\n fn primitive_impl(cx: &DocContext<'_>, path_str: &str) -> Option<&'static SmallVec<[DefId; 4]>> {\n     Some(PrimitiveType::from_symbol(Symbol::intern(path_str))?.impls(cx.tcx))\n }\n+\n+fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<'static>> {\n+    let mut stripped_segments = vec![];\n+    let mut path = path_str.chars().peekable();\n+    let mut segment = Vec::new();\n+\n+    while let Some(chr) = path.next() {\n+        match chr {\n+            ':' => {\n+                if path.next_if_eq(&':').is_some() {\n+                    let stripped_segment =\n+                        strip_generics_from_path_segment(mem::take(&mut segment))?;\n+                    if !stripped_segment.is_empty() {\n+                        stripped_segments.push(stripped_segment);\n+                    }\n+                } else {\n+                    return Err(ResolutionFailure::MalformedGenerics(\n+                        MalformedGenerics::InvalidPathSeparator,\n+                    ));\n+                }\n+            }\n+            '<' => {\n+                segment.push(chr);\n+\n+                match path.next() {\n+                    Some('<') => {\n+                        return Err(ResolutionFailure::MalformedGenerics(\n+                            MalformedGenerics::TooManyAngleBrackets,\n+                        ));\n+                    }\n+                    Some('>') => {\n+                        return Err(ResolutionFailure::MalformedGenerics(\n+                            MalformedGenerics::EmptyAngleBrackets,\n+                        ));\n+                    }\n+                    Some(chr) => {\n+                        segment.push(chr);\n+\n+                        while let Some(chr) = path.next_if(|c| *c != '>') {\n+                            segment.push(chr);\n+                        }\n+                    }\n+                    None => break,\n+                }\n+            }\n+            _ => segment.push(chr),\n+        }\n+        debug!(\"raw segment: {:?}\", segment);\n+    }\n+\n+    if !segment.is_empty() {\n+        let stripped_segment = strip_generics_from_path_segment(segment)?;\n+        if !stripped_segment.is_empty() {\n+            stripped_segments.push(stripped_segment);\n+        }\n+    }\n+\n+    debug!(\"path_str: {:?}\\nstripped segments: {:?}\", path_str, &stripped_segments);\n+\n+    let stripped_path = stripped_segments.join(\"::\");\n+\n+    if !stripped_path.is_empty() {\n+        Ok(stripped_path)\n+    } else {\n+        Err(ResolutionFailure::MalformedGenerics(MalformedGenerics::MissingType))\n+    }\n+}\n+\n+fn strip_generics_from_path_segment(\n+    segment: Vec<char>,\n+) -> Result<String, ResolutionFailure<'static>> {\n+    let mut stripped_segment = String::new();\n+    let mut param_depth = 0;\n+\n+    let mut latest_generics_chunk = String::new();\n+\n+    for c in segment {\n+        if c == '<' {\n+            param_depth += 1;\n+            latest_generics_chunk.clear();\n+        } else if c == '>' {\n+            param_depth -= 1;\n+            if latest_generics_chunk.contains(\" as \") {\n+                // The segment tries to use fully-qualified syntax, which is currently unsupported.\n+                // Give a helpful error message instead of completely ignoring the angle brackets.\n+                return Err(ResolutionFailure::MalformedGenerics(\n+                    MalformedGenerics::HasFullyQualifiedSyntax,\n+                ));\n+            }\n+        } else {\n+            if param_depth == 0 {\n+                stripped_segment.push(c);\n+            } else {\n+                latest_generics_chunk.push(c);\n+            }\n+        }\n+    }\n+\n+    if param_depth == 0 {\n+        Ok(stripped_segment)\n+    } else {\n+        // The segment has unbalanced angle brackets, e.g. `Vec<T` or `Vec<T>>`\n+        Err(ResolutionFailure::MalformedGenerics(MalformedGenerics::UnbalancedAngleBrackets))\n+    }\n+}"}, {"sha": "81e42643ae8fc5e6b70bf8554fab26f530fa3499", "filename": "src/test/rustdoc-ui/intra-link-errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -2,7 +2,7 @@\n //~^ NOTE lint level is defined\n \n // FIXME: this should say that it was skipped (maybe an allowed by default lint?)\n-/// [<invalid syntax>]\n+/// [invalid intra-doc syntax!!]\n \n /// [path::to::nonexistent::module]\n //~^ ERROR unresolved link"}, {"sha": "9c54092146fef61753e436cd8e55f7b9c45e1a16", "filename": "src/test/rustdoc-ui/intra-link-malformed-generics.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Ftest%2Frustdoc-ui%2Fintra-link-malformed-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Ftest%2Frustdoc-ui%2Fintra-link-malformed-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-malformed-generics.rs?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -0,0 +1,19 @@\n+#![deny(broken_intra_doc_links)]\n+\n+//! [Vec<] //~ ERROR\n+//! [Vec<Box<T] //~ ERROR\n+//! [Vec<Box<T>] //~ ERROR\n+//! [Vec<Box<T>>>] //~ ERROR\n+//! [Vec<T>>>] //~ ERROR\n+//! [<Vec] //~ ERROR\n+//! [Vec::<] //~ ERROR\n+//! [<T>] //~ ERROR\n+//! [<invalid syntax>] //~ ERROR\n+//! [Vec:<T>:new()] //~ ERROR\n+//! [Vec<<T>>] //~ ERROR\n+//! [Vec<>] //~ ERROR\n+//! [Vec<<>>] //~ ERROR\n+\n+// FIXME(#74563) support UFCS\n+//! [<Vec as IntoIterator>::into_iter] //~ ERROR\n+//! [<Vec<T> as IntoIterator>::iter] //~ ERROR"}, {"sha": "fe5d4cd1bbffa43a3a19ae706e943bd32e523985", "filename": "src/test/rustdoc-ui/intra-link-malformed-generics.stderr", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Ftest%2Frustdoc-ui%2Fintra-link-malformed-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Ftest%2Frustdoc-ui%2Fintra-link-malformed-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-malformed-generics.stderr?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -0,0 +1,102 @@\n+error: unresolved link to `Vec<`\n+  --> $DIR/intra-link-malformed-generics.rs:3:6\n+   |\n+LL | //! [Vec<]\n+   |      ^^^^ unbalanced angle brackets\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intra-link-malformed-generics.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unresolved link to `Vec<Box<T`\n+  --> $DIR/intra-link-malformed-generics.rs:4:6\n+   |\n+LL | //! [Vec<Box<T]\n+   |      ^^^^^^^^^ unbalanced angle brackets\n+\n+error: unresolved link to `Vec<Box<T>`\n+  --> $DIR/intra-link-malformed-generics.rs:5:6\n+   |\n+LL | //! [Vec<Box<T>]\n+   |      ^^^^^^^^^^ unbalanced angle brackets\n+\n+error: unresolved link to `Vec<Box<T>>>`\n+  --> $DIR/intra-link-malformed-generics.rs:6:6\n+   |\n+LL | //! [Vec<Box<T>>>]\n+   |      ^^^^^^^^^^^^ unbalanced angle brackets\n+\n+error: unresolved link to `Vec<T>>>`\n+  --> $DIR/intra-link-malformed-generics.rs:7:6\n+   |\n+LL | //! [Vec<T>>>]\n+   |      ^^^^^^^^ unbalanced angle brackets\n+\n+error: unresolved link to `<Vec`\n+  --> $DIR/intra-link-malformed-generics.rs:8:6\n+   |\n+LL | //! [<Vec]\n+   |      ^^^^ unbalanced angle brackets\n+\n+error: unresolved link to `Vec::<`\n+  --> $DIR/intra-link-malformed-generics.rs:9:6\n+   |\n+LL | //! [Vec::<]\n+   |      ^^^^^^ unbalanced angle brackets\n+\n+error: unresolved link to `<T>`\n+  --> $DIR/intra-link-malformed-generics.rs:10:6\n+   |\n+LL | //! [<T>]\n+   |      ^^^ missing type for generic parameters\n+\n+error: unresolved link to `<invalid syntax>`\n+  --> $DIR/intra-link-malformed-generics.rs:11:6\n+   |\n+LL | //! [<invalid syntax>]\n+   |      ^^^^^^^^^^^^^^^^ missing type for generic parameters\n+\n+error: unresolved link to `Vec:<T>:new`\n+  --> $DIR/intra-link-malformed-generics.rs:12:6\n+   |\n+LL | //! [Vec:<T>:new()]\n+   |      ^^^^^^^^^^^^^ has invalid path separator\n+\n+error: unresolved link to `Vec<<T>>`\n+  --> $DIR/intra-link-malformed-generics.rs:13:6\n+   |\n+LL | //! [Vec<<T>>]\n+   |      ^^^^^^^^ too many angle brackets\n+\n+error: unresolved link to `Vec<>`\n+  --> $DIR/intra-link-malformed-generics.rs:14:6\n+   |\n+LL | //! [Vec<>]\n+   |      ^^^^^ empty angle brackets\n+\n+error: unresolved link to `Vec<<>>`\n+  --> $DIR/intra-link-malformed-generics.rs:15:6\n+   |\n+LL | //! [Vec<<>>]\n+   |      ^^^^^^^ too many angle brackets\n+\n+error: unresolved link to `<Vec as IntoIterator>::into_iter`\n+  --> $DIR/intra-link-malformed-generics.rs:18:6\n+   |\n+LL | //! [<Vec as IntoIterator>::into_iter]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ fully-qualified syntax is unsupported\n+   |\n+   = note: see https://github.com/rust-lang/rust/issues/74563 for more information\n+\n+error: unresolved link to `<Vec<T> as IntoIterator>::iter`\n+  --> $DIR/intra-link-malformed-generics.rs:19:6\n+   |\n+LL | //! [<Vec<T> as IntoIterator>::iter]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ fully-qualified syntax is unsupported\n+   |\n+   = note: see https://github.com/rust-lang/rust/issues/74563 for more information\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "7d7289437ff8afe411d27cc9405abc12258fed2d", "filename": "src/test/rustdoc/intra-doc-link-generic-params.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Ftest%2Frustdoc%2Fintra-doc-link-generic-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1af43bc63bc7417938df056f7f25d456cc11b0e/src%2Ftest%2Frustdoc%2Fintra-doc-link-generic-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-link-generic-params.rs?ref=b1af43bc63bc7417938df056f7f25d456cc11b0e", "patch": "@@ -0,0 +1,59 @@\n+// ignore-tidy-linelength\n+\n+#![crate_name = \"foo\"]\n+\n+//! Here's a link to [`Vec<T>`] and one to [`Box<Vec<Option<T>>>`].\n+//! Here's a link to [`Iterator<Box<T>>::Item`].\n+//!\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html\"]' 'Vec<T>'\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html\"]' 'Box<Vec<Option<T>>>'\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\"]' 'Iterator<Box<T>>::Item'\n+\n+//! And what about a link to [just `Option`](Option) and, [with the generic, `Option<T>`](Option<T>)?\n+//!\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\"]' 'just Option'\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\"]' 'with the generic, Option<T>'\n+\n+//! We should also try linking to [`Result<T, E>`]; it has *two* generics!\n+//!\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\"]' 'Result<T, E>'\n+\n+//! Now let's test a trickier case: [`Vec::<T>::new`], or you could write it\n+//! [with parentheses as `Vec::<T>::new()`][Vec::<T>::new()].\n+//! And what about something even harder? That would be [`Vec::<Box<T>>::new()`].\n+//!\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.new\"]' 'Vec::<T>::new'\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.new\"]' 'with parentheses as Vec::<T>::new()'\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.new\"]' 'Vec::<Box<T>>::new()'\n+\n+//! This is also pretty tricky: [`TypeId::of::<String>()`].\n+//! And this too: [`Vec::<std::error::Error>::len`].\n+//!\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html#method.of\"]' 'TypeId::of::<String>()'\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.len\"]' 'Vec::<std::error::Error>::len'\n+\n+//! We unofficially and implicitly support things that aren't valid in the actual Rust syntax, like\n+//! [`Box::<T>new()`]. We may not support them in the future!\n+//!\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.new\"]' 'Box::<T>new()'\n+\n+//! These will be resolved as regular links:\n+//! - [`this is <invalid syntax> first`](https://www.rust-lang.org)\n+//! - [`this is <invalid syntax> twice`]\n+//! - [`<invalid syntax> thrice`](https://www.rust-lang.org)\n+//! - [`<invalid syntax> four times`][rlo]\n+//! - [a < b][rlo]\n+//! - [c > d]\n+//!\n+//! [`this is <invalid syntax> twice`]: https://www.rust-lang.org\n+//! [rlo]: https://www.rust-lang.org\n+//! [c > d]: https://www.rust-lang.org\n+//!\n+// @has foo/index.html '//a[@href=\"https://www.rust-lang.org\"]' 'this is <invalid syntax> first'\n+// @has foo/index.html '//a[@href=\"https://www.rust-lang.org\"]' 'this is <invalid syntax> twice'\n+// @has foo/index.html '//a[@href=\"https://www.rust-lang.org\"]' '<invalid syntax> thrice'\n+// @has foo/index.html '//a[@href=\"https://www.rust-lang.org\"]' '<invalid syntax> four times'\n+// @has foo/index.html '//a[@href=\"https://www.rust-lang.org\"]' 'a < b'\n+// @has foo/index.html '//a[@href=\"https://www.rust-lang.org\"]' 'c > d'\n+\n+use std::any::TypeId;"}]}