{"sha": "869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OWU5NzE5ZmRkNmRkNzdlOTkxMGE2ZWIwMTJlNGJjNGE1MGY1MzU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-27T19:23:31Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-05T22:22:34Z"}, "message": "rustfmt librustc_front", "tree": {"sha": "c3f36f85dc3961db095efba4ecc7883a71e83a6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3f36f85dc3961db095efba4ecc7883a71e83a6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "html_url": "https://github.com/rust-lang/rust/commit/869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "html_url": "https://github.com/rust-lang/rust/commit/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c"}], "stats": {"total": 2380, "additions": 1262, "deletions": 1118}, "files": [{"sha": "c6108044beacea38e8112509414172d571c38193", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 433, "deletions": 392, "changes": 825, "blob_url": "https://github.com/rust-lang/rust/blob/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "patch": "@@ -29,7 +29,9 @@ pub trait MoveMap<T> {\n }\n \n impl<T> MoveMap<T> for Vec<T> {\n-    fn move_map<F>(mut self, mut f: F) -> Vec<T> where F: FnMut(T) -> T {\n+    fn move_map<F>(mut self, mut f: F) -> Vec<T>\n+        where F: FnMut(T) -> T\n+    {\n         for p in &mut self {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n@@ -41,7 +43,9 @@ impl<T> MoveMap<T> for Vec<T> {\n }\n \n impl<T> MoveMap<T> for OwnedSlice<T> {\n-    fn move_map<F>(self, f: F) -> OwnedSlice<T> where F: FnMut(T) -> T {\n+    fn move_map<F>(self, f: F) -> OwnedSlice<T>\n+        where F: FnMut(T) -> T\n+    {\n         OwnedSlice::from_vec(self.into_vec().move_map(f))\n     }\n }\n@@ -167,15 +171,15 @@ pub trait Folder : Sized {\n         noop_fold_path_parameters(p, self)\n     }\n \n-    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedParameterData)\n-                                           -> AngleBracketedParameterData\n-    {\n+    fn fold_angle_bracketed_parameter_data(&mut self,\n+                                           p: AngleBracketedParameterData)\n+                                           -> AngleBracketedParameterData {\n         noop_fold_angle_bracketed_parameter_data(p, self)\n     }\n \n-    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedParameterData)\n-                                         -> ParenthesizedParameterData\n-    {\n+    fn fold_parenthesized_parameter_data(&mut self,\n+                                         p: ParenthesizedParameterData)\n+                                         -> ParenthesizedParameterData {\n         noop_fold_parenthesized_parameter_data(p, self)\n     }\n \n@@ -247,13 +251,13 @@ pub trait Folder : Sized {\n         noop_fold_variant_arg(va, self)\n     }\n \n-    fn fold_opt_bounds(&mut self, b: Option<OwnedSlice<TyParamBound>>)\n+    fn fold_opt_bounds(&mut self,\n+                       b: Option<OwnedSlice<TyParamBound>>)\n                        -> Option<OwnedSlice<TyParamBound>> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n-    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>)\n-                       -> OwnedSlice<TyParamBound> {\n+    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>) -> OwnedSlice<TyParamBound> {\n         noop_fold_bounds(b, self)\n     }\n \n@@ -269,13 +273,11 @@ pub trait Folder : Sized {\n         noop_fold_field(field, self)\n     }\n \n-    fn fold_where_clause(&mut self, where_clause: WhereClause)\n-                         -> WhereClause {\n+    fn fold_where_clause(&mut self, where_clause: WhereClause) -> WhereClause {\n         noop_fold_where_clause(where_clause, self)\n     }\n \n-    fn fold_where_predicate(&mut self, where_predicate: WherePredicate)\n-                            -> WherePredicate {\n+    fn fold_where_predicate(&mut self, where_predicate: WherePredicate) -> WherePredicate {\n         noop_fold_where_predicate(where_predicate, self)\n     }\n \n@@ -288,51 +290,52 @@ pub trait Folder : Sized {\n     }\n }\n \n-pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T)\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>,\n+                                       fld: &mut T)\n                                        -> Vec<P<MetaItem>> {\n     meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n-    view_path.map(|Spanned {node, span}| Spanned {\n-        node: match node {\n-            ViewPathSimple(name, path) => {\n-                ViewPathSimple(name, fld.fold_path(path))\n-            }\n-            ViewPathGlob(path) => {\n-                ViewPathGlob(fld.fold_path(path))\n-            }\n-            ViewPathList(path, path_list_idents) => {\n-                ViewPathList(fld.fold_path(path),\n-                             path_list_idents.move_map(|path_list_ident| {\n-                                Spanned {\n-                                    node: match path_list_ident.node {\n-                                        PathListIdent { id, name, rename } =>\n-                                            PathListIdent {\n-                                                id: fld.new_id(id),\n-                                                name: name,\n-                                                rename: rename,\n-                                            },\n-                                        PathListMod { id, rename } =>\n-                                            PathListMod {\n-                                                id: fld.new_id(id),\n-                                                rename: rename,\n-                                            }\n-                                    },\n-                                    span: fld.new_span(path_list_ident.span)\n-                                }\n-                             }))\n-            }\n-        },\n-        span: fld.new_span(span)\n+    view_path.map(|Spanned { node, span }| {\n+        Spanned {\n+            node: match node {\n+                ViewPathSimple(name, path) => {\n+                    ViewPathSimple(name, fld.fold_path(path))\n+                }\n+                ViewPathGlob(path) => {\n+                    ViewPathGlob(fld.fold_path(path))\n+                }\n+                ViewPathList(path, path_list_idents) => {\n+                    ViewPathList(fld.fold_path(path),\n+                                 path_list_idents.move_map(|path_list_ident| {\n+                                     Spanned {\n+                                         node: match path_list_ident.node {\n+                                             PathListIdent { id, name, rename } => PathListIdent {\n+                                                 id: fld.new_id(id),\n+                                                 name: name,\n+                                                 rename: rename,\n+                                             },\n+                                             PathListMod { id, rename } => PathListMod {\n+                                                 id: fld.new_id(id),\n+                                                 rename: rename,\n+                                             },\n+                                         },\n+                                         span: fld.new_span(path_list_ident.span),\n+                                     }\n+                                 }))\n+                }\n+            },\n+            span: fld.new_span(span),\n+        }\n     })\n }\n \n pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n     attrs.into_iter().flat_map(|x| fld.fold_attribute(x)).collect()\n }\n \n-pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n+pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n     Arm {\n         attrs: fold_attrs(attrs, fld),\n         pats: pats.move_map(|x| fld.fold_pat(x)),\n@@ -342,100 +345,114 @@ pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T\n }\n \n pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n-    d.and_then(|Spanned {node, span}| match node {\n-        DeclLocal(l) => SmallVector::one(P(Spanned {\n-            node: DeclLocal(fld.fold_local(l)),\n-            span: fld.new_span(span)\n-        })),\n-        DeclItem(it) => fld.fold_item(it).into_iter().map(|i| P(Spanned {\n-            node: DeclItem(i),\n-            span: fld.new_span(span)\n-        })).collect()\n+    d.and_then(|Spanned { node, span }| {\n+        match node {\n+            DeclLocal(l) => SmallVector::one(P(Spanned {\n+                node: DeclLocal(fld.fold_local(l)),\n+                span: fld.new_span(span),\n+            })),\n+            DeclItem(it) => fld.fold_item(it)\n+                               .into_iter()\n+                               .map(|i| {\n+                                   P(Spanned {\n+                                       node: DeclItem(i),\n+                                       span: fld.new_span(span),\n+                                   })\n+                               })\n+                               .collect(),\n+        }\n     })\n }\n \n pub fn noop_fold_ty_binding<T: Folder>(b: P<TypeBinding>, fld: &mut T) -> P<TypeBinding> {\n-    b.map(|TypeBinding { id, name, ty, span }| TypeBinding {\n-        id: fld.new_id(id),\n-        name: name,\n-        ty: fld.fold_ty(ty),\n-        span: fld.new_span(span),\n+    b.map(|TypeBinding { id, name, ty, span }| {\n+        TypeBinding {\n+            id: fld.new_id(id),\n+            name: name,\n+            ty: fld.fold_ty(ty),\n+            span: fld.new_span(span),\n+        }\n     })\n }\n \n pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n-    t.map(|Ty {id, node, span}| Ty {\n-        id: fld.new_id(id),\n-        node: match node {\n-            TyInfer => node,\n-            TyVec(ty) => TyVec(fld.fold_ty(ty)),\n-            TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n-            TyRptr(region, mt) => {\n-                TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n-            }\n-            TyBareFn(f) => {\n-                TyBareFn(f.map(|BareFnTy {lifetimes, unsafety, abi, decl}| BareFnTy {\n-                    lifetimes: fld.fold_lifetime_defs(lifetimes),\n-                    unsafety: unsafety,\n-                    abi: abi,\n-                    decl: fld.fold_fn_decl(decl)\n-                }))\n-            }\n-            TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n-            TyParen(ty) => TyParen(fld.fold_ty(ty)),\n-            TyPath(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n-                    QSelf {\n-                        ty: fld.fold_ty(ty),\n-                        position: position\n-                    }\n-                });\n-                TyPath(qself, fld.fold_path(path))\n-            }\n-            TyObjectSum(ty, bounds) => {\n-                TyObjectSum(fld.fold_ty(ty),\n-                            fld.fold_bounds(bounds))\n-            }\n-            TyFixedLengthVec(ty, e) => {\n-                TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n-            }\n-            TyTypeof(expr) => {\n-                TyTypeof(fld.fold_expr(expr))\n-            }\n-            TyPolyTraitRef(bounds) => {\n-                TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-            }\n-        },\n-        span: fld.new_span(span)\n+    t.map(|Ty { id, node, span }| {\n+        Ty {\n+            id: fld.new_id(id),\n+            node: match node {\n+                TyInfer => node,\n+                TyVec(ty) => TyVec(fld.fold_ty(ty)),\n+                TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n+                TyRptr(region, mt) => {\n+                    TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n+                }\n+                TyBareFn(f) => {\n+                    TyBareFn(f.map(|BareFnTy { lifetimes, unsafety, abi, decl }| {\n+                        BareFnTy {\n+                            lifetimes: fld.fold_lifetime_defs(lifetimes),\n+                            unsafety: unsafety,\n+                            abi: abi,\n+                            decl: fld.fold_fn_decl(decl),\n+                        }\n+                    }))\n+                }\n+                TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n+                TyParen(ty) => TyParen(fld.fold_ty(ty)),\n+                TyPath(qself, path) => {\n+                    let qself = qself.map(|QSelf { ty, position }| {\n+                        QSelf {\n+                            ty: fld.fold_ty(ty),\n+                            position: position,\n+                        }\n+                    });\n+                    TyPath(qself, fld.fold_path(path))\n+                }\n+                TyObjectSum(ty, bounds) => {\n+                    TyObjectSum(fld.fold_ty(ty), fld.fold_bounds(bounds))\n+                }\n+                TyFixedLengthVec(ty, e) => {\n+                    TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n+                }\n+                TyTypeof(expr) => {\n+                    TyTypeof(fld.fold_expr(expr))\n+                }\n+                TyPolyTraitRef(bounds) => {\n+                    TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+                }\n+            },\n+            span: fld.new_span(span),\n+        }\n     })\n }\n \n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n-                                        fld: &mut T) -> ForeignMod {\n+pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod { abi, items }: ForeignMod,\n+                                        fld: &mut T)\n+                                        -> ForeignMod {\n     ForeignMod {\n         abi: abi,\n         items: items.move_map(|x| fld.fold_foreign_item(x)),\n     }\n }\n \n pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n-    v.map(|Spanned {node: Variant_ {id, name, attrs, kind, disr_expr}, span}| Spanned {\n-        node: Variant_ {\n-            id: fld.new_id(id),\n-            name: name,\n-            attrs: fold_attrs(attrs, fld),\n-            kind: match kind {\n-                TupleVariantKind(variant_args) => {\n-                    TupleVariantKind(variant_args.move_map(|x|\n-                        fld.fold_variant_arg(x)))\n-                }\n-                StructVariantKind(struct_def) => {\n-                    StructVariantKind(fld.fold_struct_def(struct_def))\n-                }\n+    v.map(|Spanned { node: Variant_ { id, name, attrs, kind, disr_expr }, span }| {\n+        Spanned {\n+            node: Variant_ {\n+                id: fld.new_id(id),\n+                name: name,\n+                attrs: fold_attrs(attrs, fld),\n+                kind: match kind {\n+                    TupleVariantKind(variant_args) => {\n+                        TupleVariantKind(variant_args.move_map(|x| fld.fold_variant_arg(x)))\n+                    }\n+                    StructVariantKind(struct_def) => {\n+                        StructVariantKind(fld.fold_struct_def(struct_def))\n+                    }\n+                },\n+                disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n             },\n-            disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n-        },\n-        span: fld.new_span(span),\n+            span: fld.new_span(span),\n+        }\n     })\n }\n \n@@ -451,20 +468,22 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n     i\n }\n \n-pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut T) -> Path {\n+pub fn noop_fold_path<T: Folder>(Path { global, segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n         global: global,\n-        segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n-            identifier: fld.fold_ident(identifier),\n-            parameters: fld.fold_path_parameters(parameters),\n+        segments: segments.move_map(|PathSegment { identifier, parameters }| {\n+            PathSegment {\n+                identifier: fld.fold_ident(identifier),\n+                parameters: fld.fold_path_parameters(parameters),\n+            }\n         }),\n-        span: fld.new_span(span)\n+        span: fld.new_span(span),\n     }\n }\n \n-pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld: &mut T)\n-                                            -> PathParameters\n-{\n+pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters,\n+                                            fld: &mut T)\n+                                            -> PathParameters {\n     match path_parameters {\n         AngleBracketedParameters(data) =>\n             AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n@@ -475,31 +494,35 @@ pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld\n \n pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n                                                            fld: &mut T)\n-                                                           -> AngleBracketedParameterData\n-{\n+                                                           -> AngleBracketedParameterData {\n     let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n-    AngleBracketedParameterData { lifetimes: fld.fold_lifetimes(lifetimes),\n-                                  types: types.move_map(|ty| fld.fold_ty(ty)),\n-                                  bindings: bindings.move_map(|b| fld.fold_ty_binding(b)) }\n+    AngleBracketedParameterData {\n+        lifetimes: fld.fold_lifetimes(lifetimes),\n+        types: types.move_map(|ty| fld.fold_ty(ty)),\n+        bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n+    }\n }\n \n pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n                                                          fld: &mut T)\n-                                                         -> ParenthesizedParameterData\n-{\n+                                                         -> ParenthesizedParameterData {\n     let ParenthesizedParameterData { inputs, output, span } = data;\n-    ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-                                 output: output.map(|ty| fld.fold_ty(ty)),\n-                                 span: fld.new_span(span) }\n+    ParenthesizedParameterData {\n+        inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n+        output: output.map(|ty| fld.fold_ty(ty)),\n+        span: fld.new_span(span),\n+    }\n }\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local {id, pat, ty, init, span}| Local {\n-        id: fld.new_id(id),\n-        ty: ty.map(|t| fld.fold_ty(t)),\n-        pat: fld.fold_pat(pat),\n-        init: init.map(|e| fld.fold_expr(e)),\n-        span: fld.new_span(span)\n+    l.map(|Local { id, pat, ty, init, span }| {\n+        Local {\n+            id: fld.new_id(id),\n+            ty: ty.map(|t| fld.fold_ty(t)),\n+            pat: fld.fold_pat(pat),\n+            init: init.map(|e| fld.fold_expr(e)),\n+            span: fld.new_span(span),\n+        }\n     })\n }\n \n@@ -510,13 +533,14 @@ pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attr\n             id: id,\n             style: style,\n             value: fld.fold_meta_item(value),\n-            is_sugared_doc: is_sugared_doc\n+            is_sugared_doc: is_sugared_doc,\n         },\n-        span: fld.new_span(span)\n+        span: fld.new_span(span),\n     })\n }\n \n-pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mut T)\n+pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_,\n+                                                     fld: &mut T)\n                                                      -> ExplicitSelf_ {\n     match es {\n         SelfStatic | SelfValue(_) => es,\n@@ -529,50 +553,55 @@ pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mu\n     }\n }\n \n-pub fn noop_fold_explicit_self<T: Folder>(Spanned {span, node}: ExplicitSelf, fld: &mut T)\n+pub fn noop_fold_explicit_self<T: Folder>(Spanned { span, node }: ExplicitSelf,\n+                                          fld: &mut T)\n                                           -> ExplicitSelf {\n     Spanned {\n         node: fld.fold_explicit_self_underscore(node),\n-        span: fld.new_span(span)\n+        span: fld.new_span(span),\n     }\n }\n \n pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n-    mi.map(|Spanned {node, span}| Spanned {\n-        node: match node {\n-            MetaWord(id) => MetaWord(id),\n-            MetaList(id, mis) => {\n-                MetaList(id, mis.move_map(|e| fld.fold_meta_item(e)))\n-            }\n-            MetaNameValue(id, s) => MetaNameValue(id, s)\n-        },\n-        span: fld.new_span(span)\n+    mi.map(|Spanned { node, span }| {\n+        Spanned {\n+            node: match node {\n+                MetaWord(id) => MetaWord(id),\n+                MetaList(id, mis) => {\n+                    MetaList(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+                }\n+                MetaNameValue(id, s) => MetaNameValue(id, s),\n+            },\n+            span: fld.new_span(span),\n+        }\n     })\n }\n \n-pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n+pub fn noop_fold_arg<T: Folder>(Arg { id, pat, ty }: Arg, fld: &mut T) -> Arg {\n     Arg {\n         id: fld.new_id(id),\n         pat: fld.fold_pat(pat),\n-        ty: fld.fold_ty(ty)\n+        ty: fld.fold_ty(ty),\n     }\n }\n \n pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n-    decl.map(|FnDecl {inputs, output, variadic}| FnDecl {\n-        inputs: inputs.move_map(|x| fld.fold_arg(x)),\n-        output: match output {\n-            Return(ty) => Return(fld.fold_ty(ty)),\n-            DefaultReturn(span) => DefaultReturn(span),\n-            NoReturn(span) => NoReturn(span)\n-        },\n-        variadic: variadic\n+    decl.map(|FnDecl { inputs, output, variadic }| {\n+        FnDecl {\n+            inputs: inputs.move_map(|x| fld.fold_arg(x)),\n+            output: match output {\n+                Return(ty) => Return(fld.fold_ty(ty)),\n+                DefaultReturn(span) => DefaultReturn(span),\n+                NoReturn(span) => NoReturn(span),\n+            },\n+            variadic: variadic,\n+        }\n     })\n }\n \n-pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n-                                   -> TyParamBound\n-                                   where T: Folder {\n+pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T) -> TyParamBound\n+    where T: Folder\n+{\n     match tpb {\n         TraitTyParamBound(ty, modifier) => TraitTyParamBound(fld.fold_poly_trait_ref(ty), modifier),\n         RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n@@ -586,11 +615,12 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n         name: name,\n         bounds: fld.fold_bounds(bounds),\n         default: default.map(|x| fld.fold_ty(x)),\n-        span: span\n+        span: span,\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>, fld: &mut T)\n+pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>,\n+                                      fld: &mut T)\n                                       -> OwnedSlice<TyParam> {\n     tps.move_map(|tp| fld.fold_ty_param(tp))\n }\n@@ -599,12 +629,11 @@ pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n         name: l.name,\n-        span: fld.new_span(l.span)\n+        span: fld.new_span(l.span),\n     }\n }\n \n-pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T)\n-                                         -> LifetimeDef {\n+pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T) -> LifetimeDef {\n     LifetimeDef {\n         lifetime: fld.fold_lifetime(l.lifetime),\n         bounds: fld.fold_lifetimes(l.bounds),\n@@ -615,41 +644,34 @@ pub fn noop_fold_lifetimes<T: Folder>(lts: Vec<Lifetime>, fld: &mut T) -> Vec<Li\n     lts.move_map(|l| fld.fold_lifetime(l))\n }\n \n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T)\n-                                          -> Vec<LifetimeDef> {\n+pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T) -> Vec<LifetimeDef> {\n     lts.move_map(|l| fld.fold_lifetime_def(l))\n }\n \n-pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T)\n-                                         -> Option<Lifetime> {\n+pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T) -> Option<Lifetime> {\n     o_lt.map(|lt| fld.fold_lifetime(lt))\n }\n \n-pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause}: Generics,\n-                                     fld: &mut T) -> Generics {\n+pub fn noop_fold_generics<T: Folder>(Generics { ty_params, lifetimes, where_clause }: Generics,\n+                                     fld: &mut T)\n+                                     -> Generics {\n     Generics {\n         ty_params: fld.fold_ty_params(ty_params),\n         lifetimes: fld.fold_lifetime_defs(lifetimes),\n         where_clause: fld.fold_where_clause(where_clause),\n     }\n }\n \n-pub fn noop_fold_where_clause<T: Folder>(\n-                              WhereClause {id, predicates}: WhereClause,\n-                              fld: &mut T)\n-                              -> WhereClause {\n+pub fn noop_fold_where_clause<T: Folder>(WhereClause { id, predicates }: WhereClause,\n+                                         fld: &mut T)\n+                                         -> WhereClause {\n     WhereClause {\n         id: fld.new_id(id),\n-        predicates: predicates.move_map(|predicate| {\n-            fld.fold_where_predicate(predicate)\n-        })\n+        predicates: predicates.move_map(|predicate| fld.fold_where_predicate(predicate)),\n     }\n }\n \n-pub fn noop_fold_where_predicate<T: Folder>(\n-                                 pred: WherePredicate,\n-                                 fld: &mut T)\n-                                 -> WherePredicate {\n+pub fn noop_fold_where_predicate<T: Folder>(pred: WherePredicate, fld: &mut T) -> WherePredicate {\n     match pred {\n         hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{bound_lifetimes,\n                                                                      bounded_ty,\n@@ -659,7 +681,7 @@ pub fn noop_fold_where_predicate<T: Folder>(\n                 bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n                 bounded_ty: fld.fold_ty(bounded_ty),\n                 bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n-                span: fld.new_span(span)\n+                span: fld.new_span(span),\n             })\n         }\n         hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{lifetime,\n@@ -668,27 +690,29 @@ pub fn noop_fold_where_predicate<T: Folder>(\n             hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                 span: fld.new_span(span),\n                 lifetime: fld.fold_lifetime(lifetime),\n-                bounds: bounds.move_map(|bound| fld.fold_lifetime(bound))\n+                bounds: bounds.move_map(|bound| fld.fold_lifetime(bound)),\n             })\n         }\n         hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{id,\n                                                                path,\n                                                                ty,\n                                                                span}) => {\n-            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{\n+            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                 id: fld.new_id(id),\n                 path: fld.fold_path(path),\n-                ty:fld.fold_ty(ty),\n-                span: fld.new_span(span)\n+                ty: fld.fold_ty(ty),\n+                span: fld.new_span(span),\n             })\n         }\n     }\n }\n \n pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n-    struct_def.map(|StructDef { fields, ctor_id }| StructDef {\n-        fields: fields.move_map(|f| fld.fold_struct_field(f)),\n-        ctor_id: ctor_id.map(|cid| fld.new_id(cid)),\n+    struct_def.map(|StructDef { fields, ctor_id }| {\n+        StructDef {\n+            fields: fields.move_map(|f| fld.fold_struct_field(f)),\n+            ctor_id: ctor_id.map(|cid| fld.new_id(cid)),\n+        }\n     })\n }\n \n@@ -721,50 +745,54 @@ pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructF\n             ty: fld.fold_ty(ty),\n             attrs: fold_attrs(attrs, fld),\n         },\n-        span: fld.new_span(span)\n+        span: fld.new_span(span),\n     }\n }\n \n-pub fn noop_fold_field<T: Folder>(Field {name, expr, span}: Field, folder: &mut T) -> Field {\n+pub fn noop_fold_field<T: Folder>(Field { name, expr, span }: Field, folder: &mut T) -> Field {\n     Field {\n-        name: respan(folder.new_span(name.span), folder.fold_name(name.node)),\n+        name: respan(folder.new_span(name.span),\n+                     folder.fold_name(name.node)),\n         expr: folder.fold_expr(expr),\n-        span: folder.new_span(span)\n+        span: folder.new_span(span),\n     }\n }\n \n-pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutTy {\n+pub fn noop_fold_mt<T: Folder>(MutTy { ty, mutbl }: MutTy, folder: &mut T) -> MutTy {\n     MutTy {\n         ty: folder.fold_ty(ty),\n         mutbl: mutbl,\n     }\n }\n \n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>,\n+                                       folder: &mut T)\n                                        -> Option<OwnedSlice<TyParamBound>> {\n     b.map(|bounds| folder.fold_bounds(bounds))\n }\n \n-fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n-                          -> TyParamBounds {\n+fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T) -> TyParamBounds {\n     bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n }\n \n-fn noop_fold_variant_arg<T: Folder>(VariantArg {id, ty}: VariantArg, folder: &mut T)\n+fn noop_fold_variant_arg<T: Folder>(VariantArg { id, ty }: VariantArg,\n+                                    folder: &mut T)\n                                     -> VariantArg {\n     VariantArg {\n         id: folder.new_id(id),\n-        ty: folder.fold_ty(ty)\n+        ty: folder.fold_ty(ty),\n     }\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block {id, stmts, expr, rules, span}| Block {\n-        id: folder.new_id(id),\n-        stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n-        expr: expr.map(|x| folder.fold_expr(x)),\n-        rules: rules,\n-        span: folder.new_span(span),\n+    b.map(|Block { id, stmts, expr, rules, span }| {\n+        Block {\n+            id: folder.new_id(id),\n+            stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n+            expr: expr.map(|x| folder.fold_expr(x)),\n+            rules: rules,\n+            span: folder.new_span(span),\n+        }\n     })\n }\n \n@@ -781,38 +809,38 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n         }\n         ItemFn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemFn(\n-                folder.fold_fn_decl(decl),\n-                unsafety,\n-                constness,\n-                abi,\n-                folder.fold_generics(generics),\n-                folder.fold_block(body)\n-            )\n+            ItemFn(folder.fold_fn_decl(decl),\n+                   unsafety,\n+                   constness,\n+                   abi,\n+                   folder.fold_generics(generics),\n+                   folder.fold_block(body))\n         }\n         ItemMod(m) => ItemMod(folder.fold_mod(m)),\n         ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n         ItemTy(t, generics) => {\n             ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n         ItemEnum(enum_definition, generics) => {\n-            ItemEnum(\n-                hir::EnumDef {\n-                    variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n-                },\n-                folder.fold_generics(generics))\n+            ItemEnum(hir::EnumDef {\n+                         variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n+                     },\n+                     folder.fold_generics(generics))\n         }\n         ItemStruct(struct_def, generics) => {\n             let struct_def = folder.fold_struct_def(struct_def);\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n         ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n+            ItemDefaultImpl(unsafety,\n+                            folder.fold_trait_ref((*trait_ref).clone()))\n         }\n         ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items.into_iter().flat_map(|item| {\n-                folder.fold_impl_item(item).into_iter()\n-            }).collect();\n+            let new_impl_items = impl_items.into_iter()\n+                                           .flat_map(|item| {\n+                                               folder.fold_impl_item(item).into_iter()\n+                                           })\n+                                           .collect();\n             let ifce = match ifce {\n                 None => None,\n                 Some(ref trait_ref) => {\n@@ -828,81 +856,84 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n         }\n         ItemTrait(unsafety, generics, bounds, items) => {\n             let bounds = folder.fold_bounds(bounds);\n-            let items = items.into_iter().flat_map(|item| {\n-                folder.fold_trait_item(item).into_iter()\n-            }).collect();\n-            ItemTrait(unsafety,\n-                      folder.fold_generics(generics),\n-                      bounds,\n-                      items)\n+            let items = items.into_iter()\n+                             .flat_map(|item| folder.fold_trait_item(item).into_iter())\n+                             .collect();\n+            ItemTrait(unsafety, folder.fold_generics(generics), bounds, items)\n         }\n     }\n }\n \n-pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n+pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>,\n+                                       folder: &mut T)\n                                        -> SmallVector<P<TraitItem>> {\n-    SmallVector::one(i.map(|TraitItem {id, name, attrs, node, span}| TraitItem {\n-        id: folder.new_id(id),\n-        name: folder.fold_name(name),\n-        attrs: fold_attrs(attrs, folder),\n-        node: match node {\n-            ConstTraitItem(ty, default) => {\n-                ConstTraitItem(folder.fold_ty(ty),\n-                               default.map(|x| folder.fold_expr(x)))\n-            }\n-            MethodTraitItem(sig, body) => {\n-                MethodTraitItem(noop_fold_method_sig(sig, folder),\n-                                body.map(|x| folder.fold_block(x)))\n-            }\n-            TypeTraitItem(bounds, default) => {\n-                TypeTraitItem(folder.fold_bounds(bounds),\n-                              default.map(|x| folder.fold_ty(x)))\n-            }\n-        },\n-        span: folder.new_span(span)\n+    SmallVector::one(i.map(|TraitItem { id, name, attrs, node, span }| {\n+        TraitItem {\n+            id: folder.new_id(id),\n+            name: folder.fold_name(name),\n+            attrs: fold_attrs(attrs, folder),\n+            node: match node {\n+                ConstTraitItem(ty, default) => {\n+                    ConstTraitItem(folder.fold_ty(ty),\n+                                   default.map(|x| folder.fold_expr(x)))\n+                }\n+                MethodTraitItem(sig, body) => {\n+                    MethodTraitItem(noop_fold_method_sig(sig, folder),\n+                                    body.map(|x| folder.fold_block(x)))\n+                }\n+                TypeTraitItem(bounds, default) => {\n+                    TypeTraitItem(folder.fold_bounds(bounds),\n+                                  default.map(|x| folder.fold_ty(x)))\n+                }\n+            },\n+            span: folder.new_span(span),\n+        }\n     }))\n }\n \n-pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n-                                      -> SmallVector<P<ImplItem>> {\n-    SmallVector::one(i.map(|ImplItem {id, name, attrs, node, vis, span}| ImplItem {\n-        id: folder.new_id(id),\n-        name: folder.fold_name(name),\n-        attrs: fold_attrs(attrs, folder),\n-        vis: vis,\n-        node: match node  {\n-            ConstImplItem(ty, expr) => {\n-                ConstImplItem(folder.fold_ty(ty), folder.fold_expr(expr))\n-            }\n-            MethodImplItem(sig, body) => {\n-                MethodImplItem(noop_fold_method_sig(sig, folder),\n-                               folder.fold_block(body))\n-            }\n-            TypeImplItem(ty) => TypeImplItem(folder.fold_ty(ty)),\n-        },\n-        span: folder.new_span(span)\n+pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> SmallVector<P<ImplItem>> {\n+    SmallVector::one(i.map(|ImplItem { id, name, attrs, node, vis, span }| {\n+        ImplItem {\n+            id: folder.new_id(id),\n+            name: folder.fold_name(name),\n+            attrs: fold_attrs(attrs, folder),\n+            vis: vis,\n+            node: match node {\n+                ConstImplItem(ty, expr) => {\n+                    ConstImplItem(folder.fold_ty(ty), folder.fold_expr(expr))\n+                }\n+                MethodImplItem(sig, body) => {\n+                    MethodImplItem(noop_fold_method_sig(sig, folder),\n+                                   folder.fold_block(body))\n+                }\n+                TypeImplItem(ty) => TypeImplItem(folder.fold_ty(ty)),\n+            },\n+            span: folder.new_span(span),\n+        }\n     }))\n }\n \n-pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n+pub fn noop_fold_mod<T: Folder>(Mod { inner, items }: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n         items: items.into_iter().flat_map(|x| folder.fold_item(x).into_iter()).collect(),\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, span, exported_macros}: Crate,\n-                                  folder: &mut T) -> Crate {\n+pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span, exported_macros }: Crate,\n+                                  folder: &mut T)\n+                                  -> Crate {\n     let config = folder.fold_meta_items(config);\n \n     let mut items = folder.fold_item(P(hir::Item {\n-        name: token::special_idents::invalid.name,\n-        attrs: attrs,\n-        id: DUMMY_NODE_ID,\n-        vis: hir::Public,\n-        span: span,\n-        node: hir::ItemMod(module),\n-    })).into_iter();\n+                              name: token::special_idents::invalid.name,\n+                              attrs: attrs,\n+                              id: DUMMY_NODE_ID,\n+                              vis: hir::Public,\n+                              span: span,\n+                              node: hir::ItemMod(module),\n+                          }))\n+                          .into_iter();\n \n     let (module, attrs, span) = match items.next() {\n         Some(item) => {\n@@ -918,7 +949,9 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, span, exported_m\n         None => (hir::Mod {\n             inner: span,\n             items: vec![],\n-        }, vec![], span)\n+        },\n+                 vec![],\n+                 span),\n     };\n \n     Crate {\n@@ -936,8 +969,9 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n }\n \n // fold one item into exactly one item\n-pub fn noop_fold_item_simple<T: Folder>(Item {id, name, attrs, node, vis, span}: Item,\n-                                        folder: &mut T) -> Item {\n+pub fn noop_fold_item_simple<T: Folder>(Item { id, name, attrs, node, vis, span }: Item,\n+                                        folder: &mut T)\n+                                        -> Item {\n     let id = folder.new_id(id);\n     let node = folder.fold_item_underscore(node);\n     // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n@@ -955,25 +989,28 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, name, attrs, node, vis, span}:\n         attrs: fold_attrs(attrs, folder),\n         node: node,\n         vis: vis,\n-        span: folder.new_span(span)\n+        span: folder.new_span(span),\n     }\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n-    ni.map(|ForeignItem {id, name, attrs, node, span, vis}| ForeignItem {\n-        id: folder.new_id(id),\n-        name: folder.fold_name(name),\n-        attrs: fold_attrs(attrs, folder),\n-        node: match node {\n-            ForeignItemFn(fdec, generics) => {\n-                ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n-            }\n-            ForeignItemStatic(t, m) => {\n-                ForeignItemStatic(folder.fold_ty(t), m)\n-            }\n-        },\n-        vis: vis,\n-        span: folder.new_span(span)\n+    ni.map(|ForeignItem { id, name, attrs, node, span, vis }| {\n+        ForeignItem {\n+            id: folder.new_id(id),\n+            name: folder.fold_name(name),\n+            attrs: fold_attrs(attrs, folder),\n+            node: match node {\n+                ForeignItemFn(fdec, generics) => {\n+                    ForeignItemFn(folder.fold_fn_decl(fdec),\n+                                  folder.fold_generics(generics))\n+                }\n+                ForeignItemStatic(t, m) => {\n+                    ForeignItemStatic(folder.fold_ty(t), m)\n+                }\n+            },\n+            vis: vis,\n+            span: folder.new_span(span),\n+        }\n     })\n }\n \n@@ -984,59 +1021,65 @@ pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> Method\n         explicit_self: folder.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n-        decl: folder.fold_fn_decl(sig.decl)\n+        decl: folder.fold_fn_decl(sig.decl),\n     }\n }\n \n pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n-    p.map(|Pat {id, node, span}| Pat {\n-        id: folder.new_id(id),\n-        node: match node {\n-            PatWild(k) => PatWild(k),\n-            PatIdent(binding_mode, pth1, sub) => {\n-                PatIdent(binding_mode,\n-                        Spanned{span: folder.new_span(pth1.span),\n-                                node: folder.fold_ident(pth1.node)},\n-                        sub.map(|x| folder.fold_pat(x)))\n-            }\n-            PatLit(e) => PatLit(folder.fold_expr(e)),\n-            PatEnum(pth, pats) => {\n-                PatEnum(folder.fold_path(pth),\n-                        pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n-            }\n-            PatQPath(qself, pth) => {\n-                let qself = QSelf {ty: folder.fold_ty(qself.ty), .. qself};\n-                PatQPath(qself, folder.fold_path(pth))\n-            }\n-            PatStruct(pth, fields, etc) => {\n-                let pth = folder.fold_path(pth);\n-                let fs = fields.move_map(|f| {\n-                    Spanned { span: folder.new_span(f.span),\n-                              node: hir::FieldPat {\n-                                  name: f.node.name,\n-                                  pat: folder.fold_pat(f.node.pat),\n-                                  is_shorthand: f.node.is_shorthand,\n-                              }}\n-                });\n-                PatStruct(pth, fs, etc)\n-            }\n-            PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n-            PatBox(inner) => PatBox(folder.fold_pat(inner)),\n-            PatRegion(inner, mutbl) => PatRegion(folder.fold_pat(inner), mutbl),\n-            PatRange(e1, e2) => {\n-                PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+    p.map(|Pat { id, node, span }| {\n+        Pat {\n+            id: folder.new_id(id),\n+            node: match node {\n+                PatWild(k) => PatWild(k),\n+                PatIdent(binding_mode, pth1, sub) => {\n+                    PatIdent(binding_mode,\n+                             Spanned {\n+                                 span: folder.new_span(pth1.span),\n+                                 node: folder.fold_ident(pth1.node),\n+                             },\n+                             sub.map(|x| folder.fold_pat(x)))\n+                }\n+                PatLit(e) => PatLit(folder.fold_expr(e)),\n+                PatEnum(pth, pats) => {\n+                    PatEnum(folder.fold_path(pth),\n+                            pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n+                }\n+                PatQPath(qself, pth) => {\n+                    let qself = QSelf { ty: folder.fold_ty(qself.ty), ..qself };\n+                    PatQPath(qself, folder.fold_path(pth))\n+                }\n+                PatStruct(pth, fields, etc) => {\n+                    let pth = folder.fold_path(pth);\n+                    let fs = fields.move_map(|f| {\n+                        Spanned {\n+                            span: folder.new_span(f.span),\n+                            node: hir::FieldPat {\n+                                name: f.node.name,\n+                                pat: folder.fold_pat(f.node.pat),\n+                                is_shorthand: f.node.is_shorthand,\n+                            },\n+                        }\n+                    });\n+                    PatStruct(pth, fs, etc)\n+                }\n+                PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n+                PatBox(inner) => PatBox(folder.fold_pat(inner)),\n+                PatRegion(inner, mutbl) => PatRegion(folder.fold_pat(inner), mutbl),\n+                PatRange(e1, e2) => {\n+                    PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+                }\n+                PatVec(before, slice, after) => {\n+                    PatVec(before.move_map(|x| folder.fold_pat(x)),\n+                           slice.map(|x| folder.fold_pat(x)),\n+                           after.move_map(|x| folder.fold_pat(x)))\n+                }\n             },\n-            PatVec(before, slice, after) => {\n-                PatVec(before.move_map(|x| folder.fold_pat(x)),\n-                       slice.map(|x| folder.fold_pat(x)),\n-                       after.move_map(|x| folder.fold_pat(x)))\n-            }\n-        },\n-        span: folder.new_span(span)\n+            span: folder.new_span(span),\n+        }\n     })\n }\n \n-pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) -> Expr {\n+pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T) -> Expr {\n     Expr {\n         id: folder.new_id(id),\n         node: match node {\n@@ -1055,15 +1098,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                          args.move_map(|x| folder.fold_expr(x)))\n             }\n             ExprMethodCall(name, tps, args) => {\n-                ExprMethodCall(\n-                    respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-                    tps.move_map(|x| folder.fold_ty(x)),\n-                    args.move_map(|x| folder.fold_expr(x)))\n+                ExprMethodCall(respan(folder.new_span(name.span),\n+                                      folder.fold_name(name.node)),\n+                               tps.move_map(|x| folder.fold_ty(x)),\n+                               args.move_map(|x| folder.fold_expr(x)))\n             }\n             ExprBinary(binop, lhs, rhs) => {\n-                ExprBinary(binop,\n-                        folder.fold_expr(lhs),\n-                        folder.fold_expr(rhs))\n+                ExprBinary(binop, folder.fold_expr(lhs), folder.fold_expr(rhs))\n             }\n             ExprUnary(binop, ohs) => {\n                 ExprUnary(binop, folder.fold_expr(ohs))\n@@ -1085,12 +1126,12 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             }\n             ExprLoop(body, opt_ident) => {\n                 ExprLoop(folder.fold_block(body),\n-                        opt_ident.map(|i| folder.fold_ident(i)))\n+                         opt_ident.map(|i| folder.fold_ident(i)))\n             }\n             ExprMatch(expr, arms, source) => {\n                 ExprMatch(folder.fold_expr(expr),\n-                        arms.move_map(|x| folder.fold_arm(x)),\n-                        source)\n+                          arms.move_map(|x| folder.fold_arm(x)),\n+                          source)\n             }\n             ExprClosure(capture_clause, decl, body) => {\n                 ExprClosure(capture_clause,\n@@ -1102,9 +1143,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n             }\n             ExprAssignOp(op, el, er) => {\n-                ExprAssignOp(op,\n-                            folder.fold_expr(el),\n-                            folder.fold_expr(er))\n+                ExprAssignOp(op, folder.fold_expr(el), folder.fold_expr(er))\n             }\n             ExprField(el, name) => {\n                 ExprField(folder.fold_expr(el),\n@@ -1127,19 +1166,19 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 let qself = qself.map(|QSelf { ty, position }| {\n                     QSelf {\n                         ty: folder.fold_ty(ty),\n-                        position: position\n+                        position: position,\n                     }\n                 });\n                 ExprPath(qself, folder.fold_path(path))\n             }\n-            ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|label|\n+            ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|label| {\n                 respan(folder.new_span(label.span),\n-                       folder.fold_ident(label.node)))\n-            ),\n-            ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|label|\n+                       folder.fold_ident(label.node))\n+            })),\n+            ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|label| {\n                 respan(folder.new_span(label.span),\n-                       folder.fold_ident(label.node)))\n-            ),\n+                       folder.fold_ident(label.node))\n+            })),\n             ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n             ExprInlineAsm(InlineAsm {\n                 inputs,\n@@ -1152,12 +1191,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 dialect,\n                 expn_id,\n             }) => ExprInlineAsm(InlineAsm {\n-                inputs: inputs.move_map(|(c, input)| {\n-                    (c, folder.fold_expr(input))\n-                }),\n-                outputs: outputs.move_map(|(c, out, is_rw)| {\n-                    (c, folder.fold_expr(out), is_rw)\n-                }),\n+                inputs: inputs.move_map(|(c, input)| (c, folder.fold_expr(input))),\n+                outputs: outputs.move_map(|(c, out, is_rw)| (c, folder.fold_expr(out), is_rw)),\n                 asm: asm,\n                 asm_str_style: asm_str_style,\n                 clobbers: clobbers,\n@@ -1168,37 +1203,43 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             }),\n             ExprStruct(path, fields, maybe_expr) => {\n                 ExprStruct(folder.fold_path(path),\n-                        fields.move_map(|x| folder.fold_field(x)),\n-                        maybe_expr.map(|x| folder.fold_expr(x)))\n-            },\n+                           fields.move_map(|x| folder.fold_field(x)),\n+                           maybe_expr.map(|x| folder.fold_expr(x)))\n+            }\n         },\n-        span: folder.new_span(span)\n+        span: folder.new_span(span),\n     }\n }\n \n-pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n+pub fn noop_fold_stmt<T: Folder>(Spanned { node, span }: Stmt,\n+                                 folder: &mut T)\n                                  -> SmallVector<P<Stmt>> {\n     let span = folder.new_span(span);\n     match node {\n         StmtDecl(d, id) => {\n             let id = folder.new_id(id);\n-            folder.fold_decl(d).into_iter().map(|d| P(Spanned {\n-                node: StmtDecl(d, id),\n-                span: span\n-            })).collect()\n+            folder.fold_decl(d)\n+                  .into_iter()\n+                  .map(|d| {\n+                      P(Spanned {\n+                          node: StmtDecl(d, id),\n+                          span: span,\n+                      })\n+                  })\n+                  .collect()\n         }\n         StmtExpr(e, id) => {\n             let id = folder.new_id(id);\n             SmallVector::one(P(Spanned {\n                 node: StmtExpr(folder.fold_expr(e), id),\n-                span: span\n+                span: span,\n             }))\n         }\n         StmtSemi(e, id) => {\n             let id = folder.new_id(id);\n             SmallVector::one(P(Spanned {\n                 node: StmtSemi(folder.fold_expr(e), id),\n-                span: span\n+                span: span,\n             }))\n         }\n     }"}, {"sha": "a89bc26ec09082c86cb53bf92d0fcd0e284ea653", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "patch": "@@ -56,20 +56,23 @@ use serialize::{Encodable, Encoder, Decoder};\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n-    pub name: Name\n+    pub name: Name,\n }\n \n impl fmt::Debug for Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n+        write!(f,\n+               \"lifetime({}: {})\",\n+               self.id,\n+               pprust::lifetime_to_string(self))\n     }\n }\n \n /// A lifetime definition, eg `'a: 'b+'c+'d`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>\n+    pub bounds: Vec<Lifetime>,\n }\n \n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n@@ -161,7 +164,8 @@ impl PathParameters {\n                 data.types.iter().collect()\n             }\n             ParenthesizedParameters(ref data) => {\n-                data.inputs.iter()\n+                data.inputs\n+                    .iter()\n                     .chain(data.output.iter())\n                     .collect()\n             }\n@@ -229,7 +233,7 @@ pub struct ParenthesizedParameterData {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TyParamBound {\n     TraitTyParamBound(PolyTraitRef, TraitBoundModifier),\n-    RegionTyParamBound(Lifetime)\n+    RegionTyParamBound(Lifetime),\n }\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n@@ -248,7 +252,7 @@ pub struct TyParam {\n     pub id: NodeId,\n     pub bounds: TyParamBounds,\n     pub default: Option<P<Ty>>,\n-    pub span: Span\n+    pub span: Span,\n }\n \n /// Represents lifetimes and type parameters attached to a declaration\n@@ -287,7 +291,7 @@ pub enum WherePredicate {\n     /// A lifetime predicate, e.g. `'a: 'b+'c`\n     RegionPredicate(WhereRegionPredicate),\n     /// An equality predicate (unsupported)\n-    EqPredicate(WhereEqPredicate)\n+    EqPredicate(WhereEqPredicate),\n }\n \n /// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n@@ -496,7 +500,7 @@ pub enum UnOp {\n     /// The `!` operator for logical inversion\n     UnNot,\n     /// The `-` operator for negation\n-    UnNeg\n+    UnNeg,\n }\n \n /// A statement\n@@ -506,7 +510,8 @@ impl fmt::Debug for Stmt_ {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Sadness.\n         let spanned = codemap::dummy_spanned(self.clone());\n-        write!(f, \"stmt({}: {})\",\n+        write!(f,\n+               \"stmt({}: {})\",\n                util::stmt_id(&spanned),\n                pprust::stmt_to_string(&spanned))\n     }\n@@ -709,13 +714,15 @@ pub enum Expr_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct QSelf {\n     pub ty: P<Ty>,\n-    pub position: usize\n+    pub position: usize,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {\n     Normal,\n-    IfLetDesugar { contains_else_clause: bool },\n+    IfLetDesugar {\n+        contains_else_clause: bool,\n+    },\n     WhileLetDesugar,\n     ForLoopDesugar,\n }\n@@ -815,15 +822,15 @@ pub enum PrimTy {\n     TyFloat(FloatTy),\n     TyStr,\n     TyBool,\n-    TyChar\n+    TyChar,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n     pub lifetimes: Vec<LifetimeDef>,\n-    pub decl: P<FnDecl>\n+    pub decl: P<FnDecl>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -839,7 +846,7 @@ pub enum Ty_ {\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n-    TyTup(Vec<P<Ty>> ),\n+    TyTup(Vec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n@@ -881,7 +888,10 @@ pub struct Arg {\n \n impl Arg {\n     pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n-        let path = Spanned{span:span,node:self_ident};\n+        let path = Spanned {\n+            span: span,\n+            node: self_ident,\n+        };\n         Arg {\n             // HACK(eddyb) fake type for the self argument.\n             ty: P(Ty {\n@@ -892,9 +902,9 @@ impl Arg {\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n                 node: PatIdent(BindByValue(mutability), path, None),\n-                span: span\n+                span: span,\n             }),\n-            id: DUMMY_NODE_ID\n+            id: DUMMY_NODE_ID,\n         }\n     }\n }\n@@ -904,7 +914,7 @@ impl Arg {\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: FunctionRetTy,\n-    pub variadic: bool\n+    pub variadic: bool,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -922,9 +932,10 @@ pub enum Constness {\n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(match *self {\n-            Unsafety::Normal => \"normal\",\n-            Unsafety::Unsafe => \"unsafe\",\n-        }, f)\n+                              Unsafety::Normal => \"normal\",\n+                              Unsafety::Unsafe => \"unsafe\",\n+                          },\n+                          f)\n     }\n }\n \n@@ -966,7 +977,7 @@ impl FunctionRetTy {\n         match *self {\n             NoReturn(span) => span,\n             DefaultReturn(span) => span,\n-            Return(ref ty) => ty.span\n+            Return(ref ty) => ty.span,\n         }\n     }\n }\n@@ -1038,19 +1049,19 @@ pub enum PathListItem_ {\n         name: Name,\n         /// renamed in list, eg `use foo::{bar as baz};`\n         rename: Option<Name>,\n-        id: NodeId\n+        id: NodeId,\n     },\n     PathListMod {\n         /// renamed in list, eg `use foo::{self as baz};`\n         rename: Option<Name>,\n-        id: NodeId\n-    }\n+        id: NodeId,\n+    },\n }\n \n impl PathListItem_ {\n     pub fn id(&self) -> NodeId {\n         match *self {\n-            PathListIdent { id, .. } | PathListMod { id, .. } => id\n+            PathListIdent { id, .. } | PathListMod { id, .. } => id,\n         }\n     }\n \n@@ -1063,7 +1074,7 @@ impl PathListItem_ {\n \n     pub fn rename(&self) -> Option<Name> {\n         match *self {\n-            PathListIdent { rename, .. } | PathListMod { rename, .. } => rename\n+            PathListIdent { rename, .. } | PathListMod { rename, .. } => rename,\n         }\n     }\n }\n@@ -1086,7 +1097,7 @@ pub enum ViewPath_ {\n     ViewPathGlob(Path),\n \n     /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, Vec<PathListItem>)\n+    ViewPathList(Path, Vec<PathListItem>),\n }\n \n /// TraitRef's appear in impls.\n@@ -1122,7 +1133,7 @@ impl Visibility {\n     pub fn inherit_from(&self, parent_visibility: Visibility) -> Visibility {\n         match self {\n             &Inherited => parent_visibility,\n-            &Public => *self\n+            &Public => *self,\n         }\n     }\n }\n@@ -1139,7 +1150,7 @@ impl StructField_ {\n     pub fn name(&self) -> Option<Name> {\n         match self.kind {\n             NamedField(name, _) => Some(name),\n-            UnnamedField(_) => None\n+            UnnamedField(_) => None,\n         }\n     }\n }\n@@ -1214,10 +1225,7 @@ pub enum Item_ {\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     ItemStruct(P<StructDef>, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(Unsafety,\n-              Generics,\n-              TyParamBounds,\n-              Vec<P<TraitItem>>),\n+    ItemTrait(Unsafety, Generics, TyParamBounds, Vec<P<TraitItem>>),\n \n     // Default trait implementations\n     ///\n@@ -1247,7 +1255,7 @@ impl Item_ {\n             ItemStruct(..) => \"struct\",\n             ItemTrait(..) => \"trait\",\n             ItemImpl(..) |\n-            ItemDefaultImpl(..) => \"item\"\n+            ItemDefaultImpl(..) => \"item\",\n         }\n     }\n }\n@@ -1276,7 +1284,7 @@ impl ForeignItem_ {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n             ForeignItemFn(..) => \"foreign function\",\n-            ForeignItemStatic(..) => \"foreign static item\"\n+            ForeignItemStatic(..) => \"foreign static item\",\n         }\n     }\n }"}, {"sha": "022744cbc3a14e430ff010ae1c60a8660739e208", "filename": "src/librustc_front/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "patch": "@@ -38,9 +38,13 @@\n #![feature(filling_drop)]\n \n extern crate serialize;\n-#[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n-#[macro_use] #[no_link] extern crate rustc_bitflags;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate syntax;\n+#[macro_use]\n+#[no_link]\n+extern crate rustc_bitflags;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "d1026f1dfb291ee19d3df8f6485855b7354432c8", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 280, "deletions": 240, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "patch": "@@ -29,24 +29,26 @@ pub fn lower_view_path(view_path: &ViewPath) -> P<hir::ViewPath> {\n             }\n             ViewPathList(ref path, ref path_list_idents) => {\n                 hir::ViewPathList(lower_path(path),\n-                             path_list_idents.iter().map(|path_list_ident| {\n-                                Spanned {\n-                                    node: match path_list_ident.node {\n-                                        PathListIdent { id, name, rename } =>\n-                                            hir::PathListIdent {\n-                                                id: id,\n-                                                name: name.name,\n-                                                rename: rename.map(|x| x.name),\n-                                            },\n-                                        PathListMod { id, rename } =>\n-                                            hir::PathListMod {\n-                                                id: id,\n-                                                rename: rename.map(|x| x.name)\n-                                            }\n-                                    },\n-                                    span: path_list_ident.span\n-                                }\n-                             }).collect())\n+                                  path_list_idents.iter()\n+                                                  .map(|path_list_ident| {\n+                                                      Spanned {\n+                                                          node: match path_list_ident.node {\n+                                                              PathListIdent { id, name, rename } =>\n+                                                                  hir::PathListIdent {\n+                                                                  id: id,\n+                                                                  name: name.name,\n+                                                                  rename: rename.map(|x| x.name),\n+                                                              },\n+                                                              PathListMod { id, rename } =>\n+                                                                  hir::PathListMod {\n+                                                                  id: id,\n+                                                                  rename: rename.map(|x| x.name),\n+                                                              },\n+                                                          },\n+                                                          span: path_list_ident.span,\n+                                                      }\n+                                                  })\n+                                                  .collect())\n             }\n         },\n         span: view_path.span,\n@@ -66,17 +68,22 @@ pub fn lower_decl(d: &Decl) -> P<hir::Decl> {\n     match d.node {\n         DeclLocal(ref l) => P(Spanned {\n             node: hir::DeclLocal(lower_local(l)),\n-            span: d.span\n+            span: d.span,\n         }),\n         DeclItem(ref it) => P(Spanned {\n             node: hir::DeclItem(lower_item(it)),\n-            span: d.span\n+            span: d.span,\n         }),\n     }\n }\n \n pub fn lower_ty_binding(b: &TypeBinding) -> P<hir::TypeBinding> {\n-    P(hir::TypeBinding { id: b.id, name: b.ident.name, ty: lower_ty(&b.ty), span: b.span })\n+    P(hir::TypeBinding {\n+        id: b.id,\n+        name: b.ident.name,\n+        ty: lower_ty(&b.ty),\n+        span: b.span,\n+    })\n }\n \n pub fn lower_ty(t: &Ty) -> P<hir::Ty> {\n@@ -94,7 +101,7 @@ pub fn lower_ty(t: &Ty) -> P<hir::Ty> {\n                     lifetimes: lower_lifetime_defs(&f.lifetimes),\n                     unsafety: lower_unsafety(f.unsafety),\n                     abi: f.abi,\n-                    decl: lower_fn_decl(&f.decl)\n+                    decl: lower_fn_decl(&f.decl),\n                 }))\n             }\n             TyTup(ref tys) => hir::TyTup(tys.iter().map(|ty| lower_ty(ty)).collect()),\n@@ -103,14 +110,13 @@ pub fn lower_ty(t: &Ty) -> P<hir::Ty> {\n                 let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                     hir::QSelf {\n                         ty: lower_ty(ty),\n-                        position: position\n+                        position: position,\n                     }\n                 });\n                 hir::TyPath(qself, lower_path(path))\n             }\n             TyObjectSum(ref ty, ref bounds) => {\n-                hir::TyObjectSum(lower_ty(ty),\n-                            lower_bounds(bounds))\n+                hir::TyObjectSum(lower_ty(ty), lower_bounds(bounds))\n             }\n             TyFixedLengthVec(ref ty, ref e) => {\n                 hir::TyFixedLengthVec(lower_ty(ty), lower_expr(e))\n@@ -142,8 +148,9 @@ pub fn lower_variant(v: &Variant) -> P<hir::Variant> {\n             attrs: v.node.attrs.clone(),\n             kind: match v.node.kind {\n                 TupleVariantKind(ref variant_args) => {\n-                    hir::TupleVariantKind(variant_args.iter().map(|ref x|\n-                        lower_variant_arg(x)).collect())\n+                    hir::TupleVariantKind(variant_args.iter()\n+                                                      .map(|ref x| lower_variant_arg(x))\n+                                                      .collect())\n                 }\n                 StructVariantKind(ref struct_def) => {\n                     hir::StructVariantKind(lower_struct_def(struct_def))\n@@ -158,11 +165,15 @@ pub fn lower_variant(v: &Variant) -> P<hir::Variant> {\n pub fn lower_path(p: &Path) -> hir::Path {\n     hir::Path {\n         global: p.global,\n-        segments: p.segments.iter().map(|&PathSegment {identifier, ref parameters}|\n-            hir::PathSegment {\n-                identifier: identifier,\n-                parameters: lower_path_parameters(parameters),\n-            }).collect(),\n+        segments: p.segments\n+                   .iter()\n+                   .map(|&PathSegment { identifier, ref parameters }| {\n+                       hir::PathSegment {\n+                           identifier: identifier,\n+                           parameters: lower_path_parameters(parameters),\n+                       }\n+                   })\n+                   .collect(),\n         span: p.span,\n     }\n }\n@@ -198,20 +209,22 @@ pub fn lower_parenthesized_parameter_data(data: &ParenthesizedParameterData)\n \n pub fn lower_local(l: &Local) -> P<hir::Local> {\n     P(hir::Local {\n-            id: l.id,\n-            ty: l.ty.as_ref().map(|t| lower_ty(t)),\n-            pat: lower_pat(&l.pat),\n-            init: l.init.as_ref().map(|e| lower_expr(e)),\n-            span: l.span,\n-        })\n+        id: l.id,\n+        ty: l.ty.as_ref().map(|t| lower_ty(t)),\n+        pat: lower_pat(&l.pat),\n+        init: l.init.as_ref().map(|e| lower_expr(e)),\n+        span: l.span,\n+    })\n }\n \n pub fn lower_explicit_self_underscore(es: &ExplicitSelf_) -> hir::ExplicitSelf_ {\n     match *es {\n         SelfStatic => hir::SelfStatic,\n         SelfValue(v) => hir::SelfValue(v.name),\n         SelfRegion(ref lifetime, m, ident) => {\n-            hir::SelfRegion(lower_opt_lifetime(lifetime), lower_mutability(m), ident.name)\n+            hir::SelfRegion(lower_opt_lifetime(lifetime),\n+                            lower_mutability(m),\n+                            ident.name)\n         }\n         SelfExplicit(ref typ, ident) => {\n             hir::SelfExplicit(lower_ty(typ), ident.name)\n@@ -227,11 +240,18 @@ pub fn lower_mutability(m: Mutability) -> hir::Mutability {\n }\n \n pub fn lower_explicit_self(s: &ExplicitSelf) -> hir::ExplicitSelf {\n-    Spanned { node: lower_explicit_self_underscore(&s.node), span: s.span }\n+    Spanned {\n+        node: lower_explicit_self_underscore(&s.node),\n+        span: s.span,\n+    }\n }\n \n pub fn lower_arg(arg: &Arg) -> hir::Arg {\n-    hir::Arg { id: arg.id, pat: lower_pat(&arg.pat), ty: lower_ty(&arg.ty) }\n+    hir::Arg {\n+        id: arg.id,\n+        pat: lower_pat(&arg.pat),\n+        ty: lower_ty(&arg.ty),\n+    }\n }\n \n pub fn lower_fn_decl(decl: &FnDecl) -> P<hir::FnDecl> {\n@@ -240,7 +260,7 @@ pub fn lower_fn_decl(decl: &FnDecl) -> P<hir::FnDecl> {\n         output: match decl.output {\n             Return(ref ty) => hir::Return(lower_ty(ty)),\n             DefaultReturn(span) => hir::DefaultReturn(span),\n-            NoReturn(span) => hir::NoReturn(span)\n+            NoReturn(span) => hir::NoReturn(span),\n         },\n         variadic: decl.variadic,\n     })\n@@ -249,7 +269,8 @@ pub fn lower_fn_decl(decl: &FnDecl) -> P<hir::FnDecl> {\n pub fn lower_ty_param_bound(tpb: &TyParamBound) -> hir::TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ref ty, modifier) => {\n-            hir::TraitTyParamBound(lower_poly_trait_ref(ty), lower_trait_bound_modifier(modifier))\n+            hir::TraitTyParamBound(lower_poly_trait_ref(ty),\n+                                   lower_trait_bound_modifier(modifier))\n         }\n         RegionTyParamBound(ref lifetime) => hir::RegionTyParamBound(lower_lifetime(lifetime)),\n     }\n@@ -270,11 +291,18 @@ pub fn lower_ty_params(tps: &OwnedSlice<TyParam>) -> OwnedSlice<hir::TyParam> {\n }\n \n pub fn lower_lifetime(l: &Lifetime) -> hir::Lifetime {\n-    hir::Lifetime { id: l.id, name: l.name, span: l.span }\n+    hir::Lifetime {\n+        id: l.id,\n+        name: l.name,\n+        span: l.span,\n+    }\n }\n \n pub fn lower_lifetime_def(l: &LifetimeDef) -> hir::LifetimeDef {\n-    hir::LifetimeDef { lifetime: lower_lifetime(&l.lifetime), bounds: lower_lifetimes(&l.bounds) }\n+    hir::LifetimeDef {\n+        lifetime: lower_lifetime(&l.lifetime),\n+        bounds: lower_lifetimes(&l.bounds),\n+    }\n }\n \n pub fn lower_lifetimes(lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n@@ -300,8 +328,10 @@ pub fn lower_generics(g: &Generics) -> hir::Generics {\n pub fn lower_where_clause(wc: &WhereClause) -> hir::WhereClause {\n     hir::WhereClause {\n         id: wc.id,\n-        predicates: wc.predicates.iter().map(|predicate|\n-            lower_where_predicate(predicate)).collect(),\n+        predicates: wc.predicates\n+                      .iter()\n+                      .map(|predicate| lower_where_predicate(predicate))\n+                      .collect(),\n     }\n }\n \n@@ -315,7 +345,7 @@ pub fn lower_where_predicate(pred: &WherePredicate) -> hir::WherePredicate {\n                 bound_lifetimes: lower_lifetime_defs(bound_lifetimes),\n                 bounded_ty: lower_ty(bounded_ty),\n                 bounds: bounds.iter().map(|x| lower_ty_param_bound(x)).collect(),\n-                span: span\n+                span: span,\n             })\n         }\n         WherePredicate::RegionPredicate(WhereRegionPredicate{ ref lifetime,\n@@ -324,18 +354,18 @@ pub fn lower_where_predicate(pred: &WherePredicate) -> hir::WherePredicate {\n             hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                 span: span,\n                 lifetime: lower_lifetime(lifetime),\n-                bounds: bounds.iter().map(|bound| lower_lifetime(bound)).collect()\n+                bounds: bounds.iter().map(|bound| lower_lifetime(bound)).collect(),\n             })\n         }\n         WherePredicate::EqPredicate(WhereEqPredicate{ id,\n                                                       ref path,\n                                                       ref ty,\n                                                       span}) => {\n-            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{\n+            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                 id: id,\n                 path: lower_path(path),\n-                ty:lower_ty(ty),\n-                span: span\n+                ty: lower_ty(ty),\n+                span: span,\n             })\n         }\n     }\n@@ -349,7 +379,10 @@ pub fn lower_struct_def(sd: &StructDef) -> P<hir::StructDef> {\n }\n \n pub fn lower_trait_ref(p: &TraitRef) -> hir::TraitRef {\n-    hir::TraitRef { path: lower_path(&p.path), ref_id: p.ref_id }\n+    hir::TraitRef {\n+        path: lower_path(&p.path),\n+        ref_id: p.ref_id,\n+    }\n }\n \n pub fn lower_poly_trait_ref(p: &PolyTraitRef) -> hir::PolyTraitRef {\n@@ -375,12 +408,16 @@ pub fn lower_struct_field(f: &StructField) -> hir::StructField {\n pub fn lower_field(f: &Field) -> hir::Field {\n     hir::Field {\n         name: respan(f.ident.span, f.ident.node.name),\n-        expr: lower_expr(&f.expr), span: f.span\n+        expr: lower_expr(&f.expr),\n+        span: f.span,\n     }\n }\n \n pub fn lower_mt(mt: &MutTy) -> hir::MutTy {\n-    hir::MutTy { ty: lower_ty(&mt.ty), mutbl: lower_mutability(mt.mutbl) }\n+    hir::MutTy {\n+        ty: lower_ty(&mt.ty),\n+        mutbl: lower_mutability(mt.mutbl),\n+    }\n }\n \n pub fn lower_opt_bounds(b: &Option<OwnedSlice<TyParamBound>>)\n@@ -393,7 +430,10 @@ fn lower_bounds(bounds: &TyParamBounds) -> hir::TyParamBounds {\n }\n \n fn lower_variant_arg(va: &VariantArg) -> hir::VariantArg {\n-    hir::VariantArg { id: va.id, ty: lower_ty(&va.ty) }\n+    hir::VariantArg {\n+        id: va.id,\n+        ty: lower_ty(&va.ty),\n+    }\n }\n \n pub fn lower_block(b: &Block) -> P<hir::Block> {\n@@ -419,26 +459,26 @@ pub fn lower_item_underscore(i: &Item_) -> hir::Item_ {\n             hir::ItemConst(lower_ty(t), lower_expr(e))\n         }\n         ItemFn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-            hir::ItemFn(\n-                lower_fn_decl(decl),\n-                lower_unsafety(unsafety),\n-                lower_constness(constness),\n-                abi,\n-                lower_generics(generics),\n-                lower_block(body)\n-            )\n+            hir::ItemFn(lower_fn_decl(decl),\n+                        lower_unsafety(unsafety),\n+                        lower_constness(constness),\n+                        abi,\n+                        lower_generics(generics),\n+                        lower_block(body))\n         }\n         ItemMod(ref m) => hir::ItemMod(lower_mod(m)),\n         ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(nm)),\n         ItemTy(ref t, ref generics) => {\n             hir::ItemTy(lower_ty(t), lower_generics(generics))\n         }\n         ItemEnum(ref enum_definition, ref generics) => {\n-            hir::ItemEnum(\n-                hir::EnumDef {\n-                    variants: enum_definition.variants.iter().map(|x| lower_variant(x)).collect(),\n-                },\n-                lower_generics(generics))\n+            hir::ItemEnum(hir::EnumDef {\n+                              variants: enum_definition.variants\n+                                                       .iter()\n+                                                       .map(|x| lower_variant(x))\n+                                                       .collect(),\n+                          },\n+                          lower_generics(generics))\n         }\n         ItemStruct(ref struct_def, ref generics) => {\n             let struct_def = lower_struct_def(struct_def);\n@@ -471,10 +511,10 @@ pub fn lower_item_underscore(i: &Item_) -> hir::Item_ {\n \n pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n     P(hir::TraitItem {\n-            id: i.id,\n-            name: i.ident.name,\n-            attrs: i.attrs.clone(),\n-            node: match i.node {\n+        id: i.id,\n+        name: i.ident.name,\n+        attrs: i.attrs.clone(),\n+        node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n                 hir::ConstTraitItem(lower_ty(ty),\n                                     default.as_ref().map(|x| lower_expr(x)))\n@@ -488,33 +528,35 @@ pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n                                    default.as_ref().map(|x| lower_ty(x)))\n             }\n         },\n-            span: i.span,\n-        })\n+        span: i.span,\n+    })\n }\n \n pub fn lower_impl_item(i: &ImplItem) -> P<hir::ImplItem> {\n     P(hir::ImplItem {\n-            id: i.id,\n-            name: i.ident.name,\n-            attrs: i.attrs.clone(),\n-            vis: lower_visibility(i.vis),\n-            node: match i.node  {\n+        id: i.id,\n+        name: i.ident.name,\n+        attrs: i.attrs.clone(),\n+        vis: lower_visibility(i.vis),\n+        node: match i.node {\n             ConstImplItem(ref ty, ref expr) => {\n                 hir::ConstImplItem(lower_ty(ty), lower_expr(expr))\n             }\n             MethodImplItem(ref sig, ref body) => {\n-                hir::MethodImplItem(lower_method_sig(sig),\n-                                    lower_block(body))\n+                hir::MethodImplItem(lower_method_sig(sig), lower_block(body))\n             }\n             TypeImplItem(ref ty) => hir::TypeImplItem(lower_ty(ty)),\n             MacImplItem(..) => panic!(\"Shouldn't exist any more\"),\n         },\n-            span: i.span,\n-        })\n+        span: i.span,\n+    })\n }\n \n pub fn lower_mod(m: &Mod) -> hir::Mod {\n-    hir::Mod { inner: m.inner, items: m.items.iter().map(|x| lower_item(x)).collect() }\n+    hir::Mod {\n+        inner: m.inner,\n+        items: m.items.iter().map(|x| lower_item(x)).collect(),\n+    }\n }\n \n pub fn lower_crate(c: &Crate) -> hir::Crate {\n@@ -562,20 +604,20 @@ pub fn lower_item_simple(i: &Item) -> hir::Item {\n \n pub fn lower_foreign_item(i: &ForeignItem) -> P<hir::ForeignItem> {\n     P(hir::ForeignItem {\n-            id: i.id,\n-            name: i.ident.name,\n-            attrs: i.attrs.clone(),\n-            node: match i.node {\n+        id: i.id,\n+        name: i.ident.name,\n+        attrs: i.attrs.clone(),\n+        node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n                 hir::ForeignItemFn(lower_fn_decl(fdec), lower_generics(generics))\n             }\n             ForeignItemStatic(ref t, m) => {\n                 hir::ForeignItemStatic(lower_ty(t), m)\n             }\n         },\n-            vis: lower_visibility(i.vis),\n-            span: i.span,\n-        })\n+        vis: lower_visibility(i.vis),\n+        span: i.span,\n+    })\n }\n \n pub fn lower_method_sig(sig: &MethodSig) -> hir::MethodSig {\n@@ -639,18 +681,18 @@ pub fn lower_binop(b: BinOp) -> hir::BinOp {\n \n pub fn lower_pat(p: &Pat) -> P<hir::Pat> {\n     P(hir::Pat {\n-            id: p.id,\n-            node: match p.node {\n+        id: p.id,\n+        node: match p.node {\n             PatWild(k) => hir::PatWild(lower_pat_wild_kind(k)),\n             PatIdent(ref binding_mode, pth1, ref sub) => {\n                 hir::PatIdent(lower_binding_mode(binding_mode),\n-                        pth1,\n-                        sub.as_ref().map(|x| lower_pat(x)))\n+                              pth1,\n+                              sub.as_ref().map(|x| lower_pat(x)))\n             }\n             PatLit(ref e) => hir::PatLit(lower_expr(e)),\n             PatEnum(ref pth, ref pats) => {\n                 hir::PatEnum(lower_path(pth),\n-                        pats.as_ref().map(|pats| pats.iter().map(|x| lower_pat(x)).collect()))\n+                             pats.as_ref().map(|pats| pats.iter().map(|x| lower_pat(x)).collect()))\n             }\n             PatQPath(ref qself, ref pth) => {\n                 let qself = hir::QSelf {\n@@ -661,130 +703,126 @@ pub fn lower_pat(p: &Pat) -> P<hir::Pat> {\n             }\n             PatStruct(ref pth, ref fields, etc) => {\n                 let pth = lower_path(pth);\n-                let fs = fields.iter().map(|f| {\n-                    Spanned { span: f.span,\n-                              node: hir::FieldPat {\n-                                  name: f.node.ident.name,\n-                                  pat: lower_pat(&f.node.pat),\n-                                  is_shorthand: f.node.is_shorthand,\n-                              }}\n-                }).collect();\n+                let fs = fields.iter()\n+                               .map(|f| {\n+                                   Spanned {\n+                                       span: f.span,\n+                                       node: hir::FieldPat {\n+                                           name: f.node.ident.name,\n+                                           pat: lower_pat(&f.node.pat),\n+                                           is_shorthand: f.node.is_shorthand,\n+                                       },\n+                                   }\n+                               })\n+                               .collect();\n                 hir::PatStruct(pth, fs, etc)\n             }\n             PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(x)).collect()),\n             PatBox(ref inner) => hir::PatBox(lower_pat(inner)),\n-            PatRegion(ref inner, mutbl) => hir::PatRegion(lower_pat(inner),\n-                                                          lower_mutability(mutbl)),\n+            PatRegion(ref inner, mutbl) =>\n+                hir::PatRegion(lower_pat(inner), lower_mutability(mutbl)),\n             PatRange(ref e1, ref e2) => {\n                 hir::PatRange(lower_expr(e1), lower_expr(e2))\n-            },\n+            }\n             PatVec(ref before, ref slice, ref after) => {\n                 hir::PatVec(before.iter().map(|x| lower_pat(x)).collect(),\n-                       slice.as_ref().map(|x| lower_pat(x)),\n-                       after.iter().map(|x| lower_pat(x)).collect())\n+                            slice.as_ref().map(|x| lower_pat(x)),\n+                            after.iter().map(|x| lower_pat(x)).collect())\n             }\n             PatMac(_) => panic!(\"Shouldn't exist here\"),\n         },\n-            span: p.span,\n-        })\n+        span: p.span,\n+    })\n }\n \n pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n     P(hir::Expr {\n-            id: e.id,\n-            node: match e.node {\n-                ExprBox(ref e) => {\n-                    hir::ExprBox(lower_expr(e))\n-                }\n-                ExprVec(ref exprs) => {\n-                    hir::ExprVec(exprs.iter().map(|x| lower_expr(x)).collect())\n-                }\n-                ExprRepeat(ref expr, ref count) => {\n-                    hir::ExprRepeat(lower_expr(expr), lower_expr(count))\n-                }\n-                ExprTup(ref elts) => hir::ExprTup(elts.iter().map(|x| lower_expr(x)).collect()),\n-                ExprCall(ref f, ref args) => {\n-                    hir::ExprCall(lower_expr(f),\n-                             args.iter().map(|x| lower_expr(x)).collect())\n-                }\n-                ExprMethodCall(i, ref tps, ref args) => {\n-                    hir::ExprMethodCall(\n-                        respan(i.span, i.node.name),\n-                        tps.iter().map(|x| lower_ty(x)).collect(),\n-                        args.iter().map(|x| lower_expr(x)).collect())\n-                }\n-                ExprBinary(binop, ref lhs, ref rhs) => {\n-                    hir::ExprBinary(lower_binop(binop),\n-                            lower_expr(lhs),\n-                            lower_expr(rhs))\n-                }\n-                ExprUnary(op, ref ohs) => {\n-                    hir::ExprUnary(lower_unop(op), lower_expr(ohs))\n-                }\n-                ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n-                ExprCast(ref expr, ref ty) => {\n-                    hir::ExprCast(lower_expr(expr), lower_ty(ty))\n-                }\n-                ExprAddrOf(m, ref ohs) => hir::ExprAddrOf(lower_mutability(m), lower_expr(ohs)),\n-                ExprIf(ref cond, ref tr, ref fl) => {\n-                    hir::ExprIf(lower_expr(cond),\n-                           lower_block(tr),\n-                           fl.as_ref().map(|x| lower_expr(x)))\n-                }\n-                ExprWhile(ref cond, ref body, opt_ident) => {\n-                    hir::ExprWhile(lower_expr(cond),\n-                              lower_block(body),\n-                              opt_ident)\n-                }\n-                ExprLoop(ref body, opt_ident) => {\n-                    hir::ExprLoop(lower_block(body),\n-                            opt_ident)\n-                }\n-                ExprMatch(ref expr, ref arms, ref source) => {\n-                    hir::ExprMatch(lower_expr(expr),\n-                            arms.iter().map(|x| lower_arm(x)).collect(),\n-                            lower_match_source(source))\n-                }\n-                ExprClosure(capture_clause, ref decl, ref body) => {\n-                    hir::ExprClosure(lower_capture_clause(capture_clause),\n-                                lower_fn_decl(decl),\n-                                lower_block(body))\n-                }\n-                ExprBlock(ref blk) => hir::ExprBlock(lower_block(blk)),\n-                ExprAssign(ref el, ref er) => {\n-                    hir::ExprAssign(lower_expr(el), lower_expr(er))\n-                }\n-                ExprAssignOp(op, ref el, ref er) => {\n-                    hir::ExprAssignOp(lower_binop(op),\n-                                lower_expr(el),\n-                                lower_expr(er))\n-                }\n-                ExprField(ref el, ident) => {\n-                    hir::ExprField(lower_expr(el), respan(ident.span, ident.node.name))\n-                }\n-                ExprTupField(ref el, ident) => {\n-                    hir::ExprTupField(lower_expr(el), ident)\n-                }\n-                ExprIndex(ref el, ref er) => {\n-                    hir::ExprIndex(lower_expr(el), lower_expr(er))\n-                }\n-                ExprRange(ref e1, ref e2) => {\n-                    hir::ExprRange(e1.as_ref().map(|x| lower_expr(x)),\n-                              e2.as_ref().map(|x| lower_expr(x)))\n-                }\n-                ExprPath(ref qself, ref path) => {\n-                    let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n-                        hir::QSelf {\n-                            ty: lower_ty(ty),\n-                            position: position\n-                        }\n-                    });\n-                    hir::ExprPath(qself, lower_path(path))\n-                }\n-                ExprBreak(opt_ident) => hir::ExprBreak(opt_ident),\n-                ExprAgain(opt_ident) => hir::ExprAgain(opt_ident),\n-                ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(x))),\n-                ExprInlineAsm(InlineAsm {\n+        id: e.id,\n+        node: match e.node {\n+            ExprBox(ref e) => {\n+                hir::ExprBox(lower_expr(e))\n+            }\n+            ExprVec(ref exprs) => {\n+                hir::ExprVec(exprs.iter().map(|x| lower_expr(x)).collect())\n+            }\n+            ExprRepeat(ref expr, ref count) => {\n+                hir::ExprRepeat(lower_expr(expr), lower_expr(count))\n+            }\n+            ExprTup(ref elts) => hir::ExprTup(elts.iter().map(|x| lower_expr(x)).collect()),\n+            ExprCall(ref f, ref args) => {\n+                hir::ExprCall(lower_expr(f),\n+                              args.iter().map(|x| lower_expr(x)).collect())\n+            }\n+            ExprMethodCall(i, ref tps, ref args) => {\n+                hir::ExprMethodCall(respan(i.span, i.node.name),\n+                                    tps.iter().map(|x| lower_ty(x)).collect(),\n+                                    args.iter().map(|x| lower_expr(x)).collect())\n+            }\n+            ExprBinary(binop, ref lhs, ref rhs) => {\n+                hir::ExprBinary(lower_binop(binop), lower_expr(lhs), lower_expr(rhs))\n+            }\n+            ExprUnary(op, ref ohs) => {\n+                hir::ExprUnary(lower_unop(op), lower_expr(ohs))\n+            }\n+            ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n+            ExprCast(ref expr, ref ty) => {\n+                hir::ExprCast(lower_expr(expr), lower_ty(ty))\n+            }\n+            ExprAddrOf(m, ref ohs) => hir::ExprAddrOf(lower_mutability(m), lower_expr(ohs)),\n+            ExprIf(ref cond, ref tr, ref fl) => {\n+                hir::ExprIf(lower_expr(cond),\n+                            lower_block(tr),\n+                            fl.as_ref().map(|x| lower_expr(x)))\n+            }\n+            ExprWhile(ref cond, ref body, opt_ident) => {\n+                hir::ExprWhile(lower_expr(cond), lower_block(body), opt_ident)\n+            }\n+            ExprLoop(ref body, opt_ident) => {\n+                hir::ExprLoop(lower_block(body), opt_ident)\n+            }\n+            ExprMatch(ref expr, ref arms, ref source) => {\n+                hir::ExprMatch(lower_expr(expr),\n+                               arms.iter().map(|x| lower_arm(x)).collect(),\n+                               lower_match_source(source))\n+            }\n+            ExprClosure(capture_clause, ref decl, ref body) => {\n+                hir::ExprClosure(lower_capture_clause(capture_clause),\n+                                 lower_fn_decl(decl),\n+                                 lower_block(body))\n+            }\n+            ExprBlock(ref blk) => hir::ExprBlock(lower_block(blk)),\n+            ExprAssign(ref el, ref er) => {\n+                hir::ExprAssign(lower_expr(el), lower_expr(er))\n+            }\n+            ExprAssignOp(op, ref el, ref er) => {\n+                hir::ExprAssignOp(lower_binop(op), lower_expr(el), lower_expr(er))\n+            }\n+            ExprField(ref el, ident) => {\n+                hir::ExprField(lower_expr(el), respan(ident.span, ident.node.name))\n+            }\n+            ExprTupField(ref el, ident) => {\n+                hir::ExprTupField(lower_expr(el), ident)\n+            }\n+            ExprIndex(ref el, ref er) => {\n+                hir::ExprIndex(lower_expr(el), lower_expr(er))\n+            }\n+            ExprRange(ref e1, ref e2) => {\n+                hir::ExprRange(e1.as_ref().map(|x| lower_expr(x)),\n+                               e2.as_ref().map(|x| lower_expr(x)))\n+            }\n+            ExprPath(ref qself, ref path) => {\n+                let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n+                    hir::QSelf {\n+                        ty: lower_ty(ty),\n+                        position: position,\n+                    }\n+                });\n+                hir::ExprPath(qself, lower_path(path))\n+            }\n+            ExprBreak(opt_ident) => hir::ExprBreak(opt_ident),\n+            ExprAgain(opt_ident) => hir::ExprAgain(opt_ident),\n+            ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(x))),\n+            ExprInlineAsm(InlineAsm {\n                     ref inputs,\n                     ref outputs,\n                     ref asm,\n@@ -795,59 +833,61 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                     dialect,\n                     expn_id,\n                 }) => hir::ExprInlineAsm(hir::InlineAsm {\n-                    inputs: inputs.iter().map(|&(ref c, ref input)| {\n-                        (c.clone(), lower_expr(input))\n-                    }).collect(),\n-                    outputs: outputs.iter().map(|&(ref c, ref out, ref is_rw)| {\n-                        (c.clone(), lower_expr(out), *is_rw)\n-                    }).collect(),\n-                    asm: asm.clone(),\n-                    asm_str_style: asm_str_style,\n-                    clobbers: clobbers.clone(),\n-                    volatile: volatile,\n-                    alignstack: alignstack,\n-                    dialect: dialect,\n-                    expn_id: expn_id,\n-                }),\n-                ExprStruct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(lower_path(path),\n-                            fields.iter().map(|x| lower_field(x)).collect(),\n-                            maybe_expr.as_ref().map(|x| lower_expr(x)))\n-                },\n-                ExprParen(ref ex) => {\n-                    return lower_expr(ex);\n-                }\n-                ExprInPlace(..) |\n-                ExprIfLet(..) |\n-                ExprWhileLet(..) |\n-                ExprForLoop(..) |\n-                ExprMac(_) => panic!(\"Shouldn't exist here\"),\n-            },\n-            span: e.span,\n-        })\n+                inputs: inputs.iter()\n+                              .map(|&(ref c, ref input)| (c.clone(), lower_expr(input)))\n+                              .collect(),\n+                outputs: outputs.iter()\n+                                .map(|&(ref c, ref out, ref is_rw)| {\n+                                    (c.clone(), lower_expr(out), *is_rw)\n+                                })\n+                                .collect(),\n+                asm: asm.clone(),\n+                asm_str_style: asm_str_style,\n+                clobbers: clobbers.clone(),\n+                volatile: volatile,\n+                alignstack: alignstack,\n+                dialect: dialect,\n+                expn_id: expn_id,\n+            }),\n+            ExprStruct(ref path, ref fields, ref maybe_expr) => {\n+                hir::ExprStruct(lower_path(path),\n+                                fields.iter().map(|x| lower_field(x)).collect(),\n+                                maybe_expr.as_ref().map(|x| lower_expr(x)))\n+            }\n+            ExprParen(ref ex) => {\n+                return lower_expr(ex);\n+            }\n+            ExprInPlace(..) |\n+            ExprIfLet(..) |\n+            ExprWhileLet(..) |\n+            ExprForLoop(..) |\n+            ExprMac(_) => panic!(\"Shouldn't exist here\"),\n+        },\n+        span: e.span,\n+    })\n }\n \n pub fn lower_stmt(s: &Stmt) -> P<hir::Stmt> {\n     match s.node {\n         StmtDecl(ref d, id) => {\n             P(Spanned {\n                 node: hir::StmtDecl(lower_decl(d), id),\n-                span: s.span\n+                span: s.span,\n             })\n         }\n         StmtExpr(ref e, id) => {\n             P(Spanned {\n                 node: hir::StmtExpr(lower_expr(e), id),\n-                span: s.span\n+                span: s.span,\n             })\n         }\n         StmtSemi(ref e, id) => {\n             P(Spanned {\n                 node: hir::StmtSemi(lower_expr(e), id),\n-                span: s.span\n+                span: s.span,\n             })\n         }\n-        StmtMac(..) => panic!(\"Shouldn't exist here\")\n+        StmtMac(..) => panic!(\"Shouldn't exist here\"),\n     }\n }\n "}, {"sha": "db0981728acc3913b90ac29d7ffd0287ad1efc80", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 355, "deletions": 350, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "patch": "@@ -39,8 +39,12 @@ pub enum AnnNode<'a> {\n }\n \n pub trait PpAnn {\n-    fn pre(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> { Ok(()) }\n-    fn post(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> { Ok(()) }\n+    fn pre(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> {\n+        Ok(())\n+    }\n+    fn post(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n #[derive(Copy, Clone)]\n@@ -56,7 +60,7 @@ pub struct State<'a> {\n     literals: Option<Vec<comments::Literal>>,\n     cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral,\n     boxes: Vec<pp::Breaks>,\n-    ann: &'a (PpAnn+'a),\n+    ann: &'a (PpAnn + 'a),\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -81,21 +85,20 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n }\n \n-pub fn rust_printer<'a>(writer: Box<Write+'a>) -> State<'a> {\n+pub fn rust_printer<'a>(writer: Box<Write + 'a>) -> State<'a> {\n     static NO_ANN: NoAnn = NoAnn;\n     rust_printer_annotated(writer, &NO_ANN)\n }\n \n-pub fn rust_printer_annotated<'a>(writer: Box<Write+'a>,\n-                                  ann: &'a PpAnn) -> State<'a> {\n+pub fn rust_printer_annotated<'a>(writer: Box<Write + 'a>, ann: &'a PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None,\n         comments: None,\n         literals: None,\n         cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n             cur_cmnt: 0,\n-            cur_lit: 0\n+            cur_lit: 0,\n         },\n         boxes: Vec::new(),\n         ann: ann,\n@@ -117,16 +120,11 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        krate: &hir::Crate,\n                        filename: String,\n                        input: &mut Read,\n-                       out: Box<Write+'a>,\n+                       out: Box<Write + 'a>,\n                        ann: &'a PpAnn,\n-                       is_expanded: bool) -> io::Result<()> {\n-    let mut s = State::new_from_input(cm,\n-                                      span_diagnostic,\n-                                      filename,\n-                                      input,\n-                                      out,\n-                                      ann,\n-                                      is_expanded);\n+                       is_expanded: bool)\n+                       -> io::Result<()> {\n+    let mut s = State::new_from_input(cm, span_diagnostic, filename, input, out, ann, is_expanded);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -141,47 +139,51 @@ impl<'a> State<'a> {\n                           span_diagnostic: &diagnostic::SpanHandler,\n                           filename: String,\n                           input: &mut Read,\n-                          out: Box<Write+'a>,\n+                          out: Box<Write + 'a>,\n                           ann: &'a PpAnn,\n-                          is_expanded: bool) -> State<'a> {\n-        let (cmnts, lits) = comments::gather_comments_and_literals(\n-            span_diagnostic,\n-            filename,\n-            input);\n-\n-        State::new(\n-            cm,\n-            out,\n-            ann,\n-            Some(cmnts),\n-            // If the code is post expansion, don't use the table of\n-            // literals, since it doesn't correspond with the literals\n-            // in the AST anymore.\n-            if is_expanded { None } else { Some(lits) })\n+                          is_expanded: bool)\n+                          -> State<'a> {\n+        let (cmnts, lits) = comments::gather_comments_and_literals(span_diagnostic,\n+                                                                   filename,\n+                                                                   input);\n+\n+        State::new(cm,\n+                   out,\n+                   ann,\n+                   Some(cmnts),\n+                   // If the code is post expansion, don't use the table of\n+                   // literals, since it doesn't correspond with the literals\n+                   // in the AST anymore.\n+                   if is_expanded {\n+                       None\n+                   } else {\n+                       Some(lits)\n+                   })\n     }\n \n     pub fn new(cm: &'a CodeMap,\n-               out: Box<Write+'a>,\n+               out: Box<Write + 'a>,\n                ann: &'a PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>) -> State<'a> {\n+               literals: Option<Vec<comments::Literal>>)\n+               -> State<'a> {\n         State {\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments: comments.clone(),\n             literals: literals.clone(),\n             cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n                 cur_cmnt: 0,\n-                cur_lit: 0\n+                cur_lit: 0,\n             },\n             boxes: Vec::new(),\n             ann: ann,\n         }\n     }\n }\n \n-pub fn to_string<F>(f: F) -> String where\n-    F: FnOnce(&mut State) -> io::Result<()>,\n+pub fn to_string<F>(f: F) -> String\n+    where F: FnOnce(&mut State) -> io::Result<()>\n {\n     let mut wr = Vec::new();\n     {\n@@ -194,16 +196,16 @@ pub fn to_string<F>(f: F) -> String where\n \n pub fn binop_to_string(op: BinOpToken) -> &'static str {\n     match op {\n-        token::Plus     => \"+\",\n-        token::Minus    => \"-\",\n-        token::Star     => \"*\",\n-        token::Slash    => \"/\",\n-        token::Percent  => \"%\",\n-        token::Caret    => \"^\",\n-        token::And      => \"&\",\n-        token::Or       => \"|\",\n-        token::Shl      => \"<<\",\n-        token::Shr      => \">>\",\n+        token::Plus => \"+\",\n+        token::Minus => \"-\",\n+        token::Star => \"*\",\n+        token::Slash => \"/\",\n+        token::Percent => \"%\",\n+        token::Caret => \"^\",\n+        token::And => \"&\",\n+        token::Or => \"|\",\n+        token::Shl => \"<<\",\n+        token::Shr => \">>\",\n     }\n }\n \n@@ -276,8 +278,14 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n                      -> String {\n     to_string(|s| {\n         try!(s.head(\"\"));\n-        try!(s.print_fn(decl, unsafety, constness, abi::Rust, Some(name),\n-                        generics, opt_explicit_self, hir::Inherited));\n+        try!(s.print_fn(decl,\n+                        unsafety,\n+                        constness,\n+                        abi::Rust,\n+                        Some(name),\n+                        generics,\n+                        opt_explicit_self,\n+                        hir::Inherited));\n         try!(s.end()); // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -308,15 +316,17 @@ pub fn arg_to_string(arg: &hir::Arg) -> String {\n pub fn visibility_qualified(vis: hir::Visibility, s: &str) -> String {\n     match vis {\n         hir::Public => format!(\"pub {}\", s),\n-        hir::Inherited => s.to_string()\n+        hir::Inherited => s.to_string(),\n     }\n }\n \n fn needs_parentheses(expr: &hir::Expr) -> bool {\n     match expr.node {\n-        hir::ExprAssign(..) | hir::ExprBinary(..) |\n+        hir::ExprAssign(..) |\n+        hir::ExprBinary(..) |\n         hir::ExprClosure(..) |\n-        hir::ExprAssignOp(..) | hir::ExprCast(..) => true,\n+        hir::ExprAssignOp(..) |\n+        hir::ExprCast(..) => true,\n         _ => false,\n     }\n }\n@@ -327,7 +337,9 @@ impl<'a> State<'a> {\n         pp::cbox(&mut self.s, u)\n     }\n \n-    pub fn nbsp(&mut self) -> io::Result<()> { word(&mut self.s, \" \") }\n+    pub fn nbsp(&mut self) -> io::Result<()> {\n+        word(&mut self.s, \" \")\n+    }\n \n     pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n         try!(word(&mut self.s, w));\n@@ -351,12 +363,14 @@ impl<'a> State<'a> {\n         self.end() // close the head-box\n     }\n \n-    pub fn bclose_(&mut self, span: codemap::Span,\n-                   indented: usize) -> io::Result<()> {\n+    pub fn bclose_(&mut self, span: codemap::Span, indented: usize) -> io::Result<()> {\n         self.bclose_maybe_open(span, indented, true)\n     }\n-    pub fn bclose_maybe_open (&mut self, span: codemap::Span,\n-                              indented: usize, close_box: bool) -> io::Result<()> {\n+    pub fn bclose_maybe_open(&mut self,\n+                             span: codemap::Span,\n+                             indented: usize,\n+                             close_box: bool)\n+                             -> io::Result<()> {\n         try!(self.maybe_print_comment(span.hi));\n         try!(self.break_offset_if_not_bol(1, -(indented as isize)));\n         try!(word(&mut self.s, \"}\"));\n@@ -372,15 +386,16 @@ impl<'a> State<'a> {\n     pub fn in_cbox(&self) -> bool {\n         match self.boxes.last() {\n             Some(&last_box) => last_box == pp::Breaks::Consistent,\n-            None => false\n+            None => false,\n         }\n     }\n     pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n-        if !self.is_bol() { try!(space(&mut self.s)); }\n+        if !self.is_bol() {\n+            try!(space(&mut self.s));\n+        }\n         Ok(())\n     }\n-    pub fn break_offset_if_not_bol(&mut self, n: usize,\n-                                   off: isize) -> io::Result<()> {\n+    pub fn break_offset_if_not_bol(&mut self, n: usize, off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n             break_offset(&mut self.s, n, off)\n         } else {\n@@ -409,9 +424,10 @@ impl<'a> State<'a> {\n                                   b: Breaks,\n                                   elts: &[T],\n                                   mut op: F,\n-                                  mut get_span: G) -> io::Result<()> where\n-        F: FnMut(&mut State, &T) -> io::Result<()>,\n-        G: FnMut(&T) -> codemap::Span,\n+                                  mut get_span: G)\n+                                  -> io::Result<()>\n+        where F: FnMut(&mut State, &T) -> io::Result<()>,\n+              G: FnMut(&T) -> codemap::Span\n     {\n         try!(self.rbox(0, b));\n         let len = elts.len();\n@@ -422,39 +438,37 @@ impl<'a> State<'a> {\n             i += 1;\n             if i < len {\n                 try!(word(&mut self.s, \",\"));\n-                try!(self.maybe_print_trailing_comment(get_span(elt),\n-                                                    Some(get_span(&elts[i]).hi)));\n+                try!(self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi)));\n                 try!(self.space_if_not_bol());\n             }\n         }\n         self.end()\n     }\n \n-    pub fn commasep_exprs(&mut self, b: Breaks,\n-                          exprs: &[P<hir::Expr>]) -> io::Result<()> {\n+    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n     }\n \n-    pub fn print_mod(&mut self, _mod: &hir::Mod,\n-                     attrs: &[ast::Attribute]) -> io::Result<()> {\n+    pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &_mod.items {\n             try!(self.print_item(&**item));\n         }\n         Ok(())\n     }\n \n-    pub fn print_foreign_mod(&mut self, nmod: &hir::ForeignMod,\n-                             attrs: &[ast::Attribute]) -> io::Result<()> {\n+    pub fn print_foreign_mod(&mut self,\n+                             nmod: &hir::ForeignMod,\n+                             attrs: &[ast::Attribute])\n+                             -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &nmod.items {\n             try!(self.print_foreign_item(&**item));\n         }\n         Ok(())\n     }\n \n-    pub fn print_opt_lifetime(&mut self,\n-                              lifetime: &Option<hir::Lifetime>) -> io::Result<()> {\n+    pub fn print_opt_lifetime(&mut self, lifetime: &Option<hir::Lifetime>) -> io::Result<()> {\n         if let Some(l) = *lifetime {\n             try!(self.print_lifetime(&l));\n             try!(self.nbsp());\n@@ -486,8 +500,7 @@ impl<'a> State<'a> {\n             }\n             hir::TyTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, &elts[..],\n-                                   |s, ty| s.print_type(&**ty)));\n+                try!(self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&**ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n@@ -507,12 +520,7 @@ impl<'a> State<'a> {\n                         predicates: Vec::new(),\n                     },\n                 };\n-                try!(self.print_ty_fn(f.abi,\n-                                      f.unsafety,\n-                                      &*f.decl,\n-                                      None,\n-                                      &generics,\n-                                      None));\n+                try!(self.print_ty_fn(f.abi, f.unsafety, &*f.decl, None, &generics, None));\n             }\n             hir::TyPath(None, ref path) => {\n                 try!(self.print_path(path, false, 0));\n@@ -546,25 +554,27 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_foreign_item(&mut self,\n-                              item: &hir::ForeignItem) -> io::Result<()> {\n+    pub fn print_foreign_item(&mut self, item: &hir::ForeignItem) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n         try!(self.print_outer_attributes(&item.attrs));\n         match item.node {\n             hir::ForeignItemFn(ref decl, ref generics) => {\n                 try!(self.head(\"\"));\n-                try!(self.print_fn(decl, hir::Unsafety::Normal,\n+                try!(self.print_fn(decl,\n+                                   hir::Unsafety::Normal,\n                                    hir::Constness::NotConst,\n-                                   abi::Rust, Some(item.name),\n-                                   generics, None, item.vis));\n+                                   abi::Rust,\n+                                   Some(item.name),\n+                                   generics,\n+                                   None,\n+                                   item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemStatic(ref t, m) => {\n-                try!(self.head(&visibility_qualified(item.vis,\n-                                                    \"static\")));\n+                try!(self.head(&visibility_qualified(item.vis, \"static\")));\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -583,8 +593,7 @@ impl<'a> State<'a> {\n                               ty: &hir::Ty,\n                               default: Option<&hir::Expr>,\n                               vis: hir::Visibility)\n-                              -> io::Result<()>\n-    {\n+                              -> io::Result<()> {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n         try!(self.word_space(\"const\"));\n         try!(self.print_name(name));\n@@ -624,8 +633,7 @@ impl<'a> State<'a> {\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n             hir::ItemExternCrate(ref optional_path) => {\n-                try!(self.head(&visibility_qualified(item.vis,\n-                                                     \"extern crate\")));\n+                try!(self.head(&visibility_qualified(item.vis, \"extern crate\")));\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n                     if val.contains(\"-\") {\n@@ -643,16 +651,14 @@ impl<'a> State<'a> {\n                 try!(self.end()); // end outer head-block\n             }\n             hir::ItemUse(ref vp) => {\n-                try!(self.head(&visibility_qualified(item.vis,\n-                                                     \"use\")));\n+                try!(self.head(&visibility_qualified(item.vis, \"use\")));\n                 try!(self.print_view_path(&**vp));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n             }\n             hir::ItemStatic(ref ty, m, ref expr) => {\n-                try!(self.head(&visibility_qualified(item.vis,\n-                                                    \"static\")));\n+                try!(self.head(&visibility_qualified(item.vis, \"static\")));\n                 if m == hir::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -668,8 +674,7 @@ impl<'a> State<'a> {\n                 try!(self.end()); // end the outer cbox\n             }\n             hir::ItemConst(ref ty, ref expr) => {\n-                try!(self.head(&visibility_qualified(item.vis,\n-                                                    \"const\")));\n+                try!(self.head(&visibility_qualified(item.vis, \"const\")));\n                 try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n@@ -683,22 +688,19 @@ impl<'a> State<'a> {\n             }\n             hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n                 try!(self.head(\"\"));\n-                try!(self.print_fn(\n-                    decl,\n-                    unsafety,\n-                    constness,\n-                    abi,\n-                    Some(item.name),\n-                    typarams,\n-                    None,\n-                    item.vis\n-                ));\n+                try!(self.print_fn(decl,\n+                                   unsafety,\n+                                   constness,\n+                                   abi,\n+                                   Some(item.name),\n+                                   typarams,\n+                                   None,\n+                                   item.vis));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.print_block_with_attrs(&**body, &item.attrs));\n             }\n             hir::ItemMod(ref _mod) => {\n-                try!(self.head(&visibility_qualified(item.vis,\n-                                                    \"mod\")));\n+                try!(self.head(&visibility_qualified(item.vis, \"mod\")));\n                 try!(self.print_name(item.name));\n                 try!(self.nbsp());\n                 try!(self.bopen());\n@@ -728,16 +730,10 @@ impl<'a> State<'a> {\n                 try!(self.end()); // end the outer ibox\n             }\n             hir::ItemEnum(ref enum_definition, ref params) => {\n-                try!(self.print_enum_def(\n-                    enum_definition,\n-                    params,\n-                    item.name,\n-                    item.span,\n-                    item.vis\n-                ));\n+                try!(self.print_enum_def(enum_definition, params, item.name, item.span, item.vis));\n             }\n             hir::ItemStruct(ref struct_def, ref generics) => {\n-                try!(self.head(&visibility_qualified(item.vis,\"struct\")));\n+                try!(self.head(&visibility_qualified(item.vis, \"struct\")));\n                 try!(self.print_struct(&**struct_def, generics, item.name, item.span));\n             }\n \n@@ -772,7 +768,7 @@ impl<'a> State<'a> {\n                 match polarity {\n                     hir::ImplPolarity::Negative => {\n                         try!(word(&mut self.s, \"!\"));\n-                    },\n+                    }\n                     _ => {}\n                 }\n \n@@ -851,10 +847,13 @@ impl<'a> State<'a> {\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n-    pub fn print_enum_def(&mut self, enum_definition: &hir::EnumDef,\n-                          generics: &hir::Generics, name: ast::Name,\n+    pub fn print_enum_def(&mut self,\n+                          enum_definition: &hir::EnumDef,\n+                          generics: &hir::Generics,\n+                          name: ast::Name,\n                           span: codemap::Span,\n-                          visibility: hir::Visibility) -> io::Result<()> {\n+                          visibility: hir::Visibility)\n+                          -> io::Result<()> {\n         try!(self.head(&visibility_qualified(visibility, \"enum\")));\n         try!(self.print_name(name));\n         try!(self.print_generics(generics));\n@@ -865,7 +864,8 @@ impl<'a> State<'a> {\n \n     pub fn print_variants(&mut self,\n                           variants: &[P<hir::Variant>],\n-                          span: codemap::Span) -> io::Result<()> {\n+                          span: codemap::Span)\n+                          -> io::Result<()> {\n         try!(self.bopen());\n         for v in variants {\n             try!(self.space_if_not_bol());\n@@ -883,33 +883,33 @@ impl<'a> State<'a> {\n     pub fn print_visibility(&mut self, vis: hir::Visibility) -> io::Result<()> {\n         match vis {\n             hir::Public => self.word_nbsp(\"pub\"),\n-            hir::Inherited => Ok(())\n+            hir::Inherited => Ok(()),\n         }\n     }\n \n     pub fn print_struct(&mut self,\n                         struct_def: &hir::StructDef,\n                         generics: &hir::Generics,\n                         name: ast::Name,\n-                        span: codemap::Span) -> io::Result<()> {\n+                        span: codemap::Span)\n+                        -> io::Result<()> {\n         try!(self.print_name(name));\n         try!(self.print_generics(generics));\n         if ::util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n-                try!(self.commasep(\n-                    Inconsistent, &struct_def.fields,\n-                    |s, field| {\n-                        match field.node.kind {\n-                            hir::NamedField(..) => panic!(\"unexpected named field\"),\n-                            hir::UnnamedField(vis) => {\n-                                try!(s.print_visibility(vis));\n-                                try!(s.maybe_print_comment(field.span.lo));\n-                                s.print_type(&*field.node.ty)\n-                            }\n-                        }\n-                    }\n-                ));\n+                try!(self.commasep(Inconsistent,\n+                                   &struct_def.fields,\n+                                   |s, field| {\n+                                       match field.node.kind {\n+                                           hir::NamedField(..) => panic!(\"unexpected named field\"),\n+                                           hir::UnnamedField(vis) => {\n+                                               try!(s.print_visibility(vis));\n+                                               try!(s.maybe_print_comment(field.span.lo));\n+                                               s.print_type(&*field.node.ty)\n+                                           }\n+                                       }\n+                                   }));\n                 try!(self.pclose());\n             }\n             try!(self.print_where_clause(&generics.where_clause));\n@@ -948,9 +948,7 @@ impl<'a> State<'a> {\n                 try!(self.print_name(v.node.name));\n                 if !args.is_empty() {\n                     try!(self.popen());\n-                    try!(self.commasep(Consistent,\n-                                       &args[..],\n-                                       |s, arg| s.print_type(&*arg.ty)));\n+                    try!(self.commasep(Consistent, &args[..], |s, arg| s.print_type(&*arg.ty)));\n                     try!(self.pclose());\n                 }\n             }\n@@ -966,7 +964,7 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"=\"));\n                 self.print_expr(&**d)\n             }\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n \n@@ -985,15 +983,15 @@ impl<'a> State<'a> {\n                       vis)\n     }\n \n-    pub fn print_trait_item(&mut self, ti: &hir::TraitItem)\n-                            -> io::Result<()> {\n+    pub fn print_trait_item(&mut self, ti: &hir::TraitItem) -> io::Result<()> {\n         try!(self.ann.pre(self, NodeSubItem(ti.id)));\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n             hir::ConstTraitItem(ref ty, ref default) => {\n-                try!(self.print_associated_const(ti.name, &ty,\n+                try!(self.print_associated_const(ti.name,\n+                                                 &ty,\n                                                  default.as_ref().map(|expr| &**expr),\n                                                  hir::Inherited));\n             }\n@@ -1010,7 +1008,8 @@ impl<'a> State<'a> {\n                 }\n             }\n             hir::TypeTraitItem(ref bounds, ref default) => {\n-                try!(self.print_associated_type(ti.name, Some(bounds),\n+                try!(self.print_associated_type(ti.name,\n+                                                Some(bounds),\n                                                 default.as_ref().map(|ty| &**ty)));\n             }\n         }\n@@ -1069,25 +1068,29 @@ impl<'a> State<'a> {\n         self.print_block_unclosed_indent(blk, indent_unit)\n     }\n \n-    pub fn print_block_unclosed_indent(&mut self, blk: &hir::Block,\n-                                       indented: usize) -> io::Result<()> {\n+    pub fn print_block_unclosed_indent(&mut self,\n+                                       blk: &hir::Block,\n+                                       indented: usize)\n+                                       -> io::Result<()> {\n         self.print_block_maybe_unclosed(blk, indented, &[], false)\n     }\n \n     pub fn print_block_with_attrs(&mut self,\n                                   blk: &hir::Block,\n-                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n+                                  attrs: &[ast::Attribute])\n+                                  -> io::Result<()> {\n         self.print_block_maybe_unclosed(blk, indent_unit, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(&mut self,\n                                       blk: &hir::Block,\n                                       indented: usize,\n                                       attrs: &[ast::Attribute],\n-                                      close_box: bool) -> io::Result<()> {\n+                                      close_box: bool)\n+                                      -> io::Result<()> {\n         match blk.rules {\n             hir::UnsafeBlock(..) | hir::PushUnsafeBlock(..) => try!(self.word_space(\"unsafe\")),\n-            hir::DefaultBlock    | hir::PopUnsafeBlock(..) => ()\n+            hir::DefaultBlock | hir::PopUnsafeBlock(..) => (),\n         }\n         try!(self.maybe_print_comment(blk.span.lo));\n         try!(self.ann.pre(self, NodeBlock(blk)));\n@@ -1104,7 +1107,7 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**expr));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n-            _ => ()\n+            _ => (),\n         }\n         try!(self.bclose_maybe_open(blk.span, indented, close_box));\n         self.ann.post(self, NodeBlock(blk))\n@@ -1137,21 +1140,28 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n \n-    pub fn print_if(&mut self, test: &hir::Expr, blk: &hir::Block,\n-                    elseopt: Option<&hir::Expr>) -> io::Result<()> {\n+    pub fn print_if(&mut self,\n+                    test: &hir::Expr,\n+                    blk: &hir::Block,\n+                    elseopt: Option<&hir::Expr>)\n+                    -> io::Result<()> {\n         try!(self.head(\"if\"));\n         try!(self.print_expr(test));\n         try!(space(&mut self.s));\n         try!(self.print_block(blk));\n         self.print_else(elseopt)\n     }\n \n-    pub fn print_if_let(&mut self, pat: &hir::Pat, expr: &hir::Expr, blk: &hir::Block,\n-                        elseopt: Option<&hir::Expr>) -> io::Result<()> {\n+    pub fn print_if_let(&mut self,\n+                        pat: &hir::Pat,\n+                        expr: &hir::Expr,\n+                        blk: &hir::Block,\n+                        elseopt: Option<&hir::Expr>)\n+                        -> io::Result<()> {\n         try!(self.head(\"if let\"));\n         try!(self.print_pat(pat));\n         try!(space(&mut self.s));\n@@ -1189,9 +1199,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    fn print_expr_repeat(&mut self,\n-                         element: &hir::Expr,\n-                         count: &hir::Expr) -> io::Result<()> {\n+    fn print_expr_repeat(&mut self, element: &hir::Expr, count: &hir::Expr) -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n         try!(word(&mut self.s, \"[\"));\n         try!(self.print_expr(element));\n@@ -1204,20 +1212,20 @@ impl<'a> State<'a> {\n     fn print_expr_struct(&mut self,\n                          path: &hir::Path,\n                          fields: &[hir::Field],\n-                         wth: &Option<P<hir::Expr>>) -> io::Result<()> {\n+                         wth: &Option<P<hir::Expr>>)\n+                         -> io::Result<()> {\n         try!(self.print_path(path, true, 0));\n         try!(word(&mut self.s, \"{\"));\n-        try!(self.commasep_cmnt(\n-            Consistent,\n-            &fields[..],\n-            |s, field| {\n-                try!(s.ibox(indent_unit));\n-                try!(s.print_name(field.name.node));\n-                try!(s.word_space(\":\"));\n-                try!(s.print_expr(&*field.expr));\n-                s.end()\n-            },\n-            |f| f.span));\n+        try!(self.commasep_cmnt(Consistent,\n+                                &fields[..],\n+                                |s, field| {\n+                                    try!(s.ibox(indent_unit));\n+                                    try!(s.print_name(field.name.node));\n+                                    try!(s.word_space(\":\"));\n+                                    try!(s.print_expr(&*field.expr));\n+                                    s.end()\n+                                },\n+                                |f| f.span));\n         match *wth {\n             Some(ref expr) => {\n                 try!(self.ibox(indent_unit));\n@@ -1231,7 +1239,7 @@ impl<'a> State<'a> {\n             }\n             _ => if !fields.is_empty() {\n                 try!(word(&mut self.s, \",\"))\n-            }\n+            },\n         }\n         try!(word(&mut self.s, \"}\"));\n         Ok(())\n@@ -1246,25 +1254,23 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    fn print_expr_call(&mut self,\n-                       func: &hir::Expr,\n-                       args: &[P<hir::Expr>]) -> io::Result<()> {\n+    fn print_expr_call(&mut self, func: &hir::Expr, args: &[P<hir::Expr>]) -> io::Result<()> {\n         try!(self.print_expr_maybe_paren(func));\n         self.print_call_post(args)\n     }\n \n     fn print_expr_method_call(&mut self,\n                               name: Spanned<ast::Name>,\n                               tys: &[P<hir::Ty>],\n-                              args: &[P<hir::Expr>]) -> io::Result<()> {\n+                              args: &[P<hir::Expr>])\n+                              -> io::Result<()> {\n         let base_args = &args[1..];\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_name(name.node));\n         if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n-            try!(self.commasep(Inconsistent, tys,\n-                               |s, ty| s.print_type(&**ty)));\n+            try!(self.commasep(Inconsistent, tys, |s, ty| s.print_type(&**ty)));\n             try!(word(&mut self.s, \">\"));\n         }\n         self.print_call_post(base_args)\n@@ -1273,23 +1279,23 @@ impl<'a> State<'a> {\n     fn print_expr_binary(&mut self,\n                          op: hir::BinOp,\n                          lhs: &hir::Expr,\n-                         rhs: &hir::Expr) -> io::Result<()> {\n+                         rhs: &hir::Expr)\n+                         -> io::Result<()> {\n         try!(self.print_expr(lhs));\n         try!(space(&mut self.s));\n         try!(self.word_space(::util::binop_to_string(op.node)));\n         self.print_expr(rhs)\n     }\n \n-    fn print_expr_unary(&mut self,\n-                        op: hir::UnOp,\n-                        expr: &hir::Expr) -> io::Result<()> {\n+    fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) -> io::Result<()> {\n         try!(word(&mut self.s, ::util::unop_to_string(op)));\n         self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_addr_of(&mut self,\n                           mutability: hir::Mutability,\n-                          expr: &hir::Expr) -> io::Result<()> {\n+                          expr: &hir::Expr)\n+                          -> io::Result<()> {\n         try!(word(&mut self.s, \"&\"));\n         try!(self.print_mutability(mutability));\n         self.print_expr_maybe_paren(expr)\n@@ -1382,7 +1388,7 @@ impl<'a> State<'a> {\n \n                 let default_return = match decl.output {\n                     hir::DefaultReturn(..) => true,\n-                    _ => false\n+                    _ => false,\n                 };\n \n                 if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n@@ -1479,7 +1485,7 @@ impl<'a> State<'a> {\n                         try!(word(&mut self.s, \" \"));\n                         try!(self.print_expr(&**expr));\n                     }\n-                    _ => ()\n+                    _ => (),\n                 }\n             }\n             hir::ExprInlineAsm(ref a) => {\n@@ -1488,39 +1494,42 @@ impl<'a> State<'a> {\n                 try!(self.print_string(&a.asm, a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.outputs,\n+                try!(self.commasep(Inconsistent,\n+                                   &a.outputs,\n                                    |s, &(ref co, ref o, is_rw)| {\n-                    match co.slice_shift_char() {\n-                        Some(('=', operand)) if is_rw => {\n-                            try!(s.print_string(&format!(\"+{}\", operand),\n-                                                ast::CookedStr))\n-                        }\n-                        _ => try!(s.print_string(&co, ast::CookedStr))\n-                    }\n-                    try!(s.popen());\n-                    try!(s.print_expr(&**o));\n-                    try!(s.pclose());\n-                    Ok(())\n-                }));\n+                                       match co.slice_shift_char() {\n+                                           Some(('=', operand)) if is_rw => {\n+                                               try!(s.print_string(&format!(\"+{}\", operand),\n+                                                                   ast::CookedStr))\n+                                           }\n+                                           _ => try!(s.print_string(&co, ast::CookedStr)),\n+                                       }\n+                                       try!(s.popen());\n+                                       try!(s.print_expr(&**o));\n+                                       try!(s.pclose());\n+                                       Ok(())\n+                                   }));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.inputs,\n+                try!(self.commasep(Inconsistent,\n+                                   &a.inputs,\n                                    |s, &(ref co, ref o)| {\n-                    try!(s.print_string(&co, ast::CookedStr));\n-                    try!(s.popen());\n-                    try!(s.print_expr(&**o));\n-                    try!(s.pclose());\n-                    Ok(())\n-                }));\n+                                       try!(s.print_string(&co, ast::CookedStr));\n+                                       try!(s.popen());\n+                                       try!(s.print_expr(&**o));\n+                                       try!(s.pclose());\n+                                       Ok(())\n+                                   }));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.clobbers,\n+                try!(self.commasep(Inconsistent,\n+                                   &a.clobbers,\n                                    |s, co| {\n-                    try!(s.print_string(&co, ast::CookedStr));\n-                    Ok(())\n-                }));\n+                                       try!(s.print_string(&co, ast::CookedStr));\n+                                       Ok(())\n+                                   }));\n \n                 let mut options = vec!();\n                 if a.volatile {\n@@ -1536,11 +1545,12 @@ impl<'a> State<'a> {\n                 if !options.is_empty() {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n-                    try!(self.commasep(Inconsistent, &*options,\n+                    try!(self.commasep(Inconsistent,\n+                                       &*options,\n                                        |s, &co| {\n-                        try!(s.print_string(co, ast::CookedStr));\n-                        Ok(())\n-                    }));\n+                                           try!(s.print_string(co, ast::CookedStr));\n+                                           Ok(())\n+                                       }));\n                 }\n \n                 try!(self.pclose());\n@@ -1577,7 +1587,7 @@ impl<'a> State<'a> {\n                 }\n                 self.end()\n             }\n-            hir::DeclItem(ref item) => self.print_item(&**item)\n+            hir::DeclItem(ref item) => self.print_item(&**item),\n         }\n     }\n \n@@ -1590,8 +1600,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeName(&name))\n     }\n \n-    pub fn print_for_decl(&mut self, loc: &hir::Local,\n-                          coll: &hir::Expr) -> io::Result<()> {\n+    pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) -> io::Result<()> {\n         try!(self.print_local_decl(loc));\n         try!(space(&mut self.s));\n         try!(self.word_space(\"in\"));\n@@ -1602,8 +1611,7 @@ impl<'a> State<'a> {\n                   path: &hir::Path,\n                   colons_before_params: bool,\n                   depth: usize)\n-                  -> io::Result<()>\n-    {\n+                  -> io::Result<()> {\n         try!(self.maybe_print_comment(path.span.lo));\n \n         let mut first = !path.global;\n@@ -1626,8 +1634,7 @@ impl<'a> State<'a> {\n                    path: &hir::Path,\n                    qself: &hir::QSelf,\n                    colons_before_params: bool)\n-                   -> io::Result<()>\n-    {\n+                   -> io::Result<()> {\n         try!(word(&mut self.s, \"<\"));\n         try!(self.print_type(&qself.ty));\n         if qself.position > 0 {\n@@ -1646,8 +1653,7 @@ impl<'a> State<'a> {\n     fn print_path_parameters(&mut self,\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n-                             -> io::Result<()>\n-    {\n+                             -> io::Result<()> {\n         if parameters.is_empty() {\n             return Ok(());\n         }\n@@ -1673,11 +1679,8 @@ impl<'a> State<'a> {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n-                    try!(self.commasep(\n-                        Inconsistent,\n-                        &data.types,\n-                        |s, ty| s.print_type(&**ty)));\n-                        comma = true;\n+                    try!(self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&**ty)));\n+                    comma = true;\n                 }\n \n                 for binding in data.bindings.iter() {\n@@ -1696,14 +1699,13 @@ impl<'a> State<'a> {\n \n             hir::ParenthesizedParameters(ref data) => {\n                 try!(word(&mut self.s, \"(\"));\n-                try!(self.commasep(\n-                    Inconsistent,\n-                    &data.inputs,\n-                    |s, ty| s.print_type(&**ty)));\n+                try!(self.commasep(Inconsistent,\n+                                   &data.inputs,\n+                                   |s, ty| s.print_type(&**ty)));\n                 try!(word(&mut self.s, \")\"));\n \n                 match data.output {\n-                    None => { }\n+                    None => {}\n                     Some(ref ty) => {\n                         try!(self.space_if_not_bol());\n                         try!(self.word_space(\"->\"));\n@@ -1741,7 +1743,7 @@ impl<'a> State<'a> {\n                         try!(word(&mut self.s, \"@\"));\n                         try!(self.print_pat(&**p));\n                     }\n-                    None => ()\n+                    None => (),\n                 }\n             }\n             hir::PatEnum(ref path, ref args_) => {\n@@ -1751,8 +1753,7 @@ impl<'a> State<'a> {\n                     Some(ref args) => {\n                         if !args.is_empty() {\n                             try!(self.popen());\n-                            try!(self.commasep(Inconsistent, &args[..],\n-                                              |s, p| s.print_pat(&**p)));\n+                            try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&**p)));\n                             try!(self.pclose());\n                         }\n                     }\n@@ -1765,30 +1766,30 @@ impl<'a> State<'a> {\n                 try!(self.print_path(path, true, 0));\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n-                try!(self.commasep_cmnt(\n-                    Consistent, &fields[..],\n-                    |s, f| {\n-                        try!(s.cbox(indent_unit));\n-                        if !f.node.is_shorthand {\n-                            try!(s.print_name(f.node.name));\n-                            try!(s.word_nbsp(\":\"));\n-                        }\n-                        try!(s.print_pat(&*f.node.pat));\n-                        s.end()\n-                    },\n-                    |f| f.node.pat.span));\n+                try!(self.commasep_cmnt(Consistent,\n+                                        &fields[..],\n+                                        |s, f| {\n+                                            try!(s.cbox(indent_unit));\n+                                            if !f.node.is_shorthand {\n+                                                try!(s.print_name(f.node.name));\n+                                                try!(s.word_nbsp(\":\"));\n+                                            }\n+                                            try!(s.print_pat(&*f.node.pat));\n+                                            s.end()\n+                                        },\n+                                        |f| f.node.pat.span));\n                 if etc {\n-                    if !fields.is_empty() { try!(self.word_space(\",\")); }\n+                    if !fields.is_empty() {\n+                        try!(self.word_space(\",\"));\n+                    }\n                     try!(word(&mut self.s, \"..\"));\n                 }\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"}\"));\n             }\n             hir::PatTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent,\n-                                   &elts[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&**p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n@@ -1814,23 +1815,23 @@ impl<'a> State<'a> {\n             }\n             hir::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep(Inconsistent,\n-                                   &before[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&**p)));\n                 if let Some(ref p) = *slice {\n-                    if !before.is_empty() { try!(self.word_space(\",\")); }\n+                    if !before.is_empty() {\n+                        try!(self.word_space(\",\"));\n+                    }\n                     try!(self.print_pat(&**p));\n                     match **p {\n                         hir::Pat { node: hir::PatWild(hir::PatWildMulti), .. } => {\n                             // this case is handled by print_pat\n                         }\n                         _ => try!(word(&mut self.s, \"..\")),\n                     }\n-                    if !after.is_empty() { try!(self.word_space(\",\")); }\n+                    if !after.is_empty() {\n+                        try!(self.word_space(\",\"));\n+                    }\n                 }\n-                try!(self.commasep(Inconsistent,\n-                                   &after[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&**p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n         }\n@@ -1886,10 +1887,13 @@ impl<'a> State<'a> {\n     // Returns whether it printed anything\n     fn print_explicit_self(&mut self,\n                            explicit_self: &hir::ExplicitSelf_,\n-                           mutbl: hir::Mutability) -> io::Result<bool> {\n+                           mutbl: hir::Mutability)\n+                           -> io::Result<bool> {\n         try!(self.print_mutability(mutbl));\n         match *explicit_self {\n-            hir::SelfStatic => { return Ok(false); }\n+            hir::SelfStatic => {\n+                return Ok(false);\n+            }\n             hir::SelfValue(_) => {\n                 try!(word(&mut self.s, \"self\"));\n             }\n@@ -1916,7 +1920,8 @@ impl<'a> State<'a> {\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n-                    vis: hir::Visibility) -> io::Result<()> {\n+                    vis: hir::Visibility)\n+                    -> io::Result<()> {\n         try!(self.print_fn_header_info(unsafety, constness, abi, vis));\n \n         if let Some(name) = name {\n@@ -1928,9 +1933,10 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    pub fn print_fn_args(&mut self, decl: &hir::FnDecl,\n+    pub fn print_fn_args(&mut self,\n+                         decl: &hir::FnDecl,\n                          opt_explicit_self: Option<&hir::ExplicitSelf_>)\n-        -> io::Result<()> {\n+                         -> io::Result<()> {\n         // It is unfortunate to duplicate the commasep logic, but we want the\n         // self type and the args all in the same box.\n         try!(self.rbox(0, Inconsistent));\n@@ -1940,8 +1946,8 @@ impl<'a> State<'a> {\n                 &hir::SelfStatic => hir::MutImmutable,\n                 _ => match decl.inputs[0].pat.node {\n                     hir::PatIdent(hir::BindByValue(m), _, _) => m,\n-                    _ => hir::MutImmutable\n-                }\n+                    _ => hir::MutImmutable,\n+                },\n             };\n             first = !try!(self.print_explicit_self(explicit_self, m));\n         }\n@@ -1954,16 +1960,21 @@ impl<'a> State<'a> {\n         };\n \n         for arg in args {\n-            if first { first = false; } else { try!(self.word_space(\",\")); }\n+            if first {\n+                first = false;\n+            } else {\n+                try!(self.word_space(\",\"));\n+            }\n             try!(self.print_arg(arg));\n         }\n \n         self.end()\n     }\n \n-    pub fn print_fn_args_and_ret(&mut self, decl: &hir::FnDecl,\n+    pub fn print_fn_args_and_ret(&mut self,\n+                                 decl: &hir::FnDecl,\n                                  opt_explicit_self: Option<&hir::ExplicitSelf_>)\n-        -> io::Result<()> {\n+                                 -> io::Result<()> {\n         try!(self.popen());\n         try!(self.print_fn_args(decl, opt_explicit_self));\n         if decl.variadic {\n@@ -1974,10 +1985,7 @@ impl<'a> State<'a> {\n         self.print_fn_output(decl)\n     }\n \n-    pub fn print_fn_block_args(\n-            &mut self,\n-            decl: &hir::FnDecl)\n-            -> io::Result<()> {\n+    pub fn print_fn_block_args(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         try!(word(&mut self.s, \"|\"));\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n@@ -2001,18 +2009,14 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_capture_clause(&mut self, capture_clause: hir::CaptureClause)\n-                                -> io::Result<()> {\n+    pub fn print_capture_clause(&mut self, capture_clause: hir::CaptureClause) -> io::Result<()> {\n         match capture_clause {\n             hir::CaptureByValue => self.word_space(\"move\"),\n             hir::CaptureByRef => Ok(()),\n         }\n     }\n \n-    pub fn print_bounds(&mut self,\n-                        prefix: &str,\n-                        bounds: &[hir::TyParamBound])\n-                        -> io::Result<()> {\n+    pub fn print_bounds(&mut self, prefix: &str, bounds: &[hir::TyParamBound]) -> io::Result<()> {\n         if !bounds.is_empty() {\n             try!(word(&mut self.s, prefix));\n             let mut first = true;\n@@ -2043,17 +2047,11 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_lifetime(&mut self,\n-                          lifetime: &hir::Lifetime)\n-                          -> io::Result<()>\n-    {\n+    pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n         self.print_name(lifetime.name)\n     }\n \n-    pub fn print_lifetime_def(&mut self,\n-                              lifetime: &hir::LifetimeDef)\n-                              -> io::Result<()>\n-    {\n+    pub fn print_lifetime_def(&mut self, lifetime: &hir::LifetimeDef) -> io::Result<()> {\n         try!(self.print_lifetime(&lifetime.lifetime));\n         let mut sep = \":\";\n         for v in &lifetime.bounds {\n@@ -2064,10 +2062,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_generics(&mut self,\n-                          generics: &hir::Generics)\n-                          -> io::Result<()>\n-    {\n+    pub fn print_generics(&mut self, generics: &hir::Generics) -> io::Result<()> {\n         let total = generics.lifetimes.len() + generics.ty_params.len();\n         if total == 0 {\n             return Ok(());\n@@ -2080,16 +2075,18 @@ impl<'a> State<'a> {\n             ints.push(i);\n         }\n \n-        try!(self.commasep(Inconsistent, &ints[..], |s, &idx| {\n-            if idx < generics.lifetimes.len() {\n-                let lifetime = &generics.lifetimes[idx];\n-                s.print_lifetime_def(lifetime)\n-            } else {\n-                let idx = idx - generics.lifetimes.len();\n-                let param = &generics.ty_params[idx];\n-                s.print_ty_param(param)\n-            }\n-        }));\n+        try!(self.commasep(Inconsistent,\n+                           &ints[..],\n+                           |s, &idx| {\n+                               if idx < generics.lifetimes.len() {\n+                                   let lifetime = &generics.lifetimes[idx];\n+                                   s.print_lifetime_def(lifetime)\n+                               } else {\n+                                   let idx = idx - generics.lifetimes.len();\n+                                   let param = &generics.ty_params[idx];\n+                                   s.print_ty_param(param)\n+                               }\n+                           }));\n \n         try!(word(&mut self.s, \">\"));\n         Ok(())\n@@ -2104,12 +2101,11 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"=\"));\n                 self.print_type(&**default)\n             }\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n \n-    pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause)\n-                              -> io::Result<()> {\n+    pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause) -> io::Result<()> {\n         if where_clause.predicates.is_empty() {\n             return Ok(())\n         }\n@@ -2183,23 +2179,24 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false, 0));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n-                try!(self.commasep(Inconsistent, &segments[..], |s, w| {\n-                    match w.node {\n-                        hir::PathListIdent { name, .. } => {\n-                            s.print_name(name)\n-                        },\n-                        hir::PathListMod { .. } => {\n-                            word(&mut s.s, \"self\")\n-                        }\n-                    }\n-                }));\n+                try!(self.commasep(Inconsistent,\n+                                   &segments[..],\n+                                   |s, w| {\n+                                       match w.node {\n+                                           hir::PathListIdent { name, .. } => {\n+                                               s.print_name(name)\n+                                           }\n+                                           hir::PathListMod { .. } => {\n+                                               word(&mut s.s, \"self\")\n+                                           }\n+                                       }\n+                                   }));\n                 word(&mut self.s, \"}\")\n             }\n         }\n     }\n \n-    pub fn print_mutability(&mut self,\n-                            mutbl: hir::Mutability) -> io::Result<()> {\n+    pub fn print_mutability(&mut self, mutbl: hir::Mutability) -> io::Result<()> {\n         match mutbl {\n             hir::MutMutable => self.word_nbsp(\"mut\"),\n             hir::MutImmutable => Ok(()),\n@@ -2243,17 +2240,15 @@ impl<'a> State<'a> {\n         try!(self.ibox(indent_unit));\n         try!(self.word_space(\"->\"));\n         match decl.output {\n-            hir::NoReturn(_) =>\n-                try!(self.word_nbsp(\"!\")),\n+            hir::NoReturn(_) => try!(self.word_nbsp(\"!\")),\n             hir::DefaultReturn(..) => unreachable!(),\n-            hir::Return(ref ty) =>\n-                try!(self.print_type(&**ty))\n+            hir::Return(ref ty) => try!(self.print_type(&**ty)),\n         }\n         try!(self.end());\n \n         match decl.output {\n             hir::Return(ref output) => self.maybe_print_comment(output.span.lo),\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n \n@@ -2289,27 +2284,33 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn maybe_print_trailing_comment(&mut self, span: codemap::Span,\n+    pub fn maybe_print_trailing_comment(&mut self,\n+                                        span: codemap::Span,\n                                         next_pos: Option<BytePos>)\n-        -> io::Result<()> {\n+                                        -> io::Result<()> {\n         let cm = match self.cm {\n             Some(cm) => cm,\n-            _ => return Ok(())\n+            _ => return Ok(()),\n         };\n         match self.next_comment() {\n             Some(ref cmnt) => {\n-                if (*cmnt).style != comments::Trailing { return Ok(()) }\n+                if (*cmnt).style != comments::Trailing {\n+                    return Ok(())\n+                }\n                 let span_line = cm.lookup_char_pos(span.hi);\n                 let comment_line = cm.lookup_char_pos((*cmnt).pos);\n                 let mut next = (*cmnt).pos + BytePos(1);\n-                match next_pos { None => (), Some(p) => next = p }\n+                match next_pos {\n+                    None => (),\n+                    Some(p) => next = p,\n+                }\n                 if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n-                    span_line.line == comment_line.line {\n-                        try!(self.print_comment(cmnt));\n-                        self.cur_cmnt_and_lit.cur_cmnt += 1;\n-                    }\n+                   span_line.line == comment_line.line {\n+                    try!(self.print_comment(cmnt));\n+                    self.cur_cmnt_and_lit.cur_cmnt += 1;\n+                }\n             }\n-            _ => ()\n+            _ => (),\n         }\n         Ok(())\n     }\n@@ -2326,47 +2327,47 @@ impl<'a> State<'a> {\n                     try!(self.print_comment(cmnt));\n                     self.cur_cmnt_and_lit.cur_cmnt += 1;\n                 }\n-                _ => break\n+                _ => break,\n             }\n         }\n         Ok(())\n     }\n \n     pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n                                                   opt_abi: Option<abi::Abi>)\n-        -> io::Result<()> {\n+                                                  -> io::Result<()> {\n         match opt_abi {\n             Some(abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n                 self.word_nbsp(&abi.to_string())\n             }\n-            None => Ok(())\n+            None => Ok(()),\n         }\n     }\n \n-    pub fn print_extern_opt_abi(&mut self,\n-                                opt_abi: Option<abi::Abi>) -> io::Result<()> {\n+    pub fn print_extern_opt_abi(&mut self, opt_abi: Option<abi::Abi>) -> io::Result<()> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n                 self.word_nbsp(&abi.to_string())\n             }\n-            None => Ok(())\n+            None => Ok(()),\n         }\n     }\n \n     pub fn print_fn_header_info(&mut self,\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n                                 abi: abi::Abi,\n-                                vis: hir::Visibility) -> io::Result<()> {\n+                                vis: hir::Visibility)\n+                                -> io::Result<()> {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n         try!(self.print_unsafety(unsafety));\n \n         match constness {\n             hir::Constness::NotConst => {}\n-            hir::Constness::Const => try!(self.word_nbsp(\"const\"))\n+            hir::Constness::Const => try!(self.word_nbsp(\"const\")),\n         }\n \n         if abi != abi::Rust {\n@@ -2395,12 +2396,12 @@ impl<'a> State<'a> {\n /// isn't parsed as (if true {...} else {...} | x) | 5\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n-        hir::ExprIf(..)\n-        | hir::ExprMatch(..)\n-        | hir::ExprBlock(_)\n-        | hir::ExprWhile(..)\n-        | hir::ExprLoop(..) => false,\n-        _ => true\n+        hir::ExprIf(..) |\n+        hir::ExprMatch(..) |\n+        hir::ExprBlock(_) |\n+        hir::ExprWhile(..) |\n+        hir::ExprLoop(..) => false,\n+        _ => true,\n     }\n }\n \n@@ -2412,10 +2413,14 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n         hir::StmtDecl(ref d, _) => {\n             match d.node {\n                 hir::DeclLocal(_) => true,\n-                hir::DeclItem(_) => false\n+                hir::DeclItem(_) => false,\n             }\n         }\n-        hir::StmtExpr(ref e, _) => { expr_requires_semi_to_be_stmt(&**e) }\n-        hir::StmtSemi(..) => { false }\n+        hir::StmtExpr(ref e, _) => {\n+            expr_requires_semi_to_be_stmt(&**e)\n+        }\n+        hir::StmtSemi(..) => {\n+            false\n+        }\n     }\n }"}, {"sha": "c6b2a2acc2b8d5b34e2a6cb39af6564ebb533c3f", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "patch": "@@ -17,9 +17,13 @@ use syntax::codemap::Span;\n use syntax::ptr::P;\n use syntax::owned_slice::OwnedSlice;\n \n-pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n+pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n+    where F: FnMut(&Pat) -> bool\n+{\n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_pat_<G>(pat: &Pat, it: &mut G) -> bool where G: FnMut(&Pat) -> bool {\n+    fn walk_pat_<G>(pat: &Pat, it: &mut G) -> bool\n+        where G: FnMut(&Pat) -> bool\n+    {\n         if !(*it)(pat) {\n             return false;\n         }\n@@ -40,8 +44,12 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n                 slice.iter().all(|p| walk_pat_(&**p, it)) &&\n                 after.iter().all(|p| walk_pat_(&**p, it))\n             }\n-            PatWild(_) | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n-            PatEnum(_, _) | PatQPath(_, _) => {\n+            PatWild(_) |\n+            PatLit(_) |\n+            PatRange(_, _) |\n+            PatIdent(_, _, _) |\n+            PatEnum(_, _) |\n+            PatQPath(_, _) => {\n                 true\n             }\n         }\n@@ -69,7 +77,7 @@ pub fn binop_to_string(op: BinOp_) -> &'static str {\n         BiLe => \"<=\",\n         BiNe => \"!=\",\n         BiGe => \">=\",\n-        BiGt => \">\"\n+        BiGt => \">\",\n     }\n }\n \n@@ -81,35 +89,43 @@ pub fn struct_def_is_tuple_like(struct_def: &hir::StructDef) -> bool {\n \n pub fn stmt_id(s: &Stmt) -> NodeId {\n     match s.node {\n-      StmtDecl(_, id) => id,\n-      StmtExpr(_, id) => id,\n-      StmtSemi(_, id) => id,\n+        StmtDecl(_, id) => id,\n+        StmtExpr(_, id) => id,\n+        StmtSemi(_, id) => id,\n     }\n }\n \n pub fn lazy_binop(b: BinOp_) -> bool {\n     match b {\n-      BiAnd => true,\n-      BiOr => true,\n-      _ => false\n+        BiAnd => true,\n+        BiOr => true,\n+        _ => false,\n     }\n }\n \n pub fn is_shift_binop(b: BinOp_) -> bool {\n     match b {\n-      BiShl => true,\n-      BiShr => true,\n-      _ => false\n+        BiShl => true,\n+        BiShr => true,\n+        _ => false,\n     }\n }\n \n pub fn is_comparison_binop(b: BinOp_) -> bool {\n     match b {\n-        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe =>\n-            true,\n-        BiAnd | BiOr | BiAdd | BiSub | BiMul | BiDiv | BiRem |\n-        BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr =>\n-            false,\n+        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n+        BiAnd |\n+        BiOr |\n+        BiAdd |\n+        BiSub |\n+        BiMul |\n+        BiDiv |\n+        BiRem |\n+        BiBitXor |\n+        BiBitAnd |\n+        BiBitOr |\n+        BiShl |\n+        BiShr => false,\n     }\n }\n \n@@ -134,7 +150,7 @@ pub fn unop_to_string(op: UnOp) -> &'static str {\n     }\n }\n \n-pub struct IdVisitor<'a, O:'a> {\n+pub struct IdVisitor<'a, O: 'a> {\n     pub operation: &'a mut O,\n     pub pass_through_items: bool,\n     pub visited_outermost: bool,\n@@ -152,10 +168,7 @@ impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n }\n \n impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n-    fn visit_mod(&mut self,\n-                 module: &Mod,\n-                 _: Span,\n-                 node_id: NodeId) {\n+    fn visit_mod(&mut self, module: &Mod, _: Span, node_id: NodeId) {\n         self.operation.visit_id(node_id);\n         visit::walk_mod(self, module)\n     }\n@@ -265,11 +278,7 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n             self.operation.visit_id(argument.id)\n         }\n \n-        visit::walk_fn(self,\n-                       function_kind,\n-                       function_declaration,\n-                       block,\n-                       span);\n+        visit::walk_fn(self, function_kind, function_declaration, block, span);\n \n         if !self.pass_through_items {\n             if let FnKind::Method(..) = function_kind {\n@@ -323,11 +332,8 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n                                     body: &Block,\n                                     sp: Span,\n                                     id: NodeId)\n-                                    -> ast_util::IdRange\n-{\n-    let mut visitor = ast_util::IdRangeComputingVisitor {\n-        result: ast_util::IdRange::max()\n-    };\n+                                    -> ast_util::IdRange {\n+    let mut visitor = ast_util::IdRangeComputingVisitor { result: ast_util::IdRange::max() };\n     let mut id_visitor = IdVisitor {\n         operation: &mut visitor,\n         pass_through_items: false,\n@@ -338,7 +344,10 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n }\n \n pub fn is_path(e: P<Expr>) -> bool {\n-    match e.node { ExprPath(..) => true, _ => false }\n+    match e.node {\n+        ExprPath(..) => true,\n+        _ => false,\n+    }\n }\n \n pub fn empty_generics() -> Generics {\n@@ -348,7 +357,7 @@ pub fn empty_generics() -> Generics {\n         where_clause: WhereClause {\n             id: DUMMY_NODE_ID,\n             predicates: Vec::new(),\n-        }\n+        },\n     }\n }\n \n@@ -358,15 +367,13 @@ pub fn ident_to_path(s: Span, ident: Ident) -> Path {\n     hir::Path {\n         span: s,\n         global: false,\n-        segments: vec!(\n-            hir::PathSegment {\n-                identifier: ident,\n-                parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n-                    bindings: OwnedSlice::empty(),\n-                })\n-            }\n-        ),\n+        segments: vec!(hir::PathSegment {\n+            identifier: ident,\n+            parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n+                lifetimes: Vec::new(),\n+                types: OwnedSlice::empty(),\n+                bindings: OwnedSlice::empty(),\n+            }),\n+        }),\n     }\n }"}, {"sha": "9e91ab34d089a9da5d848212245a4c7dc9698c49", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 90, "deletions": 51, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869e9719fdd6dd77e9910a6eb012e4bc4a50f535/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=869e9719fdd6dd77e9910a6eb012e4bc4a50f535", "patch": "@@ -56,25 +56,56 @@ pub trait Visitor<'v> : Sized {\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n         walk_ident(self, span, ident);\n     }\n-    fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n-    fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n-    fn visit_item(&mut self, i: &'v Item) { walk_item(self, i) }\n-    fn visit_local(&mut self, l: &'v Local) { walk_local(self, l) }\n-    fn visit_block(&mut self, b: &'v Block) { walk_block(self, b) }\n-    fn visit_stmt(&mut self, s: &'v Stmt) { walk_stmt(self, s) }\n-    fn visit_arm(&mut self, a: &'v Arm) { walk_arm(self, a) }\n-    fn visit_pat(&mut self, p: &'v Pat) { walk_pat(self, p) }\n-    fn visit_decl(&mut self, d: &'v Decl) { walk_decl(self, d) }\n-    fn visit_expr(&mut self, ex: &'v Expr) { walk_expr(self, ex) }\n-    fn visit_expr_post(&mut self, _ex: &'v Expr) { }\n-    fn visit_ty(&mut self, t: &'v Ty) { walk_ty(self, t) }\n-    fn visit_generics(&mut self, g: &'v Generics) { walk_generics(self, g) }\n+    fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) {\n+        walk_mod(self, m)\n+    }\n+    fn visit_foreign_item(&mut self, i: &'v ForeignItem) {\n+        walk_foreign_item(self, i)\n+    }\n+    fn visit_item(&mut self, i: &'v Item) {\n+        walk_item(self, i)\n+    }\n+    fn visit_local(&mut self, l: &'v Local) {\n+        walk_local(self, l)\n+    }\n+    fn visit_block(&mut self, b: &'v Block) {\n+        walk_block(self, b)\n+    }\n+    fn visit_stmt(&mut self, s: &'v Stmt) {\n+        walk_stmt(self, s)\n+    }\n+    fn visit_arm(&mut self, a: &'v Arm) {\n+        walk_arm(self, a)\n+    }\n+    fn visit_pat(&mut self, p: &'v Pat) {\n+        walk_pat(self, p)\n+    }\n+    fn visit_decl(&mut self, d: &'v Decl) {\n+        walk_decl(self, d)\n+    }\n+    fn visit_expr(&mut self, ex: &'v Expr) {\n+        walk_expr(self, ex)\n+    }\n+    fn visit_expr_post(&mut self, _ex: &'v Expr) {\n+    }\n+    fn visit_ty(&mut self, t: &'v Ty) {\n+        walk_ty(self, t)\n+    }\n+    fn visit_generics(&mut self, g: &'v Generics) {\n+        walk_generics(self, g)\n+    }\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, b, s)\n     }\n-    fn visit_trait_item(&mut self, ti: &'v TraitItem) { walk_trait_item(self, ti) }\n-    fn visit_impl_item(&mut self, ii: &'v ImplItem) { walk_impl_item(self, ii) }\n-    fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n+    fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n+        walk_trait_item(self, ti)\n+    }\n+    fn visit_impl_item(&mut self, ii: &'v ImplItem) {\n+        walk_impl_item(self, ii)\n+    }\n+    fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n+        walk_trait_ref(self, t)\n+    }\n     fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n     }\n@@ -84,13 +115,16 @@ pub trait Visitor<'v> : Sized {\n     fn visit_struct_def(&mut self, s: &'v StructDef, _: Name, _: &'v Generics, _: NodeId) {\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &'v StructField) { walk_struct_field(self, s) }\n-    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n-                      generics: &'v Generics) {\n+    fn visit_struct_field(&mut self, s: &'v StructField) {\n+        walk_struct_field(self, s)\n+    }\n+    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef, generics: &'v Generics) {\n         walk_enum_def(self, enum_definition, generics)\n     }\n \n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) { walk_variant(self, v, g) }\n+    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) {\n+        walk_variant(self, v, g)\n+    }\n \n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n@@ -116,7 +150,8 @@ pub trait Visitor<'v> : Sized {\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n         walk_assoc_type_binding(self, type_binding)\n     }\n-    fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n+    fn visit_attribute(&mut self, _attr: &'v Attribute) {\n+    }\n     fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n         walk_macro_def(self, macro_def)\n     }\n@@ -164,16 +199,14 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n     visitor.visit_name(lifetime.span, lifetime.name);\n }\n \n-pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              lifetime_def: &'v LifetimeDef) {\n+pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V, lifetime_def: &'v LifetimeDef) {\n     visitor.visit_lifetime(&lifetime_def.lifetime);\n     walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n-pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              explicit_self: &'v ExplicitSelf) {\n+pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V, explicit_self: &'v ExplicitSelf) {\n     match explicit_self.node {\n-        SelfStatic => {},\n+        SelfStatic => {}\n         SelfValue(name) => {\n             visitor.visit_name(explicit_self.span, name)\n         }\n@@ -193,12 +226,13 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   _modifier: &'v TraitBoundModifier)\n     where V: Visitor<'v>\n {\n-    walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n+    walk_list!(visitor,\n+               visit_lifetime_def,\n+               &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n-pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n-                                   trait_ref: &'v TraitRef)\n+pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n     where V: Visitor<'v>\n {\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n@@ -236,8 +270,12 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_expr(expr);\n         }\n         ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n-            visitor.visit_fn(FnKind::ItemFn(item.name, generics, unsafety,\n-                                            constness, abi, item.vis),\n+            visitor.visit_fn(FnKind::ItemFn(item.name,\n+                                            generics,\n+                                            unsafety,\n+                                            constness,\n+                                            abi,\n+                                            item.vis),\n                              declaration,\n                              body,\n                              item.span,\n@@ -272,10 +310,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_struct_def(struct_definition,\n-                                     item.name,\n-                                     generics,\n-                                     item.id)\n+            visitor.visit_struct_def(struct_definition, item.name, generics, item.id)\n         }\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n@@ -333,7 +368,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         }\n         TyBareFn(ref function_declaration) => {\n             walk_fn_decl(visitor, &function_declaration.decl);\n-            walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n+            walk_list!(visitor,\n+                       visit_lifetime_def,\n+                       &function_declaration.lifetimes);\n         }\n         TyPath(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n@@ -365,7 +402,8 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     }\n }\n \n-pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, prefix: &'v Path,\n+pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                               prefix: &'v Path,\n                                                item: &'v PathListItem) {\n     for segment in &prefix.segments {\n         visitor.visit_path_segment(prefix.span, segment);\n@@ -448,8 +486,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     }\n }\n \n-pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             foreign_item: &'v ForeignItem) {\n+pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem) {\n     visitor.visit_name(foreign_item.span, foreign_item.name);\n \n     match foreign_item.node {\n@@ -463,8 +500,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n     walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n }\n \n-pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                               bound: &'v TyParamBound) {\n+pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v TyParamBound) {\n     match *bound {\n         TraitTyParamBound(ref typ, ref modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n@@ -530,8 +566,7 @@ pub fn walk_fn_decl_nopat<'v, V: Visitor<'v>>(visitor: &mut V, function_declarat\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n-pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                        function_kind: FnKind<'v>) {\n+pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n     match function_kind {\n         FnKind::ItemFn(_, generics, _, _, _, _) => {\n             visitor.visit_generics(generics);\n@@ -568,8 +603,11 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_fn_decl(visitor, &sig.decl);\n         }\n         MethodTraitItem(ref sig, Some(ref body)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.name, sig, None), &sig.decl,\n-                             body, trait_item.span, trait_item.id);\n+            visitor.visit_fn(FnKind::Method(trait_item.name, sig, None),\n+                             &sig.decl,\n+                             body,\n+                             trait_item.span,\n+                             trait_item.id);\n         }\n         TypeTraitItem(ref bounds, ref default) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n@@ -587,22 +625,23 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_expr(expr);\n         }\n         MethodImplItem(ref sig, ref body) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.name, sig, Some(impl_item.vis)), &sig.decl,\n-                             body, impl_item.span, impl_item.id);\n+            visitor.visit_fn(FnKind::Method(impl_item.name, sig, Some(impl_item.vis)),\n+                             &sig.decl,\n+                             body,\n+                             impl_item.span,\n+                             impl_item.id);\n         }\n         TypeImplItem(ref ty) => {\n             visitor.visit_ty(ty);\n         }\n     }\n }\n \n-pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                           struct_definition: &'v StructDef) {\n+pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v StructDef) {\n     walk_list!(visitor, visit_struct_field, &struct_definition.fields);\n }\n \n-pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             struct_field: &'v StructField) {\n+pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField) {\n     walk_opt_name(visitor, struct_field.span, struct_field.node.name());\n     visitor.visit_ty(&struct_field.node.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.node.attrs);"}]}