{"sha": "50a0defd5a93523067ef239936cc2e0755220904", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYTBkZWZkNWE5MzUyMzA2N2VmMjM5OTM2Y2MyZTA3NTUyMjA5MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-21T06:37:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-21T06:37:03Z"}, "message": "Auto merge of #60903 - nnethercote:mv-gensyms-from-Symbol-to-Ident, r=petrochenkov\n\nMove gensym operations from `Symbol` to `Ident`\n\nGensyms are always at the `Ident` level, and long-term we probably want to record gensym-ness in hygiene data.\n\nr? @petrochenkov", "tree": {"sha": "34871483c741cd864f4d55a51d651b5fc1286f14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34871483c741cd864f4d55a51d651b5fc1286f14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50a0defd5a93523067ef239936cc2e0755220904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50a0defd5a93523067ef239936cc2e0755220904", "html_url": "https://github.com/rust-lang/rust/commit/50a0defd5a93523067ef239936cc2e0755220904", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50a0defd5a93523067ef239936cc2e0755220904/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46ad3e188287a3514de45ff89bac3cc451590d62", "url": "https://api.github.com/repos/rust-lang/rust/commits/46ad3e188287a3514de45ff89bac3cc451590d62", "html_url": "https://github.com/rust-lang/rust/commit/46ad3e188287a3514de45ff89bac3cc451590d62"}, {"sha": "88d29992bdd3d881b336b724675c59323e70e2e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d29992bdd3d881b336b724675c59323e70e2e7", "html_url": "https://github.com/rust-lang/rust/commit/88d29992bdd3d881b336b724675c59323e70e2e7"}], "stats": {"total": 138, "additions": 67, "deletions": 71}, "files": [{"sha": "6931b3542f7614c25a7314e7dbbd107da9f27697", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -140,7 +140,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n \n         // Generate the submodule itself\n         let name = f.kind.fn_name(\"allocator_abi\");\n-        let allocator_abi = Ident::with_empty_ctxt(Symbol::gensym(&name));\n+        let allocator_abi = Ident::from_str(&name).gensym();\n         let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n         let module = f.cx.monotonic_expander().flat_map_item(module).pop().unwrap();\n "}, {"sha": "3b58a99d19fe00b8389af4716511bd535327ec32", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -314,7 +314,7 @@ impl<'a> Resolver<'a> {\n                             Ident::new(keywords::SelfLower.name(), new_span)\n                         ),\n                         kind: ast::UseTreeKind::Simple(\n-                            Some(Ident::new(Name::gensym(\"__dummy\"), new_span)),\n+                            Some(Ident::from_str_and_span(\"__dummy\", new_span).gensym()),\n                             ast::DUMMY_NODE_ID,\n                             ast::DUMMY_NODE_ID,\n                         ),"}, {"sha": "c4a4dd306055bb92db05298eebe2bba46db2ef20", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -4225,7 +4225,7 @@ impl<'a> Resolver<'a> {\n         let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n-                    if !ident.name.is_gensymed() && filter_fn(binding.res()) {\n+                    if !ident.is_gensymed() && filter_fn(binding.res()) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: binding.res().article(),\n@@ -4243,7 +4243,7 @@ impl<'a> Resolver<'a> {\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n-                    if !ident.name.is_gensymed() && filter_fn(res) {\n+                    if !ident.is_gensymed() && filter_fn(res) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: res.article(),\n@@ -4273,7 +4273,7 @@ impl<'a> Resolver<'a> {\n                                             },\n                                         );\n \n-                                        if !ident.name.is_gensymed() && filter_fn(crate_mod) {\n+                                        if !ident.is_gensymed() && filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n                                                 candidate: ident.name,\n                                                 article: \"a\",\n@@ -4298,7 +4298,6 @@ impl<'a> Resolver<'a> {\n                 names.extend(\n                     self.primitive_type_table.primitive_types\n                         .iter()\n-                        .filter(|(name, _)| !name.is_gensymed())\n                         .map(|(name, _)| {\n                             TypoSuggestion {\n                                 candidate: *name,"}, {"sha": "3a6a8b56ff35d875b695f8d2c644ddaec78be745", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -1395,7 +1395,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // so they can cause name conflict errors downstream.\n             let is_good_import = binding.is_import() && !binding.is_ambiguity() &&\n                                  // Note that as_str() de-gensyms the Symbol\n-                                 !(ident.name.is_gensymed() && ident.name.as_str() != \"_\");\n+                                 !(ident.is_gensymed() && ident.name.as_str() != \"_\");\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {"}, {"sha": "a6bb47bef87e0ad5a9fc20fd4bf4abc3bd9d5023", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -72,11 +72,7 @@ pub struct Path {\n impl PartialEq<Symbol> for Path {\n     fn eq(&self, symbol: &Symbol) -> bool {\n         self.segments.len() == 1 && {\n-            let name = self.segments[0].ident.name;\n-            // Make sure these symbols are pure strings\n-            debug_assert!(!symbol.is_gensymed());\n-            debug_assert!(!name.is_gensymed());\n-            name == *symbol\n+            self.segments[0].ident.name == *symbol\n         }\n     }\n }"}, {"sha": "c988dc61bec449034082097b18c8ab4e7582a311", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -7,7 +7,7 @@ use crate::ext::base::{ExtCtxt, MacEager, MacResult};\n use crate::ext::build::AstBuilder;\n use crate::parse::token;\n use crate::ptr::P;\n-use crate::symbol::{keywords, Symbol};\n+use crate::symbol::keywords;\n use crate::tokenstream::{TokenTree};\n \n use smallvec::smallvec;\n@@ -121,13 +121,13 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n \n     let span = span.apply_mark(ecx.current_expansion.mark);\n \n-    let sym = Ident::new(Symbol::gensym(&format!(\"__register_diagnostic_{}\", code)), span);\n+    let name = Ident::from_str_and_span(&format!(\"__register_diagnostic_{}\", code), span).gensym();\n \n     MacEager::items(smallvec![\n         ecx.item_mod(\n             span,\n             span,\n-            sym,\n+            name,\n             vec![],\n             vec![],\n         )"}, {"sha": "672b7b4285522b1a13ba1911510257d0f80db99a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -252,8 +252,8 @@ pub fn compile(\n     def: &ast::Item,\n     edition: Edition\n ) -> SyntaxExtension {\n-    let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n-    let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n+    let lhs_nm = ast::Ident::from_str(\"lhs\").gensym();\n+    let rhs_nm = ast::Ident::from_str(\"rhs\").gensym();\n \n     // Parse the macro_rules! invocation\n     let body = match def.node {"}, {"sha": "1be7986ad53cd92665335e4d5c8ae1875cc658e3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -2,7 +2,7 @@ use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n use crate::ext::hygiene::{Mark, SyntaxContext};\n-use crate::symbol::{Symbol, keywords, sym};\n+use crate::symbol::{Ident, Symbol, keywords, sym};\n use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n use crate::ptr::P;\n use crate::tokenstream::TokenStream;\n@@ -63,18 +63,15 @@ pub fn maybe_inject_crates_ref(\n \n     // .rev() to preserve ordering above in combination with insert(0, ...)\n     let alt_std_name = alt_std_name.map(Symbol::intern);\n-    for orig_name in names.iter().rev() {\n-        let orig_name = Symbol::intern(orig_name);\n-        let mut rename = orig_name;\n+    for orig_name_str in names.iter().rev() {\n         // HACK(eddyb) gensym the injected crates on the Rust 2018 edition,\n         // so they don't accidentally interfere with the new import paths.\n-        if rust_2018 {\n-            rename = orig_name.gensymed();\n-        }\n-        let orig_name = if rename != orig_name {\n-            Some(orig_name)\n+        let orig_name_sym = Symbol::intern(orig_name_str);\n+        let orig_name_ident = Ident::with_empty_ctxt(orig_name_sym);\n+        let (rename, orig_name) = if rust_2018 {\n+            (orig_name_ident.gensym(), Some(orig_name_sym))\n         } else {\n-            None\n+            (orig_name_ident, None)\n         };\n         krate.module.items.insert(0, P(ast::Item {\n             attrs: vec![attr::mk_attr_outer(\n@@ -84,7 +81,7 @@ pub fn maybe_inject_crates_ref(\n             )],\n             vis: dummy_spanned(ast::VisibilityKind::Inherited),\n             node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n-            ident: ast::Ident::with_empty_ctxt(rename),\n+            ident: rename,\n             id: ast::DUMMY_NODE_ID,\n             span: DUMMY_SP,\n             tokens: None,"}, {"sha": "3dc7aad945939da2a34587643e9873606b5f35da", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -232,11 +232,11 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n         items,\n     };\n \n-    let sym = Ident::with_empty_ctxt(Symbol::gensym(\"__test_reexports\"));\n+    let name = Ident::from_str(\"__test_reexports\").gensym();\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().flat_map_item(P(ast::Item {\n-        ident: sym,\n+        ident: name,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n@@ -245,7 +245,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n         tokens: None,\n     })).pop().unwrap();\n \n-    (it, sym)\n+    (it, name)\n }\n \n /// Crawl over the crate, inserting test reexports and the test main function\n@@ -373,9 +373,10 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n                            main_body);\n \n     // Honor the reexport_test_harness_main attribute\n-    let main_id = Ident::new(\n-        cx.reexport_test_harness_main.unwrap_or(Symbol::gensym(\"main\")),\n-        sp);\n+    let main_id = match cx.reexport_test_harness_main {\n+        Some(sym) => Ident::new(sym, sp),\n+        None => Ident::from_str_and_span(\"main\", sp).gensym(),\n+    };\n \n     P(ast::Item {\n         ident: main_id,"}, {"sha": "200445d12488007102b6f7adc1cbca1ff0bc52a1", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -429,7 +429,7 @@ fn mk_decls(\n     let module = cx.item_mod(\n         span,\n         span,\n-        ast::Ident::with_empty_ctxt(Symbol::gensym(\"decls\")),\n+        ast::Ident::from_str(\"decls\").gensym(),\n         vec![doc_hidden],\n         vec![krate, decls_static],\n     ).map(|mut i| {"}, {"sha": "211a098022f98e65569620c8adcd664c5a670025", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -127,7 +127,7 @@ pub fn expand_test_or_bench(\n         ])\n     };\n \n-    let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name.gensymed(), sp),\n+    let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp).gensym(),\n         vec![\n             // #[cfg(test)]\n             cx.attribute(attr_sp, cx.meta_list(attr_sp, Symbol::intern(\"cfg\"), vec!["}, {"sha": "a07c7eb897ec1e42b00cb973fad8032b94ce5fc9", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0defd5a93523067ef239936cc2e0755220904/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=50a0defd5a93523067ef239936cc2e0755220904", "patch": "@@ -630,10 +630,12 @@ pub struct Ident {\n \n impl Ident {\n     #[inline]\n+    /// Constructs a new identifier from a symbol and a span.\n     pub const fn new(name: Symbol, span: Span) -> Ident {\n         Ident { name, span }\n     }\n \n+    /// Constructs a new identifier with an empty syntax context.\n     #[inline]\n     pub const fn with_empty_ctxt(name: Symbol) -> Ident {\n         Ident::new(name, DUMMY_SP)\n@@ -644,11 +646,16 @@ impl Ident {\n         Ident::with_empty_ctxt(string.as_symbol())\n     }\n \n-    /// Maps a string to an identifier with an empty syntax context.\n+    /// Maps a string to an identifier with an empty span.\n     pub fn from_str(string: &str) -> Ident {\n         Ident::with_empty_ctxt(Symbol::intern(string))\n     }\n \n+    /// Maps a string and a span to an identifier.\n+    pub fn from_str_and_span(string: &str, span: Span) -> Ident {\n+        Ident::new(Symbol::intern(string), span)\n+    }\n+\n     /// Replaces `lo` and `hi` with those from `span`, but keep hygiene context.\n     pub fn with_span_pos(self, span: Span) -> Ident {\n         Ident::new(self.name, span.with_ctxt(self.span.ctxt()))\n@@ -676,14 +683,23 @@ impl Ident {\n         Ident::new(self.name, self.span.modern_and_legacy())\n     }\n \n+    /// Transforms an identifier into one with the same name, but gensymed.\n     pub fn gensym(self) -> Ident {\n-        Ident::new(self.name.gensymed(), self.span)\n+        let name = with_interner(|interner| interner.gensymed(self.name));\n+        Ident::new(name, self.span)\n     }\n \n+    /// Transforms an underscore identifier into one with the same name, but\n+    /// gensymed. Leaves non-underscore identifiers unchanged.\n     pub fn gensym_if_underscore(self) -> Ident {\n         if self.name == keywords::Underscore.name() { self.gensym() } else { self }\n     }\n \n+    // WARNING: this function is deprecated and will be removed in the future.\n+    pub fn is_gensymed(self) -> bool {\n+        with_interner(|interner| interner.is_gensymed(self.name))\n+    }\n+\n     pub fn as_str(self) -> LocalInternedString {\n         self.name.as_str()\n     }\n@@ -736,30 +752,34 @@ impl Decodable for Ident {\n         Ok(if !string.starts_with('#') {\n             Ident::from_str(&string)\n         } else { // FIXME(jseyfried): intercrate hygiene\n-            Ident::with_empty_ctxt(Symbol::gensym(&string[1..]))\n+            Ident::from_str(&string[1..]).gensym()\n         })\n     }\n }\n \n /// A symbol is an interned or gensymed string. A gensym is a symbol that is\n-/// never equal to any other symbol. E.g.:\n-/// ```\n-/// assert_eq!(Symbol::intern(\"x\"), Symbol::intern(\"x\"))\n-/// assert_ne!(Symbol::gensym(\"x\"), Symbol::intern(\"x\"))\n-/// assert_ne!(Symbol::gensym(\"x\"), Symbol::gensym(\"x\"))\n-/// ```\n+/// never equal to any other symbol.\n+///\n /// Conceptually, a gensym can be thought of as a normal symbol with an\n /// invisible unique suffix. Gensyms are useful when creating new identifiers\n /// that must not match any existing identifiers, e.g. during macro expansion\n-/// and syntax desugaring.\n+/// and syntax desugaring. Because gensyms should always be identifiers, all\n+/// gensym operations are on `Ident` rather than `Symbol`. (Indeed, in the\n+/// future the gensym-ness may be moved from `Symbol` to hygiene data.)\n ///\n-/// Internally, a Symbol is implemented as an index, and all operations\n+/// Examples:\n+/// ```\n+/// assert_eq!(Ident::from_str(\"x\"), Ident::from_str(\"x\"))\n+/// assert_ne!(Ident::from_str(\"x\").gensym(), Ident::from_str(\"x\"))\n+/// assert_ne!(Ident::from_str(\"x\").gensym(), Ident::from_str(\"x\").gensym())\n+/// ```\n+/// Internally, a symbol is implemented as an index, and all operations\n /// (including hashing, equality, and ordering) operate on that index. The use\n /// of `newtype_index!` means that `Option<Symbol>` only takes up 4 bytes,\n /// because `newtype_index!` reserves the last 256 values for tagging purposes.\n ///\n-/// Note that `Symbol` cannot directly be a `newtype_index!` because it implements\n-/// `fmt::Debug`, `Encodable`, and `Decodable` in special ways.\n+/// Note that `Symbol` cannot directly be a `newtype_index!` because it\n+/// implements `fmt::Debug`, `Encodable`, and `Decodable` in special ways.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Symbol(SymbolIndex);\n \n@@ -777,20 +797,6 @@ impl Symbol {\n         with_interner(|interner| interner.intern(string))\n     }\n \n-    /// Gensyms a new `usize`, using the current interner.\n-    pub fn gensym(string: &str) -> Self {\n-        with_interner(|interner| interner.gensym(string))\n-    }\n-\n-    pub fn gensymed(self) -> Self {\n-        with_interner(|interner| interner.gensymed(self))\n-    }\n-\n-    // WARNING: this function is deprecated and will be removed in the future.\n-    pub fn is_gensymed(self) -> bool {\n-        with_interner(|interner| interner.is_gensymed(self))\n-    }\n-\n     pub fn as_str(self) -> LocalInternedString {\n         with_interner(|interner| unsafe {\n             LocalInternedString {\n@@ -898,11 +904,6 @@ impl Interner {\n         }\n     }\n \n-    fn gensym(&mut self, string: &str) -> Symbol {\n-        let symbol = self.intern(string);\n-        self.gensymed(symbol)\n-    }\n-\n     fn gensymed(&mut self, symbol: Symbol) -> Symbol {\n         self.gensyms.push(symbol);\n         Symbol::new(SymbolIndex::MAX_AS_U32 - self.gensyms.len() as u32 + 1)\n@@ -1288,11 +1289,13 @@ mod tests {\n         assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n         // dog is still at zero\n         assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n-        assert_eq!(i.gensym(\"zebra\"), Symbol::new(SymbolIndex::MAX_AS_U32));\n+        let z = i.intern(\"zebra\");\n+        assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32));\n         // gensym of same string gets new number:\n-        assert_eq!(i.gensym(\"zebra\"), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n+        assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n+        let d = i.intern(\"dog\");\n+        assert_eq!(i.gensymed(d), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n     }\n \n     #[test]"}]}