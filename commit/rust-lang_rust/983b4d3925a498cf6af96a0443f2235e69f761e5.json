{"sha": "983b4d3925a498cf6af96a0443f2235e69f761e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4M2I0ZDM5MjVhNDk4Y2Y2YWY5NmEwNDQzZjIyMzVlNjlmNzYxZTU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-04T06:00:27Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-09T02:31:06Z"}, "message": "Refactor the interface that `resolve` exposes to `driver`", "tree": {"sha": "87878d6bd07d731167fcd3f97b04f36d0975c588", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87878d6bd07d731167fcd3f97b04f36d0975c588"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/983b4d3925a498cf6af96a0443f2235e69f761e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/983b4d3925a498cf6af96a0443f2235e69f761e5", "html_url": "https://github.com/rust-lang/rust/commit/983b4d3925a498cf6af96a0443f2235e69f761e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/983b4d3925a498cf6af96a0443f2235e69f761e5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84284472533b1e48e6365f6c37b644d0fe00647a", "url": "https://api.github.com/repos/rust-lang/rust/commits/84284472533b1e48e6365f6c37b644d0fe00647a", "html_url": "https://github.com/rust-lang/rust/commit/84284472533b1e48e6365f6c37b644d0fe00647a"}], "stats": {"total": 140, "additions": 56, "deletions": 84}, "files": [{"sha": "efe899a78fd440add02a029c353578813884b3fd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/983b4d3925a498cf6af96a0443f2235e69f761e5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/983b4d3925a498cf6af96a0443f2235e69f761e5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=983b4d3925a498cf6af96a0443f2235e69f761e5", "patch": "@@ -61,6 +61,13 @@ use syntax::visit;\n use syntax;\n use syntax_ext;\n \n+pub struct Resolutions {\n+    pub def_map: RefCell<DefMap>,\n+    pub freevars: FreevarMap,\n+    pub trait_map: TraitMap,\n+    pub maybe_unused_trait_imports: NodeSet,\n+}\n+\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      cfg: ast::CrateConfig,\n@@ -147,23 +154,25 @@ pub fn compile_input(sess: &Session,\n              \"early lint checks\",\n              || lint::check_ast_crate(sess, &expanded_crate));\n \n-        let resolve::CrateMap {\n-            def_map,\n-            freevars,\n-            maybe_unused_trait_imports,\n-            export_map,\n-            trait_map,\n-            glob_map,\n-        } = time(sess.time_passes(), \"name resolution\", || {\n-            resolve::resolve_crate(sess, &expanded_crate, &defs.borrow(), control.make_glob_map)\n-        });\n-\n-        let analysis = ty::CrateAnalysis {\n-            export_map: export_map,\n-            access_levels: AccessLevels::default(),\n-            reachable: NodeSet(),\n-            name: &id,\n-            glob_map: glob_map,\n+        let (analysis, resolutions) = {\n+            resolve::with_resolver(sess, &defs.borrow(), control.make_glob_map, |mut resolver| {\n+                time(sess.time_passes(), \"name resolution\", || {\n+                    resolve::resolve_crate(&mut resolver, &expanded_crate);\n+                });\n+\n+                (ty::CrateAnalysis {\n+                    export_map: resolver.export_map,\n+                    access_levels: AccessLevels::default(),\n+                    reachable: NodeSet(),\n+                    name: &id,\n+                    glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n+                }, Resolutions {\n+                    def_map: RefCell::new(resolver.def_map),\n+                    freevars: resolver.freevars,\n+                    trait_map: resolver.trait_map,\n+                    maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n+                })\n+            })\n         };\n \n         // Lower ast -> hir.\n@@ -218,13 +227,10 @@ pub fn compile_input(sess: &Session,\n \n         phase_3_run_analysis_passes(sess,\n                                     hir_map,\n+                                    analysis,\n+                                    resolutions,\n                                     &arenas,\n                                     &id,\n-                                    analysis,\n-                                    def_map,\n-                                    freevars,\n-                                    trait_map,\n-                                    maybe_unused_trait_imports,\n                                     |tcx, mir_map, analysis, result| {\n             {\n                 // Eventually, we will want to track plugins.\n@@ -785,13 +791,10 @@ pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n+                                               mut analysis: ty::CrateAnalysis,\n+                                               resolutions: Resolutions,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n-                                               mut analysis: ty::CrateAnalysis,\n-                                               def_map: RefCell<DefMap>,\n-                                               freevars: FreevarMap,\n-                                               trait_map: TraitMap,\n-                                               maybe_unused_trait_imports: NodeSet,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: FnOnce(&TyCtxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n@@ -820,7 +823,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                 \"lifetime resolution\",\n                                 || middle::resolve_lifetime::krate(sess,\n                                                                    &hir_map,\n-                                                                   &def_map.borrow()))?;\n+                                                                   &resolutions.def_map.borrow()))?;\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -840,17 +843,18 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n               \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &def_map.borrow(), &hir_map))?;\n+              || static_recursion::check_crate(sess, &resolutions.def_map.borrow(), &hir_map))?;\n \n     let index = stability::Index::new(&hir_map);\n \n+    let trait_map = resolutions.trait_map;\n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             def_map,\n+                             resolutions.def_map,\n                              named_region_map,\n                              hir_map,\n-                             freevars,\n-                             maybe_unused_trait_imports,\n+                             resolutions.freevars,\n+                             resolutions.maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "2ed35cdd0ad798c533da6d2b6d1d5ad2013e9235", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 52, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/983b4d3925a498cf6af96a0443f2235e69f761e5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/983b4d3925a498cf6af96a0443f2235e69f761e5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=983b4d3925a498cf6af96a0443f2235e69f761e5", "patch": "@@ -995,11 +995,11 @@ pub struct Resolver<'a> {\n     // The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n-    def_map: DefMap,\n-    freevars: FreevarMap,\n+    pub def_map: DefMap,\n+    pub freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n-    export_map: ExportMap,\n-    trait_map: TraitMap,\n+    pub export_map: ExportMap,\n+    pub trait_map: TraitMap,\n \n     // A map from nodes to modules, both normal (`mod`) modules and anonymous modules.\n     // Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -1022,14 +1022,14 @@ pub struct Resolver<'a> {\n     // so as to avoid printing duplicate errors\n     emit_errors: bool,\n \n-    make_glob_map: bool,\n+    pub make_glob_map: bool,\n     // Maps imports to the names of items actually imported (this actually maps\n     // all imports, but only glob imports are actually interesting).\n-    glob_map: GlobMap,\n+    pub glob_map: GlobMap,\n \n     used_imports: HashSet<(NodeId, Namespace)>,\n     used_crates: HashSet<CrateNum>,\n-    maybe_unused_trait_imports: NodeSet,\n+    pub maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n \n@@ -3563,27 +3563,14 @@ fn err_path_resolution() -> PathResolution {\n }\n \n \n-pub struct CrateMap {\n-    pub def_map: RefCell<DefMap>,\n-    pub freevars: FreevarMap,\n-    pub maybe_unused_trait_imports: NodeSet,\n-    pub export_map: ExportMap,\n-    pub trait_map: TraitMap,\n-    pub glob_map: Option<GlobMap>,\n-}\n-\n #[derive(PartialEq,Copy, Clone)]\n pub enum MakeGlobMap {\n     Yes,\n     No,\n }\n \n /// Entry point to crate resolution.\n-pub fn resolve_crate<'a>(session: &'a Session,\n-                         krate: &'a Crate,\n-                         definitions: &'a Definitions,\n-                         make_glob_map: MakeGlobMap)\n-                         -> CrateMap {\n+pub fn resolve_crate<'a, 'b>(resolver: &'b mut Resolver<'a>, krate: &'b Crate) {\n     // Currently, we ignore the name resolution data structures for\n     // the purposes of dependency tracking. Instead we will run name\n     // resolution and include its output in the hash of each item,\n@@ -3592,42 +3579,23 @@ pub fn resolve_crate<'a>(session: &'a Session,\n     // resolution on those contents. Hopefully we'll push this back at\n     // some point.\n \n-    let arenas = Resolver::arenas();\n-    let mut resolver = create_resolver(session, definitions, krate, make_glob_map, &arenas);\n-\n+    resolver.build_reduced_graph(krate);\n+    resolve_imports::resolve_imports(resolver);\n     resolver.resolve_crate(krate);\n \n-    check_unused::check_crate(&mut resolver, krate);\n+    check_unused::check_crate(resolver, krate);\n     resolver.report_privacy_errors();\n-\n-    CrateMap {\n-        def_map: RefCell::new(resolver.def_map),\n-        freevars: resolver.freevars,\n-        maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-        export_map: resolver.export_map,\n-        trait_map: resolver.trait_map,\n-        glob_map: if resolver.make_glob_map {\n-            Some(resolver.glob_map)\n-        } else {\n-            None\n-        },\n-    }\n }\n \n-/// Builds a name resolution walker.\n-fn create_resolver<'a>(session: &'a Session,\n-                       definitions: &'a Definitions,\n-                       krate: &'a Crate,\n-                       make_glob_map: MakeGlobMap,\n-                       arenas: &'a ResolverArenas<'a>)\n-                       -> Resolver<'a> {\n-    let mut resolver = Resolver::new(session, definitions, make_glob_map, arenas);\n-\n-    resolver.build_reduced_graph(krate);\n-\n-    resolve_imports::resolve_imports(&mut resolver);\n-\n-    resolver\n+pub fn with_resolver<'a, T, F>(session: &'a Session,\n+                               definitions: &'a Definitions,\n+                               make_glob_map: MakeGlobMap,\n+                               f: F) -> T\n+    where F: for<'b> FnOnce(Resolver<'b>) -> T,\n+{\n+    let arenas = Resolver::arenas();\n+    let resolver = Resolver::new(session, definitions, make_glob_map, &arenas);\n+    f(resolver)\n }\n \n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}]}