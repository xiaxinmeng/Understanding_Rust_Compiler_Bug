{"sha": "e369d87b015a84653343032833d65d0545fd3f26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNjlkODdiMDE1YTg0NjUzMzQzMDMyODMzZDY1ZDA1NDVmZDNmMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-15T00:54:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-15T00:54:10Z"}, "message": "Auto merge of #65422 - tmandry:rollup-r5u3mlc, r=tmandry\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #65170 (rustc_metadata: Privatize private code and remove dead code)\n - #65260 (Optimize `LexicalResolve::expansion`.)\n - #65261 (Remove `Option` from `TokenStream`)\n - #65332 (std::fmt: reorder docs)\n - #65340 (Several changes to the codegen backend organization)\n - #65365 (Include const generic arguments in metadata)\n - #65398 (Bring attention to suggestions when the only difference is capitalization)\n - #65410 (syntax: add parser recovery for intersection- / and-patterns `p1 @ p2`)\n - #65415 (Remove an outdated test output file)\n - #65416 (Minor sync changes)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d58c82d0b3d84633a9452fa78a4c3c136cfa229b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d58c82d0b3d84633a9452fa78a4c3c136cfa229b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e369d87b015a84653343032833d65d0545fd3f26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e369d87b015a84653343032833d65d0545fd3f26", "html_url": "https://github.com/rust-lang/rust/commit/e369d87b015a84653343032833d65d0545fd3f26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e369d87b015a84653343032833d65d0545fd3f26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e413dc36a83a5aad3ab6270373000693a917e92b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e413dc36a83a5aad3ab6270373000693a917e92b", "html_url": "https://github.com/rust-lang/rust/commit/e413dc36a83a5aad3ab6270373000693a917e92b"}, {"sha": "9422feb43395a7a1df60d6e81b5ead87abc90b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9422feb43395a7a1df60d6e81b5ead87abc90b4b", "html_url": "https://github.com/rust-lang/rust/commit/9422feb43395a7a1df60d6e81b5ead87abc90b4b"}], "stats": {"total": 2148, "additions": 1099, "deletions": 1049}, "files": [{"sha": "1e39b7f822e99345c40cbcce0a2a633102451413", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 175, "deletions": 191, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -80,24 +80,187 @@\n //! arguments which have names. Like with positional parameters, it is not\n //! valid to provide named parameters that are unused by the format string.\n //!\n-//! ## Argument types\n+//! # Formatting Parameters\n+//!\n+//! Each argument being formatted can be transformed by a number of formatting\n+//! parameters (corresponding to `format_spec` in the syntax above). These\n+//! parameters affect the string representation of what's being formatted.\n+//!\n+//! ## Fill/Alignment\n+//!\n+//! The fill character is provided normally in conjunction with the\n+//! [`width`](#width)\n+//! parameter. This indicates that if the value being formatted is smaller than\n+//! `width` some extra characters will be printed around it. The extra\n+//! characters are specified by `fill`, and the alignment can be one of the\n+//! following options:\n+//!\n+//! * `<` - the argument is left-aligned in `width` columns\n+//! * `^` - the argument is center-aligned in `width` columns\n+//! * `>` - the argument is right-aligned in `width` columns\n+//!\n+//! Note that alignment may not be implemented by some types. In particular, it\n+//! is not generally implemented for the `Debug` trait.  A good way to ensure\n+//! padding is applied is to format your input, then use this resulting string\n+//! to pad your output.\n+//!\n+//! ## Sign/`#`/`0`\n+//!\n+//! These can all be interpreted as flags for a particular formatter.\n+//!\n+//! * `+` - This is intended for numeric types and indicates that the sign\n+//!         should always be printed. Positive signs are never printed by\n+//!         default, and the negative sign is only printed by default for the\n+//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n+//!         should always be printed.\n+//! * `-` - Currently not used\n+//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n+//!         be used. The alternate forms are:\n+//!     * `#?` - pretty-print the [`Debug`] formatting\n+//!     * `#x` - precedes the argument with a `0x`\n+//!     * `#X` - precedes the argument with a `0x`\n+//!     * `#b` - precedes the argument with a `0b`\n+//!     * `#o` - precedes the argument with a `0o`\n+//! * `0` - This is used to indicate for integer formats that the padding should\n+//!         both be done with a `0` character as well as be sign-aware. A format\n+//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n+//!         same format would yield `-0000001` for the integer `-1`. Notice that\n+//!         the negative version has one fewer zero than the positive version.\n+//!         Note that padding zeroes are always placed after the sign (if any)\n+//!         and before the digits. When used together with the `#` flag, a similar\n+//!         rule applies: padding zeroes are inserted after the prefix but before\n+//!         the digits.\n+//!\n+//! ## Width\n+//!\n+//! This is a parameter for the \"minimum width\" that the format should take up.\n+//! If the value's string does not fill up this many characters, then the\n+//! padding specified by fill/alignment will be used to take up the required\n+//! space.\n+//!\n+//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n+//! left-aligned. The\n+//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! the `0` flag is specified for numerics, then the implicit fill character is\n+//! `0`.\n+//!\n+//! The value for the width can also be provided as a [`usize`] in the list of\n+//! parameters by using the dollar syntax indicating that the second argument is\n+//! a [`usize`] specifying the width, for example:\n+//!\n+//! ```\n+//! // All of these print \"Hello x    !\"\n+//! println!(\"Hello {:5}!\", \"x\");\n+//! println!(\"Hello {:1$}!\", \"x\", 5);\n+//! println!(\"Hello {1:0$}!\", 5, \"x\");\n+//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n+//! ```\n+//!\n+//! Referring to an argument with the dollar syntax does not affect the \"next\n+//! argument\" counter, so it's usually a good idea to refer to arguments by\n+//! position, or use named arguments.\n+//!\n+//! ## Precision\n+//!\n+//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n+//! longer than this width, then it is truncated down to this many characters and that truncated\n+//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n+//!\n+//! For integral types, this is ignored.\n+//!\n+//! For floating-point types, this indicates how many digits after the decimal point should be\n+//! printed.\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//!\n+//! 1. An integer `.N`:\n+//!\n+//!    the integer `N` itself is the precision.\n+//!\n+//! 2. An integer or name followed by dollar sign `.N$`:\n+//!\n+//!    use format *argument* `N` (which must be a `usize`) as the precision.\n+//!\n+//! 3. An asterisk `.*`:\n+//!\n+//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n+//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n+//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!\n+//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n+//!\n+//! ```\n+//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n+//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+//!\n+//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n+//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+//!\n+//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n+//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n+//! //                          specified in first of next two args (5)}\n+//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n+//! //                          specified in its predecessor (5)}\n+//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n+//! //                          in arg \"prec\" (5)}\n+//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n+//! ```\n //!\n-//! Each argument's type is dictated by the format string.\n-//! There are various parameters which require a particular type, however.\n-//! An example is the `{:.*}` syntax, which sets the number of decimal places\n-//! in floating-point types:\n+//! While these:\n //!\n //! ```\n-//! let formatted_number = format!(\"{:.*}\", 2, 1.234567);\n+//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n+//! ```\n //!\n-//! assert_eq!(\"1.23\", formatted_number)\n+//! print two significantly different things:\n+//!\n+//! ```text\n+//! Hello, `1234.560` has 3 fractional digits\n+//! Hello, `123` has 3 characters\n+//! Hello, `     123` has 3 right-aligned characters\n //! ```\n //!\n-//! If this syntax is used, then the number of characters to print precedes the\n-//! actual object being formatted, and the number of characters must have the\n-//! type [`usize`].\n+//! # Escaping\n+//!\n+//! The literal characters `{` and `}` may be included in a string by preceding\n+//! them with the same character. For example, the `{` character is escaped with\n+//! `{{` and the `}` character is escaped with `}}`.\n+//!\n+//! # Syntax\n+//!\n+//! To summarize, you can find the full grammar of format strings.\n+//! The syntax for the formatting language used is drawn from other languages,\n+//! so it should not be too alien. Arguments are formatted with Python-like\n+//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n+//! `%`. The actual grammar for the formatting syntax is:\n+//!\n+//! ```text\n+//! format_string := <text> [ maybe-format <text> ] *\n+//! maybe-format := '{' '{' | '}' '}' | <format>\n+//! format := '{' [ argument ] [ ':' format_spec ] '}'\n+//! argument := integer | identifier\n+//!\n+//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n+//! fill := character\n+//! align := '<' | '^' | '>'\n+//! sign := '+' | '-'\n+//! width := count\n+//! precision := count | '*'\n+//! type := identifier | '?' | ''\n+//! count := parameter | integer\n+//! parameter := argument '$'\n+//! ```\n //!\n-//! ## Formatting traits\n+//! # Formatting traits\n //!\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n@@ -220,7 +383,7 @@\n //! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n //! ```\n //!\n-//! ## Related macros\n+//! # Related macros\n //!\n //! There are a number of related macros in the [`format!`] family. The ones that\n //! are currently implemented are:\n@@ -300,185 +463,6 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! # Syntax\n-//!\n-//! The syntax for the formatting language used is drawn from other languages,\n-//! so it should not be too alien. Arguments are formatted with Python-like\n-//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n-//! `%`. The actual grammar for the formatting syntax is:\n-//!\n-//! ```text\n-//! format_string := <text> [ maybe-format <text> ] *\n-//! maybe-format := '{' '{' | '}' '}' | <format>\n-//! format := '{' [ argument ] [ ':' format_spec ] '}'\n-//! argument := integer | identifier\n-//!\n-//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n-//! fill := character\n-//! align := '<' | '^' | '>'\n-//! sign := '+' | '-'\n-//! width := count\n-//! precision := count | '*'\n-//! type := identifier | '?' | ''\n-//! count := parameter | integer\n-//! parameter := argument '$'\n-//! ```\n-//!\n-//! # Formatting Parameters\n-//!\n-//! Each argument being formatted can be transformed by a number of formatting\n-//! parameters (corresponding to `format_spec` in the syntax above). These\n-//! parameters affect the string representation of what's being formatted.\n-//!\n-//! ## Fill/Alignment\n-//!\n-//! The fill character is provided normally in conjunction with the\n-//! [`width`](#width)\n-//! parameter. This indicates that if the value being formatted is smaller than\n-//! `width` some extra characters will be printed around it. The extra\n-//! characters are specified by `fill`, and the alignment can be one of the\n-//! following options:\n-//!\n-//! * `<` - the argument is left-aligned in `width` columns\n-//! * `^` - the argument is center-aligned in `width` columns\n-//! * `>` - the argument is right-aligned in `width` columns\n-//!\n-//! Note that alignment may not be implemented by some types. In particular, it\n-//! is not generally implemented for the `Debug` trait.  A good way to ensure\n-//! padding is applied is to format your input, then use this resulting string\n-//! to pad your output.\n-//!\n-//! ## Sign/`#`/`0`\n-//!\n-//! These can all be interpreted as flags for a particular formatter.\n-//!\n-//! * `+` - This is intended for numeric types and indicates that the sign\n-//!         should always be printed. Positive signs are never printed by\n-//!         default, and the negative sign is only printed by default for the\n-//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n-//!         should always be printed.\n-//! * `-` - Currently not used\n-//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n-//!         be used. The alternate forms are:\n-//!     * `#?` - pretty-print the [`Debug`] formatting\n-//!     * `#x` - precedes the argument with a `0x`\n-//!     * `#X` - precedes the argument with a `0x`\n-//!     * `#b` - precedes the argument with a `0b`\n-//!     * `#o` - precedes the argument with a `0o`\n-//! * `0` - This is used to indicate for integer formats that the padding should\n-//!         both be done with a `0` character as well as be sign-aware. A format\n-//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n-//!         same format would yield `-0000001` for the integer `-1`. Notice that\n-//!         the negative version has one fewer zero than the positive version.\n-//!         Note that padding zeroes are always placed after the sign (if any)\n-//!         and before the digits. When used together with the `#` flag, a similar\n-//!         rule applies: padding zeroes are inserted after the prefix but before\n-//!         the digits.\n-//!\n-//! ## Width\n-//!\n-//! This is a parameter for the \"minimum width\" that the format should take up.\n-//! If the value's string does not fill up this many characters, then the\n-//! padding specified by fill/alignment will be used to take up the required\n-//! space.\n-//!\n-//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n-//! left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If\n-//! the `0` flag is specified for numerics, then the implicit fill character is\n-//! `0`.\n-//!\n-//! The value for the width can also be provided as a [`usize`] in the list of\n-//! parameters by using the dollar syntax indicating that the second argument is\n-//! a [`usize`] specifying the width, for example:\n-//!\n-//! ```\n-//! // All of these print \"Hello x    !\"\n-//! println!(\"Hello {:5}!\", \"x\");\n-//! println!(\"Hello {:1$}!\", \"x\", 5);\n-//! println!(\"Hello {1:0$}!\", 5, \"x\");\n-//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n-//! ```\n-//!\n-//! Referring to an argument with the dollar syntax does not affect the \"next\n-//! argument\" counter, so it's usually a good idea to refer to arguments by\n-//! position, or use named arguments.\n-//!\n-//! ## Precision\n-//!\n-//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n-//! longer than this width, then it is truncated down to this many characters and that truncated\n-//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n-//!\n-//! For integral types, this is ignored.\n-//!\n-//! For floating-point types, this indicates how many digits after the decimal point should be\n-//! printed.\n-//!\n-//! There are three possible ways to specify the desired `precision`:\n-//!\n-//! 1. An integer `.N`:\n-//!\n-//!    the integer `N` itself is the precision.\n-//!\n-//! 2. An integer or name followed by dollar sign `.N$`:\n-//!\n-//!    use format *argument* `N` (which must be a `usize`) as the precision.\n-//!\n-//! 3. An asterisk `.*`:\n-//!\n-//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n-//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n-//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n-//!\n-//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n-//!\n-//! ```\n-//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n-//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n-//!\n-//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n-//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n-//!\n-//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n-//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n-//! //                          specified in first of next two args (5)}\n-//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n-//! //                          specified in its predecessor (5)}\n-//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n-//! //                          in arg \"prec\" (5)}\n-//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n-//! ```\n-//!\n-//! While these:\n-//!\n-//! ```\n-//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n-//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n-//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n-//! ```\n-//!\n-//! print two significantly different things:\n-//!\n-//! ```text\n-//! Hello, `1234.560` has 3 fractional digits\n-//! Hello, `123` has 3 characters\n-//! Hello, `     123` has 3 right-aligned characters\n-//! ```\n-//!\n-//! # Escaping\n-//!\n-//! The literal characters `{` and `}` may be included in a string by preceding\n-//! them with the same character. For example, the `{` character is escaped with\n-//! `{{` and the `}` character is escaped with `}}`.\n-//!\n //! [`usize`]: ../../std/primitive.usize.html\n //! [`isize`]: ../../std/primitive.isize.html\n //! [`i8`]: ../../std/primitive.i8.html"}, {"sha": "6f55ade1e8612b32fb181737d5ae313462b1629a", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -304,7 +304,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n-        self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n+        self.iterate_until_fixed_point(|constraint| {\n             debug!(\"expansion: constraint={:?}\", constraint);\n             let (a_region, b_vid, b_data, retain) = match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n@@ -360,13 +360,21 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         match *b_data {\n             VarValue::Value(cur_region) => {\n                 // Identical scopes can show up quite often, if the fixed point\n-                // iteration converges slowly, skip them\n+                // iteration converges slowly. Skip them. This is purely an\n+                // optimization.\n                 if let (ReScope(a_scope), ReScope(cur_scope)) = (a_region, cur_region) {\n                     if a_scope == cur_scope {\n                         return false;\n                     }\n                 }\n \n+                // This is a specialized version of the `lub_concrete_regions`\n+                // check below for a common case, here purely as an\n+                // optimization.\n+                if let ReEmpty = a_region {\n+                    return false;\n+                }\n+\n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n                 if lub == cur_region {\n                     return false;\n@@ -407,8 +415,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        let tcx = self.tcx();\n-\n         match (a, b) {\n             (&ty::ReClosureBound(..), _)\n             | (_, &ty::ReClosureBound(..))\n@@ -468,15 +474,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n                 // otherwise, we don't know what the free region is,\n                 // so we must conservatively say the LUB is static:\n-                tcx.lifetimes.re_static\n+                self.tcx().lifetimes.re_static\n             }\n \n             (&ReScope(a_id), &ReScope(b_id)) => {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n                 let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n-                tcx.mk_region(ReScope(lub))\n+                self.tcx().mk_region(ReScope(lub))\n             }\n \n             (&ReEarlyBound(_), &ReEarlyBound(_))\n@@ -490,7 +496,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 if a == b {\n                     a\n                 } else {\n-                    tcx.lifetimes.re_static\n+                    self.tcx().lifetimes.re_static\n                 }\n             }\n         }\n@@ -860,7 +866,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n+    fn iterate_until_fixed_point<F>(&self, mut body: F)\n     where\n         F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n     {\n@@ -870,7 +876,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n+            debug!(\"---- Expansion iteration {}\", iteration);\n             constraints.retain(|constraint| {\n                 let (edge_changed, retain) = body(constraint);\n                 if edge_changed {\n@@ -880,7 +886,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 retain\n             });\n         }\n-        debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n+        debug!(\"---- Expansion complete after {} iteration(s)\", iteration);\n     }\n \n     fn bound_is_met("}, {"sha": "2170a288c922bac2d84a27e2c041fdaf9694116c", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -32,6 +32,12 @@ pub struct CrateSource {\n     pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n+impl CrateSource {\n+    pub fn paths(&self) -> impl Iterator<Item = &PathBuf> {\n+        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).map(|p| &p.0)\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Copy, Clone,\n          Ord, PartialOrd, Eq, PartialEq, Debug, HashStable)]\n pub enum DepKind {\n@@ -208,7 +214,6 @@ pub trait CrateStore {\n     fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool;\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator;\n     fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n-    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics;\n     fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n "}, {"sha": "2517141542d571317e325ac5030fdfde9dd51400", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -23,7 +23,7 @@ use syntax::feature_gate::UnstableFeatures;\n use syntax::source_map::SourceMap;\n \n use errors::emitter::HumanReadableErrorType;\n-use errors::{ColorConfig, FatalError, Handler};\n+use errors::{ColorConfig, FatalError, Handler, SourceMapperDyn};\n \n use getopts;\n \n@@ -1857,6 +1857,7 @@ struct NullEmitter;\n \n impl errors::emitter::Emitter for NullEmitter {\n     fn emit_diagnostic(&mut self, _: &errors::Diagnostic) {}\n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> { None }\n }\n \n // Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`."}, {"sha": "256194cfb00ef79a0fff741d532d50eaa68707a0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -43,7 +43,7 @@ use crate::ty::subst::{UserSubsts, GenericArgKind};\n use crate::ty::{BoundVar, BindingMode};\n use crate::ty::CanonicalPolyFnSig;\n use crate::util::common::ErrorReported;\n-use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet, NodeMap};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::profiling::SelfProfilerRef;\n \n@@ -1051,6 +1051,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n+    /// Resolutions of `extern crate` items produced by resolver.\n+    extern_crate_map: NodeMap<CrateNum>,\n+\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     trait_map: FxHashMap<DefIndex,\n@@ -1274,6 +1277,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n+            extern_crate_map: resolutions.extern_crate_map,\n             trait_map,\n             export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n                 let exports: Vec<_> = v.into_iter().map(|e| {\n@@ -2951,7 +2955,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.extern_mod_stmt_cnum = |tcx, id| {\n         let id = tcx.hir().as_local_node_id(id).unwrap();\n-        tcx.cstore.extern_mod_stmt_cnum_untracked(id)\n+        tcx.extern_crate_map.get(&id).cloned()\n     };\n     providers.all_crate_nums = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "00b5fa23047eb165f6ae075a169b0a64536beccf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -28,7 +28,7 @@ use crate::ty::subst::{Subst, InternalSubsts, SubstsRef};\n use crate::ty::util::{IntTypeExt, Discr};\n use crate::ty::walk::TypeWalker;\n use crate::util::captures::Captures;\n-use crate::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use crate::util::nodemap::{NodeMap, NodeSet, DefIdMap, FxHashMap};\n use arena::SyncDroplessArena;\n use crate::session::DataTypeKind;\n \n@@ -121,6 +121,7 @@ mod sty;\n \n #[derive(Clone)]\n pub struct Resolutions {\n+    pub extern_crate_map: NodeMap<CrateNum>,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,"}, {"sha": "98be0ae44335f14723e212d60012aa8a25d5f54c", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -52,6 +52,7 @@ const UNNAMED: *const c_char = EMPTY_C_STR.as_ptr();\n \n impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n+    type Function = <CodegenCx<'ll, 'tcx> as BackendTypes>::Function;\n     type BasicBlock = <CodegenCx<'ll, 'tcx> as BackendTypes>::BasicBlock;\n     type Type = <CodegenCx<'ll, 'tcx> as BackendTypes>::Type;\n     type Funclet = <CodegenCx<'ll, 'tcx> as BackendTypes>::Funclet;"}, {"sha": "08fa23f2a7c9e31b09b539309692a655f9384926", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -33,7 +33,7 @@ pub fn get_fn(\n     assert!(!instance.substs.has_param_types());\n \n     let sig = instance.fn_sig(cx.tcx());\n-    if let Some(&llfn) = cx.instances().borrow().get(&instance) {\n+    if let Some(&llfn) = cx.instances.borrow().get(&instance) {\n         return llfn;\n     }\n "}, {"sha": "a1a5232d588327c7fc8d3eb95bcadd8bd8181557", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -2,7 +2,7 @@\n \n //! Code that is useful in various codegen modules.\n \n-use crate::llvm::{self, True, False, Bool, BasicBlock, OperandBundleDef};\n+use crate::llvm::{self, True, False, Bool, BasicBlock, OperandBundleDef, ConstantInt};\n use crate::abi;\n use crate::consts;\n use crate::type_::Type;\n@@ -86,6 +86,8 @@ impl Funclet<'ll> {\n \n impl BackendTypes for CodegenCx<'ll, 'tcx> {\n     type Value = &'ll Value;\n+    type Function = &'ll Value;\n+\n     type BasicBlock = &'ll BasicBlock;\n     type Type = &'ll Type;\n     type Funclet = Funclet<'ll>;\n@@ -243,33 +245,23 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         struct_in_context(self.llcx, elts, packed)\n     }\n \n-    fn const_to_uint(&self, v: &'ll Value) -> u64 {\n-        unsafe {\n+    fn const_to_opt_uint(&self, v: &'ll Value) -> Option<u64> {\n+        try_as_const_integral(v).map(|v| unsafe {\n             llvm::LLVMConstIntGetZExtValue(v)\n-        }\n-    }\n-\n-    fn is_const_integral(&self, v: &'ll Value) -> bool {\n-        unsafe {\n-            llvm::LLVMIsAConstantInt(v).is_some()\n-        }\n+        })\n     }\n \n     fn const_to_opt_u128(&self, v: &'ll Value, sign_ext: bool) -> Option<u128> {\n-        unsafe {\n-            if self.is_const_integral(v) {\n-                let (mut lo, mut hi) = (0u64, 0u64);\n-                let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n-                                                           &mut hi, &mut lo);\n-                if success {\n-                    Some(hi_lo_to_u128(lo, hi))\n-                } else {\n-                    None\n-                }\n+        try_as_const_integral(v).and_then(|v| unsafe {\n+            let (mut lo, mut hi) = (0u64, 0u64);\n+            let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n+                                                        &mut hi, &mut lo);\n+            if success {\n+                Some(hi_lo_to_u128(lo, hi))\n             } else {\n                 None\n             }\n-        }\n+        })\n     }\n \n     fn scalar_to_backend(\n@@ -305,7 +297,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         }\n                     }\n                     Some(GlobalAlloc::Function(fn_instance)) => {\n-                        self.get_fn(fn_instance)\n+                        self.get_fn_addr(fn_instance)\n                     }\n                     Some(GlobalAlloc::Static(def_id)) => {\n                         assert!(self.tcx.is_static(def_id));\n@@ -386,3 +378,9 @@ pub fn struct_in_context(\n fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n     ((hi as u128) << 64) | (lo as u128)\n }\n+\n+fn try_as_const_integral(v: &'ll Value) -> Option<&'ll ConstantInt> {\n+    unsafe {\n+        llvm::LLVMIsAConstantInt(v)\n+    }\n+}"}, {"sha": "2da93877172141890b20c3ba11cbc146e5c83733", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -20,7 +20,6 @@ use rustc::ty::layout::{\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::{HasTargetSpec, Target};\n-use rustc_codegen_ssa::callee::resolve_and_get_fn;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use crate::callee::get_fn;\n \n@@ -327,11 +326,11 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         &self.vtables\n     }\n \n-    fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, &'ll Value>> {\n-        &self.instances\n+    fn get_fn(&self, instance: Instance<'tcx>) -> &'ll Value {\n+        get_fn(self, instance)\n     }\n \n-    fn get_fn(&self, instance: Instance<'tcx>) -> &'ll Value {\n+    fn get_fn_addr(&self, instance: Instance<'tcx>) -> &'ll Value {\n         get_fn(self, instance)\n     }\n \n@@ -362,7 +361,14 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n         let llfn = match tcx.lang_items().eh_personality() {\n             Some(def_id) if !wants_msvc_seh(self.sess()) => {\n-                resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n+                self.get_fn_addr(\n+                    ty::Instance::resolve(\n+                        tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        tcx.intern_substs(&[]),\n+                    ).unwrap()\n+                )\n             }\n             _ => {\n                 let name = if wants_msvc_seh(self.sess()) {\n@@ -390,7 +396,14 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n-            let llfn = resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n+            let llfn = self.get_fn_addr(\n+                ty::Instance::resolve(\n+                    tcx,\n+                    ty::ParamEnv::reveal_all(),\n+                    def_id,\n+                    tcx.intern_substs(&[]),\n+                ).unwrap()\n+            );\n             unwresume.set(Some(llfn));\n             return llfn;\n         }"}, {"sha": "042e51ed2ba7a4e95e0f4bacd7e16142947df71c", "filename": "src/librustc_codegen_llvm/error_codes.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e413dc36a83a5aad3ab6270373000693a917e92b/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e413dc36a83a5aad3ab6270373000693a917e92b/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs?ref=e413dc36a83a5aad3ab6270373000693a917e92b", "patch": "@@ -1,38 +0,0 @@\n-register_diagnostics! {\n-\n-E0511: r##\"\n-Invalid monomorphization of an intrinsic function was used. Erroneous code\n-example:\n-\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#![feature(platform_intrinsics)]\n-\n-extern \"platform-intrinsic\" {\n-    fn simd_add<T>(a: T, b: T) -> T;\n-}\n-\n-fn main() {\n-    unsafe { simd_add(0, 1); }\n-    // error: invalid monomorphization of `simd_add` intrinsic\n-}\n-```\n-\n-The generic type has to be a SIMD type. Example:\n-\n-```\n-#![feature(repr_simd)]\n-#![feature(platform_intrinsics)]\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone)]\n-struct i32x2(i32, i32);\n-\n-extern \"platform-intrinsic\" {\n-    fn simd_add<T>(a: T, b: T) -> T;\n-}\n-\n-unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n-```\n-\"##,\n-\n-}"}, {"sha": "3df8d4c26903bd43e859632e2c53a334b69689aa", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -20,9 +20,9 @@ use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n use syntax::ast::{self, FloatTy};\n \n+use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::traits::*;\n \n-use rustc::session::Session;\n use syntax_pos::Span;\n \n use std::cmp::Ordering;\n@@ -1026,10 +1026,6 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     rust_try\n }\n \n-fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n-    span_err!(a, b, E0511, \"{}\", c);\n-}\n-\n fn generic_simd_intrinsic(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n     name: &str,"}, {"sha": "fde04a68457d074898181d000749889a64ae86c3", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -38,7 +38,7 @@ extern crate rustc_fs_util;\n extern crate rustc_driver as _;\n \n #[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n \n@@ -64,8 +64,6 @@ use rustc::util::common::ErrorReported;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n-mod error_codes;\n-\n mod back {\n     pub mod archive;\n     pub mod bytecode;\n@@ -258,10 +256,6 @@ impl CodegenBackend for LlvmCodegenBackend {\n         llvm_util::print_version();\n     }\n \n-    fn diagnostics(&self) -> &[(&'static str, &'static str)] {\n-        &error_codes::DIAGNOSTICS\n-    }\n-\n     fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n         target_features(sess)\n     }\n@@ -271,15 +265,10 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn provide(&self, providers: &mut ty::query::Providers<'_>) {\n-        rustc_codegen_utils::symbol_names::provide(providers);\n-        rustc_codegen_ssa::back::symbol_export::provide(providers);\n-        rustc_codegen_ssa::base::provide_both(providers);\n         attributes::provide(providers);\n     }\n \n     fn provide_extern(&self, providers: &mut ty::query::Providers<'_>) {\n-        rustc_codegen_ssa::back::symbol_export::provide_extern(providers);\n-        rustc_codegen_ssa::base::provide_both(providers);\n         attributes::provide_extern(providers);\n     }\n "}, {"sha": "a2313b933a6c970b56e63811f4a904bd40a7a81e", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -510,6 +510,7 @@ extern { pub type Module; }\n extern { pub type Context; }\n extern { pub type Type; }\n extern { pub type Value; }\n+extern { pub type ConstantInt; }\n extern { pub type Metadata; }\n extern { pub type BasicBlock; }\n #[repr(C)]\n@@ -719,8 +720,8 @@ extern \"C\" {\n     pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> &Value;\n     pub fn LLVMConstIntOfArbitraryPrecision(IntTy: &Type, Wn: c_uint, Ws: *const u64) -> &Value;\n     pub fn LLVMConstReal(RealTy: &Type, N: f64) -> &Value;\n-    pub fn LLVMConstIntGetZExtValue(ConstantVal: &Value) -> c_ulonglong;\n-    pub fn LLVMRustConstInt128Get(ConstantVal: &Value, SExt: bool,\n+    pub fn LLVMConstIntGetZExtValue(ConstantVal: &ConstantInt) -> c_ulonglong;\n+    pub fn LLVMRustConstInt128Get(ConstantVal: &ConstantInt, SExt: bool,\n                                   high: &mut u64, low: &mut u64) -> bool;\n \n \n@@ -1666,7 +1667,7 @@ extern \"C\" {\n     #[allow(improper_ctypes)]\n     pub fn LLVMRustWriteValueToString(value_ref: &Value, s: &RustString);\n \n-    pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&Value>;\n+    pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&ConstantInt>;\n \n     pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;"}, {"sha": "a09a0c22c1ba5ec8dbd1918c809ee71fbde5fa99", "filename": "src/librustc_codegen_ssa/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FREADME.md?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -84,7 +84,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n {\n     fn new_block<'b>(\n         cx: &'a Self::CodegenCx,\n-        llfn: Self::Value,\n+        llfn: Self::Function,\n         name: &'b str\n     ) -> Self;\n     /* ... */"}, {"sha": "ef3b115890f8b77fb649c9b0aa02d868ab29d10f", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -22,7 +22,8 @@ use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};\n use rustc::util::profiling::SelfProfilerRef;\n use rustc_fs_util::link_or_copy;\n use rustc_data_structures::svh::Svh;\n-use rustc_errors::{Handler, Level, FatalError, DiagnosticId};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::{Handler, Level, FatalError, DiagnosticId, SourceMapperDyn};\n use rustc_errors::emitter::{Emitter};\n use rustc_target::spec::MergeFunctions;\n use syntax::attr;\n@@ -1681,6 +1682,9 @@ impl Emitter for SharedEmitter {\n         }\n         drop(self.sender.send(SharedEmitterMessage::AbortIfErrors));\n     }\n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> {\n+        None\n+    }\n }\n \n impl SharedEmitterMain {"}, {"sha": "1c441ca7cbf2e277b860dc3d70e6dc58a126a909", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -36,7 +36,6 @@ use crate::mir::place::PlaceRef;\n use crate::back::write::{OngoingCodegen, start_async_codegen, submit_pre_lto_module_to_llvm,\n     submit_post_lto_module_to_llvm};\n use crate::{MemFlags, CrateInfo};\n-use crate::callee;\n use crate::common::{RealPredicate, TypeKind, IntPredicate};\n use crate::meth;\n use crate::mir;\n@@ -377,8 +376,7 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let sig = instance.fn_sig(cx.tcx());\n     let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n \n-    let lldecl = cx.instances().borrow().get(&instance).cloned().unwrap_or_else(||\n-        bug!(\"Instance `{:?}` not already declared\", instance));\n+    let lldecl = cx.get_fn(instance);\n \n     let mir = cx.tcx().instance_mir(instance.def);\n     mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n@@ -400,7 +398,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         return;\n     }\n \n-    let main_llfn = cx.get_fn(instance);\n+    let main_llfn = cx.get_fn_addr(instance);\n \n     let et = cx.tcx().entry_fn(LOCAL_CRATE).map(|e| e.1);\n     match et {\n@@ -455,10 +453,13 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n \n         let (start_fn, args) = if use_start_lang_item {\n             let start_def_id = cx.tcx().require_lang_item(StartFnLangItem, None);\n-            let start_fn = callee::resolve_and_get_fn(\n-                cx,\n-                start_def_id,\n-                cx.tcx().intern_substs(&[main_ret_ty.into()]),\n+            let start_fn = cx.get_fn_addr(\n+                ty::Instance::resolve(\n+                    cx.tcx(),\n+                    ty::ParamEnv::reveal_all(),\n+                    start_def_id,\n+                    cx.tcx().intern_substs(&[main_ret_ty.into()]),\n+                ).unwrap()\n             );\n             (start_fn, vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())),\n                             arg_argc, arg_argv])"}, {"sha": "6ba6774cbf881cb72210a0595d34c17880ec6cff", "filename": "src/librustc_codegen_ssa/callee.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e413dc36a83a5aad3ab6270373000693a917e92b/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e413dc36a83a5aad3ab6270373000693a917e92b/src%2Flibrustc_codegen_ssa%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcallee.rs?ref=e413dc36a83a5aad3ab6270373000693a917e92b", "patch": "@@ -1,53 +0,0 @@\n-use crate::traits::*;\n-use rustc::ty;\n-use rustc::ty::subst::SubstsRef;\n-use rustc::hir::def_id::DefId;\n-\n-pub fn resolve_and_get_fn<'tcx, Cx: CodegenMethods<'tcx>>(\n-    cx: &Cx,\n-    def_id: DefId,\n-    substs: SubstsRef<'tcx>,\n-) -> Cx::Value {\n-    cx.get_fn(\n-        ty::Instance::resolve(\n-            cx.tcx(),\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}\n-\n-pub fn resolve_and_get_fn_for_ptr<'tcx,\n-    Cx: Backend<'tcx> + MiscMethods<'tcx> + TypeMethods<'tcx>\n->(\n-    cx: &Cx,\n-    def_id: DefId,\n-    substs: SubstsRef<'tcx>,\n-) -> Cx::Value {\n-    cx.get_fn(\n-        ty::Instance::resolve_for_fn_ptr(\n-            cx.tcx(),\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}\n-\n-pub fn resolve_and_get_fn_for_vtable<'tcx,\n-    Cx: Backend<'tcx> + MiscMethods<'tcx> + TypeMethods<'tcx>\n->(\n-    cx: &Cx,\n-    def_id: DefId,\n-    substs: SubstsRef<'tcx>,\n-) -> Cx::Value {\n-    cx.get_fn(\n-        ty::Instance::resolve_for_vtable(\n-            cx.tcx(),\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs\n-        ).unwrap()\n-    )\n-}"}, {"sha": "ac39ca98476670ed2761ade3808667e35b4b2e51", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -1,6 +1,7 @@\n #![allow(non_camel_case_types, non_snake_case)]\n \n use rustc::ty::{Ty, TyCtxt};\n+use rustc::session::Session;\n use syntax_pos::Span;\n \n use rustc::hir::def_id::DefId;\n@@ -200,3 +201,7 @@ pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n+\n+pub fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n+    span_err!(a, b, E0511, \"{}\", c);\n+}"}, {"sha": "02e26d8f6ecf0f9bebb552fc5dbb11b3717c7120", "filename": "src/librustc_codegen_ssa/error_codes.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -1,5 +1,40 @@\n syntax::register_diagnostics! {\n \n+E0511: r##\"\n+Invalid monomorphization of an intrinsic function was used. Erroneous code\n+example:\n+\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#![feature(platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(a: T, b: T) -> T;\n+}\n+\n+fn main() {\n+    unsafe { simd_add(0, 1); }\n+    // error: invalid monomorphization of `simd_add` intrinsic\n+}\n+```\n+\n+The generic type has to be a SIMD type. Example:\n+\n+```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x2(i32, i32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(a: T, b: T) -> T;\n+}\n+\n+unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n+```\n+\"##,\n+\n E0668: r##\"\n Malformed inline assembly rejected by LLVM.\n "}, {"sha": "0221a04b045188840e07efef6cf66154fdfecb9c", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -27,6 +27,7 @@ use rustc::dep_graph::WorkProduct;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::middle::lang_items::LangItem;\n use rustc::hir::def_id::CrateNum;\n+use rustc::ty::query::Providers;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::svh::Svh;\n@@ -41,7 +42,6 @@ pub mod traits;\n pub mod mir;\n pub mod debuginfo;\n pub mod base;\n-pub mod callee;\n pub mod glue;\n pub mod meth;\n pub mod mono_item;\n@@ -156,3 +156,13 @@ pub struct CodegenResults {\n     pub linker_info: back::linker::LinkerInfo,\n     pub crate_info: CrateInfo,\n }\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    crate::back::symbol_export::provide(providers);\n+    crate::base::provide_both(providers);\n+}\n+\n+pub fn provide_extern(providers: &mut Providers<'_>) {\n+    crate::back::symbol_export::provide_extern(providers);\n+    crate::base::provide_both(providers);\n+}"}, {"sha": "266d2e5b18d22bbbfe2aa256b472cb495bb02c1e", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -1,6 +1,5 @@\n use rustc_target::abi::call::FnType;\n \n-use crate::callee;\n use crate::traits::*;\n \n use rustc::ty::{self, Ty, Instance};\n@@ -92,7 +91,14 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n \n     let methods = methods.cloned().map(|opt_mth| {\n         opt_mth.map_or(nullptr, |(def_id, substs)| {\n-            callee::resolve_and_get_fn_for_vtable(cx, def_id, substs)\n+            cx.get_fn_addr(\n+                ty::Instance::resolve_for_vtable(\n+                    cx.tcx(),\n+                    ty::ParamEnv::reveal_all(),\n+                    def_id,\n+                    substs,\n+                ).unwrap()\n+            )\n         })\n     });\n \n@@ -102,7 +108,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     // `get_vtable` in rust_mir/interpret/traits.rs\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n-        cx.get_fn(Instance::resolve_drop_in_place(cx.tcx(), ty)),\n+        cx.get_fn_addr(Instance::resolve_drop_in_place(cx.tcx(), ty)),\n         cx.const_usize(layout.size.bytes()),\n         cx.const_usize(layout.align.abi.bytes())\n     ].iter().cloned().chain(methods).collect();"}, {"sha": "dc77d025c005fa4307d5dd77f187a95ffd31609f", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -358,7 +358,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_ty), fn_ty)\n             }\n             _ => {\n-                (bx.get_fn(drop_fn),\n+                (bx.get_fn_addr(drop_fn),\n                  FnType::of_instance(&bx, drop_fn))\n             }\n         };\n@@ -460,7 +460,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n         let fn_ty = FnType::of_instance(&bx, instance);\n-        let llfn = bx.get_fn(instance);\n+        let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n         helper.do_call(self, &mut bx, fn_ty, llfn, &args, None, cleanup);\n@@ -576,7 +576,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n                 let fn_ty = FnType::of_instance(&bx, instance);\n-                let llfn = bx.get_fn(instance);\n+                let llfn = bx.get_fn_addr(instance);\n \n                 if let Some((_, target)) = destination.as_ref() {\n                     helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n@@ -793,7 +793,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let fn_ptr = match (llfn, instance) {\n             (Some(llfn), _) => llfn,\n-            (None, Some(instance)) => bx.get_fn(instance),\n+            (None, Some(instance)) => bx.get_fn_addr(instance),\n             _ => span_bug!(span, \"no llfn for call\"),\n         };\n "}, {"sha": "1a2e796a5b7be6adc44b375316295c035d5ed2c9", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -30,7 +30,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     debug_context: FunctionDebugContext<Bx::DIScope>,\n \n-    llfn: Bx::Value,\n+    llfn: Bx::Function,\n \n     cx: &'a Bx::CodegenCx,\n \n@@ -183,7 +183,7 @@ impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n \n pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n-    llfn: Bx::Value,\n+    llfn: Bx::Function,\n     mir: &'a Body<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,"}, {"sha": "1d1bc2a81a2ca7459205a34391f665b92ec35a4e", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -394,8 +394,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         // Statically compute the offset if we can, otherwise just use the element size,\n         // as this will yield the lowest alignment.\n         let layout = self.layout.field(bx, 0);\n-        let offset = if bx.is_const_integral(llindex) {\n-            layout.size.checked_mul(bx.const_to_uint(llindex), bx).unwrap_or(layout.size)\n+        let offset = if let Some(llindex) = bx.const_to_opt_uint(llindex) {\n+            layout.size.checked_mul(llindex, bx).unwrap_or(layout.size)\n         } else {\n             layout.size\n         };"}, {"sha": "27442bb6bff887f54d866f6fe090267d1e89e427", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -10,7 +10,6 @@ use syntax::source_map::{DUMMY_SP, Span};\n \n use crate::base;\n use crate::MemFlags;\n-use crate::callee;\n use crate::common::{self, RealPredicate, IntPredicate};\n \n use crate::traits::*;\n@@ -95,7 +94,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let size = bx.const_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n-                    if bx.cx().is_const_integral(v) && bx.cx().const_to_uint(v) == 0 {\n+                    if bx.cx().const_to_opt_uint(v) == Some(0) {\n                         let fill = bx.cx().const_u8(0);\n                         bx.memset(start, fill, size, dest.align, MemFlags::empty());\n                         return bx;\n@@ -190,7 +189,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     bug!(\"reifying a fn ptr that requires const arguments\");\n                                 }\n                                 OperandValue::Immediate(\n-                                    callee::resolve_and_get_fn_for_ptr(bx.cx(), def_id, substs))\n+                                    bx.get_fn_addr(\n+                                        ty::Instance::resolve_for_fn_ptr(\n+                                            bx.tcx(),\n+                                            ty::ParamEnv::reveal_all(),\n+                                            def_id,\n+                                            substs\n+                                        ).unwrap()\n+                                    )\n+                                )\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.layout.ty)\n@@ -205,7 +212,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     def_id,\n                                     substs,\n                                     ty::ClosureKind::FnOnce);\n-                                OperandValue::Immediate(bx.cx().get_fn(instance))\n+                                OperandValue::Immediate(bx.cx().get_fn_addr(instance))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.layout.ty)\n@@ -488,7 +495,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 };\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let r = bx.cx().get_fn(instance);\n+                let r = bx.cx().get_fn_addr(instance);\n                 let call = bx.call(r, &[llsize, llalign], None);\n                 let val = bx.pointercast(call, llty_ptr);\n "}, {"sha": "a7faf4eaf10227de4c1297c3422c6c793ced34a8", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -14,6 +14,8 @@ use syntax_pos::symbol::InternedString;\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n+    type Function: CodegenObject;\n+\n     type BasicBlock: Copy;\n     type Type: CodegenObject;\n     type Funclet;"}, {"sha": "62b5bcbb6c9dcff67c89e7899ae4d0a50c0e7951", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -34,7 +34,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     + HasTargetSpec\n \n {\n-    fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Value, name: &'b str) -> Self;\n+    fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Function, name: &'b str) -> Self;\n     fn with_cx(cx: &'a Self::CodegenCx) -> Self;\n     fn build_sibling_block(&self, name: &str) -> Self;\n     fn cx(&self) -> &Self::CodegenCx;"}, {"sha": "95ada60fae08dd74ffc6f926967232489a27e50d", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -21,11 +21,9 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n \n     fn const_struct(&self, elts: &[Self::Value], packed: bool) -> Self::Value;\n \n-    fn const_to_uint(&self, v: Self::Value) -> u64;\n+    fn const_to_opt_uint(&self, v: Self::Value) -> Option<u64>;\n     fn const_to_opt_u128(&self, v: Self::Value, sign_ext: bool) -> Option<u128>;\n \n-    fn is_const_integral(&self, v: Self::Value) -> bool;\n-\n     fn scalar_to_backend(\n         &self,\n         cv: Scalar,"}, {"sha": "989e6cf9dcaf1ea57aad2df096189b725a1adab8", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -20,7 +20,7 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         &self,\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n-        llfn: Self::Value,\n+        llfn: Self::Function,\n         mir: &mir::Body<'_>,\n     ) -> FunctionDebugContext<Self::DIScope>;\n "}, {"sha": "cd42044e48df8cf6d6c5cf0dfa458acc50c31b85", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -17,13 +17,13 @@ pub trait DeclareMethods<'tcx>: BackendTypes {\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will\n     /// update the declaration and return existing Value instead.\n-    fn declare_cfn(&self, name: &str, fn_type: Self::Type) -> Self::Value;\n+    fn declare_cfn(&self, name: &str, fn_type: Self::Type) -> Self::Function;\n \n     /// Declare a Rust function.\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will\n     /// update the declaration and return existing Value instead.\n-    fn declare_fn(&self, name: &str, sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n+    fn declare_fn(&self, name: &str, sig: ty::PolyFnSig<'tcx>) -> Self::Function;\n \n     /// Declare a global with an intention to define it.\n     ///"}, {"sha": "658ddd0028076970726f1d05b38a9b39400b7699", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -11,14 +11,14 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n         &self,\n     ) -> &RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Self::Value>>;\n     fn check_overflow(&self) -> bool;\n-    fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, Self::Value>>;\n-    fn get_fn(&self, instance: Instance<'tcx>) -> Self::Value;\n+    fn get_fn(&self, instance: Instance<'tcx>) -> Self::Function;\n+    fn get_fn_addr(&self, instance: Instance<'tcx>) -> Self::Value;\n     fn eh_personality(&self) -> Self::Value;\n     fn eh_unwind_resume(&self) -> Self::Value;\n     fn sess(&self) -> &Session;\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>>;\n     fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n-    fn set_frame_pointer_elimination(&self, llfn: Self::Value);\n-    fn apply_target_cpu_attr(&self, llfn: Self::Value);\n+    fn set_frame_pointer_elimination(&self, llfn: Self::Function);\n+    fn apply_target_cpu_attr(&self, llfn: Self::Function);\n     fn create_used_variable(&self);\n }"}, {"sha": "4318ef16494a11194af39f0c434f3488106909ec", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -88,6 +88,7 @@ pub trait HasCodegen<'tcx>:\n     type CodegenCx: CodegenMethods<'tcx>\n         + BackendTypes<\n             Value = Self::Value,\n+            Function = Self::Function,\n             BasicBlock = Self::BasicBlock,\n             Type = Self::Type,\n             Funclet = Self::Funclet,"}, {"sha": "1077c1f42637ebf85a00c5d41a9b3c5b378a0eef", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -25,7 +25,6 @@ pub trait CodegenBackend {\n     fn target_features(&self, _sess: &Session) -> Vec<Symbol> { vec![] }\n     fn print_passes(&self) {}\n     fn print_version(&self) {}\n-    fn diagnostics(&self) -> &[(&'static str, &'static str)] { &[] }\n \n     fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync>;\n     fn provide(&self, _providers: &mut Providers<'_>);"}, {"sha": "66920342ff6ba3b894ec3135af73e45a0257fa90", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -18,6 +18,7 @@\n extern crate rustc;\n \n use rustc::ty::TyCtxt;\n+use rustc::ty::query::Providers;\n use rustc::hir::def_id::LOCAL_CRATE;\n use syntax::symbol::sym;\n \n@@ -37,3 +38,7 @@ pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_>) {\n         }\n     }\n }\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    crate::symbol_names::provide(providers);\n+}"}, {"sha": "9622c290039d5ddac11616b97714f55a47d8abe4", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -1,6 +1,6 @@\n //! This module defines types which are thread safe if cfg!(parallel_compiler) is true.\n //!\n-//! `Lrc` is an alias of either Rc or Arc.\n+//! `Lrc` is an alias of `Arc` if cfg!(parallel_compiler) is true, `Rc` otherwise.\n //!\n //! `Lock` is a mutex.\n //! It internally uses `parking_lot::Mutex` if cfg!(parallel_compiler) is true,\n@@ -12,7 +12,7 @@\n //!\n //! `MTLock` is a mutex which disappears if cfg!(parallel_compiler) is false.\n //!\n-//! `MTRef` is a immutable reference if cfg!(parallel_compiler), and an mutable reference otherwise.\n+//! `MTRef` is an immutable reference if cfg!(parallel_compiler), and a mutable reference otherwise.\n //!\n //! `rustc_erase_owner!` erases a OwningRef owner into Erased or Erased + Send + Sync\n //! depending on the value of cfg!(parallel_compiler).\n@@ -23,29 +23,6 @@ use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n use crate::owning_ref::{Erased, OwningRef};\n \n-pub fn serial_join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)\n-    where A: FnOnce() -> RA,\n-          B: FnOnce() -> RB\n-{\n-    (oper_a(), oper_b())\n-}\n-\n-pub struct SerialScope;\n-\n-impl SerialScope {\n-    pub fn spawn<F>(&self, f: F)\n-        where F: FnOnce(&SerialScope)\n-    {\n-        f(self)\n-    }\n-}\n-\n-pub fn serial_scope<F, R>(f: F) -> R\n-    where F: FnOnce(&SerialScope) -> R\n-{\n-    f(&SerialScope)\n-}\n-\n pub use std::sync::atomic::Ordering::SeqCst;\n pub use std::sync::atomic::Ordering;\n \n@@ -176,8 +153,28 @@ cfg_if! {\n         pub type AtomicU32 = Atomic<u32>;\n         pub type AtomicU64 = Atomic<u64>;\n \n-        pub use self::serial_join as join;\n-        pub use self::serial_scope as scope;\n+        pub fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)\n+            where A: FnOnce() -> RA,\n+                  B: FnOnce() -> RB\n+        {\n+            (oper_a(), oper_b())\n+        }\n+\n+        pub struct SerialScope;\n+\n+        impl SerialScope {\n+            pub fn spawn<F>(&self, f: F)\n+                where F: FnOnce(&SerialScope)\n+            {\n+                f(self)\n+            }\n+        }\n+\n+        pub fn scope<F, R>(f: F) -> R\n+            where F: FnOnce(&SerialScope) -> R\n+        {\n+            f(&SerialScope)\n+        }\n \n         #[macro_export]\n         macro_rules! parallel {"}, {"sha": "f33cb4e215d332a4b7edef4bc953d2d170233196", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -616,7 +616,7 @@ impl RustcDefaultCalls {\n                     let mut v = Vec::new();\n                     locator::list_file_metadata(&sess.target.target,\n                                                 path,\n-                                                &*cstore.metadata_loader,\n+                                                cstore,\n                                                 &mut v)\n                             .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());"}, {"sha": "16a1a28cd3a80c968bdcc20552cfec3620dcad40", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -49,6 +49,10 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n                                    &suggestions);\n     }\n \n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> {\n+        self.source_map.as_ref()\n+    }\n+\n     fn should_show_explain(&self) -> bool {\n         !self.short_message\n     }"}, {"sha": "84400091100e6047c556977331e3ae3618e0e39b", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -13,7 +13,7 @@ use syntax_pos::{SourceFile, Span, MultiSpan};\n \n use crate::{\n     Level, CodeSuggestion, Diagnostic, SubDiagnostic,\n-    SuggestionStyle, SourceMapperDyn, DiagnosticId,\n+    SuggestionStyle, SourceMapper, SourceMapperDyn, DiagnosticId,\n };\n use crate::Level::Error;\n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n@@ -192,6 +192,8 @@ pub trait Emitter {\n         true\n     }\n \n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>>;\n+\n     /// Formats the substitutions of the primary_span\n     ///\n     /// The are a lot of conditions to this method, but in short:\n@@ -204,7 +206,7 @@ pub trait Emitter {\n     ///   we return the original `primary_span` and the original suggestions.\n     fn primary_span_formatted<'a>(\n         &mut self,\n-        db: &'a Diagnostic\n+        db: &'a Diagnostic,\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = db.span.clone();\n         if let Some((sugg, rest)) = db.suggestions.split_first() {\n@@ -234,7 +236,20 @@ pub trait Emitter {\n                     format!(\"help: {}\", sugg.msg)\n                 } else {\n                     // Show the default suggestion text with the substitution\n-                    format!(\"help: {}: `{}`\", sugg.msg, substitution)\n+                    format!(\n+                        \"help: {}{}: `{}`\",\n+                        sugg.msg,\n+                        if self.source_map().map(|sm| is_case_difference(\n+                            &**sm,\n+                            substitution,\n+                            sugg.substitutions[0].parts[0].span,\n+                        )).unwrap_or(false) {\n+                            \" (notice the capitalization)\"\n+                        } else {\n+                            \"\"\n+                        },\n+                        substitution,\n+                    )\n                 };\n                 primary_span.push_span_label(sugg.substitutions[0].parts[0].span, msg);\n \n@@ -382,6 +397,10 @@ pub trait Emitter {\n }\n \n impl Emitter for EmitterWriter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> {\n+        self.sm.as_ref()\n+    }\n+\n     fn emit_diagnostic(&mut self, db: &Diagnostic) {\n         let mut children = db.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n@@ -1461,7 +1480,9 @@ impl EmitterWriter {\n         let suggestions = suggestion.splice_lines(&**sm);\n \n         let mut row_num = 2;\n-        for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+        let mut notice_capitalization = false;\n+        for (complete, parts, only_capitalization) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+            notice_capitalization |= only_capitalization;\n             // Only show underline if the suggestion spans a single line and doesn't cover the\n             // entirety of the code output. If you have multiple replacements in the same line\n             // of code, show the underline.\n@@ -1552,7 +1573,10 @@ impl EmitterWriter {\n         }\n         if suggestions.len() > MAX_SUGGESTIONS {\n             let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n-            buffer.puts(row_num, 0, &msg, Style::NoStyle);\n+            buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n+        } else if notice_capitalization {\n+            let msg = \"notice the capitalization difference\";\n+            buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n         }\n         emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         Ok(())\n@@ -2034,3 +2058,18 @@ impl<'a> Drop for WritableDst<'a> {\n         }\n     }\n }\n+\n+/// Whether the original and suggested code are visually similar enough to warrant extra wording.\n+pub fn is_case_difference(sm: &dyn SourceMapper, suggested: &str, sp: Span) -> bool {\n+    // FIXME: this should probably be extended to also account for `FO0` \u2192 `FOO` and unicode.\n+    let found = sm.span_to_snippet(sp).unwrap();\n+    let ascii_confusables = &['c', 'f', 'i', 'k', 'o', 's', 'u', 'v', 'w', 'x', 'y', 'z'];\n+    // All the chars that differ in capitalization are confusable (above):\n+    let confusable = found.chars().zip(suggested.chars()).filter(|(f, s)| f != s).all(|(f, s)| {\n+        (ascii_confusables.contains(&f) || ascii_confusables.contains(&s))\n+    });\n+    confusable && found.to_lowercase() == suggested.to_lowercase()\n+            // FIXME: We sometimes suggest the same thing we already have, which is a\n+            //        bug, but be defensive against that here.\n+            && found != suggested\n+}"}, {"sha": "63df052a225041095d263a75ae11e51d45dd33f9", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -13,7 +13,7 @@ pub use emitter::ColorConfig;\n \n use Level::*;\n \n-use emitter::{Emitter, EmitterWriter};\n+use emitter::{Emitter, EmitterWriter, is_case_difference};\n use registry::Registry;\n \n use rustc_data_structures::sync::{self, Lrc, Lock};\n@@ -37,13 +37,16 @@ pub mod registry;\n mod styled_buffer;\n mod lock;\n \n-use syntax_pos::{BytePos,\n-                 Loc,\n-                 FileLinesResult,\n-                 SourceFile,\n-                 FileName,\n-                 MultiSpan,\n-                 Span};\n+use syntax_pos::{\n+    BytePos,\n+    FileLinesResult,\n+    FileName,\n+    Loc,\n+    MultiSpan,\n+    SourceFile,\n+    Span,\n+    SpanSnippetError,\n+};\n \n /// Indicates the confidence in the correctness of a suggestion.\n ///\n@@ -147,6 +150,7 @@ pub trait SourceMapper {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc;\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n     fn span_to_string(&self, sp: Span) -> String;\n+    fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError>;\n     fn span_to_filename(&self, sp: Span) -> FileName;\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n     fn call_span_if_macro(&self, sp: Span) -> Span;\n@@ -155,9 +159,12 @@ pub trait SourceMapper {\n }\n \n impl CodeSuggestion {\n-    /// Returns the assembled code suggestions and whether they should be shown with an underline.\n-    pub fn splice_lines(&self, cm: &SourceMapperDyn)\n-                        -> Vec<(String, Vec<SubstitutionPart>)> {\n+    /// Returns the assembled code suggestions, whether they should be shown with an underline\n+    /// and whether the substitution only differs in capitalization.\n+    pub fn splice_lines(\n+        &self,\n+        cm: &SourceMapperDyn,\n+    ) -> Vec<(String, Vec<SubstitutionPart>, bool)> {\n         use syntax_pos::{CharPos, Pos};\n \n         fn push_trailing(buf: &mut String,\n@@ -232,6 +239,7 @@ impl CodeSuggestion {\n                 prev_hi = cm.lookup_char_pos(part.span.hi());\n                 prev_line = fm.get_line(prev_hi.line - 1);\n             }\n+            let only_capitalization = is_case_difference(cm, &buf, bounding_span);\n             // if the replacement already ends with a newline, don't print the next line\n             if !buf.ends_with('\\n') {\n                 push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n@@ -240,7 +248,7 @@ impl CodeSuggestion {\n             while buf.ends_with('\\n') {\n                 buf.pop();\n             }\n-            (buf, substitution.parts)\n+            (buf, substitution.parts, only_capitalization)\n         }).collect()\n     }\n }"}, {"sha": "396c5610251a34075404e1ff65dbd76a5babbea7", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -130,15 +130,15 @@ pub fn configure_and_expand(\n     let crate_name = crate_name.to_string();\n     let (result, resolver) = BoxedResolver::new(static move || {\n         let sess = &*sess;\n-        let mut crate_loader = CrateLoader::new(sess, &*cstore, &crate_name);\n+        let crate_loader = CrateLoader::new(sess, &*cstore, &crate_name);\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n             sess,\n             &*cstore,\n             krate,\n             &crate_name,\n             &resolver_arenas,\n-            &mut crate_loader,\n+            &crate_loader,\n             plugin_info,\n         );\n         let mut resolver = match res {\n@@ -169,6 +169,7 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions),\n             resolutions: Steal::new(Resolutions {\n+                extern_crate_map: resolver.extern_crate_map,\n                 export_map: resolver.export_map,\n                 trait_map: resolver.trait_map,\n                 glob_map: resolver.glob_map,\n@@ -187,6 +188,7 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions.clone()),\n             resolutions: Steal::new(Resolutions {\n+                extern_crate_map: resolver.extern_crate_map.clone(),\n                 export_map: resolver.export_map.clone(),\n                 trait_map: resolver.trait_map.clone(),\n                 glob_map: resolver.glob_map.clone(),\n@@ -319,7 +321,7 @@ fn configure_and_expand_inner<'a>(\n     mut krate: ast::Crate,\n     crate_name: &str,\n     resolver_arenas: &'a ResolverArenas<'a>,\n-    crate_loader: &'a mut CrateLoader<'a>,\n+    crate_loader: &'a CrateLoader<'a>,\n     plugin_info: PluginInfo,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     time(sess, \"pre-AST-expansion lint checks\", || {\n@@ -663,16 +665,15 @@ fn write_out_deps(compiler: &Compiler, outputs: &OutputFilenames, out_filenames:\n \n         if sess.binary_dep_depinfo() {\n             for cnum in compiler.cstore.crates_untracked() {\n-                let metadata = compiler.cstore.crate_data_as_rc_any(cnum);\n-                let metadata = metadata.downcast_ref::<cstore::CrateMetadata>().unwrap();\n-                if let Some((path, _)) = &metadata.source.dylib {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                let source = compiler.cstore.crate_source_untracked(cnum);\n+                if let Some((path, _)) = source.dylib {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n-                if let Some((path, _)) = &metadata.source.rlib {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                if let Some((path, _)) = source.rlib {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n-                if let Some((path, _)) = &metadata.source.rmeta {\n-                    files.push(escape_dep_filename(&FileName::Real(path.clone())));\n+                if let Some((path, _)) = source.rmeta {\n+                    files.push(escape_dep_filename(&FileName::Real(path)));\n                 }\n             }\n         }\n@@ -790,10 +791,13 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     cstore::provide(providers);\n     lint::provide(providers);\n     rustc_lint::provide(providers);\n+    rustc_codegen_utils::provide(providers);\n+    rustc_codegen_ssa::provide(providers);\n }\n \n pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n     cstore::provide_extern(providers);\n+    rustc_codegen_ssa::provide_extern(providers);\n }\n \n declare_box_region_type!("}, {"sha": "9850121d2ce5d782e6f1742c1e104cd588d02f41", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 32, "deletions": 56, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -1,6 +1,6 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n+use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n use crate::schema::{CrateRoot, CrateDep};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n@@ -14,7 +14,7 @@ use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n-use rustc::middle::cstore::{ExternCrate, ExternCrateSource};\n+use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n@@ -33,15 +33,13 @@ use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n \n-pub struct Library {\n-    pub dylib: Option<(PathBuf, PathKind)>,\n-    pub rlib: Option<(PathBuf, PathKind)>,\n-    pub rmeta: Option<(PathBuf, PathKind)>,\n+crate struct Library {\n+    pub source: CrateSource,\n     pub metadata: MetadataBlob,\n }\n \n pub struct CrateLoader<'a> {\n-    pub sess: &'a Session,\n+    sess: &'a Session,\n     cstore: &'a CStore,\n     local_crate_name: Symbol,\n }\n@@ -189,18 +187,18 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn register_crate(\n-        &mut self,\n+        &self,\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n         span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol\n     ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n-        let _prof_timer =\n-            self.sess.prof.generic_activity(\"metadata_register_crate\");\n+        let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n-        let crate_root = lib.metadata.get_root();\n+        let Library { source, metadata } = lib;\n+        let crate_root = metadata.get_root();\n         self.verify_no_symbol_conflicts(span, &crate_root);\n \n         let private_dep = self.sess.opts.externs.get(&name.as_str())\n@@ -218,28 +216,22 @@ impl<'a> CrateLoader<'a> {\n         let root = if let Some(root) = root {\n             root\n         } else {\n-            crate_paths = CratePaths {\n-                ident: crate_root.name.to_string(),\n-                dylib: lib.dylib.clone().map(|p| p.0),\n-                rlib:  lib.rlib.clone().map(|p| p.0),\n-                rmeta: lib.rmeta.clone().map(|p| p.0),\n-            };\n+            crate_paths = CratePaths { name: crate_root.name, source: source.clone() };\n             &crate_paths\n         };\n \n-        let Library { dylib, rlib, rmeta, metadata } = lib;\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n         let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n             let temp_root;\n-            let (dlsym_dylib, dlsym_root) = match &host_lib {\n+            let (dlsym_source, dlsym_root) = match &host_lib {\n                 Some(host_lib) =>\n-                    (&host_lib.dylib, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n-                None => (&dylib, &crate_root),\n+                    (&host_lib.source, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n+                None => (&source, &crate_root),\n             };\n-            let dlsym_dylib = dlsym_dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n+            let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n             self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span)\n         });\n \n@@ -268,13 +260,8 @@ impl<'a> CrateLoader<'a> {\n             source_map_import_info: RwLock::new(vec![]),\n             alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n             dep_kind: Lock::new(dep_kind),\n-            source: cstore::CrateSource {\n-                dylib,\n-                rlib,\n-                rmeta,\n-            },\n+            source,\n             private_dep,\n-            span,\n             raw_proc_macros,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n         };\n@@ -285,7 +272,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn load_proc_macro<'b>(\n-        &mut self,\n+        &self,\n         locate_ctxt: &mut locator::Context<'b>,\n         path_kind: PathKind,\n     ) -> Option<(LoadResult, Option<Library>)>\n@@ -340,7 +327,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn resolve_crate<'b>(\n-        &'b mut self,\n+        &'b self,\n         name: Symbol,\n         span: Span,\n         dep_kind: DepKind,\n@@ -350,7 +337,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn maybe_resolve_crate<'b>(\n-        &'b mut self,\n+        &'b self,\n         name: Symbol,\n         span: Span,\n         mut dep_kind: DepKind,\n@@ -410,7 +397,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn load(&mut self, locate_ctxt: &mut locator::Context<'_>) -> Option<LoadResult> {\n+    fn load(&self, locate_ctxt: &mut locator::Context<'_>) -> Option<LoadResult> {\n         let library = locate_ctxt.maybe_load_library_crate()?;\n \n         // In the case that we're loading a crate, but not matching\n@@ -437,7 +424,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn update_extern_crate(&mut self,\n+    fn update_extern_crate(&self,\n                            cnum: CrateNum,\n                            mut extern_crate: ExternCrate,\n                            visited: &mut FxHashSet<(CrateNum, bool)>)\n@@ -479,7 +466,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     // Go through the crate metadata and load any crates that it references\n-    fn resolve_crate_deps(&mut self,\n+    fn resolve_crate_deps(&self,\n                           root: &CratePaths,\n                           crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n@@ -509,7 +496,7 @@ impl<'a> CrateLoader<'a> {\n         })).collect()\n     }\n \n-    fn read_extension_crate(&mut self, name: Symbol, span: Span) -> ExtensionCrate {\n+    fn read_extension_crate(&self, name: Symbol, span: Span) -> ExtensionCrate {\n         info!(\"read extension crate `{}`\", name);\n         let target_triple = self.sess.opts.target_triple.clone();\n         let host_triple = TargetTriple::from_triple(config::host_triple());\n@@ -559,7 +546,7 @@ impl<'a> CrateLoader<'a> {\n                 (data.source.dylib.clone(), PMDSource::Registered(data))\n             }\n             LoadResult::Loaded(library) => {\n-                let dylib = library.dylib.clone();\n+                let dylib = library.source.dylib.clone();\n                 let metadata = PMDSource::Owned(library);\n                 (dylib, metadata)\n             }\n@@ -605,7 +592,7 @@ impl<'a> CrateLoader<'a> {\n \n     /// Look for a plugin registrar. Returns library path, crate\n     /// SVH and DefIndex of the registrar function.\n-    pub fn find_plugin_registrar(&mut self,\n+    pub fn find_plugin_registrar(&self,\n                                  span: Span,\n                                  name: Symbol)\n                                  -> Option<(PathBuf, CrateDisambiguator)> {\n@@ -638,7 +625,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n+    fn inject_panic_runtime(&self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n         let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| {\n@@ -719,7 +706,7 @@ impl<'a> CrateLoader<'a> {\n                                   &|data| data.root.needs_panic_runtime);\n     }\n \n-    fn inject_sanitizer_runtime(&mut self) {\n+    fn inject_sanitizer_runtime(&self) {\n         if let Some(ref sanitizer) = self.sess.opts.debugging_opts.sanitizer {\n             // Sanitizers can only be used on some tested platforms with\n             // executables linked to `std`\n@@ -817,7 +804,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_profiler_runtime(&mut self) {\n+    fn inject_profiler_runtime(&self) {\n         if self.sess.opts.debugging_opts.profile ||\n            self.sess.opts.cg.profile_generate.enabled()\n         {\n@@ -834,7 +821,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n+    fn inject_allocator_crate(&self, krate: &ast::Crate) {\n         let has_global_allocator = match &*global_allocator_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess.struct_span_err(*span2, \"cannot define multiple global allocators\")\n@@ -973,7 +960,7 @@ impl<'a> CrateLoader<'a> {\n }\n \n impl<'a> CrateLoader<'a> {\n-    pub fn postprocess(&mut self, krate: &ast::Crate) {\n+    pub fn postprocess(&self, krate: &ast::Crate) {\n         self.inject_sanitizer_runtime();\n         self.inject_profiler_runtime();\n         self.inject_allocator_crate(krate);\n@@ -984,9 +971,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn process_extern_crate(\n-        &mut self, item: &ast::Item, definitions: &Definitions,\n-    ) -> CrateNum {\n+    pub fn process_extern_crate(&self, item: &ast::Item, definitions: &Definitions) -> CrateNum {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n@@ -1019,18 +1004,13 @@ impl<'a> CrateLoader<'a> {\n                     },\n                     &mut FxHashSet::default(),\n                 );\n-                self.cstore.add_extern_mod_stmt_cnum(item.id, cnum);\n                 cnum\n             }\n             _ => bug!(),\n         }\n     }\n \n-    pub fn process_path_extern(\n-        &mut self,\n-        name: Symbol,\n-        span: Span,\n-    ) -> CrateNum {\n+    pub fn process_path_extern(&self, name: Symbol, span: Span) -> CrateNum {\n         let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n \n         self.update_extern_crate(\n@@ -1048,11 +1028,7 @@ impl<'a> CrateLoader<'a> {\n         cnum\n     }\n \n-    pub fn maybe_process_path_extern(\n-        &mut self,\n-        name: Symbol,\n-        span: Span,\n-    ) -> Option<CrateNum> {\n+    pub fn maybe_process_path_extern(&self, name: Symbol, span: Span) -> Option<CrateNum> {\n         let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n \n         self.update_extern_crate("}, {"sha": "a5a458e49a38e5f398c4e3ef45801b670047af0f", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 59, "deletions": 71, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -5,37 +5,29 @@ use crate::schema;\n use rustc::dep_graph::DepNodeIndex;\n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n+use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate, MetadataLoader};\n use rustc::mir::interpret::AllocDecodingState;\n use rustc_index::vec::IndexVec;\n-use rustc::util::nodemap::{FxHashMap, NodeMap};\n-\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock, AtomicCell};\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::sync::{Lrc, RwLock, Lock, MetadataRef, AtomicCell};\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax_pos;\n-\n-pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n-pub use rustc::middle::cstore::NativeLibraryKind::*;\n-pub use rustc::middle::cstore::{CrateSource, LibSource, ForeignModule};\n+use proc_macro::bridge::client::ProcMacro;\n \n pub use crate::cstore_impl::{provide, provide_extern};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n+crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-pub use rustc_data_structures::sync::MetadataRef;\n-use syntax_pos::Span;\n-use proc_macro::bridge::client::ProcMacro;\n-\n-pub struct MetadataBlob(pub MetadataRef);\n+crate struct MetadataBlob(pub MetadataRef);\n \n /// Holds information about a syntax_pos::SourceFile imported from another crate.\n /// See `imported_source_files()` for more information.\n-pub struct ImportedSourceFile {\n+crate struct ImportedSourceFile {\n     /// This SourceFile's byte-offset within the source_map of its original crate\n     pub original_start_pos: syntax_pos::BytePos,\n     /// The end of this SourceFile within the source_map of its original crate\n@@ -45,59 +37,66 @@ pub struct ImportedSourceFile {\n }\n \n pub struct CrateMetadata {\n-    /// Information about the extern crate that caused this crate to\n-    /// be loaded. If this is `None`, then the crate was injected\n-    /// (e.g., by the allocator)\n-    pub extern_crate: Lock<Option<ExternCrate>>,\n-\n-    pub blob: MetadataBlob,\n-    pub cnum_map: CrateNumMap,\n-    pub cnum: CrateNum,\n-    pub dependencies: Lock<Vec<CrateNum>>,\n-    pub source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n+    /// The primary crate data - binary metadata blob.\n+    crate blob: MetadataBlob,\n \n-    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n-    pub alloc_decoding_state: AllocDecodingState,\n-\n-    // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    // lifetime is only used behind `Lazy`, and therefore acts like an\n-    // universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n-    // is being used to decode those values.\n-    pub root: schema::CrateRoot<'static>,\n+    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n \n+    /// Properties of the whole crate.\n+    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n+    /// lifetime is only used behind `Lazy`, and therefore acts like an\n+    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    /// is being used to decode those values.\n+    crate root: schema::CrateRoot<'static>,\n     /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub def_path_table: Lrc<DefPathTable>,\n-\n-    pub trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n-\n-    pub dep_kind: Lock<DepKind>,\n-    pub source: CrateSource,\n-\n+    crate def_path_table: Lrc<DefPathTable>,\n+    /// Trait impl data.\n+    /// FIXME: Used only from queries and can use query cache,\n+    /// so pre-decoding can probably be avoided.\n+    crate trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n+    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n+    crate raw_proc_macros: Option<&'static [ProcMacro]>,\n+    /// Source maps for code from the crate.\n+    crate source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n+    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n+    crate alloc_decoding_state: AllocDecodingState,\n+    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n+    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n+    /// Do not access the value directly, as it might not have been initialized yet.\n+    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n+    crate dep_node_index: AtomicCell<DepNodeIndex>,\n+\n+    // --- Other significant crate properties ---\n+\n+    /// ID of this crate, from the current compilation session's point of view.\n+    crate cnum: CrateNum,\n+    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n+    /// IDs as they are seen from the current compilation session.\n+    crate cnum_map: CrateNumMap,\n+    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n+    crate dependencies: Lock<Vec<CrateNum>>,\n+    /// How to link (or not link) this crate to the currently compiled crate.\n+    crate dep_kind: Lock<DepKind>,\n+    /// Filesystem location of this crate.\n+    crate source: CrateSource,\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n-    pub private_dep: bool,\n+    crate private_dep: bool,\n \n-    pub span: Span,\n+    // --- Data used only for improving diagnostics ---\n \n-    pub raw_proc_macros: Option<&'static [ProcMacro]>,\n-\n-    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n-    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n-    /// Do not access the value directly, as it might not have been initialized\n-    /// yet.\n-    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n-    pub(super) dep_node_index: AtomicCell<DepNodeIndex>,\n+    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n+    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n+    crate extern_crate: Lock<Option<ExternCrate>>,\n }\n \n pub struct CStore {\n     metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n-    /// Map from NodeId's of local extern crate statements to crate numbers\n-    extern_mod_crate_map: Lock<NodeMap<CrateNum>>,\n-    pub metadata_loader: Box<dyn MetadataLoader + Sync>,\n+    crate metadata_loader: Box<dyn MetadataLoader + Sync>,\n }\n \n pub enum LoadedMacro {\n@@ -113,30 +112,29 @@ impl CStore {\n             // corresponding `CrateNum`. This first entry will always remain\n             // `None`.\n             metas: RwLock::new(IndexVec::from_elem_n(None, 1)),\n-            extern_mod_crate_map: Default::default(),\n             metadata_loader,\n         }\n     }\n \n-    pub(super) fn alloc_new_crate_num(&self) -> CrateNum {\n+    crate fn alloc_new_crate_num(&self) -> CrateNum {\n         let mut metas = self.metas.borrow_mut();\n         let cnum = CrateNum::new(metas.len());\n         metas.push(None);\n         cnum\n     }\n \n-    pub(super) fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n         self.metas.borrow()[cnum].clone()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n     }\n \n-    pub(super) fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n+    crate fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {\n         let mut metas = self.metas.borrow_mut();\n         assert!(metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n         metas[cnum] = Some(data);\n     }\n \n-    pub(super) fn iter_crate_data<I>(&self, mut i: I)\n+    crate fn iter_crate_data<I>(&self, mut i: I)\n         where I: FnMut(CrateNum, &Lrc<CrateMetadata>)\n     {\n         for (k, v) in self.metas.borrow().iter_enumerated() {\n@@ -146,16 +144,14 @@ impl CStore {\n         }\n     }\n \n-    pub(super) fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n+    crate fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);\n         ordering.reverse();\n         ordering\n     }\n \n-    pub(super) fn push_dependencies_in_postorder(&self,\n-                                                 ordering: &mut Vec<CrateNum>,\n-                                                 krate: CrateNum) {\n+    crate fn push_dependencies_in_postorder(&self, ordering: &mut Vec<CrateNum>, krate: CrateNum) {\n         if ordering.contains(&krate) {\n             return;\n         }\n@@ -170,7 +166,7 @@ impl CStore {\n         ordering.push(krate);\n     }\n \n-    pub(super) fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n+    crate fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         for (num, v) in self.metas.borrow().iter_enumerated() {\n             if let &Some(_) = v {\n@@ -179,12 +175,4 @@ impl CStore {\n         }\n         return ordering\n     }\n-\n-    pub(super) fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n-        self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n-    }\n-\n-    pub(super) fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n-        self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n-    }\n }"}, {"sha": "fd011265da7cb72d3527bf71c86bb4ae262b1b9e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -6,8 +6,7 @@ use crate::foreign_modules;\n use crate::schema;\n \n use rustc::ty::query::QueryConfig;\n-use rustc::middle::cstore::{CrateStore, DepKind,\n-                            EncodedMetadata, NativeLibraryKind};\n+use rustc::middle::cstore::{CrateSource, CrateStore, DepKind, EncodedMetadata, NativeLibraryKind};\n use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::middle::stability::DeprecationEntry;\n use rustc::middle::dependency_format::Linkage;\n@@ -414,12 +413,6 @@ impl cstore::CStore {\n         }\n     }\n \n-    pub fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind {\n-        let data = self.get_crate_data(cnum);\n-        let r = *data.dep_kind.lock();\n-        r\n-    }\n-\n     pub fn crate_edition_untracked(&self, cnum: CrateNum) -> Edition {\n         self.get_crate_data(cnum).root.edition\n     }\n@@ -428,14 +421,6 @@ impl cstore::CStore {\n         self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n     }\n \n-    pub fn ctor_kind_untracked(&self, def: DefId) -> def::CtorKind {\n-        self.get_crate_data(def.krate).get_ctor_kind(def.index)\n-    }\n-\n-    pub fn item_attrs_untracked(&self, def: DefId, sess: &Session) -> Lrc<[ast::Attribute]> {\n-        self.get_crate_data(def.krate).get_item_attrs(def.index, sess)\n-    }\n-\n     pub fn item_children_untracked(\n         &self,\n         def_id: DefId,\n@@ -493,6 +478,10 @@ impl cstore::CStore {\n     pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n+\n+    pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {\n+        self.get_crate_data(cnum).source.clone()\n+    }\n }\n \n impl CrateStore for cstore::CStore {\n@@ -549,11 +538,6 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n-    {\n-        self.do_extern_mod_stmt_cnum(emod_id)\n-    }\n-\n     fn postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         self.do_postorder_cnums_untracked()\n     }"}, {"sha": "6969d608d76da1da75d39d75f3fdd8edda48db9a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -1,13 +1,13 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob};\n use crate::schema::*;\n \n use rustc_index::vec::IndexVec;\n use rustc_data_structures::sync::{Lrc, ReadGuard};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n-use rustc::middle::cstore::LinkagePreference;\n+use rustc::middle::cstore::{LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -38,7 +38,7 @@ use log::debug;\n use proc_macro::bridge::client::ProcMacro;\n use syntax::ext::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n \n-pub struct DecodeContext<'a, 'tcx> {\n+crate struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'tcx Session>,\n@@ -54,7 +54,7 @@ pub struct DecodeContext<'a, 'tcx> {\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n-pub trait Metadata<'a, 'tcx>: Copy {\n+crate trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'tcx Session> { None }\n@@ -130,15 +130,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n }\n \n impl<'a, 'tcx, T: Decodable> Lazy<T> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n+    crate fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(\n+    crate fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n@@ -149,11 +149,11 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n-    pub fn cdata(&self) -> &'a CrateMetadata {\n+    fn cdata(&self) -> &'a CrateMetadata {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n@@ -379,15 +379,15 @@ for DecodeContext<'a, 'tcx> {\n implement_ty_decoder!( DecodeContext<'a, 'tcx> );\n \n impl<'tcx> MetadataBlob {\n-    pub fn is_compatible(&self) -> bool {\n+    crate fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n \n-    pub fn get_rustc_version(&self) -> String {\n+    crate fn get_rustc_version(&self) -> String {\n         Lazy::<String>::from_position(METADATA_HEADER.len() + 4).decode(self)\n     }\n \n-    pub fn get_root(&self) -> CrateRoot<'tcx> {\n+    crate fn get_root(&self) -> CrateRoot<'tcx> {\n         let slice = self.raw_bytes();\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n@@ -396,7 +396,7 @@ impl<'tcx> MetadataBlob {\n         Lazy::<CrateRoot<'tcx>>::from_position(pos).decode(self)\n     }\n \n-    pub fn list_crate_metadata(&self,\n+    crate fn list_crate_metadata(&self,\n                                out: &mut dyn io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n@@ -449,7 +449,7 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n-    pub fn is_proc_macro_crate(&self) -> bool {\n+    crate fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n \n@@ -499,7 +499,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    pub fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    crate fn item_name(&self, item_index: DefIndex) -> Symbol {\n         if !self.is_proc_macro(item_index) {\n             self.def_key(item_index)\n                 .disambiguated_data\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n+    crate fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n@@ -522,7 +522,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+    crate fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n         self.entry(index).span.decode((self, sess))\n     }\n \n@@ -556,7 +556,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n+    crate fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         match self.entry(item_id).kind {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+    crate fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -647,23 +647,23 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, kind, variants, repr)\n     }\n \n-    pub fn get_predicates(\n+    crate fn get_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n }\n \n-    pub fn get_predicates_defined_on(\n+    crate fn get_predicates_defined_on(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_super_predicates(\n+    crate fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n@@ -677,30 +677,27 @@ impl<'a, 'tcx> CrateMetadata {\n         super_predicates.decode((self, tcx))\n     }\n \n-    pub fn get_generics(&self,\n-                        item_id: DefIndex,\n-                        sess: &Session)\n-                        -> ty::Generics {\n+    crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.entry(item_id).generics.unwrap().decode((self, sess))\n     }\n \n-    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    crate fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         self.entry(id).ty.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+    crate fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability.clone(),\n             false => self.entry(id).stability.map(|stab| stab.decode(self)),\n         }\n     }\n \n-    pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+    crate fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.entry_unless_proc_macro(id)\n             .and_then(|entry| entry.deprecation.map(|depr| depr.decode(self)))\n     }\n \n-    pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+    crate fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n             false => self.entry(id).visibility.decode(self),\n@@ -714,30 +711,31 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+    crate fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    pub fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n+    crate fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n \n-    pub fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n+    crate fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n         self.get_impl_data(id).defaultness\n     }\n \n-    pub fn get_coerce_unsized_info(&self,\n-                                   id: DefIndex)\n-                                   -> Option<ty::adjustment::CoerceUnsizedInfo> {\n+    crate fn get_coerce_unsized_info(\n+        &self,\n+        id: DefIndex,\n+    ) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    pub fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n+    crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    pub fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    crate fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root\n@@ -746,7 +744,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    crate fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -759,7 +757,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    pub fn get_diagnostic_items(\n+    crate fn get_diagnostic_items(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx FxHashMap<Symbol, DefId> {\n@@ -776,7 +774,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over each child of the given item.\n-    pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n+    crate fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n         if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n@@ -911,20 +909,20 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+    crate fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    crate fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.entry_unless_proc_macro(id)\n             .and_then(|entry| entry.mir.map(|mir| mir.decode((self, tcx))))\n             .unwrap_or_else(|| {\n                 bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n     }\n \n-    pub fn get_promoted_mir(\n+    crate fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -936,7 +934,7 @@ impl<'a, 'tcx> CrateMetadata {\n             })\n     }\n \n-    pub fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+    crate fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n         match self.entry(id).kind {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n@@ -947,7 +945,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n+    crate fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n         let item = self.entry(id);\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n@@ -981,11 +979,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n+    crate fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n         self.entry(id).variances.decode(self).collect()\n     }\n \n-    pub fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n+    crate fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n         match self.entry(node_id).kind {\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) |\n@@ -994,7 +992,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+    crate fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.entry(node_id).kind {\n             EntryKind::Struct(data, _) => {\n                 data.decode(self).ctor.map(|index| self.local_def_id(index))\n@@ -1006,8 +1004,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-\n-    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n+    crate fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1022,7 +1019,11 @@ impl<'a, 'tcx> CrateMetadata {\n         Lrc::from(self.get_attributes(&item, sess))\n     }\n \n-    pub fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<ast::Name>> {\n+    crate fn get_struct_field_names(\n+        &self,\n+        id: DefIndex,\n+        sess: &Session,\n+    ) -> Vec<Spanned<ast::Name>> {\n         self.entry(id)\n             .children\n             .decode(self)\n@@ -1049,7 +1050,7 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    pub fn get_inherent_implementations_for_type(\n+    crate fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -1060,7 +1061,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                       .map(|index| self.local_def_id(index)))\n     }\n \n-    pub fn get_implementations_for_trait(\n+    crate fn get_implementations_for_trait(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n@@ -1091,7 +1092,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+    crate fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n         let def_key = self.def_key(id);\n         match def_key.disambiguated_data.data {\n             DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n@@ -1108,7 +1109,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n+    crate fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1117,7 +1118,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n+    crate fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1126,7 +1127,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_dylib_dependency_formats(\n+    crate fn get_dylib_dependency_formats(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n@@ -1140,7 +1141,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    crate fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1151,7 +1152,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+    crate fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n         let param_names = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).param_names,\n@@ -1161,7 +1162,7 @@ impl<'a, 'tcx> CrateMetadata {\n         param_names.decode(self).collect()\n     }\n \n-    pub fn exported_symbols(\n+    crate fn exported_symbols(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n@@ -1174,15 +1175,15 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_rendered_const(&self, id: DefIndex) -> String {\n+    crate fn get_rendered_const(&self, id: DefIndex) -> String {\n         match self.entry(id).kind {\n             EntryKind::Const(_, data) |\n             EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n             _ => bug!(),\n         }\n     }\n \n-    pub fn get_macro(&self, id: DefIndex) -> MacroDef {\n+    crate fn get_macro(&self, id: DefIndex) -> MacroDef {\n         let entry = self.entry(id);\n         match entry.kind {\n             EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n@@ -1200,7 +1201,7 @@ impl<'a, 'tcx> CrateMetadata {\n         constness == hir::Constness::Const\n     }\n \n-    pub fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+    crate fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n          match self.entry(id).kind {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n@@ -1209,7 +1210,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_foreign_item(&self, id: DefIndex) -> bool {\n+    crate fn is_foreign_item(&self, id: DefIndex) -> bool {\n         match self.entry(id).kind {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n@@ -1228,7 +1229,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+    crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         let sig = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).sig,\n@@ -1242,7 +1243,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     #[inline]\n-    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+    crate fn def_key(&self, index: DefIndex) -> DefKey {\n         let mut key = self.def_path_table.def_key(index);\n         if self.is_proc_macro(index) {\n             let name = self.raw_proc_macro(index).name();\n@@ -1252,13 +1253,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     // Returns the path leading to the thing with this `id`.\n-    pub fn def_path(&self, id: DefIndex) -> DefPath {\n+    crate fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n-    pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+    crate fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.def_path_table.def_path_hash(index)\n     }\n \n@@ -1287,9 +1288,10 @@ impl<'a, 'tcx> CrateMetadata {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    pub fn imported_source_files(&'a self,\n-                                 local_source_map: &source_map::SourceMap)\n-                                 -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n+    fn imported_source_files(\n+        &'a self,\n+        local_source_map: &source_map::SourceMap,\n+    ) -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n         {\n             let source_files = self.source_map_import_info.borrow();\n             if !source_files.is_empty() {"}, {"sha": "7f76a9730e198392cde7ac039bef100cc77ad373", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -60,7 +60,7 @@ use rustc::ty::TyCtxt;\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n \n-pub fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n+crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n     tcx.sess.crate_types.borrow().iter().map(|&ty| {\n         let linkage = calculate_type(tcx, ty);\n         verify_ok(tcx, &linkage);"}, {"sha": "3871eb89f7b42c42e4c49dd5bc181d04659b00f2", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 14, "deletions": 47, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -32,30 +32,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Loads a dynamic library into the global namespace (RTLD_GLOBAL on Unix)\n-    /// and do it now (don't use RTLD_LAZY on Unix).\n-    pub fn open_global_now(filename: &Path) -> Result<DynamicLibrary, String> {\n-        let maybe_library = dl::open_global_now(filename.as_os_str());\n-        match maybe_library {\n-            Err(err) => Err(err),\n-            Ok(handle) => Ok(DynamicLibrary { handle })\n-        }\n-    }\n-\n-    /// Returns the environment variable for this process's dynamic library\n-    /// search path\n-    pub fn envvar() -> &'static str {\n-        if cfg!(windows) {\n-            \"PATH\"\n-        } else if cfg!(target_os = \"macos\") {\n-            \"DYLD_LIBRARY_PATH\"\n-        } else if cfg!(target_os = \"haiku\") {\n-            \"LIBRARY_PATH\"\n-        } else {\n-            \"LD_LIBRARY_PATH\"\n-        }\n-    }\n-\n     /// Accesses the value at the symbol of the dynamic library.\n     pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n         // This function should have a lifetime constraint of 'a on\n@@ -83,7 +59,7 @@ mod dl {\n     use std::ptr;\n     use std::str;\n \n-    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n+    pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         check_for_errors_in(|| {\n             unsafe {\n                 match filename {\n@@ -94,13 +70,6 @@ mod dl {\n         })\n     }\n \n-    pub fn open_global_now(filename: &OsStr) -> Result<*mut u8, String> {\n-        check_for_errors_in(|| unsafe {\n-            let s = CString::new(filename.as_bytes()).unwrap();\n-            libc::dlopen(s.as_ptr(), libc::RTLD_GLOBAL | libc::RTLD_NOW) as *mut u8\n-        })\n-    }\n-\n     unsafe fn open_external(filename: &OsStr) -> *mut u8 {\n         let s = CString::new(filename.as_bytes()).unwrap();\n         libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) as *mut u8\n@@ -110,8 +79,8 @@ mod dl {\n         libc::dlopen(ptr::null(), libc::RTLD_LAZY) as *mut u8\n     }\n \n-    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n-        F: FnOnce() -> T,\n+    fn check_for_errors_in<T, F>(f: F) -> Result<T, String>\n+        where F: FnOnce() -> T,\n     {\n         use std::sync::{Mutex, Once};\n         static INIT: Once = Once::new();\n@@ -139,14 +108,15 @@ mod dl {\n         }\n     }\n \n-    pub unsafe fn symbol(handle: *mut u8,\n-                         symbol: *const libc::c_char)\n-                         -> Result<*mut u8, String> {\n+    pub(super) unsafe fn symbol(\n+        handle: *mut u8,\n+        symbol: *const libc::c_char,\n+    ) -> Result<*mut u8, String> {\n         check_for_errors_in(|| {\n             libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8\n         })\n     }\n-    pub unsafe fn close(handle: *mut u8) {\n+    pub(super) unsafe fn close(handle: *mut u8) {\n         libc::dlclose(handle as *mut libc::c_void); ()\n     }\n }\n@@ -178,11 +148,7 @@ mod dl {\n         fn FreeLibrary(handle: HMODULE) -> BOOL;\n     }\n \n-    pub fn open_global_now(filename: &OsStr) -> Result<*mut u8, String> {\n-        open(Some(filename))\n-    }\n-\n-    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n+    pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n         let prev_error_mode = unsafe {\n             // SEM_FAILCRITICALERRORS 0x01\n@@ -225,14 +191,15 @@ mod dl {\n         result\n     }\n \n-    pub unsafe fn symbol(handle: *mut u8,\n-                         symbol: *const c_char)\n-                         -> Result<*mut u8, String> {\n+    pub(super) unsafe fn symbol(\n+        handle: *mut u8,\n+        symbol: *const c_char,\n+    ) -> Result<*mut u8, String> {\n         let ptr = GetProcAddress(handle as HMODULE, symbol) as *mut u8;\n         ptr_result(ptr)\n     }\n \n-    pub unsafe fn close(handle: *mut u8) {\n+    pub(super) unsafe fn close(handle: *mut u8) {\n         FreeLibrary(handle as HMODULE);\n     }\n "}, {"sha": "03a14f886455af38b2e6b74c7492c6aef5e1ef24", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -5,7 +5,7 @@ use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc::hir::GenericParamKind;\n+use rustc::hir::{GenericParamKind, AnonConst};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n@@ -42,9 +42,9 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-pub struct EncodeContext<'tcx> {\n+struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n-    pub tcx: TyCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n \n     entries_index: Index<'tcx>,\n \n@@ -313,11 +313,12 @@ impl<'tcx> EncodeContext<'tcx> {\n     /// the `Entry` (which may point to other encoded information)\n     /// and will then record the `Lazy<Entry>` for use in the index.\n     // FIXME(eddyb) remove this.\n-    pub fn record<DATA>(&mut self,\n-                        id: DefId,\n-                        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n-                        data: DATA)\n-    {\n+    fn record<DATA>(\n+        &mut self,\n+        id: DefId,\n+        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n+        data: DATA,\n+    ) {\n         assert!(id.is_local());\n \n         let entry = op(self, data);\n@@ -1711,6 +1712,11 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         intravisit::walk_expr(self, ex);\n         self.encode_info_for_expr(ex);\n     }\n+    fn visit_anon_const(&mut self, c: &'tcx AnonConst) {\n+        intravisit::walk_anon_const(self, c);\n+        let def_id = self.tcx.hir().local_def_id(c.hir_id);\n+        self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n+    }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n@@ -1728,25 +1734,10 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n                           EncodeContext::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n-    fn visit_variant(&mut self,\n-                     v: &'tcx hir::Variant,\n-                     g: &'tcx hir::Generics,\n-                     id: hir::HirId) {\n-        intravisit::walk_variant(self, v, g, id);\n-\n-        if let Some(ref discr) = v.disr_expr {\n-            let def_id = self.tcx.hir().local_def_id(discr.hir_id);\n-            self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n-        }\n-    }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         intravisit::walk_generics(self, generics);\n         self.encode_info_for_generics(generics);\n     }\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        intravisit::walk_ty(self, ty);\n-        self.encode_info_for_ty(ty);\n-    }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         self.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n@@ -1784,16 +1775,6 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        match ty.kind {\n-            hir::TyKind::Array(_, ref length) => {\n-                let def_id = self.tcx.hir().local_def_id(length.hir_id);\n-                self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.kind {\n             hir::ExprKind::Closure(..) => {\n@@ -1920,7 +1901,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n+crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n@@ -1962,7 +1943,7 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     EncodedMetadata { raw_data: result }\n }\n \n-pub fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n+fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n     match ty.kind {\n         ty::Adt(ref def, _) => return def.repr,"}, {"sha": "fa1402584eda50f7ba83eead17510d5b97e0b88e", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -3,7 +3,7 @@ use rustc::hir;\n use rustc::middle::cstore::ForeignModule;\n use rustc::ty::TyCtxt;\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut collector = Collector {\n         tcx,\n         modules: Vec::new(),"}, {"sha": "037f9d35630833702ae7d8e31a2ec55bdf72e11e", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -7,7 +7,7 @@ use std::u32;\n use log::debug;\n \n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n-pub trait FixedSizeEncoding {\n+trait FixedSizeEncoding {\n     const BYTE_LEN: usize;\n \n     // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n@@ -75,25 +75,25 @@ impl FixedSizeEncoding for u32 {\n /// `u32::MAX`. Whenever an index is visited, we fill in the\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n-pub struct Index<'tcx> {\n+crate struct Index<'tcx> {\n     positions: Vec<u8>,\n     _marker: PhantomData<&'tcx ()>,\n }\n \n impl Index<'tcx> {\n-    pub fn new(max_index: usize) -> Self {\n+    crate fn new(max_index: usize) -> Self {\n         Index {\n             positions: vec![0xff; max_index * 4],\n             _marker: PhantomData,\n         }\n     }\n \n-    pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'tcx>>) {\n+    crate fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'tcx>>) {\n         assert!(def_id.is_local());\n         self.record_index(def_id.index, entry);\n     }\n \n-    pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n+    fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n         assert!(entry.position < (u32::MAX as usize));\n         let position = entry.position as u32;\n         let array_index = item.index();\n@@ -108,7 +108,7 @@ impl Index<'tcx> {\n         position.write_to_bytes_at(positions, array_index)\n     }\n \n-    pub fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n+    crate fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n@@ -123,7 +123,7 @@ impl Lazy<[Index<'tcx>]> {\n     /// Given the metadata, extract out the offset of a particular\n     /// DefIndex (if any).\n     #[inline(never)]\n-    pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n+    crate fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         let bytes = &bytes[self.position..];\n         debug!(\"Index::lookup: index={:?} len={:?}\",\n                def_index,"}, {"sha": "4291f3a4ae34e74358513fcd37f3cf9d931a9160", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     let mut collector = Collector {\n         args: Vec::new(),\n     };"}, {"sha": "05676dad3340c7553772ea73f362222ced55f033", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 36, "deletions": 53, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -212,13 +212,14 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use crate::cstore::{MetadataRef, MetadataBlob};\n+use crate::cstore::{MetadataBlob, CStore};\n use crate::creader::Library;\n use crate::schema::{METADATA_HEADER, rustc_version};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc_data_structures::sync::MetadataRef;\n+use rustc::middle::cstore::{CrateSource, MetadataLoader};\n use rustc::session::{config, Session};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n@@ -245,13 +246,13 @@ use rustc_data_structures::owning_ref::OwningRef;\n use log::{debug, info, warn};\n \n #[derive(Clone)]\n-pub struct CrateMismatch {\n+crate struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n }\n \n #[derive(Clone)]\n-pub struct Context<'a> {\n+crate struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n     pub crate_name: Symbol,\n@@ -272,11 +273,9 @@ pub struct Context<'a> {\n     pub metadata_loader: &'a dyn MetadataLoader,\n }\n \n-pub struct CratePaths {\n-    pub ident: String,\n-    pub dylib: Option<PathBuf>,\n-    pub rlib: Option<PathBuf>,\n-    pub rmeta: Option<PathBuf>,\n+crate struct CratePaths {\n+    pub name: Symbol,\n+    pub source: CrateSource,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -296,22 +295,16 @@ impl fmt::Display for CrateFlavor {\n     }\n }\n \n-impl CratePaths {\n-    fn paths(&self) -> Vec<PathBuf> {\n-        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).cloned().collect()\n-    }\n-}\n-\n impl<'a> Context<'a> {\n-    pub fn reset(&mut self) {\n+    crate fn reset(&mut self) {\n         self.rejected_via_hash.clear();\n         self.rejected_via_triple.clear();\n         self.rejected_via_kind.clear();\n         self.rejected_via_version.clear();\n         self.rejected_via_filename.clear();\n     }\n \n-    pub fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+    crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n         let mut seen_paths = FxHashSet::default();\n         match self.extra_filename {\n             Some(s) => self.find_library_crate(s, &mut seen_paths)\n@@ -320,10 +313,10 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    pub fn report_errs(self) -> ! {\n+    crate fn report_errs(self) -> ! {\n         let add = match self.root {\n             None => String::new(),\n-            Some(r) => format!(\" which `{}` depends on\", r.ident),\n+            Some(r) => format!(\" which `{}` depends on\", r.name),\n         };\n         let mut msg = \"the following crate versions were found:\".to_string();\n         let mut err = if !self.rejected_via_hash.is_empty() {\n@@ -341,8 +334,8 @@ impl<'a> Context<'a> {\n             match self.root {\n                 None => {}\n                 Some(r) => {\n-                    for path in r.paths().iter() {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.ident, path.display()));\n+                    for path in r.source.paths() {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n                     }\n                 }\n             }\n@@ -534,18 +527,8 @@ impl<'a> Context<'a> {\n         // search is being performed for.\n         let mut libraries = FxHashMap::default();\n         for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n-            let mut slot = None;\n-            let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n-            let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n-            let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n-            if let Some((h, m)) = slot {\n-                libraries.insert(h,\n-                                 Library {\n-                                     dylib,\n-                                     rlib,\n-                                     rmeta,\n-                                     metadata: m,\n-                                 });\n+            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs) {\n+                libraries.insert(svh, lib);\n             }\n         }\n \n@@ -563,7 +546,7 @@ impl<'a> Context<'a> {\n                                                self.crate_name);\n                 let candidates = libraries.iter().filter_map(|(_, lib)| {\n                     let crate_name = &lib.metadata.get_root().name.as_str();\n-                    match &(&lib.dylib, &lib.rlib) {\n+                    match &(&lib.source.dylib, &lib.source.rlib) {\n                         &(&Some((ref pd, _)), &Some((ref pr, _))) => {\n                             Some(format!(\"\\ncrate `{}`: {}\\n{:>padding$}\",\n                                          crate_name,\n@@ -584,6 +567,21 @@ impl<'a> Context<'a> {\n         }\n     }\n \n+    fn extract_lib(\n+        &mut self,\n+        rlibs: FxHashMap<PathBuf, PathKind>,\n+        rmetas: FxHashMap<PathBuf, PathKind>,\n+        dylibs: FxHashMap<PathBuf, PathKind>,\n+    ) -> Option<(Svh, Library)> {\n+        let mut slot = None;\n+        let source = CrateSource {\n+            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot),\n+            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot),\n+            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot),\n+        };\n+        slot.map(|(svh, metadata)| (svh, Library { source, metadata }))\n+    }\n+\n     // Attempts to extract *one* library from the set `m`. If the set has no\n     // elements, `None` is returned. If the set has more than one element, then\n     // the errors and notes are emitted about the set of libraries.\n@@ -828,23 +826,8 @@ impl<'a> Context<'a> {\n             }\n         };\n \n-        // Extract the rlib/dylib pair.\n-        let mut slot = None;\n-        let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n-        let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n-        let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n-\n-        if rlib.is_none() && rmeta.is_none() && dylib.is_none() {\n-            return None;\n-        }\n-        slot.map(|(_, metadata)|\n-            Library {\n-                dylib,\n-                rlib,\n-                rmeta,\n-                metadata,\n-            }\n-        )\n+        // Extract the dylib/rlib/rmeta triple.\n+        self.extract_lib(rlibs, rmetas, dylibs).map(|(_, lib)| lib)\n     }\n }\n \n@@ -931,7 +914,7 @@ fn get_metadata_section_imp(target: &Target,\n /// A diagnostic function for dumping crate metadata to an output stream.\n pub fn list_file_metadata(target: &Target,\n                           path: &Path,\n-                          loader: &dyn MetadataLoader,\n+                          cstore: &CStore,\n                           out: &mut dyn io::Write)\n                           -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n@@ -942,7 +925,7 @@ pub fn list_file_metadata(target: &Target,\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path, loader) {\n+    match get_metadata_section(target, flavor, path, &*cstore.metadata_loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "9e4c2685f11626f6744cf8f0b197d9de2a530145", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -11,7 +11,7 @@ use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::{span_err, struct_span_err};\n \n-pub fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n+crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n     let mut collector = Collector {\n         tcx,\n         libs: Vec::new(),\n@@ -21,7 +21,7 @@ pub fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLibrary> {\n     return collector.libs;\n }\n \n-pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+crate fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n         None => true,"}, {"sha": "d3539e7140121e774920b2ef31702a6989892a1a", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -21,15 +21,15 @@ use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n \n-pub fn rustc_version() -> String {\n+crate fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n }\n \n /// Metadata encoding version.\n /// N.B., increment this if you change the format of metadata such that\n /// the rustc version can't be found to compare with `rustc_version()`.\n-pub const METADATA_VERSION: u8 = 4;\n+const METADATA_VERSION: u8 = 4;\n \n /// Metadata header which includes `METADATA_VERSION`.\n /// To get older versions of rustc to ignore this metadata,\n@@ -39,12 +39,12 @@ pub const METADATA_VERSION: u8 = 4;\n /// This header is followed by the position of the `CrateRoot`,\n /// which is encoded as a 32-bit big-endian unsigned integer,\n /// and further followed by the rustc version string.\n-pub const METADATA_HEADER: &[u8; 12] =\n+crate const METADATA_HEADER: &[u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n /// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n-pub trait LazyMeta {\n+crate trait LazyMeta {\n     type Meta: Copy + 'static;\n \n     /// Returns the minimum encoded size.\n@@ -98,7 +98,7 @@ impl<T> LazyMeta for [T] {\n #[must_use]\n // FIXME(#59875) the `Meta` parameter only exists to dodge\n // invariance wrt `T` (coming from the `meta: T::Meta` field).\n-pub struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n+crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n@@ -108,7 +108,7 @@ pub struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n }\n \n impl<T: ?Sized + LazyMeta> Lazy<T> {\n-    pub fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n+    crate fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n         Lazy {\n             position,\n             meta,\n@@ -118,13 +118,13 @@ impl<T: ?Sized + LazyMeta> Lazy<T> {\n }\n \n impl<T> Lazy<T> {\n-    pub fn from_position(position: usize) -> Lazy<T> {\n+    crate fn from_position(position: usize) -> Lazy<T> {\n         Lazy::from_position_and_meta(position, ())\n     }\n }\n \n impl<T> Lazy<[T]> {\n-    pub fn empty() -> Lazy<[T]> {\n+    crate fn empty() -> Lazy<[T]> {\n         Lazy::from_position_and_meta(0, 0)\n     }\n }\n@@ -141,7 +141,7 @@ impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T>\n \n /// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum LazyState {\n+crate enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n@@ -156,7 +156,7 @@ pub enum LazyState {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateRoot<'tcx> {\n+crate struct CrateRoot<'tcx> {\n     pub name: Symbol,\n     pub triple: TargetTriple,\n     pub extra_filename: String,\n@@ -202,21 +202,21 @@ pub struct CrateRoot<'tcx> {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct CrateDep {\n+crate struct CrateDep {\n     pub name: ast::Name,\n     pub hash: Svh,\n     pub kind: DepKind,\n     pub extra_filename: String,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitImpls {\n+crate struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n     pub impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct Entry<'tcx> {\n+crate struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: Lazy<ty::Visibility>,\n     pub span: Lazy<Span>,\n@@ -237,7 +237,7 @@ pub struct Entry<'tcx> {\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum EntryKind<'tcx> {\n+crate enum EntryKind<'tcx> {\n     Const(ConstQualif, Lazy<RenderedConst>),\n     ImmStatic,\n     MutStatic,\n@@ -272,36 +272,36 @@ pub enum EntryKind<'tcx> {\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n-pub struct ConstQualif {\n+crate struct ConstQualif {\n     pub mir: u8,\n }\n \n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct RenderedConst(pub String);\n+crate struct RenderedConst(pub String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ModData {\n+crate struct ModData {\n     pub reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MacroDef {\n+crate struct MacroDef {\n     pub body: String,\n     pub legacy: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct FnData<'tcx> {\n+crate struct FnData<'tcx> {\n     pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData<'tcx> {\n+crate struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n@@ -312,7 +312,7 @@ pub struct VariantData<'tcx> {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitData<'tcx> {\n+crate struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub paren_sugar: bool,\n     pub has_auto_impl: bool,\n@@ -321,12 +321,12 @@ pub struct TraitData<'tcx> {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct TraitAliasData<'tcx> {\n+crate struct TraitAliasData<'tcx> {\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ImplData<'tcx> {\n+crate struct ImplData<'tcx> {\n     pub polarity: ty::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n     pub parent_impl: Option<DefId>,\n@@ -341,15 +341,15 @@ pub struct ImplData<'tcx> {\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum AssocContainer {\n+crate enum AssocContainer {\n     TraitRequired,\n     TraitWithDefault,\n     ImplDefault,\n     ImplFinal,\n }\n \n impl AssocContainer {\n-    pub fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n+    crate fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n         match *self {\n             AssocContainer::TraitRequired |\n             AssocContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -359,7 +359,7 @@ impl AssocContainer {\n         }\n     }\n \n-    pub fn defaultness(&self) -> hir::Defaultness {\n+    crate fn defaultness(&self) -> hir::Defaultness {\n         match *self {\n             AssocContainer::TraitRequired => hir::Defaultness::Default {\n                 has_value: false,\n@@ -376,22 +376,22 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct MethodData<'tcx> {\n+crate struct MethodData<'tcx> {\n     pub fn_data: FnData<'tcx>,\n     pub container: AssocContainer,\n     pub has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct ClosureData<'tcx> {\n+crate struct ClosureData<'tcx> {\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct GeneratorData<'tcx> {\n+crate struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,\n }\n \n // Tags used for encoding Spans:\n-pub const TAG_VALID_SPAN: u8 = 0;\n-pub const TAG_INVALID_SPAN: u8 = 1;\n+crate const TAG_VALID_SPAN: u8 = 0;\n+crate const TAG_INVALID_SPAN: u8 = 1;"}, {"sha": "1f86aafbddff57339e24f69c512f68e03c39a9db", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -104,8 +104,7 @@ impl<'a> Resolver<'a> {\n             return self.module_map[&def_id]\n         }\n \n-        let macros_only = self.cstore.dep_kind_untracked(def_id.krate).macros_only();\n-        if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n+        if let Some(&module) = self.extern_module_map.get(&def_id) {\n             return module;\n         }\n \n@@ -121,7 +120,7 @@ impl<'a> Resolver<'a> {\n         let module = self.arenas.alloc_module(ModuleData::new(\n             parent, kind, def_id, ExpnId::root(), DUMMY_SP\n         ));\n-        self.extern_module_map.insert((def_id, macros_only), module);\n+        self.extern_module_map.insert(def_id, module);\n         module\n     }\n \n@@ -618,6 +617,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     let crate_id = self.r.crate_loader.process_extern_crate(\n                         item, &self.r.definitions\n                     );\n+                    self.r.extern_crate_map.insert(item.id, crate_id);\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n "}, {"sha": "5f77bcfeb7ffc689bcda8a4e391a2c5e52f8d297", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -26,7 +26,7 @@ use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::{self, DefKind, PartialRes, CtorKind, CtorOf, NonMacroAttrKind, ExportMap};\n use rustc::hir::def::Namespace::*;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::{TraitMap, GlobMap};\n use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n@@ -855,6 +855,8 @@ pub struct Resolver<'a> {\n     /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n     label_res_map: NodeMap<NodeId>,\n \n+    /// `CrateNum` resolutions of `extern crate` items.\n+    pub extern_crate_map: NodeMap<CrateNum>,\n     pub export_map: ExportMap<NodeId>,\n     pub trait_map: TraitMap,\n \n@@ -878,7 +880,7 @@ pub struct Resolver<'a> {\n     /// language items.\n     empty_module: Module<'a>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n-    extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n+    extern_module_map: FxHashMap<DefId, Module<'a>>,\n     binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n \n     /// Maps glob imports to the names of items actually imported.\n@@ -900,7 +902,7 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n \n-    crate_loader: &'a mut CrateLoader<'a>,\n+    crate_loader: &'a CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Name, SyntaxExtension>,\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n@@ -1070,7 +1072,7 @@ impl<'a> Resolver<'a> {\n                cstore: &'a CStore,\n                krate: &Crate,\n                crate_name: &str,\n-               crate_loader: &'a mut CrateLoader<'a>,\n+               crate_loader: &'a CrateLoader<'a>,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n@@ -1155,6 +1157,7 @@ impl<'a> Resolver<'a> {\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n+            extern_crate_map: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n             empty_module,"}, {"sha": "c2c883fd20e7adbe6104108a6aec71faa25961b4", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -551,7 +551,7 @@ impl MetaItem {\n impl MetaItemKind {\n     pub fn tokens(&self, span: Span) -> TokenStream {\n         match *self {\n-            MetaItemKind::Word => TokenStream::empty(),\n+            MetaItemKind::Word => TokenStream::default(),\n             MetaItemKind::NameValue(ref lit) => {\n                 let mut vec = vec![TokenTree::token(token::Eq, span).into()];\n                 lit.tokens().append_to_tree_and_joint_vec(&mut vec);"}, {"sha": "9fcd918cef1746050dc7b1c95e824cfdf4efca4c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -676,12 +676,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n             }\n             Some(TokenTree::Token(..)) => {}\n-            None => return TokenStream::empty(),\n+            None => return TokenStream::default(),\n         }\n         self.cx.span_err(span, \"custom attribute invocations must be \\\n             of the form `#[foo]` or `#[foo(..)]`, the macro name must only be \\\n             followed by a delimiter token\");\n-        TokenStream::empty()\n+        TokenStream::default()\n     }\n \n     fn gate_proc_macro_attr_item(&self, span: Span, item: &Annotatable) {"}, {"sha": "da930436d817b6d57a474a4270f9c58766bf2835", "filename": "src/libsyntax/ext/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fext%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fext%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Ftranscribe.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -95,7 +95,7 @@ pub(super) fn transcribe(\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n     if src.is_empty() {\n-        return TokenStream::empty();\n+        return TokenStream::default();\n     }\n \n     // We descend into the RHS (`src`), expanding things as we go. This stack contains the things"}, {"sha": "4fae25bbde62cc20ce7fd48611cb22a586946fdc", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -15,7 +15,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     fn mac_placeholder() -> ast::Mac {\n         ast::Mac {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n-            tts: TokenStream::empty().into(),\n+            tts: TokenStream::default().into(),\n             delim: ast::MacDelimiter::Brace,\n             span: DUMMY_SP,\n             prior_type_ascription: None,\n@@ -32,12 +32,12 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n         attrs: ThinVec::new(),\n         kind: ast::ExprKind::Mac(mac_placeholder()),\n     });\n-    let ty = P(ast::Ty {\n+    let ty = || P(ast::Ty {\n         id,\n         kind: ast::TyKind::Mac(mac_placeholder()),\n         span,\n     });\n-    let pat = P(ast::Pat {\n+    let pat = || P(ast::Pat {\n         id,\n         kind: ast::PatKind::Mac(mac_placeholder()),\n         span,\n@@ -83,7 +83,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n                 body: expr_placeholder(),\n                 guard: None,\n                 id,\n-                pat,\n+                pat: pat(),\n                 span,\n                 is_placeholder: true,\n             }\n@@ -105,7 +105,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n                 id,\n                 ident,\n                 is_shorthand: false,\n-                pat,\n+                pat: pat(),\n                 span,\n                 is_placeholder: true,\n             }\n@@ -124,9 +124,9 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n             ast::Param {\n                 attrs: Default::default(),\n                 id,\n-                pat,\n+                pat: pat(),\n                 span,\n-                ty,\n+                ty: ty(),\n                 is_placeholder: true,\n             }\n         ]),\n@@ -136,7 +136,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n                 id,\n                 ident: None,\n                 span,\n-                ty,\n+                ty: ty(),\n                 vis,\n                 is_placeholder: true,\n             }"}, {"sha": "08142ba6c58c5bb343e476bd390ca5a24d65973d", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -394,7 +394,7 @@ impl server::Types for Rustc<'_> {\n \n impl server::TokenStream for Rustc<'_> {\n     fn new(&mut self) -> Self::TokenStream {\n-        TokenStream::empty()\n+        TokenStream::default()\n     }\n     fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n         stream.is_empty()"}, {"sha": "4cf987417b8ed49d0e34507be4a0528ea9c2752e", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -12,7 +12,7 @@\n use crate::source_map::{SourceMap, FilePathMapping};\n \n use errors::registry::Registry;\n-use errors::{SubDiagnostic, CodeSuggestion, SourceMapper};\n+use errors::{SubDiagnostic, CodeSuggestion, SourceMapper, SourceMapperDyn};\n use errors::{DiagnosticId, Applicability};\n use errors::emitter::{Emitter, HumanReadableErrorType};\n \n@@ -113,6 +113,10 @@ impl Emitter for JsonEmitter {\n         }\n     }\n \n+    fn source_map(&self) -> Option<&Lrc<SourceMapperDyn>> {\n+        Some(&self.sm)\n+    }\n+\n     fn should_show_explain(&self) -> bool {\n         match self.json_rendered {\n             HumanReadableErrorType::Short(_) => false,"}, {"sha": "60ee17d09b7557dcb42cbceb6fe1abdd0632737d", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -610,10 +610,8 @@ pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n }\n \n pub fn noop_visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T) {\n-    visit_opt(tts, |tts| {\n-        let tts = Lrc::make_mut(tts);\n-        visit_vec(tts, |(tree, _is_joint)| vis.visit_tt(tree));\n-    })\n+    let tts = Lrc::make_mut(tts);\n+    visit_vec(tts, |(tree, _is_joint)| vis.visit_tt(tree));\n }\n \n // Applies ident visitor if it's an ident; applies other visits to interpolated nodes."}, {"sha": "0963efcfc8ac082610d73722eb80b1f3d11f1ce3", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -203,7 +203,7 @@ impl<'a> Parser<'a> {\n                 };\n                 TokenStream::from_streams(smallvec![eq.into(), tokens])\n             } else {\n-                TokenStream::empty()\n+                TokenStream::default()\n             };\n             ast::AttrItem { path, tokens }\n         })"}, {"sha": "478cfefc2247bdc74b682115499874732112f7b9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -1273,7 +1273,7 @@ impl<'a> Parser<'a> {\n             // This can happen due to a bad interaction of two unrelated recovery mechanisms with\n             // mismatched delimiters *and* recovery lookahead on the likely typo `pub ident(`\n             // (#62881).\n-            return Ok((ret?, TokenStream::new(vec![])));\n+            return Ok((ret?, TokenStream::default()));\n         } else {\n             &mut self.token_cursor.stack[prev].last_token\n         };\n@@ -1288,7 +1288,7 @@ impl<'a> Parser<'a> {\n                 // This can happen due to a bad interaction of two unrelated recovery mechanisms\n                 // with mismatched delimiters *and* recovery lookahead on the likely typo\n                 // `pub ident(` (#62895, different but similar to the case above).\n-                return Ok((ret?, TokenStream::new(vec![])));\n+                return Ok((ret?, TokenStream::default()));\n             }\n         };\n "}, {"sha": "e288346a329271cc80416b7a0976b1c170e730d7", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -367,6 +367,7 @@ impl<'a> Parser<'a> {\n \n         let pat = self.mk_pat(lo.to(self.prev_span), pat);\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n+        let pat = self.recover_intersection_pat(pat)?;\n \n         if !allow_range_pat {\n             self.ban_pat_range_if_ambiguous(&pat)?\n@@ -375,6 +376,65 @@ impl<'a> Parser<'a> {\n         Ok(pat)\n     }\n \n+    /// Try to recover the more general form `intersect ::= $pat_lhs @ $pat_rhs`.\n+    ///\n+    /// Allowed binding patterns generated by `binding ::= ref? mut? $ident @ $pat_rhs`\n+    /// should already have been parsed by now  at this point,\n+    /// if the next token is `@` then we can try to parse the more general form.\n+    ///\n+    /// Consult `parse_pat_ident` for the `binding` grammar.\n+    ///\n+    /// The notion of intersection patterns are found in\n+    /// e.g. [F#][and] where they are called AND-patterns.\n+    ///\n+    /// [and]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/pattern-matching\n+    fn recover_intersection_pat(&mut self, lhs: P<Pat>) -> PResult<'a, P<Pat>> {\n+        if self.token.kind != token::At {\n+            // Next token is not `@` so it's not going to be an intersection pattern.\n+            return Ok(lhs);\n+        }\n+\n+        // At this point we attempt to parse `@ $pat_rhs` and emit an error.\n+        self.bump(); // `@`\n+        let mut rhs = self.parse_pat(None)?;\n+        let sp = lhs.span.to(rhs.span);\n+\n+        if let PatKind::Ident(_, _, ref mut sub @ None) = rhs.kind {\n+            // The user inverted the order, so help them fix that.\n+            let mut applicability = Applicability::MachineApplicable;\n+            lhs.walk(&mut |p| match p.kind {\n+                // `check_match` is unhappy if the subpattern has a binding anywhere.\n+                PatKind::Ident(..) => {\n+                    applicability = Applicability::MaybeIncorrect;\n+                    false // Short-circuit.\n+                },\n+                _ => true,\n+            });\n+\n+            let lhs_span = lhs.span;\n+            // Move the LHS into the RHS as a subpattern.\n+            // The RHS is now the full pattern.\n+            *sub = Some(lhs);\n+\n+            self.struct_span_err(sp, \"pattern on wrong side of `@`\")\n+                .span_label(lhs_span, \"pattern on the left, should be on the right\")\n+                .span_label(rhs.span, \"binding on the right, should be on the left\")\n+                .span_suggestion(sp, \"switch the order\", pprust::pat_to_string(&rhs), applicability)\n+                .emit();\n+        } else {\n+            // The special case above doesn't apply so we may have e.g. `A(x) @ B(y)`.\n+            rhs.kind = PatKind::Wild;\n+            self.struct_span_err(sp, \"left-hand side of `@` must be a binding\")\n+                .span_label(lhs.span, \"interpreted as a pattern, not a binding\")\n+                .span_label(rhs.span, \"also a pattern\")\n+                .note(\"bindings are `x`, `mut x`, `ref x`, and `ref mut x`\")\n+                .emit();\n+        }\n+\n+        rhs.span = sp;\n+        Ok(rhs)\n+    }\n+\n     /// Ban a range pattern if it has an ambiguous interpretation.\n     fn ban_pat_range_if_ambiguous(&self, pat: &Pat) -> PResult<'a, ()> {\n         match pat.kind {"}, {"sha": "68dd90b54ab683f232b0766825163b536cdbdeae", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -2381,7 +2381,8 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(ident);\n                 if let Some(ref p) = *sub {\n-                    self.s.word(\"@\");\n+                    self.s.space();\n+                    self.s.word_space(\"@\");\n                     self.print_pat(p);\n                 }\n             }"}, {"sha": "1501adc597104bb5c0441b6269c9f85921100ebb", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -970,6 +970,9 @@ impl SourceMapper for SourceMap {\n     fn span_to_string(&self, sp: Span) -> String {\n         self.span_to_string(sp)\n     }\n+    fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+        self.span_to_snippet(sp)\n+    }\n     fn span_to_filename(&self, sp: Span) -> FileName {\n         self.span_to_filename(sp)\n     }"}, {"sha": "0ff1c26bac2b277a2a311e0a50f81b7a393b14f6", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 91, "deletions": 133, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -136,13 +136,8 @@ impl TokenTree {\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n-///\n-/// The use of `Option` is an optimization that avoids the need for an\n-/// allocation when the stream is empty. However, it is not guaranteed that an\n-/// empty stream is represented with `None`; it may be represented as a `Some`\n-/// around an empty `Vec`.\n-#[derive(Clone, Debug)]\n-pub struct TokenStream(pub Option<Lrc<Vec<TreeAndJoint>>>);\n+#[derive(Clone, Debug, Default)]\n+pub struct TokenStream(pub Lrc<Vec<TreeAndJoint>>);\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n \n@@ -163,36 +158,34 @@ impl TokenStream {\n     /// separating the two arguments with a comma for diagnostic suggestions.\n     pub(crate) fn add_comma(&self) -> Option<(TokenStream, Span)> {\n         // Used to suggest if a user writes `foo!(a b);`\n-        if let Some(ref stream) = self.0 {\n-            let mut suggestion = None;\n-            let mut iter = stream.iter().enumerate().peekable();\n-            while let Some((pos, ts)) = iter.next() {\n-                if let Some((_, next)) = iter.peek() {\n-                    let sp = match (&ts, &next) {\n-                        (_, (TokenTree::Token(Token { kind: token::Comma, .. }), _)) => continue,\n-                        ((TokenTree::Token(token_left), NonJoint),\n-                         (TokenTree::Token(token_right), _))\n-                        if ((token_left.is_ident() && !token_left.is_reserved_ident())\n-                            || token_left.is_lit()) &&\n-                            ((token_right.is_ident() && !token_right.is_reserved_ident())\n-                            || token_right.is_lit()) => token_left.span,\n-                        ((TokenTree::Delimited(sp, ..), NonJoint), _) => sp.entire(),\n-                        _ => continue,\n-                    };\n-                    let sp = sp.shrink_to_hi();\n-                    let comma = (TokenTree::token(token::Comma, sp), NonJoint);\n-                    suggestion = Some((pos, comma, sp));\n-                }\n-            }\n-            if let Some((pos, comma, sp)) = suggestion {\n-                let mut new_stream = vec![];\n-                let parts = stream.split_at(pos + 1);\n-                new_stream.extend_from_slice(parts.0);\n-                new_stream.push(comma);\n-                new_stream.extend_from_slice(parts.1);\n-                return Some((TokenStream::new(new_stream), sp));\n+        let mut suggestion = None;\n+        let mut iter = self.0.iter().enumerate().peekable();\n+        while let Some((pos, ts)) = iter.next() {\n+            if let Some((_, next)) = iter.peek() {\n+                let sp = match (&ts, &next) {\n+                    (_, (TokenTree::Token(Token { kind: token::Comma, .. }), _)) => continue,\n+                    ((TokenTree::Token(token_left), NonJoint),\n+                     (TokenTree::Token(token_right), _))\n+                    if ((token_left.is_ident() && !token_left.is_reserved_ident())\n+                        || token_left.is_lit()) &&\n+                        ((token_right.is_ident() && !token_right.is_reserved_ident())\n+                        || token_right.is_lit()) => token_left.span,\n+                    ((TokenTree::Delimited(sp, ..), NonJoint), _) => sp.entire(),\n+                    _ => continue,\n+                };\n+                let sp = sp.shrink_to_hi();\n+                let comma = (TokenTree::token(token::Comma, sp), NonJoint);\n+                suggestion = Some((pos, comma, sp));\n             }\n         }\n+        if let Some((pos, comma, sp)) = suggestion {\n+            let mut new_stream = vec![];\n+            let parts = self.0.split_at(pos + 1);\n+            new_stream.extend_from_slice(parts.0);\n+            new_stream.push(comma);\n+            new_stream.extend_from_slice(parts.1);\n+            return Some((TokenStream::new(new_stream), sp));\n+        }\n         None\n     }\n }\n@@ -224,28 +217,21 @@ impl PartialEq<TokenStream> for TokenStream {\n }\n \n impl TokenStream {\n-    pub fn len(&self) -> usize {\n-        if let Some(ref slice) = self.0 {\n-            slice.len()\n-        } else {\n-            0\n-        }\n+    pub fn new(streams: Vec<TreeAndJoint>) -> TokenStream {\n+        TokenStream(Lrc::new(streams))\n     }\n \n-    pub fn empty() -> TokenStream {\n-        TokenStream(None)\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n     }\n \n-    pub fn is_empty(&self) -> bool {\n-        match self.0 {\n-            None => true,\n-            Some(ref stream) => stream.is_empty(),\n-        }\n+    pub fn len(&self) -> usize {\n+        self.0.len()\n     }\n \n     pub(crate) fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n         match streams.len() {\n-            0 => TokenStream::empty(),\n+            0 => TokenStream::default(),\n             1 => streams.pop().unwrap(),\n             _ => {\n                 // We are going to extend the first stream in `streams` with\n@@ -269,41 +255,24 @@ impl TokenStream {\n                 // Get the first stream. If it's `None`, create an empty\n                 // stream.\n                 let mut iter = streams.drain();\n-                let mut first_stream_lrc = match iter.next().unwrap().0 {\n-                    Some(first_stream_lrc) => first_stream_lrc,\n-                    None => Lrc::new(vec![]),\n-                };\n+                let mut first_stream_lrc = iter.next().unwrap().0;\n \n                 // Append the elements to the first stream, after reserving\n                 // space for them.\n                 let first_vec_mut = Lrc::make_mut(&mut first_stream_lrc);\n                 first_vec_mut.reserve(num_appends);\n                 for stream in iter {\n-                    if let Some(stream) = stream.0 {\n-                        first_vec_mut.extend(stream.iter().cloned());\n-                    }\n+                    first_vec_mut.extend(stream.0.iter().cloned());\n                 }\n \n                 // Create the final `TokenStream`.\n-                match first_vec_mut.len() {\n-                    0 => TokenStream(None),\n-                    _ => TokenStream(Some(first_stream_lrc)),\n-                }\n+                TokenStream(first_stream_lrc)\n             }\n         }\n     }\n \n-    pub fn new(streams: Vec<TreeAndJoint>) -> TokenStream {\n-        match streams.len() {\n-            0 => TokenStream(None),\n-            _ => TokenStream(Some(Lrc::new(streams))),\n-        }\n-    }\n-\n     pub fn append_to_tree_and_joint_vec(self, vec: &mut Vec<TreeAndJoint>) {\n-        if let Some(stream) = self.0 {\n-            vec.extend(stream.iter().cloned());\n-        }\n+        vec.extend(self.0.iter().cloned());\n     }\n \n     pub fn trees(&self) -> Cursor {\n@@ -370,24 +339,22 @@ impl TokenStream {\n     }\n \n     pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        TokenStream(self.0.map(|stream| {\n-            Lrc::new(\n-                stream\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, (tree, is_joint))| (f(i, tree.clone()), *is_joint))\n-                    .collect())\n-        }))\n+        TokenStream(Lrc::new(\n+            self.0\n+                .iter()\n+                .enumerate()\n+                .map(|(i, (tree, is_joint))| (f(i, tree.clone()), *is_joint))\n+                .collect()\n+        ))\n     }\n \n     pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        TokenStream(self.0.map(|stream| {\n-            Lrc::new(\n-                stream\n-                    .iter()\n-                    .map(|(tree, is_joint)| (f(tree.clone()), *is_joint))\n-                    .collect())\n-        }))\n+        TokenStream(Lrc::new(\n+            self.0\n+                .iter()\n+                .map(|(tree, is_joint)| (f(tree.clone()), *is_joint))\n+                .collect()\n+        ))\n     }\n }\n \n@@ -405,44 +372,43 @@ impl TokenStreamBuilder {\n \n         // If `self` is not empty and the last tree within the last stream is a\n         // token tree marked with `Joint`...\n-        if let Some(TokenStream(Some(ref mut last_stream_lrc))) = self.0.last_mut() {\n+        if let Some(TokenStream(ref mut last_stream_lrc)) = self.0.last_mut() {\n             if let Some((TokenTree::Token(last_token), Joint)) = last_stream_lrc.last() {\n \n                 // ...and `stream` is not empty and the first tree within it is\n                 // a token tree...\n-                if let TokenStream(Some(ref mut stream_lrc)) = stream {\n-                    if let Some((TokenTree::Token(token), is_joint)) = stream_lrc.first() {\n-\n-                        // ...and the two tokens can be glued together...\n-                        if let Some(glued_tok) = last_token.glue(&token) {\n-\n-                            // ...then do so, by overwriting the last token\n-                            // tree in `self` and removing the first token tree\n-                            // from `stream`. This requires using `make_mut()`\n-                            // on the last stream in `self` and on `stream`,\n-                            // and in practice this doesn't cause cloning 99.9%\n-                            // of the time.\n-\n-                            // Overwrite the last token tree with the merged\n-                            // token.\n-                            let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n-                            *last_vec_mut.last_mut().unwrap() =\n-                                (TokenTree::Token(glued_tok), *is_joint);\n-\n-                            // Remove the first token tree from `stream`. (This\n-                            // is almost always the only tree in `stream`.)\n-                            let stream_vec_mut = Lrc::make_mut(stream_lrc);\n-                            stream_vec_mut.remove(0);\n-\n-                            // Don't push `stream` if it's empty -- that could\n-                            // block subsequent token gluing, by getting\n-                            // between two token trees that should be glued\n-                            // together.\n-                            if !stream.is_empty() {\n-                                self.0.push(stream);\n-                            }\n-                            return;\n+                let TokenStream(ref mut stream_lrc) = stream;\n+                if let Some((TokenTree::Token(token), is_joint)) = stream_lrc.first() {\n+\n+                    // ...and the two tokens can be glued together...\n+                    if let Some(glued_tok) = last_token.glue(&token) {\n+\n+                        // ...then do so, by overwriting the last token\n+                        // tree in `self` and removing the first token tree\n+                        // from `stream`. This requires using `make_mut()`\n+                        // on the last stream in `self` and on `stream`,\n+                        // and in practice this doesn't cause cloning 99.9%\n+                        // of the time.\n+\n+                        // Overwrite the last token tree with the merged\n+                        // token.\n+                        let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n+                        *last_vec_mut.last_mut().unwrap() =\n+                            (TokenTree::Token(glued_tok), *is_joint);\n+\n+                        // Remove the first token tree from `stream`. (This\n+                        // is almost always the only tree in `stream`.)\n+                        let stream_vec_mut = Lrc::make_mut(stream_lrc);\n+                        stream_vec_mut.remove(0);\n+\n+                        // Don't push `stream` if it's empty -- that could\n+                        // block subsequent token gluing, by getting\n+                        // between two token trees that should be glued\n+                        // together.\n+                        if !stream.is_empty() {\n+                            self.0.push(stream);\n                         }\n+                        return;\n                     }\n                 }\n             }\n@@ -475,16 +441,11 @@ impl Cursor {\n     }\n \n     pub fn next_with_joint(&mut self) -> Option<TreeAndJoint> {\n-        match self.stream.0 {\n-            None => None,\n-            Some(ref stream) => {\n-                if self.index < stream.len() {\n-                    self.index += 1;\n-                    Some(stream[self.index - 1].clone())\n-                } else {\n-                    None\n-                }\n-            }\n+        if self.index < self.stream.len() {\n+            self.index += 1;\n+            Some(self.stream.0[self.index - 1].clone())\n+        } else {\n+            None\n         }\n     }\n \n@@ -493,16 +454,13 @@ impl Cursor {\n             return;\n         }\n         let index = self.index;\n-        let stream = mem::replace(&mut self.stream, TokenStream(None));\n+        let stream = mem::take(&mut self.stream);\n         *self = TokenStream::from_streams(smallvec![stream, new_stream]).into_trees();\n         self.index = index;\n     }\n \n     pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n-        match self.stream.0 {\n-            None => None,\n-            Some(ref stream) => stream[self.index ..].get(n).map(|(tree, _)| tree.clone()),\n-        }\n+        self.stream.0[self.index ..].get(n).map(|(tree, _)| tree.clone())\n     }\n }\n "}, {"sha": "62c7e188eba27e5fad48b6cae0e18a43fa1b063f", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -20,7 +20,7 @@ fn plugin_macro_def(name: Name, span: Span) -> P<Item> {\n         attr::mk_word_item(Ident::new(sym::rustc_builtin_macro, span)));\n \n     let parens: TreeAndJoint = TokenTree::Delimited(\n-        DelimSpan::from_single(span), token::Paren, TokenStream::empty()\n+        DelimSpan::from_single(span), token::Paren, TokenStream::default()\n     ).into();\n     let trees = vec![parens.clone(), TokenTree::token(token::FatArrow, span).into(), parens];\n "}, {"sha": "901fb5dd054e2f6f28853b73c96a6066e37ebf23", "filename": "src/test/ui/const-generics/auxiliary/const_generic_lib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fauxiliary%2Fconst_generic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fauxiliary%2Fconst_generic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fauxiliary%2Fconst_generic_lib.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_generics)]\n+\n+pub struct Struct<const N: usize>(pub [u8; N]);\n+\n+pub type Alias = Struct<2>;\n+\n+pub fn function(value: Struct<3>) -> u8 {\n+    value.0[0]\n+}"}, {"sha": "d863d097d5caf324554f323cf7f3bb0953205027", "filename": "src/test/ui/const-generics/const-argument-cross-crate-mismatch.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:const_generic_lib.rs\n+\n+extern crate const_generic_lib;\n+\n+fn main() {\n+    let _ = const_generic_lib::function(const_generic_lib::Struct([0u8, 1u8]));\n+    //~^ ERROR mismatched types\n+    let _: const_generic_lib::Alias = const_generic_lib::Struct([0u8, 1u8, 2u8]);\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "b7fd29ce7067a266180f3697f0a10fd3a31e52be", "filename": "src/test/ui/const-generics/const-argument-cross-crate-mismatch.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/const-argument-cross-crate-mismatch.rs:6:41\n+   |\n+LL |     let _ = const_generic_lib::function(const_generic_lib::Struct([0u8, 1u8]));\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `3usize`, found `2usize`\n+   |\n+   = note: expected type `const_generic_lib::Struct<3usize>`\n+              found type `const_generic_lib::Struct<_: usize>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/const-argument-cross-crate-mismatch.rs:8:39\n+   |\n+LL |     let _: const_generic_lib::Alias = const_generic_lib::Struct([0u8, 1u8, 2u8]);\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2usize`, found `3usize`\n+   |\n+   = note: expected type `const_generic_lib::Struct<2usize>`\n+              found type `const_generic_lib::Struct<_: usize>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "98cf39a7ee11cdb38485d856fdd73b429bf64af9", "filename": "src/test/ui/const-generics/const-argument-cross-crate.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -0,0 +1,12 @@\n+// run-pass\n+// aux-build:const_generic_lib.rs\n+\n+extern crate const_generic_lib;\n+\n+struct Container(const_generic_lib::Alias);\n+\n+fn main() {\n+    let res = const_generic_lib::function(const_generic_lib::Struct([14u8, 1u8, 2u8]));\n+    assert_eq!(res, 14u8);\n+    let _ = Container(const_generic_lib::Struct([0u8, 1u8]));\n+}"}, {"sha": "32cf8d8a01a783bbea196604263e4c24169de95e", "filename": "src/test/ui/const-generics/const-parameter-uppercase-lint.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -10,7 +10,7 @@ error: const parameter `x` should have an upper case name\n   --> $DIR/const-parameter-uppercase-lint.rs:6:15\n    |\n LL | fn noop<const x: u32>() {\n-   |               ^ help: convert the identifier to upper case: `X`\n+   |               ^ help: convert the identifier to upper case (notice the capitalization): `X`\n    |\n note: lint level defined here\n   --> $DIR/const-parameter-uppercase-lint.rs:4:9"}, {"sha": "ef68bf52cf3bd4c7862994428a5119dd5fff78c8", "filename": "src/test/ui/did_you_mean/issue-43871-enum-instead-of-variant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-43871-enum-instead-of-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-43871-enum-instead-of-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-43871-enum-instead-of-variant.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -55,7 +55,7 @@ LL |     let z = ManyVariants::Three();\n    |             ^^^^^^^^^^^^^^^^^^^\n LL |     let z = ManyVariants::Four();\n    |             ^^^^^^^^^^^^^^^^^^\n-and 6 other candidates\n+     and 6 other candidates\n \n error: aborting due to 5 previous errors\n "}, {"sha": "cb350a1faeed2a6af11b41d18e95c0c660ce9d85", "filename": "src/test/ui/did_you_mean/issue-56028-there-is-an-enum-variant.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -13,7 +13,7 @@ LL | fn setup() -> Determine { Set }\n    |               ^^^^^^^^^\n LL | fn setup() -> PutDown { Set }\n    |               ^^^^^^^\n-and 3 other candidates\n+     and 3 other candidates\n \n error[E0425]: cannot find value `Set` in this scope\n   --> $DIR/issue-56028-there-is-an-enum-variant.rs:9:21\n@@ -30,7 +30,7 @@ LL | use Determine::Set;\n    |\n LL | use PutDown::Set;\n    |\n-and 3 other candidates\n+     and 3 other candidates\n \n error: aborting due to 2 previous errors\n "}, {"sha": "754006bc217ee6f8f659680d817e2b3e5c0e9a87", "filename": "src/test/ui/error-codes/E0423.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -34,7 +34,7 @@ LL |     let f = Foo();\n    |             ^^^\n    |             |\n    |             did you mean `Foo { /* fields */ }`?\n-   |             help: a function with a similar name exists: `foo`\n+   |             help: a function with a similar name exists (notice the capitalization): `foo`\n \n error[E0423]: expected value, found struct `T`\n   --> $DIR/E0423.rs:14:8"}, {"sha": "57a9350c089a8e498bc63a3c766c9877cd9df978", "filename": "src/test/ui/expr_attr_paren_order.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fexpr_attr_paren_order.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fexpr_attr_paren_order.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr_attr_paren_order.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -2,7 +2,7 @@ error: variable `X` should have a snake case name\n   --> $DIR/expr_attr_paren_order.rs:19:17\n    |\n LL |             let X = 0;\n-   |                 ^ help: convert the identifier to snake case: `x`\n+   |                 ^ help: convert the identifier to snake case (notice the capitalization): `x`\n    |\n note: lint level defined here\n   --> $DIR/expr_attr_paren_order.rs:17:17"}, {"sha": "d77fbc1e8239debff1410553b2f698755bc305b8", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.nll.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e413dc36a83a5aad3ab6270373000693a917e92b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e413dc36a83a5aad3ab6270373000693a917e92b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr?ref=e413dc36a83a5aad3ab6270373000693a917e92b", "patch": "@@ -1,16 +0,0 @@\n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/feature-gate-exhaustive-patterns.rs:7:9\n-   |\n-LL |     let Ok(_x) = foo();\n-   |         ^^^^^^ pattern `Err(_)` not covered\n-   |\n-   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n-   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     if let Ok(_x) = foo() { /* */ }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0005`."}, {"sha": "7acb266f49c0b6f22f85ef74fc13c5e699c6b50e", "filename": "src/test/ui/hygiene/globs.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -34,7 +34,7 @@ LL | use foo::test2::test::g;\n    |\n LL | use foo::test::g;\n    |\n-and 2 other candidates\n+     and 2 other candidates\n \n error[E0425]: cannot find function `f` in this scope\n   --> $DIR/globs.rs:61:12"}, {"sha": "45a2efebbb8dad8afeef17abdaf941adc6044983", "filename": "src/test/ui/hygiene/rustc-macro-transparency.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -2,7 +2,7 @@ error[E0425]: cannot find value `Opaque` in this scope\n   --> $DIR/rustc-macro-transparency.rs:26:5\n    |\n LL |     Opaque;\n-   |     ^^^^^^ help: a local variable with a similar name exists: `opaque`\n+   |     ^^^^^^ help: a local variable with a similar name exists (notice the capitalization): `opaque`\n \n error[E0423]: expected value, found macro `semitransparent`\n   --> $DIR/rustc-macro-transparency.rs:29:5"}, {"sha": "b1057d45869a8ae9394752dbc0d70383401c663b", "filename": "src/test/ui/issues/issue-10200.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fissues%2Fissue-10200.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fissues%2Fissue-10200.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10200.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -2,7 +2,7 @@ error[E0532]: expected tuple struct/variant, found function `foo`\n   --> $DIR/issue-10200.rs:6:9\n    |\n LL |         foo(x)\n-   |         ^^^ help: a tuple struct with a similar name exists: `Foo`\n+   |         ^^^ help: a tuple struct with a similar name exists (notice the capitalization): `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "1f71e159f182b1224d5fa22e4a5bba584fde8f44", "filename": "src/test/ui/issues/issue-17546.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -27,7 +27,7 @@ LL |     use std::prelude::v1::Result;\n    |\n LL |     use std::result::Result;\n    |\n-and 1 other candidates\n+     and 1 other candidates\n \n error[E0573]: expected type, found variant `Result`\n   --> $DIR/issue-17546.rs:28:13\n@@ -44,7 +44,7 @@ LL | use std::prelude::v1::Result;\n    |\n LL | use std::result::Result;\n    |\n-and 1 other candidates\n+     and 1 other candidates\n \n error[E0573]: expected type, found variant `NoResult`\n   --> $DIR/issue-17546.rs:33:15"}, {"sha": "e320c436f5b68595f9a1c73de780a77fc6296f94", "filename": "src/test/ui/issues/issue-17718-const-naming.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-naming.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -15,7 +15,7 @@ error: constant `foo` should have an upper case name\n   --> $DIR/issue-17718-const-naming.rs:4:7\n    |\n LL | const foo: isize = 3;\n-   |       ^^^ help: convert the identifier to upper case: `FOO`\n+   |       ^^^ help: convert the identifier to upper case (notice the capitalization): `FOO`\n    |\n note: lint level defined here\n   --> $DIR/issue-17718-const-naming.rs:2:9"}, {"sha": "c7e9d71700e6da595d6c7ed5e1a58e143a432dff", "filename": "src/test/ui/issues/issue-46332.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fissues%2Fissue-46332.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fissues%2Fissue-46332.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46332.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -2,7 +2,7 @@ error[E0422]: cannot find struct, variant or union type `TyUInt` in this scope\n   --> $DIR/issue-46332.rs:9:5\n    |\n LL |     TyUInt {};\n-   |     ^^^^^^ help: a struct with a similar name exists: `TyUint`\n+   |     ^^^^^^ help: a struct with a similar name exists (notice the capitalization): `TyUint`\n \n error: aborting due to previous error\n "}, {"sha": "177f8c8fe9b63d9fc0d1ebef802e65e6962722c6", "filename": "src/test/ui/lint/lint-non-camel-case-types.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -14,25 +14,25 @@ error: type `foo` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:7:8\n    |\n LL | struct foo {\n-   |        ^^^ help: convert the identifier to upper camel case: `Foo`\n+   |        ^^^ help: convert the identifier to upper camel case (notice the capitalization): `Foo`\n \n error: type `foo2` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:11:6\n    |\n LL | enum foo2 {\n-   |      ^^^^ help: convert the identifier to upper camel case: `Foo2`\n+   |      ^^^^ help: convert the identifier to upper camel case (notice the capitalization): `Foo2`\n \n error: type `foo3` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:15:8\n    |\n LL | struct foo3 {\n-   |        ^^^^ help: convert the identifier to upper camel case: `Foo3`\n+   |        ^^^^ help: convert the identifier to upper camel case (notice the capitalization): `Foo3`\n \n error: type `foo4` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:19:6\n    |\n LL | type foo4 = isize;\n-   |      ^^^^ help: convert the identifier to upper camel case: `Foo4`\n+   |      ^^^^ help: convert the identifier to upper camel case (notice the capitalization): `Foo4`\n \n error: variant `bar` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:22:5\n@@ -44,7 +44,7 @@ error: trait `foo6` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:25:7\n    |\n LL | trait foo6 {\n-   |       ^^^^ help: convert the identifier to upper camel case: `Foo6`\n+   |       ^^^^ help: convert the identifier to upper camel case (notice the capitalization): `Foo6`\n \n error: type parameter `ty` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:29:6"}, {"sha": "c5eca89debb82c3b49ad7f26adbbe7722e81f162", "filename": "src/test/ui/lint/lint-non-snake-case-functions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Flint-non-snake-case-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Flint-non-snake-case-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-non-snake-case-functions.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -38,7 +38,7 @@ error: trait method `a_b_C` should have a snake case name\n   --> $DIR/lint-non-snake-case-functions.rs:25:8\n    |\n LL |     fn a_b_C(&self) {}\n-   |        ^^^^^ help: convert the identifier to snake case: `a_b_c`\n+   |        ^^^^^ help: convert the identifier to snake case (notice the capitalization): `a_b_c`\n \n error: trait method `something__else` should have a snake case name\n   --> $DIR/lint-non-snake-case-functions.rs:28:8\n@@ -50,13 +50,13 @@ error: function `Cookie` should have a snake case name\n   --> $DIR/lint-non-snake-case-functions.rs:38:4\n    |\n LL | fn Cookie() {}\n-   |    ^^^^^^ help: convert the identifier to snake case: `cookie`\n+   |    ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `cookie`\n \n error: function `bi_S_Cuit` should have a snake case name\n   --> $DIR/lint-non-snake-case-functions.rs:41:8\n    |\n LL | pub fn bi_S_Cuit() {}\n-   |        ^^^^^^^^^ help: convert the identifier to snake case: `bi_s_cuit`\n+   |        ^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `bi_s_cuit`\n \n error: aborting due to 9 previous errors\n "}, {"sha": "ceb83d08f27779d61a971ec786b74c31516a62c6", "filename": "src/test/ui/lint/lint-non-uppercase-statics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Flint-non-uppercase-statics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Flint-non-uppercase-statics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-non-uppercase-statics.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -2,7 +2,7 @@ error: static variable `foo` should have an upper case name\n   --> $DIR/lint-non-uppercase-statics.rs:4:8\n    |\n LL | static foo: isize = 1;\n-   |        ^^^ help: convert the identifier to upper case: `FOO`\n+   |        ^^^ help: convert the identifier to upper case (notice the capitalization): `FOO`\n    |\n note: lint level defined here\n   --> $DIR/lint-non-uppercase-statics.rs:1:11"}, {"sha": "f614d5d71f88cdc0afcfa02e7082e02cf10873b6", "filename": "src/test/ui/lint/lint-uppercase-variables.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-uppercase-variables.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -21,7 +21,7 @@ error: structure field `X` should have a snake case name\n   --> $DIR/lint-uppercase-variables.rs:10:5\n    |\n LL |     X: usize\n-   |     ^ help: convert the identifier to snake case: `x`\n+   |     ^ help: convert the identifier to snake case (notice the capitalization): `x`\n    |\n note: lint level defined here\n   --> $DIR/lint-uppercase-variables.rs:3:9\n@@ -33,7 +33,7 @@ error: variable `Xx` should have a snake case name\n   --> $DIR/lint-uppercase-variables.rs:13:9\n    |\n LL | fn test(Xx: usize) {\n-   |         ^^ help: convert the identifier to snake case: `xx`\n+   |         ^^ help: convert the identifier to snake case (notice the capitalization): `xx`\n \n error: variable `Test` should have a snake case name\n   --> $DIR/lint-uppercase-variables.rs:18:9\n@@ -45,7 +45,7 @@ error: variable `Foo` should have a snake case name\n   --> $DIR/lint-uppercase-variables.rs:22:9\n    |\n LL |         Foo => {}\n-   |         ^^^ help: convert the identifier to snake case: `foo`\n+   |         ^^^ help: convert the identifier to snake case (notice the capitalization): `foo`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "5016d9b97d69e661c04f47bf62ac8da54e148715", "filename": "src/test/ui/lint/not_found.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -16,5 +16,5 @@ warning: unknown lint: `Warnings`\n   --> $DIR/not_found.rs:10:8\n    |\n LL | #[deny(Warnings)]\n-   |        ^^^^^^^^ help: did you mean: `warnings`\n+   |        ^^^^^^^^ help: did you mean (notice the capitalization): `warnings`\n "}, {"sha": "139b3f13fd6b2beccdc4e6328426ee0d828eab44", "filename": "src/test/ui/lint/reasons.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Freasons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Freasons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Freasons.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -15,7 +15,7 @@ warning: variable `Social_exchange_psychology` should have a snake case name\n   --> $DIR/reasons.rs:30:9\n    |\n LL |     let Social_exchange_psychology = CheaterDetectionMechanism {};\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `social_exchange_psychology`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `social_exchange_psychology`\n    |\n    = note: people shouldn't have to change their usual style habits\n            to contribute to our project"}, {"sha": "1da5acc966163ed004237388b6492da475369cce", "filename": "src/test/ui/lint/use_suggestion_json.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -395,7 +395,7 @@ mod foo {\n \\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m|\\u001b[0m\n \\u001b[0m\\u001b[1m\\u001b[38;5;12mLL\\u001b[0m\\u001b[0m \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m| \\u001b[0m\\u001b[0muse std::collections::hash_map::Iter;\\u001b[0m\n \\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m|\\u001b[0m\n-\\u001b[0mand 8 other candidates\\u001b[0m\n+\\u001b[0m     and 8 other candidates\\u001b[0m\n \n \"\n }"}, {"sha": "adb607cf6b97b08ca03156b535d36b1537720176", "filename": "src/test/ui/parser/intersection-patterns.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.rs?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -0,0 +1,40 @@\n+// This tests the parser recovery in `recover_intersection_pat`\n+// and serves as a regression test for the diagnostics issue #65400.\n+//\n+// The general idea is that for `$pat_lhs @ $pat_rhs` where\n+// `$pat_lhs` is not generated by `ref? mut? $ident` we want\n+// to suggest either switching the order or note that intersection\n+// patterns are not allowed.\n+\n+fn main() {\n+    let s: Option<u8> = None;\n+\n+    match s {\n+        Some(x) @ y => {}\n+        //~^ ERROR pattern on wrong side of `@`\n+        //~| pattern on the left, should be on the right\n+        //~| binding on the right, should be on the left\n+        //~| HELP switch the order\n+        //~| SUGGESTION y @ Some(x)\n+        _ => {}\n+    }\n+\n+    match s {\n+        Some(x) @ Some(y) => {}\n+        //~^ ERROR left-hand side of `@` must be a binding\n+        //~| interpreted as a pattern, not a binding\n+        //~| also a pattern\n+        //~| NOTE bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+        _ => {}\n+    }\n+\n+    match 2 {\n+        1 ..= 5 @ e => {}\n+        //~^ ERROR pattern on wrong side of `@`\n+        //~| pattern on the left, should be on the right\n+        //~| binding on the right, should be on the left\n+        //~| HELP switch the order\n+        //~| SUGGESTION e @ 1 ..=5\n+        _ => {}\n+    }\n+}"}, {"sha": "f5bfee5bbd611dd2da6df2d6bb1d7751ccb8fd75", "filename": "src/test/ui/parser/intersection-patterns.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fintersection-patterns.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -0,0 +1,33 @@\n+error: pattern on wrong side of `@`\n+  --> $DIR/intersection-patterns.rs:13:9\n+   |\n+LL |         Some(x) @ y => {}\n+   |         -------^^^-\n+   |         |         |\n+   |         |         binding on the right, should be on the left\n+   |         pattern on the left, should be on the right\n+   |         help: switch the order: `y @ Some(x)`\n+\n+error: left-hand side of `@` must be a binding\n+  --> $DIR/intersection-patterns.rs:23:9\n+   |\n+LL |         Some(x) @ Some(y) => {}\n+   |         -------^^^-------\n+   |         |         |\n+   |         |         also a pattern\n+   |         interpreted as a pattern, not a binding\n+   |\n+   = note: bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+\n+error: pattern on wrong side of `@`\n+  --> $DIR/intersection-patterns.rs:32:9\n+   |\n+LL |         1 ..= 5 @ e => {}\n+   |         -------^^^-\n+   |         |         |\n+   |         |         binding on the right, should be on the left\n+   |         pattern on the left, should be on the right\n+   |         help: switch the order: `e @ 1 ..=5`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "513e02f74e3b265cf88afc639d6cc7d91c9076ca", "filename": "src/test/ui/resolve/issue-21221-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -27,7 +27,7 @@ LL | use mul3::Mul;\n    |\n LL | use mul4::Mul;\n    |\n-and 2 other candidates\n+     and 2 other candidates\n \n error[E0405]: cannot find trait `ThisTraitReallyDoesntExistInAnyModuleReally` in this scope\n   --> $DIR/issue-21221-1.rs:63:6"}, {"sha": "e693a0ef91fc2be9414d376efcfbdaf9e75cd3a6", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -38,13 +38,13 @@ error[E0412]: cannot find type `first` in module `m`\n   --> $DIR/levenshtein.rs:28:15\n    |\n LL |     let b: m::first = m::second; // Misspelled item in module.\n-   |               ^^^^^ help: a struct with a similar name exists: `First`\n+   |               ^^^^^ help: a struct with a similar name exists (notice the capitalization): `First`\n \n error[E0425]: cannot find value `second` in module `m`\n   --> $DIR/levenshtein.rs:28:26\n    |\n LL |     let b: m::first = m::second; // Misspelled item in module.\n-   |                          ^^^^^^ help: a unit struct with a similar name exists: `Second`\n+   |                          ^^^^^^ help: a unit struct with a similar name exists (notice the capitalization): `Second`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "973c486970e6577b8ea0ae132d1fc9e250d7982a", "filename": "src/test/ui/rust-2018/issue-52202-use-suggestions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Frust-2018%2Fissue-52202-use-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e369d87b015a84653343032833d65d0545fd3f26/src%2Ftest%2Fui%2Frust-2018%2Fissue-52202-use-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fissue-52202-use-suggestions.stderr?ref=e369d87b015a84653343032833d65d0545fd3f26", "patch": "@@ -13,7 +13,7 @@ LL | use std::collections::hash_map::Drain;\n    |\n LL | use std::collections::hash_set::Drain;\n    |\n-and 3 other candidates\n+     and 3 other candidates\n \n error: aborting due to previous error\n "}]}