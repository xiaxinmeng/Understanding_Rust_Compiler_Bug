{"sha": "c5736218121542d6fedfe027c6438b8b80cf5a6f", "node_id": "C_kwDOAAsO6NoAKGM1NzM2MjE4MTIxNTQyZDZmZWRmZTAyN2M2NDM4YjhiODBjZjVhNmY", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-10-08T18:37:36Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-10-08T18:45:17Z"}, "message": "Fix some vfmaddsub intrinsics", "tree": {"sha": "951e72765f726af02afddef53604ba9ba4d7263f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/951e72765f726af02afddef53604ba9ba4d7263f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5736218121542d6fedfe027c6438b8b80cf5a6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5736218121542d6fedfe027c6438b8b80cf5a6f", "html_url": "https://github.com/rust-lang/rust/commit/c5736218121542d6fedfe027c6438b8b80cf5a6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5736218121542d6fedfe027c6438b8b80cf5a6f/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23a1a868350fb8cea1db26b68035e07144d041b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/23a1a868350fb8cea1db26b68035e07144d041b0", "html_url": "https://github.com/rust-lang/rust/commit/23a1a868350fb8cea1db26b68035e07144d041b0"}], "stats": {"total": 33, "additions": 26, "deletions": 7}, "files": [{"sha": "f3933a2d7061bdc98299c4f1031c2e5407a7b6af", "filename": "src/builder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5736218121542d6fedfe027c6438b8b80cf5a6f/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5736218121542d6fedfe027c6438b8b80cf5a6f/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=c5736218121542d6fedfe027c6438b8b80cf5a6f", "patch": "@@ -280,7 +280,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let func_name = format!(\"{:?}\", func_ptr);\n         let previous_arg_count = args.len();\n         let orig_args = args;\n-        let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args.into(), &func_name);\n+        let args = {\n+            let function_address_names = self.function_address_names.borrow();\n+            let original_function_name = function_address_names.get(&func_ptr);\n+            llvm::adjust_intrinsic_arguments(&self, gcc_func, args.into(), &func_name, original_function_name)\n+        };\n         let args_adjusted = args.len() != previous_arg_count;\n         let args = self.check_ptr_call(\"call\", func_ptr, &*args);\n "}, {"sha": "5f34ddd92bac4487484d485db17e6f28a7bda50f", "filename": "src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5736218121542d6fedfe027c6438b8b80cf5a6f/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5736218121542d6fedfe027c6438b8b80cf5a6f/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=c5736218121542d6fedfe027c6438b8b80cf5a6f", "patch": "@@ -33,6 +33,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     // TODO(bjorn3): Can this field be removed?\n     pub current_func: RefCell<Option<Function<'gcc>>>,\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n+    pub function_address_names: RefCell<FxHashMap<RValue<'gcc>, String>>,\n \n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n     pub intrinsics: RefCell<FxHashMap<String, Function<'gcc>>>,\n@@ -192,6 +193,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             context,\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n+            function_address_names: Default::default(),\n             functions: RefCell::new(functions),\n             intrinsics: RefCell::new(FxHashMap::default()),\n \n@@ -345,6 +347,7 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // FIXME(antoyo): the rustc API seems to call get_fn_addr() when not needed (e.g. for FFI).\n \n         self.normal_function_addresses.borrow_mut().insert(ptr);\n+        self.function_address_names.borrow_mut().insert(ptr, func_name.to_string());\n \n         ptr\n     }"}, {"sha": "3de018abf2eb6f30c2b050e11153fcf83bbb30f7", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c5736218121542d6fedfe027c6438b8b80cf5a6f/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5736218121542d6fedfe027c6438b8b80cf5a6f/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=c5736218121542d6fedfe027c6438b8b80cf5a6f", "patch": "@@ -5,7 +5,7 @@ use rustc_codegen_ssa::traits::BuilderMethods;\n \n use crate::{context::CodegenCx, builder::Builder};\n \n-pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str) -> Cow<'b, [RValue<'gcc>]> {\n+pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str, original_function_name: Option<&String>) -> Cow<'b, [RValue<'gcc>]> {\n     // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n     // arguments here.\n     if gcc_func.get_param_count() != args.len() {\n@@ -277,11 +277,23 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n                 let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 2]);\n                 args = vec![a, b, c, new_args[3]].into();\n             },\n-            \"__builtin_ia32_vfmaddsubpd256\" | \"__builtin_ia32_vfmaddsubps\" | \"__builtin_ia32_vfmaddsubps256\" => {\n-                let mut new_args = args.to_vec();\n-                let arg3 = &mut new_args[2];\n-                *arg3 = builder.context.new_unary_op(None, UnaryOp::Minus, arg3.get_type(), *arg3);\n-                args = new_args.into();\n+            \"__builtin_ia32_vfmaddsubpd256\" | \"__builtin_ia32_vfmaddsubps\" | \"__builtin_ia32_vfmaddsubps256\"\n+                | \"__builtin_ia32_vfmaddsubpd\" => {\n+                if let Some(original_function_name) = original_function_name {\n+                    match &**original_function_name {\n+                        \"llvm.x86.fma.vfmsubadd.pd.256\" | \"llvm.x86.fma.vfmsubadd.ps\" | \"llvm.x86.fma.vfmsubadd.ps.256\"\n+                            | \"llvm.x86.fma.vfmsubadd.pd\" => {\n+                            // NOTE: since both llvm.x86.fma.vfmsubadd.ps and llvm.x86.fma.vfmaddsub.ps maps to\n+                            // __builtin_ia32_vfmaddsubps, only add minus if this comes from a\n+                            // subadd LLVM intrinsic, e.g. _mm256_fmsubadd_pd.\n+                            let mut new_args = args.to_vec();\n+                            let arg3 = &mut new_args[2];\n+                            *arg3 = builder.context.new_unary_op(None, UnaryOp::Minus, arg3.get_type(), *arg3);\n+                            args = new_args.into();\n+                        },\n+                        _ => (),\n+                    }\n+                }\n             },\n             \"__builtin_ia32_ldmxcsr\" => {\n                 // The builtin __builtin_ia32_ldmxcsr takes an integer value while llvm.x86.sse.ldmxcsr takes a pointer,"}]}