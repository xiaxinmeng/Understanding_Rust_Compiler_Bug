{"sha": "ddc152b04d202123270d7cbfb3f821a392297685", "node_id": "C_kwDOAAsO6NoAKGRkYzE1MmIwNGQyMDIxMjMyNzBkN2NiZmIzZjgyMWEzOTIyOTc2ODU", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-01T00:52:00Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-03T21:47:46Z"}, "message": "Add more SIMD", "tree": {"sha": "cb7b4256d35865bd10f130ada0dbab34079f6f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb7b4256d35865bd10f130ada0dbab34079f6f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddc152b04d202123270d7cbfb3f821a392297685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc152b04d202123270d7cbfb3f821a392297685", "html_url": "https://github.com/rust-lang/rust/commit/ddc152b04d202123270d7cbfb3f821a392297685", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddc152b04d202123270d7cbfb3f821a392297685/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4636c59df5a7be4e47758588ad188bcb1f666f7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4636c59df5a7be4e47758588ad188bcb1f666f7c", "html_url": "https://github.com/rust-lang/rust/commit/4636c59df5a7be4e47758588ad188bcb1f666f7c"}], "stats": {"total": 235, "additions": 204, "deletions": 31}, "files": [{"sha": "738c990fa827f622779784230d9e962729629e1c", "filename": "src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddc152b04d202123270d7cbfb3f821a392297685/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc152b04d202123270d7cbfb3f821a392297685/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=ddc152b04d202123270d7cbfb3f821a392297685", "patch": "@@ -595,7 +595,7 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"Yk\",\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n             InlineAsmRegClass::X86(\n                 X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg,"}, {"sha": "160a7df03158000a64322270f7d30c5e583068f3", "filename": "src/builder.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ddc152b04d202123270d7cbfb3f821a392297685/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc152b04d202123270d7cbfb3f821a392297685/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=ddc152b04d202123270d7cbfb3f821a392297685", "patch": "@@ -7,6 +7,7 @@ use gccjit::{\n     BinaryOp,\n     Block,\n     ComparisonOp,\n+    Context,\n     Function,\n     LValue,\n     RValue,\n@@ -1380,6 +1381,85 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     pub fn shuffle_vector(&mut self, _v1: RValue<'gcc>, _v2: RValue<'gcc>, _mask: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }\n+\n+    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n+    {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut vector_elements = vec![];\n+        for i in 0..element_count {\n+            vector_elements.push(i);\n+        }\n+        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mut shift = 1;\n+        let mut res = src;\n+        while shift < element_count {\n+            let vector_elements: Vec<_> =\n+                vector_elements.iter()\n+                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .collect();\n+            let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n+            let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);\n+            shift *= 2;\n+            res = op(res, shifted, &self.context);\n+        }\n+        self.context.new_vector_access(None, res, self.context.new_rvalue_zero(self.int_type))\n+            .to_rvalue()\n+    }\n+\n+    pub fn vector_reduce_op(&mut self, src: RValue<'gcc>, op: BinaryOp) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| context.new_binary_op(None, op, a.get_type(), a, b))\n+    }\n+\n+    pub fn vector_reduce_fadd_fast(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    pub fn vector_reduce_fmul_fast(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    // Inspired by Hacker's Delight min implementation.\n+    pub fn vector_reduce_min(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| {\n+            let differences_or_zeros = difference_or_zero(a, b, context);\n+            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n+        })\n+    }\n+\n+    // Inspired by Hacker's Delight max implementation.\n+    pub fn vector_reduce_max(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| {\n+            let differences_or_zeros = difference_or_zero(a, b, context);\n+            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n+        })\n+    }\n+\n+    pub fn vector_select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, else_val: RValue<'gcc>) -> RValue<'gcc> {\n+        // cond is a vector of integers, not of bools.\n+        let vector_type = cond.get_type().dyncast_vector().expect(\"vector type\");\n+        let num_units = vector_type.get_num_units();\n+        let vector_type = self.context.new_vector_type(self.int_type, num_units as u64);\n+        let zeros = vec![self.context.new_rvalue_zero(self.int_type); num_units];\n+        let zeros = self.context.new_rvalue_from_vector(None, vector_type, &zeros);\n+\n+        let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n+        let then_vals = masks & then_val;\n+\n+        let ones = vec![self.context.new_rvalue_one(self.int_type); num_units];\n+        let ones = self.context.new_rvalue_from_vector(None, vector_type, &ones);\n+        let inverted_masks = masks + ones;\n+        let else_vals = inverted_masks & else_val;\n+\n+        then_vals | else_vals\n+    }\n+}\n+\n+fn difference_or_zero<'gcc>(a: RValue<'gcc>, b: RValue<'gcc>, context: &'gcc Context<'gcc>) -> RValue<'gcc> {\n+    let difference = a - b;\n+    let masks = context.new_comparison(None, ComparisonOp::GreaterThanEquals, b, a);\n+    difference & masks\n }\n \n impl<'a, 'gcc, 'tcx> StaticBuilderMethods for Builder<'a, 'gcc, 'tcx> {"}, {"sha": "e4a08da446bb116aac4687e841de8aad7cc8d0bc", "filename": "src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddc152b04d202123270d7cbfb3f821a392297685/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc152b04d202123270d7cbfb3f821a392297685/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=ddc152b04d202123270d7cbfb3f821a392297685", "patch": "@@ -117,8 +117,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n-    fn const_real(&self, _t: Type<'gcc>, _val: f64) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn const_real(&self, typ: Type<'gcc>, val: f64) -> RValue<'gcc> {\n+        self.context.new_rvalue_from_double(typ, val)\n     }\n \n     fn const_str(&self, s: Symbol) -> (RValue<'gcc>, RValue<'gcc>) {"}, {"sha": "dccfb89409de5efc8b72ee26a3831cc5e0a83f2e", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 117, "deletions": 28, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ddc152b04d202123270d7cbfb3f821a392297685/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc152b04d202123270d7cbfb3f821a392297685/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=ddc152b04d202123270d7cbfb3f821a392297685", "patch": "@@ -1,6 +1,6 @@\n use std::cmp::Ordering;\n \n-use gccjit::{RValue, Type, ToRValue};\n+use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n@@ -222,6 +222,24 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n     }\n \n+    if name == sym::simd_select {\n+        let m_elem_ty = in_elem;\n+        let m_len = in_len;\n+        require_simd!(arg_tys[1], \"argument\");\n+        let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        require!(\n+            m_len == v_len,\n+            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n+            m_len,\n+            v_len\n+        );\n+        match m_elem_ty.kind() {\n+            ty::Int(_) => {}\n+            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+        }\n+        return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n+    }\n+\n     if name == sym::simd_cast {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n@@ -543,7 +561,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     }\n \n     macro_rules! arith_red {\n-        ($name:ident : $integer_reduce:ident, $float_reduce:ident, $ordered:expr, $op:ident,\n+        ($name:ident : $vec_op:expr, $float_reduce:ident, $ordered:expr, $op:ident,\n          $identity:expr) => {\n             if name == sym::$name {\n                 require!(\n@@ -555,36 +573,25 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n-                        let r = bx.$integer_reduce(args[0].immediate());\n+                        let r = bx.vector_reduce_op(args[0].immediate(), $vec_op);\n                         if $ordered {\n                             // if overflow occurs, the result is the\n                             // mathematical result modulo 2^n:\n                             Ok(bx.$op(args[1].immediate(), r))\n-                        } else {\n-                            Ok(bx.$integer_reduce(args[0].immediate()))\n+                        }\n+                        else {\n+                            Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n-                    ty::Float(f) => {\n-                        let acc = if $ordered {\n+                    ty::Float(_) => {\n+                        if $ordered {\n                             // ordered arithmetic reductions take an accumulator\n-                            args[1].immediate()\n-                        } else {\n-                            // unordered arithmetic reductions use the identity accumulator\n-                            match f.bit_width() {\n-                                32 => bx.const_real(bx.type_f32(), $identity),\n-                                64 => bx.const_real(bx.type_f64(), $identity),\n-                                v => return_error!(\n-                                    r#\"\n-unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n-                                    sym::$name,\n-                                    in_ty,\n-                                    in_elem,\n-                                    v,\n-                                    ret_ty\n-                                ),\n-                            }\n-                        };\n-                        Ok(bx.$float_reduce(acc, args[0].immediate()))\n+                            let acc = args[1].immediate();\n+                            Ok(bx.$float_reduce(acc, args[0].immediate()))\n+                        }\n+                        else {\n+                            Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n+                        }\n                     }\n                     _ => return_error!(\n                         \"unsupported {} from `{}` with element `{}` to `{}`\",\n@@ -598,14 +605,96 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         };\n     }\n \n-    // TODO: use a recursive algorithm a-la Hacker's Delight.\n     arith_red!(\n-        simd_reduce_add_unordered: vector_reduce_add,\n+        simd_reduce_add_unordered: BinaryOp::Plus,\n         vector_reduce_fadd_fast,\n         false,\n         add,\n-        0.0\n+        0.0 // TODO: Use this argument.\n+    );\n+    arith_red!(\n+        simd_reduce_mul_unordered: BinaryOp::Mult,\n+        vector_reduce_fmul_fast,\n+        false,\n+        mul,\n+        1.0\n     );\n \n+    macro_rules! minmax_red {\n+        ($name:ident: $reduction:ident) => {\n+            if name == sym::$name {\n+                require!(\n+                    ret_ty == in_elem,\n+                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                    in_elem,\n+                    in_ty,\n+                    ret_ty\n+                );\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) | ty::Float(_) => Ok(bx.$reduction(args[0].immediate())),\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    minmax_red!(simd_reduce_min: vector_reduce_min);\n+    minmax_red!(simd_reduce_max: vector_reduce_max);\n+\n+    macro_rules! bitwise_red {\n+        ($name:ident : $op:expr, $boolean:expr) => {\n+            if name == sym::$name {\n+                let input = if !$boolean {\n+                    require!(\n+                        ret_ty == in_elem,\n+                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                        in_elem,\n+                        in_ty,\n+                        ret_ty\n+                    );\n+                    args[0].immediate()\n+                } else {\n+                    match in_elem.kind() {\n+                        ty::Int(_) | ty::Uint(_) => {}\n+                        _ => return_error!(\n+                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                            sym::$name,\n+                            in_ty,\n+                            in_elem,\n+                            ret_ty\n+                        ),\n+                    }\n+\n+                    // boolean reductions operate on vectors of i1s:\n+                    let i1 = bx.type_i1();\n+                    let i1xn = bx.type_vector(i1, in_len as u64);\n+                    bx.trunc(args[0].immediate(), i1xn)\n+                };\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) => {\n+                        let r = bx.vector_reduce_op(input, $op);\n+                        Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n+                    }\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    bitwise_red!(simd_reduce_and: BinaryOp::BitwiseAnd, false);\n+    bitwise_red!(simd_reduce_or: BinaryOp::BitwiseOr, false);\n+\n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "002b95db36deef85e6b2a145bfe1e1415d8c1eb5", "filename": "src/type_.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddc152b04d202123270d7cbfb3f821a392297685/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc152b04d202123270d7cbfb3f821a392297685/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=ddc152b04d202123270d7cbfb3f821a392297685", "patch": "@@ -247,6 +247,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n         self.context.new_array_type(None, ty, len)\n     }\n+\n+    pub fn type_bool(&self) -> Type<'gcc> {\n+        self.context.new_type::<bool>()\n+    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {"}]}