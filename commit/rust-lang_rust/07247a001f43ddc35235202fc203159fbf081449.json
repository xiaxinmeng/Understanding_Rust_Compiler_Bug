{"sha": "07247a001f43ddc35235202fc203159fbf081449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MjQ3YTAwMWY0M2RkYzM1MjM1MjAyZmMyMDMxNTlmYmYwODE0NDk=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-03-06T07:14:58Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-04-03T17:54:29Z"}, "message": "Various bug fixes", "tree": {"sha": "6e50ee2fde532979f5ae0cecf0e8fba221133d29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e50ee2fde532979f5ae0cecf0e8fba221133d29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07247a001f43ddc35235202fc203159fbf081449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07247a001f43ddc35235202fc203159fbf081449", "html_url": "https://github.com/rust-lang/rust/commit/07247a001f43ddc35235202fc203159fbf081449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07247a001f43ddc35235202fc203159fbf081449/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "url": "https://api.github.com/repos/rust-lang/rust/commits/93ce1c1a597aba7049fe2a39737c8155dd4e2a50", "html_url": "https://github.com/rust-lang/rust/commit/93ce1c1a597aba7049fe2a39737c8155dd4e2a50"}], "stats": {"total": 198, "additions": 180, "deletions": 18}, "files": [{"sha": "747096306ff774a296f930e7347de6412147dfd8", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -12,11 +12,11 @@ mod permute;\n #[macro_use]\n mod transmute;\n \n+mod comparisons;\n mod fmt;\n mod intrinsics;\n mod ops;\n mod round;\n-mod comparisons;\n \n mod math;\n "}, {"sha": "d30399fb5ad10c204b7332a359e3255fe880721b", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -28,6 +28,28 @@ macro_rules! define_opaque_mask {\n                 Self(<$inner_ty>::splat(value))\n             }\n \n+            /// Converts an array to a SIMD vector.\n+            pub fn from_array(array: [bool; LANES]) -> Self {\n+                let mut vector = Self::splat(false);\n+                let mut i = 0;\n+                while i < $lanes {\n+                    vector.set(i, array[i]);\n+                    i += 1;\n+                }\n+                vector\n+            }\n+\n+            /// Converts a SIMD vector to an array.\n+            pub fn to_array(self) -> [bool; LANES] {\n+                let mut array = [false; LANES];\n+                let mut i = 0;\n+                while i < $lanes {\n+                    array[i] = self.test(i);\n+                    i += 1;\n+                }\n+                array\n+            }\n+\n             /// Tests the value of the specified lane.\n             ///\n             /// # Panics\n@@ -85,6 +107,19 @@ macro_rules! define_opaque_mask {\n             }\n         }\n \n+        // vector/array conversion\n+        impl<const $lanes: usize> From<[bool; $lanes]> for $name<$lanes> where $bits_ty: crate::LanesAtMost64 {\n+            fn from(array: [bool; $lanes]) -> Self {\n+                Self::from_array(array)\n+            }\n+        }\n+\n+        impl <const $lanes: usize> From<$name<$lanes>> for [bool; $lanes] where $bits_ty: crate::LanesAtMost64 {\n+            fn from(vector: $name<$lanes>) -> Self {\n+                vector.to_array()\n+            }\n+        }\n+\n         impl<const $lanes: usize> Copy for $name<$lanes>\n         where\n             $inner_ty: Copy,"}, {"sha": "85456e7bf1ecd2aa598d89944b33e61c547e9126", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -47,21 +47,21 @@ macro_rules! impl_float_vector {\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n             #[inline]\n             pub fn is_sign_positive(self) -> crate::$mask_ty<LANES> {\n-                let sign_bits = self.to_bits() & crate::$bits_ty::splat((!0 >> 1) + 1);\n-                sign_bits.lanes_gt(crate::$bits_ty::splat(0))\n+                !self.is_sign_negative()\n             }\n \n             /// Returns true for each lane if it has a negative sign, including\n             /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n             #[inline]\n             pub fn is_sign_negative(self) -> crate::$mask_ty<LANES> {\n-                !self.is_sign_positive()\n+                let sign_bits = self.to_bits() & crate::$bits_ty::splat((!0 >> 1) + 1);\n+                sign_bits.lanes_gt(crate::$bits_ty::splat(0))\n             }\n \n             /// Returns true for each lane if its value is `NaN`.\n             #[inline]\n             pub fn is_nan(self) -> crate::$mask_ty<LANES> {\n-                self.lanes_eq(self)\n+                self.lanes_ne(self)\n             }\n \n             /// Returns true for each lane if its value is positive infinity or negative infinity.\n@@ -79,8 +79,8 @@ macro_rules! impl_float_vector {\n             /// Returns true for each lane if its value is subnormal.\n             #[inline]\n             pub fn is_subnormal(self) -> crate::$mask_ty<LANES> {\n-                let mantissa_mask = crate::$bits_ty::splat((1 << (<$type>::MANTISSA_DIGITS - 1)) - 1);\n-                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & mantissa_mask).lanes_eq(crate::$bits_ty::splat(0))\n+                let exponent_mask = crate::$bits_ty::splat(!0 << <$type>::MANTISSA_DIGITS);\n+                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & exponent_mask).lanes_eq(crate::$bits_ty::splat(0))\n             }\n \n             /// Returns true for each lane if its value is neither neither zero, infinite,\n@@ -93,7 +93,6 @@ macro_rules! impl_float_vector {\n     };\n }\n \n-\n /// A SIMD vector of containing `LANES` `f32` values.\n #[repr(simd)]\n pub struct SimdF32<const LANES: usize>([f32; LANES])"}, {"sha": "364a2ed935fb686d7adc66d31c8bff436c86dbb3", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -2,7 +2,7 @@\n \n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n-    { $name:ident, $type:ty } => {\n+    { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n \n         impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost64 {}\n@@ -24,6 +24,22 @@ macro_rules! impl_integer_vector {\n                 self.as_slice().hash(state)\n             }\n         }\n+\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            Self: crate::LanesAtMost64,\n+            crate::$mask_impl_ty<LANES>: crate::LanesAtMost64,\n+        {\n+            /// Returns true for each positive lane and false if it is zero or negative.\n+            pub fn is_positive(self) -> crate::$mask_ty<LANES> {\n+                self.lanes_gt(Self::splat(0))\n+            }\n+\n+            /// Returns true for each negative lane and false if it is zero or positive.\n+            pub fn is_negative(self) -> crate::$mask_ty<LANES> {\n+                self.lanes_lt(Self::splat(0))\n+            }\n+        }\n     }\n }\n \n@@ -33,7 +49,7 @@ pub struct SimdIsize<const LANES: usize>([isize; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdIsize, isize }\n+impl_integer_vector! { SimdIsize, isize, MaskSize, SimdIsize }\n \n #[cfg(target_pointer_width = \"32\")]\n from_transmute_x86! { unsafe isizex4 => __m128i }\n@@ -53,7 +69,7 @@ pub struct SimdI128<const LANES: usize>([i128; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdI128, i128 }\n+impl_integer_vector! { SimdI128, i128, Mask128, SimdI128 }\n \n from_transmute_x86! { unsafe i128x2 => __m256i }\n //from_transmute_x86! { unsafe i128x4 => __m512i }\n@@ -64,7 +80,7 @@ pub struct SimdI16<const LANES: usize>([i16; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdI16, i16 }\n+impl_integer_vector! { SimdI16, i16, Mask16, SimdI16 }\n \n from_transmute_x86! { unsafe i16x8 => __m128i }\n from_transmute_x86! { unsafe i16x16 => __m256i }\n@@ -76,7 +92,7 @@ pub struct SimdI32<const LANES: usize>([i32; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdI32, i32 }\n+impl_integer_vector! { SimdI32, i32, Mask32, SimdI32 }\n \n from_transmute_x86! { unsafe i32x4 => __m128i }\n from_transmute_x86! { unsafe i32x8 => __m256i }\n@@ -88,7 +104,7 @@ pub struct SimdI64<const LANES: usize>([i64; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdI64, i64 }\n+impl_integer_vector! { SimdI64, i64, Mask64, SimdI64 }\n \n from_transmute_x86! { unsafe i64x2 => __m128i }\n from_transmute_x86! { unsafe i64x4 => __m256i }\n@@ -100,7 +116,7 @@ pub struct SimdI8<const LANES: usize>([i8; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdI8, i8 }\n+impl_integer_vector! { SimdI8, i8, Mask8, SimdI8 }\n \n from_transmute_x86! { unsafe i8x16 => __m128i }\n from_transmute_x86! { unsafe i8x32 => __m256i }"}, {"sha": "048c070a391d545a742c7907da3c4f734f317398", "filename": "crates/core_simd/tests/f32_ops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -1,3 +1,5 @@\n+#![feature(is_subnormal)]\n+\n #[macro_use]\n mod ops_macros;\n impl_float_tests! { SimdF32, f32, i32 }"}, {"sha": "8f0dd6b7365538e2b64f5455271e53cbe84db3d5", "filename": "crates/core_simd/tests/f64_ops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -1,3 +1,5 @@\n+#![feature(is_subnormal)]\n+\n #[macro_use]\n mod ops_macros;\n impl_float_tests! { SimdF64, f64, i64 }"}, {"sha": "a70a8a9c48b9d0e66ba99481a5bd7c768b794c94", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -147,11 +147,27 @@ macro_rules! impl_signed_tests {\n             test_helpers::test_lanes! {\n                 fn neg<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n-                        &<Vector<LANES> as core::ops::Neg>::neg,\n+                        &<Vector::<LANES> as core::ops::Neg>::neg,\n                         &<Scalar as core::ops::Neg>::neg,\n                         &|x| !x.contains(&Scalar::MIN),\n                     );\n                 }\n+\n+                fn is_positive<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_positive,\n+                        &Scalar::is_positive,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_negative<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_negative,\n+                        &Scalar::is_negative,\n+                        &|_| true,\n+                    );\n+                }\n             }\n \n             test_helpers::test_lanes_panic! {\n@@ -285,6 +301,62 @@ macro_rules! impl_float_tests {\n             }\n \n             test_helpers::test_lanes! {\n+                fn is_sign_positive<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_sign_positive,\n+                        &Scalar::is_sign_positive,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_sign_negative<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_sign_negative,\n+                        &Scalar::is_sign_negative,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_finite<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_finite,\n+                        &Scalar::is_finite,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_infinite<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_infinite,\n+                        &Scalar::is_infinite,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_nan<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_nan,\n+                        &Scalar::is_nan,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_normal<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_normal,\n+                        &Scalar::is_normal,\n+                        &|_| true,\n+                    );\n+                }\n+\n+                fn is_subnormal<const LANES: usize>() {\n+                    test_helpers::test_unary_mask_elementwise(\n+                        &Vector::<LANES>::is_subnormal,\n+                        &Scalar::is_subnormal,\n+                        &|_| true,\n+                    );\n+                }\n+\n                 fn abs<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n                         &Vector::<LANES>::abs,"}, {"sha": "4a41fe3a16ea55ebefaf6f137205e0407ad46a9f", "filename": "crates/test_helpers/src/biteq.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -5,6 +5,16 @@ pub trait BitEq {\n     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;\n }\n \n+impl BitEq for bool {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n macro_rules! impl_integer_biteq {\n     { $($type:ty),* } => {\n         $("}, {"sha": "df1abcddaea16c5d197d90814e3267722bdae637", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/07247a001f43ddc35235202fc203159fbf081449/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07247a001f43ddc35235202fc203159fbf081449/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=07247a001f43ddc35235202fc203159fbf081449", "patch": "@@ -124,6 +124,32 @@ pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const\n     });\n }\n \n+/// Test a unary vector function against a unary scalar function, applied elementwise.\n+#[inline(never)]\n+pub fn test_unary_mask_elementwise<Scalar, Vector, Mask, const LANES: usize>(\n+    fv: &dyn Fn(Vector) -> Mask,\n+    fs: &dyn Fn(Scalar) -> bool,\n+    check: &dyn Fn([Scalar; LANES]) -> bool,\n+) where\n+    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n+    Mask: Into<[bool; LANES]> + From<[bool; LANES]> + Copy,\n+{\n+    test_1(&|x: [Scalar; LANES]| {\n+        proptest::prop_assume!(check(x));\n+        let result_1: [bool; LANES] = fv(x.into()).into();\n+        let result_2: [bool; LANES] = {\n+            let mut result = [false; LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n /// Test a binary vector function against a binary scalar function, applied elementwise.\n #[inline(never)]\n pub fn test_binary_elementwise<\n@@ -307,7 +333,7 @@ macro_rules! test_lanes {\n             }\n         )*\n     }\n-}  \n+}\n \n /// Expand a const-generic `#[should_panic]` test into separate tests for each possible lane count.\n #[macro_export]\n@@ -382,4 +408,4 @@ macro_rules! test_lanes_panic {\n             }\n         )*\n     }\n-}  \n+}"}]}