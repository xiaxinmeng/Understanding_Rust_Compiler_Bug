{"sha": "550bc9bd1c5aa90f6574b7d4ebd9922b986f9741", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MGJjOWJkMWM1YWE5MGY2NTc0YjdkNGViZDk5MjJiOTg2Zjk3NDE=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-26T03:46:26Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T03:10:10Z"}, "message": "path2: Reimplement PosixPath in terms of ~[u8]", "tree": {"sha": "21fc404dfe96594798ed89ea92e0fd9842d42b76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21fc404dfe96594798ed89ea92e0fd9842d42b76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/550bc9bd1c5aa90f6574b7d4ebd9922b986f9741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/550bc9bd1c5aa90f6574b7d4ebd9922b986f9741", "html_url": "https://github.com/rust-lang/rust/commit/550bc9bd1c5aa90f6574b7d4ebd9922b986f9741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/550bc9bd1c5aa90f6574b7d4ebd9922b986f9741/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b41391306692c82d9b44721a47833eb809e0cbf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b41391306692c82d9b44721a47833eb809e0cbf1", "html_url": "https://github.com/rust-lang/rust/commit/b41391306692c82d9b44721a47833eb809e0cbf1"}], "stats": {"total": 292, "additions": 154, "deletions": 138}, "files": [{"sha": "dea326fadfea37221c5f9563666a0356624a403c", "filename": "src/libstd/path2.rs", "status": "modified", "additions": 154, "deletions": 138, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/550bc9bd1c5aa90f6574b7d4ebd9922b986f9741/src%2Flibstd%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550bc9bd1c5aa90f6574b7d4ebd9922b986f9741/src%2Flibstd%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2.rs?ref=550bc9bd1c5aa90f6574b7d4ebd9922b986f9741", "patch": "@@ -18,10 +18,11 @@ use from_str::FromStr;\n use iterator::{AdditiveIterator, Extendable, Iterator};\n use option::{Option, None, Some};\n use str;\n-use str::{OwnedStr, Str, StrSlice, StrVector};\n+use str::{OwnedStr, Str, StrSlice};\n use util;\n use vec;\n-use vec::{ImmutableVector, OwnedVector};\n+use vec::{CopyableVector, OwnedCopyableVector, OwnedVector};\n+use vec::{ImmutableEqVector, ImmutableVector, Vector, VectorVector};\n \n /// Typedef for the platform-native path type\n #[cfg(unix)]\n@@ -38,7 +39,7 @@ pub type ComponentIter<'self> = PosixComponentIter<'self>;\n //pub type ComponentIter<'self> = WindowsComponentIter<'self>;\n \n /// Iterator that yields successive components of a PosixPath\n-type PosixComponentIter<'self> = str::CharSplitIterator<'self, char>;\n+type PosixComponentIter<'self> = vec::SplitIterator<'self, u8>;\n \n // Condition that is raised when a NUL is found in a byte vector given to a Path function\n condition! {\n@@ -541,142 +542,142 @@ impl ToCStr for PosixPath {\n     }\n }\n \n-impl GenericPath for PosixPath {\n-    #[inline]\n-    fn from_str(s: &str) -> PosixPath {\n-        PosixPath::new(s)\n+impl GenericPathUnsafe for PosixPath {\n+    unsafe fn from_vec_unchecked(path: &[u8]) -> PosixPath {\n+        let path = PosixPath::normalize(path);\n+        assert!(!path.is_empty());\n+        let idx = path.rposition_elem(&posix::sep);\n+        PosixPath{ repr: path, sepidx: idx }\n     }\n \n-    #[inline]\n-    fn as_str<'a>(&'a self) -> &'a str {\n-        self.repr.as_slice()\n-    }\n-\n-    fn dirname<'a>(&'a self) -> &'a str {\n+    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]) {\n         match self.sepidx {\n-            None if \"..\" == self.repr => \"..\",\n-            None => \".\",\n-            Some(0) => self.repr.slice_to(1),\n-            Some(idx) if self.repr.slice_from(idx+1) == \"..\" => self.repr.as_slice(),\n-            Some(idx) => self.repr.slice_to(idx)\n-        }\n-    }\n-\n-    fn filename<'a>(&'a self) -> &'a str {\n-        match self.sepidx {\n-            None if \".\" == self.repr || \"..\" == self.repr => \"\",\n-            None => self.repr.as_slice(),\n-            Some(idx) if self.repr.slice_from(idx+1) == \"..\" => \"\",\n-            Some(idx) => self.repr.slice_from(idx+1)\n-        }\n-    }\n-\n-    fn set_dirname(&mut self, dirname: &str) {\n-        match self.sepidx {\n-            None if \".\" == self.repr || \"..\" == self.repr => {\n+            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => {\n                 self.repr = PosixPath::normalize(dirname);\n             }\n             None => {\n-                let mut s = str::with_capacity(dirname.len() + self.repr.len() + 1);\n-                s.push_str(dirname);\n-                s.push_char(posix::sep);\n-                s.push_str(self.repr);\n-                self.repr = PosixPath::normalize(s);\n+                let mut v = vec::with_capacity(dirname.len() + self.repr.len() + 1);\n+                v.push_all(dirname);\n+                v.push(posix::sep);\n+                v.push_all(self.repr);\n+                self.repr = PosixPath::normalize(v);\n             }\n-            Some(0) if self.repr.len() == 1 && self.repr[0] == posix::sep as u8 => {\n+            Some(0) if self.repr.len() == 1 && self.repr[0] == posix::sep => {\n                 self.repr = PosixPath::normalize(dirname);\n             }\n-            Some(idx) if dirname == \"\" => {\n-                let s = PosixPath::normalize(self.repr.slice_from(idx+1));\n-                self.repr = s;\n+            Some(idx) if dirname.is_empty() => {\n+                let v = PosixPath::normalize(self.repr.slice_from(idx+1));\n+                self.repr = v;\n             }\n-            Some(idx) if self.repr.slice_from(idx+1) == \"..\" => {\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n                 self.repr = PosixPath::normalize(dirname);\n             }\n             Some(idx) => {\n-                let mut s = str::with_capacity(dirname.len() + self.repr.len() - idx);\n-                s.push_str(dirname);\n-                s.push_str(self.repr.slice_from(idx));\n-                self.repr = PosixPath::normalize(s);\n+                let mut v = vec::with_capacity(dirname.len() + self.repr.len() - idx);\n+                v.push_all(dirname);\n+                v.push_all(self.repr.slice_from(idx));\n+                self.repr = PosixPath::normalize(v);\n             }\n         }\n-        self.sepidx = self.repr.rfind(posix::sep);\n+        self.sepidx = self.repr.rposition_elem(&posix::sep);\n     }\n \n-    fn set_filename(&mut self, filename: &str) {\n+    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]) {\n         match self.sepidx {\n-            None if \"..\" == self.repr => {\n-                let mut s = str::with_capacity(3 + filename.len());\n-                s.push_str(\"..\");\n-                s.push_char(posix::sep);\n-                s.push_str(filename);\n-                self.repr = PosixPath::normalize(s);\n+            None if bytes!(\"..\") == self.repr => {\n+                let mut v = vec::with_capacity(3 + filename.len());\n+                v.push_all(dot_dot_static);\n+                v.push(posix::sep);\n+                v.push_all(filename);\n+                self.repr = PosixPath::normalize(v);\n             }\n             None => {\n                 self.repr = PosixPath::normalize(filename);\n             }\n-            Some(idx) if self.repr.slice_from(idx+1) == \"..\" => {\n-                let mut s = str::with_capacity(self.repr.len() + 1 + filename.len());\n-                s.push_str(self.repr);\n-                s.push_char(posix::sep);\n-                s.push_str(filename);\n-                self.repr = PosixPath::normalize(s);\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n+                let mut v = vec::with_capacity(self.repr.len() + 1 + filename.len());\n+                v.push_all(self.repr);\n+                v.push(posix::sep);\n+                v.push_all(filename);\n+                self.repr = PosixPath::normalize(v);\n             }\n             Some(idx) => {\n-                let mut s = str::with_capacity(self.repr.len() - idx + filename.len());\n-                s.push_str(self.repr.slice_to(idx+1));\n-                s.push_str(filename);\n-                self.repr = PosixPath::normalize(s);\n+                let mut v = vec::with_capacity(self.repr.len() - idx + filename.len());\n+                v.push_all(self.repr.slice_to(idx+1));\n+                v.push_all(filename);\n+                self.repr = PosixPath::normalize(v);\n             }\n         }\n-        self.sepidx = self.repr.rfind(posix::sep);\n+        self.sepidx = self.repr.rposition_elem(&posix::sep);\n     }\n \n-    fn push(&mut self, path: &str) {\n+    unsafe fn push_unchecked(&mut self, path: &[u8]) {\n         if !path.is_empty() {\n-            if path[0] == posix::sep as u8 {\n+            if path[0] == posix::sep {\n                 self.repr = PosixPath::normalize(path);\n             }  else {\n-                let mut s = str::with_capacity(self.repr.len() + path.len() + 1);\n-                s.push_str(self.repr);\n-                s.push_char(posix::sep);\n-                s.push_str(path);\n-                self.repr = PosixPath::normalize(s);\n+                let mut v = vec::with_capacity(self.repr.len() + path.len() + 1);\n+                v.push_all(self.repr);\n+                v.push(posix::sep);\n+                v.push_all(path);\n+                self.repr = PosixPath::normalize(v);\n             }\n-            self.sepidx = self.repr.rfind(posix::sep);\n+            self.sepidx = self.repr.rposition_elem(&posix::sep);\n         }\n     }\n+}\n \n-    fn push_path(&mut self, path: &PosixPath) {\n-        self.push(path.as_str());\n+impl GenericPath for PosixPath {\n+    #[inline]\n+    fn as_vec<'a>(&'a self) -> &'a [u8] {\n+        self.repr.as_slice()\n     }\n \n-    fn pop_opt(&mut self) -> Option<~str> {\n+    fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if \".\" == self.repr => None,\n+            None if bytes!(\"..\") == self.repr => self.repr.as_slice(),\n+            None => dot_static,\n+            Some(0) => self.repr.slice_to(1),\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => self.repr.as_slice(),\n+            Some(idx) => self.repr.slice_to(idx)\n+        }\n+    }\n+\n+    fn filename<'a>(&'a self) -> &'a [u8] {\n+        match self.sepidx {\n+            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => &[],\n+            None => self.repr.as_slice(),\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => &[],\n+            Some(idx) => self.repr.slice_from(idx+1)\n+        }\n+    }\n+\n+    fn pop_opt(&mut self) -> Option<~[u8]> {\n+        match self.sepidx {\n+            None if bytes!(\".\") == self.repr => None,\n             None => {\n-                let mut s = ~\".\";\n-                util::swap(&mut s, &mut self.repr);\n+                let mut v = ~['.' as u8];\n+                util::swap(&mut v, &mut self.repr);\n                 self.sepidx = None;\n-                Some(s)\n+                Some(v)\n             }\n-            Some(0) if \"/\" == self.repr => None,\n+            Some(0) if bytes!(\"/\") == self.repr => None,\n             Some(idx) => {\n-                let s = self.repr.slice_from(idx+1).to_owned();\n+                let v = self.repr.slice_from(idx+1).to_owned();\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n                 } else {\n                     self.repr.truncate(idx);\n                 }\n-                self.sepidx = self.repr.rfind(posix::sep);\n-                Some(s)\n+                self.sepidx = self.repr.rposition_elem(&posix::sep);\n+                Some(v)\n             }\n         }\n     }\n \n     #[inline]\n     fn is_absolute(&self) -> bool {\n-        self.repr[0] == posix::sep as u8\n+        self.repr[0] == posix::sep\n     }\n \n     fn is_ancestor_of(&self, other: &PosixPath) -> bool {\n@@ -685,19 +686,16 @@ impl GenericPath for PosixPath {\n         } else {\n             let mut ita = self.component_iter();\n             let mut itb = other.component_iter();\n-            if \".\" == self.repr {\n-                return match itb.next() {\n-                    Some(\"..\") => false,\n-                    _ => true\n-                };\n+            if bytes!(\".\") == self.repr {\n+                return itb.next() != Some(bytes!(\"..\"));\n             }\n             loop {\n                 match (ita.next(), itb.next()) {\n                     (None, _) => break,\n                     (Some(a), Some(b)) if a == b => { loop },\n-                    (Some(\"..\"), _) => {\n+                    (Some(a), _) if a == bytes!(\"..\") => {\n                         // if ita contains only .. components, it's an ancestor\n-                        return ita.all(|x| x == \"..\");\n+                        return ita.all(|x| x == bytes!(\"..\"));\n                     }\n                     _ => return false\n                 }\n@@ -725,76 +723,92 @@ impl GenericPath for PosixPath {\n                         comps.extend(&mut ita);\n                         break;\n                     }\n-                    (None, _) => comps.push(\"..\"),\n+                    (None, _) => comps.push(dot_dot_static),\n                     (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n-                    (Some(a), Some(\".\")) => comps.push(a),\n-                    (Some(_), Some(\"..\")) => return None,\n+                    (Some(a), Some(b)) if b == bytes!(\".\") => comps.push(a),\n+                    (Some(_), Some(b)) if b == bytes!(\"..\") => return None,\n                     (Some(a), Some(_)) => {\n-                        comps.push(\"..\");\n+                        comps.push(dot_dot_static);\n                         for _ in itb {\n-                            comps.push(\"..\");\n+                            comps.push(dot_dot_static);\n                         }\n                         comps.push(a);\n                         comps.extend(&mut ita);\n                         break;\n                     }\n                 }\n             }\n-            Some(PosixPath::new(comps.connect(str::from_char(posix::sep))))\n+            Some(PosixPath::new(comps.connect_vec(&posix::sep)))\n         }\n     }\n }\n \n impl PosixPath {\n+    /// Returns a new PosixPath from a byte vector\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the vector contains a NUL.\n+    #[inline]\n+    pub fn new(v: &[u8]) -> PosixPath {\n+        GenericPath::from_vec(v)\n+    }\n+\n     /// Returns a new PosixPath from a string\n-    pub fn new(s: &str) -> PosixPath {\n-        let s = PosixPath::normalize(s);\n-        assert!(!s.is_empty());\n-        let idx = s.rfind(posix::sep);\n-        PosixPath{ repr: s, sepidx: idx }\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the str contains a NUL.\n+    #[inline]\n+    pub fn from_str(s: &str) -> PosixPath {\n+        GenericPath::from_str(s)\n     }\n \n-    /// Converts the PosixPath into an owned string\n-    pub fn into_str(self) -> ~str {\n+    /// Converts the PosixPath into an owned byte vector\n+    pub fn into_vec(self) -> ~[u8] {\n         self.repr\n     }\n \n-    /// Returns a normalized string representation of a path, by removing all empty\n+    /// Converts the PosixPath into an owned string, if possible\n+    pub fn into_str(self) -> Option<~str> {\n+        str::from_bytes_owned_opt(self.repr)\n+    }\n+\n+    /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    pub fn normalize<S: Str>(s: S) -> ~str {\n+    pub fn normalize<V: Vector<u8>+CopyableVector<u8>>(v: V) -> ~[u8] {\n         // borrowck is being very picky\n         let val = {\n-            let is_abs = !s.as_slice().is_empty() && s.as_slice()[0] == posix::sep as u8;\n-            let s_ = if is_abs { s.as_slice().slice_from(1) } else { s.as_slice() };\n-            let comps = normalize_helper(s_, is_abs, posix::sep);\n+            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == posix::sep;\n+            let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n+            let comps = normalize_helper(v_, is_abs, posix::is_sep);\n             match comps {\n                 None => None,\n                 Some(comps) => {\n-                    let sepstr = str::from_char(posix::sep);\n                     if is_abs && comps.is_empty() {\n-                        Some(sepstr)\n+                        Some(~[posix::sep])\n                     } else {\n                         let n = if is_abs { comps.len() } else { comps.len() - 1} +\n-                                comps.iter().map(|s| s.len()).sum();\n-                        let mut s = str::with_capacity(n);\n+                                comps.iter().map(|v| v.len()).sum();\n+                        let mut v = vec::with_capacity(n);\n                         let mut it = comps.move_iter();\n                         if !is_abs {\n                             match it.next() {\n                                 None => (),\n-                                Some(comp) => s.push_str(comp)\n+                                Some(comp) => v.push_all(comp)\n                             }\n                         }\n                         for comp in it {\n-                            s.push_str(sepstr);\n-                            s.push_str(comp);\n+                            v.push(posix::sep);\n+                            v.push_all(comp);\n                         }\n-                        Some(s)\n+                        Some(v)\n                     }\n                 }\n             }\n         };\n         match val {\n-            None => s.into_owned(),\n+            None => v.into_owned(),\n             Some(val) => val\n         }\n     }\n@@ -804,49 +818,51 @@ impl PosixPath {\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn component_iter<'a>(&'a self) -> PosixComponentIter<'a> {\n-        let s = if self.repr[0] == posix::sep as u8 {\n+        let v = if self.repr[0] == posix::sep {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n-        let mut ret = s.split_iter(posix::sep);\n-        if s.is_empty() {\n+        let mut ret = v.split_iter(posix::is_sep);\n+        if v.is_empty() {\n             // consume the empty \"\" component\n             ret.next();\n         }\n         ret\n     }\n }\n \n-// None result means the string didn't need normalizing\n-fn normalize_helper<'a, Sep: str::CharEq>(s: &'a str, is_abs: bool, sep: Sep) -> Option<~[&'a str]> {\n-    if is_abs && s.as_slice().is_empty() {\n+// None result means the byte vector didn't need normalizing\n+fn normalize_helper<'a>(v: &'a [u8], is_abs: bool, f: &'a fn(&u8) -> bool) -> Option<~[&'a [u8]]> {\n+    if is_abs && v.as_slice().is_empty() {\n         return None;\n     }\n-    let mut comps: ~[&'a str] = ~[];\n+    let mut comps: ~[&'a [u8]] = ~[];\n     let mut n_up = 0u;\n     let mut changed = false;\n-    for comp in s.split_iter(sep) {\n-        match comp {\n-            \"\" => { changed = true; }\n-            \".\" => { changed = true; }\n-            \"..\" if is_abs && comps.is_empty() => { changed = true; }\n-            \"..\" if comps.len() == n_up => { comps.push(\"..\"); n_up += 1; }\n-            \"..\" => { comps.pop_opt(); changed = true; }\n-            x => comps.push(x)\n-        }\n+    for comp in v.split_iter(f) {\n+        if comp.is_empty() { changed = true }\n+        else if comp == bytes!(\".\") { changed = true }\n+        else if comp == bytes!(\"..\") {\n+            if is_abs && comps.is_empty() { changed = true }\n+            else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n+            else { comps.pop_opt(); changed = true }\n+        } else { comps.push(comp) }\n     }\n     if changed {\n         if comps.is_empty() && !is_abs {\n-            if s == \".\" {\n+            if v == bytes!(\".\") {\n                 return None;\n             }\n-            comps.push(\".\");\n+            comps.push(dot_static);\n         }\n         Some(comps)\n     } else {\n         None\n     }\n }\n \n+static dot_static: &'static [u8] = &'static ['.' as u8];\n+static dot_dot_static: &'static [u8] = &'static ['.' as u8, '.' as u8];\n+\n /// Various POSIX helpers\n pub mod posix {\n     /// The standard path separator character"}]}