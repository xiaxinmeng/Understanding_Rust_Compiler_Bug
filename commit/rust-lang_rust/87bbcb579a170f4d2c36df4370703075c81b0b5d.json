{"sha": "87bbcb579a170f4d2c36df4370703075c81b0b5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YmJjYjU3OWExNzBmNGQyYzM2ZGY0MzcwNzAzMDc1YzgxYjBiNWQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-15T17:59:17Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:58Z"}, "message": "(cleanup) Modernize taskgroup code for the new borrow-checker.", "tree": {"sha": "229059be4eac9373f431358e3135c7651212b6cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/229059be4eac9373f431358e3135c7651212b6cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87bbcb579a170f4d2c36df4370703075c81b0b5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87bbcb579a170f4d2c36df4370703075c81b0b5d", "html_url": "https://github.com/rust-lang/rust/commit/87bbcb579a170f4d2c36df4370703075c81b0b5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87bbcb579a170f4d2c36df4370703075c81b0b5d/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bbec651dfff68c93d7213fceadecc21c324b0cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bbec651dfff68c93d7213fceadecc21c324b0cb", "html_url": "https://github.com/rust-lang/rust/commit/9bbec651dfff68c93d7213fceadecc21c324b0cb"}], "stats": {"total": 81, "additions": 20, "deletions": 61}, "files": [{"sha": "ea7be96b3a165815292c9a1fb4a4c4a76e7def40", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 20, "deletions": 61, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/87bbcb579a170f4d2c36df4370703075c81b0b5d/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87bbcb579a170f4d2c36df4370703075c81b0b5d/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=87bbcb579a170f4d2c36df4370703075c81b0b5d", "patch": "@@ -178,8 +178,8 @@ struct AncestorNode {\n     // approach the tail of the list.\n     // FIXME(#3068): Make the generation counter togglable with #[cfg(debug)].\n     generation:     uint,\n-    // Should really be a non-option. This way appeases borrowck.\n-    parent_group:   Option<TaskGroupArc>,\n+    // Handle to the tasks in the group of the current generation.\n+    parent_group:   TaskGroupArc,\n     // Recursive rest of the list.\n     ancestors:      AncestorList,\n }\n@@ -221,18 +221,13 @@ fn each_ancestor(list:        &mut AncestorList,\n                 bail_blk:        &fn(TaskGroupInner),\n                 forward_blk:     &fn(TaskGroupInner) -> bool,\n                 last_generation: uint) -> bool {\n-        // Need to swap the list out to use it, to appease borrowck.\n-        let tmp_list = util::replace(&mut *list, AncestorList(None));\n         let (coalesce_this, early_break) =\n-            iterate(&tmp_list, bail_blk, forward_blk, last_generation);\n+            iterate(list, bail_blk, forward_blk, last_generation);\n         // What should our next ancestor end up being?\n         if coalesce_this.is_some() {\n             // Needed coalesce. Our next ancestor becomes our old\n             // ancestor's next ancestor. (\"next = old_next->next;\")\n             *list = coalesce_this.unwrap();\n-        } else {\n-            // No coalesce; restore from tmp. (\"next = old_next;\")\n-            *list = tmp_list;\n         }\n         return early_break;\n     }\n@@ -245,7 +240,7 @@ fn each_ancestor(list:        &mut AncestorList,\n     // bool:\n     //     True if the supplied block did 'break', here or in any recursive\n     //     calls. If so, must call the unwinder on all previous nodes.\n-    fn iterate(ancestors:       &AncestorList,\n+    fn iterate(ancestors:       &mut AncestorList,\n                bail_blk:        &fn(TaskGroupInner),\n                forward_blk:     &fn(TaskGroupInner) -> bool,\n                last_generation: uint)\n@@ -263,7 +258,7 @@ fn each_ancestor(list:        &mut AncestorList,\n \n         // The map defaults to None, because if ancestors is None, we're at\n         // the end of the list, which doesn't make sense to coalesce.\n-        return do (**ancestors).map_default((None,false)) |ancestor_arc| {\n+        do ancestors.map_default((None,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n             do access_ancestors(ancestor_arc) |nobe| {\n                 // Argh, but we couldn't give it to coalesce() otherwise.\n@@ -276,7 +271,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                 let mut nobe_is_dead = false;\n                 let do_continue =\n                     // NB: Takes a lock! (this ancestor node's parent group)\n-                    do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n+                    do access_group(&nobe.parent_group) |tg_opt| {\n                         // Decide whether this group is dead. Note that the\n                         // group being *dead* is disjoint from it *failing*.\n                         nobe_is_dead = match *tg_opt {\n@@ -305,7 +300,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                  * Step 3: Maybe unwind; compute return info for our caller.\n                  *##########################################################*/\n                 if need_unwind && !nobe_is_dead {\n-                    do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n+                    do access_group(&nobe.parent_group) |tg_opt| {\n                         bail_blk(tg_opt)\n                     }\n                 }\n@@ -321,16 +316,6 @@ fn each_ancestor(list:        &mut AncestorList,\n                     (None, need_unwind)\n                 }\n             }\n-        };\n-\n-        // Wrapper around exclusive::with that appeases borrowck.\n-        fn with_parent_tg<U>(parent_group: &mut Option<TaskGroupArc>,\n-                             blk: &fn(TaskGroupInner) -> U) -> U {\n-            // If this trips, more likely the problem is 'blk' failed inside.\n-            let tmp_arc = parent_group.take_unwrap();\n-            let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };\n-            *parent_group = Some(tmp_arc);\n-            result\n         }\n     }\n }\n@@ -544,7 +529,7 @@ impl RuntimeGlue {\n         }\n     }\n \n-    fn with_my_taskgroup<U>(blk: &fn(&mut TCB) -> U) -> U {\n+    fn with_my_taskgroup<U>(blk: &fn(&TCB) -> U) -> U {\n         match context() {\n             OldTaskContext => unsafe {\n                 let me = rt::rust_get_task();\n@@ -561,9 +546,9 @@ impl RuntimeGlue {\n                             // Main task/group has no ancestors, no notifier, etc.\n                             let group = @@mut TCB(tasks, AncestorList(None), true, None);\n                             local_set(OldHandle(me), taskgroup_key(), group);\n-                            blk(&mut **group)\n+                            blk(&**group)\n                         }\n-                        Some(&group) => blk(&mut **group)\n+                        Some(&group) => blk(&**group)\n                     }\n                 }\n             },\n@@ -583,9 +568,9 @@ impl RuntimeGlue {\n                         }));\n                         let group = TCB(tasks, AncestorList(None), true, None);\n                         (*me).taskgroup = Some(group);\n-                        (*me).taskgroup.get_mut_ref()\n+                        (*me).taskgroup.get_ref()\n                     }\n-                    Some(ref mut group) => group,\n+                    Some(ref group) => group,\n                 })\n             },\n             SchedulerContext | GlobalContext => rtabort!(\"spawning in bad context\"),\n@@ -595,64 +580,44 @@ impl RuntimeGlue {\n \n fn gen_child_taskgroup(linked: bool, supervised: bool)\n     -> (TaskGroupArc, AncestorList, bool) {\n-    return do RuntimeGlue::with_my_taskgroup |spawner_group| {\n+    do RuntimeGlue::with_my_taskgroup |spawner_group| {\n+        let ancestors = AncestorList(spawner_group.ancestors.map(|x| x.clone()));\n         if linked {\n             // Child is in the same group as spawner.\n-            let g = spawner_group.tasks.clone();\n             // Child's ancestors are spawner's ancestors.\n-            let a = share_ancestors(&mut spawner_group.ancestors);\n             // Propagate main-ness.\n-            (g, a, spawner_group.is_main)\n+            (spawner_group.tasks.clone(), ancestors, spawner_group.is_main)\n         } else {\n             // Child is in a separate group from spawner.\n             let g = exclusive(Some(TaskGroupData {\n                 members:     new_taskset(),\n                 descendants: new_taskset(),\n             }));\n             let a = if supervised {\n-                // Child's ancestors start with the spawner.\n-                let old_ancestors =\n-                    share_ancestors(&mut spawner_group.ancestors);\n                 // FIXME(#3068) - The generation counter is only used for a\n                 // debug assertion, but initialising it requires locking a\n                 // mutex. Hence it should be enabled only in debug builds.\n                 let new_generation =\n-                    match *old_ancestors {\n+                    match *ancestors {\n                         Some(ref arc) => {\n                             access_ancestors(arc, |a| a.generation+1)\n                         }\n                         None => 0 // the actual value doesn't really matter.\n                     };\n                 assert!(new_generation < uint::max_value);\n+                // Child's ancestors start with the spawner.\n                 // Build a new node in the ancestor list.\n                 AncestorList(Some(exclusive(AncestorNode {\n                     generation: new_generation,\n-                    parent_group: Some(spawner_group.tasks.clone()),\n-                    ancestors: old_ancestors,\n+                    parent_group: spawner_group.tasks.clone(),\n+                    ancestors: ancestors,\n                 })))\n             } else {\n                 // Child has no ancestors.\n                 AncestorList(None)\n             };\n             (g, a, false)\n         }\n-    };\n-\n-    fn share_ancestors(ancestors: &mut AncestorList) -> AncestorList {\n-        // Appease the borrow-checker. Really this wants to be written as:\n-        // match ancestors\n-        //    Some(ancestor_arc) { ancestor_list(Some(ancestor_arc.clone())) }\n-        //    None               { ancestor_list(None) }\n-        let tmp = util::replace(&mut **ancestors, None);\n-        if tmp.is_some() {\n-            let ancestor_arc = tmp.unwrap();\n-            let result = ancestor_arc.clone();\n-            error!(\"cloned ancestors\");\n-            **ancestors = Some(ancestor_arc);\n-            AncestorList(Some(result))\n-        } else {\n-            AncestorList(None)\n-        }\n     }\n }\n \n@@ -754,14 +719,8 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n             };\n             assert!(!new_task.is_null());\n             // Getting killed after here would leak the task.\n-            let notify_chan = if opts.notify_chan.is_none() {\n-                None\n-            } else {\n-                Some(opts.notify_chan.take_unwrap())\n-            };\n-\n             let child_wrapper = make_child_wrapper(new_task, child_tg,\n-                  ancestors, is_main, notify_chan, f);\n+                  ancestors, is_main, opts.notify_chan.take(), f);\n \n             let closure = cast::transmute(&child_wrapper);\n "}]}