{"sha": "cb1e7d96767525fde3965f86bace8a5acf0dc643", "node_id": "C_kwDOAAsO6NoAKGNiMWU3ZDk2NzY3NTI1ZmRlMzk2NWY4NmJhY2U4YTVhY2YwZGM2NDM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-27T17:24:38Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-27T19:04:48Z"}, "message": "Only ban duplication across parameters.", "tree": {"sha": "6f51e4935239e14888abc4f78f91c13676886b6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f51e4935239e14888abc4f78f91c13676886b6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb1e7d96767525fde3965f86bace8a5acf0dc643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb1e7d96767525fde3965f86bace8a5acf0dc643", "html_url": "https://github.com/rust-lang/rust/commit/cb1e7d96767525fde3965f86bace8a5acf0dc643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb1e7d96767525fde3965f86bace8a5acf0dc643/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47704bbcc063c2a8f3e88b06cf2f54f6b64b5ae7", "url": "https://api.github.com/repos/rust-lang/rust/commits/47704bbcc063c2a8f3e88b06cf2f54f6b64b5ae7", "html_url": "https://github.com/rust-lang/rust/commit/47704bbcc063c2a8f3e88b06cf2f54f6b64b5ae7"}], "stats": {"total": 101, "additions": 70, "deletions": 31}, "files": [{"sha": "17a9553263147be8360b0f3ade0c29d28d345936", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 66, "deletions": 31, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/cb1e7d96767525fde3965f86bace8a5acf0dc643/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1e7d96767525fde3965f86bace8a5acf0dc643/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=cb1e7d96767525fde3965f86bace8a5acf0dc643", "patch": "@@ -30,6 +30,7 @@ use rustc_span::{BytePos, Span};\n use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n+use std::assert_matches::debug_assert_matches;\n use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, take};\n \n@@ -1852,12 +1853,25 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         has_self: bool,\n         inputs: impl Iterator<Item = (Option<&'ast Pat>, &'ast Ty)>,\n     ) -> Result<LifetimeRes, (Vec<MissingLifetime>, Vec<ElisionFnParameter>)> {\n-        let outer_candidates =\n-            replace(&mut self.lifetime_elision_candidates, Some(Default::default()));\n+        enum Elision {\n+            /// We have not found any candidate.\n+            None,\n+            /// We have a candidate bound to `self`.\n+            Self_(LifetimeRes),\n+            /// We have a candidate bound to a parameter.\n+            Param(LifetimeRes),\n+            /// We failed elision.\n+            Err,\n+        }\n \n-        let mut elision_lifetime = None;\n-        let mut lifetime_count = 0;\n+        // Save elision state to reinstate it later.\n+        let outer_candidates = self.lifetime_elision_candidates.take();\n+\n+        // Result of elision.\n+        let mut elision_lifetime = Elision::None;\n+        // Information for diagnostics.\n         let mut parameter_info = Vec::new();\n+        let mut all_candidates = Vec::new();\n \n         let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n         for (index, (pat, ty)) in inputs.enumerate() {\n@@ -1867,61 +1881,82 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     this.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n                 }\n             });\n+\n+            // Record elision candidates only for this parameter.\n+            debug_assert_matches!(self.lifetime_elision_candidates, None);\n+            self.lifetime_elision_candidates = Some(Default::default());\n             self.visit_ty(ty);\n+            let local_candidates = self.lifetime_elision_candidates.take();\n \n-            if let Some(ref candidates) = self.lifetime_elision_candidates {\n-                let new_count = candidates.len();\n-                let local_count = new_count - lifetime_count;\n-                if local_count != 0 {\n+            if let Some(candidates) = local_candidates {\n+                let distinct: FxHashSet<_> = candidates.iter().map(|(res, _)| *res).collect();\n+                let lifetime_count = distinct.len();\n+                if lifetime_count != 0 {\n                     parameter_info.push(ElisionFnParameter {\n                         index,\n                         ident: if let Some(pat) = pat && let PatKind::Ident(_, ident, _) = pat.kind {\n                             Some(ident)\n                         } else {\n                             None\n                         },\n-                        lifetime_count: local_count,\n+                        lifetime_count,\n                         span: ty.span,\n                     });\n+                    all_candidates.extend(candidates.into_iter().filter_map(|(_, candidate)| {\n+                        match candidate {\n+                            LifetimeElisionCandidate::Ignore | LifetimeElisionCandidate::Named => {\n+                                None\n+                            }\n+                            LifetimeElisionCandidate::Missing(missing) => Some(missing),\n+                        }\n+                    }));\n+                }\n+                let mut distinct_iter = distinct.into_iter();\n+                if let Some(res) = distinct_iter.next() {\n+                    match elision_lifetime {\n+                        // We are the first parameter to bind lifetimes.\n+                        Elision::None => {\n+                            if distinct_iter.next().is_none() {\n+                                // We have a single lifetime => success.\n+                                elision_lifetime = Elision::Param(res)\n+                            } else {\n+                                // We have have multiple lifetimes => error.\n+                                elision_lifetime = Elision::Err;\n+                            }\n+                        }\n+                        // We have 2 parameters that bind lifetimes => error.\n+                        Elision::Param(_) => elision_lifetime = Elision::Err,\n+                        // `self` elision takes precedence over everything else.\n+                        Elision::Self_(_) | Elision::Err => {}\n+                    }\n                 }\n-                lifetime_count = new_count;\n             }\n \n             // Handle `self` specially.\n             if index == 0 && has_self {\n                 let self_lifetime = self.find_lifetime_for_self(ty);\n                 if let Set1::One(lifetime) = self_lifetime {\n-                    elision_lifetime = Some(lifetime);\n-                    self.lifetime_elision_candidates = None;\n+                    // We found `self` elision.\n+                    elision_lifetime = Elision::Self_(lifetime);\n                 } else {\n-                    self.lifetime_elision_candidates = Some(Default::default());\n-                    lifetime_count = 0;\n+                    // We do not have `self` elision: disregard the `Elision::Param` that we may\n+                    // have found.\n+                    elision_lifetime = Elision::None;\n                 }\n             }\n             debug!(\"(resolving function / closure) recorded parameter\");\n         }\n \n-        let all_candidates = replace(&mut self.lifetime_elision_candidates, outer_candidates);\n-        debug!(?all_candidates);\n+        // Reinstate elision state.\n+        debug_assert_matches!(self.lifetime_elision_candidates, None);\n+        self.lifetime_elision_candidates = outer_candidates;\n \n-        if let Some(res) = elision_lifetime {\n+        if let Elision::Param(res) | Elision::Self_(res) = elision_lifetime {\n             return Ok(res);\n         }\n \n-        // We do not have a `self` candidate, look at the full list.\n-        let all_candidates = all_candidates.unwrap();\n-        if let [(res, _)] = &all_candidates[..] {\n-            Ok(*res)\n-        } else {\n-            let all_candidates = all_candidates\n-                .into_iter()\n-                .filter_map(|(_, candidate)| match candidate {\n-                    LifetimeElisionCandidate::Ignore | LifetimeElisionCandidate::Named => None,\n-                    LifetimeElisionCandidate::Missing(missing) => Some(missing),\n-                })\n-                .collect();\n-            Err((all_candidates, parameter_info))\n-        }\n+        // We do not have a candidate.\n+        Err((all_candidates, parameter_info))\n     }\n \n     /// List all the lifetimes that appear in the provided type."}, {"sha": "a0f05878283e6cf68324a08a24f4600bc1c72bbc", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb1e7d96767525fde3965f86bace8a5acf0dc643/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1e7d96767525fde3965f86bace8a5acf0dc643/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=cb1e7d96767525fde3965f86bace8a5acf0dc643", "patch": "@@ -7,6 +7,7 @@\n //! Type-relative name resolution (methods, fields, associated items) happens in `rustc_hir_analysis`.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(if_let_guard)]"}, {"sha": "d0a8fe795efd03549df1ec44ac889d45a8a0d506", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb1e7d96767525fde3965f86bace8a5acf0dc643/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1e7d96767525fde3965f86bace8a5acf0dc643/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=cb1e7d96767525fde3965f86bace8a5acf0dc643", "patch": "@@ -45,4 +45,7 @@ fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &isize {\n fn l<'a>(_: &'a str, _: &'a str) -> &str { \"\" }\n //~^ ERROR missing lifetime specifier\n \n+// This is ok because both `'a` are for the same parameter.\n+fn m<'a>(_: &'a Foo<'a>) -> &str { \"\" }\n+\n fn main() {}"}]}