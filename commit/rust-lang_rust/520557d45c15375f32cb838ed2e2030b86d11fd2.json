{"sha": "520557d45c15375f32cb838ed2e2030b86d11fd2", "node_id": "C_kwDOAAsO6NoAKDUyMDU1N2Q0NWMxNTM3NWYzMmNiODM4ZWQyZTIwMzBiODZkMTFmZDI", "commit": {"author": {"name": "Ethiraric", "email": "ethiraric@gmail.com", "date": "2022-03-13T20:56:34Z"}, "committer": {"name": "Ethiraric", "email": "ethiraric@gmail.com", "date": "2022-04-03T12:34:08Z"}, "message": "feat: assist to remove unneeded `async`s", "tree": {"sha": "f36401858fec1952088a37042bc4baa4a5e3a395", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f36401858fec1952088a37042bc4baa4a5e3a395"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/520557d45c15375f32cb838ed2e2030b86d11fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/520557d45c15375f32cb838ed2e2030b86d11fd2", "html_url": "https://github.com/rust-lang/rust/commit/520557d45c15375f32cb838ed2e2030b86d11fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/520557d45c15375f32cb838ed2e2030b86d11fd2/comments", "author": {"login": "Ethiraric", "id": 3604786, "node_id": "MDQ6VXNlcjM2MDQ3ODY=", "avatar_url": "https://avatars.githubusercontent.com/u/3604786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ethiraric", "html_url": "https://github.com/Ethiraric", "followers_url": "https://api.github.com/users/Ethiraric/followers", "following_url": "https://api.github.com/users/Ethiraric/following{/other_user}", "gists_url": "https://api.github.com/users/Ethiraric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ethiraric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ethiraric/subscriptions", "organizations_url": "https://api.github.com/users/Ethiraric/orgs", "repos_url": "https://api.github.com/users/Ethiraric/repos", "events_url": "https://api.github.com/users/Ethiraric/events{/privacy}", "received_events_url": "https://api.github.com/users/Ethiraric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ethiraric", "id": 3604786, "node_id": "MDQ6VXNlcjM2MDQ3ODY=", "avatar_url": "https://avatars.githubusercontent.com/u/3604786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ethiraric", "html_url": "https://github.com/Ethiraric", "followers_url": "https://api.github.com/users/Ethiraric/followers", "following_url": "https://api.github.com/users/Ethiraric/following{/other_user}", "gists_url": "https://api.github.com/users/Ethiraric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ethiraric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ethiraric/subscriptions", "organizations_url": "https://api.github.com/users/Ethiraric/orgs", "repos_url": "https://api.github.com/users/Ethiraric/repos", "events_url": "https://api.github.com/users/Ethiraric/events{/privacy}", "received_events_url": "https://api.github.com/users/Ethiraric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8a21e4c70bba61d63472c730f7e0b16324b5806", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a21e4c70bba61d63472c730f7e0b16324b5806", "html_url": "https://github.com/rust-lang/rust/commit/f8a21e4c70bba61d63472c730f7e0b16324b5806"}], "stats": {"total": 274, "additions": 274, "deletions": 0}, "files": [{"sha": "d90fee7809e8ac69814b0c0b18fc0c1018104b1a", "filename": "crates/ide_assists/src/handlers/unnecessary_async.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/520557d45c15375f32cb838ed2e2030b86d11fd2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520557d45c15375f32cb838ed2e2030b86d11fd2/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs?ref=520557d45c15375f32cb838ed2e2030b86d11fd2", "patch": "@@ -0,0 +1,257 @@\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    base_db::FileId,\n+    defs::Definition,\n+    search::FileReference,\n+    syntax_helpers::node_ext::full_path_of_name_ref,\n+};\n+use syntax::{\n+    ast::{self, NameLike, NameRef},\n+    AstNode, SyntaxKind, TextRange,\n+};\n+\n+use crate::{AssistContext, Assists};\n+\n+// Assist: unnecessary_async\n+//\n+// Removes the `async` mark from functions which have no `.await` in their body.\n+// Looks for calls to the functions and removes the `.await` on the call site.\n+//\n+// ```\n+// pub async f$0n foo() {}\n+// pub async fn bar() { foo().await }\n+// ```\n+// ->\n+// ```\n+// pub fn foo() {}\n+// pub async fn bar() { foo() }\n+// ```\n+pub(crate) fn unnecessary_async(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let function: ast::Fn = ctx.find_node_at_offset()?;\n+\n+    // Do nothing if the cursor is not on the prototype. This is so that the check does not pollute\n+    // when the user asks us for assists when in the middle of the function body.\n+    // We consider the prototype to be anything that is before the body of the function.\n+    let cursor_position = ctx.offset();\n+    if cursor_position >= function.body()?.syntax().text_range().start() {\n+        return None;\n+    }\n+    // Do nothing if the function isn't async.\n+    if let None = function.async_token() {\n+        return None;\n+    }\n+    // Do nothing if the function has an `await` expression in its body.\n+    if function.body()?.syntax().descendants().find_map(ast::AwaitExpr::cast).is_some() {\n+        return None;\n+    }\n+\n+    // Remove the `async` keyword plus whitespace after it, if any.\n+    let async_range = {\n+        let async_token = function.async_token()?;\n+        let next_token = async_token.next_token()?;\n+        if matches!(next_token.kind(), SyntaxKind::WHITESPACE) {\n+            TextRange::new(async_token.text_range().start(), next_token.text_range().end())\n+        } else {\n+            async_token.text_range()\n+        }\n+    };\n+\n+    // Otherwise, we may remove the `async` keyword.\n+    acc.add(\n+        AssistId(\"unnecessary_async\", AssistKind::QuickFix),\n+        \"Remove unnecessary async\",\n+        async_range,\n+        |edit| {\n+            // Remove async on the function definition.\n+            edit.replace(async_range, \"\");\n+\n+            // Remove all `.await`s from calls to the function we remove `async` from.\n+            if let Some(fn_def) = ctx.sema.to_def(&function) {\n+                for await_expr in find_all_references(ctx, &Definition::Function(fn_def))\n+                    // Keep only references that correspond NameRefs.\n+                    .filter_map(|(_, reference)| match reference.name {\n+                        NameLike::NameRef(nameref) => Some(nameref),\n+                        _ => None,\n+                    })\n+                    // Keep only references that correspond to await expressions\n+                    .filter_map(|nameref| find_await_expression(ctx, &nameref))\n+                {\n+                    if let Some(await_token) = &await_expr.await_token() {\n+                        edit.replace(await_token.text_range(), \"\");\n+                    }\n+                    if let Some(dot_token) = &await_expr.dot_token() {\n+                        edit.replace(dot_token.text_range(), \"\");\n+                    }\n+                }\n+            }\n+        },\n+    )\n+}\n+\n+fn find_all_references(\n+    ctx: &AssistContext,\n+    def: &Definition,\n+) -> impl Iterator<Item = (FileId, FileReference)> {\n+    def.usages(&ctx.sema).all().into_iter().flat_map(|(file_id, references)| {\n+        references.into_iter().map(move |reference| (file_id, reference))\n+    })\n+}\n+\n+/// Finds the await expression for the given `NameRef`.\n+/// If no await expression is found, returns None.\n+fn find_await_expression(ctx: &AssistContext, nameref: &NameRef) -> Option<ast::AwaitExpr> {\n+    // From the nameref, walk up the tree to the await expression.\n+    let await_expr = if let Some(path) = full_path_of_name_ref(&nameref) {\n+        // Function calls.\n+        path.syntax()\n+            .parent()\n+            .and_then(ast::PathExpr::cast)?\n+            .syntax()\n+            .parent()\n+            .and_then(ast::CallExpr::cast)?\n+            .syntax()\n+            .parent()\n+            .and_then(ast::AwaitExpr::cast)\n+    } else {\n+        // Method calls.\n+        nameref\n+            .syntax()\n+            .parent()\n+            .and_then(ast::MethodCallExpr::cast)?\n+            .syntax()\n+            .parent()\n+            .and_then(ast::AwaitExpr::cast)\n+    };\n+\n+    ctx.sema.original_ast_node(await_expr?)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn applies_on_empty_function() {\n+        check_assist(unnecessary_async, \"pub async f$0n f() {}\", \"pub fn f() {}\")\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_whitespace() {\n+        check_assist(unnecessary_async, \"pub async       f$0n f() {}\", \"pub fn f() {}\")\n+    }\n+\n+    #[test]\n+    fn does_not_apply_on_non_async_function() {\n+        check_assist_not_applicable(unnecessary_async, \"pub f$0n f() {}\")\n+    }\n+\n+    #[test]\n+    fn applies_on_function_with_a_non_await_expr() {\n+        check_assist(unnecessary_async, \"pub async f$0n f() { f2() }\", \"pub fn f() { f2() }\")\n+    }\n+\n+    #[test]\n+    fn does_not_apply_on_function_with_an_await_expr() {\n+        check_assist_not_applicable(unnecessary_async, \"pub async f$0n f() { f2().await }\")\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_await_on_reference() {\n+        check_assist(\n+            unnecessary_async,\n+            r#\"\n+pub async fn f4() { }\n+pub async f$0n f2() { }\n+pub async fn f() { f2().await }\n+pub async fn f3() { f2().await }\"#,\n+            r#\"\n+pub async fn f4() { }\n+pub fn f2() { }\n+pub async fn f() { f2() }\n+pub async fn f3() { f2() }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_await_from_within_module() {\n+        check_assist(\n+            unnecessary_async,\n+            r#\"\n+pub async fn f4() { }\n+mod a { pub async f$0n f2() { } }\n+pub async fn f() { a::f2().await }\n+pub async fn f3() { a::f2().await }\"#,\n+            r#\"\n+pub async fn f4() { }\n+mod a { pub fn f2() { } }\n+pub async fn f() { a::f2() }\n+pub async fn f3() { a::f2() }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_await_on_inner_await() {\n+        check_assist(\n+            unnecessary_async,\n+            // Ensure that it is the first await on the 3rd line that is removed\n+            r#\"\n+pub async fn f() { f2().await }\n+pub async f$0n f2() -> i32 { 1 }\n+pub async fn f3() { f4(f2().await).await }\n+pub async fn f4(i: i32) { }\"#,\n+            r#\"\n+pub async fn f() { f2() }\n+pub fn f2() -> i32 { 1 }\n+pub async fn f3() { f4(f2()).await }\n+pub async fn f4(i: i32) { }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_await_on_outer_await() {\n+        check_assist(\n+            unnecessary_async,\n+            // Ensure that it is the second await on the 3rd line that is removed\n+            r#\"\n+pub async fn f() { f2().await }\n+pub async f$0n f2(i: i32) { }\n+pub async fn f3() { f2(f4().await).await }\n+pub async fn f4() -> i32 { 1 }\"#,\n+            r#\"\n+pub async fn f() { f2() }\n+pub fn f2(i: i32) { }\n+pub async fn f3() { f2(f4().await) }\n+pub async fn f4() -> i32 { 1 }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn applies_on_method_call() {\n+        check_assist(\n+            unnecessary_async,\n+            r#\"\n+pub struct S { }\n+impl S { pub async f$0n f2(&self) { } }\n+pub async fn f(s: &S) { s.f2().await }\"#,\n+            r#\"\n+pub struct S { }\n+impl S { pub fn f2(&self) { } }\n+pub async fn f(s: &S) { s.f2() }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn does_not_apply_on_function_with_a_nested_await_expr() {\n+        check_assist_not_applicable(\n+            unnecessary_async,\n+            \"async f$0n f() { if true { loop { f2().await } } }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn does_not_apply_when_not_on_prototype() {\n+        check_assist_not_applicable(unnecessary_async, \"pub async fn f() { $0f2() }\")\n+    }\n+}"}, {"sha": "ef4aa1c62bdf7594bd5d84bc34991fb4a9cedc86", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/520557d45c15375f32cb838ed2e2030b86d11fd2/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520557d45c15375f32cb838ed2e2030b86d11fd2/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=520557d45c15375f32cb838ed2e2030b86d11fd2", "patch": "@@ -183,6 +183,7 @@ mod handlers {\n     mod sort_items;\n     mod toggle_ignore;\n     mod unmerge_use;\n+    mod unnecessary_async;\n     mod unwrap_block;\n     mod unwrap_result_return_type;\n     mod wrap_return_type_in_result;\n@@ -268,6 +269,7 @@ mod handlers {\n             split_import::split_import,\n             toggle_ignore::toggle_ignore,\n             unmerge_use::unmerge_use,\n+            unnecessary_async::unnecessary_async,\n             unwrap_block::unwrap_block,\n             unwrap_result_return_type::unwrap_result_return_type,\n             wrap_return_type_in_result::wrap_return_type_in_result,"}, {"sha": "8a1e95d8947be3ed0e26ff35a787a38be3d15038", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/520557d45c15375f32cb838ed2e2030b86d11fd2/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520557d45c15375f32cb838ed2e2030b86d11fd2/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=520557d45c15375f32cb838ed2e2030b86d11fd2", "patch": "@@ -2106,6 +2106,21 @@ use std::fmt::Display;\n     )\n }\n \n+#[test]\n+fn doctest_unnecessary_async() {\n+    check_doc_test(\n+        \"unnecessary_async\",\n+        r#####\"\n+pub async f$0n foo() {}\n+pub async fn bar() { foo().await }\n+\"#####,\n+        r#####\"\n+pub fn foo() {}\n+pub async fn bar() { foo() }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_unwrap_block() {\n     check_doc_test("}]}