{"sha": "eb19cd65756cd285c81410e627752a75a41e3f0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMTljZDY1NzU2Y2QyODVjODE0MTBlNjI3NzUyYTc1YTQxZTNmMGU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-11T20:47:28Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-09-16T12:08:32Z"}, "message": "groundwork refactoring of `gather_moves`", "tree": {"sha": "03353acf24ab761d9228426180779fd2691db9a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03353acf24ab761d9228426180779fd2691db9a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb19cd65756cd285c81410e627752a75a41e3f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb19cd65756cd285c81410e627752a75a41e3f0e", "html_url": "https://github.com/rust-lang/rust/commit/eb19cd65756cd285c81410e627752a75a41e3f0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb19cd65756cd285c81410e627752a75a41e3f0e/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "89500e934134d19b09e51a1f45430ded65e291b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/89500e934134d19b09e51a1f45430ded65e291b4", "html_url": "https://github.com/rust-lang/rust/commit/89500e934134d19b09e51a1f45430ded65e291b4"}], "stats": {"total": 1188, "additions": 480, "deletions": 708}, "files": [{"sha": "53b6ccdbd530a065880a27efbdab77418184f66e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=eb19cd65756cd285c81410e627752a75a41e3f0e", "patch": "@@ -1243,7 +1243,7 @@ impl<'a, 'b>  GraphSuccessors<'b> for Mir<'a> {\n     type Iter = IntoIter<BasicBlock>;\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, Ord, PartialOrd)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub struct Location {\n     /// the location is within this block\n     pub block: BasicBlock,\n@@ -1253,3 +1253,8 @@ pub struct Location {\n     pub statement_index: usize,\n }\n \n+impl fmt::Debug for Location {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}[{}]\", self.block, self.statement_index)\n+    }\n+}"}, {"sha": "16e0b376f4b53f48697bcd0fb17f1ac4cdea3cef", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=eb19cd65756cd285c81410e627752a75a41e3f0e", "patch": "@@ -774,9 +774,6 @@ pub enum LvalueContext<'tcx> {\n     // Being borrowed\n     Borrow { region: &'tcx Region, kind: BorrowKind },\n \n-    // Being sliced -- this should be same as being borrowed, probably\n-    Slice { from_start: usize, from_end: usize },\n-\n     // Used as base for another lvalue, e.g. `x` in `x.y`\n     Projection,\n "}, {"sha": "8ac59c60396f6f260e0b9b2e3e028b9907d48d85", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=eb19cd65756cd285c81410e627752a75a41e3f0e", "patch": "@@ -17,7 +17,7 @@ use super::super::MoveDataParamEnv;\n use super::super::DropFlagState;\n use super::super::drop_flag_effects_for_function_entry;\n use super::super::drop_flag_effects_for_location;\n-use super::super::on_all_children_bits;\n+use super::super::on_lookup_result_bits;\n \n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n@@ -277,10 +277,9 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n-        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n-                             move_path_index,\n-                             |mpi| { in_out.add(&mpi); });\n+        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n+                              ctxt.move_data.rev_lookup.find(dest_lval),\n+                              |mpi| { in_out.add(&mpi); });\n     }\n }\n \n@@ -338,11 +337,10 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n-        // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n-        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n-                             move_path_index,\n-                             |mpi| { in_out.remove(&mpi); });\n+        // the bits for that dest_lval to 0 (initialized).\n+        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n+                              ctxt.move_data.rev_lookup.find(dest_lval),\n+                              |mpi| { in_out.remove(&mpi); });\n     }\n }\n \n@@ -400,10 +398,9 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.move_data.rev_lookup.find(dest_lval);\n-        on_all_children_bits(self.tcx, self.mir, &ctxt.move_data,\n-                             move_path_index,\n-                             |mpi| { in_out.add(&mpi); });\n+        on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n+                              ctxt.move_data.rev_lookup.find(dest_lval),\n+                              |mpi| { in_out.add(&mpi); });\n     }\n }\n \n@@ -448,11 +445,10 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                 // assigning into this `lvalue` kills all\n                 // MoveOuts from it, and *also* all MoveOuts\n                 // for children and associated fragment sets.\n-                let move_path_index = rev_lookup.find(lvalue);\n-                on_all_children_bits(tcx,\n+                on_lookup_result_bits(tcx,\n                                      mir,\n                                      move_data,\n-                                     move_path_index,\n+                                     rev_lookup.find(lvalue),\n                                      |mpi| for moi in &path_map[mpi] {\n                                          assert!(moi.index() < bits_per_block);\n                                          sets.kill_set.add(&moi);\n@@ -489,18 +485,17 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n         let move_data = &ctxt.move_data;\n-        let move_path_index = move_data.rev_lookup.find(dest_lval);\n         let bits_per_block = self.bits_per_block(ctxt);\n \n         let path_map = &move_data.path_map;\n-        on_all_children_bits(self.tcx,\n-                             self.mir,\n-                             move_data,\n-                             move_path_index,\n-                             |mpi| for moi in &path_map[mpi] {\n-                                 assert!(moi.index() < bits_per_block);\n-                                 in_out.remove(&moi);\n-                             });\n+        on_lookup_result_bits(self.tcx,\n+                              self.mir,\n+                              move_data,\n+                              move_data.rev_lookup.find(dest_lval),\n+                              |mpi| for moi in &path_map[mpi] {\n+                                  assert!(moi.index() < bits_per_block);\n+                                  in_out.remove(&moi);\n+                              });\n     }\n }\n "}, {"sha": "88f6d5fef562db18d4b11baa8b8ee9dbfd63a9b9", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=eb19cd65756cd285c81410e627752a75a41e3f0e", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::repr::{self, Mir};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::super::gather_moves::{MovePathIndex};\n+use super::super::gather_moves::{MovePathIndex, LookupResult};\n use super::super::MoveDataParamEnv;\n use super::BitDenotation;\n use super::DataflowResults;\n@@ -116,20 +116,26 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      repr::BorrowKind::Shared,\n                                      ref peeking_at_lval) = *rvalue {\n                 // Okay, our search is over.\n-                let peek_mpi = move_data.rev_lookup.find(peeking_at_lval);\n-                let bit_state = sets.on_entry.contains(&peek_mpi);\n-                debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n-                       lvalue, peeking_at_lval, bit_state);\n-                if !bit_state {\n-                    tcx.sess.span_err(span, &format!(\"rustc_peek: bit not set\"));\n+                match move_data.rev_lookup.find(peeking_at_lval) {\n+                    LookupResult::Exact(peek_mpi) => {\n+                        let bit_state = sets.on_entry.contains(&peek_mpi);\n+                        debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n+                               lvalue, peeking_at_lval, bit_state);\n+                        if !bit_state {\n+                            tcx.sess.span_err(span, \"rustc_peek: bit not set\");\n+                        }\n+                    }\n+                    LookupResult::Parent(..) => {\n+                        tcx.sess.span_err(span, \"rustc_peek: argument untracked\");\n+                    }\n                 }\n                 return;\n             } else {\n                 // Our search should have been over, but the input\n                 // does not match expectations of `rustc_peek` for\n                 // this sanity_check.\n-                let msg = &format!(\"rustc_peek: argument expression \\\n-                                    must be immediate borrow of form `&expr`\");\n+                let msg = \"rustc_peek: argument expression \\\n+                           must be immediate borrow of form `&expr`\";\n                 tcx.sess.span_err(span, msg);\n             }\n         }"}, {"sha": "96702b209a1f5d0b271b8a5e0c7e6f2b5b6e9e1b", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 79, "deletions": 82, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=eb19cd65756cd285c81410e627752a75a41e3f0e", "patch": "@@ -9,10 +9,11 @@\n // except according to those terms.\n \n use indexed_set::IdxSetBuf;\n-use super::gather_moves::{MoveData, MovePathIndex, MovePathContent};\n+use super::gather_moves::{MoveData, MovePathIndex, LookupResult};\n use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use super::dataflow::{DataflowResults};\n use super::{drop_flag_effects_for_location, on_all_children_bits};\n+use super::on_lookup_result_bits;\n use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -42,7 +43,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n         }\n         let id = src.item_id();\n         let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-        let move_data = MoveData::gather_moves(mir, tcx);\n+        let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n         let elaborate_patch = {\n             let mir = &*mir;\n             let env = MoveDataParamEnv {\n@@ -184,31 +185,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn path_needs_drop(&self, path: MovePathIndex) -> bool\n     {\n-        match self.move_data().move_paths[path].content {\n-            MovePathContent::Lvalue(ref lvalue) => {\n-                let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                debug!(\"path_needs_drop({:?}, {:?} : {:?})\", path, lvalue, ty);\n+        let lvalue = &self.move_data().move_paths[path].lvalue;\n+        let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        debug!(\"path_needs_drop({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n-                self.tcx.type_needs_drop_given_env(ty, self.param_env())\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    /// Returns whether this lvalue is tracked by drop elaboration. This\n-    /// includes all lvalues, except these (1.) behind references or arrays,\n-    ///  or (2.) behind ADT's with a Drop impl.\n-    fn lvalue_is_tracked(&self, lv: &Lvalue<'tcx>) -> bool\n-    {\n-        // `lvalue_contents_drop_state_cannot_differ` only compares\n-        // the `lv` to its immediate contents, while this recursively\n-        // follows parent chain formed by `base` of each projection.\n-        if let &Lvalue::Projection(ref data) = lv {\n-            !super::lvalue_contents_drop_state_cannot_differ(self.tcx, self.mir, &data.base) &&\n-                self.lvalue_is_tracked(&data.base)\n-        } else {\n-            true\n-        }\n+        self.tcx.type_needs_drop_given_env(ty, self.param_env())\n     }\n \n     fn collect_drop_flags(&mut self)\n@@ -221,19 +202,29 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 _ => continue\n             };\n \n-            if !self.lvalue_is_tracked(location) {\n-                continue\n-            }\n-\n             let init_data = self.initialization_data_at(Location {\n                 block: bb,\n                 statement_index: data.statements.len()\n             });\n \n             let path = self.move_data().rev_lookup.find(location);\n-            debug!(\"collect_drop_flags: {:?}, lv {:?} (index {:?})\",\n+            debug!(\"collect_drop_flags: {:?}, lv {:?} ({:?})\",\n                    bb, location, path);\n \n+            let path = match path {\n+                LookupResult::Exact(e) => e,\n+                LookupResult::Parent(None) => continue,\n+                LookupResult::Parent(Some(parent)) => {\n+                    let (_maybe_live, maybe_dead) = init_data.state(parent);\n+                    if maybe_dead {\n+                        span_bug!(terminator.source_info.span,\n+                                  \"drop of untracked, uninitialized value {:?}, lv {:?} ({:?})\",\n+                                  bb, location, path);\n+                    }\n+                    continue\n+                }\n+            };\n+\n             on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n                 if self.path_needs_drop(child) {\n                     let (maybe_live, maybe_dead) = init_data.state(child);\n@@ -257,20 +248,27 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             match terminator.kind {\n                 TerminatorKind::Drop { ref location, target, unwind } => {\n                     let init_data = self.initialization_data_at(loc);\n-                    let path = self.move_data().rev_lookup.find(location);\n-                    self.elaborate_drop(&DropCtxt {\n-                        source_info: terminator.source_info,\n-                        is_cleanup: data.is_cleanup,\n-                        init_data: &init_data,\n-                        lvalue: location,\n-                        path: path,\n-                        succ: target,\n-                        unwind: if data.is_cleanup {\n-                            None\n-                        } else {\n-                            Some(Option::unwrap_or(unwind, resume_block))\n+                    match self.move_data().rev_lookup.find(location) {\n+                        LookupResult::Exact(path) => {\n+                            self.elaborate_drop(&DropCtxt {\n+                                source_info: terminator.source_info,\n+                                is_cleanup: data.is_cleanup,\n+                                init_data: &init_data,\n+                                lvalue: location,\n+                                path: path,\n+                                succ: target,\n+                                unwind: if data.is_cleanup {\n+                                    None\n+                                } else {\n+                                    Some(Option::unwrap_or(unwind, resume_block))\n+                                }\n+                            }, bb);\n                         }\n-                    }, bb);\n+                        LookupResult::Parent(..) => {\n+                            span_bug!(terminator.source_info.span,\n+                                      \"drop of untracked value {:?}\", bb);\n+                        }\n+                    }\n                 }\n                 TerminatorKind::DropAndReplace { ref location, ref value,\n                                                  target, unwind } =>\n@@ -336,35 +334,37 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             is_cleanup: data.is_cleanup,\n         });\n \n-        if !self.lvalue_is_tracked(location) {\n-            // drop and replace behind a pointer/array/whatever. The location\n-            // must be initialized.\n-            debug!(\"elaborate_drop_and_replace({:?}) - untracked\", terminator);\n-            self.patch.patch_terminator(bb, TerminatorKind::Drop {\n-                location: location.clone(),\n-                target: target,\n-                unwind: Some(unwind)\n-            });\n-        } else {\n-            debug!(\"elaborate_drop_and_replace({:?}) - tracked\", terminator);\n-            let init_data = self.initialization_data_at(loc);\n-            let path = self.move_data().rev_lookup.find(location);\n-\n-            self.elaborate_drop(&DropCtxt {\n-                source_info: terminator.source_info,\n-                is_cleanup: data.is_cleanup,\n-                init_data: &init_data,\n-                lvalue: location,\n-                path: path,\n-                succ: target,\n-                unwind: Some(unwind)\n-            }, bb);\n-            on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n-                self.set_drop_flag(Location { block: target, statement_index: 0 },\n-                                   child, DropFlagState::Present);\n-                self.set_drop_flag(Location { block: unwind, statement_index: 0 },\n-                                   child, DropFlagState::Present);\n-            });\n+        match self.move_data().rev_lookup.find(location) {\n+            LookupResult::Exact(path) => {\n+                debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n+                let init_data = self.initialization_data_at(loc);\n+\n+                self.elaborate_drop(&DropCtxt {\n+                    source_info: terminator.source_info,\n+                    is_cleanup: data.is_cleanup,\n+                    init_data: &init_data,\n+                    lvalue: location,\n+                    path: path,\n+                    succ: target,\n+                    unwind: Some(unwind)\n+                }, bb);\n+                on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n+                    self.set_drop_flag(Location { block: target, statement_index: 0 },\n+                                       child, DropFlagState::Present);\n+                    self.set_drop_flag(Location { block: unwind, statement_index: 0 },\n+                                       child, DropFlagState::Present);\n+                });\n+            }\n+            LookupResult::Parent(parent) => {\n+                // drop and replace behind a pointer/array/whatever. The location\n+                // must be initialized.\n+                debug!(\"elaborate_drop_and_replace({:?}) - untracked {:?}\", terminator, parent);\n+                self.patch.patch_terminator(bb, TerminatorKind::Drop {\n+                    location: location.clone(),\n+                    target: target,\n+                    unwind: Some(unwind)\n+                });\n+            }\n         }\n     }\n \n@@ -446,10 +446,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                              substs: &'tcx Substs<'tcx>)\n                              -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n     {\n-        let move_paths = &self.move_data().move_paths;\n         variant.fields.iter().enumerate().map(|(i, f)| {\n             let subpath =\n-                super::move_path_children_matching(move_paths, variant_path, |p| {\n+                super::move_path_children_matching(self.move_data(), variant_path, |p| {\n                     match p {\n                         &Projection {\n                             elem: ProjectionElem::Field(idx, _), ..\n@@ -580,7 +579,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let fields = tys.iter().enumerate().map(|(i, &ty)| {\n             (c.lvalue.clone().field(Field::new(i), ty),\n              super::move_path_children_matching(\n-                 &self.move_data().move_paths, c.path, |proj| match proj {\n+                 self.move_data(), c.path, |proj| match proj {\n                      &Projection {\n                          elem: ProjectionElem::Field(f, _), ..\n                      } => f.index() == i,\n@@ -598,7 +597,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         debug!(\"open_drop_for_box({:?}, {:?})\", c, ty);\n \n         let interior_path = super::move_path_children_matching(\n-            &self.move_data().move_paths, c.path, |proj| match proj {\n+            self.move_data(), c.path, |proj| match proj {\n                 &Projection { elem: ProjectionElem::Deref, .. } => true,\n                 _ => false\n             }).unwrap();\n@@ -625,10 +624,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                                  variant_index: usize)\n                                  -> BasicBlock\n     {\n-        let move_paths = &self.move_data().move_paths;\n-\n         let subpath = super::move_path_children_matching(\n-            move_paths, c.path, |proj| match proj {\n+            self.move_data(), c.path, |proj| match proj {\n                 &Projection {\n                     elem: ProjectionElem::Downcast(_, idx), ..\n                 } => idx == variant_index,\n@@ -942,7 +939,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n                 let loc = Location { block: tgt, statement_index: 0 };\n                 let path = self.move_data().rev_lookup.find(lv);\n-                on_all_children_bits(\n+                on_lookup_result_bits(\n                     self.tcx, self.mir, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n                 );\n@@ -1011,7 +1008,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n                 let loc = Location { block: bb, statement_index: data.statements.len() };\n                 let path = self.move_data().rev_lookup.find(lv);\n-                on_all_children_bits(\n+                on_lookup_result_bits(\n                     self.tcx, self.mir, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n                 );"}, {"sha": "2713a3c371db9cf5c7f4bb14db9095690cc6c4c7", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 318, "deletions": 557, "changes": 875, "blob_url": "https://github.com/rust-lang/rust/blob/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=eb19cd65756cd285c81410e627752a75a41e3f0e", "patch": "@@ -9,16 +9,18 @@\n // except according to those terms.\n \n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc::util::common::ErrorReported;\n+use rustc_data_structures::indexed_vec::{IndexVec};\n+\n+use syntax::codemap::DUMMY_SP;\n \n-use std::cell::{Cell};\n use std::collections::hash_map::Entry;\n use std::fmt;\n-use std::iter;\n-use std::ops::Index;\n+use std::mem;\n+use std::ops::{Index, IndexMut};\n \n use super::abs_domain::{AbstractElem, Lift};\n \n@@ -28,17 +30,15 @@ use super::abs_domain::{AbstractElem, Lift};\n // ensure that other code does not accidentally access `index.0`\n // (which is likely to yield a subtle off-by-one error).\n mod indexes {\n+    use std::fmt;\n     use core::nonzero::NonZero;\n     use rustc_data_structures::indexed_vec::Idx;\n \n     macro_rules! new_index {\n-        ($Index:ident) => {\n-            #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+        ($Index:ident, $debug_name:expr) => {\n+            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n             pub struct $Index(NonZero<usize>);\n \n-            impl $Index {\n-            }\n-\n             impl Idx for $Index {\n                 fn new(idx: usize) -> Self {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n@@ -47,22 +47,28 @@ mod indexes {\n                     *self.0 - 1\n                 }\n             }\n+\n+            impl fmt::Debug for $Index {\n+                fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                    write!(fmt, \"{}{}\", $debug_name, self.index())\n+                }\n+            }\n         }\n     }\n \n     /// Index into MovePathData.move_paths\n-    new_index!(MovePathIndex);\n+    new_index!(MovePathIndex, \"mp\");\n \n     /// Index into MoveData.moves.\n-    new_index!(MoveOutIndex);\n+    new_index!(MoveOutIndex, \"mo\");\n }\n \n pub use self::indexes::MovePathIndex;\n pub use self::indexes::MoveOutIndex;\n \n impl self::indexes::MoveOutIndex {\n     pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n-        move_data.moves[self.index()].path\n+        move_data.moves[*self].path\n     }\n }\n \n@@ -83,40 +89,7 @@ pub struct MovePath<'tcx> {\n     pub next_sibling: Option<MovePathIndex>,\n     pub first_child: Option<MovePathIndex>,\n     pub parent: Option<MovePathIndex>,\n-    pub content: MovePathContent<'tcx>,\n-}\n-\n-/// MovePaths usually represent a single l-value. The exceptions are\n-/// forms that arise due to erroneous input code: static data holds\n-/// l-values that we cannot actually move out of. Therefore we map\n-/// statics to a special marker value (`MovePathContent::Static`)\n-/// representing an invalid origin.\n-#[derive(Clone, Debug)]\n-pub enum MovePathContent<'tcx> {\n-    Lvalue(Lvalue<'tcx>),\n-    Static,\n-}\n-\n-/// During construction of the MovePath's, we use PreMovePath to\n-/// represent accumulated state while we are gathering up all the\n-/// children of each path.\n-#[derive(Clone)]\n-struct PreMovePath<'tcx> {\n-    pub next_sibling: Option<MovePathIndex>,\n-    pub first_child: Cell<Option<MovePathIndex>>,\n-    pub parent: Option<MovePathIndex>,\n-    pub content: MovePathContent<'tcx>,\n-}\n-\n-impl<'tcx> PreMovePath<'tcx> {\n-    fn into_move_path(self) -> MovePath<'tcx> {\n-        MovePath {\n-            next_sibling: self.next_sibling,\n-            parent: self.parent,\n-            content: self.content,\n-            first_child: self.first_child.get(),\n-        }\n-    }\n+    pub lvalue: Lvalue<'tcx>,\n }\n \n impl<'tcx> fmt::Debug for MovePath<'tcx> {\n@@ -131,52 +104,50 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n         if let Some(next_sibling) = self.next_sibling {\n             write!(w, \" next_sibling: {:?}\", next_sibling)?;\n         }\n-        write!(w, \" content: {:?} }}\", self.content)\n+        write!(w, \" lvalue: {:?} }}\", self.lvalue)\n     }\n }\n \n #[derive(Debug)]\n pub struct MoveData<'tcx> {\n-    pub move_paths: MovePathData<'tcx>,\n-    pub moves: Vec<MoveOut>,\n-    pub loc_map: LocMap,\n-    pub path_map: PathMap,\n+    pub move_paths: IndexVec<MovePathIndex, MovePath<'tcx>>,\n+    pub moves: IndexVec<MoveOutIndex, MoveOut>,\n+    /// Each Location `l` is mapped to the MoveOut's that are effects\n+    /// of executing the code at `l`. (There can be multiple MoveOut's\n+    /// for a given `l` because each MoveOut is associated with one\n+    /// particular path being moved.)\n+    pub loc_map: LocationMap<Vec<MoveOutIndex>>,\n+    pub path_map: IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n     pub rev_lookup: MovePathLookup<'tcx>,\n }\n \n #[derive(Debug)]\n-pub struct LocMap {\n+pub struct LocationMap<T> {\n     /// Location-indexed (BasicBlock for outer index, index within BB\n-    /// for inner index) map to list of MoveOutIndex's.\n-    ///\n-    /// Each Location `l` is mapped to the MoveOut's that are effects\n-    /// of executing the code at `l`. (There can be multiple MoveOut's\n-    /// for a given `l` because each MoveOut is associated with one\n-    /// particular path being moved.)\n-    map: Vec<Vec<Vec<MoveOutIndex>>>,\n+    /// for inner index) map.\n+    map: IndexVec<BasicBlock, Vec<T>>,\n }\n \n-impl Index<Location> for LocMap {\n-    type Output = [MoveOutIndex];\n+impl<T> Index<Location> for LocationMap<T> {\n+    type Output = T;\n     fn index(&self, index: Location) -> &Self::Output {\n-        assert!(index.block.index() < self.map.len());\n-        assert!(index.statement_index < self.map[index.block.index()].len());\n-        &self.map[index.block.index()][index.statement_index]\n+        &self.map[index.block][index.statement_index]\n     }\n }\n \n-#[derive(Debug)]\n-pub struct PathMap {\n-    /// Path-indexed map to list of MoveOutIndex's.\n-    ///\n-    /// Each Path `p` is mapped to the MoveOut's that move out of `p`.\n-    map: Vec<Vec<MoveOutIndex>>,\n+impl<T> IndexMut<Location> for LocationMap<T> {\n+    fn index_mut(&mut self, index: Location) -> &mut Self::Output {\n+        &mut self.map[index.block][index.statement_index]\n+    }\n }\n \n-impl Index<MovePathIndex> for PathMap {\n-    type Output = [MoveOutIndex];\n-    fn index(&self, index: MovePathIndex) -> &Self::Output {\n-        &self.map[index.index()]\n+impl<T> LocationMap<T> where T: Default + Clone {\n+    fn new(mir: &Mir) -> Self {\n+        LocationMap {\n+            map: mir.basic_blocks().iter().map(|block| {\n+                vec![T::default(); block.statements.len()+1]\n+            }).collect()\n+        }\n     }\n }\n \n@@ -196,583 +167,373 @@ pub struct MoveOut {\n \n impl fmt::Debug for MoveOut {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"p{}@{:?}\", self.path.index(), self.source)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct MovePathData<'tcx> {\n-    move_paths: Vec<MovePath<'tcx>>,\n-}\n-\n-impl<'tcx> MovePathData<'tcx> {\n-    pub fn len(&self) -> usize { self.move_paths.len() }\n-}\n-\n-impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n-    type Output = MovePath<'tcx>;\n-    fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n-        &self.move_paths[i.index()]\n+        write!(fmt, \"{:?}@{:?}\", self.path, self.source)\n     }\n }\n \n-struct MovePathDataBuilder<'tcx> {\n-    pre_move_paths: Vec<PreMovePath<'tcx>>,\n-    rev_lookup: MovePathLookup<'tcx>,\n-}\n-\n /// Tables mapping from an l-value to its MovePathIndex.\n #[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n-    vars: IndexVec<Var, Option<MovePathIndex>>,\n-    temps: IndexVec<Temp, Option<MovePathIndex>>,\n-    args: IndexVec<Arg, Option<MovePathIndex>>,\n+    vars: IndexVec<Var, MovePathIndex>,\n+    temps: IndexVec<Temp, MovePathIndex>,\n+    args: IndexVec<Arg, MovePathIndex>,\n \n     /// The move path representing the return value is constructed\n     /// lazily when we first encounter it in the input MIR.\n     return_ptr: Option<MovePathIndex>,\n \n-    /// A single move path (representing any static data referenced)\n-    /// is constructed lazily when we first encounter statics in the\n-    /// input MIR.\n-    statics: Option<MovePathIndex>,\n-\n     /// projections are made from a base-lvalue and a projection\n     /// elem. The base-lvalue will have a unique MovePathIndex; we use\n     /// the latter as the index into the outer vector (narrowing\n     /// subsequent search so that it is solely relative to that\n     /// base-lvalue). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: Vec<FnvHashMap<AbstractElem<'tcx>, MovePathIndex>>,\n-\n-    /// Tracks the next index to allocate during construction of the\n-    /// MovePathData. Unused after MovePathData is fully constructed.\n-    next_index: MovePathIndex,\n+    projections: FnvHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n \n-trait FillTo {\n-    type T;\n-    fn fill_to_with(&mut self, idx: usize, x: Self::T);\n-    fn fill_to(&mut self, idx: usize) where Self::T: Default {\n-        self.fill_to_with(idx, Default::default())\n-    }\n+struct MoveDataBuilder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: &'a ParameterEnvironment<'tcx>,\n+    data: MoveData<'tcx>,\n }\n-impl<T:Clone> FillTo for Vec<T> {\n-    type T = T;\n-    fn fill_to_with(&mut self, idx: usize, x: T) {\n-        if idx >= self.len() {\n-            let delta = idx + 1 - self.len();\n-            assert_eq!(idx + 1, self.len() + delta);\n-            self.extend(iter::repeat(x).take(delta))\n+\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>,\n+           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           param_env: &'a ParameterEnvironment<'tcx>)\n+           -> Self {\n+        let mut move_paths = IndexVec::new();\n+        let mut path_map = IndexVec::new();\n+\n+        MoveDataBuilder {\n+            mir: mir,\n+            tcx: tcx,\n+            param_env: param_env,\n+            data: MoveData {\n+                moves: IndexVec::new(),\n+                loc_map: LocationMap::new(mir),\n+                rev_lookup: MovePathLookup {\n+                    vars: mir.var_decls.indices().map(Lvalue::Var).map(|v| {\n+                        Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n+                    }).collect(),\n+                    temps: mir.temp_decls.indices().map(Lvalue::Temp).map(|t| {\n+                        Self::new_move_path(&mut move_paths, &mut path_map, None, t)\n+                    }).collect(),\n+                    args: mir.arg_decls.indices().map(Lvalue::Arg).map(|a| {\n+                        Self::new_move_path(&mut move_paths, &mut path_map, None, a)\n+                    }).collect(),\n+                    return_ptr: None,\n+                    projections: FnvHashMap(),\n+                },\n+                move_paths: move_paths,\n+                path_map: path_map,\n+            }\n         }\n-        debug_assert!(idx < self.len());\n     }\n-}\n \n-#[derive(Clone, Debug)]\n-enum LookupKind { Generate, Reuse }\n-#[derive(Clone, Debug)]\n-struct Lookup<T>(LookupKind, T);\n-\n-impl Lookup<MovePathIndex> {\n-    fn index(&self) -> usize { (self.1).index() }\n-}\n-\n-impl<'tcx> MovePathLookup<'tcx> {\n-    fn new(mir: &Mir) -> Self {\n-        MovePathLookup {\n-            vars: IndexVec::from_elem(None, &mir.var_decls),\n-            temps: IndexVec::from_elem(None, &mir.temp_decls),\n-            args: IndexVec::from_elem(None, &mir.arg_decls),\n-            statics: None,\n-            return_ptr: None,\n-            projections: vec![],\n-            next_index: MovePathIndex::new(0),\n+    fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n+                     path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n+                     parent: Option<MovePathIndex>,\n+                     lvalue: Lvalue<'tcx>)\n+                     -> MovePathIndex\n+    {\n+        let move_path = move_paths.push(MovePath {\n+            next_sibling: None,\n+            first_child: None,\n+            parent: parent,\n+            lvalue: lvalue\n+        });\n+\n+        if let Some(parent) = parent {\n+            let next_sibling =\n+                mem::replace(&mut move_paths[parent].first_child, Some(move_path));\n+            move_paths[move_path].next_sibling = next_sibling;\n         }\n-    }\n \n-    fn next_index(next: &mut MovePathIndex) -> MovePathIndex {\n-        let i = *next;\n-        *next = MovePathIndex::new(i.index() + 1);\n-        i\n+        let path_map_ent = path_map.push(vec![]);\n+        assert_eq!(path_map_ent, move_path);\n+        move_path\n     }\n \n-    fn lookup_or_generate<I: Idx>(vec: &mut IndexVec<I, Option<MovePathIndex>>,\n-                                  idx: I,\n-                                  next_index: &mut MovePathIndex)\n-                                  -> Lookup<MovePathIndex> {\n-        let entry = &mut vec[idx];\n-        match *entry {\n-            None => {\n-                let i = Self::next_index(next_index);\n-                *entry = Some(i);\n-                Lookup(LookupKind::Generate, i)\n-            }\n-            Some(entry_idx) => {\n-                Lookup(LookupKind::Reuse, entry_idx)\n+    /// This creates a MovePath for a given lvalue, returning an `ErrorReported`\n+    /// if that lvalue can't be moved from.\n+    ///\n+    /// NOTE: lvalues behind references *do not* get a move path, which is\n+    /// problematic for borrowck.\n+    ///\n+    /// Maybe we should have seperate \"borrowck\" and \"moveck\" modes.\n+    fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n+                     -> Result<MovePathIndex, ErrorReported>\n+    {\n+        debug!(\"lookup({:?})\", lval);\n+        match *lval {\n+            Lvalue::Var(var) => Ok(self.data.rev_lookup.vars[var]),\n+            Lvalue::Arg(arg) => Ok(self.data.rev_lookup.args[arg]),\n+            Lvalue::Temp(temp) => Ok(self.data.rev_lookup.temps[temp]),\n+            // error: can't move out of a static\n+            Lvalue::Static(..) => Err(ErrorReported),\n+            Lvalue::ReturnPointer => match self.data.rev_lookup.return_ptr {\n+                Some(ptr) => Ok(ptr),\n+                ref mut ptr @ None => {\n+                    let path = Self::new_move_path(\n+                        &mut self.data.move_paths,\n+                        &mut self.data.path_map,\n+                        None,\n+                        lval.clone());\n+                    *ptr = Some(path);\n+                    Ok(path)\n+                }\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                self.move_path_for_projection(lval, proj)\n             }\n         }\n     }\n \n-    fn lookup_var(&mut self, var_idx: Var) -> Lookup<MovePathIndex> {\n-        Self::lookup_or_generate(&mut self.vars,\n-                                 var_idx,\n-                                 &mut self.next_index)\n-    }\n-\n-    fn lookup_temp(&mut self, temp_idx: Temp) -> Lookup<MovePathIndex> {\n-        Self::lookup_or_generate(&mut self.temps,\n-                                 temp_idx,\n-                                 &mut self.next_index)\n-    }\n-\n-    fn lookup_arg(&mut self, arg_idx: Arg) -> Lookup<MovePathIndex> {\n-        Self::lookup_or_generate(&mut self.args,\n-                                 arg_idx,\n-                                 &mut self.next_index)\n+    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n+        // This is an assignment, not a move, so this not being a valid\n+        // move path is OK.\n+        let _ = self.move_path_for(lval);\n     }\n \n-    fn lookup_static(&mut self) -> Lookup<MovePathIndex> {\n-        match self.statics {\n-            Some(mpi) => {\n-                Lookup(LookupKind::Reuse, mpi)\n-            }\n-            ref mut ret @ None => {\n-                let mpi = Self::next_index(&mut self.next_index);\n-                *ret = Some(mpi);\n-                Lookup(LookupKind::Generate, mpi)\n+    fn move_path_for_projection(&mut self,\n+                                lval: &Lvalue<'tcx>,\n+                                proj: &LvalueProjection<'tcx>)\n+                                -> Result<MovePathIndex, ErrorReported>\n+    {\n+        let base = try!(self.move_path_for(&proj.base));\n+        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        match lv_ty.sty {\n+            // error: can't move out of borrowed content\n+            ty::TyRef(..) | ty::TyRawPtr(..) => return Err(ErrorReported),\n+            // error: can't move out of struct with destructor\n+            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) if adt.has_dtor() =>\n+                return Err(ErrorReported),\n+\n+            ty::TyArray(..) | ty::TySlice(..) => match proj.elem {\n+                // error: can't move out of an array\n+                ProjectionElem::Index(..) => return Err(ErrorReported),\n+                _ => {}\n+            },\n+            _ => {}\n+        };\n+        match self.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n+            Entry::Occupied(ent) => Ok(*ent.get()),\n+            Entry::Vacant(ent) => {\n+                let path = Self::new_move_path(\n+                    &mut self.data.move_paths,\n+                    &mut self.data.path_map,\n+                    Some(base),\n+                    lval.clone()\n+                );\n+                ent.insert(path);\n+                Ok(path)\n             }\n         }\n     }\n \n-    fn lookup_return_pointer(&mut self) -> Lookup<MovePathIndex> {\n-        match self.return_ptr {\n-            Some(mpi) => {\n-                Lookup(LookupKind::Reuse, mpi)\n+    fn finalize(self) -> MoveData<'tcx> {\n+        debug!(\"{}\", {\n+            debug!(\"moves for {:?}:\", self.mir.span);\n+            for (j, mo) in self.data.moves.iter_enumerated() {\n+                debug!(\"    {:?} = {:?}\", j, mo);\n             }\n-            ref mut ret @ None => {\n-                let mpi = Self::next_index(&mut self.next_index);\n-                *ret = Some(mpi);\n-                Lookup(LookupKind::Generate, mpi)\n+            debug!(\"move paths for {:?}:\", self.mir.span);\n+            for (j, path) in self.data.move_paths.iter_enumerated() {\n+                debug!(\"    {:?} = {:?}\", j, path);\n             }\n-        }\n+            \"done dumping moves\"\n+        });\n+        self.data\n     }\n+}\n \n-    fn lookup_proj(&mut self,\n-                   proj: &LvalueProjection<'tcx>,\n-                   base: MovePathIndex) -> Lookup<MovePathIndex> {\n-        let MovePathLookup { ref mut projections,\n-                             ref mut next_index, .. } = *self;\n-        projections.fill_to(base.index());\n-        match projections[base.index()].entry(proj.elem.lift()) {\n-            Entry::Occupied(ent) => {\n-                Lookup(LookupKind::Reuse, *ent.get())\n-            }\n-            Entry::Vacant(ent) => {\n-                let mpi = Self::next_index(next_index);\n-                ent.insert(mpi);\n-                Lookup(LookupKind::Generate, mpi)\n-            }\n-        }\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub enum LookupResult {\n+    Exact(MovePathIndex),\n+    Parent(Option<MovePathIndex>)\n }\n \n impl<'tcx> MovePathLookup<'tcx> {\n     // Unlike the builder `fn move_path_for` below, this lookup\n     // alternative will *not* create a MovePath on the fly for an\n-    // unknown l-value; it will simply panic.\n-    pub fn find(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+    // unknown l-value, but will rather return the nearest available\n+    // parent.\n+    pub fn find(&self, lval: &Lvalue<'tcx>) -> LookupResult {\n         match *lval {\n-            Lvalue::Var(var) => self.vars[var].unwrap(),\n-            Lvalue::Temp(temp) => self.temps[temp].unwrap(),\n-            Lvalue::Arg(arg) => self.args[arg].unwrap(),\n-            Lvalue::Static(ref _def_id) => self.statics.unwrap(),\n-            Lvalue::ReturnPointer => self.return_ptr.unwrap(),\n+            Lvalue::Var(var) => LookupResult::Exact(self.vars[var]),\n+            Lvalue::Temp(temp) => LookupResult::Exact(self.temps[temp]),\n+            Lvalue::Arg(arg) => LookupResult::Exact(self.args[arg]),\n+            Lvalue::Static(..) => LookupResult::Parent(None),\n+            Lvalue::ReturnPointer => LookupResult::Exact(self.return_ptr.unwrap()),\n             Lvalue::Projection(ref proj) => {\n-                let base_index = self.find(&proj.base);\n-                self.projections[base_index.index()][&proj.elem.lift()]\n+                match self.find(&proj.base) {\n+                    LookupResult::Exact(base_path) => {\n+                        match self.projections.get(&(base_path, proj.elem.lift())) {\n+                            Some(&subpath) => LookupResult::Exact(subpath),\n+                            None => LookupResult::Parent(Some(base_path))\n+                        }\n+                    }\n+                    inexact => inexact\n+                }\n             }\n         }\n     }\n }\n \n-impl<'tcx> MovePathDataBuilder<'tcx> {\n-    fn lookup(&mut self, lval: &Lvalue<'tcx>) -> Lookup<MovePathIndex> {\n-        let proj = match *lval {\n-            Lvalue::Var(var_idx) =>\n-                return self.rev_lookup.lookup_var(var_idx),\n-            Lvalue::Temp(temp_idx) =>\n-                return self.rev_lookup.lookup_temp(temp_idx),\n-            Lvalue::Arg(arg_idx) =>\n-                return self.rev_lookup.lookup_arg(arg_idx),\n-            Lvalue::Static(_def_id) =>\n-                return self.rev_lookup.lookup_static(),\n-            Lvalue::ReturnPointer =>\n-                return self.rev_lookup.lookup_return_pointer(),\n-            Lvalue::Projection(ref proj) => {\n-                proj\n-            }\n-        };\n-\n-        let base_index = self.move_path_for(&proj.base);\n-        self.rev_lookup.lookup_proj(proj, base_index)\n-    }\n-\n-    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n-        // Create MovePath for `lval`, discarding returned index.\n-        self.move_path_for(lval);\n+impl<'a, 'tcx> MoveData<'tcx> {\n+    pub fn gather_moves(mir: &Mir<'tcx>,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        param_env: &ParameterEnvironment<'tcx>)\n+                        -> Self {\n+        gather_moves(mir, tcx, param_env)\n     }\n+}\n \n-    fn move_path_for(&mut self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n-        debug!(\"move_path_for({:?})\", lval);\n-\n-        let lookup: Lookup<MovePathIndex> = self.lookup(lval);\n-\n-        // `lookup` is either the previously assigned index or a\n-        // newly-allocated one.\n-        debug_assert!(lookup.index() <= self.pre_move_paths.len());\n-\n-        if let Lookup(LookupKind::Generate, mpi) = lookup {\n-            let parent;\n-            let sibling;\n-            // tracks whether content is Some non-static; statics map to None.\n-            let content: Option<&Lvalue<'tcx>>;\n-\n-            match *lval {\n-                Lvalue::Static(_) => {\n-                    content = None;\n-                    sibling = None;\n-                    parent = None;\n-                }\n-\n-                Lvalue::Var(_) | Lvalue::Temp(_) | Lvalue::Arg(_) |\n-                Lvalue::ReturnPointer => {\n-                    content = Some(lval);\n-                    sibling = None;\n-                    parent = None;\n-                }\n-                Lvalue::Projection(ref proj) => {\n-                    content = Some(lval);\n-\n-                    // Here, install new MovePath as new first_child.\n-\n-                    // Note: `parent` previously allocated (Projection\n-                    // case of match above established this).\n-                    let idx = self.move_path_for(&proj.base);\n-                    parent = Some(idx);\n-\n-                    let parent_move_path = &mut self.pre_move_paths[idx.index()];\n-\n-                    // At last: Swap in the new first_child.\n-                    sibling = parent_move_path.first_child.get();\n-                    parent_move_path.first_child.set(Some(mpi));\n-                }\n-            };\n-\n-            let content = match content {\n-                Some(lval) => MovePathContent::Lvalue(lval.clone()),\n-                None => MovePathContent::Static,\n-            };\n-\n-            let move_path = PreMovePath {\n-                next_sibling: sibling,\n-                parent: parent,\n-                content: content,\n-                first_child: Cell::new(None),\n-            };\n+fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          param_env: &ParameterEnvironment<'tcx>)\n+                          -> MoveData<'tcx> {\n+    let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n \n-            self.pre_move_paths.push(move_path);\n+    for (bb, block) in mir.basic_blocks().iter_enumerated() {\n+        for (i, stmt) in block.statements.iter().enumerate() {\n+            let source = Location { block: bb, statement_index: i };\n+            builder.gather_statement(source, stmt);\n         }\n \n-        return lookup.1;\n+        let terminator_loc = Location {\n+            block: bb,\n+            statement_index: block.statements.len()\n+        };\n+        builder.gather_terminator(terminator_loc, block.terminator());\n     }\n-}\n \n-impl<'a, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        gather_moves(mir, tcx)\n-    }\n+    builder.finalize()\n }\n \n-#[derive(Debug)]\n-enum StmtKind {\n-    Use, Repeat, Cast, BinaryOp, UnaryOp, Box,\n-    Aggregate, Drop, CallFn, CallArg, Return, If,\n-}\n-\n-fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveData<'tcx> {\n-    use self::StmtKind as SK;\n-\n-    let bb_count = mir.basic_blocks().len();\n-    let mut moves = vec![];\n-    let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bb_count).collect();\n-    let mut path_map = Vec::new();\n-\n-    // this is mutable only because we will move it to and fro' the\n-    // BlockContexts constructed on each iteration. (Moving is more\n-    // straight-forward than mutable borrows in this instance.)\n-    let mut builder = MovePathDataBuilder {\n-        pre_move_paths: Vec::new(),\n-        rev_lookup: MovePathLookup::new(mir),\n-    };\n-\n-    // Before we analyze the program text, we create the MovePath's\n-    // for all of the vars, args, and temps. (This enforces a basic\n-    // property that even if the MIR body doesn't contain any\n-    // references to a var/arg/temp, it will still be a valid\n-    // operation to lookup the MovePath associated with it.)\n-    assert!(mir.var_decls.len() <= ::std::u32::MAX as usize);\n-    assert!(mir.arg_decls.len() <= ::std::u32::MAX as usize);\n-    assert!(mir.temp_decls.len() <= ::std::u32::MAX as usize);\n-    for var in mir.var_decls.indices() {\n-        let path_idx = builder.move_path_for(&Lvalue::Var(var));\n-        path_map.fill_to(path_idx.index());\n-    }\n-    for arg in mir.arg_decls.indices() {\n-        let path_idx = builder.move_path_for(&Lvalue::Arg(arg));\n-        path_map.fill_to(path_idx.index());\n-    }\n-    for temp in mir.temp_decls.indices() {\n-        let path_idx = builder.move_path_for(&Lvalue::Temp(temp));\n-        path_map.fill_to(path_idx.index());\n+impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+    fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n+        debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n+        match stmt.kind {\n+            StatementKind::Assign(ref lval, ref rval) => {\n+                self.create_move_path(lval);\n+                self.gather_rvalue(loc, rval);\n+            }\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) => {}\n+            StatementKind::SetDiscriminant{ .. } => {\n+                span_bug!(stmt.source_info.span,\n+                          \"SetDiscriminant should not exist during borrowck\");\n+            }\n+        }\n     }\n \n-    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-        let loc_map_bb = &mut loc_map[bb.index()];\n-\n-        debug_assert!(loc_map_bb.len() == 0);\n-        let len = bb_data.statements.len();\n-        loc_map_bb.fill_to(len);\n-        debug_assert!(loc_map_bb.len() == len + 1);\n-\n-        let mut bb_ctxt = BlockContext {\n-            _tcx: tcx,\n-            moves: &mut moves,\n-            builder: builder,\n-            path_map: &mut path_map,\n-            loc_map_bb: loc_map_bb,\n-        };\n-\n-        for (i, stmt) in bb_data.statements.iter().enumerate() {\n-            let source = Location { block: bb, statement_index: i };\n-            match stmt.kind {\n-                StatementKind::Assign(ref lval, ref rval) => {\n-                    bb_ctxt.builder.create_move_path(lval);\n-\n-                    // Ensure that the path_map contains entries even\n-                    // if the lvalue is assigned and never read.\n-                    let assigned_path = bb_ctxt.builder.move_path_for(lval);\n-                    bb_ctxt.path_map.fill_to(assigned_path.index());\n-\n-                    match *rval {\n-                        Rvalue::Use(ref operand) => {\n-                            bb_ctxt.on_operand(SK::Use, operand, source)\n-                        }\n-                        Rvalue::Repeat(ref operand, ref _const) =>\n-                            bb_ctxt.on_operand(SK::Repeat, operand, source),\n-                        Rvalue::Cast(ref _kind, ref operand, ref _ty) =>\n-                            bb_ctxt.on_operand(SK::Cast, operand, source),\n-                        Rvalue::BinaryOp(ref _binop, ref operand1, ref operand2) |\n-                        Rvalue::CheckedBinaryOp(ref _binop, ref operand1, ref operand2) => {\n-                            bb_ctxt.on_operand(SK::BinaryOp, operand1, source);\n-                            bb_ctxt.on_operand(SK::BinaryOp, operand2, source);\n-                        }\n-                        Rvalue::UnaryOp(ref _unop, ref operand) => {\n-                            bb_ctxt.on_operand(SK::UnaryOp, operand, source);\n-                        }\n-                        Rvalue::Box(ref _ty) => {\n-                            // this is creating uninitialized\n-                            // memory that needs to be initialized.\n-                            let deref_lval = Lvalue::Projection(Box::new(Projection {\n-                                base: lval.clone(),\n-                                elem: ProjectionElem::Deref,\n-                            }));\n-                            bb_ctxt.on_move_out_lval(SK::Box, &deref_lval, source);\n-                        }\n-                        Rvalue::Aggregate(ref _kind, ref operands) => {\n-                            for operand in operands {\n-                                bb_ctxt.on_operand(SK::Aggregate, operand, source);\n-                            }\n-                        }\n-                        Rvalue::Ref(..) |\n-                        Rvalue::Len(..) |\n-                        Rvalue::InlineAsm { .. } => {}\n-                    }\n-                }\n-                StatementKind::StorageLive(_) |\n-                StatementKind::StorageDead(_) => {}\n-                StatementKind::SetDiscriminant{ .. } => {\n-                    span_bug!(stmt.source_info.span,\n-                              \"SetDiscriminant should not exist during borrowck\");\n+    fn gather_rvalue(&mut self, loc: Location, rvalue: &Rvalue<'tcx>) {\n+        match *rvalue {\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::Cast(_, ref operand, _) |\n+            Rvalue::UnaryOp(_, ref operand) => {\n+                self.gather_operand(loc, operand)\n+            }\n+            Rvalue::BinaryOp(ref _binop, ref lhs, ref rhs) |\n+            Rvalue::CheckedBinaryOp(ref _binop, ref lhs, ref rhs) => {\n+                self.gather_operand(loc, lhs);\n+                self.gather_operand(loc, rhs);\n+            }\n+            Rvalue::Aggregate(ref _kind, ref operands) => {\n+                for operand in operands {\n+                    self.gather_operand(loc, operand);\n                 }\n             }\n+            Rvalue::Ref(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::InlineAsm { .. } => {}\n+            Rvalue::Box(..) => {\n+                // This returns an rvalue with uninitialized contents. We can't\n+                // move out of it here because it is an rvalue - assignments always\n+                // completely initialize their lvalue.\n+                //\n+                // However, this does not matter - MIR building is careful to\n+                // only emit a shallow free for the partially-initialized\n+                // temporary.\n+                //\n+                // In any case, if we want to fix this, we have to register a\n+                // special move and change the `statement_effect` functions.\n+            }\n         }\n+    }\n \n-        debug!(\"gather_moves({:?})\", bb_data.terminator());\n-        match bb_data.terminator().kind {\n+    fn gather_terminator(&mut self, loc: Location, term: &Terminator<'tcx>) {\n+        debug!(\"gather_terminator({:?}, {:?})\", loc, term);\n+        match term.kind {\n             TerminatorKind::Goto { target: _ } |\n             TerminatorKind::Resume |\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n-                bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n-            }\n-\n-            TerminatorKind::If { ref cond, targets: _ } => {\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                bb_ctxt.on_operand(SK::If, cond, source);\n-            }\n-\n-            TerminatorKind::Assert {\n-                ref cond, expected: _,\n-                ref msg, target: _, cleanup: _\n-            } => {\n-                // The `cond` is always of (copyable) type `bool`,\n-                // so there will never be anything to move.\n-                let _ = cond;\n-                match *msg {\n-                    AssertMessage:: BoundsCheck { ref len, ref index } => {\n-                        // Same for the usize length and index in bounds-checking.\n-                        let _ = (len, index);\n-                    }\n-                    AssertMessage::Math(_) => {}\n-                }\n+                self.gather_move(loc, &Lvalue::ReturnPointer);\n             }\n \n-            TerminatorKind::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n-            TerminatorKind::Switch { adt_def: _, targets: _, ref discr } => {\n-                // The `discr` is not consumed; that is instead\n-                // encoded on specific match arms (and for\n-                // SwitchInt`, it is always a copyable integer\n-                // type anyway).\n-                let _ = discr;\n+            TerminatorKind::If { .. } |\n+            TerminatorKind::Assert { .. } |\n+            TerminatorKind::SwitchInt { .. } |\n+            TerminatorKind::Switch { .. } => {\n+                // branching terminators - these don't move anything\n             }\n \n             TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                bb_ctxt.on_move_out_lval(SK::Drop, location, source);\n+                self.gather_move(loc, location);\n             }\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n-                let assigned_path = bb_ctxt.builder.move_path_for(location);\n-                bb_ctxt.path_map.fill_to(assigned_path.index());\n-\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                bb_ctxt.on_operand(SK::Use, value, source);\n+                self.create_move_path(location);\n+                self.gather_operand(loc, value);\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n-                let source = Location { block: bb,\n-                                        statement_index: bb_data.statements.len() };\n-                bb_ctxt.on_operand(SK::CallFn, func, source);\n+                self.gather_operand(loc, func);\n                 for arg in args {\n-                    debug!(\"gather_moves Call on_operand {:?} {:?}\", arg, source);\n-                    bb_ctxt.on_operand(SK::CallArg, arg, source);\n+                    self.gather_operand(loc, arg);\n                 }\n                 if let Some((ref destination, _bb)) = *destination {\n-                    debug!(\"gather_moves Call create_move_path {:?} {:?}\", destination, source);\n-\n-                    // Ensure that the path_map contains entries even\n-                    // if the lvalue is assigned and never read.\n-                    let assigned_path = bb_ctxt.builder.move_path_for(destination);\n-                    bb_ctxt.path_map.fill_to(assigned_path.index());\n-\n-                    bb_ctxt.builder.create_move_path(destination);\n+                    self.create_move_path(destination);\n                 }\n             }\n         }\n-\n-        builder = bb_ctxt.builder;\n     }\n \n-    // At this point, we may have created some MovePaths that do not\n-    // have corresponding entries in the path map.\n-    //\n-    // (For example, creating the path `a.b.c` may, as a side-effect,\n-    // create a path for the parent path `a.b`.)\n-    //\n-    // All such paths were not referenced ...\n-    //\n-    // well you know, lets actually try just asserting that the path map *is* complete.\n-    assert_eq!(path_map.len(), builder.pre_move_paths.len());\n-\n-    let pre_move_paths = builder.pre_move_paths;\n-    let move_paths: Vec<_> = pre_move_paths.into_iter()\n-        .map(|p| p.into_move_path())\n-        .collect();\n-\n-    debug!(\"{}\", {\n-        let mut seen: Vec<_> = move_paths.iter().map(|_| false).collect();\n-        for (j, &MoveOut { ref path, ref source }) in moves.iter().enumerate() {\n-            debug!(\"MovePathData moves[{}]: MoveOut {{ path: {:?} = {:?}, source: {:?} }}\",\n-                   j, path, move_paths[path.index()], source);\n-            seen[path.index()] = true;\n-        }\n-        for (j, path) in move_paths.iter().enumerate() {\n-            if !seen[j] {\n-                debug!(\"MovePathData move_paths[{}]: {:?}\", j, path);\n+    fn gather_operand(&mut self, loc: Location, operand: &Operand<'tcx>) {\n+        match *operand {\n+            Operand::Constant(..) => {} // not-a-move\n+            Operand::Consume(ref lval) => { // a move\n+                self.gather_move(loc, lval);\n             }\n         }\n-        \"done dumping MovePathData\"\n-    });\n-\n-    MoveData {\n-        move_paths: MovePathData { move_paths: move_paths, },\n-        moves: moves,\n-        loc_map: LocMap { map: loc_map },\n-        path_map: PathMap { map: path_map },\n-        rev_lookup: builder.rev_lookup,\n     }\n-}\n \n-struct BlockContext<'b, 'tcx: 'b> {\n-    _tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-    moves: &'b mut Vec<MoveOut>,\n-    builder: MovePathDataBuilder<'tcx>,\n-    path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n-    loc_map_bb: &'b mut Vec<Vec<MoveOutIndex>>,\n-}\n+    fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n+        debug!(\"gather_move({:?}, {:?})\", loc, lval);\n \n-impl<'b, 'tcx: 'b> BlockContext<'b, 'tcx> {\n-    fn on_move_out_lval(&mut self,\n-                        stmt_kind: StmtKind,\n-                        lval: &Lvalue<'tcx>,\n-                        source: Location) {\n-        let i = source.statement_index;\n-        let index = MoveOutIndex::new(self.moves.len());\n-\n-        let path = self.builder.move_path_for(lval);\n-        self.moves.push(MoveOut { path: path, source: source.clone() });\n-        self.path_map.fill_to(path.index());\n-\n-        debug!(\"ctxt: {:?} add consume of lval: {:?} \\\n-                at index: {:?} \\\n-                to path_map for path: {:?} and \\\n-                to loc_map for loc: {:?}\",\n-               stmt_kind, lval, index, path, source);\n-\n-        debug_assert!(path.index() < self.path_map.len());\n-        // this is actually a questionable assert; at the very\n-        // least, incorrect input code can probably cause it to\n-        // fire.\n-        assert!(self.path_map[path.index()].iter().find(|idx| **idx == index).is_none());\n-        self.path_map[path.index()].push(index);\n-\n-        debug_assert!(i < self.loc_map_bb.len());\n-        debug_assert!(self.loc_map_bb[i].iter().find(|idx| **idx == index).is_none());\n-        self.loc_map_bb[i].push(index);\n-    }\n-\n-    fn on_operand(&mut self, stmt_kind: StmtKind, operand: &Operand<'tcx>, source: Location) {\n-        match *operand {\n-            Operand::Constant(..) => {} // not-a-move\n-            Operand::Consume(ref lval) => { // a move\n-                self.on_move_out_lval(stmt_kind, lval, source);\n-            }\n+        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n+            debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n+            return\n         }\n+\n+        let path = self.move_path_for(lval).unwrap_or_else(|_| {\n+            // Moving out of a bad path. Eventually, this should be a MIR\n+            // borrowck error instead of a bug.\n+            span_bug!(self.mir.span,\n+                      \"Broken MIR: moving out of lvalue {:?}: {:?} at {:?}\",\n+                      lval, lv_ty, loc);\n+        });\n+        let move_out = self.data.moves.push(MoveOut { path: path, source: loc });\n+\n+        debug!(\"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n+               loc, lval, move_out, path);\n+\n+        self.data.path_map[path].push(move_out);\n+        self.data.loc_map[loc].push(move_out);\n     }\n }"}, {"sha": "7c2410a2c145f844efb00edf4a6ec753e2fddbd7", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=eb19cd65756cd285c81410e627752a75a41e3f0e", "patch": "@@ -34,8 +34,7 @@ use self::dataflow::{DataflowOperator};\n use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use self::dataflow::{DefinitelyInitializedLvals};\n-use self::gather_moves::{MoveData, MovePathIndex};\n-use self::gather_moves::{MovePathContent, MovePathData};\n+use self::gather_moves::{MoveData, MovePathIndex, LookupResult};\n \n fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n     for attr in attrs {\n@@ -78,8 +77,8 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n \n     let tcx = bcx.tcx;\n \n-    let move_data = MoveData::gather_moves(mir, tcx);\n     let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+    let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let flow_inits =\n         do_dataflow(tcx, mir, id, attributes, &mdpe, MaybeInitializedLvals::new(tcx, mir));\n@@ -211,23 +210,23 @@ impl DropFlagState {\n     }\n }\n \n-fn move_path_children_matching<'tcx, F>(move_paths: &MovePathData<'tcx>,\n+fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)\n                                         -> Option<MovePathIndex>\n     where F: FnMut(&repr::LvalueProjection<'tcx>) -> bool\n {\n-    let mut next_child = move_paths[path].first_child;\n+    let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n-        match move_paths[child_index].content {\n-            MovePathContent::Lvalue(repr::Lvalue::Projection(ref proj)) => {\n+        match move_data.move_paths[child_index].lvalue {\n+            repr::Lvalue::Projection(ref proj) => {\n                 if cond(proj) {\n                     return Some(child_index)\n                 }\n             }\n             _ => {}\n         }\n-        next_child = move_paths[child_index].next_sibling;\n+        next_child = move_data.move_paths[child_index].next_sibling;\n     }\n \n     None\n@@ -272,6 +271,24 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n     }\n }\n \n+fn on_lookup_result_bits<'a, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    lookup_result: LookupResult,\n+    each_child: F)\n+    where F: FnMut(MovePathIndex)\n+{\n+    match lookup_result {\n+        LookupResult::Parent(..) => {\n+            // access to untracked value - do not touch children\n+        }\n+        LookupResult::Exact(e) => {\n+            on_all_children_bits(tcx, mir, move_data, e, each_child)\n+        }\n+    }\n+}\n+\n fn on_all_children_bits<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n@@ -286,12 +303,8 @@ fn on_all_children_bits<'a, 'tcx, F>(\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex) -> bool\n     {\n-        match move_data.move_paths[path].content {\n-            MovePathContent::Lvalue(ref lvalue) => {\n-                lvalue_contents_drop_state_cannot_differ(tcx, mir, lvalue)\n-            }\n-            _ => true\n-        }\n+        lvalue_contents_drop_state_cannot_differ(\n+            tcx, mir, &move_data.move_paths[path].lvalue)\n     }\n \n     fn on_all_children_bits<'a, 'tcx, F>(\n@@ -327,10 +340,10 @@ fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     let move_data = &ctxt.move_data;\n     for (arg, _) in mir.arg_decls.iter_enumerated() {\n         let lvalue = repr::Lvalue::Arg(arg);\n-        let move_path_index = move_data.rev_lookup.find(&lvalue);\n-        on_all_children_bits(tcx, mir, move_data,\n-                             move_path_index,\n-                             |moi| callback(moi, DropFlagState::Present));\n+        let lookup_result = move_data.rev_lookup.find(&lvalue);\n+        on_lookup_result_bits(tcx, mir, move_data,\n+                              lookup_result,\n+                              |moi| callback(moi, DropFlagState::Present));\n     }\n }\n \n@@ -352,11 +365,10 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n         debug!(\"moving out of path {:?}\", move_data.move_paths[path]);\n \n         // don't move out of non-Copy things\n-        if let MovePathContent::Lvalue(ref lvalue) = move_data.move_paths[path].content {\n-            let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n-            if !ty.moves_by_default(tcx, param_env, DUMMY_SP) {\n-                continue;\n-            }\n+        let lvalue = &move_data.move_paths[path].lvalue;\n+        let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n+        if !ty.moves_by_default(tcx, param_env, DUMMY_SP) {\n+            continue;\n         }\n \n         on_all_children_bits(tcx, mir, move_data,\n@@ -372,9 +384,9 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             }\n             repr::StatementKind::Assign(ref lvalue, _) => {\n                 debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n-                 on_all_children_bits(tcx, mir, move_data,\n-                                     move_data.rev_lookup.find(lvalue),\n-                                     |moi| callback(moi, DropFlagState::Present))\n+                 on_lookup_result_bits(tcx, mir, move_data,\n+                                       move_data.rev_lookup.find(lvalue),\n+                                       |moi| callback(moi, DropFlagState::Present))\n             }\n             repr::StatementKind::StorageLive(_) |\n             repr::StatementKind::StorageDead(_) => {}\n@@ -383,9 +395,9 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             debug!(\"drop_flag_effects: replace {:?}\", block.terminator());\n             match block.terminator().kind {\n                 repr::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                    on_all_children_bits(tcx, mir, move_data,\n-                                         move_data.rev_lookup.find(location),\n-                                         |moi| callback(moi, DropFlagState::Present))\n+                    on_lookup_result_bits(tcx, mir, move_data,\n+                                          move_data.rev_lookup.find(location),\n+                                          |moi| callback(moi, DropFlagState::Present))\n                 }\n                 _ => {\n                     // other terminators do not contain move-ins"}, {"sha": "e13da2531024f2d72728a198afc9f51ddcfed66b", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb19cd65756cd285c81410e627752a75a41e3f0e/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=eb19cd65756cd285c81410e627752a75a41e3f0e", "patch": "@@ -180,7 +180,6 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n                 LvalueContext::Store |\n                 LvalueContext::Inspect |\n                 LvalueContext::Borrow { .. } |\n-                LvalueContext::Slice { .. } |\n                 LvalueContext::Projection => {\n                     self.mark_as_lvalue(index);\n                 }"}]}