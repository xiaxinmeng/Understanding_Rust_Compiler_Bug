{"sha": "05e4d944a9f7db17e759cd4e09fb82357b8cee28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZTRkOTQ0YTlmN2RiMTdlNzU5Y2Q0ZTA5ZmI4MjM1N2I4Y2VlMjg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-02-26T14:06:45Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-02-26T14:06:45Z"}, "message": "Replace callee_id with information stored in method_map.", "tree": {"sha": "ad01af5adf976b29f72956c05de0dc395e45412f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad01af5adf976b29f72956c05de0dc395e45412f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05e4d944a9f7db17e759cd4e09fb82357b8cee28", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05e4d944a9f7db17e759cd4e09fb82357b8cee28", "html_url": "https://github.com/rust-lang/rust/commit/05e4d944a9f7db17e759cd4e09fb82357b8cee28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05e4d944a9f7db17e759cd4e09fb82357b8cee28/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a588ceff2143198f33a62d27b8cd735cb2b9b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a588ceff2143198f33a62d27b8cd735cb2b9b82", "html_url": "https://github.com/rust-lang/rust/commit/7a588ceff2143198f33a62d27b8cd735cb2b9b82"}], "stats": {"total": 1028, "additions": 478, "deletions": 550}, "files": [{"sha": "4450fbb04a9319a98eb9e697da57ef5a614accc3", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -255,7 +255,7 @@ impl Visitor<()> for Context {\n \n     fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         match e.node {\n-            ast::ExprUnary(_, ast::UnBox, _) => {\n+            ast::ExprUnary(ast::UnBox, _) => {\n                 self.gate_box(e.span);\n             }\n             _ => {}"}, {"sha": "f6f51f107647ef22354c589fe35edb0108fe29e3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -21,7 +21,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n                          RegionParameter};\n use metadata::tyencode;\n-use middle::typeck::method_origin;\n+use middle::typeck::{MethodCallee, MethodOrigin};\n use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n@@ -574,10 +574,50 @@ impl tr for moves::CaptureVar {\n }\n \n // ______________________________________________________________________\n-// Encoding and decoding of method_origin\n+// Encoding and decoding of MethodCallee\n \n-impl tr for method_origin {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> method_origin {\n+trait read_method_callee_helper {\n+    fn read_method_callee(&mut self, xcx: @ExtendedDecodeContext) -> MethodCallee;\n+}\n+\n+fn encode_method_callee(ecx: &e::EncodeContext,\n+                        ebml_w: &mut writer::Encoder,\n+                        method: &MethodCallee) {\n+    ebml_w.emit_struct(\"MethodCallee\", 3, |ebml_w| {\n+        ebml_w.emit_struct_field(\"origin\", 0u, |ebml_w| {\n+            method.origin.encode(ebml_w);\n+        });\n+        ebml_w.emit_struct_field(\"ty\", 1u, |ebml_w| {\n+            ebml_w.emit_ty(ecx, method.ty);\n+        });\n+        ebml_w.emit_struct_field(\"substs\", 2u, |ebml_w| {\n+            ebml_w.emit_substs(ecx, &method.substs);\n+        });\n+    })\n+}\n+\n+impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n+    fn read_method_callee(&mut self, xcx: @ExtendedDecodeContext) -> MethodCallee {\n+        self.read_struct(\"MethodCallee\", 3, |this| {\n+            MethodCallee {\n+                origin: this.read_struct_field(\"origin\", 0, |this| {\n+                    let method_origin: MethodOrigin =\n+                        Decodable::decode(this);\n+                    method_origin.tr(xcx)\n+                }),\n+                ty: this.read_struct_field(\"ty\", 1, |this| {\n+                    this.read_ty(xcx)\n+                }),\n+                substs: this.read_struct_field(\"substs\", 2, |this| {\n+                    this.read_substs(xcx)\n+                })\n+            }\n+        })\n+    }\n+}\n+\n+impl tr for MethodOrigin {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> MethodOrigin {\n         match *self {\n             typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(xcx)),\n             typeck::MethodParam(ref mp) => {\n@@ -991,17 +1031,13 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    {\n-        let method_map = maps.method_map.borrow();\n-        let r = method_map.get().find(&id);\n-        for &origin in r.iter() {\n-            ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    origin.encode(ebml_w);\n-                })\n+    for &method in maps.method_map.borrow().get().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                encode_method_callee(ecx, ebml_w, method)\n             })\n-        }\n+        })\n     }\n \n     {\n@@ -1335,9 +1371,8 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                         ty_param_defs.get().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        let origin: method_origin = Decodable::decode(val_dsr);\n-                        let mut method_map = dcx.maps.method_map.borrow_mut();\n-                        method_map.get().insert(id, origin.tr(xcx));\n+                        let method = val_dsr.read_method_callee(xcx);\n+                        dcx.maps.method_map.borrow_mut().get().insert(id, method);\n                     }\n                     c::tag_table_vtable_map => {\n                         let vtable_res ="}, {"sha": "f974b324f05644cc78856f58589dbc060ba7cb38", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -784,7 +784,6 @@ impl<'a> CheckLoanCtxt<'a> {\n     pub fn check_call(&self,\n                       _expr: &ast::Expr,\n                       _callee: Option<@ast::Expr>,\n-                      _callee_id: ast::NodeId,\n                       _callee_span: Span,\n                       _args: &[@ast::Expr]) {\n         // NB: This call to check for conflicting loans is not truly\n@@ -828,23 +827,22 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n           this.check_captured_variables(expr.id, expr.span)\n       }\n       ast::ExprAssign(dest, _) |\n-      ast::ExprAssignOp(_, _, dest, _) => {\n+      ast::ExprAssignOp(_, dest, _) => {\n         this.check_assignment(dest);\n       }\n       ast::ExprCall(f, ref args) => {\n-        this.check_call(expr, Some(f), f.id, f.span, *args);\n+        this.check_call(expr, Some(f), f.span, *args);\n       }\n-      ast::ExprMethodCall(callee_id, _, _, ref args) => {\n-        this.check_call(expr, None, callee_id, expr.span, *args);\n+      ast::ExprMethodCall(_, _, ref args) => {\n+        this.check_call(expr, None, expr.span, *args);\n       }\n-      ast::ExprIndex(callee_id, _, rval) |\n-      ast::ExprBinary(callee_id, _, _, rval)\n+      ast::ExprIndex(_, rval) | ast::ExprBinary(_, _, rval)\n       if method_map.get().contains_key(&expr.id) => {\n-        this.check_call(expr, None, callee_id, expr.span, [rval]);\n+        this.check_call(expr, None, expr.span, [rval]);\n       }\n-      ast::ExprUnary(callee_id, _, _) | ast::ExprIndex(callee_id, _, _)\n+      ast::ExprUnary(_, _) | ast::ExprIndex(_, _)\n       if method_map.get().contains_key(&expr.id) => {\n-        this.check_call(expr, None, callee_id, expr.span, []);\n+        this.check_call(expr, None, expr.span, []);\n       }\n       ast::ExprInlineAsm(ref ia) => {\n           for &(_, out) in ia.outputs.iter() {"}, {"sha": "202ea4978688a88e2e26d5c9254ad073e3f8e931", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -181,20 +181,9 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n     this.id_range.add(ex.id);\n \n-    {\n-        let r = ex.get_callee_id();\n-        for callee_id in r.iter() {\n-            this.id_range.add(*callee_id);\n-        }\n-    }\n-\n     // If this expression is borrowed, have to ensure it remains valid:\n-    {\n-        let adjustments = tcx.adjustments.borrow();\n-        let r = adjustments.get().find(&ex.id);\n-        for &adjustments in r.iter() {\n-            this.guarantee_adjustments(ex, *adjustments);\n-        }\n+    for &adjustments in tcx.adjustments.borrow().get().find(&ex.id).iter() {\n+        this.guarantee_adjustments(ex, *adjustments);\n     }\n \n     // If this expression is a move, gather it:\n@@ -225,7 +214,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n         visit::walk_expr(this, ex, ());\n       }\n \n-      ast::ExprAssign(l, _) | ast::ExprAssignOp(_, _, l, _) => {\n+      ast::ExprAssign(l, _) | ast::ExprAssignOp(_, l, _) => {\n           let l_cmt = this.bccx.cat_expr(l);\n           match opt_loan_path(l_cmt) {\n               Some(l_lp) => {\n@@ -252,8 +241,8 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n         visit::walk_expr(this, ex, ());\n       }\n \n-      ast::ExprIndex(_, _, arg) |\n-      ast::ExprBinary(_, _, _, arg)\n+      ast::ExprIndex(_, arg) |\n+      ast::ExprBinary(_, _, arg)\n       if method_map.get().contains_key(&ex.id) => {\n           // Arguments in method calls are always passed by ref.\n           //"}, {"sha": "12853fe6742da222da333095ead93c340492dfb6", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -305,7 +305,7 @@ impl CFGBuilder {\n                 expr_exit\n             }\n \n-            ast::ExprBinary(_, op, l, r) if ast_util::lazy_binop(op) => {\n+            ast::ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -355,16 +355,16 @@ impl CFGBuilder {\n                 self.call(expr, pred, func, *args)\n             }\n \n-            ast::ExprMethodCall(_, _, _, ref args) => {\n+            ast::ExprMethodCall(_, _, ref args) => {\n                 self.call(expr, pred, args[0], args.slice_from(1))\n             }\n \n-            ast::ExprIndex(_, l, r) |\n-            ast::ExprBinary(_, _, l, r) if self.is_method_call(expr) => {\n+            ast::ExprIndex(l, r) |\n+            ast::ExprBinary(_, l, r) if self.is_method_call(expr) => {\n                 self.call(expr, pred, l, [r])\n             }\n \n-            ast::ExprUnary(_, _, e) if self.is_method_call(expr) => {\n+            ast::ExprUnary(_, e) if self.is_method_call(expr) => {\n                 self.call(expr, pred, e, [])\n             }\n \n@@ -384,12 +384,12 @@ impl CFGBuilder {\n             }\n \n             ast::ExprAssign(l, r) |\n-            ast::ExprAssignOp(_, _, l, r) => {\n+            ast::ExprAssignOp(_, l, r) => {\n                 self.straightline(expr, pred, [r, l])\n             }\n \n-            ast::ExprIndex(_, l, r) |\n-            ast::ExprBinary(_, _, l, r) => { // NB: && and || handled earlier\n+            ast::ExprIndex(l, r) |\n+            ast::ExprBinary(_, l, r) => { // NB: && and || handled earlier\n                 self.straightline(expr, pred, [l, r])\n             }\n \n@@ -399,7 +399,7 @@ impl CFGBuilder {\n \n             ast::ExprAddrOf(_, e) |\n             ast::ExprCast(e, _) |\n-            ast::ExprUnary(_, _, e) |\n+            ast::ExprUnary(_, e) |\n             ast::ExprParen(e) |\n             ast::ExprVstore(e, _) |\n             ast::ExprField(e, _, _) => {"}, {"sha": "864b4473336027fd5733081e513a789ff59d06ab", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -108,8 +108,8 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                   is_const: bool) {\n     if is_const {\n         match e.node {\n-          ExprUnary(_, UnDeref, _) => { }\n-          ExprUnary(_, UnBox, _) | ExprUnary(_, UnUniq, _) => {\n+          ExprUnary(UnDeref, _) => { }\n+          ExprUnary(UnBox, _) | ExprUnary(UnUniq, _) => {\n             sess.span_err(e.span,\n                           \"cannot do allocations in constant expressions\");\n             return;"}, {"sha": "0b516a7f05fcf257aac65b8bcd1a1cb34a46aa7a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -225,10 +225,10 @@ impl ConstEvalVisitor {\n                 }\n             }\n \n-            ast::ExprUnary(_, _, inner) | ast::ExprParen(inner) =>\n+            ast::ExprUnary(_, inner) | ast::ExprParen(inner) =>\n                 self.classify(inner),\n \n-            ast::ExprBinary(_, _, a, b) =>\n+            ast::ExprBinary(_, a, b) =>\n                 join(self.classify(a), self.classify(b)),\n \n             ast::ExprTup(ref es) |\n@@ -262,7 +262,7 @@ impl ConstEvalVisitor {\n \n             ast::ExprField(base, _, _) => self.classify(base),\n \n-            ast::ExprIndex(_, base, idx) =>\n+            ast::ExprIndex(base, idx) =>\n                 join(self.classify(base), self.classify(idx)),\n \n             ast::ExprAddrOf(ast::MutImmutable, base) => self.classify(base),\n@@ -336,7 +336,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n     use middle::ty;\n     fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n     match e.node {\n-      ExprUnary(_, UnNeg, inner) => {\n+      ExprUnary(UnNeg, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n@@ -346,15 +346,15 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           ref err => ((*err).clone())\n         }\n       }\n-      ExprUnary(_, UnNot, inner) => {\n+      ExprUnary(UnNot, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(~\"not on float or string\")\n         }\n       }\n-      ExprBinary(_, op, a, b) => {\n+      ExprBinary(op, a, b) => {\n         match (eval_const_expr_partial(tcx, a),\n                eval_const_expr_partial(tcx, b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {"}, {"sha": "e81e6b0f96d2d0c6a8e89de12c823621778e9a15", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -556,7 +556,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n \n             ast::ExprAssign(l, r) |\n-            ast::ExprAssignOp(_, _, l, r) => {\n+            ast::ExprAssignOp(_, l, r) => {\n                 self.walk_expr(r, in_out, loop_scopes);\n                 self.walk_expr(l, in_out, loop_scopes);\n             }\n@@ -579,35 +579,35 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n             ast::ExprCall(f, ref args) => {\n                 self.walk_expr(f, in_out, loop_scopes);\n-                self.walk_call(f.id, expr.id, *args, in_out, loop_scopes);\n+                self.walk_call(expr.id, *args, in_out, loop_scopes);\n             }\n \n-            ast::ExprMethodCall(callee_id, _, _, ref args) => {\n-                self.walk_call(callee_id, expr.id, *args, in_out, loop_scopes);\n+            ast::ExprMethodCall(_, _, ref args) => {\n+                self.walk_call(expr.id, *args, in_out, loop_scopes);\n             }\n \n-            ast::ExprIndex(callee_id, l, r) |\n-            ast::ExprBinary(callee_id, _, l, r) if self.is_method_call(expr) => {\n-                self.walk_call(callee_id, expr.id, [l, r], in_out, loop_scopes);\n+            ast::ExprIndex(l, r) |\n+            ast::ExprBinary(_, l, r) if self.is_method_call(expr) => {\n+                self.walk_call(expr.id, [l, r], in_out, loop_scopes);\n             }\n \n-            ast::ExprUnary(callee_id, _, e) if self.is_method_call(expr) => {\n-                self.walk_call(callee_id, expr.id, [e], in_out, loop_scopes);\n+            ast::ExprUnary(_, e) if self.is_method_call(expr) => {\n+                self.walk_call(expr.id, [e], in_out, loop_scopes);\n             }\n \n             ast::ExprTup(ref exprs) => {\n                 self.walk_exprs(*exprs, in_out, loop_scopes);\n             }\n \n-            ast::ExprBinary(_, op, l, r) if ast_util::lazy_binop(op) => {\n+            ast::ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n                 let temp = in_out.to_owned();\n                 self.walk_expr(r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n \n-            ast::ExprIndex(_, l, r) |\n-            ast::ExprBinary(_, _, l, r) => {\n+            ast::ExprIndex(l, r) |\n+            ast::ExprBinary(_, l, r) => {\n                 self.walk_exprs([l, r], in_out, loop_scopes);\n             }\n \n@@ -617,7 +617,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n             ast::ExprAddrOf(_, e) |\n             ast::ExprCast(e, _) |\n-            ast::ExprUnary(_, _, e) |\n+            ast::ExprUnary(_, e) |\n             ast::ExprParen(e) |\n             ast::ExprVstore(e, _) |\n             ast::ExprField(e, _, _) => {\n@@ -715,16 +715,15 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     }\n \n     fn walk_call(&mut self,\n-                 _callee_id: ast::NodeId,\n                  call_id: ast::NodeId,\n                  args: &[@ast::Expr],\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         self.walk_exprs(args, in_out, loop_scopes);\n \n         // FIXME(#6268) nested method calls\n-        // self.merge_with_entry_set(callee_id, in_out);\n-        // self.dfcx.apply_gen_kill(callee_id, in_out);\n+        // self.merge_with_entry_set(in_out);\n+        // self.dfcx.apply_gen_kill(in_out);\n \n         let return_ty = ty::node_id_to_type(self.tcx(), call_id);\n         let fails = ty::type_is_bot(return_ty);"}, {"sha": "7d66c80dea08b755a725c5f90f2a7b1fcffa66fe", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -92,10 +92,9 @@ impl MarkSymbolVisitor {\n \n     fn lookup_and_handle_method(&mut self, id: &ast::NodeId,\n                                 span: codemap::Span) {\n-        let method_map = self.method_map.borrow();\n-        match method_map.get().find(id) {\n-            Some(&origin) => {\n-                match origin {\n+        match self.method_map.borrow().get().find(id) {\n+            Some(method) => {\n+                match method.origin {\n                     typeck::MethodStatic(def_id) => {\n                         match ty::provided_source(self.tcx, def_id) {\n                             Some(p_did) => self.check_def_id(p_did),"}, {"sha": "bac706e5a866005d093837e655e96a9126a10cbd", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -65,7 +65,7 @@ impl EffectCheckVisitor {\n \n     fn check_str_index(&mut self, e: @ast::Expr) {\n         let base_type = match e.node {\n-            ast::ExprIndex(_, base, _) => ty::node_id_to_type(self.tcx, base.id),\n+            ast::ExprIndex(base, _) => ty::node_id_to_type(self.tcx, base.id),\n             _ => return\n         };\n         debug!(\"effect: checking index with base type {}\",\n@@ -137,8 +137,8 @@ impl Visitor<()> for EffectCheckVisitor {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _:()) {\n         match expr.node {\n-            ast::ExprMethodCall(callee_id, _, _, _) => {\n-                let base_type = ty::node_id_to_type(self.tcx, callee_id);\n+            ast::ExprMethodCall(_, _, _) => {\n+                let base_type = self.method_map.borrow().get().get(&expr.id).ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {\n@@ -154,7 +154,7 @@ impl Visitor<()> for EffectCheckVisitor {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n-            ast::ExprUnary(_, ast::UnDeref, base) => {\n+            ast::ExprUnary(ast::UnDeref, base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n                         ppaux::ty_to_str(self.tcx, base_type));\n@@ -166,7 +166,7 @@ impl Visitor<()> for EffectCheckVisitor {\n                     _ => {}\n                 }\n             }\n-            ast::ExprAssign(base, _) | ast::ExprAssignOp(_, _, base, _) => {\n+            ast::ExprAssign(base, _) | ast::ExprAssignOp(_, base, _) => {\n                 self.check_str_index(base);\n             }\n             ast::ExprAddrOf(ast::MutMutable, base) => {"}, {"sha": "f4c9911c24387ef6e3effc7309aec27fbe70a36e", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -264,13 +264,14 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     debug!(\"kind::check_expr({})\", expr_to_str(e));\n \n     // Handle any kind bounds on type parameters\n-    let type_parameter_id = match e.get_callee_id() {\n-        Some(callee_id) => callee_id,\n-        None => e.id,\n-    };\n     {\n+        let method_map = cx.method_map.borrow();\n+        let method = method_map.get().find(&e.id);\n         let node_type_substs = cx.tcx.node_type_substs.borrow();\n-        let r = node_type_substs.get().find(&type_parameter_id);\n+        let r = match method {\n+            Some(method) => Some(&method.substs.tps),\n+            None => node_type_substs.get().find(&e.id)\n+        };\n         for ts in r.iter() {\n             let def_map = cx.tcx.def_map.borrow();\n             let type_param_defs = match e.node {\n@@ -285,9 +286,9 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n \n                 // Even though the callee_id may have been the id with\n                 // node_type_substs, e.id is correct here.\n-                match cx.method_map.borrow().get().find(&e.id) {\n-                    Some(origin) => {\n-                        ty::method_call_type_param_defs(cx.tcx, *origin)\n+                match method {\n+                    Some(method) => {\n+                        ty::method_call_type_param_defs(cx.tcx, method.origin)\n                     }\n                     None => {\n                         cx.tcx.sess.span_bug(e.span,\n@@ -306,13 +307,13 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                       type_param_defs.repr(cx.tcx));\n             }\n             for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n-                check_typaram_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n+                check_typaram_bounds(cx, e.span, ty, type_param_def)\n             }\n         }\n     }\n \n     match e.node {\n-        ExprUnary(_, UnBox, interior) => {\n+        ExprUnary(UnBox, interior) => {\n             let interior_type = ty::expr_ty(cx.tcx, interior);\n             let _ = check_durable(cx.tcx, interior_type, interior.span);\n         }\n@@ -373,7 +374,7 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n                 let generics = ty::lookup_item_type(cx.tcx, did).generics;\n                 let type_param_defs = generics.type_param_defs();\n                 for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n-                    check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n+                    check_typaram_bounds(cx, aty.span, ty, type_param_def)\n                 }\n             }\n         }\n@@ -400,11 +401,9 @@ pub fn check_builtin_bounds(cx: &Context,\n }\n \n pub fn check_typaram_bounds(cx: &Context,\n-                    _type_parameter_id: NodeId,\n-                    sp: Span,\n-                    ty: ty::t,\n-                    type_param_def: &ty::TypeParameterDef)\n-{\n+                            sp: Span,\n+                            ty: ty::t,\n+                            type_param_def: &ty::TypeParameterDef) {\n     check_builtin_bounds(cx,\n                          ty,\n                          type_param_def.bounds.builtin_bounds,"}, {"sha": "c3e57bd9c60df1a20d65eb5523a4d384b085f29d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -674,7 +674,7 @@ fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n \n fn check_type_limits(cx: &Context, e: &ast::Expr) {\n     return match e.node {\n-        ast::ExprBinary(_, binop, l, r) => {\n+        ast::ExprBinary(binop, l, r) => {\n             if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n                 cx.span_lint(TypeLimits, e.span,\n                              \"comparison is useless due to type limits\");\n@@ -1176,7 +1176,7 @@ fn check_unnecessary_parens_expr(cx: &Context, e: &ast::Expr) {\n         ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n         ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n         ast::ExprAssign(_, value) => (value, \"assigned value\"),\n-        ast::ExprAssignOp(_, _, _, value) => (value, \"assigned value\"),\n+        ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n         _ => return\n     };\n     check_unnecessary_parens_core(cx, value, msg);\n@@ -1263,8 +1263,8 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n                 _ => return\n             }\n         }\n-        ast::ExprUnary(_, ast::UnUniq, _) |\n-        ast::ExprUnary(_, ast::UnBox, _) => BoxAllocation,\n+        ast::ExprUnary(ast::UnUniq, _) |\n+        ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n \n         _ => return\n     };\n@@ -1411,10 +1411,9 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            let method_map = cx.method_map.borrow();\n-            match method_map.get().find(&e.id) {\n-                Some(&origin) => {\n-                    match origin {\n+            match cx.method_map.borrow().get().find(&e.id) {\n+                Some(method) => {\n+                    match method.origin {\n                         typeck::MethodStatic(def_id) => {\n                             // If this implements a trait method, get def_id\n                             // of the method inside trait definition.\n@@ -1531,7 +1530,7 @@ impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         match e.node {\n-            ast::ExprUnary(_, ast::UnNeg, expr) => {\n+            ast::ExprUnary(ast::UnNeg, expr) => {\n                 // propagate negation, if the negation itself isn't negated\n                 if self.negated_expr_id != e.id {\n                     self.negated_expr_id = expr.id;"}, {"sha": "eb123a91119af18a45c200f3109487a6e992f4a7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -534,7 +534,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n         visit::walk_expr(v, expr, this);\n       }\n       ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n-      ExprBinary(_, op, _, _) if ast_util::lazy_binop(op) => {\n+      ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n       }\n@@ -1179,7 +1179,7 @@ impl Liveness {\n             self.propagate_through_expr(r, succ)\n           }\n \n-          ExprAssignOp(_, _, l, r) => {\n+          ExprAssignOp(_, l, r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ);\n@@ -1219,10 +1219,10 @@ impl Liveness {\n             self.propagate_through_expr(f, succ)\n           }\n \n-          ExprMethodCall(callee_id, _, _, ref args) => {\n+          ExprMethodCall(_, _, ref args) => {\n             // calling a method with bot return type means that the method\n             // will fail, and hence the successors can be ignored\n-            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx, callee_id));\n+            let t_ret = ty::node_id_to_type(self.tcx, expr.id);\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n             self.propagate_through_exprs(*args, succ)\n@@ -1232,7 +1232,7 @@ impl Liveness {\n             self.propagate_through_exprs(*exprs, succ)\n           }\n \n-          ExprBinary(_, op, l, r) if ast_util::lazy_binop(op) => {\n+          ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n             let r_succ = self.propagate_through_expr(r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n@@ -1242,15 +1242,15 @@ impl Liveness {\n             self.propagate_through_expr(l, ln)\n           }\n \n-          ExprIndex(_, l, r) |\n-          ExprBinary(_, _, l, r) |\n+          ExprIndex(l, r) |\n+          ExprBinary(_, l, r) |\n           ExprBox(l, r) => {\n             self.propagate_through_exprs([l, r], succ)\n           }\n \n           ExprAddrOf(_, e) |\n           ExprCast(e, _) |\n-          ExprUnary(_, _, e) |\n+          ExprUnary(_, e) |\n           ExprParen(e) => {\n             self.propagate_through_expr(e, succ)\n           }\n@@ -1508,7 +1508,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         visit::walk_expr(this, expr, ());\n       }\n \n-      ExprAssignOp(_, _, l, _) => {\n+      ExprAssignOp(_, l, _) => {\n         this.check_lvalue(l);\n \n         visit::walk_expr(this, expr, ());"}, {"sha": "fe66ec88f8fb8cec751e38883906cf966b3f86c4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -432,7 +432,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n \n         let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n-          ast::ExprUnary(_, ast::UnDeref, e_base) => {\n+          ast::ExprUnary(ast::UnDeref, e_base) => {\n             if self.typer.is_method_call(expr.id) {\n                 return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n             }\n@@ -450,7 +450,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n             Ok(self.cat_field(expr, base_cmt, f_name, expr_ty))\n           }\n \n-          ast::ExprIndex(_, base, _) => {\n+          ast::ExprIndex(base, _) => {\n             if self.typer.is_method_call(expr.id) {\n                 return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n             }"}, {"sha": "4864f72d8fcbd15ea2f836cbf0a6424b2d040aa0", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -361,20 +361,20 @@ impl VisitContext {\n                 }\n             }\n \n-            ExprUnary(_, UnDeref, base) => {       // *base\n+            ExprUnary(UnDeref, base) => {      // *base\n                 if !self.use_overloaded_operator(expr, base, [])\n                 {\n                     // Moving out of *base moves out of base.\n                     self.use_expr(base, comp_mode);\n                 }\n             }\n \n-            ExprField(base, _, _) => {        // base.f\n+            ExprField(base, _, _) => {         // base.f\n                 // Moving out of base.f moves out of base.\n                 self.use_expr(base, comp_mode);\n             }\n \n-            ExprIndex(_, lhs, rhs) => {          // lhs[rhs]\n+            ExprIndex(lhs, rhs) => {           // lhs[rhs]\n                 if !self.use_overloaded_operator(expr, lhs, [rhs])\n                 {\n                     self.use_expr(lhs, comp_mode);\n@@ -409,11 +409,11 @@ impl VisitContext {\n                     }\n                 }\n                 self.use_expr(callee, mode);\n-                self.use_fn_args(callee.id, *args);\n+                self.use_fn_args(*args);\n             }\n \n-            ExprMethodCall(callee_id, _, _, ref args) => { // callee.m(args)\n-                self.use_fn_args(callee_id, *args);\n+            ExprMethodCall(_, _, ref args) => { // callee.m(args)\n+                self.use_fn_args(*args);\n             }\n \n             ExprStruct(_, ref fields, opt_with) => {\n@@ -521,14 +521,14 @@ impl VisitContext {\n \n             ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ExprUnary(_, _, lhs) => {\n+            ExprUnary(_, lhs) => {\n                 if !self.use_overloaded_operator(expr, lhs, [])\n                 {\n                     self.consume_expr(lhs);\n                 }\n             }\n \n-            ExprBinary(_, _, lhs, rhs) => {\n+            ExprBinary(_, lhs, rhs) => {\n                 if !self.use_overloaded_operator(expr, lhs, [rhs])\n                 {\n                     self.consume_expr(lhs);\n@@ -555,7 +555,7 @@ impl VisitContext {\n                 self.consume_expr(base);\n             }\n \n-            ExprAssignOp(_, _, lhs, rhs) => {\n+            ExprAssignOp(_, lhs, rhs) => {\n                 // FIXME(#4712) --- Overloaded operators?\n                 //\n                 // if !self.use_overloaded_operator(expr, DoDerefArgs, lhs, [rhs])\n@@ -668,7 +668,6 @@ impl VisitContext {\n     }\n \n     pub fn use_fn_args(&mut self,\n-                       _: NodeId,\n                        arg_exprs: &[@Expr]) {\n         //! Uses the argument expressions.\n         for arg_expr in arg_exprs.iter() {"}, {"sha": "453160dc001156ef4487e2b5505f951a90fd775c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -785,7 +785,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     _ => {}\n                 }\n             }\n-            ast::ExprMethodCall(_, ident, _, ref args) => {\n+            ast::ExprMethodCall(ident, _, ref args) => {\n                 // see above\n                 let t = ty::type_autoderef(ty::expr_ty(self.tcx, args[0]));\n                 match ty::get(t).sty {\n@@ -796,9 +796,9 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                                        \"method call not in \\\n                                                         method map\");\n                             }\n-                            Some(origin) => {\n+                            Some(method) => {\n                                 debug!(\"(privacy checking) checking impl method\");\n-                                self.check_method(expr.span, origin, ident);\n+                                self.check_method(expr.span, method.origin, ident);\n                             }\n                         }\n                     }"}, {"sha": "4b2bc5c966f89ce4315acb60164c304bb81e77fe", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -147,9 +147,8 @@ impl Visitor<()> for MarkSymbolVisitor {\n                 }\n             }\n             ast::ExprMethodCall(..) => {\n-                let method_map = self.method_map.borrow();\n-                match method_map.get().find(&expr.id) {\n-                    Some(&typeck::method_static(def_id)) => {\n+                match self.method_map.borrow().get().get(&expr.id).origin {\n+                    typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if ReachableContext::\n                                 def_id_represents_local_inlined_item(\n@@ -168,11 +167,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n                             }\n                         }\n                     }\n-                    Some(_) => {}\n-                    None => {\n-                        self.tcx.sess.span_bug(expr.span,\n-                            \"method call expression not in method map?!\")\n-                    }\n+                    _ => {}\n                 }\n             }\n             _ => {}"}, {"sha": "9e1552ae35e1bab9e776e3639918691a0a208f76", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -512,8 +512,8 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n         // scopes, meaning that temporaries cannot outlive them.\n         // This ensures fixed size stacks.\n \n-        ast::ExprBinary(_, ast::BiAnd, _, r) |\n-        ast::ExprBinary(_, ast::BiOr, _, r) => {\n+        ast::ExprBinary(ast::BiAnd, _, r) |\n+        ast::ExprBinary(ast::BiOr, _, r) => {\n             // For shortcircuiting operators, mark the RHS as a terminating\n             // scope since it only executes conditionally.\n             visitor.region_maps.mark_as_terminating_scope(r.id);\n@@ -756,7 +756,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n                         visitor, subexpr, blk_id);\n                 }\n             }\n-            ast::ExprUnary(_, ast::UnUniq, subexpr) => {\n+            ast::ExprUnary(ast::UnUniq, subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n             }\n             ast::ExprCast(subexpr, _) |\n@@ -811,9 +811,9 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n \n             match expr.node {\n                 ast::ExprAddrOf(_, ref subexpr) |\n-                ast::ExprUnary(_, ast::UnDeref, ref subexpr) |\n+                ast::ExprUnary(ast::UnDeref, ref subexpr) |\n                 ast::ExprField(ref subexpr, _, _) |\n-                ast::ExprIndex(_, ref subexpr, _) |\n+                ast::ExprIndex(ref subexpr, _) |\n                 ast::ExprParen(ref subexpr) => {\n                     let subexpr: &'a @Expr = subexpr; // FIXME(#11586)\n                     expr = &**subexpr;"}, {"sha": "8f0261dfb9170478c2c54f3d95249e440cebb636", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -5257,7 +5257,7 @@ impl Resolver {\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, traits);\n             }\n-            ExprMethodCall(_, ident, _, _) => {\n+            ExprMethodCall(ident, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);"}, {"sha": "3c44c607e7f566a7544b29968305ab5cd453aee1", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -118,7 +118,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         match def {\n             ast::DefFn(did, _) |\n             ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n-                fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id))\n+                fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id, false))\n             }\n             ast::DefStaticMethod(impl_did,\n                                    ast::FromTrait(trait_did),\n@@ -132,10 +132,10 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n                 assert!(ty::enum_variant_with_id(bcx.tcx(),\n                                                       tid,\n                                                       vid).args.len() > 0u);\n-                fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id))\n+                fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id, false))\n             }\n             ast::DefStruct(def_id) => {\n-                fn_callee(bcx, trans_fn_ref(bcx, def_id, ref_expr.id))\n+                fn_callee(bcx, trans_fn_ref(bcx, def_id, ref_expr.id, false))\n             }\n             ast::DefStatic(..) |\n             ast::DefArg(..) |\n@@ -158,16 +158,8 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     }\n }\n \n-pub fn trans_fn_ref_to_callee<'a>(\n-                              bcx: &'a Block<'a>,\n-                              def_id: ast::DefId,\n-                              ref_id: ast::NodeId)\n-                              -> Callee<'a> {\n-    Callee {bcx: bcx,\n-            data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n-}\n-\n-pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, ref_id: ast::NodeId)\n+pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId,\n+                    ref_id: ast::NodeId, is_method: bool)\n                     -> ValueRef {\n     /*!\n      *\n@@ -177,23 +169,22 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, ref_id: ast::NodeId)\n \n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n-    let type_params = node_id_type_params(bcx, ref_id);\n+    let type_params = node_id_type_params(bcx, ref_id, is_method);\n     let vtables = node_vtables(bcx, ref_id);\n     debug!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n            def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n-    trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params, vtables)\n+    trans_fn_ref_with_vtables(bcx, def_id, ref_id, is_method, type_params, vtables)\n }\n \n-pub fn trans_fn_ref_with_vtables_to_callee<'a>(\n-                                           bcx: &'a Block<'a>,\n+fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n                                            def_id: ast::DefId,\n                                            ref_id: ast::NodeId,\n                                            type_params: &[ty::t],\n                                            vtables: Option<typeck::vtable_res>)\n                                            -> Callee<'a> {\n     Callee {bcx: bcx,\n-            data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ref_id,\n+            data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ref_id, false,\n                                                type_params, vtables))}\n }\n \n@@ -243,6 +234,7 @@ pub fn trans_fn_ref_with_vtables(\n         bcx: &Block,       //\n         def_id: ast::DefId,   // def id of fn\n         ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n+        is_method: bool,\n         type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> ValueRef {\n@@ -388,7 +380,12 @@ pub fn trans_fn_ref_with_vtables(\n         if must_cast && ref_id != 0 {\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)\n-            let ref_ty = common::node_id_type(bcx, ref_id);\n+            let ref_ty = if is_method {\n+                let t = bcx.ccx().maps.method_map.borrow().get().get(&ref_id).ty;\n+                monomorphize_type(bcx, t)\n+            } else {\n+                node_id_type(bcx, ref_id)\n+            };\n \n             val = PointerCast(\n                 bcx, val, type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to());\n@@ -461,41 +458,22 @@ pub fn trans_call<'a>(\n }\n \n pub fn trans_method_call<'a>(\n-                         in_cx: &'a Block<'a>,\n+                         bcx: &'a Block<'a>,\n                          call_ex: &ast::Expr,\n-                         callee_id: ast::NodeId,\n                          rcvr: &ast::Expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n                          -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_ex={})\", call_ex.repr(in_cx.tcx()));\n+    debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n+    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&call_ex.id).ty;\n     trans_call_inner(\n-        in_cx,\n+        bcx,\n         Some(common::expr_info(call_ex)),\n-        node_id_type(in_cx, callee_id),\n-        expr_ty(in_cx, call_ex),\n+        monomorphize_type(bcx, method_ty),\n+        expr_ty(bcx, call_ex),\n         |cx, arg_cleanup_scope| {\n-            let origin_opt = {\n-                let mut method_map = cx.ccx().maps.method_map.borrow_mut();\n-                method_map.get().find_copy(&call_ex.id)\n-            };\n-            match origin_opt {\n-                Some(origin) => {\n-                    debug!(\"origin for {}: {}\",\n-                           call_ex.repr(in_cx.tcx()),\n-                           origin.repr(in_cx.tcx()));\n-\n-                    meth::trans_method_callee(cx,\n-                                              callee_id,\n-                                              rcvr,\n-                                              origin,\n-                                              arg_cleanup_scope)\n-                }\n-                None => {\n-                    cx.tcx().sess.span_bug(call_ex.span, \"method call expr wasn't in method map\")\n-                }\n-            }\n+            meth::trans_method_callee(cx, call_ex.id, rcvr, arg_cleanup_scope)\n         },\n         args,\n         Some(dest)).bcx"}, {"sha": "dfff05966cb99505188240199545d651871867f3", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -673,7 +673,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n \n         // The exception handling personality function.\n         let def_id = common::langcall(pad_bcx, None, \"\", EhPersonalityLangItem);\n-        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, 0);\n+        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, 0, false);\n \n         // The only landing pad clause will be 'cleanup'\n         let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1u);"}, {"sha": "037ea3e14f336b1c1ce7d3c811c8bcfcafc29c72", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -807,9 +807,13 @@ pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: &Block, id: ast::NodeId) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n-    let params = ty::node_id_to_type_params(tcx, id);\n+    let params = if is_method {\n+        bcx.ccx().maps.method_map.borrow().get().get(&id).substs.tps.clone()\n+    } else {\n+        ty::node_id_to_type_params(tcx, id)\n+    };\n \n     if !params.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug("}, {"sha": "b3c3b22c1f5ba5c9fec44270c11084132d476bda", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -310,7 +310,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n           ast::ExprLit(lit) => {\n               (consts::const_lit(cx, e, (*lit).clone()), true)\n           }\n-          ast::ExprBinary(_, b, e1, e2) => {\n+          ast::ExprBinary(b, e1, e2) => {\n             let (te1, _) = const_expr(cx, e1, is_local);\n             let (te2, _) = const_expr(cx, e2, is_local);\n \n@@ -392,7 +392,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               },\n             }, true)\n           },\n-          ast::ExprUnary(_, u, e) => {\n+          ast::ExprUnary(u, e) => {\n             let (te, _) = const_expr(cx, e, is_local);\n             let ty = ty::expr_ty(cx.tcx, e);\n             let is_float = ty::type_is_fp(ty);\n@@ -429,7 +429,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               })\n           }\n \n-          ast::ExprIndex(_, base, index) => {\n+          ast::ExprIndex(base, index) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {"}, {"sha": "9dc119b024f54e29b5c6ec57a0e9470f22ca7064", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -2539,15 +2539,13 @@ fn populate_scope_map(cx: &CrateContext,\n                 None => ()\n             },\n \n-            ast::ExprUnary(node_id, _, sub_exp) => {\n-                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n+            ast::ExprUnary(_, sub_exp) => {\n                 walk_expr(cx, sub_exp, scope_stack, scope_map);\n             }\n \n-            ast::ExprAssignOp(node_id, _, lhs, rhs) |\n-            ast::ExprIndex(node_id, lhs, rhs)        |\n-            ast::ExprBinary(node_id, _, lhs, rhs)    => {\n-                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n+            ast::ExprAssignOp(_, lhs, rhs) |\n+            ast::ExprIndex(lhs, rhs)        |\n+            ast::ExprBinary(_, lhs, rhs)    => {\n                 walk_expr(cx, lhs, scope_stack, scope_map);\n                 walk_expr(cx, rhs, scope_stack, scope_map);\n             }\n@@ -2638,9 +2636,7 @@ fn populate_scope_map(cx: &CrateContext,\n                 }\n             }\n \n-            ast::ExprMethodCall(node_id, _, _, ref args) => {\n-                scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n-\n+            ast::ExprMethodCall(_, _, ref args) => {\n                 for arg_exp in args.iter() {\n                     walk_expr(cx, *arg_exp, scope_stack, scope_map);\n                 }"}, {"sha": "987d60957d1755a464a7035aba799f2c97f7f07c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -442,7 +442,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprField(base, ident, _) => {\n             trans_rec_field(bcx, base, ident)\n         }\n-        ast::ExprIndex(_, base, idx) => {\n+        ast::ExprIndex(base, idx) => {\n             trans_index(bcx, expr, base, idx)\n         }\n         ast::ExprVstore(contents, ast::ExprVstoreUniq) => {\n@@ -461,20 +461,17 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             return trans_boxed_expr(bcx, box_ty, contents, contents_ty, heap)\n         }\n         ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n-        ast::ExprBinary(_, op, lhs, rhs) => {\n+        ast::ExprBinary(op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n-            {\n-                let method_map = bcx.ccx().maps.method_map.borrow();\n-                assert!(!method_map.get().contains_key(&expr.id));\n-            }\n+            assert!(!bcx.ccx().maps.method_map.borrow().get().contains_key(&expr.id));\n \n             trans_binary(bcx, expr, op, lhs, rhs)\n         }\n-        ast::ExprUnary(_, ast::UnDeref, base) => {\n+        ast::ExprUnary(ast::UnDeref, base) => {\n             let basedatum = unpack_datum!(bcx, trans(bcx, base));\n             deref_once(bcx, expr, basedatum, 0)\n         }\n-        ast::ExprUnary(_, op, x) => {\n+        ast::ExprUnary(op, x) => {\n             trans_unary_datum(bcx, expr, op, x)\n         }\n         ast::ExprAddrOf(_, x) => {\n@@ -698,8 +695,8 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n                 src_datum.store_to(bcx, dst_datum.val)\n             }\n         }\n-        ast::ExprAssignOp(callee_id, op, dst, src) => {\n-            trans_assign_op(bcx, expr, callee_id, op, dst, src)\n+        ast::ExprAssignOp(op, dst, src) => {\n+            trans_assign_op(bcx, expr, op, dst, src)\n         }\n         ast::ExprInlineAsm(ref a) => {\n             asm::trans_inline_asm(bcx, a)\n@@ -780,26 +777,24 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             closure::trans_expr_fn(bcx, sigil, decl, body, expr.id, dest)\n         }\n         ast::ExprCall(f, ref args) => {\n-            callee::trans_call(bcx, expr, f,\n-                               callee::ArgExprs(*args), expr.id, dest)\n+            callee::trans_call(bcx, expr, f, callee::ArgExprs(*args), expr.id, dest)\n         }\n-        ast::ExprMethodCall(callee_id, _, _, ref args) => {\n-            callee::trans_method_call(bcx, expr, callee_id, args[0],\n-                                      callee::ArgExprs(*args), dest)\n+        ast::ExprMethodCall(_, _, ref args) => {\n+            callee::trans_method_call(bcx, expr, args[0], callee::ArgExprs(*args), dest)\n         }\n-        ast::ExprBinary(callee_id, _, lhs, rhs) => {\n+        ast::ExprBinary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, callee_id, lhs,\n+            trans_overloaded_op(bcx, expr, lhs,\n                                 Some(&*rhs), expr_ty(bcx, expr), dest)\n         }\n-        ast::ExprUnary(callee_id, _, subexpr) => {\n+        ast::ExprUnary(_, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, callee_id, subexpr,\n+            trans_overloaded_op(bcx, expr, subexpr,\n                                 None, expr_ty(bcx, expr), dest)\n         }\n-        ast::ExprIndex(callee_id, base, idx) => {\n+        ast::ExprIndex(base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, callee_id, base,\n+            trans_overloaded_op(bcx, expr, base,\n                                 Some(&*idx), expr_ty(bcx, expr), dest)\n         }\n         ast::ExprCast(val, _) => {\n@@ -815,8 +810,8 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::ExprAssignOp(callee_id, op, dst, src) => {\n-            trans_assign_op(bcx, expr, callee_id, op, dst, src)\n+        ast::ExprAssignOp(op, dst, src) => {\n+            trans_assign_op(bcx, expr, op, dst, src)\n         }\n         ast::ExprBox(_, contents) => {\n             // Special case for `Gc<T>` for now. The other case, for unique\n@@ -851,7 +846,7 @@ fn trans_def_dps_unadjusted<'a>(\n             let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n-                let llfn = callee::trans_fn_ref(bcx, vid, ref_expr.id);\n+                let llfn = callee::trans_fn_ref(bcx, vid, ref_expr.id, false);\n                 Store(bcx, llfn, lldest);\n                 return bcx;\n             } else {\n@@ -884,15 +879,14 @@ fn trans_def_dps_unadjusted<'a>(\n \n fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n                                ref_expr: &ast::Expr,\n-                               def: ast::Def) -> DatumBlock<'a, Expr>\n-{\n+                               def: ast::Def) -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let llfn = match def {\n         ast::DefFn(did, _) |\n         ast::DefStruct(did) | ast::DefVariant(_, did, _) |\n         ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n-            callee::trans_fn_ref(bcx, did, ref_expr.id)\n+            callee::trans_fn_ref(bcx, did, ref_expr.id, false)\n         }\n         ast::DefStaticMethod(impl_did, ast::FromTrait(trait_did), _) => {\n             meth::trans_static_method_callee(bcx, impl_did,\n@@ -1496,26 +1490,20 @@ fn trans_binary<'a>(\n fn trans_overloaded_op<'a, 'b>(\n                        bcx: &'a Block<'a>,\n                        expr: &ast::Expr,\n-                       callee_id: ast::NodeId,\n                        rcvr: &'b ast::Expr,\n                        arg: Option<&'b ast::Expr>,\n                        ret_ty: ty::t,\n                        dest: Dest)\n                        -> &'a Block<'a> {\n-    let origin = {\n-        let method_map = bcx.ccx().maps.method_map.borrow();\n-        method_map.get().get_copy(&expr.id)\n-    };\n-    let fty = node_id_type(bcx, callee_id);\n+    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&expr.id).ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n-                             fty,\n+                             monomorphize_type(bcx, method_ty),\n                              ret_ty,\n                              |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n-                                                          callee_id,\n+                                                          expr.id,\n                                                           rcvr,\n-                                                          origin,\n                                                           arg_cleanup_scope)\n                              },\n                              callee::ArgAutorefSecond(rcvr, arg),\n@@ -1666,7 +1654,6 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n fn trans_assign_op<'a>(\n                    bcx: &'a Block<'a>,\n                    expr: &ast::Expr,\n-                   _callee_id: ast::NodeId,\n                    op: ast::BinOp,\n                    dst: &ast::Expr,\n                    src: @ast::Expr)"}, {"sha": "a9473d9f4801996e8b7e4fc17cb7d7b66e3a6dab", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -93,21 +93,29 @@ pub fn trans_method(ccx: @CrateContext, method: &ast::Method,\n \n pub fn trans_method_callee<'a>(\n                            bcx: &'a Block<'a>,\n-                           callee_id: ast::NodeId,\n+                           expr_id: ast::NodeId,\n                            this: &ast::Expr,\n-                           origin: typeck::method_origin,\n                            arg_cleanup_scope: cleanup::ScopeId)\n                            -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n-    debug!(\"trans_method_callee(callee_id={:?}, origin={})\",\n-           callee_id, origin.repr(bcx.tcx()));\n+    let (origin, method_ty) = match bcx.ccx().maps.method_map\n+                                       .borrow().get().find(&expr_id) {\n+        Some(method) => {\n+            debug!(\"trans_method_callee(expr_id={:?}, method={})\",\n+                expr_id, method.repr(bcx.tcx()));\n+            (method.origin, method.ty)\n+        }\n+        None => {\n+            bcx.tcx().sess.span_bug(this.span, \"method call expr wasn't in method map\")\n+        }\n+    };\n \n     match origin {\n         typeck::MethodStatic(did) => {\n             Callee {\n                 bcx: bcx,\n-                data: Fn(callee::trans_fn_ref(bcx, did, callee_id))\n+                data: Fn(callee::trans_fn_ref(bcx, did, expr_id, true))\n             }\n         }\n         typeck::MethodParam(typeck::MethodParam {\n@@ -123,7 +131,7 @@ pub fn trans_method_callee<'a>(\n                         trait_id);\n \n                     let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n-                    trans_monomorphized_callee(bcx, callee_id,\n+                    trans_monomorphized_callee(bcx, expr_id,\n                                                trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n@@ -133,7 +141,7 @@ pub fn trans_method_callee<'a>(\n \n         typeck::MethodObject(ref mt) => {\n             trans_trait_callee(bcx,\n-                               callee_id,\n+                               monomorphize_type(bcx, method_ty),\n                                mt.real_index,\n                                this,\n                                arg_cleanup_scope)\n@@ -144,16 +152,16 @@ pub fn trans_method_callee<'a>(\n pub fn trans_static_method_callee(bcx: &Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n-                                  callee_id: ast::NodeId)\n+                                  expr_id: ast::NodeId)\n                                   -> ValueRef {\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n-            callee_id={:?})\",\n+            expr_id={:?})\",\n            method_id,\n            ty::item_path_str(bcx.tcx(), trait_id),\n-           callee_id);\n+           expr_id);\n     let _indenter = indenter();\n \n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trait_id);\n@@ -188,13 +196,10 @@ pub fn trans_static_method_callee(bcx: &Block,\n     } else {\n         csearch::get_item_path(bcx.tcx(), method_id).last().unwrap().name()\n     };\n-    debug!(\"trans_static_method_callee: method_id={:?}, callee_id={:?}, \\\n-            name={}\", method_id, callee_id, token::get_name(mname));\n+    debug!(\"trans_static_method_callee: method_id={:?}, expr_id={:?}, \\\n+            name={}\", method_id, expr_id, token::get_name(mname));\n \n-    let vtbls = {\n-        let vtable_map = ccx.maps.vtable_map.borrow();\n-        vtable_map.get().get_copy(&callee_id)\n-    };\n+    let vtbls = ccx.maps.vtable_map.borrow().get().get_copy(&expr_id);\n     let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, vtbls);\n \n     match vtbls[bound_index][0] {\n@@ -204,14 +209,14 @@ pub fn trans_static_method_callee(bcx: &Block,\n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n-                    bcx, mth_id, callee_id,\n+                    bcx, mth_id, expr_id, false,\n                     *rcvr_substs, rcvr_origins);\n \n-            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, callee_id,\n-                                                 callee_substs,\n+            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, expr_id,\n+                                                 false, callee_substs,\n                                                  Some(callee_origins));\n \n-            let callee_ty = node_id_type(bcx, callee_id);\n+            let callee_ty = node_id_type(bcx, expr_id);\n             let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n             PointerCast(bcx, llfn, llty)\n         }\n@@ -246,13 +251,13 @@ pub fn method_with_name(ccx: &CrateContext,\n }\n \n fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n-                                  callee_id: ast::NodeId,\n+                                  expr_id: ast::NodeId,\n                                   trait_id: ast::DefId,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n                                   -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n-    return match vtbl {\n+    match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n@@ -262,13 +267,14 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           // those from the impl and those from the method:\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n-                  bcx, mth_id, callee_id,\n+                  bcx, mth_id, expr_id, true,\n                   *rcvr_substs, rcvr_origins);\n \n           // translate the function\n           let llfn = trans_fn_ref_with_vtables(bcx,\n                                                mth_id,\n-                                               callee_id,\n+                                               expr_id,\n+                                               true,\n                                                callee_substs,\n                                                Some(callee_origins));\n \n@@ -277,16 +283,16 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n       typeck::vtable_param(..) => {\n           fail!(\"vtable_param left in monomorphized function's vtable substs\");\n       }\n-    };\n-\n+    }\n }\n \n-pub fn combine_impl_and_methods_tps(bcx: &Block,\n-                                    mth_did: ast::DefId,\n-                                    callee_id: ast::NodeId,\n-                                    rcvr_substs: &[ty::t],\n-                                    rcvr_origins: typeck::vtable_res)\n-                                    -> (~[ty::t], typeck::vtable_res) {\n+fn combine_impl_and_methods_tps(bcx: &Block,\n+                                mth_did: ast::DefId,\n+                                expr_id: ast::NodeId,\n+                                is_method: bool,\n+                                rcvr_substs: &[ty::t],\n+                                rcvr_origins: typeck::vtable_res)\n+                                -> (~[ty::t], typeck::vtable_res) {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -307,7 +313,7 @@ pub fn combine_impl_and_methods_tps(bcx: &Block,\n     let ccx = bcx.ccx();\n     let method = ty::method(ccx.tcx, mth_did);\n     let n_m_tps = method.generics.type_param_defs().len();\n-    let node_substs = node_id_type_params(bcx, callee_id);\n+    let node_substs = node_id_type_params(bcx, expr_id, is_method);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n         = vec::append(rcvr_substs.to_owned(),\n@@ -319,19 +325,19 @@ pub fn combine_impl_and_methods_tps(bcx: &Block,\n \n     // Now, do the same work for the vtables.  The vtables might not\n     // exist, in which case we need to make them.\n-    let r_m_origins = match node_vtables(bcx, callee_id) {\n+    let r_m_origins = match node_vtables(bcx, expr_id) {\n         Some(vt) => vt,\n         None => @vec::from_elem(node_substs.len(), @~[])\n     };\n     let vtables\n         = @vec::append(rcvr_origins.to_owned(),\n                        r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n \n-    return (ty_substs, vtables);\n+    (ty_substs, vtables)\n }\n \n fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n-                          callee_id: ast::NodeId,\n+                          method_ty: ty::t,\n                           n_method: uint,\n                           self_expr: &ast::Expr,\n                           arg_cleanup_scope: cleanup::ScopeId)\n@@ -371,8 +377,7 @@ fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n         self_datum.val\n     };\n \n-    let callee_ty = node_id_type(bcx, callee_id);\n-    trans_trait_callee_from_llval(bcx, callee_ty, n_method, llval)\n+    trans_trait_callee_from_llval(bcx, method_ty, n_method, llval)\n }\n \n pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n@@ -540,7 +545,7 @@ fn emit_vtable_methods(bcx: &Block,\n                    token::get_ident(ident));\n             C_null(Type::nil().ptr_to())\n         } else {\n-            trans_fn_ref_with_vtables(bcx, m_id, 0, substs, Some(vtables))\n+            trans_fn_ref_with_vtables(bcx, m_id, 0, false, substs, Some(vtables))\n         }\n     })\n }"}, {"sha": "7e047ae8c105de4932452b99ec30c08d7ecc72d6", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -33,8 +33,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                       vtables: Option<typeck::vtable_res>,\n                       self_vtables: Option<typeck::vtable_param_res>,\n                       ref_id: Option<ast::NodeId>)\n-    -> (ValueRef, bool)\n-{\n+    -> (ValueRef, bool) {\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n@@ -280,7 +279,6 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         ast_map::NodeStmt(..) |\n         ast_map::NodeArg(..) |\n         ast_map::NodeBlock(..) |\n-        ast_map::NodeCalleeScope(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.tcx.sess.bug(format!(\"can't monomorphize a {:?}\", map_node))\n         }"}, {"sha": "6db83ff32b6f9cb09bf52d8c94174d9e92fc9760", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -3372,7 +3372,7 @@ pub fn expr_kind(tcx: ctxt,\n             }\n         }\n \n-        ast::ExprUnary(_, ast::UnDeref, _) |\n+        ast::ExprUnary(ast::UnDeref, _) |\n         ast::ExprField(..) |\n         ast::ExprIndex(..) => {\n             LvalueExpr"}, {"sha": "aff41ce1979c067ef44c20b3ed99ceaa785beed6", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -89,6 +89,7 @@ use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::check::vtable;\n use middle::typeck::check;\n use middle::typeck::infer;\n+use middle::typeck::MethodCallee;\n use middle::typeck::{MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodObject};\n use middle::typeck::{param_numbered, param_self, param_index};\n@@ -101,7 +102,7 @@ use collections::HashSet;\n use std::result;\n use std::vec;\n use syntax::ast::{DefId, SelfValue, SelfRegion};\n-use syntax::ast::{SelfUniq, SelfStatic, NodeId};\n+use syntax::ast::{SelfUniq, SelfStatic};\n use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n use syntax::parse::token;\n@@ -124,20 +125,17 @@ pub fn lookup(\n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: &ast::Expr,                   // The expression `a.b(...)`.\n         self_expr: &ast::Expr,              // The expression `a`.\n-        callee_id: NodeId,                  /* Where to store `a.b`'s type,\n-                                             * also the scope of the call */\n         m_name: ast::Name,                  // The name `b`.\n         self_ty: ty::t,                     // The type of `a`.\n         supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n-     -> Option<method_origin> {\n+     -> Option<MethodCallee> {\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n         self_expr: self_expr,\n-        callee_id: callee_id,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: @RefCell::new(HashSet::new()),\n@@ -173,19 +171,16 @@ pub fn lookup_in_trait(\n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: &ast::Expr,                   // The expression `a.b(...)`.\n         self_expr: &ast::Expr,              // The expression `a`.\n-        callee_id: NodeId,                  /* Where to store `a.b`'s type,\n-                                             * also the scope of the call */\n         m_name: ast::Name,                  // The name `b`.\n         trait_did: DefId,                   // The trait to limit the lookup to.\n         self_ty: ty::t,                     // The type of `a`.\n         supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n         autoderef_receiver: AutoderefReceiverFlag)\n-     -> Option<method_origin> {\n+     -> Option<MethodCallee> {\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n         self_expr: self_expr,\n-        callee_id: callee_id,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: @RefCell::new(HashSet::new()),\n@@ -210,7 +205,6 @@ pub struct LookupContext<'a> {\n     fcx: @FnCtxt,\n     expr: &'a ast::Expr,\n     self_expr: &'a ast::Expr,\n-    callee_id: NodeId,\n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n     impl_dups: @RefCell<HashSet<DefId>>,\n@@ -248,7 +242,7 @@ enum RcvrMatchCondition {\n }\n \n impl<'a> LookupContext<'a> {\n-    fn search(&self, self_ty: ty::t) -> Option<method_origin> {\n+    fn search(&self, self_ty: ty::t) -> Option<MethodCallee> {\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n@@ -636,7 +630,7 @@ impl<'a> LookupContext<'a> {\n     fn search_for_autoderefd_method(&self,\n                                         self_ty: ty::t,\n                                         autoderefs: uint)\n-                                        -> Option<method_origin> {\n+                                        -> Option<MethodCallee> {\n         let (self_ty, autoadjust) =\n             self.consider_reborrow(self_ty, autoderefs);\n         match self.search_for_method(self_ty) {\n@@ -732,7 +726,7 @@ impl<'a> LookupContext<'a> {\n     fn search_for_autosliced_method(&self,\n                                     self_ty: ty::t,\n                                     autoderefs: uint)\n-                                    -> Option<method_origin> {\n+                                    -> Option<MethodCallee> {\n         /*!\n          *\n          * Searches for a candidate by converting things like\n@@ -807,7 +801,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n-                                  -> Option<method_origin> {\n+                                  -> Option<MethodCallee> {\n         /*!\n          *\n          * Converts any type `T` to `&M T` where `M` is an\n@@ -843,7 +837,7 @@ impl<'a> LookupContext<'a> {\n             autoderefs: uint,\n             mutbls: &[ast::Mutability],\n             mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n-            -> Option<method_origin> {\n+            -> Option<MethodCallee> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region =\n@@ -867,7 +861,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn search_for_method(&self, rcvr_ty: ty::t)\n-                         -> Option<method_origin> {\n+                         -> Option<MethodCallee> {\n         debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n@@ -899,7 +893,7 @@ impl<'a> LookupContext<'a> {\n     fn consider_candidates(&self,\n                            rcvr_ty: ty::t,\n                            candidates: &mut ~[Candidate])\n-                           -> Option<method_origin> {\n+                           -> Option<MethodCallee> {\n         // FIXME(pcwalton): Do we need to clone here?\n         let relevant_candidates: ~[Candidate] =\n             candidates.iter().map(|c| (*c).clone()).\n@@ -970,7 +964,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n-                         -> method_origin {\n+                         -> MethodCallee {\n         // This method performs two sets of substitutions, one after the other:\n         // 1. Substitute values for any type/lifetime parameters from the impl and\n         //    method declaration into the method type. This is the function type\n@@ -1079,9 +1073,11 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n-        self.fcx.write_ty(self.callee_id, fty);\n-        self.fcx.write_substs(self.callee_id, all_substs);\n-        candidate.origin\n+        MethodCallee {\n+            origin: candidate.origin,\n+            ty: fty,\n+            substs: all_substs\n+        }\n     }\n \n     fn construct_transformed_self_ty_for_object("}, {"sha": "9b8ce481de958345aeef0b473505d2cdf6caa0c8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -1088,8 +1088,7 @@ impl FnCtxt {\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n-        let node_types = self.inh.node_types.borrow();\n-        match node_types.get().find(&id) {\n+        match self.inh.node_types.borrow().get().find(&id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -1100,9 +1099,20 @@ impl FnCtxt {\n         }\n     }\n \n+    pub fn method_ty(&self, id: ast::NodeId) -> ty::t {\n+        match self.inh.method_map.borrow().get().find(&id) {\n+            Some(method) => method.ty,\n+            None => {\n+                self.tcx().sess.bug(\n+                    format!(\"no method entry for node {}: {} in fcx {}\",\n+                            id, self.tcx().map.node_to_str(id),\n+                            self.tag()));\n+            }\n+        }\n+    }\n+\n     pub fn node_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n-        let mut node_type_substs = self.inh.node_type_substs.borrow_mut();\n-        match node_type_substs.get().find(&id) {\n+        match self.inh.node_type_substs.borrow().get().find(&id) {\n             Some(ts) => (*ts).clone(),\n             None => {\n                 self.tcx().sess.bug(\n@@ -1113,6 +1123,18 @@ impl FnCtxt {\n         }\n     }\n \n+    pub fn method_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n+        match self.inh.method_map.borrow().get().find(&id) {\n+            Some(method) => method.substs.clone(),\n+            None => {\n+                self.tcx().sess.bug(\n+                    format!(\"no method entry for node {}: {} in fcx {}\",\n+                            id, self.tcx().map.node_to_str(id),\n+                            self.tag()));\n+            }\n+        }\n+    }\n+\n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n                               f: |&ty::substs| -> bool)\n@@ -1776,7 +1798,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @FnCtxt,\n-                  callee_id: ast::NodeId,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n                   args: &[@ast::Expr]) {\n@@ -1787,13 +1808,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n-        // FIXME(#6273) should write callee type AFTER regions have\n-        // been subst'd.  However, it is awkward to deal with this\n-        // now. Best thing would I think be to just have a separate\n-        // \"callee table\" that contains the FnSig and not a general\n-        // purpose ty::t\n-        fcx.write_ty(callee_id, fn_ty);\n-\n         // Extract the function signature from `in_fty`.\n         let fn_sty = structure_of(fcx, f.span, fn_ty);\n \n@@ -1834,7 +1848,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     // Checks a method call.\n     fn check_method_call(fcx: @FnCtxt,\n-                         callee_id: ast::NodeId,\n                          expr: &ast::Expr,\n                          method_name: ast::Ident,\n                          args: &[@ast::Expr],\n@@ -1848,20 +1861,16 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                 fcx.expr_ty(rcvr));\n \n         let tps = tps.map(|&ast_ty| fcx.to_ty(ast_ty));\n-        match method::lookup(fcx,\n-                             expr,\n-                             rcvr,\n-                             callee_id,\n-                             method_name.name,\n-                             expr_t,\n-                             tps,\n-                             DontDerefArgs,\n-                             CheckTraitsAndInherentMethods,\n-                             AutoderefReceiver) {\n-            Some(ref entry) => {\n-                let method_map = fcx.inh.method_map;\n-                let mut method_map = method_map.borrow_mut();\n-                method_map.get().insert(expr.id, (*entry));\n+        let fn_ty = match method::lookup(fcx, expr, rcvr,\n+                                         method_name.name,\n+                                         expr_t, tps,\n+                                         DontDerefArgs,\n+                                         CheckTraitsAndInherentMethods,\n+                                         AutoderefReceiver) {\n+            Some(method) => {\n+                let method_ty = method.ty;\n+                fcx.inh.method_map.borrow_mut().get().insert(expr.id, method);\n+                method_ty\n             }\n             None => {\n                 debug!(\"(checking method call) failing expr is {}\", expr.id);\n@@ -1877,12 +1886,11 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n                 // Add error type for the result\n                 fcx.write_error(expr.id);\n-                fcx.write_error(callee_id);\n+                ty::mk_err()\n             }\n-        }\n+        };\n \n         // Call the generic checker.\n-        let fn_ty = fcx.node_ty(callee_id);\n         let ret_ty = check_method_argument_types(fcx, expr.span,\n                                                  fn_ty, expr, args,\n                                                  DontDerefArgs);\n@@ -1932,26 +1940,24 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     fn lookup_op_method(fcx: @FnCtxt,\n-                        callee_id: ast::NodeId,\n                         op_ex: &ast::Expr,\n                         self_t: ty::t,\n                         opname: ast::Name,\n                         trait_did: Option<ast::DefId>,\n                         args: &[@ast::Expr],\n                         autoderef_receiver: AutoderefReceiverFlag,\n                         unbound_method: ||) -> ty::t {\n-        let origin = match trait_did {\n+        let method = match trait_did {\n             Some(trait_did) => {\n-                method::lookup_in_trait(fcx, op_ex, args[0], callee_id, opname,\n-                                        trait_did, self_t, [], autoderef_receiver)\n+                method::lookup_in_trait(fcx, op_ex, args[0], opname, trait_did,\n+                                        self_t, [], autoderef_receiver)\n             }\n             None => None\n         };\n-        match origin {\n-            Some(origin) => {\n-                let method_ty = fcx.node_ty(callee_id);\n-                let method_map = fcx.inh.method_map;\n-                method_map.borrow_mut().get().insert(op_ex.id, origin);\n+        match method {\n+            Some(method) => {\n+                let method_ty = method.ty;\n+                fcx.inh.method_map.borrow_mut().get().insert(op_ex.id, method);\n                 check_method_argument_types(fcx, op_ex.span,\n                                             method_ty, op_ex,\n                                             args, DoDerefArgs)\n@@ -1971,7 +1977,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     // could be either an expr_binop or an expr_assign_binop\n     fn check_binop(fcx: @FnCtxt,\n-                   callee_id: ast::NodeId,\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n                    lhs: @ast::Expr,\n@@ -2023,7 +2028,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n         // Check for overloaded operators if not an assignment.\n         let result_t = if is_binop_assignment == SimpleBinop {\n-            check_user_binop(fcx, callee_id, expr, lhs, lhs_t, op, rhs)\n+            check_user_binop(fcx, expr, lhs, lhs_t, op, rhs)\n         } else {\n             fcx.type_error_message(expr.span,\n                                    |actual| {\n@@ -2045,7 +2050,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     fn check_user_binop(fcx: @FnCtxt,\n-                        callee_id: ast::NodeId,\n                         ex: &ast::Expr,\n                         lhs_expr: @ast::Expr,\n                         lhs_resolved_t: ty::t,\n@@ -2075,7 +2079,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 return ty::mk_err();\n             }\n         };\n-        lookup_op_method(fcx, callee_id, ex, lhs_resolved_t, token::intern(name),\n+        lookup_op_method(fcx, ex, lhs_resolved_t, token::intern(name),\n                          trait_did, [lhs_expr, rhs], DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"binary operation `{}` cannot be applied to type `{}`\",\n@@ -2085,14 +2089,13 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     fn check_user_unop(fcx: @FnCtxt,\n-                       callee_id: ast::NodeId,\n                        op_str: &str,\n                        mname: &str,\n                        trait_did: Option<ast::DefId>,\n                        ex: &ast::Expr,\n                        rhs_expr: @ast::Expr,\n                        rhs_t: ty::t) -> ty::t {\n-       lookup_op_method(fcx, callee_id, ex, rhs_t, token::intern(mname),\n+       lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n                         trait_did, [rhs_expr], DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"cannot apply unary operator `{}` to type `{}`\", op_str, actual)\n@@ -2264,7 +2267,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         match method::lookup(fcx,\n                              expr,\n                              base,\n-                             expr.id,\n                              field,\n                              expr_t,\n                              tps,\n@@ -2620,8 +2622,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         let typ = check_lit(fcx, lit);\n         fcx.write_ty(id, typ);\n       }\n-      ast::ExprBinary(callee_id, op, lhs, rhs) => {\n-        check_binop(fcx, callee_id, expr, op, lhs, rhs, SimpleBinop);\n+      ast::ExprBinary(op, lhs, rhs) => {\n+        check_binop(fcx, expr, op, lhs, rhs, SimpleBinop);\n \n         let lhs_ty = fcx.expr_ty(lhs);\n         let rhs_ty = fcx.expr_ty(rhs);\n@@ -2634,8 +2636,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::ExprAssignOp(callee_id, op, lhs, rhs) => {\n-        check_binop(fcx, callee_id, expr, op, lhs, rhs, BinopAssignment);\n+      ast::ExprAssignOp(op, lhs, rhs) => {\n+        check_binop(fcx, expr, op, lhs, rhs, BinopAssignment);\n \n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n@@ -2654,7 +2656,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             fcx.write_nil(expr.id);\n         }\n       }\n-      ast::ExprUnary(callee_id, unop, oprnd) => {\n+      ast::ExprUnary(unop, oprnd) => {\n         let exp_inner = unpack_expected(fcx, expected, |sty| {\n             match unop {\n                 ast::UnBox | ast::UnUniq => match *sty {\n@@ -2710,7 +2712,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n-                        oprnd_t = check_user_unop(fcx, callee_id, \"!\", \"not\",\n+                        oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n                                                   tcx.lang_items.not_trait(),\n                                                   expr, oprnd, oprnd_t);\n                     }\n@@ -2720,7 +2722,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::type_is_fp(oprnd_t)) {\n-                        oprnd_t = check_user_unop(fcx, callee_id, \"-\", \"neg\",\n+                        oprnd_t = check_user_unop(fcx, \"-\", \"neg\",\n                                                   tcx.lang_items.neg_trait(),\n                                                   expr, oprnd, oprnd_t);\n                     }\n@@ -2883,7 +2885,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(f, ref args) => {\n-          check_call(fcx, expr.id, expr, f, *args);\n+          check_call(fcx, expr, f, *args);\n           let f_ty = fcx.expr_ty(f);\n           let (args_bot, args_err) = args.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {\n@@ -2898,8 +2900,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n               fcx.write_bot(id);\n           }\n       }\n-      ast::ExprMethodCall(callee_id, ident, ref tps, ref args) => {\n-        check_method_call(fcx, callee_id, expr, ident, *args, *tps);\n+      ast::ExprMethodCall(ident, ref tps, ref args) => {\n+        check_method_call(fcx, expr, ident, *args, *tps);\n         let arg_tys = args.map(|a| fcx.expr_ty(*a));\n         let (args_bot, args_err) = arg_tys.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {\n@@ -3100,7 +3102,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n       ast::ExprField(base, field, ref tys) => {\n         check_field(fcx, expr, base, field.name, *tys);\n       }\n-      ast::ExprIndex(callee_id, base, idx) => {\n+      ast::ExprIndex(base, idx) => {\n           check_expr(fcx, base);\n           check_expr(fcx, idx);\n           let raw_base_t = fcx.expr_ty(base);\n@@ -3133,7 +3135,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                None);\n                       };\n                       let ret_ty = lookup_op_method(fcx,\n-                                                    callee_id,\n                                                     expr,\n                                                     resolved,\n                                                     token::intern(\"index\"),"}, {"sha": "5e2ad9fc35bd0cb0738b60d6c94e6c7010847567", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -226,6 +226,12 @@ impl Rcx {\n         self.resolve_type(t)\n     }\n \n+    /// Try to resolve the callee type for the given method call.\n+    pub fn resolve_method_type(&mut self, id: ast::NodeId) -> ty::t {\n+        let t = self.fcx.method_ty(id);\n+        self.resolve_type(t)\n+    }\n+\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n@@ -378,10 +384,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n-    let has_method_map = {\n-        let method_map = rcx.fcx.inh.method_map;\n-        method_map.get().contains_key(&expr.id)\n-    };\n+    let has_method_map = rcx.fcx.inh.method_map.get().contains_key(&expr.id);\n \n     // Check any autoderefs or autorefs that appear.\n     {\n@@ -434,13 +437,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     match expr.node {\n         ast::ExprCall(callee, ref args) => {\n             constrain_callee(rcx, callee.id, expr, callee);\n-            constrain_call(rcx, callee.id, expr, None, *args, false);\n+            constrain_call(rcx, Some(callee.id), expr, None, *args, false);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprMethodCall(callee_id, _, _, ref args) => {\n-            constrain_call(rcx, callee_id, expr, Some(args[0]),\n+        ast::ExprMethodCall(_, _, ref args) => {\n+            constrain_call(rcx, None, expr, Some(args[0]),\n                            args.slice_from(1), false);\n \n             visit::walk_expr(rcx, expr, ());\n@@ -451,43 +454,43 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAssignOp(callee_id, _, lhs, rhs) => {\n+        ast::ExprAssignOp(_, lhs, rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, callee_id, expr, Some(lhs), [rhs], true);\n+                constrain_call(rcx, None, expr, Some(lhs), [rhs], true);\n             }\n \n             adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprIndex(callee_id, lhs, rhs) |\n-        ast::ExprBinary(callee_id, _, lhs, rhs) if has_method_map => {\n+        ast::ExprIndex(lhs, rhs) |\n+        ast::ExprBinary(_, lhs, rhs) if has_method_map => {\n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, callee_id, expr, Some(lhs), [rhs], true);\n+            constrain_call(rcx, None, expr, Some(lhs), [rhs], true);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprUnary(callee_id, _, lhs) if has_method_map => {\n+        ast::ExprUnary(_, lhs) if has_method_map => {\n             // As above.\n-            constrain_call(rcx, callee_id, expr, Some(lhs), [], true);\n+            constrain_call(rcx, None, expr, Some(lhs), [], true);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprUnary(_, ast::UnDeref, base) => {\n+        ast::ExprUnary(ast::UnDeref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let base_ty = rcx.resolve_node_type(base.id);\n             constrain_derefs(rcx, expr, 1, base_ty);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprIndex(_, vec_expr, _) => {\n+        ast::ExprIndex(vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n             let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n             constrain_index(rcx, expr, vec_type);\n@@ -711,8 +714,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n fn constrain_callee(rcx: &mut Rcx,\n                     callee_id: ast::NodeId,\n                     call_expr: &ast::Expr,\n-                    callee_expr: &ast::Expr)\n-{\n+                    callee_expr: &ast::Expr) {\n     let call_region = ty::ReScope(call_expr.id);\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n@@ -736,12 +738,11 @@ fn constrain_callee(rcx: &mut Rcx,\n fn constrain_call(rcx: &mut Rcx,\n                   // might be expr_call, expr_method_call, or an overloaded\n                   // operator\n-                  callee_id: ast::NodeId,\n+                  fn_expr_id: Option<ast::NodeId>,\n                   call_expr: &ast::Expr,\n                   receiver: Option<@ast::Expr>,\n                   arg_exprs: &[@ast::Expr],\n-                  implicitly_ref_args: bool)\n-{\n+                  implicitly_ref_args: bool) {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n     //! and overloaded operators). Constrains the regions which appear\n     //! in the type of the function. Also constrains the regions that\n@@ -756,7 +757,10 @@ fn constrain_call(rcx: &mut Rcx,\n             receiver.repr(tcx),\n             arg_exprs.repr(tcx),\n             implicitly_ref_args);\n-    let callee_ty = rcx.resolve_node_type(callee_id);\n+    let callee_ty = match fn_expr_id {\n+        Some(id) => rcx.resolve_node_type(id),\n+        None => rcx.resolve_method_type(call_expr.id)\n+    };\n     if ty::type_is_error(callee_ty) {\n         // Bail, as function type is unknown\n         return;"}, {"sha": "a9ea968fe1d19d6da361a5ff41c857a56e17c1ca", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -537,11 +537,10 @@ fn connect_trait_tps(vcx: &VtableContext,\n     relate_trait_refs(vcx, location_info, impl_trait_ref, trait_ref);\n }\n \n-fn insert_vtables(fcx: &FnCtxt, callee_id: ast::NodeId, vtables: vtable_res) {\n-    debug!(\"insert_vtables(callee_id={}, vtables={:?})\",\n-           callee_id, vtables.repr(fcx.tcx()));\n-    let mut vtable_map = fcx.inh.vtable_map.borrow_mut();\n-    vtable_map.get().insert(callee_id, vtables);\n+fn insert_vtables(fcx: &FnCtxt, expr_id: ast::NodeId, vtables: vtable_res) {\n+    debug!(\"insert_vtables(expr_id={}, vtables={:?})\",\n+           expr_id, vtables.repr(fcx.tcx()));\n+    fcx.inh.vtable_map.borrow_mut().get().insert(expr_id, vtables);\n }\n \n pub fn location_info_for_expr(expr: &ast::Expr) -> LocationInfo {\n@@ -692,23 +691,23 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       }\n \n       // Must resolve bounds on methods with bounded params\n-      ast::ExprBinary(callee_id, _, _, _) |\n-      ast::ExprUnary(callee_id, _, _) |\n-      ast::ExprAssignOp(callee_id, _, _, _) |\n-      ast::ExprIndex(callee_id, _, _) |\n-      ast::ExprMethodCall(callee_id, _, _, _) => {\n+      ast::ExprBinary(_, _, _) |\n+      ast::ExprUnary(_, _) |\n+      ast::ExprAssignOp(_, _, _) |\n+      ast::ExprIndex(_, _) |\n+      ast::ExprMethodCall(_, _, _) => {\n         match fcx.inh.method_map.borrow().get().find(&ex.id) {\n-          Some(origin) => {\n+          Some(method) => {\n             debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n-            let type_param_defs = ty::method_call_type_param_defs(cx.tcx, *origin);\n+            let type_param_defs = ty::method_call_type_param_defs(cx.tcx, method.origin);\n             if has_trait_bounds(*type_param_defs.borrow()) {\n-                let substs = fcx.node_ty_substs(callee_id);\n+                let substs = fcx.method_ty_substs(ex.id);\n                 let vcx = fcx.vtable_context();\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            *type_param_defs.borrow(), &substs, is_early);\n                 if !is_early {\n-                    insert_vtables(fcx, callee_id, vtbls);\n+                    insert_vtables(fcx, ex.id, vtbls);\n                 }\n             }\n           }"}, {"sha": "ec230761d350fc22a995d33a9490e9f1d547dc69", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 44, "deletions": 70, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -20,6 +20,7 @@ use middle::typeck::check::FnCtxt;\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n+use middle::typeck::MethodCallee;\n use middle::typeck::{vtable_res, vtable_origin};\n use middle::typeck::{vtable_static, vtable_param};\n use middle::typeck::write_substs_to_tcx;\n@@ -61,39 +62,54 @@ fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n     })\n }\n \n-fn resolve_method_map_entry(fcx: @FnCtxt, id: ast::NodeId) {\n+fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n+    let fcx = wbcx.fcx;\n+    let tcx = fcx.ccx.tcx;\n+\n     // Resolve any method map entry\n-    let method_map_entry_opt = {\n-        let method_map = fcx.inh.method_map.borrow();\n-        method_map.get().find_copy(&id)\n-    };\n-    match method_map_entry_opt {\n-        None => {}\n-        Some(mme) => {\n-            debug!(\"writeback::resolve_method_map_entry(id={:?}, entry={:?})\", id, mme);\n-            let mut method_map = fcx.ccx.method_map.borrow_mut();\n-            method_map.get().insert(id, mme);\n+    match fcx.inh.method_map.borrow().get().find(&id) {\n+        Some(method) => {\n+            debug!(\"writeback::resolve_method_map_entry(id={:?}, entry={:?})\",\n+                   id, method.repr(tcx));\n+            let method_ty = match resolve_type_vars_in_type(fcx, sp, method.ty) {\n+                Some(t) => t,\n+                None => {\n+                    wbcx.success = false;\n+                    return;\n+                }\n+            };\n+            let mut new_tps = ~[];\n+            for &subst in method.substs.tps.iter() {\n+                match resolve_type_vars_in_type(fcx, sp, subst) {\n+                    Some(t) => new_tps.push(t),\n+                    None => { wbcx.success = false; return; }\n+                }\n+            }\n+            let new_method = MethodCallee {\n+                origin: method.origin,\n+                ty: method_ty,\n+                substs: ty::substs {\n+                    tps: new_tps,\n+                    regions: ty::ErasedRegions,\n+                    self_ty: None\n+                }\n+            };\n+            fcx.ccx.method_map.borrow_mut().get().insert(id, new_method);\n         }\n+        None => {}\n     }\n }\n \n fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n-    // Resolve any method map entry\n-    {\n-        let origins_opt = {\n-            let vtable_map = fcx.inh.vtable_map.borrow();\n-            vtable_map.get().find_copy(&id)\n-        };\n-        match origins_opt {\n-            None => {}\n-            Some(origins) => {\n-                let r_origins = resolve_origins(fcx, sp, origins);\n-                let mut vtable_map = fcx.ccx.vtable_map.borrow_mut();\n-                vtable_map.get().insert(id, r_origins);\n-                debug!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n-                       id, r_origins.repr(fcx.tcx()));\n-            }\n+    // Resolve any vtable map entry\n+    match fcx.inh.vtable_map.borrow().get().find_copy(&id) {\n+        Some(origins) => {\n+            let r_origins = resolve_origins(fcx, sp, origins);\n+            fcx.ccx.vtable_map.borrow_mut().get().insert(id, r_origins);\n+            debug!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n+                    id, r_origins.repr(fcx.tcx()));\n         }\n+        None => {}\n     }\n \n     fn resolve_origins(fcx: @FnCtxt, sp: Span,\n@@ -241,21 +257,6 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n     }\n }\n \n-fn maybe_resolve_type_vars_for_node(wbcx: &mut WbCtxt,\n-                                    sp: Span,\n-                                    id: ast::NodeId)\n-                                 -> Option<ty::t> {\n-    let contained = {\n-        let node_types = wbcx.fcx.inh.node_types.borrow();\n-        node_types.get().contains_key(&id)\n-    };\n-    if contained {\n-        resolve_type_vars_for_node(wbcx, sp, id)\n-    } else {\n-        None\n-    }\n-}\n-\n struct WbCtxt {\n     fcx: @FnCtxt,\n \n@@ -276,43 +277,16 @@ fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n     }\n \n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n-\n-    resolve_method_map_entry(wbcx.fcx, e.id);\n-    {\n-        let r = e.get_callee_id();\n-        for callee_id in r.iter() {\n-            resolve_method_map_entry(wbcx.fcx, *callee_id);\n-        }\n-    }\n-\n+    resolve_method_map_entry(wbcx, e.span, e.id);\n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n-    {\n-        let r = e.get_callee_id();\n-        for callee_id in r.iter() {\n-            resolve_vtable_map_entry(wbcx.fcx, e.span, *callee_id);\n-        }\n-    }\n \n     match e.node {\n         ast::ExprFnBlock(ref decl, _) | ast::ExprProc(ref decl, _) => {\n             for input in decl.inputs.iter() {\n                 let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n         }\n-\n-        ast::ExprBinary(callee_id, _, _, _) |\n-        ast::ExprUnary(callee_id, _, _) |\n-        ast::ExprAssignOp(callee_id, _, _, _) |\n-        ast::ExprIndex(callee_id, _, _) => {\n-            maybe_resolve_type_vars_for_node(wbcx, e.span, callee_id);\n-        }\n-\n-        ast::ExprMethodCall(callee_id, _, _, _) => {\n-            // We must always have written in a callee ID type for these.\n-            resolve_type_vars_for_node(wbcx, e.span, callee_id);\n-        }\n-\n-        _ => ()\n+        _ => {}\n     }\n \n     visit::walk_expr(wbcx, e, ());"}, {"sha": "c04e4f24b0db0f18f71e08d3fd63567b2204cffb", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -142,9 +142,16 @@ pub struct MethodObject {\n     real_index: uint,\n }\n \n+#[deriving(Clone)]\n+pub struct MethodCallee {\n+    origin: MethodOrigin,\n+    ty: ty::t,\n+    substs: ty::substs\n+}\n+\n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type method_map = @RefCell<HashMap<ast::NodeId, method_origin>>;\n+pub type MethodMap = @RefCell<HashMap<ast::NodeId, MethodCallee>>;\n \n pub type vtable_param_res = @~[vtable_origin];\n // Resolutions for bounds of all parameters, left to right, for a given path."}, {"sha": "b47143869e9fcef3b45c91b511f8f44578320020", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -74,9 +74,6 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           Some(ast_map::NodeBlock(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n-          Some(ast_map::NodeCalleeScope(expr)) => {\n-              explain_span(cx, \"callee\", expr.span)\n-          }\n           Some(ast_map::NodeExpr(expr)) => {\n             match expr.node {\n               ast::ExprCall(..) => explain_span(cx, \"call\", expr.span),\n@@ -870,6 +867,15 @@ impl Repr for ty::FnSig {\n     }\n }\n \n+impl Repr for typeck::MethodCallee {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"MethodCallee \\\\{origin: {}, ty: {}, {}\\\\}\",\n+            self.origin.repr(tcx),\n+            self.ty.repr(tcx),\n+            self.substs.repr(tcx))\n+    }\n+}\n+\n impl Repr for typeck::MethodOrigin {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {"}, {"sha": "f6dca713e711eb957ccefe6f731d945f9bc78d67", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -521,30 +521,17 @@ pub struct Expr {\n     span: Span,\n }\n \n-impl Expr {\n-    pub fn get_callee_id(&self) -> Option<NodeId> {\n-        match self.node {\n-            ExprMethodCall(callee_id, _, _, _) |\n-            ExprIndex(callee_id, _, _) |\n-            ExprBinary(callee_id, _, _, _) |\n-            ExprAssignOp(callee_id, _, _, _) |\n-            ExprUnary(callee_id, _, _) => Some(callee_id),\n-            _ => None,\n-        }\n-    }\n-}\n-\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n     ExprBox(@Expr, @Expr),\n     ExprVec(~[@Expr], Mutability),\n     ExprCall(@Expr, ~[@Expr]),\n-    ExprMethodCall(NodeId, Ident, ~[P<Ty>], ~[@Expr]),\n+    ExprMethodCall(Ident, ~[P<Ty>], ~[@Expr]),\n     ExprTup(~[@Expr]),\n-    ExprBinary(NodeId, BinOp, @Expr, @Expr),\n-    ExprUnary(NodeId, UnOp, @Expr),\n+    ExprBinary(BinOp, @Expr, @Expr),\n+    ExprUnary(UnOp, @Expr),\n     ExprLit(@Lit),\n     ExprCast(@Expr, P<Ty>),\n     ExprIf(@Expr, P<Block>, Option<@Expr>),\n@@ -560,9 +547,9 @@ pub enum Expr_ {\n     ExprBlock(P<Block>),\n \n     ExprAssign(@Expr, @Expr),\n-    ExprAssignOp(NodeId, BinOp, @Expr, @Expr),\n+    ExprAssignOp(BinOp, @Expr, @Expr),\n     ExprField(@Expr, Ident, ~[P<Ty>]),\n-    ExprIndex(NodeId, @Expr, @Expr),\n+    ExprIndex(@Expr, @Expr),\n \n     /// Expression that looks like a \"name\". For example,\n     /// `std::vec::from_elem::<uint>` is an ExprPath that's the \"name\" part"}, {"sha": "31c258b36c02bfd862946dd0820ca27b344bbad8", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -107,7 +107,6 @@ pub enum Node {\n \n     /// NodeStructCtor represents a tuple struct.\n     NodeStructCtor(@StructDef),\n-    NodeCalleeScope(@Expr),\n }\n \n // The odd layout is to bring down the total size.\n@@ -128,7 +127,6 @@ enum MapEntry {\n     EntryLocal(NodeId, @Pat),\n     EntryBlock(NodeId, P<Block>),\n     EntryStructCtor(NodeId, @StructDef),\n-    EntryCalleeScope(NodeId, @Expr),\n \n     // Roots for node trees.\n     RootCrate,\n@@ -155,7 +153,6 @@ impl MapEntry {\n             EntryLocal(id, _) => id,\n             EntryBlock(id, _) => id,\n             EntryStructCtor(id, _) => id,\n-            EntryCalleeScope(id, _) => id,\n             _ => return None\n         })\n     }\n@@ -173,7 +170,6 @@ impl MapEntry {\n             EntryLocal(_, p) => NodeLocal(p),\n             EntryBlock(_, p) => NodeBlock(p),\n             EntryStructCtor(_, p) => NodeStructCtor(p),\n-            EntryCalleeScope(_, p) => NodeCalleeScope(p),\n             _ => return None\n         })\n     }\n@@ -368,7 +364,6 @@ impl Map {\n             Some(NodeArg(pat)) | Some(NodeLocal(pat)) => pat.span,\n             Some(NodeBlock(block)) => block.span,\n             Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n-            Some(NodeCalleeScope(expr)) => expr.span,\n             _ => fail!(\"node_span: could not find span for id {}\", id),\n         }\n     }\n@@ -493,11 +488,6 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n \n         self.insert(expr.id, EntryExpr(self.parent, expr));\n \n-        // Expressions which are or might be calls:\n-        for callee_id in expr.get_callee_id().iter() {\n-            self.insert(*callee_id, EntryCalleeScope(self.parent, expr));\n-        }\n-\n         expr\n     }\n \n@@ -650,9 +640,6 @@ fn node_id_to_str(map: &Map, id: NodeId) -> ~str {\n         Some(NodeExpr(expr)) => {\n             format!(\"expr {} (id={})\", pprust::expr_to_str(expr), id)\n         }\n-        Some(NodeCalleeScope(expr)) => {\n-            format!(\"callee_scope {} (id={})\", pprust::expr_to_str(expr), id)\n-        }\n         Some(NodeStmt(stmt)) => {\n             format!(\"stmt {} (id={})\", pprust::stmt_to_str(stmt), id)\n         }"}, {"sha": "f9d7696565aa1643c49b68ed9aac02f5505a476f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -450,12 +450,6 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n \n \n     fn visit_expr(&mut self, expression: &Expr, env: ()) {\n-        {\n-            let optional_callee_id = expression.get_callee_id();\n-            for callee_id in optional_callee_id.iter() {\n-                self.operation.visit_id(*callee_id)\n-            }\n-        }\n         self.operation.visit_id(expression.id);\n         visit::walk_expr(self, expression, env)\n     }"}, {"sha": "1ddd579a2f112395c6cb94ef7bc4db19be748974", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -502,15 +502,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n                    lhs: @ast::Expr, rhs: @ast::Expr) -> @ast::Expr {\n-        self.expr(sp, ast::ExprBinary(ast::DUMMY_NODE_ID, op, lhs, rhs))\n+        self.expr(sp, ast::ExprBinary(op, lhs, rhs))\n     }\n \n     fn expr_deref(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n         self.expr_unary(sp, ast::UnDeref, e)\n     }\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr)\n-        -> @ast::Expr {\n-        self.expr(sp, ast::ExprUnary(ast::DUMMY_NODE_ID, op, e))\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr) -> @ast::Expr {\n+        self.expr(sp, ast::ExprUnary(op, e))\n     }\n \n     fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n@@ -543,7 +542,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                         ident: ast::Ident,\n                         mut args: ~[@ast::Expr]) -> @ast::Expr {\n         args.unshift(expr);\n-        self.expr(span, ast::ExprMethodCall(ast::DUMMY_NODE_ID, ident, ~[], args))\n+        self.expr(span, ast::ExprMethodCall(ident, ~[], args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr {\n         self.expr(b.span, ast::ExprBlock(b))"}, {"sha": "e62abac443ebb15c0363260e14e898c15ec2ab2b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -749,21 +749,19 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n             ExprCall(folder.fold_expr(f),\n                      args.map(|&x| folder.fold_expr(x)))\n         }\n-        ExprMethodCall(callee_id, i, ref tps, ref args) => {\n+        ExprMethodCall(i, ref tps, ref args) => {\n             ExprMethodCall(\n-                folder.new_id(callee_id),\n                 folder.fold_ident(i),\n                 tps.map(|&x| folder.fold_ty(x)),\n                 args.map(|&x| folder.fold_expr(x)))\n         }\n-        ExprBinary(callee_id, binop, lhs, rhs) => {\n-            ExprBinary(folder.new_id(callee_id),\n-                       binop,\n+        ExprBinary(binop, lhs, rhs) => {\n+            ExprBinary(binop,\n                        folder.fold_expr(lhs),\n                        folder.fold_expr(rhs))\n         }\n-        ExprUnary(callee_id, binop, ohs) => {\n-            ExprUnary(folder.new_id(callee_id), binop, folder.fold_expr(ohs))\n+        ExprUnary(binop, ohs) => {\n+            ExprUnary(binop, folder.fold_expr(ohs))\n         }\n         ExprLit(_) => e.node.clone(),\n         ExprCast(expr, ty) => {\n@@ -802,9 +800,8 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         ExprAssign(el, er) => {\n             ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n         }\n-        ExprAssignOp(callee_id, op, el, er) => {\n-            ExprAssignOp(folder.new_id(callee_id),\n-                         op,\n+        ExprAssignOp(op, el, er) => {\n+            ExprAssignOp(op,\n                          folder.fold_expr(el),\n                          folder.fold_expr(er))\n         }\n@@ -813,10 +810,8 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n                       folder.fold_ident(id),\n                       tys.map(|&x| folder.fold_ty(x)))\n         }\n-        ExprIndex(callee_id, el, er) => {\n-            ExprIndex(folder.new_id(callee_id),\n-                      folder.fold_expr(el),\n-                      folder.fold_expr(er))\n+        ExprIndex(el, er) => {\n+            ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n         }\n         ExprPath(ref pth) => ExprPath(folder.fold_path(pth)),\n         ExprLogLevel => ExprLogLevel,"}, {"sha": "2fd6d34adf19533ffe3d875bce420226d9daab2d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -1683,31 +1683,31 @@ impl Parser {\n     }\n \n     pub fn mk_unary(&mut self, unop: ast::UnOp, expr: @Expr) -> ast::Expr_ {\n-        ExprUnary(ast::DUMMY_NODE_ID, unop, expr)\n+        ExprUnary(unop, expr)\n     }\n \n     pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n-        ExprBinary(ast::DUMMY_NODE_ID, binop, lhs, rhs)\n+        ExprBinary(binop, lhs, rhs)\n     }\n \n     pub fn mk_call(&mut self, f: @Expr, args: ~[@Expr]) -> ast::Expr_ {\n         ExprCall(f, args)\n     }\n \n     fn mk_method_call(&mut self, ident: Ident, tps: ~[P<Ty>], args: ~[@Expr]) -> ast::Expr_ {\n-        ExprMethodCall(ast::DUMMY_NODE_ID, ident, tps, args)\n+        ExprMethodCall(ident, tps, args)\n     }\n \n     pub fn mk_index(&mut self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n-        ExprIndex(ast::DUMMY_NODE_ID, expr, idx)\n+        ExprIndex(expr, idx)\n     }\n \n     pub fn mk_field(&mut self, expr: @Expr, ident: Ident, tys: ~[P<Ty>]) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n     pub fn mk_assign_op(&mut self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n-        ExprAssignOp(ast::DUMMY_NODE_ID, binop, lhs, rhs)\n+        ExprAssignOp(binop, lhs, rhs)\n     }\n \n     pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> @Expr {"}, {"sha": "688494ec5eeaba4ebd7d42908de2e61664f7ad4d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -1235,7 +1235,7 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n         try!(print_expr(s, func));\n         try!(print_call_post(s, *args));\n       }\n-      ast::ExprMethodCall(_, ident, ref tys, ref args) => {\n+      ast::ExprMethodCall(ident, ref tys, ref args) => {\n         let base_args = args.slice_from(1);\n         try!(print_expr(s, args[0]));\n         try!(word(&mut s.s, \".\"));\n@@ -1247,13 +1247,13 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n         }\n         try!(print_call_post(s, base_args));\n       }\n-      ast::ExprBinary(_, op, lhs, rhs) => {\n+      ast::ExprBinary(op, lhs, rhs) => {\n         try!(print_expr(s, lhs));\n         try!(space(&mut s.s));\n         try!(word_space(s, ast_util::binop_to_str(op)));\n         try!(print_expr(s, rhs));\n       }\n-      ast::ExprUnary(_, op, expr) => {\n+      ast::ExprUnary(op, expr) => {\n         try!(word(&mut s.s, ast_util::unop_to_str(op)));\n         try!(print_expr(s, expr));\n       }\n@@ -1442,7 +1442,7 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n         try!(word_space(s, \"=\"));\n         try!(print_expr(s, rhs));\n       }\n-      ast::ExprAssignOp(_, op, lhs, rhs) => {\n+      ast::ExprAssignOp(op, lhs, rhs) => {\n         try!(print_expr(s, lhs));\n         try!(space(&mut s.s));\n         try!(word(&mut s.s, ast_util::binop_to_str(op)));\n@@ -1459,7 +1459,7 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n             try!(word(&mut s.s, \">\"));\n         }\n       }\n-      ast::ExprIndex(_, expr, index) => {\n+      ast::ExprIndex(expr, index) => {\n         try!(print_expr(s, expr));\n         try!(word(&mut s.s, \"[\"));\n         try!(print_expr(s, index));"}, {"sha": "248ba593c1f0965a36f1e4dc4142926c09f79048", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e4d944a9f7db17e759cd4e09fb82357b8cee28/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=05e4d944a9f7db17e759cd4e09fb82357b8cee28", "patch": "@@ -658,18 +658,17 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n             }\n             visitor.visit_expr(callee_expression, env.clone())\n         }\n-        ExprMethodCall(_, _, ref types, ref arguments) => {\n+        ExprMethodCall(_, ref types, ref arguments) => {\n             walk_exprs(visitor, *arguments, env.clone());\n             for &typ in types.iter() {\n                 visitor.visit_ty(typ, env.clone())\n             }\n         }\n-        ExprBinary(_, _, left_expression, right_expression) => {\n+        ExprBinary(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression, env.clone());\n             visitor.visit_expr(right_expression, env.clone())\n         }\n-        ExprAddrOf(_, subexpression) |\n-        ExprUnary(_, _, subexpression) => {\n+        ExprAddrOf(_, subexpression) | ExprUnary(_, subexpression) => {\n             visitor.visit_expr(subexpression, env.clone())\n         }\n         ExprLit(_) => {}\n@@ -719,7 +718,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n             visitor.visit_expr(right_hand_expression, env.clone());\n             visitor.visit_expr(left_hand_expression, env.clone())\n         }\n-        ExprAssignOp(_, _, left_expression, right_expression) => {\n+        ExprAssignOp(_, left_expression, right_expression) => {\n             visitor.visit_expr(right_expression, env.clone());\n             visitor.visit_expr(left_expression, env.clone())\n         }\n@@ -729,7 +728,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n                 visitor.visit_ty(typ, env.clone())\n             }\n         }\n-        ExprIndex(_, main_expression, index_expression) => {\n+        ExprIndex(main_expression, index_expression) => {\n             visitor.visit_expr(main_expression, env.clone());\n             visitor.visit_expr(index_expression, env.clone())\n         }"}]}