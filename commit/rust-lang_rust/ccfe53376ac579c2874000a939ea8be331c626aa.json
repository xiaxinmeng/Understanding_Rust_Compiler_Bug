{"sha": "ccfe53376ac579c2874000a939ea8be331c626aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZmU1MzM3NmFjNTc5YzI4NzQwMDBhOTM5ZWE4YmUzMzFjNjI2YWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-14T14:27:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-15T15:52:28Z"}, "message": "Introduce SourceBinder", "tree": {"sha": "c5e828be066a53e38fcb97b0f4c0ef411fa8951b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5e828be066a53e38fcb97b0f4c0ef411fa8951b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccfe53376ac579c2874000a939ea8be331c626aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccfe53376ac579c2874000a939ea8be331c626aa", "html_url": "https://github.com/rust-lang/rust/commit/ccfe53376ac579c2874000a939ea8be331c626aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccfe53376ac579c2874000a939ea8be331c626aa/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0661ce7444223b0fff1f5d54adb41022ab788cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0661ce7444223b0fff1f5d54adb41022ab788cb", "html_url": "https://github.com/rust-lang/rust/commit/c0661ce7444223b0fff1f5d54adb41022ab788cb"}], "stats": {"total": 318, "additions": 217, "deletions": 101}, "files": [{"sha": "a953eabc77ef0313b8c1847272b2568e800d058f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=ccfe53376ac579c2874000a939ea8be331c626aa", "patch": "@@ -8,7 +8,7 @@\n #![recursion_limit = \"512\"]\n \n macro_rules! impl_froms {\n-    ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n+    ($e:ident: $($v:ident $(($($sv:ident),*))?),*$(,)?) => {\n         $(\n             impl From<$v> for $e {\n                 fn from(it: $v) -> $e {\n@@ -28,6 +28,7 @@ macro_rules! impl_froms {\n \n pub mod db;\n pub mod source_analyzer;\n+pub mod source_binder;\n \n pub mod diagnostics;\n "}, {"sha": "90bc9399964cc62b3e687573e3e33f58bdf2da3a", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 42, "deletions": 98, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=ccfe53376ac579c2874000a939ea8be331c626aa", "patch": "@@ -14,30 +14,26 @@ use hir_def::{\n         BodySourceMap,\n     },\n     expr::{ExprId, PatId},\n-    nameres::ModuleSource,\n-    resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n+    resolver::{self, resolver_for_scope, Resolver, TypeNs, ValueNs},\n     DefWithBodyId, TraitId,\n };\n use hir_expand::{\n     hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroCallKind,\n };\n use hir_ty::{InEnvironment, InferenceResult, TraitEnvironment};\n-use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AstNode},\n-    match_ast, AstPtr,\n-    SyntaxKind::*,\n-    SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextUnit,\n+    AstPtr, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextUnit,\n };\n use rustc_hash::FxHashSet;\n \n use crate::{\n-    db::HirDatabase, Adt, Const, DefWithBody, Enum, EnumVariant, FromSource, Function, ImplBlock,\n-    Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n+    db::HirDatabase, Adt, Const, DefWithBody, EnumVariant, Function, Local, MacroDef, Name, Path,\n+    ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n };\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n-/// original source files. It should not be used inside the HIR itself.\n+/// original source files. It should not be used pinside the HIR itself.\n #[derive(Debug)]\n pub struct SourceAnalyzer {\n     file_id: HirFileId,\n@@ -109,37 +105,43 @@ impl SourceAnalyzer {\n         node: InFile<&SyntaxNode>,\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n-        let _p = profile(\"SourceAnalyzer::new\");\n-        let def_with_body = def_with_body_from_child_node(db, node);\n-        if let Some(def) = def_with_body {\n-            let (_body, source_map) = db.body_with_source_map(def.into());\n-            let scopes = db.expr_scopes(def.into());\n-            let scope = match offset {\n-                None => scope_for(&scopes, &source_map, node),\n-                Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n-            };\n-            let resolver = resolver_for_scope(db, def.into(), scope);\n-            SourceAnalyzer {\n-                resolver,\n-                body_owner: Some(def),\n-                body_source_map: Some(source_map),\n-                infer: Some(db.infer(def.into())),\n-                scopes: Some(scopes),\n-                file_id: node.file_id,\n-            }\n-        } else {\n-            SourceAnalyzer {\n-                resolver: node\n-                    .value\n-                    .ancestors()\n-                    .find_map(|it| try_get_resolver_for_node(db, node.with_value(&it)))\n-                    .unwrap_or_default(),\n-                body_owner: None,\n-                body_source_map: None,\n-                infer: None,\n-                scopes: None,\n-                file_id: node.file_id,\n-            }\n+        crate::source_binder::SourceBinder::default().analyze(db, node, offset)\n+    }\n+\n+    pub(crate) fn new_for_body(\n+        db: &impl HirDatabase,\n+        def: DefWithBodyId,\n+        node: InFile<&SyntaxNode>,\n+        offset: Option<TextUnit>,\n+    ) -> SourceAnalyzer {\n+        let (_body, source_map) = db.body_with_source_map(def);\n+        let scopes = db.expr_scopes(def);\n+        let scope = match offset {\n+            None => scope_for(&scopes, &source_map, node),\n+            Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n+        };\n+        let resolver = resolver_for_scope(db, def, scope);\n+        SourceAnalyzer {\n+            resolver,\n+            body_owner: Some(def.into()),\n+            body_source_map: Some(source_map),\n+            infer: Some(db.infer(def)),\n+            scopes: Some(scopes),\n+            file_id: node.file_id,\n+        }\n+    }\n+\n+    pub(crate) fn new_for_resolver(\n+        resolver: Resolver,\n+        node: InFile<&SyntaxNode>,\n+    ) -> SourceAnalyzer {\n+        SourceAnalyzer {\n+            resolver,\n+            body_owner: None,\n+            body_source_map: None,\n+            infer: None,\n+            scopes: None,\n+            file_id: node.file_id,\n         }\n     }\n \n@@ -366,64 +368,6 @@ impl SourceAnalyzer {\n     }\n }\n \n-fn try_get_resolver_for_node(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> Option<Resolver> {\n-    match_ast! {\n-        match (node.value) {\n-            ast::Module(it) => {\n-                let src = node.with_value(it);\n-                Some(crate::Module::from_declaration(db, src)?.id.resolver(db))\n-            },\n-             ast::SourceFile(it) => {\n-                let src = node.with_value(ModuleSource::SourceFile(it));\n-                Some(crate::Module::from_definition(db, src)?.id.resolver(db))\n-            },\n-            ast::StructDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Struct::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::EnumDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Enum::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::ImplBlock(it) => {\n-                let src = node.with_value(it);\n-                Some(ImplBlock::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::TraitDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Trait::from_source(db, src)?.id.resolver(db))\n-            },\n-            _ => match node.value.kind() {\n-                FN_DEF | CONST_DEF | STATIC_DEF => {\n-                    let def = def_with_body_from_child_node(db, node)?;\n-                    let def = DefWithBodyId::from(def);\n-                    Some(def.resolver(db))\n-                }\n-                // FIXME add missing cases\n-                _ => None\n-            }\n-        }\n-    }\n-}\n-\n-fn def_with_body_from_child_node(\n-    db: &impl HirDatabase,\n-    child: InFile<&SyntaxNode>,\n-) -> Option<DefWithBody> {\n-    let _p = profile(\"def_with_body_from_child_node\");\n-    child.cloned().ancestors_with_macros(db).find_map(|node| {\n-        let n = &node.value;\n-        match_ast! {\n-            match n {\n-                ast::FnDef(def)  => { return Function::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                ast::ConstDef(def) => { return Const::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                ast::StaticDef(def) => { return Static::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                _ => { None },\n-            }\n-        }\n-    })\n-}\n-\n fn scope_for(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,"}, {"sha": "cec3f8c2c9b22744319b51b1791692e7a55543b5", "filename": "crates/ra_hir/src/source_binder.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=ccfe53376ac579c2874000a939ea8be331c626aa", "patch": "@@ -0,0 +1,171 @@\n+//! `SourceBinder` should be the main entry point for getting info about source code.\n+//! It's main task is to map source syntax trees to hir-level IDs.\n+//!\n+//! It is intended to subsume `FromSource` and `SourceAnalyzer`.\n+\n+use hir_def::{\n+    child_by_source::ChildBySource,\n+    dyn_map::DynMap,\n+    keys::{self, Key},\n+    resolver::{HasResolver, Resolver},\n+    ConstId, DefWithBodyId, EnumId, FunctionId, ImplId, ModuleId, StaticId, StructId, TraitId,\n+    UnionId, VariantId,\n+};\n+use hir_expand::InFile;\n+use ra_prof::profile;\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, TextUnit};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{db::HirDatabase, ModuleSource, SourceAnalyzer};\n+\n+#[derive(Default)]\n+pub struct SourceBinder {\n+    child_by_source_cache: FxHashMap<ChildContainer, DynMap>,\n+}\n+\n+impl SourceBinder {\n+    pub fn analyze(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        src: InFile<&SyntaxNode>,\n+        offset: Option<TextUnit>,\n+    ) -> SourceAnalyzer {\n+        let _p = profile(\"SourceBinder::analyzer\");\n+        let container = match self.find_container(db, src) {\n+            Some(it) => it,\n+            None => return SourceAnalyzer::new_for_resolver(Resolver::default(), src),\n+        };\n+\n+        let resolver = match container {\n+            ChildContainer::DefWithBodyId(def) => {\n+                return SourceAnalyzer::new_for_body(db, def, src, offset)\n+            }\n+            ChildContainer::TraitId(it) => it.resolver(db),\n+            ChildContainer::ImplId(it) => it.resolver(db),\n+            ChildContainer::ModuleId(it) => it.resolver(db),\n+            ChildContainer::EnumId(it) => it.resolver(db),\n+            ChildContainer::VariantId(it) => it.resolver(db),\n+        };\n+        SourceAnalyzer::new_for_resolver(resolver, src)\n+    }\n+\n+    pub fn to_def<D, ID>(&mut self, db: &impl HirDatabase, src: InFile<ID::Ast>) -> Option<D>\n+    where\n+        D: From<ID>,\n+        ID: ToId,\n+    {\n+        let id: ID = self.to_id(db, src)?;\n+        Some(id.into())\n+    }\n+\n+    fn to_id<D: ToId>(&mut self, db: &impl HirDatabase, src: InFile<D::Ast>) -> Option<D> {\n+        let container = self.find_container(db, src.as_ref().map(|it| it.syntax()))?;\n+        let dyn_map =\n+            &*self.child_by_source_cache.entry(container).or_insert_with(|| match container {\n+                ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n+                ChildContainer::ModuleId(it) => it.child_by_source(db),\n+                ChildContainer::TraitId(it) => it.child_by_source(db),\n+                ChildContainer::ImplId(it) => it.child_by_source(db),\n+                ChildContainer::EnumId(it) => it.child_by_source(db),\n+                ChildContainer::VariantId(it) => it.child_by_source(db),\n+            });\n+        dyn_map[D::KEY].get(&src).copied()\n+    }\n+\n+    fn find_container(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        src: InFile<&SyntaxNode>,\n+    ) -> Option<ChildContainer> {\n+        for container in src.cloned().ancestors_with_macros(db).skip(1) {\n+            let res: ChildContainer = match_ast! {\n+                match (container.value) {\n+                    ast::TraitDef(it) => {\n+                        let def: TraitId = self.to_id(db, container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::ImplBlock(it) => {\n+                        let def: ImplId = self.to_id(db, container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::FnDef(it) => {\n+                        let def: FunctionId = self.to_id(db, container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    ast::StaticDef(it) => {\n+                        let def: StaticId = self.to_id(db, container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    ast::ConstDef(it) => {\n+                        let def: ConstId = self.to_id(db, container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    ast::EnumDef(it) => {\n+                        let def: EnumId = self.to_id(db, container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::StructDef(it) => {\n+                        let def: StructId = self.to_id(db, container.with_value(it))?;\n+                        VariantId::from(def).into()\n+                    },\n+                    ast::UnionDef(it) => {\n+                        let def: UnionId = self.to_id(db, container.with_value(it))?;\n+                        VariantId::from(def).into()\n+                    },\n+                    // FIXME: handle out-of-line modules here\n+                    _ => { continue },\n+                }\n+            };\n+            return Some(res);\n+        }\n+\n+        let module_source = ModuleSource::from_child_node(db, src);\n+        let c = crate::Module::from_definition(db, src.with_value(module_source))?;\n+        Some(c.id.into())\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+enum ChildContainer {\n+    DefWithBodyId(DefWithBodyId),\n+    ModuleId(ModuleId),\n+    TraitId(TraitId),\n+    ImplId(ImplId),\n+    EnumId(EnumId),\n+    VariantId(VariantId),\n+}\n+impl_froms! {\n+    ChildContainer:\n+    DefWithBodyId,\n+    ModuleId,\n+    TraitId,\n+    ImplId,\n+    EnumId,\n+    VariantId,\n+}\n+\n+pub trait ToId: Sized + Copy + 'static {\n+    type Ast: AstNode + 'static;\n+    const KEY: Key<Self::Ast, Self>;\n+}\n+\n+macro_rules! to_id_impls {\n+    ($(($id:ident, $ast:path, $key:path)),* ,) => {$(\n+        impl ToId for $id {\n+            type Ast = $ast;\n+            const KEY: Key<Self::Ast, Self> = $key;\n+        }\n+    )*}\n+}\n+\n+to_id_impls![\n+    (StructId, ast::StructDef, keys::STRUCT),\n+    (UnionId, ast::UnionDef, keys::UNION),\n+    (EnumId, ast::EnumDef, keys::ENUM),\n+    (TraitId, ast::TraitDef, keys::TRAIT),\n+    (FunctionId, ast::FnDef, keys::FUNCTION),\n+    (StaticId, ast::StaticDef, keys::STATIC),\n+    (ConstId, ast::ConstDef, keys::CONST),\n+    // (TypeAlias, TypeAliasId, ast::TypeAliasDef, keys::TYPE_ALIAS),\n+    (ImplId, ast::ImplBlock, keys::IMPL),\n+];"}, {"sha": "feb3a300d581ee687103f7bb2291d7974689898c", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=ccfe53376ac579c2874000a939ea8be331c626aa", "patch": "@@ -332,7 +332,7 @@ pub enum VariantId {\n     StructId(StructId),\n     UnionId(UnionId),\n }\n-impl_froms!(VariantId: EnumVariantId, StructId);\n+impl_froms!(VariantId: EnumVariantId, StructId, UnionId);\n \n trait Intern {\n     type ID;"}, {"sha": "f06a8933eaab0daf48021824b53c4e3755e80adf", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfe53376ac579c2874000a939ea8be331c626aa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=ccfe53376ac579c2874000a939ea8be331c626aa", "patch": "@@ -312,7 +312,7 @@ mod tests {\n     use test_utils::{assert_eq_text, project_dir, read_text};\n \n     #[test]\n-    fn test_highlighting() {\n+    fn te3st_highlighting() {\n         let (analysis, file_id) = single_file(\n             r#\"\n #[derive(Clone, Debug)]"}]}