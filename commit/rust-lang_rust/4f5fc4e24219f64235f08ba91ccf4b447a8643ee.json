{"sha": "4f5fc4e24219f64235f08ba91ccf4b447a8643ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNWZjNGUyNDIxOWY2NDIzNWYwOGJhOTFjY2Y0YjQ0N2E4NjQzZWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-06T15:20:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-06T15:20:23Z"}, "message": "fix case where some edges can't be recreated by expanding the graph\n\ncc #39569 -- almost certainly a fix for that", "tree": {"sha": "5c8eb841475aa26916351ca8c89388edc0718d7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c8eb841475aa26916351ca8c89388edc0718d7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f5fc4e24219f64235f08ba91ccf4b447a8643ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5fc4e24219f64235f08ba91ccf4b447a8643ee", "html_url": "https://github.com/rust-lang/rust/commit/4f5fc4e24219f64235f08ba91ccf4b447a8643ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f5fc4e24219f64235f08ba91ccf4b447a8643ee/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9757863df0c30fbff1a6b4c95c48342d25e9b4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9757863df0c30fbff1a6b4c95c48342d25e9b4a", "html_url": "https://github.com/rust-lang/rust/commit/b9757863df0c30fbff1a6b4c95c48342d25e9b4a"}], "stats": {"total": 121, "additions": 85, "deletions": 36}, "files": [{"sha": "7724658a9d6fead0f25ec19c116c9b26fd0e654e", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 84, "deletions": 35, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4f5fc4e24219f64235f08ba91ccf4b447a8643ee/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5fc4e24219f64235f08ba91ccf4b447a8643ee/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=4f5fc4e24219f64235f08ba91ccf4b447a8643ee", "patch": "@@ -176,46 +176,32 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Recreate the edges in the graph that are still clean.\n     let mut clean_work_products = FxHashSet();\n     let mut dirty_work_products = FxHashSet(); // incomplete; just used to suppress debug output\n+    let mut extra_edges = vec![];\n     for (source, targets) in &edge_map {\n         for target in targets {\n-            // If the target is dirty, skip the edge. If this is an edge\n-            // that targets a work-product, we can print the blame\n-            // information now.\n-            if let Some(blame) = dirty_raw_nodes.get(target) {\n-                if let DepNode::WorkProduct(ref wp) = *target {\n-                    if tcx.sess.opts.debugging_opts.incremental_info {\n-                        if dirty_work_products.insert(wp.clone()) {\n-                            // It'd be nice to pretty-print these paths better than just\n-                            // using the `Debug` impls, but wev.\n-                            println!(\"incremental: module {:?} is dirty because {:?} \\\n-                                      changed or was removed\",\n-                                     wp,\n-                                     blame.map_def(|&index| {\n-                                         Some(directory.def_path_string(tcx, index))\n-                                     }).unwrap());\n-                        }\n-                    }\n-                }\n-                continue;\n-            }\n-\n-            // If the source is dirty, the target will be dirty.\n-            assert!(!dirty_raw_nodes.contains_key(source));\n-\n-            // Retrace the source -> target edges to def-ids and then\n-            // create an edge in the graph. Retracing may yield none if\n-            // some of the data happens to have been removed; this ought\n-            // to be impossible unless it is dirty, so we can unwrap.\n-            let source_node = retraced.map(source).unwrap();\n-            let target_node = retraced.map(target).unwrap();\n-            let _task = tcx.dep_graph.in_task(target_node);\n-            tcx.dep_graph.read(source_node);\n-            if let DepNode::WorkProduct(ref wp) = *target {\n-                clean_work_products.insert(wp.clone());\n-            }\n+            process_edges(tcx, source, target, &edge_map, &directory, &retraced, &dirty_raw_nodes,\n+                          &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n         }\n     }\n \n+    // Subtle. Sometimes we have intermediate nodes that we can't recreate in the new graph.\n+    // This is pretty unusual but it arises in a scenario like this:\n+    //\n+    //     Hir(X) -> Foo(Y) -> Bar\n+    //\n+    // Note that the `Hir(Y)` is not an input to `Foo(Y)` -- this\n+    // almost never happens, but can happen in some obscure\n+    // scenarios. In that case, if `Y` is removed, then we can't\n+    // recreate `Foo(Y)` (the def-id `Y` no longer exists); what we do\n+    // then is to push the edge `Hir(X) -> Bar` onto `extra_edges`\n+    // (along with any other targets of `Foo(Y)`). We will then add\n+    // the edge from `Hir(X)` to `Bar` (or, if `Bar` itself cannot be\n+    // recreated, to the targets of `Bar`).\n+    while let Some((source, target)) = extra_edges.pop() {\n+        process_edges(tcx, source, target, &edge_map, &directory, &retraced, &dirty_raw_nodes,\n+                      &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n+    }\n+\n     // Add in work-products that are still clean, and delete those that are\n     // dirty.\n     reconcile_work_products(tcx, work_products, &clean_work_products);\n@@ -393,3 +379,66 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n            serialized_hashes.index_map.len());\n }\n \n+fn process_edges<'a, 'tcx, 'edges>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    source: &'edges DepNode<DefPathIndex>,\n+    target: &'edges DepNode<DefPathIndex>,\n+    edges: &'edges FxHashMap<DepNode<DefPathIndex>, Vec<DepNode<DefPathIndex>>>,\n+    directory: &DefIdDirectory,\n+    retraced: &RetracedDefIdDirectory,\n+    dirty_raw_nodes: &DirtyNodes,\n+    clean_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n+    dirty_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n+    extra_edges: &mut Vec<(&'edges DepNode<DefPathIndex>, &'edges DepNode<DefPathIndex>)>)\n+{\n+    // If the target is dirty, skip the edge. If this is an edge\n+    // that targets a work-product, we can print the blame\n+    // information now.\n+    if let Some(blame) = dirty_raw_nodes.get(target) {\n+        if let DepNode::WorkProduct(ref wp) = *target {\n+            if tcx.sess.opts.debugging_opts.incremental_info {\n+                if dirty_work_products.insert(wp.clone()) {\n+                    // It'd be nice to pretty-print these paths better than just\n+                    // using the `Debug` impls, but wev.\n+                    println!(\"incremental: module {:?} is dirty because {:?} \\\n+                              changed or was removed\",\n+                             wp,\n+                             blame.map_def(|&index| {\n+                                 Some(directory.def_path_string(tcx, index))\n+                             }).unwrap());\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    // If the source is dirty, the target will be dirty.\n+    assert!(!dirty_raw_nodes.contains_key(source));\n+\n+    // Retrace the source -> target edges to def-ids and then create\n+    // an edge in the graph. Retracing may yield none if some of the\n+    // data happens to have been removed.\n+    if let Some(source_node) = retraced.map(source) {\n+        if let Some(target_node) = retraced.map(target) {\n+            let _task = tcx.dep_graph.in_task(target_node);\n+            tcx.dep_graph.read(source_node);\n+            if let DepNode::WorkProduct(ref wp) = *target {\n+                clean_work_products.insert(wp.clone());\n+            }\n+        } else {\n+            // As discussed in `decode_dep_graph` above, sometimes the\n+            // target cannot be recreated again, in which case we add\n+            // edges to go from `source` to the targets of `target`.\n+            extra_edges.extend(\n+                edges[target].iter().map(|t| (source, t)));\n+        }\n+    } else {\n+        // It's also possible that the source can't be created! But we\n+        // can ignore such cases, because (a) if `source` is a HIR\n+        // node, it would be considered dirty; and (b) in other cases,\n+        // there must be some input to this node that is clean, and so\n+        // we'll re-create the edges over in the case where target is\n+        // undefined.\n+    }\n+}\n+"}, {"sha": "5b53e94825300d2219b3b82e40423787e27af80e", "filename": "src/test/incremental/issue-39569.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f5fc4e24219f64235f08ba91ccf4b447a8643ee/src%2Ftest%2Fincremental%2Fissue-39569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5fc4e24219f64235f08ba91ccf4b447a8643ee/src%2Ftest%2Fincremental%2Fissue-39569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-39569.rs?ref=4f5fc4e24219f64235f08ba91ccf4b447a8643ee", "patch": "@@ -32,7 +32,7 @@ struct FooX { x: usize }\n \n #[cfg(rpass2)]\n fn main() {\n-    let x: Arc<FooX> = Arc::new(Foo { x: 22 });\n+    let x: Arc<FooX> = Arc::new(FooX { x: 22 });\n     let y: Arc<FooX> = x;\n }\n "}]}