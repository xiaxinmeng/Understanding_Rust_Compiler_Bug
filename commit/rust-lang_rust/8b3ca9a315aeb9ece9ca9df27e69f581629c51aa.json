{"sha": "8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiM2NhOWEzMTVhZWI5ZWNlOWNhOWRmMjdlNjlmNTgxNjI5YzUxYWE=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-16T19:42:52Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-16T20:12:00Z"}, "message": "Fix `option_if_let_else`\n* `break` and `continue` statments local to the would-be closure are allowed\n* don't lint in const contexts\n* don't lint when yield expressions are used\n* don't lint when the captures made by the would-be closure conflict with the other branch\n* don't lint when a field of a local is used when the type could be pontentially moved from\n* in some cases, don't lint when scrutinee expression conflicts with the captures of the would-be closure", "tree": {"sha": "b8476cecfd22b172cbd076e2cfb98b4b0ab17de2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8476cecfd22b172cbd076e2cfb98b4b0ab17de2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmEaxpQACgkQ2lnoZDo37Qa5sAEAgFbY/NiQPljtqEOs0LyH4cpw\nk40S+wSx1PDxi6Ro1wMBAPUuU1qSA76uGT8gth+h4eNRdXf3nRwhSLSXihsa5CkF\n=m4Ys\n-----END PGP SIGNATURE-----", "payload": "tree b8476cecfd22b172cbd076e2cfb98b4b0ab17de2\nparent 983e5b877ef82f84bd463d74ba6035d75c456d73\nauthor Jason Newcomb <jsnewcomb@pm.me> 1629142972 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1629144720 -0400\n\nFix `option_if_let_else`\n* `break` and `continue` statments local to the would-be closure are allowed\n* don't lint in const contexts\n* don't lint when yield expressions are used\n* don't lint when the captures made by the would-be closure conflict with the other branch\n* don't lint when a field of a local is used when the type could be pontentially moved from\n* in some cases, don't lint when scrutinee expression conflicts with the captures of the would-be closure\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "html_url": "https://github.com/rust-lang/rust/commit/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "983e5b877ef82f84bd463d74ba6035d75c456d73", "url": "https://api.github.com/repos/rust-lang/rust/commits/983e5b877ef82f84bd463d74ba6035d75c456d73", "html_url": "https://github.com/rust-lang/rust/commit/983e5b877ef82f84bd463d74ba6035d75c456d73"}], "stats": {"total": 198, "additions": 186, "deletions": 12}, "files": [{"sha": "46f06362ccc677133ced3253c8b42b9d35eab8aa", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "patch": "@@ -1,12 +1,16 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{eager_or_lazy, in_macro, is_else_clause, is_lang_ctor};\n+use clippy_utils::{\n+    can_move_expr_to_closure, eager_or_lazy, in_constant, in_macro, is_else_clause, is_lang_ctor, peel_hir_expr_while,\n+    CaptureKind,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, Path, QPath, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -127,21 +131,30 @@ fn detect_option_if_let_else<'tcx>(\n ) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n-        if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if !in_constant(cx, expr.hir_id);\n+        if let ExprKind::Match(cond_expr, [some_arm, none_arm], MatchSource::IfLetDesugar{contains_else_clause: true})\n+            = &expr.kind;\n         if !is_else_clause(cx.tcx, expr);\n-        if arms.len() == 2;\n         if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n-        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &arms[0].pat.kind;\n+        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &some_arm.pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if !contains_return_break_continue_macro(arms[0].body);\n-        if !contains_return_break_continue_macro(arms[1].body);\n+        if let Some(some_captures) = can_move_expr_to_closure(cx, some_arm.body);\n+        if let Some(none_captures) = can_move_expr_to_closure(cx, none_arm.body);\n+        if some_captures\n+            .iter()\n+            .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n+            .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n-            let some_body = extract_body_from_arm(&arms[0])?;\n-            let none_body = extract_body_from_arm(&arms[1])?;\n-            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n+            let some_body = extract_body_from_arm(some_arm)?;\n+            let none_body = extract_body_from_arm(none_arm)?;\n+            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) {\n+                \"map_or\"\n+            } else {\n+                \"map_or_else\"\n+            };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &cond_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n@@ -153,6 +166,24 @@ fn detect_option_if_let_else<'tcx>(\n                 ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n                 _ => cond_expr,\n             };\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if as_ref || as_mut {\n+                let e = peel_hir_expr_while(cond_expr, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                    match some_captures.get(l)\n+                        .or_else(|| (method_sugg == \"map_or_else\").then(|| ()).and_then(|_| none_captures.get(l)))\n+                    {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if as_mut => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n             Some(OptionIfLetElseOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),"}, {"sha": "bb7de1653602ec4de20b1c0869a80cd9d9764f1a", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "patch": "@@ -709,6 +709,11 @@ pub enum CaptureKind {\n     Value,\n     Ref(Mutability),\n }\n+impl CaptureKind {\n+    pub fn is_imm_ref(self) -> bool {\n+        self == Self::Ref(Mutability::Not)\n+    }\n+}\n impl std::ops::BitOr for CaptureKind {\n     type Output = Self;\n     fn bitor(self, rhs: Self) -> Self::Output {"}, {"sha": "56e032cdb57aa5666290c2b2acc27e152b37c2fc", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "patch": "@@ -86,4 +86,46 @@ fn main() {\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n     let _ = impure_else(None);\n+\n+    let _ = Some(0).map_or(0, |x| loop {\n+            if x == 0 {\n+                break x;\n+            }\n+        });\n+\n+    // #7576\n+    const fn _f(x: Option<u32>) -> u32 {\n+        // Don't lint, `map_or` isn't const\n+        if let Some(x) = x { x } else { 10 }\n+    }\n+\n+    // #5822\n+    let s = String::new();\n+    // Don't lint, `Some` branch consumes `s`, but else branch uses `s`\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        s.len()\n+    };\n+\n+    let s = String::new();\n+    // Lint, both branches immutably borrow `s`.\n+    let _ = Some(0).map_or_else(|| s.len(), |x| s.len() + x);\n+\n+    let s = String::new();\n+    // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`.\n+    let _ = Some(0).map_or(1, |x| {\n+        let s = s;\n+        s.len() + x\n+    });\n+\n+    let s = Some(String::new());\n+    // Don't lint, `Some` branch borrows `s`, but else branch consumes `s`\n+    let _ = if let Some(x) = &s {\n+        x.len()\n+    } else {\n+        let _s = s;\n+        10\n+    };\n }"}, {"sha": "595ed8172cd0e4ea53345f2df0b0155036b904b5", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "patch": "@@ -105,4 +105,52 @@ fn main() {\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n     let _ = impure_else(None);\n+\n+    let _ = if let Some(x) = Some(0) {\n+        loop {\n+            if x == 0 {\n+                break x;\n+            }\n+        }\n+    } else {\n+        0\n+    };\n+\n+    // #7576\n+    const fn _f(x: Option<u32>) -> u32 {\n+        // Don't lint, `map_or` isn't const\n+        if let Some(x) = x { x } else { 10 }\n+    }\n+\n+    // #5822\n+    let s = String::new();\n+    // Don't lint, `Some` branch consumes `s`, but else branch uses `s`\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        s.len()\n+    };\n+\n+    let s = String::new();\n+    // Lint, both branches immutably borrow `s`.\n+    let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n+\n+    let s = String::new();\n+    // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`.\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        1\n+    };\n+\n+    let s = Some(String::new());\n+    // Don't lint, `Some` branch borrows `s`, but else branch consumes `s`\n+    let _ = if let Some(x) = &s {\n+        x.len()\n+    } else {\n+        let _s = s;\n+        10\n+    };\n }"}, {"sha": "803d941c36df8b2d8aa80ca7fa381ee8c35c780a", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b3ca9a315aeb9ece9ca9df27e69f581629c51aa/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=8b3ca9a315aeb9ece9ca9df27e69f581629c51aa", "patch": "@@ -148,5 +148,53 @@ error: use Option::map_or instead of an if let/else\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n-error: aborting due to 11 previous errors\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:109:13\n+   |\n+LL |       let _ = if let Some(x) = Some(0) {\n+   |  _____________^\n+LL | |         loop {\n+LL | |             if x == 0 {\n+LL | |                 break x;\n+...  |\n+LL | |         0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL ~     let _ = Some(0).map_or(0, |x| loop {\n+LL +             if x == 0 {\n+LL +                 break x;\n+LL +             }\n+LL ~         });\n+   |\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:137:13\n+   |\n+LL |     let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or_else(|| s.len(), |x| s.len() + x)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:141:13\n+   |\n+LL |       let _ = if let Some(x) = Some(0) {\n+   |  _____________^\n+LL | |         let s = s;\n+LL | |         s.len() + x\n+LL | |     } else {\n+LL | |         1\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL ~     let _ = Some(0).map_or(1, |x| {\n+LL +         let s = s;\n+LL +         s.len() + x\n+LL ~     });\n+   |\n+\n+error: aborting due to 14 previous errors\n "}]}