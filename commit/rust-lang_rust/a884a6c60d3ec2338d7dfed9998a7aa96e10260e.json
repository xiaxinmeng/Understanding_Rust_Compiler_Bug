{"sha": "a884a6c60d3ec2338d7dfed9998a7aa96e10260e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ODRhNmM2MGQzZWMyMzM4ZDdkZmVkOTk5OGE3YWE5NmUxMDI2MGU=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-02-04T15:26:01Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-02-04T15:44:43Z"}, "message": "Slightly optimize slice::sort\n\nFirst, get rid of some bound checks.\n\nSecond, instead of comparing by ternary `compare` function, use a binary\nfunction testing whether an element is less than some other element.\nThis apparently makes it easier for the compiler to reason about the\ncode.\n\nBenchmark:\n\n```\nname                                        before ns/iter        after ns/iter         diff ns/iter   diff %\nslice::bench::sort_large_ascending          8,969 (8919 MB/s)     7,410 (10796 MB/s)          -1,559  -17.38%\nslice::bench::sort_large_big_ascending      355,640 (3599 MB/s)   359,137 (3564 MB/s)          3,497    0.98%\nslice::bench::sort_large_big_descending     427,112 (2996 MB/s)   424,721 (3013 MB/s)         -2,391   -0.56%\nslice::bench::sort_large_big_random         2,207,799 (579 MB/s)  2,138,804 (598 MB/s)       -68,995   -3.13%\nslice::bench::sort_large_descending         13,694 (5841 MB/s)    13,514 (5919 MB/s)            -180   -1.31%\nslice::bench::sort_large_mostly_ascending   239,697 (333 MB/s)    203,542 (393 MB/s)         -36,155  -15.08%\nslice::bench::sort_large_mostly_descending  270,102 (296 MB/s)    234,263 (341 MB/s)         -35,839  -13.27%\nslice::bench::sort_large_random             513,406 (155 MB/s)    470,084 (170 MB/s)         -43,322   -8.44%\nslice::bench::sort_large_random_expensive   23,650,321 (3 MB/s)   23,675,098 (3 MB/s)         24,777    0.10%\nslice::bench::sort_medium_ascending         143 (5594 MB/s)       132 (6060 MB/s)                -11   -7.69%\nslice::bench::sort_medium_descending        197 (4060 MB/s)       188 (4255 MB/s)                 -9   -4.57%\nslice::bench::sort_medium_random            3,358 (238 MB/s)      3,271 (244 MB/s)               -87   -2.59%\nslice::bench::sort_small_ascending          32 (2500 MB/s)        32 (2500 MB/s)                   0    0.00%\nslice::bench::sort_small_big_ascending      97 (13195 MB/s)       97 (13195 MB/s)                  0    0.00%\nslice::bench::sort_small_big_descending     247 (5182 MB/s)       249 (5140 MB/s)                  2    0.81%\nslice::bench::sort_small_big_random         502 (2549 MB/s)       498 (2570 MB/s)                 -4   -0.80%\nslice::bench::sort_small_descending         55 (1454 MB/s)        61 (1311 MB/s)                   6   10.91%\nslice::bench::sort_small_random             358 (223 MB/s)        356 (224 MB/s)                  -2   -0.56%\n```", "tree": {"sha": "c99db696900f275e050d051b9b1c44a60f565f18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c99db696900f275e050d051b9b1c44a60f565f18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a884a6c60d3ec2338d7dfed9998a7aa96e10260e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a884a6c60d3ec2338d7dfed9998a7aa96e10260e", "html_url": "https://github.com/rust-lang/rust/commit/a884a6c60d3ec2338d7dfed9998a7aa96e10260e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a884a6c60d3ec2338d7dfed9998a7aa96e10260e/comments", "author": null, "committer": null, "parents": [{"sha": "7df5c0f17b2966bd7e6cd4326f990fe844254a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7df5c0f17b2966bd7e6cd4326f990fe844254a4f", "html_url": "https://github.com/rust-lang/rust/commit/7df5c0f17b2966bd7e6cd4326f990fe844254a4f"}], "stats": {"total": 68, "additions": 36, "deletions": 32}, "files": [{"sha": "2ea953df8735729b6d02dbecf7453d1a07615d9d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a884a6c60d3ec2338d7dfed9998a7aa96e10260e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a884a6c60d3ec2338d7dfed9998a7aa96e10260e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a884a6c60d3ec2338d7dfed9998a7aa96e10260e", "patch": "@@ -98,7 +98,7 @@\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n use alloc::boxed::Box;\n-use core::cmp::Ordering::{self, Greater};\n+use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n@@ -1089,7 +1089,7 @@ impl<T> [T] {\n     pub fn sort(&mut self)\n         where T: Ord\n     {\n-        self.sort_by(|a, b| a.cmp(b))\n+        merge_sort(self, |a, b| a.lt(b));\n     }\n \n     /// Sorts the slice using `f` to extract a key to compare elements by.\n@@ -1119,7 +1119,7 @@ impl<T> [T] {\n     pub fn sort_by_key<B, F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> B, B: Ord\n     {\n-        self.sort_by(|a, b| f(a).cmp(&f(b)))\n+        merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n     /// Sorts the slice using `compare` to compare elements.\n@@ -1149,10 +1149,10 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sort_by<F>(&mut self, compare: F)\n+    pub fn sort_by<F>(&mut self, mut compare: F)\n         where F: FnMut(&T, &T) -> Ordering\n     {\n-        merge_sort(self, compare)\n+        merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n \n     /// Copies the elements from `src` into `self`.\n@@ -1355,10 +1355,10 @@ impl<T: Clone> ToOwned for [T] {\n /// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n ///\n /// This is the integral subroutine of insertion sort.\n-fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n-    where F: FnMut(&T, &T) -> Ordering\n+fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n+    where F: FnMut(&T, &T) -> bool\n {\n-    if v.len() >= 2 && compare(&v[0], &v[1]) == Greater {\n+    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n         unsafe {\n             // There are three ways to implement insertion here:\n             //\n@@ -1381,12 +1381,12 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n \n             // Intermediate state of the insertion process is always tracked by `hole`, which\n             // serves two purposes:\n-            // 1. Protects integrity of `v` from panics in `compare`.\n+            // 1. Protects integrity of `v` from panics in `is_less`.\n             // 2. Fills the remaining hole in `v` in the end.\n             //\n             // Panic safety:\n             //\n-            // If `compare` panics at any point during the process, `hole` will get dropped and\n+            // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n             let mut hole = InsertionHole {\n@@ -1396,7 +1396,7 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n-                if compare(&tmp.value, &v[i]) != Greater {\n+                if !is_less(&v[i], &tmp.value) {\n                     break;\n                 }\n                 ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n@@ -1432,8 +1432,8 @@ fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n ///\n /// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n /// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n-unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n-    where F: FnMut(&T, &T) -> Ordering\n+unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n+    where F: FnMut(&T, &T) -> bool\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n@@ -1449,12 +1449,12 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n     // hole in `v`.\n     //\n     // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n-    // 1. Protects integrity of `v` from panics in `compare`.\n+    // 1. Protects integrity of `v` from panics in `is_less`.\n     // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n     //\n     // Panic safety:\n     //\n-    // If `compare` panics at any point during the process, `hole` will get dropped and fill the\n+    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n     // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n     // object it initially held exactly once.\n     let mut hole;\n@@ -1476,7 +1476,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n         while *left < hole.end && right < v_end {\n             // Consume the lesser side.\n             // If equal, prefer the left run to maintain stability.\n-            let to_copy = if compare(&**left, &*right) == Greater {\n+            let to_copy = if is_less(&*right, &**left) {\n                 get_and_increment(&mut right)\n             } else {\n                 get_and_increment(left)\n@@ -1500,7 +1500,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n         while v < *left && buf < *right {\n             // Consume the greater side.\n             // If equal, prefer the right run to maintain stability.\n-            let to_copy = if compare(&*left.offset(-1), &*right.offset(-1)) == Greater {\n+            let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n                 decrement_and_get(left)\n             } else {\n                 decrement_and_get(right)\n@@ -1550,8 +1550,8 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n-fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n-    where F: FnMut(&T, &T) -> Ordering\n+fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n+    where F: FnMut(&T, &T) -> bool\n {\n     // Sorting has no meaningful behavior on zero-sized types.\n     if size_of::<T>() == 0 {\n@@ -1565,7 +1565,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n     //\n     // Short runs are extended using insertion sort to span at least `min_run` elements, in order\n     // to improve performance.\n-    let (max_insertion, min_run) = if size_of::<T>() <= 16 {\n+    let (max_insertion, min_run) = if size_of::<T>() <= 2 * mem::size_of::<usize>() {\n         (64, 32)\n     } else {\n         (32, 16)\n@@ -1577,15 +1577,15 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n     if len <= max_insertion {\n         if len >= 2 {\n             for i in (0..len-1).rev() {\n-                insert_head(&mut v[i..], &mut compare);\n+                insert_head(&mut v[i..], &mut is_less);\n             }\n         }\n         return;\n     }\n \n     // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n     // shallow copies of the contents of `v` without risking the dtors running on copies if\n-    // `compare` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n+    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n     // which will always have length at most `len / 2`.\n     let mut buf = Vec::with_capacity(len / 2);\n \n@@ -1600,14 +1600,18 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n         let mut start = end - 1;\n         if start > 0 {\n             start -= 1;\n-            if compare(&v[start], &v[start + 1]) == Greater {\n-                while start > 0 && compare(&v[start - 1], &v[start]) == Greater {\n-                    start -= 1;\n-                }\n-                v[start..end].reverse();\n-            } else {\n-                while start > 0 && compare(&v[start - 1], &v[start]) != Greater {\n-                    start -= 1;\n+            unsafe {\n+                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n+                    while start > 0 && is_less(v.get_unchecked(start),\n+                                               v.get_unchecked(start - 1)) {\n+                        start -= 1;\n+                    }\n+                    v[start..end].reverse();\n+                } else {\n+                    while start > 0 && !is_less(v.get_unchecked(start),\n+                                                v.get_unchecked(start - 1)) {\n+                        start -= 1;\n+                    }\n                 }\n             }\n         }\n@@ -1616,7 +1620,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n         // merge sort on short sequences, so this significantly improves performance.\n         while start > 0 && end - start < min_run {\n             start -= 1;\n-            insert_head(&mut v[start..end], &mut compare);\n+            insert_head(&mut v[start..end], &mut is_less);\n         }\n \n         // Push this run onto the stack.\n@@ -1632,7 +1636,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n             let right = runs[r];\n             unsafe {\n                 merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n-                      &mut compare);\n+                      &mut is_less);\n             }\n             runs[r] = Run {\n                 start: left.start,"}]}