{"sha": "22050e3ed44d9b4d79edced506b470a425e0d302", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMDUwZTNlZDQ0ZDliNGQ3OWVkY2VkNTA2YjQ3MGE0MjVlMGQzMDI=", "commit": {"author": {"name": "Florian Wilkens", "email": "floya@live.de", "date": "2014-12-20T14:28:20Z"}, "committer": {"name": "Florian Wilkens", "email": "floya@live.de", "date": "2014-12-22T16:45:34Z"}, "message": "Added missing renames:\n\nlibcollections:\n    AbsEntries -> AbsIter, Entries -> Iter, MoveEntries -> IntoIter, MutEntries -> IterMut\n    DifferenceItems -> Difference, SymDifferenceItems -> SymmetricDifference, IntersectionItems -> Intersection, UnionItems -> Union\n\nlibstd/hash/{table, map}:\n    Entries -> Iter, MoveItems -> IntoIter, MutEntries -> IterMut\n\nAlso a [breaking-change].", "tree": {"sha": "3490261c194034a047dad0faedabdd02acf1b21d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3490261c194034a047dad0faedabdd02acf1b21d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22050e3ed44d9b4d79edced506b470a425e0d302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22050e3ed44d9b4d79edced506b470a425e0d302", "html_url": "https://github.com/rust-lang/rust/commit/22050e3ed44d9b4d79edced506b470a425e0d302", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22050e3ed44d9b4d79edced506b470a425e0d302/comments", "author": {"login": "1wilkens", "id": 2774469, "node_id": "MDQ6VXNlcjI3NzQ0Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/2774469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1wilkens", "html_url": "https://github.com/1wilkens", "followers_url": "https://api.github.com/users/1wilkens/followers", "following_url": "https://api.github.com/users/1wilkens/following{/other_user}", "gists_url": "https://api.github.com/users/1wilkens/gists{/gist_id}", "starred_url": "https://api.github.com/users/1wilkens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1wilkens/subscriptions", "organizations_url": "https://api.github.com/users/1wilkens/orgs", "repos_url": "https://api.github.com/users/1wilkens/repos", "events_url": "https://api.github.com/users/1wilkens/events{/privacy}", "received_events_url": "https://api.github.com/users/1wilkens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "1wilkens", "id": 2774469, "node_id": "MDQ6VXNlcjI3NzQ0Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/2774469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1wilkens", "html_url": "https://github.com/1wilkens", "followers_url": "https://api.github.com/users/1wilkens/followers", "following_url": "https://api.github.com/users/1wilkens/following{/other_user}", "gists_url": "https://api.github.com/users/1wilkens/gists{/gist_id}", "starred_url": "https://api.github.com/users/1wilkens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1wilkens/subscriptions", "organizations_url": "https://api.github.com/users/1wilkens/orgs", "repos_url": "https://api.github.com/users/1wilkens/repos", "events_url": "https://api.github.com/users/1wilkens/events{/privacy}", "received_events_url": "https://api.github.com/users/1wilkens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7", "html_url": "https://github.com/rust-lang/rust/commit/f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7"}], "stats": {"total": 163, "additions": 82, "deletions": 81}, "files": [{"sha": "5e1025ebfb2f9ce6f739e0f6f439e099ecbdc215", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=22050e3ed44d9b4d79edced506b470a425e0d302", "patch": "@@ -240,7 +240,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Iter<T> {\n-        Iter { iter: self.data.iter() } }\n+        Iter { iter: self.data.iter() }\n+    }\n \n     /// Creates a consuming iterator, that is, one that moves each value out of\n     /// the binary heap in arbitrary order.  The binary heap cannot be used"}, {"sha": "24d991cda7298c01e6d780d5522404e9bb21acb6", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=22050e3ed44d9b4d79edced506b470a425e0d302", "patch": "@@ -88,36 +88,36 @@ pub struct BTreeMap<K, V> {\n }\n \n /// An abstract base over-which all other BTree iterators are built.\n-struct AbsEntries<T> {\n+struct AbsIter<T> {\n     lca: T,\n     left: RingBuf<T>,\n     right: RingBuf<T>,\n     size: uint,\n }\n \n /// An iterator over a BTreeMap's entries.\n-pub struct Entries<'a, K: 'a, V: 'a> {\n-    inner: AbsEntries<Traversal<'a, K, V>>\n+pub struct Iter<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-pub struct MutEntries<'a, K: 'a, V: 'a> {\n-    inner: AbsEntries<MutTraversal<'a, K, V>>\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n-pub struct MoveEntries<K, V> {\n-    inner: AbsEntries<MoveTraversal<K, V>>\n+pub struct IntoIter<K, V> {\n+    inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n@@ -929,7 +929,7 @@ enum StackOp<T> {\n }\n \n impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        Iterator<(K, V)> for AbsEntries<T> {\n+        Iterator<(K, V)> for AbsIter<T> {\n     // This function is pretty long, but only because there's a lot of cases to consider.\n     // Our iterator represents two search paths, left and right, to the smallest and largest\n     // elements we have yet to yield. lca represents the least common ancestor of these two paths,\n@@ -995,7 +995,7 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n }\n \n impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        DoubleEndedIterator<(K, V)> for AbsEntries<T> {\n+        DoubleEndedIterator<(K, V)> for AbsIter<T> {\n     // next_back is totally symmetric to next\n     fn next_back(&mut self) -> Option<(K, V)> {\n         loop {\n@@ -1032,34 +1032,34 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n     }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n-impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Entries<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Iter<'a, K, V> {}\n \n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n-impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {}\n \n \n-impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<K, V> DoubleEndedIterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> DoubleEndedIterator<(K, V)> for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n-impl<K, V> ExactSizeIterator<(K, V)> for MoveEntries<K, V> {}\n+impl<K, V> ExactSizeIterator<(K, V)> for IntoIter<K, V> {}\n \n \n impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n@@ -1140,10 +1140,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+    pub fn iter<'a>(&'a self) -> Iter<'a, K, V> {\n         let len = self.len();\n-        Entries {\n-            inner: AbsEntries {\n+        Iter {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(&self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1172,10 +1172,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+    pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, K, V> {\n         let len = self.len();\n-        MutEntries {\n-            inner: AbsEntries {\n+        IterMut {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(&mut self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),\n@@ -1201,10 +1201,10 @@ impl<K, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n-        MoveEntries {\n-            inner: AbsEntries {\n+        IntoIter {\n+            inner: AbsIter {\n                 lca: Traverse::traverse(self.root),\n                 left: RingBuf::new(),\n                 right: RingBuf::new(),"}, {"sha": "3b403d45d82e6f3bc77c496c05eabe81deb98783", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=22050e3ed44d9b4d79edced506b470a425e0d302", "patch": "@@ -13,7 +13,7 @@\n \n use core::prelude::*;\n \n-use btree_map::{BTreeMap, Keys, MoveEntries};\n+use btree_map::{BTreeMap, Keys};\n use std::hash::Hash;\n use core::borrow::BorrowFrom;\n use core::default::Default;\n@@ -39,29 +39,29 @@ pub struct Iter<'a, T: 'a> {\n \n /// An owning iterator over a BTreeSet's items.\n pub struct IntoIter<T> {\n-    iter: Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>\n+    iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n-pub struct DifferenceItems<'a, T:'a> {\n+pub struct Difference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n-pub struct SymDifferenceItems<'a, T:'a> {\n+pub struct SymmetricDifference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n-pub struct IntersectionItems<'a, T:'a> {\n+pub struct Intersection<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n-pub struct UnionItems<'a, T:'a> {\n+pub struct Union<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n@@ -151,8 +151,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> DifferenceItems<'a, T> {\n-        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n+        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the symmetric difference, in ascending order.\n@@ -175,8 +175,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> SymDifferenceItems<'a, T> {\n-        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> SymmetricDifference<'a, T> {\n+        SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the intersection, in ascending order.\n@@ -199,8 +199,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> IntersectionItems<'a, T> {\n-        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> Intersection<'a, T> {\n+        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the union, in ascending order.\n@@ -220,8 +220,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> UnionItems<'a, T> {\n-        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n+        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Return the number of elements in the set\n@@ -573,7 +573,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Difference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n@@ -585,7 +585,7 @@ impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for SymmetricDifference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -597,7 +597,7 @@ impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n@@ -615,7 +615,7 @@ impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n     }\n }\n \n-impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n+impl<'a, T: Ord> Iterator<&'a T> for Union<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {"}, {"sha": "999025840caaabb8dce8884d69afe6d31f2e8e90", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=22050e3ed44d9b4d79edced506b470a425e0d302", "patch": "@@ -176,8 +176,8 @@ impl<V> VecMap<V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'r>(&'r self) -> Entries<'r, V> {\n-        Entries {\n+    pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n+        Iter {\n             front: 0,\n             back: self.v.len(),\n             iter: self.v.iter()\n@@ -207,8 +207,8 @@ impl<V> VecMap<V> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut<'r>(&'r mut self) -> MutEntries<'r, V> {\n-        MutEntries {\n+    pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n+        IterMut {\n             front: 0,\n             back: self.v.len(),\n             iter: self.v.iter_mut()\n@@ -605,34 +605,34 @@ macro_rules! double_ended_iterator {\n }\n \n /// An iterator over the key-value pairs of a map.\n-pub struct Entries<'a, V:'a> {\n+pub struct Iter<'a, V:'a> {\n     front: uint,\n     back: uint,\n     iter: slice::Iter<'a, Option<V>>\n }\n \n-iterator! { impl Entries -> (uint, &'a V), as_ref }\n-double_ended_iterator! { impl Entries -> (uint, &'a V), as_ref }\n+iterator! { impl Iter -> (uint, &'a V), as_ref }\n+double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-pub struct MutEntries<'a, V:'a> {\n+pub struct IterMut<'a, V:'a> {\n     front: uint,\n     back: uint,\n     iter: slice::IterMut<'a, Option<V>>\n }\n \n-iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n-double_ended_iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n+iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n+double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n pub struct Keys<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), uint, Entries<'a, V>, fn((uint, &'a V)) -> uint>\n+    iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n \n /// An iterator over the values of a map.\n pub struct Values<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), &'a V, Entries<'a, V>, fn((uint, &'a V)) -> &'a V>\n+    iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n \n /// A consuming iterator over the key-value pairs of a map."}, {"sha": "26684864c4c49fac5caa115c34853204e1b9355b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=22050e3ed44d9b4d79edced506b470a425e0d302", "patch": "@@ -781,7 +781,7 @@ iterator!{struct Iter -> *const T, &'a T}\n #[experimental = \"needs review\"]\n impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n \n-    #[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }"}, {"sha": "692f120737a5b6d1ad52a63ef7d4808c6ea1677d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=22050e3ed44d9b4d79edced506b470a425e0d302", "patch": "@@ -914,8 +914,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut(&mut self) -> MutEntries<K, V> {\n-        MutEntries { inner: self.table.iter_mut() }\n+    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n+        IterMut { inner: self.table.iter_mut() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each key-value\n@@ -936,10 +936,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n \n-        MoveEntries {\n+        IntoIter {\n             inner: self.table.into_iter().map(last_two)\n         }\n     }\n@@ -1306,16 +1306,16 @@ pub struct Entries<'a, K: 'a, V: 'a> {\n }\n \n /// HashMap mutable values iterator\n-pub struct MutEntries<'a, K: 'a, V: 'a> {\n-    inner: table::MutEntries<'a, K, V>\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n+    inner: table::IterMut<'a, K, V>\n }\n \n /// HashMap move iterator\n-pub struct MoveEntries<K, V> {\n+pub struct IntoIter<K, V> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n         (K, V),\n-        table::MoveEntries<K, V>,\n+        table::IntoIter<K, V>,\n         fn((SafeHash, K, V)) -> (K, V),\n     >\n }\n@@ -1374,12 +1374,12 @@ impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n+impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }"}, {"sha": "a2c31591d8df863131dac6cc41ef591cbe11edb2", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=22050e3ed44d9b4d79edced506b470a425e0d302", "patch": "@@ -21,7 +21,7 @@ use iter::{Iterator, IteratorExt, FromIterator, Map, Chain, Extend};\n use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n-use super::map::{mod, HashMap, MoveEntries, Keys, INITIAL_CAPACITY};\n+use super::map::{mod, HashMap, Keys, INITIAL_CAPACITY};\n \n // FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n \n@@ -625,7 +625,7 @@ pub struct Iter<'a, K: 'a> {\n \n /// HashSet move iterator\n pub struct IntoIter<K> {\n-    iter: Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>\n+    iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator"}, {"sha": "8f2152c5a9ded3ce48be6add6520cf17df4c6b8b", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22050e3ed44d9b4d79edced506b470a425e0d302/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=22050e3ed44d9b4d79edced506b470a425e0d302", "patch": "@@ -664,17 +664,17 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n-    pub fn iter_mut(&mut self) -> MutEntries<K, V> {\n-        MutEntries {\n+    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n+        IterMut {\n             iter: self.raw_buckets(),\n             elems_left: self.size(),\n         }\n     }\n \n-    pub fn into_iter(self) -> MoveEntries<K, V> {\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n         let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n         // Replace the marker regardless of lifetime bounds on parameters.\n-        MoveEntries {\n+        IntoIter {\n             iter: RawBuckets {\n                 raw: raw,\n                 hashes_end: hashes_end,\n@@ -776,13 +776,13 @@ pub struct Entries<'a, K: 'a, V: 'a> {\n }\n \n /// Iterator over mutable references to entries in a table.\n-pub struct MutEntries<'a, K: 'a, V: 'a> {\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n     elems_left: uint,\n }\n \n /// Iterator over the entries in a table, consuming the table.\n-pub struct MoveEntries<K, V> {\n+pub struct IntoIter<K, V> {\n     table: RawTable<K, V>,\n     iter: RawBuckets<'static, K, V>\n }\n@@ -809,7 +809,7 @@ impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n@@ -825,7 +825,7 @@ impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n     }\n }\n \n-impl<K, V> Iterator<(SafeHash, K, V)> for MoveEntries<K, V> {\n+impl<K, V> Iterator<(SafeHash, K, V)> for IntoIter<K, V> {\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n         self.iter.next().map(|bucket| {\n             self.table.size -= 1;"}]}