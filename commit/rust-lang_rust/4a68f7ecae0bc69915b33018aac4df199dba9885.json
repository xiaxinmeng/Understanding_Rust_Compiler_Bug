{"sha": "4a68f7ecae0bc69915b33018aac4df199dba9885", "node_id": "C_kwDOAAsO6NoAKDRhNjhmN2VjYWUwYmM2OTkxNWIzMzAxOGFhYzRkZjE5OWRiYTk4ODU", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-01-04T20:56:46Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-01-06T16:48:13Z"}, "message": "Correctly render sidebar for relative module paths", "tree": {"sha": "2c06c874a137e8050deb45c56d7641b25c923571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c06c874a137e8050deb45c56d7641b25c923571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a68f7ecae0bc69915b33018aac4df199dba9885", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a68f7ecae0bc69915b33018aac4df199dba9885", "html_url": "https://github.com/rust-lang/rust/commit/4a68f7ecae0bc69915b33018aac4df199dba9885", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a68f7ecae0bc69915b33018aac4df199dba9885/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df756439df8110e8e5ff490b68d2886c8c6ae221", "url": "https://api.github.com/repos/rust-lang/rust/commits/df756439df8110e8e5ff490b68d2886c8c6ae221", "html_url": "https://github.com/rust-lang/rust/commit/df756439df8110e8e5ff490b68d2886c8c6ae221"}], "stats": {"total": 144, "additions": 103, "deletions": 41}, "files": [{"sha": "c8899ee62b5f9c7456c96eacc3eaa44600c5a6e8", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4a68f7ecae0bc69915b33018aac4df199dba9885/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68f7ecae0bc69915b33018aac4df199dba9885/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=4a68f7ecae0bc69915b33018aac4df199dba9885", "patch": "@@ -309,7 +309,7 @@ impl<'tcx> Context<'tcx> {\n \n     pub(crate) fn href_from_span(&self, span: clean::Span, with_lines: bool) -> Option<String> {\n         let mut root = self.root_path();\n-        let mut path = String::new();\n+        let mut path: String;\n         let cnum = span.cnum(self.sess());\n \n         // We can safely ignore synthetic `SourceFile`s.\n@@ -340,10 +340,24 @@ impl<'tcx> Context<'tcx> {\n                 ExternalLocation::Unknown => return None,\n             };\n \n-            sources::clean_path(&src_root, file, false, |component| {\n-                path.push_str(&component.to_string_lossy());\n+            let href = RefCell::new(PathBuf::new());\n+            sources::clean_path(\n+                &src_root,\n+                file,\n+                |component| {\n+                    href.borrow_mut().push(component);\n+                },\n+                || {\n+                    href.borrow_mut().pop();\n+                },\n+            );\n+\n+            path = href.into_inner().to_string_lossy().to_string();\n+\n+            if let Some(c) = path.as_bytes().last() && *c != b'/' {\n                 path.push('/');\n-            });\n+            }\n+\n             let mut fname = file.file_name().expect(\"source has no filename\").to_os_string();\n             fname.push(\".html\");\n             path.push_str(&fname.to_string_lossy());"}, {"sha": "3ea4c4bea8828fbc4fbfdb8738b76b6501d9726a", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4a68f7ecae0bc69915b33018aac4df199dba9885/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68f7ecae0bc69915b33018aac4df199dba9885/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=4a68f7ecae0bc69915b33018aac4df199dba9885", "patch": "@@ -1,8 +1,9 @@\n+use std::cell::RefCell;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Component, Path};\n-use std::rc::Rc;\n+use std::rc::{Rc, Weak};\n \n use itertools::Itertools;\n use rustc_data_structures::flock;\n@@ -184,23 +185,26 @@ pub(super) fn write_shared(\n \n     use std::ffi::OsString;\n \n-    #[derive(Debug)]\n+    #[derive(Debug, Default)]\n     struct Hierarchy {\n+        parent: Weak<Self>,\n         elem: OsString,\n-        children: FxHashMap<OsString, Hierarchy>,\n-        elems: FxHashSet<OsString>,\n+        children: RefCell<FxHashMap<OsString, Rc<Self>>>,\n+        elems: RefCell<FxHashSet<OsString>>,\n     }\n \n     impl Hierarchy {\n-        fn new(elem: OsString) -> Hierarchy {\n-            Hierarchy { elem, children: FxHashMap::default(), elems: FxHashSet::default() }\n+        fn with_parent(elem: OsString, parent: &Rc<Self>) -> Self {\n+            Self { elem, parent: Rc::downgrade(parent), ..Self::default() }\n         }\n \n         fn to_json_string(&self) -> String {\n-            let mut subs: Vec<&Hierarchy> = self.children.values().collect();\n+            let borrow = self.children.borrow();\n+            let mut subs: Vec<_> = borrow.values().collect();\n             subs.sort_unstable_by(|a, b| a.elem.cmp(&b.elem));\n             let mut files = self\n                 .elems\n+                .borrow()\n                 .iter()\n                 .map(|s| format!(\"\\\"{}\\\"\", s.to_str().expect(\"invalid osstring conversion\")))\n                 .collect::<Vec<_>>();\n@@ -220,36 +224,52 @@ pub(super) fn write_shared(\n                 files = files\n             )\n         }\n-    }\n \n-    if cx.include_sources {\n-        let mut hierarchy = Hierarchy::new(OsString::new());\n-        for source in cx\n-            .shared\n-            .local_sources\n-            .iter()\n-            .filter_map(|p| p.0.strip_prefix(&cx.shared.src_root).ok())\n-        {\n-            let mut h = &mut hierarchy;\n-            let mut elems = source\n+        fn add_path(self: &Rc<Self>, path: &Path) {\n+            let mut h = Rc::clone(&self);\n+            let mut elems = path\n                 .components()\n                 .filter_map(|s| match s {\n                     Component::Normal(s) => Some(s.to_owned()),\n+                    Component::ParentDir => Some(OsString::from(\"..\")),\n                     _ => None,\n                 })\n                 .peekable();\n             loop {\n                 let cur_elem = elems.next().expect(\"empty file path\");\n+                if cur_elem == \"..\" {\n+                    if let Some(parent) = h.parent.upgrade() {\n+                        h = parent;\n+                    }\n+                    continue;\n+                }\n                 if elems.peek().is_none() {\n-                    h.elems.insert(cur_elem);\n+                    h.elems.borrow_mut().insert(cur_elem);\n                     break;\n                 } else {\n-                    let e = cur_elem.clone();\n-                    h = h.children.entry(cur_elem.clone()).or_insert_with(|| Hierarchy::new(e));\n+                    let entry = Rc::clone(\n+                        h.children\n+                            .borrow_mut()\n+                            .entry(cur_elem.clone())\n+                            .or_insert_with(|| Rc::new(Self::with_parent(cur_elem, &h))),\n+                    );\n+                    h = entry;\n                 }\n             }\n         }\n+    }\n \n+    if cx.include_sources {\n+        let hierarchy = Rc::new(Hierarchy::default());\n+        for source in cx\n+            .shared\n+            .local_sources\n+            .iter()\n+            .filter_map(|p| p.0.strip_prefix(&cx.shared.src_root).ok())\n+        {\n+            hierarchy.add_path(source);\n+        }\n+        let hierarchy = Rc::try_unwrap(hierarchy).unwrap();\n         let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n         let make_sources = || {\n             let (mut all_sources, _krates) ="}, {"sha": "799c497d13709a00d95c7fcf6a07dc2fc482f8c4", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4a68f7ecae0bc69915b33018aac4df199dba9885/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a68f7ecae0bc69915b33018aac4df199dba9885/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4a68f7ecae0bc69915b33018aac4df199dba9885", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::source_map::FileName;\n \n+use std::cell::RefCell;\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n@@ -72,12 +73,22 @@ impl LocalSourcesCollector<'_, '_> {\n             return;\n         }\n \n-        let mut href = String::new();\n-        clean_path(self.src_root, &p, false, |component| {\n-            href.push_str(&component.to_string_lossy());\n-            href.push('/');\n-        });\n+        let href = RefCell::new(PathBuf::new());\n+        clean_path(\n+            &self.src_root,\n+            &p,\n+            |component| {\n+                href.borrow_mut().push(component);\n+            },\n+            || {\n+                href.borrow_mut().pop();\n+            },\n+        );\n \n+        let mut href = href.into_inner().to_string_lossy().to_string();\n+        if let Some(c) = href.as_bytes().last() && *c != b'/' {\n+            href.push('/');\n+        }\n         let mut src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n         src_fname.push(\".html\");\n         href.push_str(&src_fname.to_string_lossy());\n@@ -180,13 +191,28 @@ impl SourceCollector<'_, '_> {\n \n         let shared = Rc::clone(&self.cx.shared);\n         // Create the intermediate directories\n-        let mut cur = self.dst.clone();\n-        let mut root_path = String::from(\"../../\");\n-        clean_path(&shared.src_root, &p, false, |component| {\n-            cur.push(component);\n-            root_path.push_str(\"../\");\n-        });\n+        let cur = RefCell::new(PathBuf::new());\n+        let root_path = RefCell::new(PathBuf::new());\n+\n+        clean_path(\n+            &shared.src_root,\n+            &p,\n+            |component| {\n+                cur.borrow_mut().push(component);\n+                root_path.borrow_mut().push(\"..\");\n+            },\n+            || {\n+                cur.borrow_mut().pop();\n+                root_path.borrow_mut().pop();\n+            },\n+        );\n \n+        let root_path = PathBuf::from(\"../../\").join(root_path.into_inner());\n+        let mut root_path = root_path.to_string_lossy();\n+        if let Some(c) = root_path.as_bytes().last() && *c != b'/' {\n+            root_path += \"/\";\n+        }\n+        let mut cur = self.dst.join(cur.into_inner());\n         shared.ensure_dir(&cur)?;\n \n         let src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n@@ -232,24 +258,26 @@ impl SourceCollector<'_, '_> {\n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree. Each component in the cleaned path will be passed as an\n-/// argument to `f`. The very last component of the path (ie the file name) will\n-/// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-pub(crate) fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+/// argument to `f`. The very last component of the path (ie the file name) is ignored.\n+/// If a `..` is encountered, the `parent` closure will be called to allow the callee to\n+/// handle it.\n+pub(crate) fn clean_path<F, P>(src_root: &Path, p: &Path, mut f: F, mut parent: P)\n where\n     F: FnMut(&OsStr),\n+    P: FnMut(),\n {\n     // make it relative, if possible\n     let p = p.strip_prefix(src_root).unwrap_or(p);\n \n     let mut iter = p.components().peekable();\n \n     while let Some(c) = iter.next() {\n-        if !keep_filename && iter.peek().is_none() {\n+        if iter.peek().is_none() {\n             break;\n         }\n \n         match c {\n-            Component::ParentDir => f(\"up\".as_ref()),\n+            Component::ParentDir => parent(),\n             Component::Normal(c) => f(c),\n             _ => continue,\n         }"}]}