{"sha": "adac6cb5c61dfae79901264af4c235b66fb6267a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYWM2Y2I1YzYxZGZhZTc5OTAxMjY0YWY0YzIzNWI2NmZiNjI2N2E=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-02-15T02:29:36Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-02-15T02:29:36Z"}, "message": "Moved numeric string conversion functions into own module", "tree": {"sha": "19e6f65e63412cac8656a30576f87a314611ac88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19e6f65e63412cac8656a30576f87a314611ac88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adac6cb5c61dfae79901264af4c235b66fb6267a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adac6cb5c61dfae79901264af4c235b66fb6267a", "html_url": "https://github.com/rust-lang/rust/commit/adac6cb5c61dfae79901264af4c235b66fb6267a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adac6cb5c61dfae79901264af4c235b66fb6267a/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf27352953dba644568118a254ac4a3c3035daa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf27352953dba644568118a254ac4a3c3035daa0", "html_url": "https://github.com/rust-lang/rust/commit/bf27352953dba644568118a254ac4a3c3035daa0"}], "stats": {"total": 1246, "additions": 642, "deletions": 604}, "files": [{"sha": "3c5de1b703b7eb24c45afc264360d449cd56a7bf", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=adac6cb5c61dfae79901264af4c235b66fb6267a", "patch": "@@ -14,6 +14,7 @@ use cmath;\n use cmp;\n use libc::{c_float, c_int};\n use num::NumCast;\n+use num::strconv;\n use num;\n use ops;\n use option::Option;\n@@ -376,8 +377,8 @@ impl num::Round for f32 {\n  */\n #[inline(always)]\n pub pure fn to_str(num: f32) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -390,8 +391,8 @@ pub pure fn to_str(num: f32) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_hex(num: f32) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    let (r, _) = strconv::to_str_common(\n+        &num, 16u, true, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -411,8 +412,8 @@ pub pure fn to_str_hex(num: f32) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n-    let (r, special) = num::to_str_common(\n-        &num, rdx, true, true, num::SignNeg, num::DigAll);\n+    let (r, special) = strconv::to_str_common(\n+        &num, rdx, true, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n                       try to_str_radix_special() if those are expected\") }\n     r\n@@ -429,7 +430,8 @@ pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n-    num::to_str_common(&num, rdx, true, true, num::SignNeg, num::DigAll)\n+    strconv::to_str_common(&num, rdx, true, true,\n+                           strconv::SignNeg, strconv::DigAll)\n }\n \n /**\n@@ -443,8 +445,8 @@ pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n  */\n #[inline(always)]\n pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigExact(dig));\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n@@ -459,8 +461,8 @@ pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_digits(num: f32, dig: uint) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigMax(dig));\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n@@ -505,7 +507,8 @@ impl num::ToStrRadix for f32 {\n  */\n #[inline(always)]\n pub pure fn from_str(num: &str) -> Option<f32> {\n-    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+    strconv::from_str_common(num, 10u, true, true, true,\n+                             strconv::ExpDec, false)\n }\n \n /**\n@@ -537,7 +540,8 @@ pub pure fn from_str(num: &str) -> Option<f32> {\n  */\n #[inline(always)]\n pub pure fn from_str_hex(num: &str) -> Option<f32> {\n-    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+    strconv::from_str_common(num, 16u, true, true, true,\n+                             strconv::ExpBin, false)\n }\n \n /**\n@@ -561,7 +565,8 @@ pub pure fn from_str_hex(num: &str) -> Option<f32> {\n  */\n #[inline(always)]\n pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n-    num::from_str_common(num, rdx, true, true, false, num::ExpNone, false)\n+    strconv::from_str_common(num, rdx, true, true, false,\n+                             strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for f32 {"}, {"sha": "0bd6e0e9d7718d382d67382bb46b1600ed9054d6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=adac6cb5c61dfae79901264af4c235b66fb6267a", "patch": "@@ -15,6 +15,7 @@ use cmp;\n use libc::{c_double, c_int};\n use libc;\n use num::NumCast;\n+use num::strconv;\n use num;\n use ops;\n use option::Option;\n@@ -401,8 +402,8 @@ impl num::Round for f64 {\n  */\n #[inline(always)]\n pub pure fn to_str(num: f64) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -415,8 +416,8 @@ pub pure fn to_str(num: f64) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_hex(num: f64) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    let (r, _) = strconv::to_str_common(\n+        &num, 16u, true, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -436,8 +437,8 @@ pub pure fn to_str_hex(num: f64) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n-    let (r, special) = num::to_str_common(\n-        &num, rdx, true, true, num::SignNeg, num::DigAll);\n+    let (r, special) = strconv::to_str_common(\n+        &num, rdx, true, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n                       try to_str_radix_special() if those are expected\") }\n     r\n@@ -454,7 +455,8 @@ pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n-    num::to_str_common(&num, rdx, true, true, num::SignNeg, num::DigAll)\n+    strconv::to_str_common(&num, rdx, true, true,\n+                           strconv::SignNeg, strconv::DigAll)\n }\n \n /**\n@@ -468,8 +470,8 @@ pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n  */\n #[inline(always)]\n pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigExact(dig));\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n@@ -484,8 +486,8 @@ pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_digits(num: f64, dig: uint) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigMax(dig));\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigMax(dig));\n     r\n }\n \n@@ -530,7 +532,8 @@ impl num::ToStrRadix for f64 {\n  */\n #[inline(always)]\n pub pure fn from_str(num: &str) -> Option<f64> {\n-    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+    strconv::from_str_common(num, 10u, true, true, true,\n+                             strconv::ExpDec, false)\n }\n \n /**\n@@ -562,7 +565,8 @@ pub pure fn from_str(num: &str) -> Option<f64> {\n  */\n #[inline(always)]\n pub pure fn from_str_hex(num: &str) -> Option<f64> {\n-    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+    strconv::from_str_common(num, 16u, true, true, true,\n+                             strconv::ExpBin, false)\n }\n \n /**\n@@ -586,7 +590,8 @@ pub pure fn from_str_hex(num: &str) -> Option<f64> {\n  */\n #[inline(always)]\n pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n-    num::from_str_common(num, rdx, true, true, false, num::ExpNone, false)\n+    strconv::from_str_common(num, rdx, true, true, false,\n+                             strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for f64 {"}, {"sha": "87879f6d7ad5d06b49d1118afc64fb8e1f0441c6", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=adac6cb5c61dfae79901264af4c235b66fb6267a", "patch": "@@ -26,6 +26,7 @@ use cmp::{Eq, Ord};\n use cmp;\n use f64;\n use num::NumCast;\n+use num::strconv;\n use num;\n use ops;\n use option::{None, Option, Some};\n@@ -107,8 +108,8 @@ pub mod consts {\n  */\n #[inline(always)]\n pub pure fn to_str(num: float) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -121,8 +122,8 @@ pub pure fn to_str(num: float) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_hex(num: float) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    let (r, _) = strconv::to_str_common(\n+        &num, 16u, true, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n@@ -142,8 +143,8 @@ pub pure fn to_str_hex(num: float) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n-    let (r, special) = num::to_str_common(\n-        &num, radix, true, true, num::SignNeg, num::DigAll);\n+    let (r, special) = strconv::to_str_common(\n+        &num, radix, true, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n                       try to_str_radix_special() if those are expected\") }\n     r\n@@ -160,7 +161,8 @@ pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n-    num::to_str_common(&num, radix, true, true, num::SignNeg, num::DigAll)\n+    strconv::to_str_common(&num, radix, true, true,\n+                           strconv::SignNeg, strconv::DigAll)\n }\n \n /**\n@@ -174,8 +176,8 @@ pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n  */\n #[inline(always)]\n pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigExact(digits));\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigExact(digits));\n     r\n }\n \n@@ -196,8 +198,8 @@ pub fn test_to_str_exact_do_decimal() {\n  */\n #[inline(always)]\n pub pure fn to_str_digits(num: float, digits: uint) -> ~str {\n-    let (r, _) = num::to_str_common(\n-        &num, 10u, true, true, num::SignNeg, num::DigMax(digits));\n+    let (r, _) = strconv::to_str_common(\n+        &num, 10u, true, true, strconv::SignNeg, strconv::DigMax(digits));\n     r\n }\n \n@@ -242,7 +244,8 @@ impl num::ToStrRadix for float {\n  */\n #[inline(always)]\n pub pure fn from_str(num: &str) -> Option<float> {\n-    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+    strconv::from_str_common(num, 10u, true, true, true,\n+                             strconv::ExpDec, false)\n }\n \n /**\n@@ -274,7 +277,8 @@ pub pure fn from_str(num: &str) -> Option<float> {\n  */\n #[inline(always)]\n pub pure fn from_str_hex(num: &str) -> Option<float> {\n-    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+    strconv::from_str_common(num, 16u, true, true, true,\n+                             strconv::ExpBin, false)\n }\n \n /**\n@@ -298,7 +302,8 @@ pub pure fn from_str_hex(num: &str) -> Option<float> {\n  */\n #[inline(always)]\n pub pure fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n-    num::from_str_common(num, radix, true, true, false, num::ExpNone, false)\n+    strconv::from_str_common(num, radix, true, true, false,\n+                             strconv::ExpNone, false)\n }\n \n impl from_str::FromStr for float {"}, {"sha": "df9756423ef7f02e916150e239293a0f8b3f7006", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=adac6cb5c61dfae79901264af4c235b66fb6267a", "patch": "@@ -16,6 +16,7 @@ use cmp;\n use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n+use num::strconv;\n use num;\n use prelude::*;\n use str;\n@@ -218,22 +219,22 @@ impl ops::Neg<T> for T {\n /// Parse a string as a number in base 10.\n #[inline(always)]\n pub pure fn from_str(s: &str) -> Option<T> {\n-    num::from_str_common(s, 10u, true, false, false,\n-                         num::ExpNone, false)\n+    strconv::from_str_common(s, 10u, true, false, false,\n+                         strconv::ExpNone, false)\n }\n \n /// Parse a string as a number in the given base.\n #[inline(always)]\n pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n-    num::from_str_common(s, radix, true, false, false,\n-                         num::ExpNone, false)\n+    strconv::from_str_common(s, radix, true, false, false,\n+                         strconv::ExpNone, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n #[inline(always)]\n pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n-    num::from_str_bytes_common(buf, radix, true, false, false,\n-                               num::ExpNone, false)\n+    strconv::from_str_bytes_common(buf, radix, true, false, false,\n+                               strconv::ExpNone, false)\n }\n \n impl FromStr for T {\n@@ -255,24 +256,24 @@ impl FromStrRadix for T {\n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n-    let (buf, _) = num::to_str_bytes_common(&n, radix, false, false,\n-                                            num::SignNeg, num::DigAll);\n+    let (buf, _) = strconv::to_str_bytes_common(&n, radix, false, false,\n+                            strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n pub pure fn to_str(num: T) -> ~str {\n-    let (buf, _) = num::to_str_common(&num, 10u, false, false,\n-                                      num::SignNeg, num::DigAll);\n+    let (buf, _) = strconv::to_str_common(&num, 10u, false, false,\n+                                      strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n-    let (buf, _) = num::to_str_common(&num, radix, false, false,\n-                                      num::SignNeg, num::DigAll);\n+    let (buf, _) = strconv::to_str_common(&num, radix, false, false,\n+                                      strconv::SignNeg, strconv::DigAll);\n     buf\n }\n "}, {"sha": "af322e9b6c6fd5a1bdfa092730ef06a731def0b1", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 3, "deletions": 538, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=adac6cb5c61dfae79901264af4c235b66fb6267a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -17,6 +17,8 @@ use str;\n use kinds::Copy;\n use vec;\n \n+pub mod strconv;\n+\n pub trait IntConvertible {\n     pure fn to_int(&self) -> int;\n     static pure fn from_int(n: int) -> Self;\n@@ -186,540 +188,3 @@ pub pure fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n     total\n }\n \n-pub enum ExponentFormat {\n-    ExpNone,\n-    ExpDec,\n-    ExpBin\n-}\n-\n-pub enum SignificantDigits {\n-    DigAll,\n-    DigMax(uint),\n-    DigExact(uint)\n-}\n-\n-pub enum SignFormat {\n-    SignNone,\n-    SignNeg,\n-    SignAll\n-}\n-\n-/**\n- * Converts a number to its string representation as a byte vector.\n- * This is meant to be a common base implementation for all numeric string\n- * conversion functions like `to_str()` or `to_str_radix()`.\n- *\n- * # Arguments\n- * - `num`           - The number to convert. Accepts any number that\n- *                     implements the numeric traits.\n- * - `radix`         - Base to use. Accepts only the values 2-36.\n- * - `special`       - Whether to attempt to compare to special values like\n- *                     `inf` or `NaN`. Also needed to detect negative 0.\n- *                     Can fail if it doesn't match `num`s type\n- *                     (see safety note).\n- * - `negative_zero` - Whether to treat the special value `-0` as\n- *                     `-0` or as `+0`.\n- * - `sign`          - How to emit the sign. Options are:\n- *     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n- *     - `SignNeg`:  Only `-` on negative values.\n- *     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n- * - `digits`        - The amount of digits to use for emitting the\n- *                     fractional part, if any. Options are:\n- *     - `DigAll`:         All calculatable digits. Beware of bignums or\n- *                         fractions!\n- *     - `DigMax(uint)`:   Maximum N digits, truncating any trailing zeros.\n- *     - `DigExact(uint)`: Exactly N digits.\n- *\n- * # Return value\n- * A tuple containing the byte vector, and a boolean flag indicating\n- * whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n- * It returns a tuple because there can be ambiguity between a special value\n- * and a number representation at higher bases.\n- *\n- * # Failure\n- * - Fails if `radix` < 2 or `radix` > 36.\n- * - Fails on wrong value for `special` (see safety note).\n- *\n- * # Safety note\n- * The function detects the special values `inf`, `-inf` and `NaN` by\n- * dynamically comparing `num` to `1 / 0`, `-1 / 0` and `0 / 0`\n- * (each of type T) if `special` is `true`. This will fail on integer types\n- * with a 'divide by zero'. Likewise, it will fail if `num` **is** one of\n- * those special values, and `special` is `false`, because then the\n- * algorithm just does normal calculations on them.\n- */\n-pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n-                                  Neg<T>+Modulo<T,T>+Mul<T,T>>(\n-        num: &T, radix: uint, special: bool, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n-    if radix as int <  2 {\n-        fail!(fmt!(\"to_str_bytes_common: radix %? to low, \\\n-                   must lie in the range [2, 36]\", radix));\n-    } else if radix as int > 36 {\n-        fail!(fmt!(\"to_str_bytes_common: radix %? to high, \\\n-                   must lie in the range [2, 36]\", radix));\n-    }\n-\n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n-\n-    if special {\n-        if is_NaN(num) {\n-            return (str::to_bytes(\"NaN\"), true);\n-        } else if is_infinity(num){\n-            return match sign {\n-                SignAll => (str::to_bytes(\"+inf\"), true),\n-                _       => (str::to_bytes(\"inf\"), true)\n-            }\n-        } else if is_neg_infinity(num) {\n-            return match sign {\n-                SignNone => (str::to_bytes(\"inf\"), true),\n-                _        => (str::to_bytes(\"-inf\"), true),\n-            }\n-        }\n-    }\n-\n-    let neg = *num < _0 || (negative_zero && *num == _0\n-                            && special && is_neg_zero(num));\n-    let mut buf: ~[u8] = ~[];\n-    let radix_gen: T   = cast(radix as int);\n-\n-    let mut deccum;\n-\n-    // First emit the non-fractional part, looping at least once to make\n-    // sure at least a `0` gets emitted.\n-    deccum = num.round(RoundToZero);\n-    loop {\n-        // Calculate the absolute value of each digit instead of only\n-        // doing it once for the whole number because a\n-        // representable negative number doesn't necessary have an\n-        // representable additive inverse of the same type\n-        // (See twos complement). But we assume that for the\n-        // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit_signed = deccum % radix_gen;\n-        let current_digit = if current_digit_signed < _0 {\n-            -current_digit_signed\n-        } else {\n-            current_digit_signed\n-        };\n-\n-        // Decrease the deccumulator one digit at a time\n-        deccum /= radix_gen;\n-        deccum = deccum.round(RoundToZero);\n-\n-        unsafe { // FIXME: Pureness workaround (#4568)\n-            buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n-                 .unwrap() as u8);\n-        }\n-\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // If limited digits, calculate one digit more for rounding.\n-    let (limit_digits, digit_count, exact) = match digits {\n-        DigAll          => (false, 0u,      false),\n-        DigMax(count)   => (true,  count+1, false),\n-        DigExact(count) => (true,  count+1, true)\n-    };\n-\n-    // Decide what sign to put in front\n-    match sign {\n-        SignNeg | SignAll if neg => {\n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push('-' as u8);\n-            }\n-        }\n-        SignAll => {\n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push('+' as u8);\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    unsafe { // FIXME: Pureness workaround (#4568)\n-        vec::reverse(buf);\n-    }\n-\n-    // Remember start of the fractional digits.\n-    // Points one beyond end of buf if none get generated,\n-    // or at the '.' otherwise.\n-    let start_fractional_digits = buf.len();\n-\n-    // Now emit the fractional part, if any\n-    deccum = num.fract();\n-    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        unsafe { // FIXME: Pureness workaround (#4568)\n-            buf.push('.' as u8);\n-        }\n-        let mut dig = 0u;\n-\n-        // calculate new digits while\n-        // - there is no limit and there are digits left\n-        // - or there is a limit, it's not reached yet and\n-        //   - it's exact\n-        //   - or it's a maximum, and there are still digits left\n-        while (!limit_digits && deccum != _0)\n-           || (limit_digits && dig < digit_count && (\n-                   exact\n-                || (!exact && deccum != _0)\n-              )\n-        ) {\n-            // Shift first fractional digit into the integer part\n-            deccum *= radix_gen;\n-\n-            // Calculate the absolute value of each digit.\n-            // See note in first loop.\n-            let current_digit_signed = deccum.round(RoundToZero);\n-            let current_digit = if current_digit_signed < _0 {\n-                -current_digit_signed\n-            } else {\n-                current_digit_signed\n-            };\n-\n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push(char::from_digit(\n-                    current_digit.to_int() as uint, radix).unwrap() as u8);\n-            }\n-\n-            // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fract();\n-            dig += 1u;\n-        }\n-\n-        // If digits are limited, and that limit has been reached,\n-        // cut off the one extra digit, and depending on its value\n-        // round the remaining ones.\n-        if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n-                char::to_digit(chr as char, radix).unwrap() as uint\n-            };\n-            let value2ascii = |val: uint| {\n-                char::from_digit(val, radix).unwrap() as u8\n-            };\n-\n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                let extra_digit = ascii2value(buf.pop());\n-                if extra_digit >= radix / 2 { // -> need to round\n-                    let mut i: int = buf.len() as int - 1;\n-                    loop {\n-                        // If reached left end of number, have to\n-                        // insert additional digit:\n-                        if i < 0\n-                        || buf[i] == '-' as u8\n-                        || buf[i] == '+' as u8 {\n-                            buf.insert((i + 1) as uint, value2ascii(1));\n-                            break;\n-                        }\n-\n-                        // Skip the '.'\n-                        if buf[i] == '.' as u8 { i -= 1; loop; }\n-\n-                        // Either increment the digit,\n-                        // or set to 0 if max and carry the 1.\n-                        let current_digit = ascii2value(buf[i]);\n-                        if current_digit < (radix - 1) {\n-                            buf[i] = value2ascii(current_digit+1);\n-                            break;\n-                        } else {\n-                            buf[i] = value2ascii(0);\n-                            i -= 1;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // if number of digits is not exact, remove all trailing '0's up to\n-    // and including the '.'\n-    if !exact {\n-        let buf_max_i = buf.len() - 1;\n-\n-        // index to truncate from\n-        let mut i = buf_max_i;\n-\n-        // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == '0' as u8 {\n-            i -= 1;\n-        }\n-\n-        // Only attempt to truncate digits if buf has fractional digits\n-        if i >= start_fractional_digits {\n-            // If buf ends with '.', cut that too.\n-            if buf[i] == '.' as u8 { i -= 1 }\n-\n-            // only resize buf if we actually remove digits\n-            if i < buf_max_i {\n-                buf = buf.slice(0, i + 1);\n-            }\n-        }\n-    } // If exact and trailing '.', just cut that\n-    else {\n-        let max_i = buf.len() - 1;\n-        if buf[max_i] == '.' as u8 {\n-            buf = buf.slice(0, max_i);\n-        }\n-    }\n-\n-    (buf, false)\n-}\n-\n-/**\n- * Converts a number to its string representation. This is a wrapper for\n- * `to_str_bytes_common()`, for details see there.\n- */\n-#[inline(always)]\n-pub pure fn to_str_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+Neg<T>\n-                            +Modulo<T,T>+Mul<T,T>>(\n-        num: &T, radix: uint, special: bool, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n-    let (bytes, special) = to_str_bytes_common(num, radix, special,\n-                               negative_zero, sign, digits);\n-    (str::from_bytes(bytes), special)\n-}\n-\n-// Some constants for from_str_bytes_common's input validation,\n-// they define minimum radix values for which the character is a valid digit.\n-priv const DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n-priv const DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n-priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n-\n-/**\n- * Parses a byte slice as a number. This is meant to\n- * be a common base implementation for all numeric string conversion\n- * functions like `from_str()` or `from_str_radix()`.\n- *\n- * # Arguments\n- * - `buf`        - The byte slice to parse.\n- * - `radix`      - Which base to parse the number as. Accepts 2-36.\n- * - `negative`   - Whether to accept negative numbers.\n- * - `fractional` - Whether to accept numbers with fractional parts.\n- * - `special`    - Whether to accept special values like `inf`\n- *                  and `NaN`. Can conflict with `radix`, see Failure.\n- * - `exponent`   - Which exponent format to accept. Options are:\n- *     - `ExpNone`: No Exponent, accepts just plain numbers like `42` or\n- *                  `-8.2`.\n- *     - `ExpDec`:  Accepts numbers with a decimal exponent like `42e5` or\n- *                  `8.2E-2`. The exponent string itself is always base 10.\n- *                  Can conflict with `radix`, see Failure.\n- *     - `ExpBin`:  Accepts numbers with a binary exponent like `42P-8` or\n- *                  `FFp128`. The exponent string itself is always base 10.\n- *                  Can conflict with `radix`, see Failure.\n- * - `empty_zero` - Whether to accept a empty `buf` as a 0 or not.\n- *\n- * # Return value\n- * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n- * `None` otherwise, depending on the constraints set by the remaining\n- * arguments.\n- *\n- * # Failure\n- * - Fails if `radix` < 2 or `radix` > 36.\n- * - Fails if `radix` > 14 and `exponent` is `ExpDec` due to conflict\n- *   between digit and exponent sign `'e'`.\n- * - Fails if `radix` > 25 and `exponent` is `ExpBin` due to conflict\n- *   between digit and exponent sign `'p'`.\n- * - Fails if `radix` > 18 and `special == true` due to conflict\n- *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n- *\n- * # Possible improvements\n- * - Could accept option to allow ignoring underscores, allowing for numbers\n- *   formated like `FF_AE_FF_FF`.\n- */\n-pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n-                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>>(\n-        buf: &[u8], radix: uint, negative: bool, fractional: bool,\n-        special: bool, exponent: ExponentFormat, empty_zero: bool\n-        ) -> Option<T> {\n-    match exponent {\n-        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => fail!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n-                        use of 'e' as decimal exponent\", radix)),\n-        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => fail!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n-                        use of 'p' as binary exponent\", radix)),\n-        _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => fail!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n-                        special values 'inf' and 'NaN'\", radix)),\n-        _ if radix as int < 2\n-          => fail!(fmt!(\"from_str_bytes_common: radix %? to low, \\\n-                        must lie in the range [2, 36]\", radix)),\n-        _ if radix as int > 36\n-          => fail!(fmt!(\"from_str_bytes_common: radix %? to high, \\\n-                        must lie in the range [2, 36]\", radix)),\n-        _ => ()\n-    }\n-\n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n-    let radix_gen: T = cast(radix as int);\n-\n-    let len = buf.len();\n-\n-    if len == 0 {\n-        if empty_zero {\n-            return Some(_0);\n-        } else {\n-            return None;\n-        }\n-    }\n-\n-    if special {\n-        if buf == str::to_bytes(\"inf\") || buf == str::to_bytes(\"+inf\") {\n-            return Some(infinity());\n-        } else if buf == str::to_bytes(\"-inf\") {\n-            if negative {\n-                return Some(neg_infinity());\n-            } else {\n-                return None;\n-            }\n-        } else if buf == str::to_bytes(\"NaN\") {\n-            return Some(NaN());\n-        }\n-    }\n-\n-    let (start, accum_positive) = match buf[0] {\n-      '-' as u8 if !negative => return None,\n-      '-' as u8 => (1u, false),\n-      '+' as u8 => (1u, true),\n-       _        => (0u, true)\n-    };\n-\n-    // Initialize accumulator with signed zero for floating point parsing to\n-    // work\n-    let mut accum      = if accum_positive { _0 } else { -_1 * _0};\n-    let mut last_accum = accum; // Necessary to detect overflow\n-    let mut i          = start;\n-    let mut exp_found  = false;\n-\n-    // Parse integer part of number\n-    while i < len {\n-        let c = buf[i] as char;\n-\n-        match char::to_digit(c, radix) {\n-            Some(digit) => {\n-                // shift accum one digit left\n-                accum *= radix_gen;\n-\n-                // add/subtract current digit depending on sign\n-                if accum_positive {\n-                    accum += cast(digit as int);\n-                } else {\n-                    accum -= cast(digit as int);\n-                }\n-\n-                // Detect overflow by comparing to last value\n-                if accum_positive && accum < last_accum { return None; }\n-                if !accum_positive && accum > last_accum { return None; }\n-                last_accum = accum;\n-            }\n-            None => match c {\n-                'e' | 'E' | 'p' | 'P' => {\n-                    exp_found = true;\n-                    break;                       // start of exponent\n-                }\n-                '.' if fractional => {\n-                    i += 1u;                     // skip the '.'\n-                    break;                       // start of fractional part\n-                }\n-                _ => return None                 // invalid number\n-            }\n-        }\n-\n-        i += 1u;\n-    }\n-\n-    // Parse fractional part of number\n-    // Skip if already reached start of exponent\n-    if !exp_found {\n-        let mut power = _1;\n-\n-        while i < len {\n-            let c = buf[i] as char;\n-\n-            match char::to_digit(c, radix) {\n-                Some(digit) => {\n-                    // Decrease power one order of magnitude\n-                    power /= radix_gen;\n-\n-                    let digit_t: T = cast(digit);\n-\n-                    // add/subtract current digit depending on sign\n-                    if accum_positive {\n-                        accum += digit_t * power;\n-                    } else {\n-                        accum -= digit_t * power;\n-                    }\n-\n-                    // Detect overflow by comparing to last value\n-                    if accum_positive && accum < last_accum { return None; }\n-                    if !accum_positive && accum > last_accum { return None; }\n-                    last_accum = accum;\n-                }\n-                None => match c {\n-                    'e' | 'E' | 'p' | 'P' => {\n-                        exp_found = true;\n-                        break;                   // start of exponent\n-                    }\n-                    _ => return None             // invalid number\n-                }\n-            }\n-\n-            i += 1u;\n-        }\n-    }\n-\n-    // Special case: buf not empty, but does not contain any digit in front\n-    // of the exponent sign -> number is empty string\n-    if i == start {\n-        if empty_zero {\n-            return Some(_0);\n-        } else {\n-            return None;\n-        }\n-    }\n-\n-    let mut multiplier = _1;\n-\n-    if exp_found {\n-        let c = buf[i] as char;\n-        let base = match (c, exponent) {\n-            ('e', ExpDec) | ('E', ExpDec) => 10u,\n-            ('p', ExpBin) | ('P', ExpBin) => 2u,\n-            _ => return None // char doesn't fit given exponent format\n-        };\n-\n-        // parse remaining bytes as decimal integer,\n-        // skipping the exponent char\n-        let exp: Option<int> = from_str_bytes_common(\n-            buf.view(i+1, len), 10, true, false, false, ExpNone, false);\n-\n-        match exp {\n-            Some(exp_pow) => {\n-                multiplier = if exp_pow < 0 {\n-                    _1 / pow_with_uint::<T>(base, (-exp_pow.to_int()) as uint)\n-                } else {\n-                    pow_with_uint::<T>(base, exp_pow.to_int() as uint)\n-                }\n-            }\n-            None => return None // invalid exponent -> invalid number\n-        }\n-    }\n-\n-    Some(accum * multiplier)\n-}\n-\n-/**\n- * Parses a string as a number. This is a wrapper for\n- * `from_str_bytes_common()`, for details see there.\n- */\n-#[inline(always)]\n-pub pure fn from_str_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+Mul<T,T>+\n-                              Sub<T,T>+Neg<T>+Add<T,T>>(\n-        buf: &str, radix: uint, negative: bool, fractional: bool,\n-        special: bool, exponent: ExponentFormat, empty_zero: bool\n-        ) -> Option<T> {\n-    from_str_bytes_common(str::to_bytes(buf), radix, negative,\n-                            fractional, special, exponent, empty_zero)\n-}"}, {"sha": "6aa933ffbed54261217bb079e49105e13c934aa3", "filename": "src/libcore/num/strconv.rs", "status": "added", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=adac6cb5c61dfae79901264af4c235b66fb6267a", "patch": "@@ -0,0 +1,556 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::cmp::{Ord, Eq};\n+use ops::{Add, Div, Modulo, Mul, Neg, Sub};\n+use option::{None, Option, Some};\n+use char;\n+use str;\n+use kinds::Copy;\n+use vec;\n+use num::*;\n+\n+pub enum ExponentFormat {\n+    ExpNone,\n+    ExpDec,\n+    ExpBin\n+}\n+\n+pub enum SignificantDigits {\n+    DigAll,\n+    DigMax(uint),\n+    DigExact(uint)\n+}\n+\n+pub enum SignFormat {\n+    SignNone,\n+    SignNeg,\n+    SignAll\n+}\n+\n+/**\n+ * Converts a number to its string representation as a byte vector.\n+ * This is meant to be a common base implementation for all numeric string\n+ * conversion functions like `to_str()` or `to_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `num`           - The number to convert. Accepts any number that\n+ *                     implements the numeric traits.\n+ * - `radix`         - Base to use. Accepts only the values 2-36.\n+ * - `special`       - Whether to attempt to compare to special values like\n+ *                     `inf` or `NaN`. Also needed to detect negative 0.\n+ *                     Can fail if it doesn't match `num`s type\n+ *                     (see safety note).\n+ * - `negative_zero` - Whether to treat the special value `-0` as\n+ *                     `-0` or as `+0`.\n+ * - `sign`          - How to emit the sign. Options are:\n+ *     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n+ *     - `SignNeg`:  Only `-` on negative values.\n+ *     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n+ * - `digits`        - The amount of digits to use for emitting the\n+ *                     fractional part, if any. Options are:\n+ *     - `DigAll`:         All calculatable digits. Beware of bignums or\n+ *                         fractions!\n+ *     - `DigMax(uint)`:   Maximum N digits, truncating any trailing zeros.\n+ *     - `DigExact(uint)`: Exactly N digits.\n+ *\n+ * # Return value\n+ * A tuple containing the byte vector, and a boolean flag indicating\n+ * whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n+ * It returns a tuple because there can be ambiguity between a special value\n+ * and a number representation at higher bases.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails on wrong value for `special` (see safety note).\n+ *\n+ * # Safety note\n+ * The function detects the special values `inf`, `-inf` and `NaN` by\n+ * dynamically comparing `num` to `1 / 0`, `-1 / 0` and `0 / 0`\n+ * (each of type T) if `special` is `true`. This will fail on integer types\n+ * with a 'divide by zero'. Likewise, it will fail if `num` **is** one of\n+ * those special values, and `special` is `false`, because then the\n+ * algorithm just does normal calculations on them.\n+ */\n+pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+\n+                                  Neg<T>+Modulo<T,T>+Mul<T,T>>(\n+        num: &T, radix: uint, special: bool, negative_zero: bool,\n+        sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n+    if radix as int <  2 {\n+        fail!(fmt!(\"to_str_bytes_common: radix %? to low, \\\n+                   must lie in the range [2, 36]\", radix));\n+    } else if radix as int > 36 {\n+        fail!(fmt!(\"to_str_bytes_common: radix %? to high, \\\n+                   must lie in the range [2, 36]\", radix));\n+    }\n+\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+\n+    if special {\n+        if is_NaN(num) {\n+            return (str::to_bytes(\"NaN\"), true);\n+        } else if is_infinity(num){\n+            return match sign {\n+                SignAll => (str::to_bytes(\"+inf\"), true),\n+                _       => (str::to_bytes(\"inf\"), true)\n+            }\n+        } else if is_neg_infinity(num) {\n+            return match sign {\n+                SignNone => (str::to_bytes(\"inf\"), true),\n+                _        => (str::to_bytes(\"-inf\"), true),\n+            }\n+        }\n+    }\n+\n+    let neg = *num < _0 || (negative_zero && *num == _0\n+                            && special && is_neg_zero(num));\n+    let mut buf: ~[u8] = ~[];\n+    let radix_gen: T   = cast(radix as int);\n+\n+    let mut deccum;\n+\n+    // First emit the non-fractional part, looping at least once to make\n+    // sure at least a `0` gets emitted.\n+    deccum = num.round(RoundToZero);\n+    loop {\n+        // Calculate the absolute value of each digit instead of only\n+        // doing it once for the whole number because a\n+        // representable negative number doesn't necessary have an\n+        // representable additive inverse of the same type\n+        // (See twos complement). But we assume that for the\n+        // numbers [-35 .. 0] we always have [0 .. 35].\n+        let current_digit_signed = deccum % radix_gen;\n+        let current_digit = if current_digit_signed < _0 {\n+            -current_digit_signed\n+        } else {\n+            current_digit_signed\n+        };\n+\n+        // Decrease the deccumulator one digit at a time\n+        deccum /= radix_gen;\n+        deccum = deccum.round(RoundToZero);\n+\n+        unsafe { // FIXME: Pureness workaround (#4568)\n+            buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n+                 .unwrap() as u8);\n+        }\n+\n+        // No more digits to calculate for the non-fractional part -> break\n+        if deccum == _0 { break; }\n+    }\n+\n+    // If limited digits, calculate one digit more for rounding.\n+    let (limit_digits, digit_count, exact) = match digits {\n+        DigAll          => (false, 0u,      false),\n+        DigMax(count)   => (true,  count+1, false),\n+        DigExact(count) => (true,  count+1, true)\n+    };\n+\n+    // Decide what sign to put in front\n+    match sign {\n+        SignNeg | SignAll if neg => {\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push('-' as u8);\n+            }\n+        }\n+        SignAll => {\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push('+' as u8);\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    unsafe { // FIXME: Pureness workaround (#4568)\n+        vec::reverse(buf);\n+    }\n+\n+    // Remember start of the fractional digits.\n+    // Points one beyond end of buf if none get generated,\n+    // or at the '.' otherwise.\n+    let start_fractional_digits = buf.len();\n+\n+    // Now emit the fractional part, if any\n+    deccum = num.fract();\n+    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n+        unsafe { // FIXME: Pureness workaround (#4568)\n+            buf.push('.' as u8);\n+        }\n+        let mut dig = 0u;\n+\n+        // calculate new digits while\n+        // - there is no limit and there are digits left\n+        // - or there is a limit, it's not reached yet and\n+        //   - it's exact\n+        //   - or it's a maximum, and there are still digits left\n+        while (!limit_digits && deccum != _0)\n+           || (limit_digits && dig < digit_count && (\n+                   exact\n+                || (!exact && deccum != _0)\n+              )\n+        ) {\n+            // Shift first fractional digit into the integer part\n+            deccum *= radix_gen;\n+\n+            // Calculate the absolute value of each digit.\n+            // See note in first loop.\n+            let current_digit_signed = deccum.round(RoundToZero);\n+            let current_digit = if current_digit_signed < _0 {\n+                -current_digit_signed\n+            } else {\n+                current_digit_signed\n+            };\n+\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push(char::from_digit(\n+                    current_digit.to_int() as uint, radix).unwrap() as u8);\n+            }\n+\n+            // Decrease the deccumulator one fractional digit at a time\n+            deccum = deccum.fract();\n+            dig += 1u;\n+        }\n+\n+        // If digits are limited, and that limit has been reached,\n+        // cut off the one extra digit, and depending on its value\n+        // round the remaining ones.\n+        if limit_digits && dig == digit_count {\n+            let ascii2value = |chr: u8| {\n+                char::to_digit(chr as char, radix).unwrap() as uint\n+            };\n+            let value2ascii = |val: uint| {\n+                char::from_digit(val, radix).unwrap() as u8\n+            };\n+\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                let extra_digit = ascii2value(buf.pop());\n+                if extra_digit >= radix / 2 { // -> need to round\n+                    let mut i: int = buf.len() as int - 1;\n+                    loop {\n+                        // If reached left end of number, have to\n+                        // insert additional digit:\n+                        if i < 0\n+                        || buf[i] == '-' as u8\n+                        || buf[i] == '+' as u8 {\n+                            buf.insert((i + 1) as uint, value2ascii(1));\n+                            break;\n+                        }\n+\n+                        // Skip the '.'\n+                        if buf[i] == '.' as u8 { i -= 1; loop; }\n+\n+                        // Either increment the digit,\n+                        // or set to 0 if max and carry the 1.\n+                        let current_digit = ascii2value(buf[i]);\n+                        if current_digit < (radix - 1) {\n+                            buf[i] = value2ascii(current_digit+1);\n+                            break;\n+                        } else {\n+                            buf[i] = value2ascii(0);\n+                            i -= 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // if number of digits is not exact, remove all trailing '0's up to\n+    // and including the '.'\n+    if !exact {\n+        let buf_max_i = buf.len() - 1;\n+\n+        // index to truncate from\n+        let mut i = buf_max_i;\n+\n+        // discover trailing zeros of fractional part\n+        while i > start_fractional_digits && buf[i] == '0' as u8 {\n+            i -= 1;\n+        }\n+\n+        // Only attempt to truncate digits if buf has fractional digits\n+        if i >= start_fractional_digits {\n+            // If buf ends with '.', cut that too.\n+            if buf[i] == '.' as u8 { i -= 1 }\n+\n+            // only resize buf if we actually remove digits\n+            if i < buf_max_i {\n+                buf = buf.slice(0, i + 1);\n+            }\n+        }\n+    } // If exact and trailing '.', just cut that\n+    else {\n+        let max_i = buf.len() - 1;\n+        if buf[max_i] == '.' as u8 {\n+            buf = buf.slice(0, max_i);\n+        }\n+    }\n+\n+    (buf, false)\n+}\n+\n+/**\n+ * Converts a number to its string representation. This is a wrapper for\n+ * `to_str_bytes_common()`, for details see there.\n+ */\n+#[inline(always)]\n+pub pure fn to_str_common<T:NumCast+Zero+One+Eq+Ord+Round+Copy+Div<T,T>+Neg<T>\n+                            +Modulo<T,T>+Mul<T,T>>(\n+        num: &T, radix: uint, special: bool, negative_zero: bool,\n+        sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n+    let (bytes, special) = to_str_bytes_common(num, radix, special,\n+                               negative_zero, sign, digits);\n+    (str::from_bytes(bytes), special)\n+}\n+\n+// Some constants for from_str_bytes_common's input validation,\n+// they define minimum radix values for which the character is a valid digit.\n+priv const DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n+priv const DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n+priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+\n+/**\n+ * Parses a byte slice as a number. This is meant to\n+ * be a common base implementation for all numeric string conversion\n+ * functions like `from_str()` or `from_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `buf`        - The byte slice to parse.\n+ * - `radix`      - Which base to parse the number as. Accepts 2-36.\n+ * - `negative`   - Whether to accept negative numbers.\n+ * - `fractional` - Whether to accept numbers with fractional parts.\n+ * - `special`    - Whether to accept special values like `inf`\n+ *                  and `NaN`. Can conflict with `radix`, see Failure.\n+ * - `exponent`   - Which exponent format to accept. Options are:\n+ *     - `ExpNone`: No Exponent, accepts just plain numbers like `42` or\n+ *                  `-8.2`.\n+ *     - `ExpDec`:  Accepts numbers with a decimal exponent like `42e5` or\n+ *                  `8.2E-2`. The exponent string itself is always base 10.\n+ *                  Can conflict with `radix`, see Failure.\n+ *     - `ExpBin`:  Accepts numbers with a binary exponent like `42P-8` or\n+ *                  `FFp128`. The exponent string itself is always base 10.\n+ *                  Can conflict with `radix`, see Failure.\n+ * - `empty_zero` - Whether to accept a empty `buf` as a 0 or not.\n+ *\n+ * # Return value\n+ * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n+ * `None` otherwise, depending on the constraints set by the remaining\n+ * arguments.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails if `radix` > 14 and `exponent` is `ExpDec` due to conflict\n+ *   between digit and exponent sign `'e'`.\n+ * - Fails if `radix` > 25 and `exponent` is `ExpBin` due to conflict\n+ *   between digit and exponent sign `'p'`.\n+ * - Fails if `radix` > 18 and `special == true` due to conflict\n+ *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n+ *\n+ * # Possible improvements\n+ * - Could accept option to allow ignoring underscores, allowing for numbers\n+ *   formated like `FF_AE_FF_FF`.\n+ */\n+pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n+                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>>(\n+        buf: &[u8], radix: uint, negative: bool, fractional: bool,\n+        special: bool, exponent: ExponentFormat, empty_zero: bool\n+        ) -> Option<T> {\n+    match exponent {\n+        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n+          => fail!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        use of 'e' as decimal exponent\", radix)),\n+        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n+          => fail!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        use of 'p' as binary exponent\", radix)),\n+        _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n+          => fail!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        special values 'inf' and 'NaN'\", radix)),\n+        _ if radix as int < 2\n+          => fail!(fmt!(\"from_str_bytes_common: radix %? to low, \\\n+                        must lie in the range [2, 36]\", radix)),\n+        _ if radix as int > 36\n+          => fail!(fmt!(\"from_str_bytes_common: radix %? to high, \\\n+                        must lie in the range [2, 36]\", radix)),\n+        _ => ()\n+    }\n+\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+    let radix_gen: T = cast(radix as int);\n+\n+    let len = buf.len();\n+\n+    if len == 0 {\n+        if empty_zero {\n+            return Some(_0);\n+        } else {\n+            return None;\n+        }\n+    }\n+\n+    if special {\n+        if buf == str::to_bytes(\"inf\") || buf == str::to_bytes(\"+inf\") {\n+            return Some(infinity());\n+        } else if buf == str::to_bytes(\"-inf\") {\n+            if negative {\n+                return Some(neg_infinity());\n+            } else {\n+                return None;\n+            }\n+        } else if buf == str::to_bytes(\"NaN\") {\n+            return Some(NaN());\n+        }\n+    }\n+\n+    let (start, accum_positive) = match buf[0] {\n+      '-' as u8 if !negative => return None,\n+      '-' as u8 => (1u, false),\n+      '+' as u8 => (1u, true),\n+       _        => (0u, true)\n+    };\n+\n+    // Initialize accumulator with signed zero for floating point parsing to\n+    // work\n+    let mut accum      = if accum_positive { _0 } else { -_1 * _0};\n+    let mut last_accum = accum; // Necessary to detect overflow\n+    let mut i          = start;\n+    let mut exp_found  = false;\n+\n+    // Parse integer part of number\n+    while i < len {\n+        let c = buf[i] as char;\n+\n+        match char::to_digit(c, radix) {\n+            Some(digit) => {\n+                // shift accum one digit left\n+                accum *= radix_gen;\n+\n+                // add/subtract current digit depending on sign\n+                if accum_positive {\n+                    accum += cast(digit as int);\n+                } else {\n+                    accum -= cast(digit as int);\n+                }\n+\n+                // Detect overflow by comparing to last value\n+                if accum_positive && accum < last_accum { return None; }\n+                if !accum_positive && accum > last_accum { return None; }\n+                last_accum = accum;\n+            }\n+            None => match c {\n+                'e' | 'E' | 'p' | 'P' => {\n+                    exp_found = true;\n+                    break;                       // start of exponent\n+                }\n+                '.' if fractional => {\n+                    i += 1u;                     // skip the '.'\n+                    break;                       // start of fractional part\n+                }\n+                _ => return None                 // invalid number\n+            }\n+        }\n+\n+        i += 1u;\n+    }\n+\n+    // Parse fractional part of number\n+    // Skip if already reached start of exponent\n+    if !exp_found {\n+        let mut power = _1;\n+\n+        while i < len {\n+            let c = buf[i] as char;\n+\n+            match char::to_digit(c, radix) {\n+                Some(digit) => {\n+                    // Decrease power one order of magnitude\n+                    power /= radix_gen;\n+\n+                    let digit_t: T = cast(digit);\n+\n+                    // add/subtract current digit depending on sign\n+                    if accum_positive {\n+                        accum += digit_t * power;\n+                    } else {\n+                        accum -= digit_t * power;\n+                    }\n+\n+                    // Detect overflow by comparing to last value\n+                    if accum_positive && accum < last_accum { return None; }\n+                    if !accum_positive && accum > last_accum { return None; }\n+                    last_accum = accum;\n+                }\n+                None => match c {\n+                    'e' | 'E' | 'p' | 'P' => {\n+                        exp_found = true;\n+                        break;                   // start of exponent\n+                    }\n+                    _ => return None             // invalid number\n+                }\n+            }\n+\n+            i += 1u;\n+        }\n+    }\n+\n+    // Special case: buf not empty, but does not contain any digit in front\n+    // of the exponent sign -> number is empty string\n+    if i == start {\n+        if empty_zero {\n+            return Some(_0);\n+        } else {\n+            return None;\n+        }\n+    }\n+\n+    let mut multiplier = _1;\n+\n+    if exp_found {\n+        let c = buf[i] as char;\n+        let base = match (c, exponent) {\n+            ('e', ExpDec) | ('E', ExpDec) => 10u,\n+            ('p', ExpBin) | ('P', ExpBin) => 2u,\n+            _ => return None // char doesn't fit given exponent format\n+        };\n+\n+        // parse remaining bytes as decimal integer,\n+        // skipping the exponent char\n+        let exp: Option<int> = from_str_bytes_common(\n+            buf.view(i+1, len), 10, true, false, false, ExpNone, false);\n+\n+        match exp {\n+            Some(exp_pow) => {\n+                multiplier = if exp_pow < 0 {\n+                    _1 / pow_with_uint::<T>(base, (-exp_pow.to_int()) as uint)\n+                } else {\n+                    pow_with_uint::<T>(base, exp_pow.to_int() as uint)\n+                }\n+            }\n+            None => return None // invalid exponent -> invalid number\n+        }\n+    }\n+\n+    Some(accum * multiplier)\n+}\n+\n+/**\n+ * Parses a string as a number. This is a wrapper for\n+ * `from_str_bytes_common()`, for details see there.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+Mul<T,T>+\n+                              Sub<T,T>+Neg<T>+Add<T,T>>(\n+        buf: &str, radix: uint, negative: bool, fractional: bool,\n+        special: bool, exponent: ExponentFormat, empty_zero: bool\n+        ) -> Option<T> {\n+    from_str_bytes_common(str::to_bytes(buf), radix, negative,\n+                            fractional, special, exponent, empty_zero)\n+}"}, {"sha": "9829bf9d9e08690ca2a3a4f6461eb43027c8c5da", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adac6cb5c61dfae79901264af4c235b66fb6267a/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=adac6cb5c61dfae79901264af4c235b66fb6267a", "patch": "@@ -17,6 +17,7 @@ use cmp;\n use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n+use num::strconv;\n use num;\n use option::{None, Option, Some};\n use prelude::*;\n@@ -182,22 +183,22 @@ impl ops::Neg<T> for T {\n /// Parse a string as a number in base 10.\n #[inline(always)]\n pub pure fn from_str(s: &str) -> Option<T> {\n-    num::from_str_common(s, 10u, false, false, false,\n-                         num::ExpNone, false)\n+    strconv::from_str_common(s, 10u, false, false, false,\n+                             strconv::ExpNone, false)\n }\n \n /// Parse a string as a number in the given base.\n #[inline(always)]\n pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n-    num::from_str_common(s, radix, false, false, false,\n-                         num::ExpNone, false)\n+    strconv::from_str_common(s, radix, false, false, false,\n+                             strconv::ExpNone, false)\n }\n \n /// Parse a byte slice as a number in the given base.\n #[inline(always)]\n pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n-    num::from_str_bytes_common(buf, radix, false, false, false,\n-                               num::ExpNone, false)\n+    strconv::from_str_bytes_common(buf, radix, false, false, false,\n+                                   strconv::ExpNone, false)\n }\n \n impl FromStr for T {\n@@ -219,24 +220,24 @@ impl FromStrRadix for T {\n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n-    let (buf, _) = num::to_str_bytes_common(&n, radix, false, false,\n-                                            num::SignNeg, num::DigAll);\n+    let (buf, _) = strconv::to_str_bytes_common(&n, radix, false, false,\n+                            strconv::SignNeg, strconv::DigAll);\n     f(buf)\n }\n \n /// Convert to a string in base 10.\n #[inline(always)]\n pub pure fn to_str(num: T) -> ~str {\n-    let (buf, _) = num::to_str_common(&num, 10u, false, false,\n-                                      num::SignNeg, num::DigAll);\n+    let (buf, _) = strconv::to_str_common(&num, 10u, false, false,\n+                            strconv::SignNeg, strconv::DigAll);\n     buf\n }\n \n /// Convert to a string in a given base.\n #[inline(always)]\n pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n-    let (buf, _) = num::to_str_common(&num, radix, false, false,\n-                                      num::SignNeg, num::DigAll);\n+    let (buf, _) = strconv::to_str_common(&num, radix, false, false,\n+                            strconv::SignNeg, strconv::DigAll);\n     buf\n }\n "}]}