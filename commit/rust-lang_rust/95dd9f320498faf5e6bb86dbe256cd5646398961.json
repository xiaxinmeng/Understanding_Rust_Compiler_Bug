{"sha": "95dd9f320498faf5e6bb86dbe256cd5646398961", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZGQ5ZjMyMDQ5OGZhZjVlNmJiODZkYmUyNTZjZDU2NDYzOTg5NjE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-10T02:29:14Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-10T22:12:12Z"}, "message": "Get rid of a lot of bind related cruft as part of Issue #2189.", "tree": {"sha": "7319578ffe44fc0d6babb373cb98bd15450a2f47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7319578ffe44fc0d6babb373cb98bd15450a2f47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95dd9f320498faf5e6bb86dbe256cd5646398961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95dd9f320498faf5e6bb86dbe256cd5646398961", "html_url": "https://github.com/rust-lang/rust/commit/95dd9f320498faf5e6bb86dbe256cd5646398961", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95dd9f320498faf5e6bb86dbe256cd5646398961/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40fc1737b29b480c15318016a24874ef6f9ef75f", "url": "https://api.github.com/repos/rust-lang/rust/commits/40fc1737b29b480c15318016a24874ef6f9ef75f", "html_url": "https://github.com/rust-lang/rust/commit/40fc1737b29b480c15318016a24874ef6f9ef75f"}], "stats": {"total": 331, "additions": 41, "deletions": 290}, "files": [{"sha": "08c055276450ac8b1f924d7433017c0df766e2da", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/95dd9f320498faf5e6bb86dbe256cd5646398961/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dd9f320498faf5e6bb86dbe256cd5646398961/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=95dd9f320498faf5e6bb86dbe256cd5646398961", "patch": "@@ -2660,7 +2660,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n         alt e.node {\n           ast::expr_path(_) {\n             let v = trans_path(cx, e.id);\n-            ret lval_maybe_callee_to_lval(v, expr_ty(cx, e));\n+            ret lval_maybe_callee_to_lval(v, e.span);\n           }\n           ast::expr_field(base, ident, _) {\n             ret trans_rec_field(cx, base, ident);\n@@ -2711,26 +2711,18 @@ fn non_gc_box_cast(cx: block, val: ValueRef) -> ValueRef {\n     PointerCast(cx, val, non_gc_t)\n }\n \n-fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n-    let must_bind = alt c.env { self_env(_, _, _) { true } _ { false } };\n-    if must_bind {\n-        let n_args = ty::ty_fn_args(ty).len();\n-        let args = vec::from_elem(n_args, none);\n-        let space = alloc_ty(c.bcx, ty);\n-        let bcx = closure::trans_bind_1(c.bcx, ty, c, args, ty,\n-                                        save_in(space));\n-        add_clean_temp(bcx, space, ty);\n-        {bcx: bcx, val: space, kind: temporary}\n-    } else {\n-        alt check c.env {\n-          is_closure { {bcx: c.bcx, val: c.val, kind: c.kind} }\n-          null_env {\n-            let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n-            let llfn = create_real_fn_pair(c.bcx, llfnty, c.val,\n-                                           null_env_ptr(c.bcx));\n-            {bcx: c.bcx, val: llfn, kind: temporary}\n-          }\n-        }\n+fn lval_maybe_callee_to_lval(c: lval_maybe_callee, sp: span) -> lval_result {\n+    alt c.env {\n+      self_env(*) {\n+        c.bcx.sess().span_bug(sp, \"implicitly binding method call\");\n+      }\n+      is_closure { {bcx: c.bcx, val: c.val, kind: c.kind} }\n+      null_env {\n+        let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n+        let llfn = create_real_fn_pair(c.bcx, llfnty, c.val,\n+                                       null_env_ptr(c.bcx));\n+        {bcx: c.bcx, val: llfn, kind: temporary}\n+      }\n     }\n }\n \n@@ -3605,7 +3597,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           ast::expr_field(base, _, _) {\n             if dest == ignore { ret trans_expr(bcx, base, ignore); }\n             let callee = trans_callee(bcx, e), ty = expr_ty(bcx, e);\n-            let lv = lval_maybe_callee_to_lval(callee, ty);\n+            let lv = lval_maybe_callee_to_lval(callee, e.span);\n             revoke_clean(lv.bcx, lv.val);\n             memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, ty);\n             ret lv.bcx;"}, {"sha": "e48a63dbefa3c1a0fcb99dbfa4148ccf6360b7de", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 238, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/95dd9f320498faf5e6bb86dbe256cd5646398961/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dd9f320498faf5e6bb86dbe256cd5646398961/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=95dd9f320498faf5e6bb86dbe256cd5646398961", "patch": "@@ -90,9 +90,6 @@ import dvec::extensions;\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n enum environment_value {\n-    // Evaluate expr and store result in env (used for bind).\n-    env_expr(@ast::expr, ty::t),\n-\n     // Copy the value from this llvm ValueRef into the environment.\n     env_copy(ValueRef, ty::t, lval_kind),\n \n@@ -105,7 +102,6 @@ enum environment_value {\n \n fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> str {\n     alt ev {\n-      env_expr(ex, _) { expr_to_str(ex) }\n       env_copy(v, t, lk) { #fmt(\"copy(%s,%s)\", val_str(ccx.tn, v),\n                                 ty_to_str(ccx.tcx, t)) }\n       env_move(v, t, lk) { #fmt(\"move(%s,%s)\", val_str(ccx.tn, v),\n@@ -123,7 +119,7 @@ fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n // Given a closure ty, emits a corresponding tuple ty\n fn mk_closure_tys(tcx: ty::ctxt,\n                   bound_values: ~[environment_value])\n-    -> (ty::t, ~[ty::t]) {\n+    -> ty::t {\n     let mut bound_tys = ~[];\n \n     // Compute the closed over data\n@@ -132,15 +128,14 @@ fn mk_closure_tys(tcx: ty::ctxt,\n             env_copy(_, t, _) { t }\n             env_move(_, t, _) { t }\n             env_ref(_, t, _) { t }\n-            env_expr(_, t) { t }\n         });\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n     // FIXME[mono] remove tuple of tydescs from closure types (#2531)\n     let cdata_ty = ty::mk_tup(tcx, ~[ty::mk_tup(tcx, ~[]),\n                                     bound_data_ty]);\n     #debug[\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)];\n-    ret (cdata_ty, bound_tys);\n+    ret cdata_ty;\n }\n \n fn allocate_cbox(bcx: block,\n@@ -196,8 +191,7 @@ fn store_environment(bcx: block,\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // compute the shape of the closure\n-    let (cdata_ty, bound_tys) =\n-        mk_closure_tys(tcx, bound_values);\n+    let cdata_ty = mk_closure_tys(tcx, bound_values);\n \n     // allocate closure in the heap\n     let llbox = allocate_cbox(bcx, ck, cdata_ty);\n@@ -225,11 +219,6 @@ fn store_environment(bcx: block,\n         let bound_data = GEPi(bcx, llbox,\n              ~[0u, abi::box_field_body, abi::closure_body_bindings, i]);\n         alt bv {\n-          env_expr(e, _) {\n-            bcx = base::trans_expr_save_in(bcx, e, bound_data);\n-            add_clean_temp_mem(bcx, bound_data, bound_tys[i]);\n-            vec::push(temp_cleanups, bound_data);\n-          }\n           env_copy(val, ty, owned) {\n             let val1 = load_if_immediate(bcx, val, ty);\n             bcx = base::copy_val(bcx, INIT, bound_data, val1, ty);\n@@ -415,70 +404,6 @@ fn trans_expr_fn(bcx: block,\n     ret bcx;\n }\n \n-fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n-                f_res: lval_maybe_callee,\n-                args: ~[option<@ast::expr>], pair_ty: ty::t,\n-                dest: dest) -> block {\n-    let _icx = cx.insn_ctxt(\"closure::trans_bind1\");\n-    let ccx = cx.ccx();\n-    let mut bound: ~[@ast::expr] = ~[];\n-    for vec::each(args) |argopt| {\n-        alt argopt { none { } some(e) { vec::push(bound, e); } }\n-    }\n-    let mut bcx = f_res.bcx;\n-    if dest == ignore {\n-        for vec::each(bound) |ex| { bcx = trans_expr(bcx, ex, ignore); }\n-        ret bcx;\n-    }\n-\n-    if bound.len() == 0u &&\n-       (f_res.env == null_env || f_res.env == is_closure) {\n-        // Trivial 'binding': just return the closure\n-        let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n-        memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, pair_ty);\n-        ret lv.bcx;\n-    }\n-\n-    // Arrange for the bound function to live in the first binding spot\n-    // if the function is not statically known.\n-    let (env_vals, target_info) = alt f_res.env {\n-      null_env { (~[], target_static(f_res.val)) }\n-      is_closure {\n-        // Cast the function we are binding to be the type that the\n-        // closure will expect it to have. The type the closure knows\n-        // about has the type parameters substituted with the real types.\n-        let llclosurety = T_ptr(type_of(ccx, outgoing_fty));\n-        let src_loc = PointerCast(bcx, f_res.val, llclosurety);\n-        (~[env_copy(src_loc, pair_ty, owned)], target_closure)\n-      }\n-      self_env(slf, slf_t, none) {\n-        (~[env_copy(slf, slf_t, owned)], target_static_self(f_res.val))\n-      }\n-      self_env(_, slf_t, some(slf)) {\n-        let cast = PointerCast(bcx, f_res.val, T_ptr(T_nil()));\n-        (~[env_copy(cast, ty::mk_nil_ptr(ccx.tcx), owned_imm),\n-          env_copy(slf, slf_t, owned_imm)], target_self)\n-      }\n-    };\n-\n-    // Actually construct the closure\n-    let {llbox, cdata_ty, bcx} = store_environment(\n-        bcx, vec::append(env_vals,\n-                         vec::map(bound, |x| {\n-                             env_expr(x, expr_ty(bcx, x))\n-                         })),\n-        ty::ck_box);\n-\n-    // Make thunk\n-    let llthunk = trans_bind_thunk(\n-        cx.fcx.ccx, cx.fcx.path, pair_ty, outgoing_fty, args,\n-        cdata_ty, target_info);\n-\n-    // Fill the function pair\n-    fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n-    ret bcx;\n-}\n-\n fn make_fn_glue(\n     cx: block,\n     v: ValueRef,\n@@ -611,163 +536,3 @@ fn make_opaque_cbox_free_glue(\n         }\n     }\n }\n-\n-enum target_info {\n-    target_closure,\n-    target_static(ValueRef),\n-    target_self,\n-    target_static_self(ValueRef),\n-}\n-\n-// pth is cx.path\n-fn trans_bind_thunk(ccx: @crate_ctxt,\n-                    path: path,\n-                    incoming_fty: ty::t,\n-                    outgoing_fty: ty::t,\n-                    args: ~[option<@ast::expr>],\n-                    cdata_ty: ty::t,\n-                    target_info: target_info)\n-    -> {val: ValueRef, ty: TypeRef} {\n-    let _icx = ccx.insn_ctxt(\"closure::trans_bind_thunk\");\n-    let tcx = ccx.tcx;\n-    #debug[\"trans_bind_thunk[incoming_fty=%s,outgoing_fty=%s,\\\n-            cdata_ty=%s]/~\",\n-           ty_to_str(tcx, incoming_fty),\n-           ty_to_str(tcx, outgoing_fty),\n-           ty_to_str(tcx, cdata_ty)];\n-\n-    // Here we're not necessarily constructing a thunk in the sense of\n-    // \"function with no arguments\".  The result of compiling 'bind f(foo,\n-    // bar, baz)' would be a thunk that, when called, applies f to those\n-    // arguments and returns the result.  But we're stretching the meaning of\n-    // the word \"thunk\" here to also mean the result of compiling, say, 'bind\n-    // f(foo, _, baz)', or any other bind expression that binds f and leaves\n-    // some (or all) of the arguments unbound.\n-\n-    // Here, 'incoming_fty' is the type of the entire bind expression, while\n-    // 'outgoing_fty' is the type of the function that is having some of its\n-    // arguments bound.  If f is a function that takes three arguments of type\n-    // int and returns int, and we're translating, say, 'bind f(3, _, 5)',\n-    // then outgoing_fty is the type of f, which is (int, int, int) -> int,\n-    // and incoming_fty is the type of 'bind f(3, _, 5)', which is int -> int.\n-\n-    // Once translated, the entire bind expression will be the call f(foo,\n-    // bar, baz) wrapped in a (so-called) thunk that takes 'bar' as its\n-    // argument and that has bindings of 'foo' to 3 and 'baz' to 5 and a\n-    // pointer to 'f' all saved in its environment.  So, our job is to\n-    // construct and return that thunk.\n-\n-    // Give the thunk a name, type, and value.\n-    let s = mangle_internal_name_by_path_and_seq(ccx, path, @\"thunk\");\n-    let llthunk_ty = get_pair_fn_ty(type_of(ccx, incoming_fty));\n-    let llthunk = decl_internal_cdecl_fn(ccx.llmod, s, llthunk_ty);\n-\n-    // Create a new function context and block context for the thunk, and hold\n-    // onto a pointer to the first block in the function for later use.\n-    let fcx = new_fn_ctxt(ccx, path, llthunk, none);\n-    let mut bcx = top_scope_block(fcx, none);\n-    let lltop = bcx.llbb;\n-    // Since we might need to construct derived tydescs that depend on\n-    // our bound tydescs, we need to load tydescs out of the environment\n-    // before derived tydescs are constructed. To do this, we load them\n-    // in the load_env block.\n-    let l_bcx = raw_block(fcx, fcx.llloadenv);\n-\n-    // The 'llenv' that will arrive in the thunk we're creating is an\n-    // environment that will contain the values of its arguments and a\n-    // pointer to the original function.  This environment is always\n-    // stored like an opaque box (see big comment at the header of the\n-    // file), so we load the body body, which contains the type descr\n-    // and cached data.\n-    let llcdata = base::opaque_box_body(l_bcx, cdata_ty, fcx.llenv);\n-\n-    // \"target\", in this context, means the function that's having some of its\n-    // arguments bound and that will be called inside the thunk we're\n-    // creating.  (In our running example, target is the function f.)  Pick\n-    // out the pointer to the target function from the environment. The\n-    // target function lives in the first binding spot.\n-    let (lltargetfn, lltargetenv, starting_idx) = alt target_info {\n-      target_static(fptr) {\n-        (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0u)\n-      }\n-      target_closure {\n-        let pair = GEPi(bcx, llcdata, ~[0u, abi::closure_body_bindings, 0u]);\n-        let lltargetenv =\n-            Load(bcx, GEPi(bcx, pair, ~[0u, abi::fn_field_box]));\n-        let lltargetfn = Load\n-            (bcx, GEPi(bcx, pair, ~[0u, abi::fn_field_code]));\n-        (lltargetfn, lltargetenv, 1u)\n-      }\n-      target_self {\n-        let fptr = Load(bcx, GEPi(bcx, llcdata,\n-                                  ~[0u, abi::closure_body_bindings, 0u]));\n-        let slfbox =\n-            GEPi(bcx, llcdata, ~[0u, abi::closure_body_bindings, 1u]);\n-        let selfptr =\n-            GEPi(bcx, Load(bcx, slfbox), ~[0u, abi::box_field_body]);\n-        (fptr, PointerCast(bcx, selfptr, T_opaque_cbox_ptr(ccx)), 2u)\n-      }\n-      target_static_self(fptr) {\n-        let slfptr =\n-            GEPi(bcx, llcdata, ~[0u, abi::closure_body_bindings, 0u]);\n-        (fptr, PointerCast(bcx, slfptr, T_opaque_cbox_ptr(ccx)), 1u)\n-      }\n-    };\n-\n-    // And then, pick out the target function's own environment.  That's what\n-    // we'll use as the environment the thunk gets.\n-\n-    // Get the types of the arguments to f.\n-    let outgoing_args = ty::ty_fn_args(outgoing_fty);\n-\n-    // Set up the three implicit arguments to the thunk.\n-    let mut llargs: ~[ValueRef] = ~[fcx.llretptr, lltargetenv];\n-\n-    let mut a: uint = first_real_arg; // retptr, env come first\n-    let mut b: uint = starting_idx;\n-    let mut outgoing_arg_index: uint = 0u;\n-    for vec::each(args) |arg| {\n-        let out_arg = outgoing_args[outgoing_arg_index];\n-        alt arg {\n-          // Arg provided at binding time; thunk copies it from\n-          // closure.\n-          some(e) {\n-            let mut val =\n-                GEPi(bcx, llcdata, ~[0u, abi::closure_body_bindings, b]);\n-\n-            alt ty::resolved_mode(tcx, out_arg.mode) {\n-              ast::by_val {\n-                val = Load(bcx, val);\n-              }\n-              ast::by_copy {\n-                let alloc = alloc_ty(bcx, out_arg.ty);\n-                memmove_ty(bcx, alloc, val, out_arg.ty);\n-                bcx = take_ty(bcx, alloc, out_arg.ty);\n-                val = alloc;\n-              }\n-              ast::by_ref | ast::by_mutbl_ref | ast::by_move { }\n-            }\n-            vec::push(llargs, val);\n-            b += 1u;\n-          }\n-\n-          // Arg will be provided when the thunk is invoked.\n-          none {\n-            vec::push(llargs, llvm::LLVMGetParam(llthunk, a as c_uint));\n-            a += 1u;\n-          }\n-        }\n-        outgoing_arg_index += 1u;\n-    }\n-\n-    // Cast the outgoing function to the appropriate type.\n-    // This is necessary because the type of the function that we have\n-    // in the closure does not know how many type descriptors the function\n-    // needs to take.\n-    let lltargetty = type_of_fn_from_ty(ccx, outgoing_fty);\n-    let lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n-    Call(bcx, lltargetfn, llargs);\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n-    ret {val: llthunk, ty: llthunk_ty};\n-}"}, {"sha": "df99c7a64003644d14fab1a1cc334659320d3d99", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/95dd9f320498faf5e6bb86dbe256cd5646398961/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95dd9f320498faf5e6bb86dbe256cd5646398961/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=95dd9f320498faf5e6bb86dbe256cd5646398961", "patch": "@@ -710,18 +710,18 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     #debug(\">> typechecking expr %d (%s)\",\n            expr.id, syntax::print::pprust::expr_to_str(expr));\n \n-    // A generic function to factor out common logic from call and bind\n-    // expressions.\n-    fn check_call_or_bind(\n+    // A generic function to factor out common logic from call and\n+    // overloaded operations\n+    fn check_call_inner(\n         fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id, in_fty: ty::t,\n-        args: ~[option<@ast::expr>]) -> {fty: ty::t, bot: bool} {\n+        args: ~[@ast::expr]) -> {fty: ty::t, bot: bool} {\n \n         let mut bot = false;\n \n         // Replace all region parameters in the arguments and return\n         // type with fresh region variables.\n \n-        #debug[\"check_call_or_bind: before universal quant., in_fty=%s\",\n+        #debug[\"check_call_inner: before universal quant., in_fty=%s\",\n                fcx.infcx.ty_to_str(in_fty)];\n \n         // This is subtle: we expect `fty` to be a function type, which\n@@ -747,7 +747,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             };\n \n         let fty = ty::mk_fn(fcx.tcx(), fn_ty);\n-        #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n+        #debug[\"check_call_inner: after universal quant., fty=%s\",\n                fcx.infcx.ty_to_str(fty)];\n \n         let supplied_arg_count = vec::len(args);\n@@ -782,23 +782,18 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n         for [false, true]/_.each |check_blocks| {\n-            for args.eachi |i, a_opt| {\n-                alt a_opt {\n-                  some(a) {\n-                    let is_block = alt a.node {\n-                      ast::expr_fn_block(*) { true }\n-                      _ { false }\n-                    };\n-                    if is_block == check_blocks {\n-                        let arg_ty = arg_tys[i];\n-                        bot |= check_expr_with_unifier(\n-                            fcx, a, some(arg_ty),\n-                            || demand::assign(fcx, a.span, call_expr_id,\n-                                              arg_ty, a)\n+            for args.eachi |i, a| {\n+                let is_block = alt a.node {\n+                  ast::expr_fn_block(*) { true }\n+                  _ { false }\n+                };\n+                if is_block == check_blocks {\n+                    let arg_ty = arg_tys[i];\n+                    bot |= check_expr_with_unifier(\n+                        fcx, a, some(arg_ty),\n+                        || demand::assign(fcx, a.span, call_expr_id,\n+                                          arg_ty, a)\n                         );\n-                    }\n-                  }\n-                  none { }\n                 }\n             }\n         }\n@@ -824,9 +819,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Call the generic checker.\n         let fty = {\n-            let args_opt = args.map(|arg| some(arg));\n-            let r = check_call_or_bind(fcx, sp, call_expr_id,\n-                                       fn_ty, args_opt);\n+            let r = check_call_inner(fcx, sp, call_expr_id,\n+                                     fn_ty, args);\n             bot |= r.bot;\n             r.fty\n         };\n@@ -890,7 +884,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     }\n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n                         self_ex: @ast::expr, self_t: ty::t,\n-                        opname: str, args: ~[option<@ast::expr>])\n+                        opname: str, args: ~[@ast::expr])\n         -> option<(ty::t, bool)> {\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n         let lkup = method::lookup(fcx, op_ex, self_ex, op_ex.id,\n@@ -899,8 +893,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           some(origin) {\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(callee_id);\n-                check_call_or_bind(fcx, op_ex.span, op_ex.id,\n-                                   method_ty, args)\n+                check_call_inner(fcx, op_ex.span, op_ex.id,\n+                                 method_ty, args)\n             };\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             some((ty::ty_fn_ret(method_ty), bot))\n@@ -965,7 +959,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           some(name) {\n             alt lookup_op_method(fcx, ex,\n                                  lhs_expr, lhs_resolved_t,\n-                                 name, ~[some(rhs)]) {\n+                                 name, ~[rhs]) {\n               some(pair) { ret pair; }\n               _ {}\n             }\n@@ -1589,7 +1583,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let resolved = structurally_resolved_type(fcx, expr.span,\n                                                       raw_base_t);\n             alt lookup_op_method(fcx, expr, base, resolved, \"[]\",\n-                                 ~[some(idx)]) {\n+                                 ~[idx]) {\n               some((ret_ty, _)) { fcx.write_ty(id, ret_ty); }\n               _ {\n                 tcx.sess.span_fatal("}]}