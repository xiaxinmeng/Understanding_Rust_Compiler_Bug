{"sha": "1bd17e4fa2ba4bad31c15c50300c32235a715223", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZDE3ZTRmYTJiYTRiYWQzMWMxNWM1MDMwMGMzMjIzNWE3MTUyMjM=", "commit": {"author": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-07-12T07:30:57Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-16T09:46:37Z"}, "message": "ExprKind", "tree": {"sha": "969671a3b388f8f5c36cca1c60c4638777b0f086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/969671a3b388f8f5c36cca1c60c4638777b0f086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bd17e4fa2ba4bad31c15c50300c32235a715223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bd17e4fa2ba4bad31c15c50300c32235a715223", "html_url": "https://github.com/rust-lang/rust/commit/1bd17e4fa2ba4bad31c15c50300c32235a715223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bd17e4fa2ba4bad31c15c50300c32235a715223/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a016890a0e2ad349423c684f595b71b19572c79", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a016890a0e2ad349423c684f595b71b19572c79", "html_url": "https://github.com/rust-lang/rust/commit/2a016890a0e2ad349423c684f595b71b19572c79"}], "stats": {"total": 1554, "additions": 777, "deletions": 777}, "files": [{"sha": "293418416a27402aba55f759a07f2608d2f051b5", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -93,9 +93,9 @@ a `.stdout` file with the generated code:\n // ./tests/ui/my_lint.stdout\n \n if_chain! {\n-    if let Expr_::ExprArray(ref elements) = stmt.node;\n+    if let ExprKind::Array(ref elements) = stmt.node;\n     if elements.len() == 1;\n-    if let Expr_::ExprLit(ref lit) = elements[0].node;\n+    if let ExprKind::Lit(ref lit) = elements[0].node;\n     if let LitKind::Int(7, _) = lit.node;\n     then {\n         // report your lint here\n@@ -179,7 +179,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n ```\n \n The [`rustc_plugin::PluginRegistry`][plugin_registry] provides two methods to register lints: [register_early_lint_pass][reg_early_lint_pass] and [register_late_lint_pass][reg_late_lint_pass].\n-Both take an object that implements an [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass] respectively. This is done in every single lint. \n+Both take an object that implements an [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass] respectively. This is done in every single lint.\n It's worth noting that the majority of `clippy_lints/src/lib.rs` is autogenerated by `util/update_lints.py` and you don't have to add anything by hand. When you are writing your own lint, you can use that script to save you some time.\n \n ```rust"}, {"sha": "13e1dbe3c0a71fe51680c2221285f2d9b7227d0d", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -63,7 +63,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprLit(ref lit) = e.node {\n+        if let ExprKind::Lit(ref lit) = e.node {\n             check_lit(cx, lit, e);\n         }\n     }"}, {"sha": "3f15f955e1997722d3f5c00c2ddfe08b51b63b25", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n             return;\n         }\n         match expr.node {\n-            hir::ExprBinary(ref op, ref l, ref r) => {\n+            hir::ExprKind::Binary(ref op, ref l, ref r) => {\n                 match op.node {\n                     hir::BiAnd\n                     | hir::BiOr\n@@ -81,7 +81,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     self.span = Some(expr.span);\n                 }\n             },\n-            hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n+            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n                 let ty = cx.tables.expr_ty(arg);\n                 if ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");"}, {"sha": "15871cdfe025494e21b04ede25fda1d70195aa30", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -76,7 +76,7 @@ impl LintPass for AssignOps {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {\n                     let lhs = &sugg::Sugg::hir(cx, lhs, \"..\");\n                     let rhs = &sugg::Sugg::hir(cx, rhs, \"..\");\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                         format!(\"{} = {}\", lhs, sugg::make_binop(higher::binop(op.node), lhs, rhs)),\n                     );\n                 });\n-                if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n+                if let hir::ExprKind::Binary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs_other: &hir::Expr| {\n                             span_lint_and_then(\n@@ -131,8 +131,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     }\n                 }\n             },\n-            hir::ExprAssign(ref assignee, ref e) => {\n-                if let hir::ExprBinary(op, ref l, ref r) = e.node {\n+            hir::ExprKind::Assign(ref assignee, ref e) => {\n+                if let hir::ExprKind::Binary(op, ref l, ref r) = e.node {\n                     #[allow(cyclomatic_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);"}, {"sha": "4418ba6307016e3d213313fcc280a84e43435aac", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -244,10 +244,10 @@ fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> b\n \n fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBlock(ref block, _) => is_relevant_block(tcx, tables, block),\n-        ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n-        ExprRet(None) | ExprBreak(_, None) => false,\n-        ExprCall(ref path_expr, _) => if let ExprPath(ref qpath) = path_expr.node {\n+        ExprKind::Block(ref block, _) => is_relevant_block(tcx, tables, block),\n+        ExprKind::Ret(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n+        ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n+        ExprKind::Call(ref path_expr, _) => if let ExprKind::Path(ref qpath) = path_expr.node {\n             if let Some(fun_id) = opt_def_id(tables.qpath_def(qpath, path_expr.hir_id)) {\n                 !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n             } else {"}, {"sha": "0558ad36b34889ce7dbe8e5bc5466c8ad62565d7", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -109,7 +109,7 @@ impl LintPass for BitMask {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n                     check_compare(cx, left, cmp.node, cmp_opt, e.span)\n@@ -119,13 +119,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n             }\n         }\n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref left, ref right) = e.node;\n+            if let ExprKind::Binary(ref op, ref left, ref right) = e.node;\n             if BinOp_::BiEq == op.node;\n-            if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n+            if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.node;\n             if BinOp_::BiBitAnd == op1.node;\n-            if let Expr_::ExprLit(ref lit) = right1.node;\n+            if let ExprKind::Lit(ref lit) = right1.node;\n             if let LitKind::Int(n, _) = lit.node;\n-            if let Expr_::ExprLit(ref lit1) = right.node;\n+            if let ExprKind::Lit(ref lit1) = right.node;\n             if let LitKind::Int(0, _) = lit1.node;\n             if n.leading_zeros() == n.count_zeros();\n             if n > u128::from(self.verbose_bit_mask_threshold);\n@@ -157,7 +157,7 @@ fn invert_cmp(cmp: BinOp_) -> BinOp_ {\n \n \n fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u128, span: Span) {\n-    if let ExprBinary(ref op, ref left, ref right) = bit_op.node {\n+    if let ExprKind::Binary(ref op, ref left, ref right) = bit_op.node {\n         if op.node != BiBitAnd && op.node != BiBitOr {\n             return;\n         }"}, {"sha": "94e17290b6a60991d4ea0f97abacc158f1de5526", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -56,10 +56,10 @@ struct ExVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let ExprClosure(_, _, eid, _, _) = expr.node {\n+        if let ExprKind::Closure(_, _, eid, _, _) = expr.node {\n             let body = self.cx.tcx.hir.body(eid);\n             let ex = &body.value;\n-            if matches!(ex.node, ExprBlock(_, _)) {\n+            if matches!(ex.node, ExprKind::Block(_, _)) {\n                 self.found_block = Some(ex);\n                 return;\n             }\n@@ -77,8 +77,8 @@ const COMPLEX_BLOCK_MESSAGE: &str = \"in an 'if' condition, avoid complex blocks\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIf(ref check, ref then, _) = expr.node {\n-            if let ExprBlock(ref block, _) = check.node {\n+        if let ExprKind::If(ref check, ref then, _) = expr.node {\n+            if let ExprKind::Block(ref block, _) = check.node {\n                 if block.rules == DefaultBlock {\n                     if block.stmts.is_empty() {\n                         if let Some(ref ex) = block.expr {"}, {"sha": "c6d0942a87708a2c877294716cf6742689b7cc9c", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -86,7 +86,7 @@ struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     fn extract(&mut self, op: BinOp_, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n         for a in a {\n-            if let ExprBinary(binop, ref lhs, ref rhs) = a.node {\n+            if let ExprKind::Binary(binop, ref lhs, ref rhs) = a.node {\n                 if binop.node == op {\n                     v = self.extract(op, &[lhs, rhs], v)?;\n                     continue;\n@@ -101,13 +101,13 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         // prevent folding of `cfg!` macros and the like\n         if !in_macro(e.span) {\n             match e.node {\n-                ExprUnary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n-                ExprBinary(binop, ref lhs, ref rhs) => match binop.node {\n+                ExprKind::Unary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprKind::Binary(binop, ref lhs, ref rhs) => match binop.node {\n                     BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n                     BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n                     _ => (),\n                 },\n-                ExprLit(ref lit) => match lit.node {\n+                ExprKind::Lit(ref lit) => match lit.node {\n                     LitKind::Bool(true) => return Ok(Bool::True),\n                     LitKind::Bool(false) => return Ok(Bool::False),\n                     _ => (),\n@@ -121,8 +121,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 return Ok(Bool::Term(n as u8));\n             }\n             let negated = match e.node {\n-                ExprBinary(binop, ref lhs, ref rhs) => {\n- \n+                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+\n                     if !implements_ord(self.cx, lhs) {\n                         continue;\n                     }\n@@ -133,7 +133,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                             hir_id: DUMMY_HIR_ID,\n                             span: DUMMY_SP,\n                             attrs: ThinVec::new(),\n-                            node: ExprBinary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n+                            node: ExprKind::Binary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n                         }\n                     };\n                     match binop.node {\n@@ -178,7 +178,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n \n     fn simplify_not(&self, expr: &Expr) -> Option<String> {\n         match expr.node {\n-            ExprBinary(binop, ref lhs, ref rhs) => {\n+            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n \n                 if !implements_ord(self.cx, lhs) {\n                     return None;\n@@ -194,7 +194,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                     _ => None,\n                 }.and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n             },\n-            ExprMethodCall(ref path, _, ref args) if args.len() == 1 => {\n+            ExprKind::MethodCall(ref path, _, ref args) if args.len() == 1 => {\n                 let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n                 if !match_type(self.cx, type_of_receiver, &paths::OPTION) &&\n                     !match_type(self.cx, type_of_receiver, &paths::RESULT) {\n@@ -441,8 +441,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n             return;\n         }\n         match e.node {\n-            ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n-            ExprUnary(UnNot, ref inner) => if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n+            ExprKind::Binary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n+            ExprKind::Unary(UnNot, ref inner) => if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n                 self.bool_expr(e);\n             } else {\n                 walk_expr(self, e);"}, {"sha": "e60fbbbe51db30cf8a51ed542d375153deb751f9", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -38,19 +38,19 @@ impl LintPass for ByteCount {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_chain! {\n-            if let ExprMethodCall(ref count, _, ref count_args) = expr.node;\n+            if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.node;\n             if count.ident.name == \"count\";\n             if count_args.len() == 1;\n-            if let ExprMethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n+            if let ExprKind::MethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n             if filter.ident.name == \"filter\";\n             if filter_args.len() == 2;\n-            if let ExprClosure(_, _, body_id, _, _) = filter_args[1].node;\n+            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].node;\n             then {\n                 let body = cx.tcx.hir.body(body_id);\n                 if_chain! {\n                     if body.arguments.len() == 1;\n                     if let Some(argname) = get_pat_name(&body.arguments[0].pat);\n-                    if let ExprBinary(ref op, ref l, ref r) = body.value.node;\n+                    if let ExprKind::Binary(ref op, ref l, ref r) = body.value.node;\n                     if op.node == BiEq;\n                     if match_type(cx,\n                                walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                         if ty::TyUint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n                             return;\n                         }\n-                        let haystack = if let ExprMethodCall(ref path, _, ref args) =\n+                        let haystack = if let ExprKind::MethodCall(ref path, _, ref args) =\n                                 filter_args[0].node {\n                             let p = path.ident.name;\n                             if (p == \"iter\" || p == \"iter_mut\") && args.len() == 1 {\n@@ -98,13 +98,13 @@ fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n \n fn get_path_name(expr: &Expr) -> Option<Name> {\n     match expr.node {\n-        ExprBox(ref e) | ExprAddrOf(_, ref e) | ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n-        ExprBlock(ref b, _) => if b.stmts.is_empty() {\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) | ExprKind::Unary(UnOp::UnDeref, ref e) => get_path_name(e),\n+        ExprKind::Block(ref b, _) => if b.stmts.is_empty() {\n             b.expr.as_ref().and_then(|p| get_path_name(p))\n         } else {\n             None\n         },\n-        ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n+        ExprKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n         _ => None,\n     }\n }"}, {"sha": "8e0e60193bbafb9247fb646c45e79976ee2accde", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -211,25 +211,25 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// simple constant folding: Insert an expression, get a constant or none.\n     pub fn expr(&mut self, e: &Expr) -> Option<Constant> {\n         match e.node {\n-            ExprPath(ref qpath) => self.fetch_path(qpath, e.hir_id),\n-            ExprBlock(ref block, _) => self.block(block),\n-            ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n-            ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty(e))),\n-            ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n-            ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprRepeat(ref value, _) => {\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id),\n+            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty(e))),\n+            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(ref value, _) => {\n                 let n = match self.tables.expr_ty(e).sty {\n                     ty::TyArray(_, n) => n.assert_usize(self.tcx).expect(\"array length\"),\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n as u64))\n             },\n-            ExprUnary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n                 UnNot => self.constant_not(&o, self.tables.expr_ty(e)),\n                 UnNeg => self.constant_negate(&o, self.tables.expr_ty(e)),\n                 UnDeref => Some(o),\n             }),\n-            ExprBinary(op, ref left, ref right) => self.binop(op, left, right),\n+            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n             // TODO: add other expressions\n             _ => None,\n         }\n@@ -279,7 +279,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             .collect::<Option<_>>()\n     }\n \n-    /// lookup a possibly constant expression from a ExprPath\n+    /// lookup a possibly constant expression from a ExprKind::Path\n     fn fetch_path(&mut self, qpath: &QPath, id: HirId) -> Option<Constant> {\n         let def = self.tables.qpath_def(qpath, id);\n         match def {"}, {"sha": "9e9a641ce27e3bc893291ea9f6e96af1850e4275", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n         if !in_macro(expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(&Expr {\n-                node: ExprIf(_, _, Some(ref else_expr)),\n+                node: ExprKind::If(_, _, Some(ref else_expr)),\n                 ..\n             }) = get_parent_expr(cx, expr)\n             {\n@@ -172,7 +172,7 @@ fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n \n /// Implementation of `MATCH_SAME_ARMS`.\n fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n-    if let ExprMatch(_, ref arms, MatchSource::Normal) = expr.node {\n+    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.node {\n         let hash = |&(_, arm): &(usize, &Arm)| -> u64 {\n             let mut h = SpanlessHash::new(cx, cx.tables);\n             h.hash_expr(&arm.body);\n@@ -236,12 +236,12 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n     let mut conds = SmallVector::new();\n     let mut blocks: SmallVector<&Block> = SmallVector::new();\n \n-    while let ExprIf(ref cond, ref then_expr, ref else_expr) = expr.node {\n+    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.node {\n         conds.push(&**cond);\n-        if let ExprBlock(ref block, _) = then_expr.node {\n+        if let ExprKind::Block(ref block, _) = then_expr.node {\n             blocks.push(block);\n         } else {\n-            panic!(\"ExprIf node is not an ExprBlock\");\n+            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n         if let Some(ref else_expr) = *else_expr {\n@@ -253,7 +253,7 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n \n     // final `else {..}`\n     if !blocks.is_empty() {\n-        if let ExprBlock(ref block, _) = expr.node {\n+        if let ExprKind::Block(ref block, _) = expr.node {\n             blocks.push(&**block);\n         }\n     }"}, {"sha": "33dbf1afc890ebe4cc374c3be6befce75c158150", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -147,14 +147,14 @@ struct CCHelper<'a, 'tcx: 'a> {\n impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprMatch(_, ref arms, _) => {\n+            ExprKind::Match(_, ref arms, _) => {\n                 walk_expr(self, e);\n                 let arms_n: u64 = arms.iter().map(|arm| arm.pats.len() as u64).sum();\n                 if arms_n > 1 {\n                     self.match_arms += arms_n - 2;\n                 }\n             },\n-            ExprCall(ref callee, _) => {\n+            ExprKind::Call(ref callee, _) => {\n                 walk_expr(self, e);\n                 let ty = self.cx.tables.node_id_to_type(callee.hir_id);\n                 match ty.sty {\n@@ -167,15 +167,15 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n                     _ => (),\n                 }\n             },\n-            ExprClosure(.., _) => (),\n-            ExprBinary(op, _, _) => {\n+            ExprKind::Closure(.., _) => (),\n+            ExprKind::Binary(op, _, _) => {\n                 walk_expr(self, e);\n                 match op.node {\n                     BiAnd | BiOr => self.short_circuits += 1,\n                     _ => (),\n                 }\n             },\n-            ExprRet(_) => self.returns += 1,\n+            ExprKind::Ret(_) => self.returns += 1,\n             _ => walk_expr(self, e),\n         }\n     }"}, {"sha": "900dabc96505b44232ca56faddad0285e00e411c", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -38,9 +38,9 @@ impl LintPass for DefaultTraitAccess {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ..) = expr.node;\n+            if let ExprKind::Call(ref path, ..) = expr.node;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.id);\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {"}, {"sha": "7681cc7225f6667167be18278f9c62e8b41d49d8", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> DoubleComparisonPass {\n         span: Span,\n     ) {\n         let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (lhs.node.clone(), rhs.node.clone()) {\n-            (ExprBinary(lb, llhs, lrhs), ExprBinary(rb, rlhs, rrhs)) => {\n+            (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n             }\n             _ => return,\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> DoubleComparisonPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisonPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref kind, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.node {\n             self.check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }\n     }"}, {"sha": "b0625e10d761d249dd02b8fc0668d5bbeee6dbe1", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -116,8 +116,8 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Call(ref path, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 1;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             then {"}, {"sha": "b3f8279c943b2d729324631f4e638d72228601d0", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -38,8 +38,8 @@ impl LintPass for DurationSubsec {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprBinary(Spanned { node: BiDiv, .. }, ref left, ref right) = expr.node;\n-            if let ExprMethodCall(ref method_path, _ , ref args) = left.node;\n+            if let ExprKind::Binary(Spanned { node: BiDiv, .. }, ref left, ref right) = expr.node;\n+            if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.node;\n             if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n             then {"}, {"sha": "f29c2d1bb6d0e26bb895a25558b6349b4157a9c6", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -41,13 +41,13 @@ impl LintPass for HashMapLint {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIf(ref check, ref then_block, ref else_block) = expr.node {\n-            if let ExprUnary(UnOp::UnNot, ref check) = check.node {\n+        if let ExprKind::If(ref check, ref then_block, ref else_block) = expr.node {\n+            if let ExprKind::Unary(UnOp::UnNot, ref check) = check.node {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = {\n-                        else_block.is_none() && if let ExprBlock(ref then_block, _) = then_block.node {\n+                        else_block.is_none() && if let ExprKind::Block(ref then_block, _) = then_block.node {\n                             (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n                         } else {\n                             true\n@@ -88,10 +88,10 @@ fn check_cond<'a, 'tcx, 'b>(\n     check: &'b Expr,\n ) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n     if_chain! {\n-        if let ExprMethodCall(ref path, _, ref params) = check.node;\n+        if let ExprKind::MethodCall(ref path, _, ref params) = check.node;\n         if params.len() >= 2;\n         if path.ident.name == \"contains_key\";\n-        if let ExprAddrOf(_, ref key) = params[1].node;\n+        if let ExprKind::AddrOf(_, ref key) = params[1].node;\n         then {\n             let map = &params[0];\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n@@ -123,7 +123,7 @@ struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprMethodCall(ref path, _, ref params) = expr.node;\n+            if let ExprKind::MethodCall(ref path, _, ref params) = expr.node;\n             if params.len() == 3;\n             if path.ident.name == \"insert\";\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);"}, {"sha": "7c4c09893d3e768cd0ab7b314e8e1faf852ccd96", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -52,7 +52,7 @@ impl LintPass for EqOp {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(op, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(op, ref left, ref right) = e.node {\n             if in_macro(e.span) {\n                 return;\n             }\n@@ -85,9 +85,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                 #[allow(match_same_arms)]\n                 match (&left.node, &right.node) {\n                     // do not suggest to dereference literals\n-                    (&ExprLit(..), _) | (_, &ExprLit(..)) => {},\n+                    (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar\n-                    (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n+                    (&ExprKind::AddrOf(_, ref l), &ExprKind::AddrOf(_, ref r)) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let rty = cx.tables.expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                         }\n                     },\n                     // &foo == bar\n-                    (&ExprAddrOf(_, ref l), _) => {\n+                    (&ExprKind::AddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy) && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()]) {\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                         }\n                     },\n                     // foo == &bar\n-                    (_, &ExprAddrOf(_, ref r)) => {\n+                    (_, &ExprKind::AddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy) && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()]) {"}, {"sha": "c14aafbd417dd3707e03720e81f3e50d26ccba8e", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n                 BiMul | BiBitAnd => {\n                     check(cx, left, e.span);"}, {"sha": "70055b13f9bd04fcaaab3e77d4cb526d990587ce", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                 if let StmtDecl(ref decl, _) = st.node {\n                     if let DeclLocal(ref loc) = decl.node {\n                         if let Some(ref ex) = loc.init {\n-                            if let ExprBox(..) = ex.node {\n+                            if let ExprKind::Box(..) = ex.node {\n                                 if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n                                     // let x = box (...)\n                                     self.set.insert(consume_pat.id);"}, {"sha": "87f0e64caafa60f282aa4c18d01ca9fd710cebde", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -37,7 +37,7 @@ impl LintPass for EtaPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n-            ExprCall(_, ref args) | ExprMethodCall(_, _, ref args) => for arg in args {\n+            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => for arg in args {\n                 check_closure(cx, arg)\n             },\n             _ => (),\n@@ -46,10 +46,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n }\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n-    if let ExprClosure(_, ref decl, eid, _, _) = expr.node {\n+    if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n         let body = cx.tcx.hir.body(eid);\n         let ex = &body.value;\n-        if let ExprCall(ref caller, ref args) = ex.node {\n+        if let ExprKind::Call(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there\n                 // is no way the closure is the same as the function\n@@ -73,7 +73,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n             for (a1, a2) in iter_input_pats(decl, body).zip(args) {\n                 if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n-                    if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {\n+                    if let ExprKind::Path(QPath::Resolved(None, ref p)) = a2.node {\n                         if p.segments.len() != 1 {\n                             // If it's a proper path, it can't be a local variable\n                             return;"}, {"sha": "ebbffc6680807ddacecd5df67e64289f422c5732", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n-            ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => if let ExprPath(ref qpath) = lhs.node {\n+            ExprKind::Assign(ref lhs, _) | ExprKind::AssignOp(_, ref lhs, _) => if let ExprKind::Path(ref qpath) = lhs.node {\n                 if let QPath::Resolved(_, ref path) = *qpath {\n                     if path.segments.len() == 1 {\n                         if let def::Def::Local(var) = cx.tables.qpath_def(qpath, lhs.hir_id) {\n@@ -102,8 +102,8 @@ struct DivergenceVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n     fn maybe_walk_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprClosure(.., _) => {},\n-            ExprMatch(ref e, ref arms, _) => {\n+            ExprKind::Closure(.., _) => {},\n+            ExprKind::Match(ref e, ref arms, _) => {\n                 self.visit_expr(e);\n                 for arm in arms {\n                     if let Some(ref guard) = arm.guard {\n@@ -124,8 +124,8 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprContinue(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n-            ExprCall(ref func, _) => {\n+            ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n+            ExprKind::Call(ref func, _) => {\n                 let typ = self.cx.tables.expr_ty(func);\n                 match typ.sty {\n                     ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                     _ => {},\n                 }\n             },\n-            ExprMethodCall(..) => {\n+            ExprKind::MethodCall(..) => {\n                 let borrowed_table = self.cx.tables;\n                 if borrowed_table.expr_ty(e).is_never() {\n                     self.report_diverging_sub_expr(e);\n@@ -218,25 +218,25 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n     }\n \n     match expr.node {\n-        ExprArray(_) |\n-        ExprTup(_) |\n-        ExprMethodCall(..) |\n-        ExprCall(_, _) |\n-        ExprAssign(_, _) |\n-        ExprIndex(_, _) |\n-        ExprRepeat(_, _) |\n-        ExprStruct(_, _, _) => {\n+        ExprKind::Array(_) |\n+        ExprKind::Tup(_) |\n+        ExprKind::MethodCall(..) |\n+        ExprKind::Call(_, _) |\n+        ExprKind::Assign(_, _) |\n+        ExprKind::Index(_, _) |\n+        ExprKind::Repeat(_, _) |\n+        ExprKind::Struct(_, _, _) => {\n             walk_expr(vis, expr);\n         },\n-        ExprBinary(op, _, _) | ExprAssignOp(op, _, _) => {\n+        ExprKind::Binary(op, _, _) | ExprKind::AssignOp(op, _, _) => {\n             if op.node == BiAnd || op.node == BiOr {\n                 // x && y and x || y always evaluate x first, so these are\n                 // strictly sequenced.\n             } else {\n                 walk_expr(vis, expr);\n             }\n         },\n-        ExprClosure(_, _, _, _, _) => {\n+        ExprKind::Closure(_, _, _, _, _) => {\n             // Either\n             //\n             // * `var` is defined in the closure body, in which case we've\n@@ -297,7 +297,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n         }\n \n         match expr.node {\n-            ExprPath(ref qpath) => {\n+            ExprKind::Path(ref qpath) => {\n                 if_chain! {\n                     if let QPath::Resolved(None, ref path) = *qpath;\n                     if path.segments.len() == 1;\n@@ -320,7 +320,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n             // We're about to descend a closure. Since we don't know when (or\n             // if) the closure will be evaluated, any reads in it might not\n             // occur here (or ever). Like above, bail to avoid false positives.\n-            ExprClosure(_, _, _, _, _) |\n+            ExprKind::Closure(_, _, _, _, _) |\n \n             // We want to avoid a false positive when a variable name occurs\n             // only to have its address taken, so we stop here. Technically,\n@@ -332,7 +332,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n             // ```\n             //\n             // TODO: fix this\n-            ExprAddrOf(_, _) => {\n+            ExprKind::AddrOf(_, _) => {\n                 return;\n             }\n             _ => {}\n@@ -348,7 +348,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n /// Returns true if `expr` is the LHS of an assignment, like `expr = ...`.\n fn is_in_assignment_position(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n-        if let ExprAssign(ref lhs, _) = parent.node {\n+        if let ExprKind::Assign(ref lhs, _) = parent.node {\n             return lhs.id == expr.id;\n         }\n     }"}, {"sha": "24bbf6692059cd7edac8e4fd728ac41c9f49c07f", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n             if let TypeVariants::TyFloat(fty) = ty.sty;\n-            if let hir::ExprLit(ref lit) = expr.node;\n+            if let hir::ExprKind::Lit(ref lit) = expr.node;\n             if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n             if let Some(sugg) = self.check(sym, fty);\n             then {"}, {"sha": "019d21f81e0e0131da6f5aed67c6b3cbd611d135", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -35,17 +35,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprMethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n+            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n             if unwrap_fun.ident.name == \"unwrap\";\n             // match call to write_fmt\n             if unwrap_args.len() > 0;\n-            if let ExprMethodCall(ref write_fun, _, ref write_args) =\n+            if let ExprKind::MethodCall(ref write_fun, _, ref write_args) =\n                 unwrap_args[0].node;\n             if write_fun.ident.name == \"write_fmt\";\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if write_args.len() > 0;\n-            if let ExprCall(ref dest_fun, _) = write_args[0].node;\n-            if let ExprPath(ref qpath) = dest_fun.node;\n+            if let ExprKind::Call(ref dest_fun, _) = write_args[0].node;\n+            if let ExprKind::Path(ref qpath) = dest_fun.node;\n             if let Some(dest_fun_id) =\n                 opt_def_id(resolve_node(cx, qpath, dest_fun.hir_id));\n             if let Some(dest_name) = if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stdout\"]) {"}, {"sha": "62e2ba7a2deefb0f557e38438cdb8265aace8d06", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -63,8 +63,8 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n         fn visit_expr(&mut self, expr: &'tcx Expr) {\n             // check for `begin_panic`\n             if_chain! {\n-                if let ExprCall(ref func_expr, _) = expr.node;\n-                if let ExprPath(QPath::Resolved(_, ref path)) = func_expr.node;\n+                if let ExprKind::Call(ref func_expr, _) = expr.node;\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.node;\n                 if let Some(path_def_id) = opt_def_id(path.def);\n                 if match_def_path(self.tcx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(self.tcx, path_def_id, &BEGIN_PANIC_FMT);"}, {"sha": "e88f03868939bfccc2b477cf6fde6b7c024c5bed", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -46,9 +46,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             match expr.node {\n \n                 // `format!(\"{}\", foo)` expansion\n-                ExprCall(ref fun, ref args) => {\n+                ExprKind::Call(ref fun, ref args) => {\n                     if_chain! {\n-                        if let ExprPath(ref qpath) = fun.node;\n+                        if let ExprKind::Path(ref qpath) = fun.node;\n                         if args.len() == 3;\n                         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n                         if match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n@@ -64,7 +64,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     }\n                 },\n                 // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-                ExprMatch(ref matchee, _, _) => if let ExprTup(ref tup) = matchee.node {\n+                ExprKind::Match(ref matchee, _, _) => if let ExprKind::Tup(ref tup) = matchee.node {\n                     if tup.is_empty() {\n                         let sugg = format!(\"{}.to_string()\", snippet(cx, expr.span, \"<expr>\").into_owned());\n                         span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n@@ -81,10 +81,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n /// Checks if the expressions matches `&[\"\"]`\n fn check_single_piece(expr: &Expr) -> bool {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\"]\n-        if let ExprArray(ref exprs) = expr.node; // [\"\"]\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\"]\n+        if let ExprKind::Array(ref exprs) = expr.node; // [\"\"]\n         if exprs.len() == 1;\n-        if let ExprLit(ref lit) = exprs[0].node;\n+        if let ExprKind::Lit(ref lit) = exprs[0].node;\n         if let LitKind::Str(ref lit, _) = lit.node;\n         then {\n             return lit.as_str().is_empty();\n@@ -105,23 +105,23 @@ fn check_single_piece(expr: &Expr) -> bool {\n /// then returns the span of first element of the matched tuple\n fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprMatch(ref match_expr, ref arms, _) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Match(ref match_expr, ref arms, _) = expr.node;\n         if arms.len() == 1;\n         if arms[0].pats.len() == 1;\n         if let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node;\n         if pat.len() == 1;\n-        if let ExprArray(ref exprs) = arms[0].body.node;\n+        if let ExprKind::Array(ref exprs) = arms[0].body.node;\n         if exprs.len() == 1;\n-        if let ExprCall(_, ref args) = exprs[0].node;\n+        if let ExprKind::Call(_, ref args) = exprs[0].node;\n         if args.len() == 2;\n-        if let ExprPath(ref qpath) = args[1].node;\n+        if let ExprKind::Path(ref qpath) = args[1].node;\n         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, args[1].hir_id));\n         if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n             if ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING) {\n-                if let ExprTup(ref values) = match_expr.node {\n+                if let ExprKind::Tup(ref values) = match_expr.node {\n                     return Some(values[0].span);\n                 }\n             }\n@@ -143,14 +143,14 @@ fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n /// ```\n fn check_unformatted(expr: &Expr) -> bool {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprArray(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Array(ref exprs) = expr.node;\n         if exprs.len() == 1;\n-        if let ExprStruct(_, ref fields, _) = exprs[0].node;\n+        if let ExprKind::Struct(_, ref fields, _) = exprs[0].node;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == \"format\");\n-        if let ExprStruct(_, ref fields, _) = format_field.expr.node;\n+        if let ExprKind::Struct(_, ref fields, _) = format_field.expr.node;\n         if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"width\");\n-        if let ExprPath(ref qpath) = align_field.expr.node;\n+        if let ExprKind::Path(ref qpath) = align_field.expr.node;\n         if last_path_segment(qpath).ident.name == \"Implied\";\n         then {\n             return true;"}, {"sha": "75ebd9eaece4bd835a5c99838b3def1541e62e78", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -184,7 +184,7 @@ struct DerefVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprCall(ref f, ref args) => {\n+            hir::ExprKind::Call(ref f, ref args) => {\n                 let ty = self.tables.expr_ty(f);\n \n                 if type_is_unsafe_function(self.cx, ty) {\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprMethodCall(_, _, ref args) => {\n+            hir::ExprKind::MethodCall(_, _, ref args) => {\n                 let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n@@ -203,7 +203,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprUnary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n+            hir::ExprKind::Unary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n             _ => (),\n         }\n \n@@ -216,7 +216,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n-        if let hir::ExprPath(ref qpath) = ptr.node {\n+        if let hir::ExprKind::Path(ref qpath) = ptr.node {\n             if let Def::Local(id) = self.cx.tables.qpath_def(qpath, ptr.hir_id) {\n                 if self.ptrs.contains(&id) {\n                     span_lint("}, {"sha": "32ae8bcb29f8b808774cd9bee5ed2a22e679c5ce", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -43,19 +43,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n         }\n \n         match e.node {\n-            ExprMatch(_, ref arms, MatchSource::TryDesugar) => {\n+            ExprKind::Match(_, ref arms, MatchSource::TryDesugar) => {\n                 let e = match arms[0].body.node {\n-                    ExprRet(Some(ref e)) | ExprBreak(_, Some(ref e)) => e,\n+                    ExprKind::Ret(Some(ref e)) | ExprKind::Break(_, Some(ref e)) => e,\n                     _ => return,\n                 };\n-                if let ExprCall(_, ref args) = e.node {\n+                if let ExprKind::Call(_, ref args) = e.node {\n                     self.try_desugar_arm.push(args[0].id);\n                 } else {\n                     return;\n                 }\n             },\n \n-            ExprMethodCall(ref name, .., ref args) => {\n+            ExprKind::MethodCall(ref name, .., ref args) => {\n                 if match_trait_method(cx, e, &paths::INTO[..]) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                 }\n             },\n \n-            ExprCall(ref path, ref args) => if let ExprPath(ref qpath) = path.node {\n+            ExprKind::Call(ref path, ref args) => if let ExprKind::Path(ref qpath) = path.node {\n                 if let Some(def_id) = opt_def_id(resolve_node(cx, qpath, path.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::FROM_FROM[..]) {\n                         let a = cx.tables.expr_ty(e);"}, {"sha": "95dea6fc6d2bf03abb3f74f1d96ea434ff34dcf4", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n                 BiAdd | BiBitOr | BiBitXor => {\n                     check(cx, left, 0, e.span, right.span);"}, {"sha": "17dcf571fbf0c35c82363b6a3b02d32fdd00f500", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -45,7 +45,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n+        if let ExprKind::Match(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n             if arms[0].pats.len() == 1 {\n                 let good_method = match arms[0].pats[0].node {\n                     PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 => {"}, {"sha": "8176408e720854e48828ee939bb5a6f04ef10e9e", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -94,7 +94,7 @@ impl LintPass for IndexingSlicing {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIndex(ref array, ref index) = &expr.node {\n+        if let ExprKind::Index(ref array, ref index) = &expr.node {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]"}, {"sha": "9abd9754d6795950823eb39e8bc0c2672986464e", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n         if_chain! {\n             if let Some(ref expr) = local.init;\n-            if let Expr_::ExprMatch(ref target, ref arms, MatchSource::Normal) = expr.node;\n+            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.node;\n             if arms.len() == 1 && arms[0].pats.len() == 1 && arms[0].guard.is_none();\n             if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pats[0].node;\n             if args.len() == 1;"}, {"sha": "a979486945a77497bec06ccb07f430070c5c0c58", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -141,7 +141,7 @@ static HEURISTICS: &[(&str, usize, Heuristic, Finiteness)] = &[\n \n fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n     match expr.node {\n-        ExprMethodCall(ref method, _, ref args) => {\n+        ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n                 if method.ident.name == name && args.len() == len {\n                     return (match heuristic {\n@@ -153,21 +153,21 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n                 }\n             }\n             if method.ident.name == \"flat_map\" && args.len() == 2 {\n-                if let ExprClosure(_, _, body_id, _, _) = args[1].node {\n+                if let ExprKind::Closure(_, _, body_id, _, _) = args[1].node {\n                     let body = cx.tcx.hir.body(body_id);\n                     return is_infinite(cx, &body.value);\n                 }\n             }\n             Finite\n         },\n-        ExprBlock(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n-        ExprBox(ref e) | ExprAddrOf(_, ref e) => is_infinite(cx, e),\n-        ExprCall(ref path, _) => if let ExprPath(ref qpath) = path.node {\n+        ExprKind::Block(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) => is_infinite(cx, e),\n+        ExprKind::Call(ref path, _) => if let ExprKind::Path(ref qpath) = path.node {\n             match_qpath(qpath, &paths::REPEAT).into()\n         } else {\n             Finite\n         },\n-        ExprStruct(..) => higher::range(cx, expr)\n+        ExprKind::Struct(..) => higher::range(cx, expr)\n             .map_or(false, |r| r.end.is_none())\n             .into(),\n         _ => Finite,\n@@ -205,7 +205,7 @@ static COMPLETING_METHODS: &[(&str, usize)] = &[\n \n fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n     match expr.node {\n-        ExprMethodCall(ref method, _, ref args) => {\n+        ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len) in COMPLETING_METHODS.iter() {\n                 if method.ident.name == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);\n@@ -224,11 +224,11 @@ fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n                 }\n             }\n         },\n-        ExprBinary(op, ref l, ref r) => if op.node.is_comparison() {\n+        ExprKind::Binary(op, ref l, ref r) => if op.node.is_comparison() {\n             return is_infinite(cx, l)\n                 .and(is_infinite(cx, r))\n                 .and(MaybeInfinite);\n-        }, // TODO: ExprLoop + Match\n+        }, // TODO: ExprKind::Loop + Match\n         _ => (),\n     }\n     Finite"}, {"sha": "255efa7416591ab3b5cc9097478f6c538be7f925", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -35,8 +35,8 @@ impl LintPass for InvalidRef {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Call(ref path, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 0;\n             if let ty::TyRef(..) = cx.tables.expr_ty(expr).sty;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));"}, {"sha": "17164c6c56a539edfcc958b4047f03fd28e6bc96", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n             return;\n         }\n \n-        if let ExprBinary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n+        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n             match cmp {\n                 BiEq => {\n                     check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n@@ -194,7 +194,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n }\n \n fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n-    if let (&ExprMethodCall(ref method_path, _, ref args), &ExprLit(ref lit)) = (&method.node, &lit.node) {\n+    if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.node, &lit.node) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name == \"is_empty\" {"}, {"sha": "44f197f7333149780ba90e9b491777ee4749ce5b", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -69,16 +69,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                 if let hir::DeclLocal(ref decl) = decl.node;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = decl.pat.node;\n                 if let hir::StmtExpr(ref if_, _) = expr.node;\n-                if let hir::ExprIf(ref cond, ref then, ref else_) = if_.node;\n+                if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.node;\n                 if !used_in_expr(cx, canonical_id, cond);\n-                if let hir::ExprBlock(ref then, _) = then.node;\n+                if let hir::ExprKind::Block(ref then, _) = then.node;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n                 if !used_in_expr(cx, canonical_id, value);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n                     let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n-                        if let hir::ExprBlock(ref else_, _) = else_.node {\n+                        if let hir::ExprKind::Block(ref else_, _) = else_.node {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)\n                             } else if let Some(ref default) = decl.init {\n@@ -140,7 +140,7 @@ struct UsedVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_chain! {\n-            if let hir::ExprPath(ref qpath) = expr.node;\n+            if let hir::ExprKind::Path(ref qpath) = expr.node;\n             if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n             if self.id == local_id;\n             then {\n@@ -164,8 +164,8 @@ fn check_assign<'a, 'tcx>(\n         if block.expr.is_none();\n         if let Some(expr) = block.stmts.iter().last();\n         if let hir::StmtSemi(ref expr, _) = expr.node;\n-        if let hir::ExprAssign(ref var, ref value) = expr.node;\n-        if let hir::ExprPath(ref qpath) = var.node;\n+        if let hir::ExprKind::Assign(ref var, ref value) = expr.node;\n+        if let hir::ExprKind::Path(ref qpath) = var.node;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, var.hir_id);\n         if decl == local_id;\n         then {"}, {"sha": "7dd7263551da43933939f136ef28ff1feab0f67f", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -411,7 +411,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         // check for never_loop\n         match expr.node {\n-            ExprWhile(_, ref block, _) | ExprLoop(ref block, _, _) => {\n+            ExprKind::While(_, ref block, _) | ExprKind::Loop(ref block, _, _) => {\n                 match never_loop_block(block, expr.id) {\n                     NeverLoopResult::AlwaysBreak =>\n                         span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n@@ -424,7 +424,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n-        if let ExprLoop(ref block, _, LoopSource::Loop) = expr.node {\n+        if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.node {\n             // also check for empty `loop {}` statements\n             if block.stmts.is_empty() && block.expr.is_none() {\n                 span_lint(\n@@ -440,7 +440,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let inner_stmt_expr = extract_expr_from_first_stmt(block);\n             // or extract the first expression (if any) from the block\n             if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(block)) {\n-                if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n+                if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n                         MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n@@ -476,11 +476,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n             }\n         }\n-        if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n+        if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n             if let (\n                 &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                &ExprMethodCall(ref method_path, _, ref method_args),\n+                &ExprKind::MethodCall(ref method_path, _, ref method_args),\n             ) = (pat, &match_expr.node)\n             {\n                 let iter_expr = &method_args[0];\n@@ -505,14 +505,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         // check for while loops which conditions never change\n-        if let ExprWhile(ref cond, _, _) = expr.node {\n+        if let ExprKind::While(ref cond, _, _) = expr.node {\n             check_infinite_loop(cx, cond, expr);\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n-            if let ExprMethodCall(ref method, _, ref args) = expr.node {\n+            if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && method.ident.name == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(\n                         cx,\n@@ -598,39 +598,39 @@ fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n \n fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n     match expr.node {\n-        ExprBox(ref e) |\n-        ExprUnary(_, ref e) |\n-        ExprCast(ref e, _) |\n-        ExprType(ref e, _) |\n-        ExprField(ref e, _) |\n-        ExprAddrOf(_, ref e) |\n-        ExprStruct(_, _, Some(ref e)) |\n-        ExprRepeat(ref e, _) => never_loop_expr(e, main_loop_id),\n-        ExprArray(ref es) | ExprMethodCall(_, _, ref es) | ExprTup(ref es) => {\n+        ExprKind::Box(ref e) |\n+        ExprKind::Unary(_, ref e) |\n+        ExprKind::Cast(ref e, _) |\n+        ExprKind::Type(ref e, _) |\n+        ExprKind::Field(ref e, _) |\n+        ExprKind::AddrOf(_, ref e) |\n+        ExprKind::Struct(_, _, Some(ref e)) |\n+        ExprKind::Repeat(ref e, _) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es) | ExprKind::Tup(ref es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },\n-        ExprCall(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n-        ExprBinary(_, ref e1, ref e2) |\n-        ExprAssign(ref e1, ref e2) |\n-        ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n-        ExprIf(ref e, ref e2, ref e3) => {\n+        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n+        ExprKind::Binary(_, ref e1, ref e2) |\n+        ExprKind::Assign(ref e1, ref e2) |\n+        ExprKind::AssignOp(_, ref e1, ref e2) |\n+        ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n+        ExprKind::If(ref e, ref e2, ref e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n             let e3 = e3.as_ref().map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n-        ExprLoop(ref b, _, _) => {\n+        ExprKind::Loop(ref b, _, _) => {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n-        ExprWhile(ref e, ref b, _) => {\n+        ExprKind::While(ref e, ref b, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             let result = never_loop_block(b, main_loop_id);\n             // Break can come from the inner loop so remove them.\n             combine_seq(e, absorb_break(&result))\n         },\n-        ExprMatch(ref e, ref arms, _) => {\n+        ExprKind::Match(ref e, ref arms, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             if arms.is_empty() {\n                 e\n@@ -639,8 +639,8 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n                 combine_seq(e, arms)\n             }\n         },\n-        ExprBlock(ref b, _) => never_loop_block(b, main_loop_id),\n-        ExprContinue(d) => {\n+        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Continue(d) => {\n             let id = d.target_id\n                 .expect(\"target id can only be missing in the presence of compilation errors\");\n             if id == main_loop_id {\n@@ -649,22 +649,22 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprBreak(_, _) => {\n+        ExprKind::Break(_, _) => {\n             NeverLoopResult::AlwaysBreak\n         },\n-        ExprRet(ref e) => {\n+        ExprKind::Ret(ref e) => {\n             if let Some(ref e) = *e {\n                 combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n             } else {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprStruct(_, _, None) |\n-        ExprYield(_) |\n-        ExprClosure(_, _, _, _, _) |\n-        ExprInlineAsm(_, _, _) |\n-        ExprPath(_) |\n-        ExprLit(_) => NeverLoopResult::Otherwise,\n+        ExprKind::Struct(_, _, None) |\n+        ExprKind::Yield(_) |\n+        ExprKind::Closure(_, _, _, _, _) |\n+        ExprKind::InlineAsm(_, _, _) |\n+        ExprKind::Path(_) |\n+        ExprKind::Lit(_) => NeverLoopResult::Otherwise,\n     }\n }\n \n@@ -701,7 +701,7 @@ fn check_for_loop<'a, 'tcx>(\n \n fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> bool {\n     if_chain! {\n-        if let ExprPath(ref qpath) = expr.node;\n+        if let ExprKind::Path(ref qpath) = expr.node;\n         if let QPath::Resolved(None, ref path) = *qpath;\n         if path.segments.len() == 1;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, expr.hir_id);\n@@ -754,23 +754,23 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> Option<FixedOffsetVar> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: ast::NodeId) -> Option<String> {\n         match e.node {\n-            ExprLit(ref l) => match l.node {\n+            ExprKind::Lit(ref l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n             },\n-            ExprPath(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            ExprKind::Path(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n             _ => None,\n         }\n     }\n \n-    if let ExprIndex(ref seqexpr, ref idx) = expr.node {\n+    if let ExprKind::Index(ref seqexpr, ref idx) = expr.node {\n         let ty = cx.tables.expr_ty(seqexpr);\n         if !is_slice_like(cx, ty) {\n             return None;\n         }\n \n         let offset = match idx.node {\n-            ExprBinary(op, ref lhs, ref rhs) => match op.node {\n+            ExprKind::Binary(op, ref lhs, ref rhs) => match op.node {\n                 BinOp_::BiAdd => {\n                     let offset_opt = if same_var(cx, lhs, var) {\n                         extract_offset(cx, rhs, var)\n@@ -785,7 +785,7 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n                 BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n                 _ => None,\n             },\n-            ExprPath(..) => if same_var(cx, idx, var) {\n+            ExprKind::Path(..) => if same_var(cx, idx, var) {\n                 Some(Offset::positive(\"0\".into()))\n             } else {\n                 None\n@@ -810,7 +810,7 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     var: ast::NodeId,\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n-        if let ExprMethodCall(ref method, _, ref args) = expr.node;\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n         if method.ident.name == \"clone\";\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n@@ -832,7 +832,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n         e: &Expr,\n         var: ast::NodeId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n-        if let Expr_::ExprAssign(ref lhs, ref rhs) = e.node {\n+        if let ExprKind::Assign(ref lhs, ref rhs) = e.node {\n             match (get_fixed_offset_var(cx, lhs, var), fetch_cloned_fixed_offset_var(cx, rhs, var)) {\n                 (Some(offset_left), Some(offset_right)) => {\n                     // Source and destination must be different\n@@ -849,7 +849,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n         }\n     }\n \n-    if let Expr_::ExprBlock(ref b, _) = body.node {\n+    if let ExprKind::Block(ref b, _) = body.node {\n         let Block {\n             ref stmts,\n             ref expr,\n@@ -906,7 +906,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n \n             let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| if let Some(end) = *end {\n                 if_chain! {\n-                    if let ExprMethodCall(ref method, _, ref len_args) = end.node;\n+                    if let ExprKind::MethodCall(ref method, _, ref len_args) = end.node;\n                     if method.ident.name == \"len\";\n                     if len_args.len() == 1;\n                     if let Some(arg) = len_args.get(0);\n@@ -1098,10 +1098,10 @@ fn check_for_loop_range<'a, 'tcx>(\n \n fn is_len_call(expr: &Expr, var: Name) -> bool {\n     if_chain! {\n-        if let ExprMethodCall(ref method, _, ref len_args) = expr.node;\n+        if let ExprKind::MethodCall(ref method, _, ref len_args) = expr.node;\n         if len_args.len() == 1;\n         if method.ident.name == \"len\";\n-        if let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node;\n+        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].node;\n         if path.segments.len() == 1;\n         if path.segments[0].ident.name == var;\n         then {\n@@ -1203,7 +1203,7 @@ fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &s\n \n fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n-    if let ExprMethodCall(ref method, _, ref args) = arg.node {\n+    if let ExprKind::MethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n             let method_name = &*method.ident.as_str();\n@@ -1377,7 +1377,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n                 MutMutable => \"_mut\",\n             };\n             let arg = match arg.node {\n-                ExprAddrOf(_, ref expr) => &**expr,\n+                ExprKind::AddrOf(_, ref expr) => &**expr,\n                 _ => arg,\n             };\n \n@@ -1483,7 +1483,7 @@ fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n \n fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n     if_chain! {\n-        if let ExprPath(ref qpath) = bound.node;\n+        if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n         then {\n             let def = cx.tables.qpath_def(qpath, bound.hir_id);\n@@ -1598,7 +1598,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n     fn check(&mut self, idx: &'tcx Expr, seqexpr: &'tcx Expr, expr: &'tcx Expr) -> bool {\n         if_chain! {\n             // the indexed container is referenced by a name\n-            if let ExprPath(ref seqpath) = seqexpr.node;\n+            if let ExprKind::Path(ref seqpath) = seqexpr.node;\n             if let QPath::Resolved(None, ref seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n             then {\n@@ -1655,7 +1655,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n             // a range index op\n-            if let ExprMethodCall(ref meth, _, ref args) = expr.node;\n+            if let ExprKind::MethodCall(ref meth, _, ref args) = expr.node;\n             if (meth.ident.name == \"index\" && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == \"index_mut\" && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n@@ -1664,14 +1664,14 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         if_chain! {\n             // an index op\n-            if let ExprIndex(ref seqexpr, ref idx) = expr.node;\n+            if let ExprKind::Index(ref seqexpr, ref idx) = expr.node;\n             if !self.check(idx, seqexpr, expr);\n             then { return }\n         }\n \n         if_chain! {\n             // directly using a variable\n-            if let ExprPath(ref qpath) = expr.node;\n+            if let ExprKind::Path(ref qpath) = expr.node;\n             if let QPath::Resolved(None, ref path) = *qpath;\n             if path.segments.len() == 1;\n             if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n@@ -1687,20 +1687,20 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         }\n         let old = self.prefer_mutable;\n         match expr.node {\n-            ExprAssignOp(_, ref lhs, ref rhs) |\n-            ExprAssign(ref lhs, ref rhs) => {\n+            ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+            ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.prefer_mutable = true;\n                 self.visit_expr(lhs);\n                 self.prefer_mutable = false;\n                 self.visit_expr(rhs);\n             },\n-            ExprAddrOf(mutbl, ref expr) => {\n+            ExprKind::AddrOf(mutbl, ref expr) => {\n                 if mutbl == MutMutable {\n                     self.prefer_mutable = true;\n                 }\n                 self.visit_expr(expr);\n             },\n-            ExprCall(ref f, ref args) => {\n+            ExprKind::Call(ref f, ref args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n                     let ty = self.cx.tables.expr_ty_adjusted(expr);\n@@ -1713,7 +1713,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprMethodCall(_, _, ref args) => {\n+            ExprKind::MethodCall(_, _, ref args) => {\n                 let def_id = self.cx.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n@@ -1841,8 +1841,8 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n /// passed expression. The expression may be within a block.\n fn is_simple_break_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBreak(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprBlock(ref b, _) => match extract_first_expr(b) {\n+        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n+        ExprKind::Block(ref b, _) => match extract_first_expr(b) {\n             Some(subexpr) => is_simple_break_expr(subexpr),\n             None => false,\n         },\n@@ -1882,7 +1882,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                 let state = self.states.entry(def_id).or_insert(VarState::Initial);\n \n                 match parent.node {\n-                    ExprAssignOp(op, ref lhs, ref rhs) => {\n+                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                         if lhs.id == expr.id {\n                             if op.node == BiAdd && is_integer_literal(rhs, 1) {\n                                 *state = match *state {\n@@ -1895,8 +1895,8 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                             }\n                         }\n                     },\n-                    ExprAssign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n-                    ExprAddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n+                    ExprKind::Assign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n+                    ExprKind::AddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n                     _ => (),\n                 }\n             }\n@@ -1969,17 +1969,17 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         if var_def_id(self.cx, expr) == Some(self.var_id) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.node {\n-                    ExprAssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n+                    ExprKind::AssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n                         self.state = VarState::DontWarn;\n                     },\n-                    ExprAssign(ref lhs, ref rhs) if lhs.id == expr.id => {\n+                    ExprKind::Assign(ref lhs, ref rhs) if lhs.id == expr.id => {\n                         self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n                             VarState::Warn\n                         } else {\n                             VarState::DontWarn\n                         }\n                     },\n-                    ExprAddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n+                    ExprKind::AddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n                     _ => (),\n                 }\n             }\n@@ -2005,7 +2005,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n }\n \n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n-    if let ExprPath(ref qpath) = expr.node {\n+    if let ExprKind::Path(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(node_id) = path_res {\n             return Some(node_id);\n@@ -2016,14 +2016,14 @@ fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n \n fn is_loop(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprLoop(..) | ExprWhile(..) => true,\n+        ExprKind::Loop(..) | ExprKind::While(..) => true,\n         _ => false,\n     }\n }\n \n fn is_conditional(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprIf(..) | ExprMatch(..) => true,\n+        ExprKind::If(..) | ExprKind::Match(..) => true,\n         _ => false,\n     }\n }\n@@ -2053,7 +2053,7 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n         }\n         match cx.tcx.hir.find(parent) {\n             Some(NodeExpr(expr)) => match expr.node {\n-                ExprLoop(..) | ExprWhile(..) => {\n+                ExprKind::Loop(..) | ExprKind::While(..) => {\n                     return true;\n                 },\n                 _ => (),\n@@ -2111,7 +2111,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.node {\n-            ExprAssign(ref path, _) | ExprAssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n+            ExprKind::Assign(ref path, _) | ExprKind::AssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n                 self.nesting = RuledOut;\n             },\n             _ => walk_expr(self, expr),\n@@ -2137,7 +2137,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n }\n \n fn path_name(e: &Expr) -> Option<Name> {\n-    if let ExprPath(QPath::Resolved(_, ref path)) = e.node {\n+    if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n         let segments = &path.segments;\n         if segments.len() == 1 {\n             return Some(segments[0].ident.name);\n@@ -2193,7 +2193,7 @@ struct VarCollectorVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n     fn insert_def_id(&mut self, ex: &'tcx Expr) {\n         if_chain! {\n-            if let ExprPath(ref qpath) = ex.node;\n+            if let ExprKind::Path(ref qpath) = ex.node;\n             if let QPath::Resolved(None, _) = *qpath;\n             let def = self.cx.tables.qpath_def(qpath, ex.hir_id);\n             then {\n@@ -2214,9 +2214,9 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         match ex.node {\n-            ExprPath(_) => self.insert_def_id(ex),\n+            ExprKind::Path(_) => self.insert_def_id(ex),\n             // If there is any fuction/method call\u2026 we just stop analysis\n-            ExprCall(..) | ExprMethodCall(..) => self.skip = true,\n+            ExprKind::Call(..) | ExprKind::MethodCall(..) => self.skip = true,\n \n             _ => walk_expr(self, ex),\n         }"}, {"sha": "01ce702c17cf78990015fa683ec2151893e4a05c", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -30,10 +30,10 @@ pub struct Pass;\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n-        if let ExprMethodCall(ref method, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n             if method.ident.name == \"map\" && args.len() == 2 {\n                 match args[1].node {\n-                    ExprClosure(_, ref decl, closure_eid, _, _) => {\n+                    ExprKind::Closure(_, ref decl, closure_eid, _, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n                         let closure_expr = remove_blocks(&body.value);\n                         if_chain! {\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                     }\n                                 }\n                                 // explicit clone() calls ( .map(|x| x.clone()) )\n-                                else if let ExprMethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n+                                else if let ExprKind::MethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n                                     if clone_call.ident.name == \"clone\" &&\n                                         clone_args.len() == 1 &&\n                                         match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n@@ -77,7 +77,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             }\n                         }\n                     },\n-                    ExprPath(ref path) => if match_qpath(path, &paths::CLONE) {\n+                    ExprKind::Path(ref path) => if match_qpath(path, &paths::CLONE) {\n                         let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n                         span_help_and_lint(\n                             cx,\n@@ -100,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn expr_eq_name(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n-        ExprPath(QPath::Resolved(None, ref path)) => {\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [\n                 PathSegment {\n                     ident: id,\n@@ -126,7 +126,7 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n \n fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n-        ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n+        ExprKind::Unary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n         _ => expr_eq_name(cx, expr, id),\n     }\n }"}, {"sha": "598160bb3efc09659e710bbe92fec8a8651079ce", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -115,12 +115,12 @@ fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<S\n     }\n \n     match expr.node {\n-        hir::ExprCall(_, _) |\n-        hir::ExprMethodCall(_, _, _) => {\n+        hir::ExprKind::Call(_, _) |\n+        hir::ExprKind::MethodCall(_, _, _) => {\n             // Calls can't be reduced any more\n             Some(expr.span)\n         },\n-        hir::ExprBlock(ref block, _) => {\n+        hir::ExprKind::Block(ref block, _) => {\n             match (&block.stmts[..], block.expr.as_ref()) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n@@ -151,7 +151,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<S\n }\n \n fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Option<(&'tcx hir::Arg, &'a hir::Expr)> {\n-    if let hir::ExprClosure(_, ref decl, inner_expr_id, _, _) = expr.node {\n+    if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.node {\n         let body = cx.tcx.hir.body(inner_expr_id);\n         let body_expr = &body.value;\n \n@@ -175,8 +175,8 @@ fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Op\n /// Anything else will return `_`.\n fn let_binding_name(cx: &LateContext, var_arg: &hir::Expr) -> String {\n     match &var_arg.node {\n-        hir::ExprField(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n-        hir::ExprPath(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n+        hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n+        hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n         _ => \"_\".to_string()\n     }\n }\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         if let hir::StmtSemi(ref expr, _) = stmt.node {\n-            if let hir::ExprMethodCall(_, _, _) = expr.node {\n+            if let hir::ExprKind::MethodCall(_, _, _) = expr.node {\n                 if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n                     lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n                 }"}, {"sha": "c82d156462d4bd857a6093a8fdbd6aee2f037cf2", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -184,14 +184,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n-        if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n+        if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.node {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n             check_wild_err_arm(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n         }\n-        if let ExprMatch(ref ex, ref arms, _) = expr.node {\n+        if let ExprKind::Match(ref ex, ref arms, _) = expr.node {\n             check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n@@ -205,7 +205,7 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n         let els = remove_blocks(&arms[1].body);\n         let els = if is_unit_expr(els) {\n             None\n-        } else if let ExprBlock(_, _) = els.node {\n+        } else if let ExprKind::Block(_, _) = els.node {\n             // matches with blocks that contain statements are prettier as `if let + else`\n             Some(els)\n         } else {\n@@ -294,7 +294,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                 if arms.len() == 2 && arms[0].pats.len() == 1 {\n                     // no guards\n                     let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n-                        if let ExprLit(ref lit) = arm_bool.node {\n+                        if let ExprKind::Lit(ref lit) = arm_bool.node {\n                             match lit.node {\n                                 LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n                                 LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n@@ -372,7 +372,7 @@ fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n                 if_chain! {\n                     if path_str == \"Err\";\n                     if inner.iter().any(is_wild);\n-                    if let ExprBlock(ref block, _) = arm.body.node;\n+                    if let ExprKind::Block(ref block, _) = arm.body.node;\n                     if is_panic_block(block);\n                     then {\n                         // `Err(_)` arm with `panic!` found\n@@ -406,7 +406,7 @@ fn is_panic_block(block: &Block) -> bool {\n fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n-        let (title, msg) = if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+        let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n             suggs.push((ex.span, Sugg::hir(cx, inner, \"..\").to_string()));\n             (\n                 \"you don't need to add `&` to both the expression and the patterns\",\n@@ -540,8 +540,8 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n \n fn is_unit_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprTup(ref v) if v.is_empty() => true,\n-        ExprBlock(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        ExprKind::Tup(ref v) if v.is_empty() => true,\n+        ExprKind::Block(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n         _ => false,\n     }\n }\n@@ -561,10 +561,10 @@ fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n         if let PatKind::Binding(rb, _, ident, _) = pats[0].node;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprCall(ref e, ref args) = remove_blocks(&arm.body).node;\n-        if let ExprPath(ref some_path) = e.node;\n+        if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).node;\n+        if let ExprKind::Path(ref some_path) = e.node;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n-        if let ExprPath(ref qpath) = args[0].node;\n+        if let ExprKind::Path(ref qpath) = args[0].node;\n         if let &QPath::Resolved(_, ref path2) = qpath;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {"}, {"sha": "11cf8a9a791ac179e8f216d72a618e391cd784be", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::*;\n-use rustc::hir::{Expr, ExprCall, ExprPath};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n \n /// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n@@ -30,8 +30,8 @@ impl LintPass for MemForget {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(ref qpath) = path_expr.node {\n+        if let ExprKind::Call(ref path_expr, ref args) = e.node {\n+            if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.tables.expr_ty(&args[0]);"}, {"sha": "ee7658334b3554d58e957e2485e98dd571abb4d7", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -718,7 +718,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         match expr.node {\n-            hir::ExprMethodCall(ref method_call, ref method_span, ref args) => {\n+            hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args) => {\n                 // Chain calls\n                 // GET_UNWRAP needs to be checked before general `UNWRAP` lints\n                 if let Some(arglists) = method_chain_args(expr, &[\"get\", \"unwrap\"]) {\n@@ -789,7 +789,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     _ => (),\n                 }\n             },\n-            hir::ExprBinary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n                 let mut info = BinaryExprInfo {\n                     expr,\n                     chain: lhs,\n@@ -889,7 +889,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n         }\n \n         if name == \"unwrap_or\" {\n-            if let hir::ExprPath(ref qpath) = fun.node {\n+            if let hir::ExprKind::Path(ref qpath) = fun.node {\n                 let path = &*last_path_segment(qpath).ident.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n@@ -982,13 +982,13 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n \n     if args.len() == 2 {\n         match args[1].node {\n-            hir::ExprCall(ref fun, ref or_args) => {\n+            hir::ExprKind::Call(ref fun, ref or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n                     check_general_case(cx, name, method_span, fun.span, &args[0], &args[1], or_has_args, expr.span);\n                 }\n             },\n-            hir::ExprMethodCall(_, span, ref or_args) => {\n+            hir::ExprKind::MethodCall(_, span, ref or_args) => {\n                 check_general_case(cx, name, method_span, span, &args[0], &args[1], !or_args.is_empty(), expr.span)\n             },\n             _ => {},\n@@ -999,10 +999,10 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n /// Checks for the `EXPECT_FUN_CALL` lint.\n fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     fn extract_format_args(arg: &hir::Expr) -> Option<&hir::HirVec<hir::Expr>> {\n-        if let hir::ExprAddrOf(_, ref addr_of) = arg.node {\n-            if let hir::ExprCall(ref inner_fun, ref inner_args) = addr_of.node {\n+        if let hir::ExprKind::AddrOf(_, ref addr_of) = arg.node {\n+            if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = addr_of.node {\n                 if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n-                    if let hir::ExprCall(_, ref format_args) = inner_args[0].node {\n+                    if let hir::ExprKind::Call(_, ref format_args) = inner_args[0].node {\n                         return Some(format_args);\n                     }\n                 }\n@@ -1013,9 +1013,9 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n     }\n \n     fn generate_format_arg_snippet(cx: &LateContext, a: &hir::Expr) -> String {\n-        if let hir::ExprAddrOf(_, ref format_arg) = a.node {\n-            if let hir::ExprMatch(ref format_arg_expr, _, _) = format_arg.node {\n-                if let hir::ExprTup(ref format_arg_expr_tup) = format_arg_expr.node {\n+        if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n+            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n+                if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n                     return snippet(cx, format_arg_expr_tup[0].span, \"..\").into_owned();\n                 }\n             }\n@@ -1090,7 +1090,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n \n     if args.len() == 2 {\n         match args[1].node {\n-            hir::ExprLit(_) => {},\n+            hir::ExprKind::Lit(_) => {},\n             _ => check_general_case(cx, name, method_span, &args[0], &args[1], expr.span),\n         }\n     }\n@@ -1133,9 +1133,9 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n                 match cx.tcx.hir.get(parent) {\n                     hir::map::NodeExpr(parent) => match parent.node {\n                         // &*x is a nop, &x.clone() is not\n-                        hir::ExprAddrOf(..) |\n+                        hir::ExprKind::AddrOf(..) |\n                         // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                        hir::ExprMethodCall(..) => return,\n+                        hir::ExprKind::MethodCall(..) => return,\n                         _ => {},\n                     }\n                     hir::map::NodeStmt(stmt) => {\n@@ -1229,9 +1229,9 @@ fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n \n fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n     if_chain! {\n-        if let hir::ExprCall(ref fun, ref args) = new.node;\n+        if let hir::ExprKind::Call(ref fun, ref args) = new.node;\n         if args.len() == 1;\n-        if let hir::ExprPath(ref path) = fun.node;\n+        if let hir::ExprKind::Path(ref path) = fun.node;\n         if let Def::Method(did) = cx.tables.qpath_def(path, fun.hir_id);\n         if match_def_path(cx.tcx, did, &paths::CSTRING_NEW);\n         then {\n@@ -1280,12 +1280,12 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n \n         if_chain! {\n             // Extract the body of the closure passed to fold\n-            if let hir::ExprClosure(_, _, body_id, _, _) = fold_args[2].node;\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].node;\n             let closure_body = cx.tcx.hir.body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n-            if let hir::ExprBinary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n+            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n             if bin_op.node == op;\n \n             // Extract the names of the two arguments to the closure\n@@ -1329,7 +1329,7 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n \n     // Check if the first argument to .fold is a suitable literal\n     match fold_args[1].node {\n-        hir::ExprLit(ref lit) => {\n+        hir::ExprKind::Lit(ref lit) => {\n             match lit.node {\n                 ast::LitKind::Bool(false) => check_fold_with_op(\n                     cx, fold_args, hir::BinOp_::BiOr, \"any\", true\n@@ -1437,7 +1437,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n         }\n     }\n \n-    if let hir::ExprMethodCall(ref path, _, ref args) = expr.node {\n+    if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n         if path.ident.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n@@ -1615,7 +1615,7 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n     if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n-        let map_or_arg_is_none = if let hir::Expr_::ExprPath(ref qpath) = map_or_args[1].node {\n+        let map_or_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].node {\n             match_qpath(qpath, &paths::OPTION_NONE)\n         } else {\n             false\n@@ -1790,9 +1790,9 @@ fn lint_chars_cmp<'a, 'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprCall(ref fun, ref arg_char) = info.other.node;\n+        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.node;\n         if arg_char.len() == 1;\n-        if let hir::ExprPath(ref qpath) = fun.node;\n+        if let hir::ExprKind::Path(ref qpath) = fun.node;\n         if let Some(segment) = single_segment_path(qpath);\n         if segment.ident.name == \"Some\";\n         then {\n@@ -1844,7 +1844,7 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprLit(ref lit) = info.other.node;\n+        if let hir::ExprKind::Lit(ref lit) = info.other.node;\n         if let ast::LitKind::Char(c) = lit.node;\n         then {\n             span_lint_and_sugg("}, {"sha": "fa2c9fda731e5ef6fef36e4b36bebdaca1c570f9", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -66,8 +66,8 @@ enum MinMax {\n }\n \n fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n-    if let ExprCall(ref path, ref args) = expr.node {\n-        if let ExprPath(ref qpath) = path.node {\n+    if let ExprKind::Call(ref path, ref args) = expr.node {\n+        if let ExprKind::Path(ref qpath) = path.node {\n             opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)).and_then(|def_id| {\n                 if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n                     fetch_const(cx, args, MinMax::Min)"}, {"sha": "f701f957031bdbdd594bd56d3d2343cdcd56ee43", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         };\n         if_chain! {\n             if let StmtSemi(ref expr, _) = s.node;\n-            if let Expr_::ExprBinary(ref binop, ref a, ref b) = expr.node;\n+            if let ExprKind::Binary(ref binop, ref a, ref b) = expr.node;\n             if binop.node == BiAnd || binop.node == BiOr;\n             if let Some(sugg) = Sugg::hir_opt(cx, a);\n             then {\n@@ -323,17 +323,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n-            ExprCast(ref e, ref ty) => {\n+            ExprKind::Cast(ref e, ref ty) => {\n                 check_cast(cx, expr.span, e, ty);\n                 return;\n             },\n-            ExprBinary(ref cmp, ref left, ref right) => {\n+            ExprKind::Binary(ref cmp, ref left, ref right) => {\n                 let op = cmp.node;\n                 if op.is_comparison() {\n-                    if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n+                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.node {\n                         check_nan(cx, path, expr);\n                     }\n-                    if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n+                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = right.node {\n                         check_nan(cx, path, expr);\n                     }\n                     check_to_owned(cx, left, right);\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         let binding = match expr.node {\n-            ExprPath(ref qpath) => {\n+            ExprKind::Path(ref qpath) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n@@ -392,7 +392,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     None\n                 }\n             },\n-            ExprField(_, ident) => {\n+            ExprKind::Field(_, ident) => {\n                 let name = ident.as_str();\n                 if name.starts_with('_') && !name.starts_with(\"__\") {\n                     Some(name)\n@@ -467,14 +467,14 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n \n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n     let (arg_ty, snip) = match expr.node {\n-        ExprMethodCall(.., ref args) if args.len() == 1 => {\n+        ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n                 (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n-        ExprCall(ref path, ref v) if v.len() == 1 => if let ExprPath(ref path) = path.node {\n+        ExprKind::Call(ref path, ref v) if v.len() == 1 => if let ExprKind::Path(ref path) = path.node {\n             if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n                 (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n             } else {\n@@ -542,7 +542,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n-            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n+            ExprKind::Assign(_, ref rhs) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n             _ => is_used(cx, parent),\n         }\n     } else {\n@@ -572,7 +572,7 @@ fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n fn check_cast(cx: &LateContext, span: Span, e: &Expr, ty: &Ty) {\n     if_chain! {\n         if let TyPtr(MutTy { mutbl, .. }) = ty.node;\n-        if let ExprLit(ref lit) = e.node;\n+        if let ExprKind::Lit(ref lit) = e.node;\n         if let LitKind::Int(value, ..) = lit.node;\n         if value == 0;\n         if !in_constant(cx, e.id);"}, {"sha": "fa8bb73f21cb4493d5d60a64ebfbac0dd39a6286", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -62,8 +62,8 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             // Let's ignore the generated code.\n             intravisit::walk_expr(self, arg);\n             intravisit::walk_expr(self, body);\n-        } else if let hir::ExprAddrOf(hir::MutMutable, ref e) = expr.node {\n-            if let hir::ExprAddrOf(hir::MutMutable, _) = e.node {\n+        } else if let hir::ExprKind::AddrOf(hir::MutMutable, ref e) = expr.node {\n+            if let hir::ExprKind::AddrOf(hir::MutMutable, _) = e.node {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,"}, {"sha": "b4d6652a65a4d00b7c26b72057bc031056452353", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -36,15 +36,15 @@ impl LintPass for UnnecessaryMutPassed {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         match e.node {\n-            ExprCall(ref fn_expr, ref arguments) => if let ExprPath(ref path) = fn_expr.node {\n+            ExprKind::Call(ref fn_expr, ref arguments) => if let ExprKind::Path(ref path) = fn_expr.node {\n                 check_arguments(\n                     cx,\n                     arguments,\n                     cx.tables.expr_ty(fn_expr),\n                     &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n                 );\n             },\n-            ExprMethodCall(ref path, _, ref arguments) => {\n+            ExprKind::MethodCall(ref path, _, ref arguments) => {\n                 let def_id = cx.tables.type_dependent_defs()[e.hir_id].def_id();\n                 let substs = cx.tables.node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n@@ -69,7 +69,7 @@ fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], typ\n                     ty::TyRawPtr(ty::TypeAndMut {\n                         mutbl: MutImmutable,\n                         ..\n-                    }) => if let ExprAddrOf(MutMutable, _) = argument.node {\n+                    }) => if let ExprKind::AddrOf(MutMutable, _) = argument.node {\n                         span_lint(\n                             cx,\n                             UNNECESSARY_MUT_PASSED,"}, {"sha": "03c602bc234e4169c7e11375d21fbf3e95d2e1c6", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -60,7 +60,7 @@ impl LintPass for NeedlessBool {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n-        if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n+        if let ExprKind::If(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n                 let snip = Sugg::hir(cx, pred, \"<predicate>\");\n                 let snip = if not { !snip } else { snip };\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     hint,\n                 );\n             };\n-            if let ExprBlock(ref then_block, _) = then_block.node {\n+            if let ExprKind::Block(ref then_block, _) = then_block.node {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     _ => (),\n                 }\n             } else {\n-                panic!(\"IfExpr 'then' node is not an ExprBlock\");\n+                panic!(\"IfExpr 'then' node is not an ExprKind::Block\");\n             }\n         }\n     }\n@@ -123,7 +123,7 @@ impl LintPass for BoolComparison {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n-        if let ExprBinary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n@@ -185,7 +185,7 @@ fn fetch_bool_block(block: &Block) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n         (&[ref e], None) => if let StmtSemi(ref e, _) = e.node {\n-            if let ExprRet(_) = e.node {\n+            if let ExprKind::Ret(_) = e.node {\n                 fetch_bool_expr(&**e)\n             } else {\n                 Expression::Other\n@@ -199,13 +199,13 @@ fn fetch_bool_block(block: &Block) -> Expression {\n \n fn fetch_bool_expr(expr: &Expr) -> Expression {\n     match expr.node {\n-        ExprBlock(ref block, _) => fetch_bool_block(block),\n-        ExprLit(ref lit_ptr) => if let LitKind::Bool(value) = lit_ptr.node {\n+        ExprKind::Block(ref block, _) => fetch_bool_block(block),\n+        ExprKind::Lit(ref lit_ptr) => if let LitKind::Bool(value) = lit_ptr.node {\n             Expression::Bool(value)\n         } else {\n             Expression::Other\n         },\n-        ExprRet(Some(ref expr)) => match fetch_bool_expr(expr) {\n+        ExprKind::Ret(Some(ref expr)) => match fetch_bool_expr(expr) {\n             Expression::Bool(value) => Expression::RetBool(value),\n             _ => Expression::Other,\n         },"}, {"sha": "90e41bc6f68ac02916e1a053ca5e6d4b8b494070", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -3,7 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n-use rustc::hir::{BindingAnnotation, Expr, ExprAddrOf, MutImmutable, Pat, PatKind};\n+use rustc::hir::{BindingAnnotation, Expr, ExprKind, MutImmutable, Pat, PatKind};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};\n use crate::utils::{in_macro, snippet_opt, span_lint_and_then};\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n+        if let ExprKind::AddrOf(MutImmutable, ref inner) = e.node {\n             if let ty::TyRef(..) = cx.tables.expr_ty(inner).sty {\n                 for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n                     if let [Adjustment {"}, {"sha": "cedc3fdfd2899ff015e6c3cae99b52b02f4f1ae8", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -339,7 +339,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                     match node {\n                         map::Node::NodeExpr(e) => {\n                             // `match` and `if let`\n-                            if let ExprMatch(ref c, ..) = e.node {\n+                            if let ExprKind::Match(ref c, ..) = e.node {\n                                 self.spans_need_deref\n                                     .entry(vid)\n                                     .or_insert_with(HashSet::new)"}, {"sha": "9c670c1a5b3e7507356d60bf11183df733e1cdd8", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n-use rustc::hir::{Expr, ExprStruct};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::span_lint;\n \n /// **What it does:** Checks for needlessly including a base struct on update\n@@ -32,7 +32,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n+        if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.non_enum_variant().fields.len() {"}, {"sha": "2eb63c264fdd04cb39de2cdf2612bf9dd34d1e1a", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -18,20 +18,20 @@ use crate::utils::{self, paths, span_lint, in_external_macro};\n ///\n /// ```rust\n /// use core::cmp::Ordering;\n-/// \n+///\n /// // Bad\n /// let a = 1.0;\n /// let b = std::f64::NAN;\n-/// \n+///\n /// let _not_less_or_equal = !(a <= b);\n ///\n /// // Good\n /// let a = 1.0;\n /// let b = std::f64::NAN;\n-/// \n+///\n /// let _not_less_or_equal = match a.partial_cmp(&b) {\n ///     None | Some(Ordering::Greater) => true,\n-///     _ => false, \n+///     _ => false,\n /// };\n /// ```\n declare_clippy_lint! {\n@@ -54,8 +54,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n         if_chain! {\n \n             if !in_external_macro(cx, expr.span);\n-            if let Expr_::ExprUnary(UnOp::UnNot, ref inner) = expr.node;\n-            if let Expr_::ExprBinary(ref op, ref left, _) = inner.node;\n+            if let ExprKind::Unary(UnOp::UnNot, ref inner) = expr.node;\n+            if let ExprKind::Binary(ref op, ref left, _) = inner.node;\n             if let BinOp_::BiLe | BinOp_::BiGe | BinOp_::BiLt | BinOp_::BiGt = op.node;\n \n             then {"}, {"sha": "70cc9eecf6e78a00b70362ffc89691be1a33bad7", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -33,11 +33,11 @@ impl LintPass for NegMultiply {\n #[allow(match_same_arms)]\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(Spanned { node: BiMul, .. }, ref l, ref r) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BiMul, .. }, ref l, ref r) = e.node {\n             match (&l.node, &r.node) {\n-                (&ExprUnary(..), &ExprUnary(..)) => (),\n-                (&ExprUnary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),\n-                (_, &ExprUnary(UnNeg, ref lit)) => check_mul(cx, e.span, lit, l),\n+                (&ExprKind::Unary(..), &ExprKind::Unary(..)) => (),\n+                (&ExprKind::Unary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),\n+                (_, &ExprKind::Unary(UnNeg, ref lit)) => check_mul(cx, e.span, lit, l),\n                 _ => (),\n             }\n         }\n@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n \n fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n     if_chain! {\n-        if let ExprLit(ref l) = lit.node;\n+        if let ExprKind::Lit(ref l) = lit.node;\n         if let Constant::Int(val) = consts::lit_to_constant(&l.node, cx.tables.expr_ty(lit));\n         if val == 1;\n         if cx.tables.expr_ty(exp).is_integral();"}, {"sha": "fea0a83b4447e68ab1642db4b11c51d2ad9d9594", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::hir::def::Def;\n-use rustc::hir::{BiAnd, BiOr, BlockCheckMode, Expr, Expr_, Stmt, StmtSemi, UnsafeSource};\n+use rustc::hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n use crate::utils::{has_drop, in_macro, snippet_opt, span_lint, span_lint_and_sugg};\n use std::ops::Deref;\n \n@@ -45,26 +45,26 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         return false;\n     }\n     match expr.node {\n-        Expr_::ExprLit(..) | Expr_::ExprClosure(.., _) => true,\n-        Expr_::ExprPath(..) => !has_drop(cx, expr),\n-        Expr_::ExprIndex(ref a, ref b) | Expr_::ExprBinary(_, ref a, ref b) => {\n+        ExprKind::Lit(..) | ExprKind::Closure(.., _) => true,\n+        ExprKind::Path(..) => !has_drop(cx, expr),\n+        ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n             has_no_effect(cx, a) && has_no_effect(cx, b)\n         },\n-        Expr_::ExprArray(ref v) | Expr_::ExprTup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n-        Expr_::ExprRepeat(ref inner, _) |\n-        Expr_::ExprCast(ref inner, _) |\n-        Expr_::ExprType(ref inner, _) |\n-        Expr_::ExprUnary(_, ref inner) |\n-        Expr_::ExprField(ref inner, _) |\n-        Expr_::ExprAddrOf(_, ref inner) |\n-        Expr_::ExprBox(ref inner) => has_no_effect(cx, inner),\n-        Expr_::ExprStruct(_, ref fields, ref base) => {\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n+        ExprKind::Repeat(ref inner, _) |\n+        ExprKind::Cast(ref inner, _) |\n+        ExprKind::Type(ref inner, _) |\n+        ExprKind::Unary(_, ref inner) |\n+        ExprKind::Field(ref inner, _) |\n+        ExprKind::AddrOf(_, ref inner) |\n+        ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n+        ExprKind::Struct(_, ref fields, ref base) => {\n             !has_drop(cx, expr) && fields.iter().all(|field| has_no_effect(cx, &field.expr)) && match *base {\n                 Some(ref base) => has_no_effect(cx, base),\n                 None => true,\n             }\n         },\n-        Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n+        ExprKind::Call(ref callee, ref args) => if let ExprKind::Path(ref qpath) = callee.node {\n             let def = cx.tables.qpath_def(qpath, callee.hir_id);\n             match def {\n                 Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) => {\n@@ -75,7 +75,7 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         } else {\n             false\n         },\n-        Expr_::ExprBlock(ref block, _) => {\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n                 has_no_effect(cx, expr)\n             } else {\n@@ -132,19 +132,19 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         return None;\n     }\n     match expr.node {\n-        Expr_::ExprIndex(ref a, ref b) => Some(vec![&**a, &**b]),\n-        Expr_::ExprBinary(ref binop, ref a, ref b) if binop.node != BiAnd && binop.node != BiOr => {\n+        ExprKind::Index(ref a, ref b) => Some(vec![&**a, &**b]),\n+        ExprKind::Binary(ref binop, ref a, ref b) if binop.node != BiAnd && binop.node != BiOr => {\n             Some(vec![&**a, &**b])\n         },\n-        Expr_::ExprArray(ref v) | Expr_::ExprTup(ref v) => Some(v.iter().collect()),\n-        Expr_::ExprRepeat(ref inner, _) |\n-        Expr_::ExprCast(ref inner, _) |\n-        Expr_::ExprType(ref inner, _) |\n-        Expr_::ExprUnary(_, ref inner) |\n-        Expr_::ExprField(ref inner, _) |\n-        Expr_::ExprAddrOf(_, ref inner) |\n-        Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        Expr_::ExprStruct(_, ref fields, ref base) => if has_drop(cx, expr) {\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => Some(v.iter().collect()),\n+        ExprKind::Repeat(ref inner, _) |\n+        ExprKind::Cast(ref inner, _) |\n+        ExprKind::Type(ref inner, _) |\n+        ExprKind::Unary(_, ref inner) |\n+        ExprKind::Field(ref inner, _) |\n+        ExprKind::AddrOf(_, ref inner) |\n+        ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n+        ExprKind::Struct(_, ref fields, ref base) => if has_drop(cx, expr) {\n             None\n         } else {\n             Some(\n@@ -156,7 +156,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n                     .collect(),\n             )\n         },\n-        Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n+        ExprKind::Call(ref callee, ref args) => if let ExprKind::Path(ref qpath) = callee.node {\n             let def = cx.tables.qpath_def(qpath, callee.hir_id);\n             match def {\n                 Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..)\n@@ -169,7 +169,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         } else {\n             None\n         },\n-        Expr_::ExprBlock(ref block, _) => {\n+        ExprKind::Block(ref block, _) => {\n             if block.stmts.is_empty() {\n                 block.expr.as_ref().and_then(|e| {\n                     match block.rules {"}, {"sha": "4e3142e451745eb0d01ea238e1f37c9a5a79986f", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprPath(qpath) = &expr.node {\n+        if let ExprKind::Path(qpath) = &expr.node {\n             // Only lint if we use the const item inside a function.\n             if in_constant(cx, expr.id) {\n                 return;\n@@ -213,22 +213,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                 }\n                 if let Some(map::NodeExpr(parent_expr)) = cx.tcx.hir.find(parent_id) {\n                     match &parent_expr.node {\n-                        ExprAddrOf(..) => {\n+                        ExprKind::AddrOf(..) => {\n                             // `&e` => `e` must be referenced\n                             needs_check_adjustment = false;\n                         }\n-                        ExprField(..) => {\n+                        ExprKind::Field(..) => {\n                             dereferenced_expr = parent_expr;\n                             needs_check_adjustment = true;\n                         }\n-                        ExprIndex(e, _) if ptr::eq(&**e, cur_expr) => {\n+                        ExprKind::Index(e, _) if ptr::eq(&**e, cur_expr) => {\n                             // `e[i]` => desugared to `*Index::index(&e, i)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now.\n                             needs_check_adjustment = false;\n                             break;\n                         }\n-                        ExprUnary(UnDeref, _) => {\n+                        ExprKind::Unary(UnDeref, _) => {\n                             // `*e` => desugared to `*Deref::deref(&e)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now."}, {"sha": "0a1399075e067886b508c9264e003aba6f5c93fa", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -44,9 +44,9 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! { //begin checking variables\n-            if let ExprMatch(ref op, ref body, ref source) = expr.node; //test if expr is a match\n+            if let ExprKind::Match(ref op, ref body, ref source) = expr.node; //test if expr is a match\n             if let MatchSource::IfLetDesugar { .. } = *source; //test if it is an If Let\n-            if let ExprMethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n+            if let ExprKind::MethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n "}, {"sha": "b4559969ac246ca1d66a08b384118b071fa78eba", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::{Expr, ExprLit, ExprMethodCall};\n+use rustc::hir::{Expr, ExprKind};\n use rustc::lint::*;\n use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n@@ -33,7 +33,7 @@ impl LintPass for NonSensical {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprMethodCall(ref path, _, ref arguments) = e.node {\n+        if let ExprKind::MethodCall(ref path, _, ref arguments) = e.node {\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n             if path.ident.name == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n@@ -61,13 +61,13 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprMethodCall(ref path, _, ref arguments) = argument.node {\n+    if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.node {\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n             let argument_option = match arguments[1].node {\n-                ExprLit(ref span) => {\n+                ExprKind::Lit(ref span) => {\n                     if let Spanned {\n                         node: LitKind::Bool(lit),\n                         .."}, {"sha": "4e63fc2f7fce262c941aebe7e4eb77f0c077ce6c", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -33,11 +33,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n-            if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node;\n+            if let ExprKind::Binary(ref op, ref first, ref second) = expr.node;\n+            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = first.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.node;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();\n@@ -58,11 +58,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n         }\n \n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n-            if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node;\n+            if let ExprKind::Binary(ref op, ref first, ref second) = expr.node;\n+            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = second.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.node;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();"}, {"sha": "24cf6544f6a061f9212cb3fa42f404ba94cc62b8", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -52,10 +52,10 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprBlock(ref block, _) = expr.node;\n+            if let ExprKind::Block(ref block, _) = expr.node;\n             if let Some(ref ex) = block.expr;\n-            if let ExprCall(ref fun, ref params) = ex.node;\n-            if let ExprPath(ref qpath) = fun.node;\n+            if let ExprKind::Call(ref fun, ref params) = ex.node;\n+            if let ExprKind::Path(ref qpath) = fun.node;\n             if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n             if match_def_path(cx.tcx, fun_def_id, &paths::BEGIN_PANIC);\n             if params.len() == 2;\n@@ -86,7 +86,7 @@ fn get_outer_span(expr: &Expr) -> Span {\n \n fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext) {\n     if_chain! {\n-        if let ExprLit(ref lit) = params[0].node;\n+        if let ExprKind::Lit(ref lit) = params[0].node;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();\n         if let LitKind::Str(ref string, _) = lit.node;\n         let string = string.as_str().replace(\"{{\", \"\").replace(\"}}\", \"\");"}, {"sha": "a2c204dd1494cfa1782ba995baf1d966483dd07b", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref op, ref l, ref r) = expr.node {\n+        if let ExprKind::Binary(ref op, ref l, ref r) = expr.node {\n             if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(\n                     cx,\n@@ -281,9 +281,9 @@ fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n }\n \n fn is_null_path(expr: &Expr) -> bool {\n-    if let ExprCall(ref pathexp, ref args) = expr.node {\n+    if let ExprKind::Call(ref pathexp, ref args) = expr.node {\n         if args.is_empty() {\n-            if let ExprPath(ref path) = pathexp.node {\n+            if let ExprKind::Path(ref path) = pathexp.node {\n                 return match_qpath(path, &paths::PTR_NULL) || match_qpath(path, &paths::PTR_NULL_MUT);\n             }\n         }"}, {"sha": "e6d231af14833d38127d70c480b88280c28b397a", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -52,8 +52,8 @@ impl QuestionMarkPass {\n     /// If it matches, it will suggest to use the question mark operator instead\n     fn check_is_none_and_early_return_none(cx: &LateContext, expr: &Expr) {\n         if_chain! {\n-            if let ExprIf(ref if_expr, ref body, _) = expr.node;\n-            if let ExprMethodCall(ref segment, _, ref args) = if_expr.node;\n+            if let ExprKind::If(ref if_expr, ref body, _) = expr.node;\n+            if let ExprKind::MethodCall(ref segment, _, ref args) = if_expr.node;\n             if segment.ident.name == \"is_none\";\n             if Self::expression_returns_none(cx, body);\n             if let Some(subject) = args.get(0);\n@@ -87,17 +87,17 @@ impl QuestionMarkPass {\n \n     fn expression_returns_none(cx: &LateContext, expression: &Expr) -> bool {\n         match expression.node {\n-            ExprBlock(ref block, _) => {\n+            ExprKind::Block(ref block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {\n                     return Self::expression_returns_none(cx, &return_expression);\n                 }\n \n                 false\n             },\n-            ExprRet(Some(ref expr)) => {\n+            ExprKind::Ret(Some(ref expr)) => {\n                 Self::expression_returns_none(cx, expr)\n             },\n-            ExprPath(ref qp) => {\n+            ExprKind::Path(ref qp) => {\n                 if let Def::VariantCtor(def_id, _) = cx.tables.qpath_def(qp, expression.hir_id) {\n                     return match_def_path(cx.tcx, def_id,  &OPTION_NONE);\n                 }\n@@ -114,7 +114,7 @@ impl QuestionMarkPass {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n             if let StmtSemi(ref expr, _) = expr.node;\n-            if let ExprRet(ref ret_expr) = expr.node;\n+            if let ExprKind::Ret(ref ret_expr) = expr.node;\n             if let &Some(ref ret_expr) = ret_expr;\n \n             then {"}, {"sha": "e33e112f05115b37a6851fbe506723584d737b29", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -88,7 +88,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprMethodCall(ref path, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n             let name = path.ident.as_str();\n \n             // Range with step_by(0).\n@@ -107,17 +107,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let zip_arg = &args[1];\n                 if_chain! {\n                     // .iter() call\n-                    if let ExprMethodCall(ref iter_path, _, ref iter_args ) = *iter;\n+                    if let ExprKind::MethodCall(ref iter_path, _, ref iter_args ) = *iter;\n                     if iter_path.ident.name == \"iter\";\n                     // range expression in .zip() call: 0..x.len()\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_literal(start, 0);\n                     // .len() call\n-                    if let ExprMethodCall(ref len_path, _, ref len_args) = end.node;\n+                    if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.node;\n                     if len_path.ident.name == \"len\" && len_args.len() == 1;\n                     // .iter() and .len() called on same Path\n-                    if let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n-                    if let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n+                    if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n+                    if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n                     if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n                      then {\n                          span_lint(cx,\n@@ -184,7 +184,7 @@ fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n \n fn y_plus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprBinary(Spanned { node: BiAdd, .. }, ref lhs, ref rhs) => if is_integer_literal(lhs, 1) {\n+        ExprKind::Binary(Spanned { node: BiAdd, .. }, ref lhs, ref rhs) => if is_integer_literal(lhs, 1) {\n             Some(rhs)\n         } else if is_integer_literal(rhs, 1) {\n             Some(lhs)\n@@ -197,7 +197,7 @@ fn y_plus_one(expr: &Expr) -> Option<&Expr> {\n \n fn y_minus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprBinary(Spanned { node: BiSub, .. }, ref lhs, ref rhs) if is_integer_literal(rhs, 1) => Some(lhs),\n+        ExprKind::Binary(Spanned { node: BiSub, .. }, ref lhs, ref rhs) if is_integer_literal(rhs, 1) => Some(lhs),\n         _ => None,\n     }\n }"}, {"sha": "d179bffd59adebb3b999f51f2e74440efd0213c7", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantFieldNames {\n             return;\n         }\n \n-        if let ExprStruct(_, ref fields, _) = expr.node {\n+        if let ExprKind::Struct(_, ref fields, _) = expr.node {\n             for field in fields {\n                 let name = field.ident.name;\n "}, {"sha": "fbead26a03b0b55d67090cf2d6431512dccdc8ec", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -108,8 +108,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref fun, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = fun.node;\n+            if let ExprKind::Call(ref fun, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = fun.node;\n             if args.len() == 1;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, fun.hir_id));\n             then {\n@@ -176,8 +176,8 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n \n fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprArray(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Array(ref exprs) = expr.node;\n         then {\n             for expr in exprs {\n                 check_regex(cx, expr, utf8);\n@@ -192,7 +192,7 @@ fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: boo\n         .allow_invalid_utf8(!utf8)\n         .build();\n \n-    if let ExprLit(ref lit) = expr.node {\n+    if let ExprKind::Lit(ref lit) = expr.node {\n         if let LitKind::Str(ref r, style) = lit.node {\n             let r = &r.as_str();\n             let offset = if let StrStyle::Raw(n) = style { 2 + n } else { 1 };"}, {"sha": "f149e3248772755bfaf848a4399bf8ca26a45a6e", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -37,7 +37,7 @@ impl LintPass for ReplaceConsts {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if_chain! {\n-            if let hir::ExprPath(ref qp) = expr.node;\n+            if let hir::ExprKind::Path(ref qp) = expr.node;\n             if let Def::Const(def_id) = cx.tables.qpath_def(qp, expr.hir_id);\n             then {\n                 for &(const_path, repl_snip) in REPLACEMENTS {"}, {"sha": "cbcdbf73e335f2eb51c7370da7235833162aa1cc", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -185,7 +185,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Struct(_, ref pfields, _) => if let Some(init_struct) = init {\n-            if let ExprStruct(_, ref efields, _) = init_struct.node {\n+            if let ExprKind::Struct(_, ref efields, _) = init_struct.node {\n                 for field in pfields {\n                     let name = field.node.ident.name;\n                     let efield = efields\n@@ -205,7 +205,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Tuple(ref inner, _) => if let Some(init_tup) = init {\n-            if let ExprTup(ref tup) = init_tup.node {\n+            if let ExprKind::Tup(ref tup) = init_tup.node {\n                 for (i, p) in inner.iter().enumerate() {\n                     check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                 }\n@@ -220,7 +220,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Box(ref inner) => if let Some(initp) = init {\n-            if let ExprBox(ref inner_init) = initp.node {\n+            if let ExprKind::Box(ref inner_init) = initp.node {\n                 check_pat(cx, inner, Some(&**inner_init), span, bindings);\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n@@ -306,27 +306,27 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n         return;\n     }\n     match expr.node {\n-        ExprUnary(_, ref e) | ExprField(ref e, _) | ExprAddrOf(_, ref e) | ExprBox(ref e) => {\n+        ExprKind::Unary(_, ref e) | ExprKind::Field(ref e, _) | ExprKind::AddrOf(_, ref e) | ExprKind::Box(ref e) => {\n             check_expr(cx, e, bindings)\n         },\n-        ExprBlock(ref block, _) | ExprLoop(ref block, _, _) => check_block(cx, block, bindings),\n-        // ExprCall\n-        // ExprMethodCall\n-        ExprArray(ref v) | ExprTup(ref v) => for e in v {\n+        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, _, _) => check_block(cx, block, bindings),\n+        // ExprKind::Call\n+        // ExprKind::MethodCall\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => for e in v {\n             check_expr(cx, e, bindings)\n         },\n-        ExprIf(ref cond, ref then, ref otherwise) => {\n+        ExprKind::If(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n             check_expr(cx, &**then, bindings);\n             if let Some(ref o) = *otherwise {\n                 check_expr(cx, o, bindings);\n             }\n         },\n-        ExprWhile(ref cond, ref block, _) => {\n+        ExprKind::While(ref cond, ref block, _) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, block, bindings);\n         },\n-        ExprMatch(ref init, ref arms, _) => {\n+        ExprKind::Match(ref init, ref arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n             for arm in arms {\n@@ -363,16 +363,16 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n \n fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBox(ref inner) | ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n-        ExprBlock(ref block, _) => {\n+        ExprKind::Box(ref inner) | ExprKind::AddrOf(_, ref inner) => is_self_shadow(name, inner),\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty()\n                 && block\n                     .expr\n                     .as_ref()\n                     .map_or(false, |e| is_self_shadow(name, e))\n         },\n-        ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n-        ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n+        ExprKind::Unary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n+        ExprKind::Path(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n         _ => false,\n     }\n }"}, {"sha": "fb9becbd43bd76a822d14952788e6a764f89b16a", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -82,12 +82,12 @@ impl LintPass for StringAdd {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if !is_allowed(cx, STRING_ADD_ASSIGN, e.id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n-                        if let ExprAssign(ref target, _) = p.node {\n+                        if let ExprKind::Assign(ref target, _) = p.node {\n                             // avoid duplicate matches\n                             if SpanlessEq::new(cx).eq_expr(target, left) {\n                                 return;\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n                     \"you added something to a string. Consider using `String::push_str()` instead\",\n                 );\n             }\n-        } else if let ExprAssign(ref target, ref src) = e.node {\n+        } else if let ExprKind::Assign(ref target, ref src) = e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(\n                     cx,\n@@ -122,8 +122,8 @@ fn is_string(cx: &LateContext, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n-        ExprBlock(ref block, _) => {\n+        ExprKind::Binary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty()\n                 && block\n                     .expr\n@@ -148,9 +148,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use syntax::ast::LitKind;\n         use crate::utils::{in_macro, snippet};\n \n-        if let ExprMethodCall(ref path, _, ref args) = e.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = e.node {\n             if path.ident.name == \"as_bytes\" {\n-                if let ExprLit(ref lit) = args[0].node {\n+                if let ExprKind::Lit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {\n                             span_lint_and_sugg("}, {"sha": "a3342591a1bd092f362817a7fa3732d5fbc9ed06", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -60,7 +60,7 @@ impl LintPass for SuspiciousImpl {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         use rustc::hir::BinOp_::*;\n-        if let hir::ExprBinary(binop, _, _) = expr.node {\n+        if let hir::ExprKind::Binary(binop, _, _) = expr.node {\n             match binop.node {\n                 BiEq | BiLt | BiLe | BiNe | BiGe | BiGt => return,\n                 _ => {},\n@@ -71,9 +71,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             while parent_expr != ast::CRATE_NODE_ID {\n                 if let hir::map::Node::NodeExpr(e) = cx.tcx.hir.get(parent_expr) {\n                     match e.node {\n-                        hir::ExprBinary(..)\n-                        | hir::ExprUnary(hir::UnOp::UnNot, _)\n-                        | hir::ExprUnary(hir::UnOp::UnNeg, _) => return,\n+                        hir::ExprKind::Binary(..)\n+                        | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n+                        | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => return,\n                         _ => {},\n                     }\n                 }\n@@ -185,9 +185,9 @@ struct BinaryExprVisitor {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for BinaryExprVisitor {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBinary(..)\n-            | hir::ExprUnary(hir::UnOp::UnNot, _)\n-            | hir::ExprUnary(hir::UnOp::UnNeg, _) => {\n+            hir::ExprKind::Binary(..)\n+            | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n+            | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => {\n                 self.in_binary_expr = true\n             },\n             _ => {},"}, {"sha": "7a124e59a6e820e8ed955c4372a4369a8ca02fb4", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -68,12 +68,12 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n \n             // foo() = bar();\n             if let StmtSemi(ref first, _) = w[1].node;\n-            if let ExprAssign(ref lhs1, ref rhs1) = first.node;\n+            if let ExprKind::Assign(ref lhs1, ref rhs1) = first.node;\n \n             // bar() = t;\n             if let StmtSemi(ref second, _) = w[2].node;\n-            if let ExprAssign(ref lhs2, ref rhs2) = second.node;\n-            if let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n+            if let ExprKind::Assign(ref lhs2, ref rhs2) = second.node;\n+            if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n             if rhs2.segments.len() == 1;\n \n             if ident.as_str() == rhs2.segments[0].ident.as_str();\n@@ -85,8 +85,8 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                     lhs1: &'a Expr,\n                     lhs2: &'a Expr,\n                 ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n-                    if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n-                        if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n+                    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.node {\n+                        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.node {\n                             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n                                 let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n \n@@ -148,8 +148,8 @@ fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n             if let StmtSemi(ref first, _) = w[0].node;\n             if let StmtSemi(ref second, _) = w[1].node;\n             if !differing_macro_contexts(first.span, second.span);\n-            if let ExprAssign(ref lhs0, ref rhs0) = first.node;\n-            if let ExprAssign(ref lhs1, ref rhs1) = second.node;\n+            if let ExprKind::Assign(ref lhs0, ref rhs0) = first.node;\n+            if let ExprKind::Assign(ref lhs1, ref rhs1) = second.node;\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n             then {"}, {"sha": "008ab56bda8407906cc85253f418333e23a97892", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::hir::{Expr, ExprAssign, ExprField, ExprStruct, ExprTup};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::is_adjusted;\n use crate::utils::span_lint;\n \n@@ -23,7 +23,7 @@ declare_clippy_lint! {\n \n fn is_temporary(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprStruct(..) | ExprTup(..) => true,\n+        ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n         _ => false,\n     }\n }\n@@ -39,8 +39,8 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprAssign(ref target, _) = expr.node {\n-            if let ExprField(ref base, _) = target.node {\n+        if let ExprKind::Assign(ref target, _) = expr.node {\n+            if let ExprKind::Field(ref base, _) = target.node {\n                 if is_temporary(base) && !is_adjusted(cx, base) {\n                     span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                 }"}, {"sha": "9d3055c3e639e998dc401eddef3eecb82f8c16db", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -215,8 +215,8 @@ impl LintPass for Transmute {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(ref qpath) = path_expr.node {\n+        if let ExprKind::Call(ref path_expr, ref args) = e.node {\n+            if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n                         let from_ty = cx.tables.expr_ty(&args[0]);"}, {"sha": "6c7c62c741ab5cfea76674810d9c68525a722db9", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -446,7 +446,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         if in_macro(expr.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, _) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() && is_unit(cx.tables.expr_ty(left)) {\n                 let result = match op {\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n             return;\n         }\n         match expr.node {\n-            ExprCall(_, ref args) | ExprMethodCall(_, _, ref args) => {\n+            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n                 for arg in args {\n                     if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n                         let map = &cx.tcx.hir;\n@@ -539,7 +539,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n \n fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n     use syntax_pos::hygiene::CompilerDesugaringKind;\n-    if let ExprCall(ref callee, _) = expr.node {\n+    if let ExprKind::Call(ref callee, _) = expr.node {\n         callee.span.is_compiler_desugaring(CompilerDesugaringKind::QuestionMark)\n     } else {\n         false\n@@ -555,7 +555,7 @@ fn is_unit(ty: Ty) -> bool {\n \n fn is_unit_literal(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprTup(ref slice) if slice.is_empty() => true,\n+        ExprKind::Tup(ref slice) if slice.is_empty() => true,\n         _ => false,\n     }\n }\n@@ -812,7 +812,7 @@ fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_t\n }\n \n fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n-    if let ExprBinary(_, _, _) = op.node {\n+    if let ExprKind::Binary(_, _, _) = op.node {\n         if snip.starts_with('(') && snip.ends_with(')') {\n             return true;\n         }\n@@ -951,9 +951,9 @@ impl LintPass for CastPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprCast(ref ex, _) = expr.node {\n+        if let ExprKind::Cast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n-            if let ExprLit(ref lit) = ex.node {\n+            if let ExprKind::Lit(ref lit) = ex.node {\n                 use syntax::ast::{LitIntType, LitKind};\n                 match lit.node {\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::FloatUnsuffixed(_) => {},\n@@ -1289,8 +1289,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use syntax::ast::{LitKind, UintTy};\n \n-        if let ExprCast(ref e, _) = expr.node {\n-            if let ExprLit(ref l) = e.node {\n+        if let ExprKind::Cast(ref e, _) = expr.node {\n+            if let ExprKind::Lit(ref l) = e.node {\n                 if let LitKind::Char(_) = l.node {\n                     if ty::TyUint(UintTy::U8) == cx.tables.expr_ty(expr).sty && !in_macro(expr.span) {\n                         let msg = \"casting character literal to u8. `char`s \\\n@@ -1362,7 +1362,7 @@ fn is_cast_between_fixed_and_target<'a, 'tcx>(\n     expr: &'tcx Expr\n ) -> bool {\n \n-    if let ExprCast(ref cast_exp, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n         let precast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n \n@@ -1453,7 +1453,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n         use crate::types::ExtremeType::*;\n         use crate::types::AbsurdComparisonResult::*;\n \n-        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n             if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n                 if !in_macro(expr.span) {\n                     let msg = \"this comparison involving the minimum or maximum element for this \\\n@@ -1564,7 +1564,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n-    if let ExprCast(ref cast_exp, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n         let pre_cast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n         // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n@@ -1627,7 +1627,7 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n }\n \n fn err_upcast_comparison(cx: &LateContext, span: Span, expr: &Expr, always: bool) {\n-    if let ExprCast(ref cast_val, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_val, _) = expr.node {\n         span_lint(\n             cx,\n             INVALID_UPCAST_COMPARISONS,\n@@ -1693,7 +1693,7 @@ fn upcast_comparison_bounds_err<'a, 'tcx>(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n             let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n                 val\n@@ -1984,8 +1984,8 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n \n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref fun, ref args) = e.node;\n-            if let ExprPath(QPath::TypeRelative(ref ty, ref method)) = fun.node;\n+            if let ExprKind::Call(ref fun, ref args) = e.node;\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.node;\n             if let TyPath(QPath::Resolved(None, ref ty_path)) = ty.node;\n             then {\n                 if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {"}, {"sha": "ddd9db9eda3a0e1412e6d2468a82e7ba53d27d9b", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -71,7 +71,7 @@ impl LintPass for Unicode {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprLit(ref lit) = expr.node {\n+        if let ExprKind::Lit(ref lit) = expr.node {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span, expr.id)\n             }"}, {"sha": "e699253efaa3fd5c8d286e1d03ed538189366a94", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -45,9 +45,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n         };\n \n         match expr.node {\n-            hir::ExprMatch(ref res, _, _) if is_try(expr).is_some() => {\n-                if let hir::ExprCall(ref func, ref args) = res.node {\n-                    if let hir::ExprPath(ref path) = func.node {\n+            hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n+                if let hir::ExprKind::Call(ref func, ref args) = res.node {\n+                    if let hir::ExprKind::Path(ref path) = func.node {\n                         if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n                             check_method_call(cx, &args[0], expr);\n                         }\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprMethodCall(ref path, _, ref args) => match &*path.ident.as_str() {\n+            hir::ExprKind::MethodCall(ref path, _, ref args) => match &*path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_method_call(cx, &args[0], expr);\n                 },\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n }\n \n fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n-    if let hir::ExprMethodCall(ref path, _, _) = call.node {\n+    if let hir::ExprKind::MethodCall(ref path, _, _) = call.node {\n         let symbol = &*path.ident.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {\n             span_lint("}, {"sha": "0ae956b9443e8dc543d4c807375c355d0086a7d5", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -69,10 +69,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBreak(destination, _) | hir::ExprContinue(destination) => if let Some(label) = destination.label {\n+            hir::ExprKind::Break(destination, _) | hir::ExprKind::Continue(destination) => if let Some(label) = destination.label {\n                 self.labels.remove(&label.ident.as_str());\n             },\n-            hir::ExprLoop(_, Some(label), _) | hir::ExprWhile(_, _, Some(label)) => {\n+            hir::ExprKind::Loop(_, Some(label), _) | hir::ExprKind::While(_, _, Some(label)) => {\n                 self.labels.insert(label.ident.as_str(), expr.span);\n             },\n             _ => (),"}, {"sha": "f9faa3b48f77ca6aabb125d7e4d5f4e8610dbb89", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -78,7 +78,7 @@ fn collect_unwrap_info<'a, 'tcx: 'a>(\n     expr: &'tcx Expr,\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n-    if let Expr_::ExprBinary(op, left, right) = &expr.node {\n+    if let ExprKind::Binary(op, left, right) = &expr.node {\n         match (invert, op.node) {\n             (false, BinOp_::BiAnd) | (false, BinOp_::BiBitAnd) | (true, BinOp_::BiOr) | (true, BinOp_::BiBitOr) => {\n                 let mut unwrap_info = collect_unwrap_info(cx, left, invert);\n@@ -87,12 +87,12 @@ fn collect_unwrap_info<'a, 'tcx: 'a>(\n             },\n             _ => (),\n         }\n-    } else if let Expr_::ExprUnary(UnNot, expr) = &expr.node {\n+    } else if let ExprKind::Unary(UnNot, expr) = &expr.node {\n         return collect_unwrap_info(cx, expr, !invert);\n     } else {\n         if_chain! {\n-            if let Expr_::ExprMethodCall(method_name, _, args) = &expr.node;\n-            if let Expr_::ExprPath(QPath::Resolved(None, path)) = &args[0].node;\n+            if let ExprKind::MethodCall(method_name, _, args) = &expr.node;\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].node;\n             let ty = cx.tables.expr_ty(&args[0]);\n             if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n             let name = method_name.ident.as_str();\n@@ -131,7 +131,7 @@ impl<'a, 'tcx: 'a> UnwrappableVariablesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let Expr_::ExprIf(cond, then, els) = &expr.node {\n+        if let ExprKind::If(cond, then, els) = &expr.node {\n             walk_expr(self, cond);\n             self.visit_branch(cond, then, false);\n             if let Some(els) = els {\n@@ -140,8 +140,8 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let Expr_::ExprMethodCall(ref method_name, _, ref args) = expr.node;\n-                if let Expr_::ExprPath(QPath::Resolved(None, ref path)) = args[0].node;\n+                if let ExprKind::MethodCall(ref method_name, _, ref args) = expr.node;\n+                if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].node;\n                 if [\"unwrap\", \"unwrap_err\"].contains(&&*method_name.ident.as_str());\n                 let call_to_unwrap = method_name.ident.name == \"unwrap\";\n                 if let Some(unwrappable) = self.unwrappables.iter()"}, {"sha": "42beb971bef7b508668551211e0ba4e6452b4ba0", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -5,7 +5,7 @@\n \n use rustc::lint::*;\n use rustc::hir;\n-use rustc::hir::{Expr, Expr_, QPath, Ty_, Pat, PatKind, BindingAnnotation, StmtSemi, StmtExpr, StmtDecl, Decl_, Stmt};\n+use rustc::hir::{Expr, ExprKind, QPath, TyKind, Pat, PatKind, BindingAnnotation, StmtKind, DeclKind, Stmt};\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use syntax::ast::{Attribute, LitKind, DUMMY_NODE_ID};\n use std::collections::HashMap;\n@@ -32,10 +32,10 @@ use crate::utils::get_attr;\n /// ```rust\n /// // ./tests/ui/new_lint.stdout\n /// if_chain!{\n-///     if let Expr_::ExprIf(ref cond, ref then, None) = item.node,\n-///     if let Expr_::ExprBinary(BinOp::Eq, ref left, ref right) = cond.node,\n-///     if let Expr_::ExprPath(ref path) = left.node,\n-///     if let Expr_::ExprLit(ref lit) = right.node,\n+///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n+///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n+///     if let ExprKind::Path(ref path) = left.node,\n+///     if let ExprKind::Lit(ref lit) = right.node,\n ///     if let LitKind::Int(42, _) = lit.node,\n ///     then {\n ///         // report your lint here\n@@ -192,16 +192,16 @@ struct PrintVisitor {\n \n impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     fn visit_expr(&mut self, expr: &Expr) {\n-        print!(\"    if let Expr_::Expr\");\n+        print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.node\", self.current);\n         match expr.node {\n-            Expr_::ExprBox(ref inner) => {\n+            ExprKind::Box(ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprArray(ref elements) => {\n+            ExprKind::Array(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Array(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -210,7 +210,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            Expr_::ExprCall(ref func, ref args) => {\n+            ExprKind::Call(ref func, ref args) => {\n                 let func_pat = self.next(\"func\");\n                 let args_pat = self.next(\"args\");\n                 println!(\"Call(ref {}, ref {}) = {};\", func_pat, args_pat, current);\n@@ -222,11 +222,11 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(arg);\n                 }\n             },\n-            Expr_::ExprMethodCall(ref _method_name, ref _generics, ref _args) => {\n+            ExprKind::MethodCall(ref _method_name, ref _generics, ref _args) => {\n                 println!(\"MethodCall(ref method_name, ref generics, ref args) = {};\", current);\n-                println!(\"    // unimplemented: `ExprMethodCall` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment\");\n             },\n-            Expr_::ExprTup(ref elements) => {\n+            ExprKind::Tup(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Tup(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -235,7 +235,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            Expr_::ExprBinary(ref op, ref left, ref right) => {\n+            ExprKind::Binary(ref op, ref left, ref right) => {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n@@ -246,13 +246,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = right_pat;\n                 self.visit_expr(right);\n             },\n-            Expr_::ExprUnary(ref op, ref inner) => {\n+            ExprKind::Unary(ref op, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprLit(ref lit) => {\n+            ExprKind::Lit(ref lit) => {\n                 let lit_pat = self.next(\"lit\");\n                 println!(\"Lit(ref {}) = {};\", lit_pat, current);\n                 match lit.node {\n@@ -277,7 +277,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     },\n                 }\n             },\n-            Expr_::ExprCast(ref expr, ref ty) => {\n+            ExprKind::Cast(ref expr, ref ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 let cast_ty = self.next(\"cast_ty\");\n                 let qp_label = self.next(\"qp\");\n@@ -291,13 +291,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            Expr_::ExprType(ref expr, ref _ty) => {\n+            ExprKind::Type(ref expr, ref _ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            Expr_::ExprIf(ref cond, ref then, ref opt_else) => {\n+            ExprKind::If(ref cond, ref then, ref opt_else) => {\n                 let cond_pat = self.next(\"cond\");\n                 let then_pat = self.next(\"then\");\n                 if let Some(ref else_) = *opt_else {\n@@ -313,7 +313,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = then_pat;\n                 self.visit_expr(then);\n             },\n-            Expr_::ExprWhile(ref cond, ref body, _) => {\n+            ExprKind::While(ref cond, ref body, _) => {\n                 let cond_pat = self.next(\"cond\");\n                 let body_pat = self.next(\"body\");\n                 let label_pat = self.next(\"label\");\n@@ -323,15 +323,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            Expr_::ExprLoop(ref body, _, desugaring) => {\n+            ExprKind::Loop(ref body, _, desugaring) => {\n                 let body_pat = self.next(\"body\");\n                 let des = loop_desugaring_name(desugaring);\n                 let label_pat = self.next(\"label\");\n                 println!(\"Loop(ref {}, ref {}, {}) = {};\", body_pat, label_pat, des, current);\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            Expr_::ExprMatch(ref expr, ref arms, desugaring) => {\n+            ExprKind::Match(ref expr, ref arms, desugaring) => {\n                 let des = desugaring_name(desugaring);\n                 let expr_pat = self.next(\"expr\");\n                 let arms_pat = self.next(\"arms\");\n@@ -355,23 +355,23 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     }\n                 }\n             },\n-            Expr_::ExprClosure(ref _capture_clause, ref _func, _, _, _) => {\n+            ExprKind::Closure(ref _capture_clause, ref _func, _, _, _) => {\n                 println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n-                println!(\"    // unimplemented: `ExprClosure` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::Closure` is not further destructured at the moment\");\n             },\n-            Expr_::ExprYield(ref sub) => {\n+            ExprKind::Yield(ref sub) => {\n                 let sub_pat = self.next(\"sub\");\n                 println!(\"Yield(ref sub) = {};\", current);\n                 self.current = sub_pat;\n                 self.visit_expr(sub);\n             },\n-            Expr_::ExprBlock(ref block, _) => {\n+            ExprKind::Block(ref block, _) => {\n                 let block_pat = self.next(\"block\");\n                 println!(\"Block(ref {}) = {};\", block_pat, current);\n                 self.current = block_pat;\n                 self.visit_block(block);\n             },\n-            Expr_::ExprAssign(ref target, ref value) => {\n+            ExprKind::Assign(ref target, ref value) => {\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n                 println!(\"Assign(ref {}, ref {}) = {};\", target_pat, value_pat, current);\n@@ -380,7 +380,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            Expr_::ExprAssignOp(ref op, ref target, ref value) => {\n+            ExprKind::AssignOp(ref op, ref target, ref value) => {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n@@ -391,15 +391,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            Expr_::ExprField(ref object, ref field_ident) => {\n+            ExprKind::Field(ref object, ref field_ident) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n                 println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n                 println!(\"    if {}.node.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n-            Expr_::ExprIndex(ref object, ref index) => {\n+            ExprKind::Index(ref object, ref index) => {\n                 let object_pat = self.next(\"object\");\n                 let index_pat = self.next(\"index\");\n                 println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n@@ -408,19 +408,19 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = index_pat;\n                 self.visit_expr(index);\n             },\n-            Expr_::ExprPath(ref path) => {\n+            ExprKind::Path(ref path) => {\n                 let path_pat = self.next(\"path\");\n                 println!(\"Path(ref {}) = {};\", path_pat, current);\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n-            Expr_::ExprAddrOf(mutability, ref inner) => {\n+            ExprKind::AddrOf(mutability, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"AddrOf({:?}, ref {}) = {};\", mutability, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprBreak(ref _destination, ref opt_value) => {\n+            ExprKind::Break(ref _destination, ref opt_value) => {\n                 let destination_pat = self.next(\"destination\");\n                 if let Some(ref value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n@@ -432,24 +432,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 }\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprContinue(ref _destination) => {\n+            ExprKind::Continue(ref _destination) => {\n                 let destination_pat = self.next(\"destination\");\n                 println!(\"Again(ref {}) = {};\", destination_pat, current);\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprRet(ref opt_value) => if let Some(ref value) = *opt_value {\n+            ExprKind::Ret(ref opt_value) => if let Some(ref value) = *opt_value {\n                 let value_pat = self.next(\"value\");\n                 println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             } else {\n                 println!(\"Ret(None) = {};\", current);\n             },\n-            Expr_::ExprInlineAsm(_, ref _input, ref _output) => {\n+            ExprKind::InlineAsm(_, ref _input, ref _output) => {\n                 println!(\"InlineAsm(_, ref input, ref output) = {};\", current);\n-                println!(\"    // unimplemented: `ExprInlineAsm` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::InlineAsm` is not further destructured at the moment\");\n             },\n-            Expr_::ExprStruct(ref path, ref fields, ref opt_base) => {\n+            ExprKind::Struct(ref path, ref fields, ref opt_base) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n                 if let Some(ref base) = *opt_base {\n@@ -472,7 +472,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"    // unimplemented: field checks\");\n             },\n             // FIXME: compute length (needs type info)\n-            Expr_::ExprRepeat(ref value, _) => {\n+            ExprKind::Repeat(ref value, _) => {\n                 let value_pat = self.next(\"value\");\n                 println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n                 println!(\"// unimplemented: repeat count check\");"}, {"sha": "74f476f55e3461dc2a7737182f8dc23a1f963dd9", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -11,24 +11,24 @@ use crate::utils::{is_expn_of, match_def_path, match_qpath, opt_def_id, paths, r\n /// Convert a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n     match op {\n-        hir::BiEq => ast::BinOpKind::Eq,\n-        hir::BiGe => ast::BinOpKind::Ge,\n-        hir::BiGt => ast::BinOpKind::Gt,\n-        hir::BiLe => ast::BinOpKind::Le,\n-        hir::BiLt => ast::BinOpKind::Lt,\n-        hir::BiNe => ast::BinOpKind::Ne,\n-        hir::BiOr => ast::BinOpKind::Or,\n-        hir::BiAdd => ast::BinOpKind::Add,\n-        hir::BiAnd => ast::BinOpKind::And,\n-        hir::BiBitAnd => ast::BinOpKind::BitAnd,\n-        hir::BiBitOr => ast::BinOpKind::BitOr,\n-        hir::BiBitXor => ast::BinOpKind::BitXor,\n-        hir::BiDiv => ast::BinOpKind::Div,\n-        hir::BiMul => ast::BinOpKind::Mul,\n-        hir::BiRem => ast::BinOpKind::Rem,\n-        hir::BiShl => ast::BinOpKind::Shl,\n-        hir::BiShr => ast::BinOpKind::Shr,\n-        hir::BiSub => ast::BinOpKind::Sub,\n+        hir::BinOpKind::Eq => ast::BinOpKind::Eq,\n+        hir::BinOpKind::Ge => ast::BinOpKind::Ge,\n+        hir::BinOpKind::Gt => ast::BinOpKind::Gt,\n+        hir::BinOpKind::Le => ast::BinOpKind::Le,\n+        hir::BinOpKind::Lt => ast::BinOpKind::Lt,\n+        hir::BinOpKind::Ne => ast::BinOpKind::Ne,\n+        hir::BinOpKind::Or => ast::BinOpKind::Or,\n+        hir::BinOpKind::Add => ast::BinOpKind::Add,\n+        hir::BinOpKind::And => ast::BinOpKind::And,\n+        hir::BinOpKind::BitAnd => ast::BinOpKind::BitAnd,\n+        hir::BinOpKind::BitOr => ast::BinOpKind::BitOr,\n+        hir::BinOpKind::BitXor => ast::BinOpKind::BitXor,\n+        hir::BinOpKind::Div => ast::BinOpKind::Div,\n+        hir::BinOpKind::Mul => ast::BinOpKind::Mul,\n+        hir::BinOpKind::Rem => ast::BinOpKind::Rem,\n+        hir::BinOpKind::Shl => ast::BinOpKind::Shl,\n+        hir::BinOpKind::Shr => ast::BinOpKind::Shr,\n+        hir::BinOpKind::Sub => ast::BinOpKind::Sub,\n     }\n }\n \n@@ -87,7 +87,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n     // `#[no_std]`. Testing both instead of resolving the paths.\n \n     match expr.node {\n-        hir::ExprPath(ref path) => {\n+        hir::ExprKind::Path(ref path) => {\n             if match_qpath(path, &paths::RANGE_FULL_STD) || match_qpath(path, &paths::RANGE_FULL) {\n                 Some(Range {\n                     start: None,\n@@ -98,7 +98,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n                 None\n             }\n         },\n-        hir::ExprCall(ref path, ref args) => if let hir::ExprPath(ref path) = path.node {\n+        hir::ExprKind::Call(ref path, ref args) => if let hir::ExprKind::Path(ref path) = path.node {\n             if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW) || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW) {\n                 Some(Range {\n                     start: Some(&args[0]),\n@@ -111,7 +111,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n         } else {\n             None\n         },\n-        hir::ExprStruct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD)\n+        hir::ExprKind::Struct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD)\n             || match_qpath(path, &paths::RANGE_FROM)\n         {\n             Some(Range {\n@@ -156,7 +156,7 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     if_chain! {\n         if let hir::DeclLocal(ref loc) = decl.node;\n         if let Some(ref expr) = loc.init;\n-        if let hir::ExprMatch(_, _, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.node;\n         then {\n             return true;\n         }\n@@ -185,10 +185,10 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)> {\n     if_chain! {\n-        if let hir::ExprMatch(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node;\n-        if let hir::ExprCall(_, ref iterargs) = iterexpr.node;\n+        if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.node;\n         if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprLoop(ref block, _, _) = arms[0].body.node;\n+        if let hir::ExprKind::Loop(ref block, _, _) = arms[0].body.node;\n         if block.expr.is_none();\n         if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n         if let hir::StmtDecl(ref decl, _) = let_stmt.node;\n@@ -213,8 +213,8 @@ pub enum VecArgs<'a> {\n /// from `vec!`.\n pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_chain! {\n-        if let hir::ExprCall(ref fun, ref args) = expr.node;\n-        if let hir::ExprPath(ref path) = fun.node;\n+        if let hir::ExprKind::Call(ref fun, ref args) = expr.node;\n+        if let hir::ExprKind::Path(ref path) = fun.node;\n         if is_expn_of(fun.span, \"vec\").is_some();\n         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, path, fun.hir_id));\n         then {\n@@ -225,8 +225,8 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n             else if match_def_path(cx.tcx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                 // `vec![a, b, c]` case\n                 if_chain! {\n-                    if let hir::ExprBox(ref boxed) = args[0].node;\n-                    if let hir::ExprArray(ref args) = boxed.node;\n+                    if let hir::ExprKind::Box(ref boxed) = args[0].node;\n+                    if let hir::ExprKind::Array(ref args) = boxed.node;\n                     then {\n                         return Some(VecArgs::Vec(&*args));\n                     }"}, {"sha": "6d3d1eeb9fe878713c3280195f40e72cbf34614c", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -75,69 +75,69 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n \n         match (&left.node, &right.node) {\n-            (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprContinue(li), &ExprContinue(ri)) => {\n+            (&ExprKind::AddrOf(l_mut, ref le), &ExprKind::AddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n+            (&ExprKind::Continue(li), &ExprKind::Continue(ri)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n-            (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n-            (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n+            (&ExprKind::Assign(ref ll, ref lr), &ExprKind::Assign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n+            (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n-            (&ExprBlock(ref l, _), &ExprBlock(ref r, _)) => self.eq_block(l, r),\n-            (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n+            (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n+            (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     || swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                         l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     })\n             },\n-            (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) => {\n+            (&ExprKind::Break(li, ref le), &ExprKind::Break(ri, ref re)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n-            (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n+            (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n+            (&ExprKind::Call(ref l_fun, ref l_args), &ExprKind::Call(ref r_fun, ref r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) |\n-            (&ExprType(ref lx, ref lt), &ExprType(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n-            (&ExprField(ref l_f_exp, ref l_f_ident), &ExprField(ref r_f_exp, ref r_f_ident)) => {\n+            (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt)) |\n+            (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n+            (&ExprKind::Field(ref l_f_exp, ref l_f_ident), &ExprKind::Field(ref r_f_exp, ref r_f_ident)) => {\n                 l_f_ident.name == r_f_ident.name && self.eq_expr(l_f_exp, r_f_exp)\n             },\n-            (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n-            (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n+            (&ExprKind::Index(ref la, ref li), &ExprKind::Index(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n+            (&ExprKind::If(ref lc, ref lt, ref le), &ExprKind::If(ref rc, ref rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-            (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n+            (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n+            (&ExprKind::Loop(ref lb, ref ll, ref lls), &ExprKind::Loop(ref rb, ref rl, ref rls)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n-            (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n+            (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) && over(la, ra, |l, r| {\n                     self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r))\n                         && over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             },\n-            (&ExprMethodCall(ref l_path, _, ref l_args), &ExprMethodCall(ref r_path, _, ref r_args)) => {\n+            (&ExprKind::MethodCall(ref l_path, _, ref l_args), &ExprKind::MethodCall(ref r_path, _, ref r_args)) => {\n                 !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprRepeat(ref le, ref ll_id), &ExprRepeat(ref re, ref rl_id)) => {\n+            (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n                 let ll = celcx.expr(&self.cx.tcx.hir.body(ll_id.body).value);\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n                 let rl = celcx.expr(&self.cx.tcx.hir.body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n             },\n-            (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n-            (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n+            (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n+            (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (&ExprKind::Struct(ref l_path, ref lf, ref lo), &ExprKind::Struct(ref r_path, ref rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r))\n                     && over(lf, rf, |l, r| self.eq_field(l, r))\n             },\n-            (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n-            (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n-            (&ExprArray(ref l), &ExprArray(ref r)) => self.eq_exprs(l, r),\n-            (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n+            (&ExprKind::Tup(ref l_tup), &ExprKind::Tup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n+            (&ExprKind::Unary(l_op, ref le), &ExprKind::Unary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n+            (&ExprKind::Array(ref l), &ExprKind::Array(ref r)) => self.eq_exprs(l, r),\n+            (&ExprKind::While(ref lc, ref lb, ref ll), &ExprKind::While(ref rc, ref rb, ref rl)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             _ => false,\n@@ -359,51 +359,51 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         }\n \n         match e.node {\n-            ExprAddrOf(m, ref e) => {\n-                let c: fn(_, _) -> _ = ExprAddrOf;\n+            ExprKind::AddrOf(m, ref e) => {\n+                let c: fn(_, _) -> _ = ExprKind::AddrOf;\n                 c.hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprContinue(i) => {\n-                let c: fn(_) -> _ = ExprContinue;\n+            ExprKind::Continue(i) => {\n+                let c: fn(_) -> _ = ExprKind::Continue;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprYield(ref e) => {\n-                let c: fn(_) -> _ = ExprYield;\n+            ExprKind::Yield(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Yield;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprAssign(ref l, ref r) => {\n-                let c: fn(_, _) -> _ = ExprAssign;\n+            ExprKind::Assign(ref l, ref r) => {\n+                let c: fn(_, _) -> _ = ExprKind::Assign;\n                 c.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprAssignOp(ref o, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprAssignOp;\n+            ExprKind::AssignOp(ref o, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::AssignOp;\n                 c.hash(&mut self.s);\n                 o.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprBlock(ref b, _) => {\n-                let c: fn(_, _) -> _ = ExprBlock;\n+            ExprKind::Block(ref b, _) => {\n+                let c: fn(_, _) -> _ = ExprKind::Block;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n             },\n-            ExprBinary(op, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprBinary;\n+            ExprKind::Binary(op, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Binary;\n                 c.hash(&mut self.s);\n                 op.node.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprBreak(i, ref j) => {\n-                let c: fn(_, _) -> _ = ExprBreak;\n+            ExprKind::Break(i, ref j) => {\n+                let c: fn(_, _) -> _ = ExprKind::Break;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n@@ -412,72 +412,72 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(&*j);\n                 }\n             },\n-            ExprBox(ref e) => {\n-                let c: fn(_) -> _ = ExprBox;\n+            ExprKind::Box(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Box;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprCall(ref fun, ref args) => {\n-                let c: fn(_, _) -> _ = ExprCall;\n+            ExprKind::Call(ref fun, ref args) => {\n+                let c: fn(_, _) -> _ = ExprKind::Call;\n                 c.hash(&mut self.s);\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n-            ExprCast(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprCast;\n+            ExprKind::Cast(ref e, ref _ty) => {\n+                let c: fn(_, _) -> _ = ExprKind::Cast;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n-            ExprClosure(cap, _, eid, _, _) => {\n-                let c: fn(_, _, _, _, _) -> _ = ExprClosure;\n+            ExprKind::Closure(cap, _, eid, _, _) => {\n+                let c: fn(_, _, _, _, _) -> _ = ExprKind::Closure;\n                 c.hash(&mut self.s);\n                 match cap {\n                     CaptureClause::CaptureByValue => 0,\n                     CaptureClause::CaptureByRef => 1,\n                 }.hash(&mut self.s);\n                 self.hash_expr(&self.cx.tcx.hir.body(eid).value);\n             },\n-            ExprField(ref e, ref f) => {\n-                let c: fn(_, _) -> _ = ExprField;\n+            ExprKind::Field(ref e, ref f) => {\n+                let c: fn(_, _) -> _ = ExprKind::Field;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_name(f.name);\n             },\n-            ExprIndex(ref a, ref i) => {\n-                let c: fn(_, _) -> _ = ExprIndex;\n+            ExprKind::Index(ref a, ref i) => {\n+                let c: fn(_, _) -> _ = ExprKind::Index;\n                 c.hash(&mut self.s);\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n             },\n-            ExprInlineAsm(..) => {\n-                let c: fn(_, _, _) -> _ = ExprInlineAsm;\n+            ExprKind::InlineAsm(..) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::InlineAsm;\n                 c.hash(&mut self.s);\n             },\n-            ExprIf(ref cond, ref t, ref e) => {\n-                let c: fn(_, _, _) -> _ = ExprIf;\n+            ExprKind::If(ref cond, ref t, ref e) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::If;\n                 c.hash(&mut self.s);\n                 self.hash_expr(cond);\n                 self.hash_expr(&**t);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprLit(ref l) => {\n-                let c: fn(_) -> _ = ExprLit;\n+            ExprKind::Lit(ref l) => {\n+                let c: fn(_) -> _ = ExprKind::Lit;\n                 c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n             },\n-            ExprLoop(ref b, ref i, _) => {\n-                let c: fn(_, _, _) -> _ = ExprLoop;\n+            ExprKind::Loop(ref b, ref i, _) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Loop;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprMatch(ref e, ref arms, ref s) => {\n-                let c: fn(_, _, _) -> _ = ExprMatch;\n+            ExprKind::Match(ref e, ref arms, ref s) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Match;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n \n@@ -491,35 +491,35 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprMethodCall(ref path, ref _tys, ref args) => {\n-                let c: fn(_, _, _) -> _ = ExprMethodCall;\n+            ExprKind::MethodCall(ref path, ref _tys, ref args) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::MethodCall;\n                 c.hash(&mut self.s);\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n-            ExprRepeat(ref e, ref l_id) => {\n-                let c: fn(_, _) -> _ = ExprRepeat;\n+            ExprKind::Repeat(ref e, ref l_id) => {\n+                let c: fn(_, _) -> _ = ExprKind::Repeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 let full_table = self.tables;\n                 self.tables = self.cx.tcx.body_tables(l_id.body);\n                 self.hash_expr(&self.cx.tcx.hir.body(l_id.body).value);\n                 self.tables = full_table;\n             },\n-            ExprRet(ref e) => {\n-                let c: fn(_) -> _ = ExprRet;\n+            ExprKind::Ret(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Ret;\n                 c.hash(&mut self.s);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprPath(ref qpath) => {\n-                let c: fn(_) -> _ = ExprPath;\n+            ExprKind::Path(ref qpath) => {\n+                let c: fn(_) -> _ = ExprKind::Path;\n                 c.hash(&mut self.s);\n                 self.hash_qpath(qpath);\n             },\n-            ExprStruct(ref path, ref fields, ref expr) => {\n-                let c: fn(_, _, _) -> _ = ExprStruct;\n+            ExprKind::Struct(ref path, ref fields, ref expr) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Struct;\n                 c.hash(&mut self.s);\n \n                 self.hash_qpath(path);\n@@ -533,32 +533,32 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprTup(ref tup) => {\n-                let c: fn(_) -> _ = ExprTup;\n+            ExprKind::Tup(ref tup) => {\n+                let c: fn(_) -> _ = ExprKind::Tup;\n                 c.hash(&mut self.s);\n                 self.hash_exprs(tup);\n             },\n-            ExprType(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprType;\n+            ExprKind::Type(ref e, ref _ty) => {\n+                let c: fn(_, _) -> _ = ExprKind::Type;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n-            ExprUnary(lop, ref le) => {\n-                let c: fn(_, _) -> _ = ExprUnary;\n+            ExprKind::Unary(lop, ref le) => {\n+                let c: fn(_, _) -> _ = ExprKind::Unary;\n                 c.hash(&mut self.s);\n \n                 lop.hash(&mut self.s);\n                 self.hash_expr(le);\n             },\n-            ExprArray(ref v) => {\n-                let c: fn(_) -> _ = ExprArray;\n+            ExprKind::Array(ref v) => {\n+                let c: fn(_) -> _ = ExprKind::Array;\n                 c.hash(&mut self.s);\n \n                 self.hash_exprs(v);\n             },\n-            ExprWhile(ref cond, ref b, l) => {\n-                let c: fn(_, _, _) -> _ = ExprWhile;\n+            ExprKind::While(ref cond, ref b, l) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::While;\n                 c.hash(&mut self.s);\n \n                 self.hash_expr(cond);"}, {"sha": "3143da08da92c0040eca214a63cc2c7180113fcf", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -160,17 +160,17 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n     println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n     println!(\"{}adjustments: {:?}\", ind, cx.tables.adjustments().get(expr.hir_id));\n     match expr.node {\n-        hir::ExprBox(ref e) => {\n+        hir::ExprKind::Box(ref e) => {\n             println!(\"{}Box\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprArray(ref v) => {\n+        hir::ExprKind::Array(ref v) => {\n             println!(\"{}Array\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprCall(ref func, ref args) => {\n+        hir::ExprKind::Call(ref func, ref args) => {\n             println!(\"{}Call\", ind);\n             println!(\"{}function:\", ind);\n             print_expr(cx, func, indent + 1);\n@@ -179,47 +179,47 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprMethodCall(ref path, _, ref args) => {\n+        hir::ExprKind::MethodCall(ref path, _, ref args) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprTup(ref v) => {\n+        hir::ExprKind::Tup(ref v) => {\n             println!(\"{}Tup\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             println!(\"{}Binary\", ind);\n             println!(\"{}op: {:?}\", ind, op.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprUnary(op, ref inner) => {\n+        hir::ExprKind::Unary(op, ref inner) => {\n             println!(\"{}Unary\", ind);\n             println!(\"{}op: {:?}\", ind, op);\n             print_expr(cx, inner, indent + 1);\n         },\n-        hir::ExprLit(ref lit) => {\n+        hir::ExprKind::Lit(ref lit) => {\n             println!(\"{}Lit\", ind);\n             println!(\"{}{:?}\", ind, lit);\n         },\n-        hir::ExprCast(ref e, ref target) => {\n+        hir::ExprKind::Cast(ref e, ref target) => {\n             println!(\"{}Cast\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n-        hir::ExprType(ref e, ref target) => {\n+        hir::ExprKind::Type(ref e, ref target) => {\n             println!(\"{}Type\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n-        hir::ExprIf(ref e, _, ref els) => {\n+        hir::ExprKind::If(ref e, _, ref els) => {\n             println!(\"{}If\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, e, indent + 1);\n@@ -228,86 +228,86 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, els, indent + 1);\n             }\n         },\n-        hir::ExprWhile(ref cond, _, _) => {\n+        hir::ExprKind::While(ref cond, _, _) => {\n             println!(\"{}While\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n         },\n-        hir::ExprLoop(..) => {\n+        hir::ExprKind::Loop(..) => {\n             println!(\"{}Loop\", ind);\n         },\n-        hir::ExprMatch(ref cond, _, ref source) => {\n+        hir::ExprKind::Match(ref cond, _, ref source) => {\n             println!(\"{}Match\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n             println!(\"{}source: {:?}\", ind, source);\n         },\n-        hir::ExprClosure(ref clause, _, _, _, _) => {\n+        hir::ExprKind::Closure(ref clause, _, _, _, _) => {\n             println!(\"{}Closure\", ind);\n             println!(\"{}clause: {:?}\", ind, clause);\n         },\n-        hir::ExprYield(ref sub) => {\n+        hir::ExprKind::Yield(ref sub) => {\n             println!(\"{}Yield\", ind);\n             print_expr(cx, sub, indent + 1);\n         },\n-        hir::ExprBlock(_, _) => {\n+        hir::ExprKind::Block(_, _) => {\n             println!(\"{}Block\", ind);\n         },\n-        hir::ExprAssign(ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(ref lhs, ref rhs) => {\n             println!(\"{}Assign\", ind);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprAssignOp(ref binop, ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(ref binop, ref lhs, ref rhs) => {\n             println!(\"{}AssignOp\", ind);\n             println!(\"{}op: {:?}\", ind, binop.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprField(ref e, ident) => {\n+        hir::ExprKind::Field(ref e, ident) => {\n             println!(\"{}Field\", ind);\n             println!(\"{}field name: {}\", ind, ident.name);\n             println!(\"{}struct expr:\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprIndex(ref arr, ref idx) => {\n+        hir::ExprKind::Index(ref arr, ref idx) => {\n             println!(\"{}Index\", ind);\n             println!(\"{}array expr:\", ind);\n             print_expr(cx, arr, indent + 1);\n             println!(\"{}index expr:\", ind);\n             print_expr(cx, idx, indent + 1);\n         },\n-        hir::ExprPath(hir::QPath::Resolved(ref ty, ref path)) => {\n+        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n             println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n-        hir::ExprPath(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+        hir::ExprKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n-        hir::ExprAddrOf(ref muta, ref e) => {\n+        hir::ExprKind::AddrOf(ref muta, ref e) => {\n             println!(\"{}AddrOf\", ind);\n             println!(\"mutability: {:?}\", muta);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprBreak(_, ref e) => {\n+        hir::ExprKind::Break(_, ref e) => {\n             println!(\"{}Break\", ind);\n             if let Some(ref e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprContinue(_) => println!(\"{}Again\", ind),\n-        hir::ExprRet(ref e) => {\n+        hir::ExprKind::Continue(_) => println!(\"{}Again\", ind),\n+        hir::ExprKind::Ret(ref e) => {\n             println!(\"{}Ret\", ind);\n             if let Some(ref e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprInlineAsm(_, ref input, ref output) => {\n+        hir::ExprKind::InlineAsm(_, ref input, ref output) => {\n             println!(\"{}InlineAsm\", ind);\n             println!(\"{}inputs:\", ind);\n             for e in input {\n@@ -318,7 +318,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprStruct(ref path, ref fields, ref base) => {\n+        hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n             println!(\"{}Struct\", ind);\n             println!(\"{}path: {:?}\", ind, path);\n             for field in fields {\n@@ -330,7 +330,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, base, indent + 1);\n             }\n         },\n-        hir::ExprRepeat(ref val, ref anon_const) => {\n+        hir::ExprKind::Repeat(ref val, ref anon_const) => {\n             println!(\"{}Repeat\", ind);\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);"}, {"sha": "20993fd0452d739960539993c77881975574f9f0", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -174,7 +174,7 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n \n /// Check if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr, var: Name) -> bool {\n-    if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.node {\n         if path.segments.len() == 1 && path.segments[0].ident.name == var {\n             return true;\n         }\n@@ -330,7 +330,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprMethodCall(ref path, _, ref args) = current.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = current.node {\n             if path.ident.name == *method_name {\n                 if args.iter().any(|e| in_macro(e.span)) {\n                     return None;\n@@ -435,7 +435,7 @@ pub fn last_line_of_span<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Span {\n     Span::new(*line_start, span.hi(), span.ctxt())\n }\n \n-/// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n+/// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n     cx: &T,\n@@ -445,7 +445,7 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n ) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n-    if let ExprBlock(_, _) = expr.node {\n+    if let ExprKind::Block(_, _) = expr.node {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n         Cow::Owned(format!(\"{{ {} }}\", code))\n@@ -530,7 +530,7 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n                 node: ImplItemKind::Method(_, eid),\n                 ..\n             }) => match cx.tcx.hir.body(eid).value.node {\n-                ExprBlock(ref block, _) => Some(block),\n+                ExprKind::Block(ref block, _) => Some(block),\n                 _ => None,\n             },\n             _ => None,\n@@ -695,7 +695,7 @@ pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n /// Check whether the given expression is a constant literal of the given value.\n pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     // FIXME: use constant folding\n-    if let ExprLit(ref spanned) = expr.node {\n+    if let ExprKind::Lit(ref spanned) = expr.node {\n         if let LitKind::Int(v, _) = spanned.node {\n             return v == value;\n         }\n@@ -945,7 +945,7 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n /// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n /// themselves.\n pub fn remove_blocks(expr: &Expr) -> &Expr {\n-    if let ExprBlock(ref block, _) = expr.node {\n+    if let ExprKind::Block(ref block, _) = expr.node {\n         if block.stmts.is_empty() {\n             if let Some(ref expr) = block.expr {\n                 remove_blocks(expr)\n@@ -1020,7 +1020,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n             if let PatKind::Binding(_, defid, _, None) = pat[0].node;\n-            if let ExprPath(QPath::Resolved(None, ref path)) = arm.body.node;\n+            if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.node;\n             if let Def::Local(lid) = path.def;\n             if lid == defid;\n             then {\n@@ -1038,7 +1038,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n         }\n     }\n \n-    if let ExprMatch(_, ref arms, ref source) = expr.node {\n+    if let ExprKind::Match(_, ref arms, ref source) = expr.node {\n         // desugared from a `?` operator\n         if let MatchSource::TryDesugar = *source {\n             return Some(expr);"}, {"sha": "4275345d395e245ed7c723500397a6d928f600cb", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref seg, _, ref args) = expr.node {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n                 if seg.ident.name == \"capacity\" {\n                     self.abort = true;"}, {"sha": "46c14f846abcb1c57c73588352eb930cee7b3cf2", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -46,35 +46,35 @@ impl<'a> Sugg<'a> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n             match expr.node {\n-                hir::ExprAddrOf(..) |\n-                hir::ExprBox(..) |\n-                hir::ExprClosure(.., _) |\n-                hir::ExprIf(..) |\n-                hir::ExprUnary(..) |\n-                hir::ExprMatch(..) => Sugg::MaybeParen(snippet),\n-                hir::ExprContinue(..) |\n-                hir::ExprYield(..) |\n-                hir::ExprArray(..) |\n-                hir::ExprBlock(..) |\n-                hir::ExprBreak(..) |\n-                hir::ExprCall(..) |\n-                hir::ExprField(..) |\n-                hir::ExprIndex(..) |\n-                hir::ExprInlineAsm(..) |\n-                hir::ExprLit(..) |\n-                hir::ExprLoop(..) |\n-                hir::ExprMethodCall(..) |\n-                hir::ExprPath(..) |\n-                hir::ExprRepeat(..) |\n-                hir::ExprRet(..) |\n-                hir::ExprStruct(..) |\n-                hir::ExprTup(..) |\n-                hir::ExprWhile(..) => Sugg::NonParen(snippet),\n-                hir::ExprAssign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-                hir::ExprAssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n-                hir::ExprBinary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n-                hir::ExprCast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-                hir::ExprType(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+                hir::ExprKind::AddrOf(..) |\n+                hir::ExprKind::Box(..) |\n+                hir::ExprKind::Closure(.., _) |\n+                hir::ExprKind::If(..) |\n+                hir::ExprKind::Unary(..) |\n+                hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+                hir::ExprKind::Continue(..) |\n+                hir::ExprKind::Yield(..) |\n+                hir::ExprKind::Array(..) |\n+                hir::ExprKind::Block(..) |\n+                hir::ExprKind::Break(..) |\n+                hir::ExprKind::Call(..) |\n+                hir::ExprKind::Field(..) |\n+                hir::ExprKind::Index(..) |\n+                hir::ExprKind::InlineAsm(..) |\n+                hir::ExprKind::Lit(..) |\n+                hir::ExprKind::Loop(..) |\n+                hir::ExprKind::MethodCall(..) |\n+                hir::ExprKind::Path(..) |\n+                hir::ExprKind::Repeat(..) |\n+                hir::ExprKind::Ret(..) |\n+                hir::ExprKind::Struct(..) |\n+                hir::ExprKind::Tup(..) |\n+                hir::ExprKind::While(..) => Sugg::NonParen(snippet),\n+                hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+                hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n+                hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n+                hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+                hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n             }\n         })\n     }"}, {"sha": "39ab77c3afa1e25418e0c5652bfd814b0e1c2c3b", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_chain! {\n             if let ty::TyRef(_, ty, _) = cx.tables.expr_ty_adjusted(expr).sty;\n             if let ty::TySlice(..) = ty.sty;\n-            if let ExprAddrOf(_, ref addressee) = expr.node;\n+            if let ExprKind::AddrOf(_, ref addressee) = expr.node;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n                 check_vec_macro(cx, &vec_args, expr.span);"}, {"sha": "0adbb36b5ffe7dd9af182824c7a52fe50c2f73a5", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -175,17 +175,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n             // print!()\n-            ExprCall(ref fun, ref args) => {\n+            ExprKind::Call(ref fun, ref args) => {\n                 if_chain! {\n-                    if let ExprPath(ref qpath) = fun.node;\n+                    if let ExprKind::Path(ref qpath) = fun.node;\n                     if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n                     then {\n                         check_print_variants(cx, expr, fun_id, args);\n                     }\n                 }\n             },\n             // write!()\n-            ExprMethodCall(ref fun, _, ref args) => {\n+            ExprKind::MethodCall(ref fun, _, ref args) => {\n                 if fun.ident.name == \"write_fmt\" {\n                     check_write_variants(cx, expr, args);\n                 }\n@@ -206,8 +206,8 @@ fn check_write_variants<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr,\n         if_chain! {\n             // ensure we're calling Arguments::new_v1 or Arguments::new_v1_formatted\n             if write_args.len() == 2;\n-            if let ExprCall(ref args_fun, ref args_args) = write_args[1].node;\n-            if let ExprPath(ref qpath) = args_fun.node;\n+            if let ExprKind::Call(ref args_fun, ref args_args) = write_args[1].node;\n+            if let ExprKind::Path(ref qpath) = args_fun.node;\n             if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n             if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1) ||\n                match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n@@ -219,9 +219,9 @@ fn check_write_variants<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr,\n \n                 if_chain! {\n                     if args_args.len() >= 2;\n-                    if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n-                    if let ExprMatch(ref args, _, _) = match_expr.node;\n-                    if let ExprTup(ref args) = args.node;\n+                    if let ExprKind::AddrOf(_, ref match_expr) = args_args[1].node;\n+                    if let ExprKind::Match(ref args, _, _) = match_expr.node;\n+                    if let ExprKind::Tup(ref args) = args.node;\n                     if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n                     then {\n                         match name {\n@@ -269,21 +269,21 @@ fn check_print_variants<'a, 'tcx>(\n             if_chain! {\n                 // ensure we're calling Arguments::new_v1\n                 if args.len() == 1;\n-                if let ExprCall(ref args_fun, ref args_args) = args[0].node;\n+                if let ExprKind::Call(ref args_fun, ref args_args) = args[0].node;\n                 then {\n                     // Check for literals in the print!/println! args\n                     check_fmt_args_for_literal(cx, args_args, |span| {\n                         span_lint(cx, PRINT_LITERAL, span, \"printing a literal with an empty format string\");\n                     });\n \n                     if_chain! {\n-                        if let ExprPath(ref qpath) = args_fun.node;\n+                        if let ExprKind::Path(ref qpath) = args_fun.node;\n                         if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n                         if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n                         if args_args.len() == 2;\n-                        if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n-                        if let ExprMatch(ref args, _, _) = match_expr.node;\n-                        if let ExprTup(ref args) = args.node;\n+                        if let ExprKind::AddrOf(_, ref match_expr) = args_args[1].node;\n+                        if let ExprKind::Match(ref args, _, _) = match_expr.node;\n+                        if let ExprKind::Tup(ref args) = args.node;\n                         if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n                         then {\n                             match name {\n@@ -315,7 +315,7 @@ fn check_print_variants<'a, 'tcx>(\n     // Search for something like\n     // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n     else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-        if let ExprPath(ref qpath) = args[1].node {\n+        if let ExprKind::Path(ref qpath) = args[1].node {\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n                 if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr)\n                     && is_expn_of(expr.span, \"panic\").is_none()\n@@ -341,25 +341,25 @@ where\n         if args.len() >= 2;\n \n         // the match statement\n-        if let ExprAddrOf(_, ref match_expr) = args[1].node;\n-        if let ExprMatch(ref matchee, ref arms, _) = match_expr.node;\n-        if let ExprTup(ref tup) = matchee.node;\n+        if let ExprKind::AddrOf(_, ref match_expr) = args[1].node;\n+        if let ExprKind::Match(ref matchee, ref arms, _) = match_expr.node;\n+        if let ExprKind::Tup(ref tup) = matchee.node;\n         if arms.len() == 1;\n-        if let ExprArray(ref arm_body_exprs) = arms[0].body.node;\n+        if let ExprKind::Array(ref arm_body_exprs) = arms[0].body.node;\n         then {\n             // it doesn't matter how many args there are in the `write!`/`writeln!`,\n             // if there's one literal, we should warn the user\n             for (idx, tup_arg) in tup.iter().enumerate() {\n                 if_chain! {\n-                    // first, make sure we're dealing with a literal (i.e., an ExprLit)\n-                    if let ExprAddrOf(_, ref tup_val) = tup_arg.node;\n-                    if let ExprLit(_) = tup_val.node;\n+                    // first, make sure we're dealing with a literal (i.e., an ExprKind::Lit)\n+                    if let ExprKind::AddrOf(_, ref tup_val) = tup_arg.node;\n+                    if let ExprKind::Lit(_) = tup_val.node;\n \n                     // next, check the corresponding match arm body to ensure\n                     // this is DISPLAY_FMT_METHOD\n-                    if let ExprCall(_, ref body_args) = arm_body_exprs[idx].node;\n+                    if let ExprKind::Call(_, ref body_args) = arm_body_exprs[idx].node;\n                     if body_args.len() == 2;\n-                    if let ExprPath(ref body_qpath) = body_args[1].node;\n+                    if let ExprKind::Path(ref body_qpath) = body_args[1].node;\n                     if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n                     if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n                     then {\n@@ -371,10 +371,10 @@ where\n                         // and is just \"{}\"\n                         if_chain! {\n                             if args.len() == 3;\n-                            if let ExprAddrOf(_, ref format_expr) = args[2].node;\n-                            if let ExprArray(ref format_exprs) = format_expr.node;\n+                            if let ExprKind::AddrOf(_, ref format_expr) = args[2].node;\n+                            if let ExprKind::Array(ref format_exprs) = format_expr.node;\n                             if format_exprs.len() >= 1;\n-                            if let ExprStruct(_, ref fields, _) = format_exprs[idx].node;\n+                            if let ExprKind::Struct(_, ref fields, _) = format_exprs[idx].node;\n                             if let Some(format_field) = fields.iter().find(|f| f.ident.name == \"format\");\n                             if check_unformatted(&format_field.expr);\n                             then {\n@@ -429,10 +429,10 @@ fn has_empty_arg<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, fmtstr: Local\n /// Returns the slice of format string parts in an `Arguments::new_v1` call.\n fn get_argument_fmtstr_parts(expr: &Expr) -> Option<(LocalInternedString, usize)> {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n-        if let ExprArray(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n+        if let ExprKind::Array(ref exprs) = expr.node;\n         if let Some(expr) = exprs.last();\n-        if let ExprLit(ref lit) = expr.node;\n+        if let ExprKind::Lit(ref lit) = expr.node;\n         if let LitKind::Str(ref lit, _) = lit.node;\n         then {\n             return Some((lit.as_str(), exprs.len()));\n@@ -468,15 +468,15 @@ fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n /// ```\n pub fn check_unformatted(format_field: &Expr) -> bool {\n     if_chain! {\n-        if let ExprStruct(_, ref fields, _) = format_field.node;\n+        if let ExprKind::Struct(_, ref fields, _) = format_field.node;\n         if let Some(width_field) = fields.iter().find(|f| f.ident.name == \"width\");\n-        if let ExprPath(ref qpath) = width_field.expr.node;\n+        if let ExprKind::Path(ref qpath) = width_field.expr.node;\n         if last_path_segment(qpath).ident.name == \"Implied\";\n         if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"align\");\n-        if let ExprPath(ref qpath) = align_field.expr.node;\n+        if let ExprKind::Path(ref qpath) = align_field.expr.node;\n         if last_path_segment(qpath).ident.name == \"Unknown\";\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == \"precision\");\n-        if let ExprPath(ref qpath_precision) = precision_field.expr.node;\n+        if let ExprKind::Path(ref qpath_precision) = precision_field.expr.node;\n         if last_path_segment(qpath_precision).ident.name == \"Implied\";\n         then {\n             return true;"}, {"sha": "d77950bddc02892daf8179570f47871d317e0d52", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // check for instances of 0.0/0.0\n         if_chain! {\n-            if let ExprBinary(ref op, ref left, ref right) = expr.node;\n+            if let ExprKind::Binary(ref op, ref left, ref right) = expr.node;\n             if let BinOp_::BiDiv = op.node;\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would"}, {"sha": "9ef1333a0e17f480d29fad36a890c161f06a00e5", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -2,10 +2,10 @@ if_chain! {\n     if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n     if let Decl_::DeclLocal(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprCast(ref expr, ref cast_ty) = init.node;\n+    if let ExprKind::Cast(ref expr, ref cast_ty) = init.node;\n     if let Ty_::TyPath(ref qp) = cast_ty.node;\n     if match_qpath(qp, &[\"char\"]);\n-    if let Expr_::ExprLit(ref lit) = expr.node;\n+    if let ExprKind::Lit(ref lit) = expr.node;\n     if let LitKind::Int(69, _) = lit.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;\n     if name.node.as_str() == \"x\";"}, {"sha": "fe90d66ad047796a2659e5ac2a615960c3a26cc7", "filename": "tests/ui/author/call.stdout", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Fauthor%2Fcall.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Fauthor%2Fcall.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fcall.stdout?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -2,13 +2,13 @@ if_chain! {\n     if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n     if let Decl_::DeclLocal(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprCall(ref func, ref args) = init.node;\n-    if let Expr_::ExprPath(ref path) = func.node;\n+    if let ExprKind::Call(ref func, ref args) = init.node;\n+    if let ExprKind::Path(ref path) = func.node;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"cmp\", \"min\"]);\n     if args.len() == 2;\n-    if let Expr_::ExprLit(ref lit) = args[0].node;\n+    if let ExprKind::Lit(ref lit) = args[0].node;\n     if let LitKind::Int(3, _) = lit.node;\n-    if let Expr_::ExprLit(ref lit1) = args[1].node;\n+    if let ExprKind::Lit(ref lit1) = args[1].node;\n     if let LitKind::Int(4, _) = lit1.node;\n     if let PatKind::Wild = local.pat.node;\n     then {"}, {"sha": "dc506b22798bdba6cc50833ae87069c1a8ab23a5", "filename": "tests/ui/author/for_loop.stdout", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -1,60 +1,60 @@\n if_chain! {\n-    if let Expr_::ExprBlock(ref block) = expr.node;\n+    if let ExprKind::Block(ref block) = expr.node;\n     if let Stmt_::StmtDecl(ref decl, _) = block.node\n     if let Decl_::DeclLocal(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::ForLoopDesugar) = init.node;\n-    if let Expr_::ExprCall(ref func, ref args) = expr.node;\n-    if let Expr_::ExprPath(ref path) = func.node;\n+    if let ExprKind::Match(ref expr, ref arms, MatchSource::ForLoopDesugar) = init.node;\n+    if let ExprKind::Call(ref func, ref args) = expr.node;\n+    if let ExprKind::Path(ref path) = func.node;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"iter\", \"IntoIterator\", \"into_iter\"]);\n     if args.len() == 1;\n-    if let Expr_::ExprStruct(ref path1, ref fields, None) = args[0].node;\n+    if let ExprKind::Struct(ref path1, ref fields, None) = args[0].node;\n     if match_qpath(path1, &[\"{{root}}\", \"std\", \"ops\", \"Range\"]);\n     if fields.len() == 2;\n     // unimplemented: field checks\n     if arms.len() == 1;\n-    if let Expr_::ExprLoop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.node;\n+    if let ExprKind::Loop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.node;\n     if let Stmt_::StmtDecl(ref decl1, _) = body.node\n     if let Decl_::DeclLocal(ref local1) = decl1.node;\n     if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local1.pat.node;\n     if name.node.as_str() == \"__next\";\n     if let Stmt_::StmtExpr(ref e, _) = local1.pat.node\n-    if let Expr_::ExprMatch(ref expr1, ref arms1, MatchSource::ForLoopDesugar) = e.node;\n-    if let Expr_::ExprCall(ref func1, ref args1) = expr1.node;\n-    if let Expr_::ExprPath(ref path2) = func1.node;\n+    if let ExprKind::Match(ref expr1, ref arms1, MatchSource::ForLoopDesugar) = e.node;\n+    if let ExprKind::Call(ref func1, ref args1) = expr1.node;\n+    if let ExprKind::Path(ref path2) = func1.node;\n     if match_qpath(path2, &[\"{{root}}\", \"std\", \"iter\", \"Iterator\", \"next\"]);\n     if args1.len() == 1;\n-    if let Expr_::ExprAddrOf(MutMutable, ref inner) = args1[0].node;\n-    if let Expr_::ExprPath(ref path3) = inner.node;\n+    if let ExprKind::AddrOf(MutMutable, ref inner) = args1[0].node;\n+    if let ExprKind::Path(ref path3) = inner.node;\n     if match_qpath(path3, &[\"iter\"]);\n     if arms1.len() == 2;\n-    if let Expr_::ExprAssign(ref target, ref value) = arms1[0].body.node;\n-    if let Expr_::ExprPath(ref path4) = target.node;\n+    if let ExprKind::Assign(ref target, ref value) = arms1[0].body.node;\n+    if let ExprKind::Path(ref path4) = target.node;\n     if match_qpath(path4, &[\"__next\"]);\n-    if let Expr_::ExprPath(ref path5) = value.node;\n+    if let ExprKind::Path(ref path5) = value.node;\n     if match_qpath(path5, &[\"val\"]);\n     if arms1[0].pats.len() == 1;\n     if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pats[0].node;\n     if match_qpath(path6, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"Some\"]);\n     if fields1.len() == 1;\n     // unimplemented: field checks\n-    if let Expr_::ExprBreak(ref destination, None) = arms1[1].body.node;\n+    if let ExprKind::Break(ref destination, None) = arms1[1].body.node;\n     if arms1[1].pats.len() == 1;\n     if let PatKind::Path(ref path7) = arms1[1].pats[0].node;\n     if match_qpath(path7, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n     if let Stmt_::StmtDecl(ref decl2, _) = path7.node\n     if let Decl_::DeclLocal(ref local2) = decl2.node;\n     if let Some(ref init1) = local2.init\n-    if let Expr_::ExprPath(ref path8) = init1.node;\n+    if let ExprKind::Path(ref path8) = init1.node;\n     if match_qpath(path8, &[\"__next\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local2.pat.node;\n     if name1.node.as_str() == \"y\";\n     if let Stmt_::StmtExpr(ref e1, _) = local2.pat.node\n-    if let Expr_::ExprBlock(ref block1) = e1.node;\n+    if let ExprKind::Block(ref block1) = e1.node;\n     if let Stmt_::StmtDecl(ref decl3, _) = block1.node\n     if let Decl_::DeclLocal(ref local3) = decl3.node;\n     if let Some(ref init2) = local3.init\n-    if let Expr_::ExprPath(ref path9) = init2.node;\n+    if let ExprKind::Path(ref path9) = init2.node;\n     if match_qpath(path9, &[\"y\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local3.pat.node;\n     if name2.node.as_str() == \"z\";\n@@ -63,7 +63,7 @@ if_chain! {\n     if name3.node.as_str() == \"iter\";\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name4, None) = local.pat.node;\n     if name4.node.as_str() == \"_result\";\n-    if let Expr_::ExprPath(ref path10) = local.pat.node;\n+    if let ExprKind::Path(ref path10) = local.pat.node;\n     if match_qpath(path10, &[\"_result\"]);\n     then {\n         // report your lint here"}, {"sha": "f314f7b2e251cb556620f1b108e2ff5ad5feb8ce", "filename": "tests/ui/author/matches.stout", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Fauthor%2Fmatches.stout", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Fauthor%2Fmatches.stout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stout?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -2,31 +2,31 @@ if_chain! {\n     if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n     if let Decl_::DeclLocal(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::Normal) = init.node;\n-    if let Expr_::ExprLit(ref lit) = expr.node;\n+    if let ExprKind::Match(ref expr, ref arms, MatchSource::Normal) = init.node;\n+    if let ExprKind::Lit(ref lit) = expr.node;\n     if let LitKind::Int(42, _) = lit.node;\n     if arms.len() == 3;\n-    if let Expr_::ExprLit(ref lit1) = arms[0].body.node;\n+    if let ExprKind::Lit(ref lit1) = arms[0].body.node;\n     if let LitKind::Int(5, _) = lit1.node;\n     if arms[0].pats.len() == 1;\n     if let PatKind::Lit(ref lit_expr) = arms[0].pats[0].node\n-    if let Expr_::ExprLit(ref lit2) = lit_expr.node;\n+    if let ExprKind::Lit(ref lit2) = lit_expr.node;\n     if let LitKind::Int(16, _) = lit2.node;\n-    if let Expr_::ExprBlock(ref block) = arms[1].body.node;\n+    if let ExprKind::Block(ref block) = arms[1].body.node;\n     if let Stmt_::StmtDecl(ref decl1, _) = block.node\n     if let Decl_::DeclLocal(ref local1) = decl1.node;\n     if let Some(ref init1) = local1.init\n-    if let Expr_::ExprLit(ref lit3) = init1.node;\n+    if let ExprKind::Lit(ref lit3) = init1.node;\n     if let LitKind::Int(3, _) = lit3.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.node;\n     if name.node.as_str() == \"x\";\n-    if let Expr_::ExprPath(ref path) = local1.pat.node;\n+    if let ExprKind::Path(ref path) = local1.pat.node;\n     if match_qpath(path, &[\"x\"]);\n     if arms[1].pats.len() == 1;\n     if let PatKind::Lit(ref lit_expr1) = arms[1].pats[0].node\n-    if let Expr_::ExprLit(ref lit4) = lit_expr1.node;\n+    if let ExprKind::Lit(ref lit4) = lit_expr1.node;\n     if let LitKind::Int(17, _) = lit4.node;\n-    if let Expr_::ExprLit(ref lit5) = arms[2].body.node;\n+    if let ExprKind::Lit(ref lit5) = arms[2].body.node;\n     if let LitKind::Int(1, _) = lit5.node;\n     if arms[2].pats.len() == 1;\n     if let PatKind::Wild = arms[2].pats[0].node;"}, {"sha": "b8f408ae29af27e03bd6ec70e66d65def9fcd6e8", "filename": "tests/ui/trailing_zeros.stdout", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Ftrailing_zeros.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1bd17e4fa2ba4bad31c15c50300c32235a715223/tests%2Fui%2Ftrailing_zeros.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zeros.stdout?ref=1bd17e4fa2ba4bad31c15c50300c32235a715223", "patch": "@@ -1,13 +1,13 @@\n if_chain! {\n-    if let Expr_::ExprBinary(ref op, ref left, ref right) = expr.node;\n+    if let ExprKind::Binary(ref op, ref left, ref right) = expr.node;\n     if BinOp_::BiEq == op.node;\n-    if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n+    if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.node;\n     if BinOp_::BiBitAnd == op1.node;\n-    if let Expr_::ExprPath(ref path) = left1.node;\n+    if let ExprKind::Path(ref path) = left1.node;\n     if match_qpath(path, &[\"x\"]);\n-    if let Expr_::ExprLit(ref lit) = right1.node;\n+    if let ExprKind::Lit(ref lit) = right1.node;\n     if let LitKind::Int(15, _) = lit.node;\n-    if let Expr_::ExprLit(ref lit1) = right.node;\n+    if let ExprKind::Lit(ref lit1) = right.node;\n     if let LitKind::Int(0, _) = lit1.node;\n     then {\n         // report your lint here"}]}