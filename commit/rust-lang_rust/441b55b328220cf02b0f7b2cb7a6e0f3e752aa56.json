{"sha": "441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MWI1NWIzMjgyMjBjZjAyYjBmN2IyY2I3YTZlMGYzZTc1MmFhNTY=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-04-30T09:48:43Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-04-30T09:48:43Z"}, "message": "Added eq_op and bad_bit_mask from the extra_lints project (mostly plain copy, need to refactor to integrate better)", "tree": {"sha": "d6f91f3da77891042c506422aa7ecb77b4d20e4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6f91f3da77891042c506422aa7ecb77b4d20e4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "html_url": "https://github.com/rust-lang/rust/commit/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2935c31692b49e5b2ffde2d33427a90be336eba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2935c31692b49e5b2ffde2d33427a90be336eba6", "html_url": "https://github.com/rust-lang/rust/commit/2935c31692b49e5b2ffde2d33427a90be336eba6"}], "stats": {"total": 413, "additions": 398, "deletions": 15}, "files": [{"sha": "27ff93982b2e6848cbbf01430df64810af5eea59", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "patch": "@@ -1,14 +1,14 @@\n [package]\n-\n name = \"clippy\"\n version = \"0.0.1\"\n-authors = [\"Manish Goregaokar <manishsmail@gmail.com>\"]\n+authors = [\n+\t\"Manish Goregaokar <manishsmail@gmail.com>\",\n+\t\"Andre Bogus <bogusandre@gmail.com>\"\n+]\n \n [lib]\n name = \"clippy\"\n crate_type = [\"dylib\"]\n \n-\n-\n [dev-dependencies.compiletest]\n git = \"https://github.com/laumann/compiletest-rs.git\""}, {"sha": "577de498dab21f46e2b66e623bfca904463be574", "filename": "README.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "patch": "@@ -1,16 +1,18 @@\n rust-clippy\n ===========\n \n-A collection of lints that give helpful tips to newbies.\n+A collection of lints that give helpful tips to newbies and catch oversights.\n \n \n Lints included in this crate:\n \n- - `clippy_single_match`: Warns when a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used, and recommends `if let` instead.\n- - `clippy_box_vec`: Warns on usage of `Box<Vec<T>>`\n- - `clippy_dlist`: Warns on usage of `DList`\n- - `clippy_str_to_string`: Warns on usage of `str::to_string()`\n- - `clippy_toplevel_ref_arg`: Warns when a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`).\n+ - `single_match`: Warns when a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used, and recommends `if let` instead.\n+ - `box_vec`: Warns on usage of `Box<Vec<T>>`\n+ - `dlist`: Warns on usage of `DList`\n+ - `str_to_string`: Warns on usage of `str::to_string()`\n+ - `toplevel_ref_arg`: Warns when a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`).\n+ - `eq_op`: Warns on equal operands on both sides of a comparison or bitwise combination\n+ - `bad_bit_mask`: Denies expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n \n You can allow/warn/deny the whole set using the `clippy` lint group (`#[allow(clippy)]`, etc)\n "}, {"sha": "313bfb1ac0be6ff33c8b4002d1b6e2a6029cf1ac", "filename": "src/bit_mask.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "patch": "@@ -0,0 +1,111 @@\n+//! Checks for incompatible bit masks in comparisons, e.g. `x & 1 == 2`. This cannot work because the bit that makes up\n+//! the value two was zeroed out by the bit-and with 1. So the formula for detecting if an expression of the type \n+//! `_ <bit_op> m <cmp_op> c` (where `<bit_op>` is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` ,`!=`, `>=`, \n+//! `>`}) can be determined from the following table:\n+//! \n+//! |Comparison  |Bit-Op|Example     |is always|Formula               |\n+//! |------------|------|------------|---------|----------------------|\n+//! |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n+//! |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n+//! |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n+//! |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n+//! |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`\t\t\t  |\n+//! |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n+//! \n+//! *TODO*: There is the open question if things like `x | 1 > 1` should be caught by this lint, because it is basically\n+//! an obfuscated version of `x > 1`.\n+//! \n+//! This lint is **deny** by default\n+\n+use rustc::plugin::Registry;\n+use rustc::lint::*;\n+use syntax::ast::*;\n+use syntax::ast_util::{is_comparison_binop, binop_to_string};\n+use syntax::ptr::P;\n+use syntax::codemap::Span;\n+\n+declare_lint! {\n+    pub BAD_BIT_MASK,\n+    Deny,\n+    \"Deny the use of incompatible bit masks in comparisons, e.g. '(a & 1) == 2'\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct BitMask;\n+\n+impl LintPass for BitMask {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(BAD_BIT_MASK)\n+    }\n+    \n+    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+\t\t\tif is_comparison_binop(cmp.node) {\n+\t\t\t\tfetch_int_literal(&right.node).map(|cmp_value| check_compare(cx, left, cmp.node, cmp_value, &e.span));\n+\t\t\t}\n+\t\t}\n+    }\n+}\n+\n+fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n+\tmatch &bit_op.node {\n+\t\t&ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n+\t\t&ExprBinary(ref op, ref left, ref right) => {\n+\t\t\tif op.node != BiBitAnd && op.node != BiBitOr { return; }\n+\t\t\tif let Some(mask_value) = fetch_int_literal(&right.node) {\n+\t\t\t\tcheck_bit_mask(cx, op.node, cmp_op, mask_value, cmp_value, span);\n+\t\t\t} else if let Some(mask_value) = fetch_int_literal(&left.node) {\n+\t\t\t\tcheck_bit_mask(cx, op.node, cmp_op, mask_value, cmp_value, span);\n+\t\t\t}\n+\t\t},\n+\t\t_ => ()\n+\t}\n+}\n+\n+fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u64, cmp_value: u64, span: &Span) {\n+\tmatch cmp_op {\n+\t\tBiEq | BiNe => match bit_op {\n+\t\t\tBiBitAnd => if mask_value & cmp_value != mask_value {\n+\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ & {} can never be equal to {}\", mask_value,\n+\t\t\t\t\tcmp_value));\n+\t\t\t},\n+\t\t\tBiBitOr => if mask_value | cmp_value != cmp_value {\n+\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ | {} can never be equal to {}\", mask_value,\n+\t\t\t\t\tcmp_value));\n+\t\t\t},\n+\t\t\t_ => ()\n+\t\t},\n+\t\tBiLt | BiGe => match bit_op {\n+\t\t\tBiBitAnd => if mask_value < cmp_value {\n+\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ & {} will always be lower than {}\", mask_value,\n+\t\t\t\t\tcmp_value));\n+\t\t\t},\n+\t\t\tBiBitOr => if mask_value >= cmp_value {\n+\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ | {} will never be lower than {}\", mask_value,\n+\t\t\t\t\tcmp_value));\n+\t\t\t},\n+\t\t\t_ => ()\n+\t\t},\n+\t\tBiLe | BiGt => match bit_op {\n+\t\t\tBiBitAnd => if mask_value <= cmp_value {\n+\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ & {} will never be higher than {}\", mask_value,\n+\t\t\t\t\tcmp_value));\n+\t\t\t},\n+\t\t\tBiBitOr => if mask_value > cmp_value {\n+\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ | {} will always be higher than {}\", mask_value,\n+\t\t\t\t\tcmp_value));\t\t\t\t\n+\t\t\t},\n+\t\t\t_ => ()\n+\t\t},\n+\t\t_ => ()\n+\t}\n+}\n+\n+fn fetch_int_literal(lit : &Expr_) -> Option<u64> {\n+\tif let &ExprLit(ref lit_ptr) = lit {\n+\t\tif let &LitInt(value, _) = &lit_ptr.node {\n+\t\t\treturn Option::Some(value); //TODO: Handle sign\n+\t\t}\n+\t}\n+\tOption::None\n+}"}, {"sha": "e0b722a0a181a568379b377ce604fee39c670fa5", "filename": "src/eq_op.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "patch": "@@ -0,0 +1,214 @@\n+use rustc::lint::*;\n+use syntax::ast::*;\n+use syntax::ast_util as ast_util;\n+use syntax::ptr::P;\n+use syntax::codemap as code;\n+\n+declare_lint! {\n+    pub EQ_OP,\n+    Warn,\n+    \"warn about comparing equal expressions (e.g. x == x)\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct EqOp;\n+\n+impl LintPass for EqOp {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(EQ_OP)\n+    }\n+    \n+    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+        if let ExprBinary(ref op, ref left, ref right) = e.node {\n+            if is_cmp_or_bit(op) && is_exp_equal(left, right) {\n+                cx.span_lint(EQ_OP, e.span, &format!(\"equal expressions as operands to {}\", ast_util::binop_to_string(op.node)));\n+            }\n+        }\n+    }\n+}\n+\n+fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n+\tmatch (&left.node, &right.node) {\n+\t\t(&ExprBinary(ref lop, ref ll, ref lr), &ExprBinary(ref rop, ref rl, ref rr)) => \n+\t\t\tlop.node == rop.node && is_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n+\t\t(&ExprBox(ref lpl, ref lboxedpl), &ExprBox(ref rpl, ref rboxedpl)) => \n+\t\t\tboth(lpl, rpl, |l, r| is_exp_equal(l, r)) && is_exp_equal(lboxedpl, rboxedpl),\n+\t\t(&ExprCall(ref lcallee, ref largs), &ExprCall(ref rcallee, ref rargs)) => \n+\t\t\tis_exp_equal(lcallee, rcallee) && is_exp_vec_equal(largs, rargs),\n+\t\t(&ExprCast(ref lcast, ref lty), &ExprCast(ref rcast, ref rty)) => \n+\t\t\tis_ty_equal(lty, rty) && is_exp_equal(lcast, rcast),\n+\t\t(&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => \n+\t\t\tlfident.node == rfident.node && is_exp_equal(lfexp, rfexp),\n+\t\t(&ExprLit(ref llit), &ExprLit(ref rlit)) => llit.node == rlit.node,\n+\t\t(&ExprMethodCall(ref lident, ref lcty, ref lmargs), &ExprMethodCall(ref rident, ref rcty, ref rmargs)) => \n+\t\t\tlident.node == rident.node && is_ty_vec_equal(lcty, rcty) && is_exp_vec_equal(lmargs, rmargs),\n+\t\t(&ExprParen(ref lparen), &ExprParen(ref rparen)) => is_exp_equal(lparen, rparen),\n+\t\t(&ExprParen(ref lparen), _) => is_exp_equal(lparen, right),\n+\t\t(_, &ExprParen(ref rparen)) => is_exp_equal(left, rparen),\n+\t\t(&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => \n+\t\t\tboth(lqself, rqself, |l, r| is_qself_equal(l, r)) && is_path_equal(lsubpath, rsubpath),\t\t\n+\t\t(&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exp_vec_equal(ltup, rtup),\n+\t\t(&ExprUnary(lunop, ref lparam), &ExprUnary(runop, ref rparam)) => lunop == runop && is_exp_equal(lparam, rparam), \n+\t\t(&ExprVec(ref lvec), &ExprVec(ref rvec)) => is_exp_vec_equal(lvec, rvec),\n+\t\t_ => false\n+\t}\n+}\n+\n+fn is_exp_vec_equal(left : &Vec<P<Expr>>, right : &Vec<P<Expr>>) -> bool {\n+\tover(left, right, |l, r| is_exp_equal(l, r))\n+}\n+\n+fn is_path_equal(left : &Path, right : &Path) -> bool {\n+\tleft.global == right.global && left.segments == right.segments\n+}\n+\n+fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n+\tleft.ty.node == right.ty.node && left.position == right.position\n+}\n+\n+fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n+\tmatch (&left.node, &right.node) {\n+\t(&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(lvec, rvec),\n+\t(&TyFixedLengthVec(ref lfvty, ref lfvexp), &TyFixedLengthVec(ref rfvty, ref rfvexp)) => \n+\t\tis_ty_equal(lfvty, rfvty) && is_exp_equal(lfvexp, rfvexp),\n+\t(&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(lmut, rmut),\n+\t(&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) => \n+\t\tboth(ltime, rtime, is_lifetime_equal) && is_mut_ty_equal(lrmut, rrmut),\n+\t(&TyBareFn(ref lbare), &TyBareFn(ref rbare)) => is_bare_fn_ty_equal(lbare, rbare),\n+    (&TyTup(ref ltup), &TyTup(ref rtup)) => is_ty_vec_equal(ltup, rtup),\n+\t(&TyPath(Option::None, ref lpath), &TyPath(Option::None, ref rpath)) => is_path_equal(lpath, rpath),\n+\t(&TyPath(Option::Some(ref lqself), ref lsubpath), &TyPath(Option::Some(ref rqself), ref rsubpath)) =>\n+\t\tis_qself_equal(lqself, rqself) && is_path_equal(lsubpath, rsubpath),\n+    (&TyObjectSum(ref lsumty, ref lobounds), &TyObjectSum(ref rsumty, ref robounds)) => \n+\t\tis_ty_equal(lsumty, rsumty) && is_param_bounds_equal(lobounds, robounds),\n+\t(&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) => is_param_bounds_equal(ltbounds, rtbounds),\n+    (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(lty, rty),\n+    (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(lof, rof),\n+\t(&TyInfer, &TyInfer) => true,\n+\t_ => false\n+\t}\n+}\n+\n+fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound) -> bool {\n+\tmatch(left, right) {\n+\t(&TraitTyParamBound(ref lpoly, ref lmod), &TraitTyParamBound(ref rpoly, ref rmod)) => \n+\t\tlmod == rmod && is_poly_traitref_equal(lpoly, rpoly),\n+    (&RegionTyParamBound(ref ltime), &RegionTyParamBound(ref rtime)) => is_lifetime_equal(ltime, rtime),\n+    _ => false\n+\t}\n+}\n+\n+fn is_poly_traitref_equal(left : &PolyTraitRef, right : &PolyTraitRef) -> bool {\n+\tis_lifetimedef_vec_equal(&left.bound_lifetimes, &right.bound_lifetimes) && \n+\t\tis_path_equal(&left.trait_ref.path, &right.trait_ref.path)\n+}\n+\n+fn is_param_bounds_equal(left : &TyParamBounds, right : &TyParamBounds) -> bool {\n+\tover(left, right, is_param_bound_equal)\n+}\n+\n+fn is_mut_ty_equal(left : &MutTy, right : &MutTy) -> bool {\n+\tleft.mutbl == right.mutbl && is_ty_equal(&left.ty, &right.ty)\n+}\n+\n+fn is_bare_fn_ty_equal(left : &BareFnTy, right : &BareFnTy) -> bool {\n+\tleft.unsafety == right.unsafety && left.abi == right.abi && \n+\t\tis_lifetimedef_vec_equal(&left.lifetimes, &right.lifetimes) && is_fndecl_equal(&left.decl, &right.decl)\n+} \n+\n+fn is_fndecl_equal(left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n+\tleft.variadic == right.variadic && is_arg_vec_equal(&left.inputs, &right.inputs) && \n+\t\tis_fnret_ty_equal(&left.output, &right.output)\n+}\n+\n+fn is_fnret_ty_equal(left : &FunctionRetTy, right : &FunctionRetTy) -> bool {\n+\tmatch (left, right) {\n+\t(&NoReturn(_), &NoReturn(_)) | (&DefaultReturn(_), &DefaultReturn(_)) => true,\n+\t(&Return(ref lty), &Return(ref rty)) => is_ty_equal(lty, rty),\n+\t_ => false\t\n+\t}\n+}\n+\n+fn is_arg_equal(left : &Arg, right : &Arg) -> bool {\n+\tis_ty_equal(&left.ty, &right.ty) && is_pat_equal(&left.pat, &right.pat)\n+}\n+\n+fn is_arg_vec_equal(left : &Vec<Arg>, right : &Vec<Arg>) -> bool {\n+\tover(left, right, is_arg_equal)\n+}\n+\n+fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n+\tmatch(&left.node, &right.node) {\n+\t(&PatWild(lwild), &PatWild(rwild)) => lwild == rwild,\n+\t(&PatIdent(ref lmode, ref lident, Option::None), &PatIdent(ref rmode, ref rident, Option::None)) =>\n+\t\tlmode == rmode && is_ident_equal(&lident.node, &rident.node),\n+\t(&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)), \n+\t\t\t&PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n+\t\tlmode == rmode && is_ident_equal(&lident.node, &rident.node) && is_pat_equal(lpat, rpat),\n+    (&PatEnum(ref lpath, Option::None), &PatEnum(ref rpath, Option::None)) => is_path_equal(lpath, rpath),\n+    (&PatEnum(ref lpath, Option::Some(ref lenum)), &PatEnum(ref rpath, Option::Some(ref renum))) => \n+\t\tis_path_equal(lpath, rpath) && is_pat_vec_equal(lenum, renum),  \n+    (&PatStruct(ref lpath, ref lfieldpat, lbool), &PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n+\t\tlbool == rbool && is_path_equal(lpath, rpath) && is_spanned_fieldpat_vec_equal(lfieldpat, rfieldpat),\n+    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pat_vec_equal(ltup, rtup), \n+    (&PatBox(ref lboxed), &PatBox(ref rboxed)) => is_pat_equal(lboxed, rboxed),\n+    (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) => is_pat_equal(lpat, rpat) && lmut == rmut,\n+\t(&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(llit, rlit),\n+    (&PatRange(ref lfrom, ref lto), &PatRange(ref rfrom, ref rto)) =>\n+\t\tis_exp_equal(lfrom, rfrom) && is_exp_equal(lto, rto),\n+    (&PatVec(ref lfirst, Option::None, ref llast), &PatVec(ref rfirst, Option::None, ref rlast)) =>\n+\t\tis_pat_vec_equal(lfirst, rfirst) && is_pat_vec_equal(llast, rlast),\n+    (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast), &PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n+\t\tis_pat_vec_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) && is_pat_vec_equal(llast, rlast),\n+\t// I don't match macros for now, the code is slow enough as is ;-)\n+\t_ => false\n+\t}\n+}\n+\n+fn is_spanned_fieldpat_vec_equal(left : &Vec<code::Spanned<FieldPat>>, right : &Vec<code::Spanned<FieldPat>>) -> bool {\n+\tover(left, right, |l, r| is_fieldpat_equal(&l.node, &r.node))\n+}\n+\n+fn is_fieldpat_equal(left : &FieldPat, right : &FieldPat) -> bool {\n+\tleft.is_shorthand == right.is_shorthand && is_ident_equal(&left.ident, &right.ident) && \n+\t\tis_pat_equal(&left.pat, &right.pat) \n+}\n+\n+fn is_ident_equal(left : &Ident, right : &Ident) -> bool {\n+\t&left.name == &right.name && left.ctxt == right.ctxt\n+}\n+\n+fn is_pat_vec_equal(left : &Vec<P<Pat>>, right : &Vec<P<Pat>>) -> bool {\n+\tover(left, right, |l, r| is_pat_equal(l, r))\n+}\n+\n+fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef) -> bool {\n+\tis_lifetime_equal(&left.lifetime, &right.lifetime) && over(&left.bounds, &right.bounds, is_lifetime_equal)\n+}\n+\n+fn is_lifetimedef_vec_equal(left : &Vec<LifetimeDef>, right : &Vec<LifetimeDef>) -> bool {\n+\tover(left, right, is_lifetimedef_equal)\n+}\n+\n+fn is_lifetime_equal(left : &Lifetime, right : &Lifetime) -> bool {\n+\tleft.name == right.name\n+}\n+\n+fn is_ty_vec_equal(left : &Vec<P<Ty>>, right : &Vec<P<Ty>>) -> bool {\n+\tover(left, right, |l, r| is_ty_equal(l, r))\n+}\n+\n+fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool where F: FnMut(&X, &X) -> bool {\n+    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n+}\n+\n+fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool where F: FnMut(&X, &X) -> bool {\n+\tif l.is_none() { r.is_none() } else { r.is_some() && eq_fn(l.as_ref().unwrap(), &r.as_ref().unwrap()) }\n+}\n+\n+fn is_cmp_or_bit(op : &BinOp) -> bool {\n+    match op.node {\n+        BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr => true,\n+        _ => false\n+    }\n+}"}, {"sha": "ad477a21042e63133697f71f3a344d2a5b611754", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "patch": "@@ -16,14 +16,19 @@ use rustc::lint::LintPassObject;\n \n pub mod types;\n pub mod misc;\n+pub mod eq_op;\n+pub mod bit_mask;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box types::TypePass as LintPassObject);\n     reg.register_lint_pass(box misc::MiscPass as LintPassObject);\n     reg.register_lint_pass(box misc::StrToStringPass as LintPassObject);\n     reg.register_lint_pass(box misc::TopLevelRefPass as LintPassObject);\n+    reg.register_lint_pass(box eq_op::EqOp as LintPassObject);\n+    reg.register_lint_pass(box bit_mask::BitMask as LintPassObject);\n     reg.register_lint_group(\"clippy\", vec![types::BOX_VEC, types::LINKEDLIST,\n                                            misc::SINGLE_MATCH, misc::STR_TO_STRING,\n-                                           misc::TOPLEVEL_REF_ARG]);\n+                                           misc::TOPLEVEL_REF_ARG, eq_op::EQ_OP,\n+                                           bit_mask::BAD_BIT_MASK]);\n }"}, {"sha": "0c1fd348234e0e0d166065e3182321c69d521154", "filename": "tests/compile-fail/bit_masks.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/tests%2Fcompile-fail%2Fbit_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/tests%2Fcompile-fail%2Fbit_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbit_masks.rs?ref=441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "patch": "@@ -0,0 +1,19 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(bad_bit_mask)]\n+fn main() {\n+\tlet x = 5;\n+\tx & 1 == 1; //ok, distinguishes bit 0\n+\tx & 2 == 1; //~ERROR\n+\tx | 1 == 3; //ok, equals x == 2 || x == 3\n+\tx | 3 == 3; //ok, equals x <= 3\n+\tx | 3 == 2; //~ERROR\n+\t\n+\tx & 1 > 1; //~ERROR\n+\tx & 2 > 1; // ok, distinguishes x & 2 == 2 from x & 2 == 0\n+\tx & 2 < 1; // ok, distinguishes x & 2 == 2 from x & 2 == 0\n+\tx | 1 > 1; // ok (if a bit silly), equals x > 1\n+\tx | 2 > 1; //~ERROR\n+\tx | 2 <= 2; // ok (if a bit silly), equals x <= 2\n+}"}, {"sha": "910b5e84816101f66269e647c7c00fd35a8e275a", "filename": "tests/compile-fail/eq_op.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "patch": "@@ -0,0 +1,36 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+fn id<X>(x: X) -> X {\n+\tx\n+}\n+\n+#[deny(eq_op)]\n+fn main() {\n+\t// simple values and comparisons\n+\t1 == 1; //~ERROR\n+\t\"no\" == \"no\"; //~ERROR \n+\t// even though I agree that no means no ;-)\n+\tfalse != false; //~ERROR\n+\t1.5 < 1.5; //~ERROR\n+\t1u64 >= 1u64; //~ERROR\n+\t\n+\t// casts, methods, parenthesis\n+\t(1 as u64) & (1 as u64); //~ERROR\n+\t1 ^ ((((((1)))))); //~ERROR\n+\tid((1)) | id(1); //~ERROR\n+\t\n+\t// unary and binary operators\n+\t(-(2) < -(2));  //~ERROR\n+    ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n+          //~^ ERROR\n+                    //~^^ ERROR\n+                               //~^^^ ERROR\n+\t(1 * 2) + (3 * 4) == 1 * 2 + 3 * 4; //~ERROR\n+\t\n+\t// various other things\n+\t([1] != [1]); //~ERROR\n+    ((1, 2) != (1, 2)); //~ERROR\n+    [1].len() == [1].len(); //~ERROR\n+    vec![1, 2, 3] == vec![1, 2, 3]; //no error yet, as we don't match macros\n+}"}, {"sha": "5008c2aa7046ee944d344b00c6a8a277187f0c55", "filename": "tests/compile-test.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441b55b328220cf02b0f7b2cb7a6e0f3e752aa56/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=441b55b328220cf02b0f7b2cb7a6e0f3e752aa56", "patch": "@@ -1,11 +1,8 @@\n extern crate compiletest;\n \n-use std::env;\n-use std::process::Command;\n use std::path::PathBuf;\n \n fn run_mode(mode: &'static str) {\n-\n     let mut config = compiletest::default_config();\n     let cfg_mode = mode.parse().ok().expect(\"Invalid mode\");\n     config.target_rustcflags = Some(\"-L target/debug/\".to_string());\n@@ -19,5 +16,4 @@ fn run_mode(mode: &'static str) {\n #[test]\n fn compile_test() {\n     run_mode(\"compile-fail\");\n-    // run_mode(\"run-pass\");\n }"}]}