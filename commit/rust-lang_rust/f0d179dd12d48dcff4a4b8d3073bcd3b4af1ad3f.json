{"sha": "f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZDE3OWRkMTJkNDhkY2ZmNGE0YjhkMzA3M2JjZDNiNGFmMWFkM2Y=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-03-08T02:36:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-08T02:36:27Z"}, "message": "Merge pull request #2456 from dlukes/feat/check-license\n\nAttempt at checking for license (#209)", "tree": {"sha": "eb249f3b3d7d39dc94e67358432e83c3c9175ac4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb249f3b3d7d39dc94e67358432e83c3c9175ac4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaoKGrCRBK7hj4Ov3rIwAAdHIIAEH9KZI6GlZtlAXjYDp7g4lz\neOPd1af7r/wMi06OzsUcZoph6yF/pPLkrge1Gu3sAFQbG+Rw0ouZ8+kzFSHSuy3s\nO8ah3hOYi0wHxN5mAa97JleachNMo4fPlzQmjjsnOvgHSNlJSgIW+T6Zli8BEvjc\nbUpvUeRS60N/qZGy2TgZQiT2CsGtb5JgHe4PnSvGdENp2MjU/Q9qCPKUWaonuk9G\ns4951fgjcu+ZwSiiHbLEN3O/D4bV+JCD9YXMAIdiz42Ff1a0KX8Huyxb4iUjvhZW\n5OQQk+4S1rMOZt2OTsbtS+vU8LX4E7ge7U8xQ2uY63edvJDDJxLwEzZC3dAzKn0=\n=UQLb\n-----END PGP SIGNATURE-----\n", "payload": "tree eb249f3b3d7d39dc94e67358432e83c3c9175ac4\nparent e01753909fe1be66478abdb57af39d8874a96112\nparent 01f652799d94140493e97a7af9ad3b696fdba5e1\nauthor Nick Cameron <nrc@ncameron.org> 1520476587 +1300\ncommitter GitHub <noreply@github.com> 1520476587 +1300\n\nMerge pull request #2456 from dlukes/feat/check-license\n\nAttempt at checking for license (#209)"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "html_url": "https://github.com/rust-lang/rust/commit/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e01753909fe1be66478abdb57af39d8874a96112", "url": "https://api.github.com/repos/rust-lang/rust/commits/e01753909fe1be66478abdb57af39d8874a96112", "html_url": "https://github.com/rust-lang/rust/commit/e01753909fe1be66478abdb57af39d8874a96112"}, {"sha": "01f652799d94140493e97a7af9ad3b696fdba5e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/01f652799d94140493e97a7af9ad3b696fdba5e1", "html_url": "https://github.com/rust-lang/rust/commit/01f652799d94140493e97a7af9ad3b696fdba5e1"}], "stats": {"total": 342, "additions": 335, "deletions": 7}, "files": [{"sha": "8540bc36383f0ee41784a049465923a7df87a56a", "filename": "Configurations.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "patch": "@@ -2115,3 +2115,23 @@ Enable unstable featuers on stable channel.\n - **Default value**: `false`\n - **Possible values**: `true`, `false`\n - **Stable**: Yes\n+\n+## `license_template_path`\n+\n+Check whether beginnings of files match a license template.\n+\n+- **Default value**: `\"\"``\n+- **Possible values**: path to a license template file\n+- **Stable**: No\n+\n+A license template is a plain text file which is matched literally against the\n+beginning of each source file, except for `{}`-delimited blocks, which are\n+matched as regular expressions. The following license template therefore\n+matches strings like `// Copyright 2017 The Rust Project Developers.`, `//\n+Copyright 2018 The Rust Project Developers.`, etc.:\n+\n+```\n+// Copyright {\\d+} The Rust Project Developers.\n+```\n+\n+`\\{`, `\\}` and `\\\\` match literal braces / backslashes."}, {"sha": "dc768490fbbaf676684656981340db7cce96775c", "filename": "src/config/config_type.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "patch": "@@ -78,6 +78,9 @@ macro_rules! create_config {\n \n         #[derive(Clone)]\n         pub struct Config {\n+            // if a license_template_path has been specified, successfully read, parsed and compiled\n+            // into a regex, it will be stored here\n+            pub license_template: Option<Regex>,\n             // For each config item, we store a bool indicating whether it has\n             // been accessed and the value, and a bool whether the option was\n             // manually initialised, or taken from the default,\n@@ -118,8 +121,10 @@ macro_rules! create_config {\n             $(\n             pub fn $i(&mut self, value: $ty) {\n                 (self.0).$i.2 = value;\n-                if stringify!($i) == \"use_small_heuristics\" {\n-                    self.0.set_heuristics();\n+                match stringify!($i) {\n+                    \"use_small_heuristics\" => self.0.set_heuristics(),\n+                    \"license_template_path\" => self.0.set_license_template(),\n+                    &_ => (),\n                 }\n             }\n             )+\n@@ -189,6 +194,7 @@ macro_rules! create_config {\n                 }\n             )+\n                 self.set_heuristics();\n+                self.set_license_template();\n                 self\n             }\n \n@@ -276,8 +282,10 @@ macro_rules! create_config {\n                     _ => panic!(\"Unknown config key in override: {}\", key)\n                 }\n \n-                if key == \"use_small_heuristics\" {\n-                    self.set_heuristics();\n+                match key {\n+                    \"use_small_heuristics\" => self.set_heuristics(),\n+                    \"license_template_path\" => self.set_license_template(),\n+                    &_ => (),\n                 }\n             }\n \n@@ -382,12 +390,24 @@ macro_rules! create_config {\n                     self.set().width_heuristics(WidthHeuristics::null());\n                 }\n             }\n+\n+            fn set_license_template(&mut self) {\n+                if self.was_set().license_template_path() {\n+                    let lt_path = self.license_template_path();\n+                    match license::load_and_compile_template(&lt_path) {\n+                        Ok(re) => self.license_template = Some(re),\n+                        Err(msg) => eprintln!(\"Warning for license template file {:?}: {}\",\n+                                              lt_path, msg),\n+                    }\n+                }\n+            }\n         }\n \n         // Template for the default configuration\n         impl Default for Config {\n             fn default() -> Config {\n                 Config {\n+                    license_template: None,\n                     $(\n                         $i: (Cell::new(false), false, $def, $stb),\n                     )+"}, {"sha": "b2babd5ac1915567e264a480c3755715e54332f8", "filename": "src/config/license.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/src%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/src%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flicense.rs?ref=f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "patch": "@@ -0,0 +1,267 @@\n+use std::io;\n+use std::fmt;\n+use std::fs::File;\n+use std::io::Read;\n+\n+use regex;\n+use regex::Regex;\n+\n+#[derive(Debug)]\n+pub enum LicenseError {\n+    IO(io::Error),\n+    Regex(regex::Error),\n+    Parse(String),\n+}\n+\n+impl fmt::Display for LicenseError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            LicenseError::IO(ref err) => err.fmt(f),\n+            LicenseError::Regex(ref err) => err.fmt(f),\n+            LicenseError::Parse(ref err) => write!(f, \"parsing failed, {}\", err),\n+        }\n+    }\n+}\n+\n+impl From<io::Error> for LicenseError {\n+    fn from(err: io::Error) -> LicenseError {\n+        LicenseError::IO(err)\n+    }\n+}\n+\n+impl From<regex::Error> for LicenseError {\n+    fn from(err: regex::Error) -> LicenseError {\n+        LicenseError::Regex(err)\n+    }\n+}\n+\n+// the template is parsed using a state machine\n+enum ParsingState {\n+    Lit,\n+    LitEsc,\n+    // the u32 keeps track of brace nesting\n+    Re(u32),\n+    ReEsc(u32),\n+    Abort(String),\n+}\n+\n+use self::ParsingState::*;\n+\n+pub struct TemplateParser {\n+    parsed: String,\n+    buffer: String,\n+    state: ParsingState,\n+    linum: u32,\n+    open_brace_line: u32,\n+}\n+\n+impl TemplateParser {\n+    fn new() -> Self {\n+        Self {\n+            parsed: \"^\".to_owned(),\n+            buffer: String::new(),\n+            state: Lit,\n+            linum: 1,\n+            // keeps track of last line on which a regex placeholder was started\n+            open_brace_line: 0,\n+        }\n+    }\n+\n+    /// Convert a license template into a string which can be turned into a regex.\n+    ///\n+    /// The license template could use regex syntax directly, but that would require a lot of manual\n+    /// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n+    /// subparts delimited by `{` and `}`. Additionally:\n+    ///\n+    /// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n+    /// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n+    ///\n+    /// This function parses this input format and builds a properly escaped *string* representation\n+    /// of the equivalent regular expression. It **does not** however guarantee that the returned\n+    /// string is a syntactically valid regular expression.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # use rustfmt_nightly::config::license::TemplateParser;\n+    /// assert_eq!(\n+    ///     TemplateParser::parse(\n+    ///         r\"\n+    /// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n+    /// // file at the top-level directory of this distribution and at\n+    /// // {}.\n+    /// //\n+    /// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+    /// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+    /// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+    /// // option. This file may not be copied, modified, or distributed\n+    /// // except according to those terms.\n+    /// \"\n+    ///     ).unwrap(),\n+    ///     r\"^\n+    /// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n+    /// // file at the top\\-level directory of this distribution and at\n+    /// // .*?\\.\n+    /// //\n+    /// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n+    /// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n+    /// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n+    /// // option\\. This file may not be copied, modified, or distributed\n+    /// // except according to those terms\\.\n+    /// \"\n+    /// );\n+    /// ```\n+    pub fn parse(template: &str) -> Result<String, LicenseError> {\n+        let mut parser = Self::new();\n+        for chr in template.chars() {\n+            if chr == '\\n' {\n+                parser.linum += 1;\n+            }\n+            parser.state = match parser.state {\n+                Lit => parser.trans_from_lit(chr),\n+                LitEsc => parser.trans_from_litesc(chr),\n+                Re(brace_nesting) => parser.trans_from_re(chr, brace_nesting),\n+                ReEsc(brace_nesting) => parser.trans_from_reesc(chr, brace_nesting),\n+                Abort(msg) => return Err(LicenseError::Parse(msg)),\n+            };\n+        }\n+        // check if we've ended parsing in a valid state\n+        match parser.state {\n+            Abort(msg) => return Err(LicenseError::Parse(msg)),\n+            Re(_) | ReEsc(_) => {\n+                return Err(LicenseError::Parse(format!(\n+                    \"escape or balance opening brace on l. {}\",\n+                    parser.open_brace_line\n+                )));\n+            }\n+            LitEsc => {\n+                return Err(LicenseError::Parse(format!(\n+                    \"incomplete escape sequence on l. {}\",\n+                    parser.linum\n+                )))\n+            }\n+            _ => (),\n+        }\n+        parser.parsed.push_str(&regex::escape(&parser.buffer));\n+\n+        Ok(parser.parsed)\n+    }\n+\n+    fn trans_from_lit(&mut self, chr: char) -> ParsingState {\n+        match chr {\n+            '{' => {\n+                self.parsed.push_str(&regex::escape(&self.buffer));\n+                self.buffer.clear();\n+                self.open_brace_line = self.linum;\n+                Re(1)\n+            }\n+            '}' => Abort(format!(\n+                \"escape or balance closing brace on l. {}\",\n+                self.linum\n+            )),\n+            '\\\\' => LitEsc,\n+            _ => {\n+                self.buffer.push(chr);\n+                Lit\n+            }\n+        }\n+    }\n+\n+    fn trans_from_litesc(&mut self, chr: char) -> ParsingState {\n+        self.buffer.push(chr);\n+        Lit\n+    }\n+\n+    fn trans_from_re(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n+        match chr {\n+            '{' => {\n+                self.buffer.push(chr);\n+                Re(brace_nesting + 1)\n+            }\n+            '}' => {\n+                match brace_nesting {\n+                    1 => {\n+                        // default regex for empty placeholder {}\n+                        if self.buffer.is_empty() {\n+                            self.parsed.push_str(\".*?\");\n+                        } else {\n+                            self.parsed.push_str(&self.buffer);\n+                        }\n+                        self.buffer.clear();\n+                        Lit\n+                    }\n+                    _ => {\n+                        self.buffer.push(chr);\n+                        Re(brace_nesting - 1)\n+                    }\n+                }\n+            }\n+            '\\\\' => {\n+                self.buffer.push(chr);\n+                ReEsc(brace_nesting)\n+            }\n+            _ => {\n+                self.buffer.push(chr);\n+                Re(brace_nesting)\n+            }\n+        }\n+    }\n+\n+    fn trans_from_reesc(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n+        self.buffer.push(chr);\n+        Re(brace_nesting)\n+    }\n+}\n+\n+pub fn load_and_compile_template(path: &str) -> Result<Regex, LicenseError> {\n+    let mut lt_file = File::open(&path)?;\n+    let mut lt_str = String::new();\n+    lt_file.read_to_string(&mut lt_str)?;\n+    let lt_parsed = TemplateParser::parse(&lt_str)?;\n+    Ok(Regex::new(&lt_parsed)?)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::TemplateParser;\n+\n+    #[test]\n+    fn test_parse_license_template() {\n+        assert_eq!(\n+            TemplateParser::parse(\"literal (.*)\").unwrap(),\n+            r\"^literal \\(\\.\\*\\)\"\n+        );\n+        assert_eq!(\n+            TemplateParser::parse(r\"escaping \\}\").unwrap(),\n+            r\"^escaping \\}\"\n+        );\n+        assert!(TemplateParser::parse(\"unbalanced } without escape\").is_err());\n+        assert_eq!(\n+            TemplateParser::parse(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n+            r\"^\\d+ place-?holders?\"\n+        );\n+        assert_eq!(TemplateParser::parse(\"default {}\").unwrap(), \"^default .*?\");\n+        assert_eq!(\n+            TemplateParser::parse(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n+            r\"^unbalanced nested braces \\{{3}\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(\"parsing error }\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, escape or balance closing brace on l. 1\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(\"parsing error {\\nsecond line\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, escape or balance opening brace on l. 1\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(r\"parsing error \\\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, incomplete escape sequence on l. 1\"\n+        );\n+    }\n+}"}, {"sha": "0d4ec8557d383f334b617dec15f346ab927fd9c4", "filename": "src/config/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "patch": "@@ -15,6 +15,8 @@ use std::fs::File;\n use std::io::{Error, ErrorKind, Read};\n use std::path::{Path, PathBuf};\n \n+use regex::Regex;\n+\n #[macro_use]\n mod config_type;\n #[macro_use]\n@@ -23,6 +25,7 @@ mod options;\n pub mod file_lines;\n pub mod lists;\n pub mod summary;\n+pub mod license;\n \n use config::config_type::ConfigType;\n use config::file_lines::FileLines;\n@@ -50,6 +53,7 @@ create_config! {\n     comment_width: usize, 80, false,\n         \"Maximum length of comments. No effect unless wrap_comments = true\";\n     normalize_comments: bool, false, true, \"Convert /* */ comments to // comments where possible\";\n+    license_template_path: String, String::default(), false, \"Beginning of file must match license template\";\n \n     // Single line expressions and items.\n     empty_item_single_line: bool, true, false,"}, {"sha": "e53f8bfb90762afda4e0d940932eb1f2eadd4bf7", "filename": "src/lib.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f0d179dd12d48dcff4a4b8d3073bcd3b4af1ad3f", "patch": "@@ -99,6 +99,8 @@ pub enum ErrorKind {\n     TrailingWhitespace,\n     // TO-DO or FIX-ME item without an issue number\n     BadIssue(Issue),\n+    // License check has failed\n+    LicenseCheck,\n }\n \n impl fmt::Display for ErrorKind {\n@@ -111,6 +113,7 @@ impl fmt::Display for ErrorKind {\n             ),\n             ErrorKind::TrailingWhitespace => write!(fmt, \"left behind trailing whitespace\"),\n             ErrorKind::BadIssue(issue) => write!(fmt, \"found {}\", issue),\n+            ErrorKind::LicenseCheck => write!(fmt, \"license check failed\"),\n         }\n     }\n }\n@@ -127,7 +130,9 @@ pub struct FormattingError {\n impl FormattingError {\n     fn msg_prefix(&self) -> &str {\n         match self.kind {\n-            ErrorKind::LineOverflow(..) | ErrorKind::TrailingWhitespace => \"error:\",\n+            ErrorKind::LineOverflow(..)\n+            | ErrorKind::TrailingWhitespace\n+            | ErrorKind::LicenseCheck => \"error:\",\n             ErrorKind::BadIssue(_) => \"WARNING:\",\n         }\n     }\n@@ -406,7 +411,6 @@ fn should_report_error(\n }\n \n // Formatting done on a char by char or line by line basis.\n-// FIXME(#209) warn on bad license\n // FIXME(#20) other stuff for parity with make tidy\n fn format_lines(\n     text: &mut String,\n@@ -415,7 +419,6 @@ fn format_lines(\n     config: &Config,\n     report: &mut FormatReport,\n ) {\n-    // Iterate over the chars in the file map.\n     let mut trims = vec![];\n     let mut last_wspace: Option<usize> = None;\n     let mut line_len = 0;\n@@ -428,6 +431,20 @@ fn format_lines(\n     let mut format_line = config.file_lines().contains_line(name, cur_line);\n     let allow_issue_seek = !issue_seeker.is_disabled();\n \n+    // Check license.\n+    if let Some(ref license_template) = config.license_template {\n+        if !license_template.is_match(text) {\n+            errors.push(FormattingError {\n+                line: cur_line,\n+                kind: ErrorKind::LicenseCheck,\n+                is_comment: false,\n+                is_string: false,\n+                line_buffer: String::new(),\n+            });\n+        }\n+    }\n+\n+    // Iterate over the chars in the file map.\n     for (kind, (b, c)) in CharClasses::new(text.chars().enumerate()) {\n         if c == '\\r' {\n             continue;"}]}