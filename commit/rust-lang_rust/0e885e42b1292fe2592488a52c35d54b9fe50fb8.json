{"sha": "0e885e42b1292fe2592488a52c35d54b9fe50fb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlODg1ZTQyYjEyOTJmZTI1OTI0ODhhNTJjMzVkNTRiOWZlNTBmYjg=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-14T07:46:58Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-15T03:01:40Z"}, "message": "remove reference counting headers from ~\n\nUnique pointers and vectors currently contain a reference counting\nheader when containing a managed pointer.\n\nThis `{ ref_count, type_desc, prev, next }` header is not necessary and\nnot a sensible foundation for tracing. It adds needless complexity to\nlibrary code and is responsible for breakage in places where the branch\nhas been left out.\n\nThe `borrow_offset` field can now be removed from `TyDesc` along with\nthe associated handling in the compiler.\n\nCloses #9510\nCloses #11533", "tree": {"sha": "d2490dba4da83d502bb4499c80395506d6f54211", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2490dba4da83d502bb4499c80395506d6f54211"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e885e42b1292fe2592488a52c35d54b9fe50fb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e885e42b1292fe2592488a52c35d54b9fe50fb8", "html_url": "https://github.com/rust-lang/rust/commit/0e885e42b1292fe2592488a52c35d54b9fe50fb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e885e42b1292fe2592488a52c35d54b9fe50fb8/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9075025c7b48ffc028b3bddbb983ceac98ce9636", "url": "https://api.github.com/repos/rust-lang/rust/commits/9075025c7b48ffc028b3bddbb983ceac98ce9636", "html_url": "https://github.com/rust-lang/rust/commit/9075025c7b48ffc028b3bddbb983ceac98ce9636"}], "stats": {"total": 300, "additions": 152, "deletions": 148}, "files": [{"sha": "a7924946ed185d885e8398a9a2c858d7dff2f3b5", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -1584,14 +1584,9 @@ fn compile_submatch_continue<'r,\n     }\n \n     if any_uniq_pat(m, col) {\n-        let pat_ty = node_id_type(bcx, pat_id);\n         let llbox = Load(bcx, val);\n-        let unboxed = match ty::get(pat_ty).sty {\n-            ty::ty_uniq(..) if !ty::type_contents(bcx.tcx(), pat_ty).owns_managed() => llbox,\n-            _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n-        };\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n-                         vec::append(~[unboxed], vals_left), chk);\n+                         vec::append(~[llbox], vals_left), chk);\n         return;\n     }\n \n@@ -2231,13 +2226,8 @@ fn bind_irrefutable_pat<'a>(\n             }\n         }\n         ast::PatUniq(inner) => {\n-            let pat_ty = node_id_type(bcx, pat.id);\n             let llbox = Load(bcx, val);\n-            let unboxed = match ty::get(pat_ty).sty {\n-                ty::ty_uniq(..) if !ty::type_contents(bcx.tcx(), pat_ty).owns_managed() => llbox,\n-                    _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n-            };\n-            bcx = bind_irrefutable_pat(bcx, inner, unboxed, binding_mode);\n+            bcx = bind_irrefutable_pat(bcx, inner, llbox, binding_mode);\n         }\n         ast::PatRegion(inner) => {\n             let loaded_val = Load(bcx, val);"}, {"sha": "a7e5dfcf67b684e2e25b7d77c57b31907214ab8b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -358,7 +358,7 @@ pub fn malloc_raw_dyn<'a>(\n     } else {\n         // we treat ~fn, @fn and @[] as @ here, which isn't ideal\n         let langcall = match heap {\n-            heap_managed | heap_managed_unique => {\n+            heap_managed => {\n                 require_alloc_fn(bcx, t, MallocFnLangItem)\n             }\n             heap_exchange_closure => {\n@@ -382,9 +382,7 @@ pub fn malloc_raw_dyn<'a>(\n             langcall,\n             [tydesc, size],\n             None);\n-        let r = rslt(r.bcx, PointerCast(r.bcx, r.val, llty));\n-        maybe_set_managed_unique_rc(r.bcx, r.val, heap);\n-        r\n+        rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n     }\n }\n \n@@ -431,27 +429,6 @@ pub fn malloc_general<'a>(bcx: &'a Block, t: ty::t, heap: heap)\n     malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n \n-pub fn heap_for_unique(bcx: &Block, t: ty::t) -> heap {\n-    if ty::type_contents(bcx.tcx(), t).owns_managed() {\n-        heap_managed_unique\n-    } else {\n-        heap_exchange\n-    }\n-}\n-\n-pub fn maybe_set_managed_unique_rc(bcx: &Block, bx: ValueRef, heap: heap) {\n-    assert!(heap != heap_exchange);\n-    if heap == heap_managed_unique {\n-        // In cases where we are looking at a unique-typed allocation in the\n-        // managed heap (thus have refcount 1 from the managed allocator),\n-        // such as a ~(@foo) or such. These need to have their refcount forced\n-        // to -2 so the annihilator ignores them.\n-        let rc = GEPi(bcx, bx, [0u, abi::box_field_refcnt]);\n-        let rc_val = C_int(bcx.ccx(), -2);\n-        Store(bcx, rc_val, rc);\n-    }\n-}\n-\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc_simple(ccx: &CrateContext, t: ty::t) -> ValueRef {"}, {"sha": "f3d061f70b1503aab3444241061dc363edb5884c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -150,14 +150,6 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn heap_for_unique_closure(bcx: &Block, t: ty::t) -> heap {\n-    if ty::type_contents(bcx.tcx(), t).owns_managed() {\n-        heap_managed_unique\n-    } else {\n-        heap_exchange_closure\n-    }\n-}\n-\n pub fn allocate_cbox<'a>(\n                      bcx: &'a Block<'a>,\n                      sigil: ast::Sigil,\n@@ -173,7 +165,7 @@ pub fn allocate_cbox<'a>(\n             tcx.sess.bug(\"trying to trans allocation of @fn\")\n         }\n         ast::OwnedSigil => {\n-            malloc_raw(bcx, cdata_ty, heap_for_unique_closure(bcx, cdata_ty))\n+            malloc_raw(bcx, cdata_ty, heap_exchange_closure)\n         }\n         ast::BorrowedSigil => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);"}, {"sha": "fb0b241b5fc342ca7e8fee33ad9e59b4327457b0", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -316,7 +316,6 @@ pub fn warn_not_to_commit(ccx: &CrateContext, msg: &str) {\n #[deriving(Eq)]\n pub enum heap {\n     heap_managed,\n-    heap_managed_unique,\n     heap_exchange,\n     heap_exchange_closure\n }\n@@ -498,7 +497,7 @@ pub fn add_clean_temp_mem_in_scope_(bcx: &Block, scope_id: Option<ast::NodeId>,\n \n pub fn add_clean_free(cx: &Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n-        heap_managed | heap_managed_unique => {\n+        heap_managed => {\n             @GCHeapFreeingCleanupFunction {\n                 ptr: ptr,\n             } as @CleanupFunction"}, {"sha": "c2591beac4a7d39703bafd62ddce4d8b36ad1cce", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -570,19 +570,14 @@ impl Datum {\n         let (content_ty, header) = match ty::get(self.ty).sty {\n             ty::ty_box(typ) => (typ, true),\n             ty::ty_uniq(typ) => (typ, false),\n-            ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n-                let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);\n-                let unboxed_vec_ty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n-                (unboxed_vec_ty, true)\n-            }\n             _ => {\n                 bcx.tcx().sess.bug(format!(\n                     \"box_body() invoked on non-box type {}\",\n                     ty_to_str(bcx.tcx(), self.ty)));\n             }\n         };\n \n-        if !header && !ty::type_contents(bcx.tcx(), content_ty).owns_managed() {\n+        if !header {\n             let ptr = self.to_value_llval(bcx);\n             let ty = type_of::type_of(bcx.ccx(), content_ty);\n             let body = PointerCast(bcx, ptr, ty.ptr_to());"}, {"sha": "4e8b3c78dc8721545ccdf8ca21dc61a34c3d03d4", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -2147,10 +2147,6 @@ fn type_metadata(cx: &CrateContext,\n                 ty::vstore_fixed(len) => {\n                     fixed_vec_metadata(cx, mt.ty, len, usage_site_span)\n                 }\n-                ty::vstore_uniq if ty::type_contents(cx.tcx, mt.ty).owns_managed() => {\n-                    let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, usage_site_span);\n-                    pointer_type_metadata(cx, t, boxed_vec_metadata)\n-                }\n                 ty::vstore_uniq => {\n                     let vec_metadata = vec_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n@@ -2165,12 +2161,8 @@ fn type_metadata(cx: &CrateContext,\n             }\n         },\n         ty::ty_uniq(typ) => {\n-            if ty::type_contents(cx.tcx, typ).owns_managed() {\n-                create_pointer_to_box_metadata(cx, t, typ)\n-            } else {\n-                let pointee = type_metadata(cx, typ, usage_site_span);\n-                pointer_type_metadata(cx, t, pointee)\n-            }\n+            let pointee = type_metadata(cx, typ, usage_site_span);\n+            pointer_type_metadata(cx, t, pointee)\n         }\n         ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n             let pointee = type_metadata(cx, mt.ty, usage_site_span);"}, {"sha": "7fb66c521b147bd3f8b7f7471131388bbe7252e5", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -608,16 +608,15 @@ fn trans_rvalue_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n                                                       expr, contents);\n         }\n         ast::ExprVstore(contents, ast::ExprVstoreUniq) => {\n-            let heap = heap_for_unique(bcx, expr_ty(bcx, contents));\n-            return tvec::trans_uniq_or_managed_vstore(bcx, heap,\n+            return tvec::trans_uniq_or_managed_vstore(bcx, heap_exchange,\n                                                       expr, contents);\n         }\n         ast::ExprBox(_, contents) => {\n             // Special case for `~T`. (The other case, for GC, is handled in\n             // `trans_rvalue_dps_unadjusted`.)\n             let box_ty = expr_ty(bcx, expr);\n             let contents_ty = expr_ty(bcx, contents);\n-            let heap = heap_for_unique(bcx, contents_ty);\n+            let heap = heap_exchange;\n             return trans_boxed_expr(bcx, box_ty, contents, contents_ty, heap)\n         }\n         ast::ExprLit(lit) => {\n@@ -1461,8 +1460,7 @@ fn trans_unary_datum<'a>(\n             trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_managed)\n         }\n         ast::UnUniq => {\n-            let heap  = heap_for_unique(bcx, un_ty);\n-            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap)\n+            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_exchange)\n         }\n         ast::UnDeref => {\n             bcx.sess().bug(\"deref expressions should have been \\"}, {"sha": "457cac09fc5a23e0981127b62844ea19b921d43a", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -303,11 +303,7 @@ pub fn make_free_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n         with_cond(bcx, not_null, |bcx| {\n             let body_datum = box_datum.box_body(bcx);\n             let bcx = drop_ty(bcx, body_datum.to_ref_llval(bcx), body_datum.ty);\n-            if ty::type_contents(bcx.tcx(), t).owns_managed() {\n-                trans_free(bcx, box_datum.val)\n-            } else {\n-                trans_exchange_free(bcx, box_datum.val)\n-            }\n+            trans_exchange_free(bcx, box_datum.val)\n         })\n       }\n       ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) |\n@@ -552,7 +548,6 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n \n     let has_header = match ty::get(t).sty {\n         ty::ty_box(..) => true,\n-        ty::ty_uniq(..) => ty::type_contents(ccx.tcx, t).owns_managed(),\n         _ => false\n     };\n "}, {"sha": "2a8c23a6c32a4501b08464f65658937db1b5d3d1", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -184,11 +184,7 @@ impl<'a> Reflector<'a> {\n           ty::ty_vec(ref mt, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               let extra = extra + self.c_mt(mt);\n-              if \"uniq\" == name && ty::type_contents(bcx.tcx(), t).owns_managed() {\n-                  self.visit(\"evec_uniq_managed\", extra)\n-              } else {\n-                  self.visit(~\"evec_\" + name, extra)\n-              }\n+              self.visit(~\"evec_\" + name, extra)\n           }\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n@@ -203,11 +199,7 @@ impl<'a> Reflector<'a> {\n                   ty: typ,\n                   mutbl: ast::MutImmutable,\n               });\n-              if ty::type_contents(bcx.tcx(), t).owns_managed() {\n-                  self.visit(\"uniq_managed\", extra)\n-              } else {\n-                  self.visit(\"uniq\", extra)\n-              }\n+              self.visit(\"uniq\", extra)\n           }\n           ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);"}, {"sha": "100f28af97dad94b9ce34b3b1fa0490297ca7d58", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -64,7 +64,14 @@ pub fn get_alloc(bcx: &Block, vptr: ValueRef) -> ValueRef {\n }\n \n pub fn get_bodyptr(bcx: &Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n-    if ty::type_contents(bcx.tcx(), t).owns_managed() {\n+    let vt = vec_types(bcx, t);\n+\n+    let managed = match ty::get(vt.vec_ty).sty {\n+      ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => true,\n+      _ => false\n+    };\n+\n+    if managed {\n         GEPi(bcx, vptr, [0u, abi::box_field_body])\n     } else {\n         vptr\n@@ -106,7 +113,6 @@ pub fn alloc_raw<'a>(\n             base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n         Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n         Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n-        base::maybe_set_managed_unique_rc(bcx, bx, heap);\n         return rslt(bcx, bx);\n     }\n }\n@@ -117,7 +123,7 @@ pub fn alloc_uniq_raw<'a>(\n                       fill: ValueRef,\n                       alloc: ValueRef)\n                       -> Result<'a> {\n-    alloc_raw(bcx, unit_ty, fill, alloc, base::heap_for_unique(bcx, unit_ty))\n+    alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n }\n \n pub fn alloc_vec<'a>(\n@@ -350,7 +356,7 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n             }\n         }\n         heap_exchange_closure => fail!(\"vectors use exchange_alloc\"),\n-        heap_managed | heap_managed_unique => {}\n+        heap_managed => {}\n     }\n \n     let vt = vec_types_from_expr(bcx, vstore_expr);"}, {"sha": "b5349ca323b1d5d9494ad1bd441329e7305fe979", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -269,10 +269,6 @@ impl Type {\n         Type::smart_ptr(ctx, &Type::opaque())\n     }\n \n-    pub fn unique(ctx: &CrateContext, ty: &Type) -> Type {\n-        Type::smart_ptr(ctx, ty)\n-    }\n-\n     pub fn opaque_cbox_ptr(cx: &CrateContext) -> Type {\n         Type::opaque_box(cx).ptr_to()\n     }\n@@ -281,7 +277,7 @@ impl Type {\n         let tydesc_ptr = ctx.tydesc_type.ptr_to();\n         let box_ty = match store {\n             ty::BoxTraitStore => Type::opaque_box(ctx),\n-            ty::UniqTraitStore => Type::unique(ctx, &Type::i8()),\n+            ty::UniqTraitStore => Type::i8(),\n             ty::RegionTraitStore(..) => Type::i8()\n         };\n         Type::struct_([tydesc_ptr, box_ty.ptr_to()], false)"}, {"sha": "ae96f43b07d3633f545a5646d717a746d20e64db", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -245,21 +245,11 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           Type::smart_ptr(cx, &ty).ptr_to()\n       }\n       ty::ty_uniq(typ) => {\n-          let ty = type_of(cx, typ);\n-          if ty::type_contents(cx.tcx, typ).owns_managed() {\n-              Type::unique(cx, &ty).ptr_to()\n-          } else {\n-              ty.ptr_to()\n-          }\n+          type_of(cx, typ).ptr_to()\n       }\n       ty::ty_vec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n-          let ty = Type::vec(cx.sess.targ_cfg.arch, &ty);\n-          if ty::type_contents(cx.tcx, mt.ty).owns_managed() {\n-              Type::unique(cx, &ty).ptr_to()\n-          } else {\n-              ty.ptr_to()\n-          }\n+          Type::vec(cx.sess.targ_cfg.arch, &ty).ptr_to()\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n           let ty = type_of(cx, mt.ty);"}, {"sha": "48e796f0f4a53941a8fd87e90f63832688d14d9c", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -230,4 +230,12 @@ mod tests {\n         drop(x);\n         assert!(y.upgrade().is_none());\n     }\n+\n+    #[test]\n+    fn gc_inside() {\n+        // see issue #11532\n+        use gc::Gc;\n+        let a = Rc::new(RefCell::new(Gc::new(1)));\n+        assert!(a.borrow().try_borrow_mut().is_some());\n+    }\n }"}, {"sha": "c4a5561a7aad32539d3b01078f62c6121b89a711", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -227,6 +227,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n         if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n@@ -275,6 +276,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[@u8]>();\n         if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }"}, {"sha": "8539717544d5e45989e7f94fe57bd6b4244e317c", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -310,6 +310,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n+    #[cfg(stage0)]\n     fn visit_uniq_managed(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['~' as u8]);\n         self.get::<&raw::Box<()>>(|this, b| {\n@@ -358,6 +359,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n+    #[cfg(stage0)]\n     fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n             this.writer.write(['~' as u8]);"}, {"sha": "269622d02c03c72df2a689b8fb91995b99a514bc", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -146,6 +146,7 @@ pub trait TyVisitor {\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    #[cfg(stage0)]\n     fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n@@ -154,6 +155,7 @@ pub trait TyVisitor {\n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    #[cfg(stage0)]\n     fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,"}, {"sha": "df4d82678d3347f62f433d1a330304ff73825f2c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -116,14 +116,18 @@ use ptr::to_unsafe_ptr;\n use ptr;\n use ptr::RawPtr;\n use rt::global_heap::{malloc_raw, realloc_raw, exchange_free};\n+#[cfg(stage0)]\n use rt::local_heap::local_free;\n use mem;\n use mem::size_of;\n use uint;\n use unstable::finally::Finally;\n use unstable::intrinsics;\n+#[cfg(stage0)]\n use unstable::intrinsics::{get_tydesc, owns_managed};\n-use unstable::raw::{Box, Repr, Slice, Vec};\n+use unstable::raw::{Repr, Slice, Vec};\n+#[cfg(stage0)]\n+use unstable::raw::Box;\n use util;\n \n /**\n@@ -178,6 +182,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n \n /// Creates a new vector with a capacity of `capacity`\n #[inline]\n+#[cfg(stage0)]\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     unsafe {\n         if owns_managed::<T>() {\n@@ -198,6 +203,23 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     }\n }\n \n+/// Creates a new vector with a capacity of `capacity`\n+#[inline]\n+#[cfg(not(stage0))]\n+pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n+    unsafe {\n+        let alloc = capacity * mem::nonzero_size_of::<T>();\n+        let size = alloc + mem::size_of::<Vec<()>>();\n+        if alloc / mem::nonzero_size_of::<T>() != capacity || size < alloc {\n+            fail!(\"vector size is too large: {}\", capacity);\n+        }\n+        let ptr = malloc_raw(size) as *mut Vec<()>;\n+        (*ptr).alloc = alloc;\n+        (*ptr).fill = 0;\n+        cast::transmute(ptr)\n+    }\n+}\n+\n /**\n  * Builds a vector by calling a provided function with an argument\n  * function that pushes an element to the back of a vector.\n@@ -1481,6 +1503,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.move_iter().invert()\n     }\n \n+    #[cfg(stage0)]\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if self.capacity() < n {\n@@ -1504,6 +1527,24 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    fn reserve(&mut self, n: uint) {\n+        // Only make the (slow) call into the runtime if we have to\n+        if self.capacity() < n {\n+            unsafe {\n+                let ptr: *mut *mut Vec<()> = cast::transmute(self);\n+                let alloc = n * mem::nonzero_size_of::<T>();\n+                let size = alloc + mem::size_of::<Vec<()>>();\n+                if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n+                    fail!(\"vector size is too large: {}\", n);\n+                }\n+                *ptr = realloc_raw(*ptr as *mut c_void, size)\n+                       as *mut Vec<()>;\n+                (**ptr).alloc = alloc;\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two_opt(n).unwrap_or(n));\n@@ -1520,6 +1561,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     fn capacity(&self) -> uint {\n         unsafe {\n             if owns_managed::<T>() {\n@@ -1532,6 +1574,15 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn capacity(&self) -> uint {\n+        unsafe {\n+            let repr: **Vec<()> = cast::transmute(self);\n+            (**repr).alloc / mem::nonzero_size_of::<T>()\n+        }\n+    }\n+\n     fn shrink_to_fit(&mut self) {\n         unsafe {\n             let ptr: *mut *mut Vec<()> = cast::transmute(self);\n@@ -1543,6 +1594,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     fn push(&mut self, t: T) {\n         unsafe {\n             if owns_managed::<T>() {\n@@ -1583,7 +1635,31 @@ impl<T> OwnedVector<T> for ~[T] {\n                 intrinsics::move_val_init(&mut(*p), t);\n             }\n         }\n+    }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn push(&mut self, t: T) {\n+        unsafe {\n+            let repr: **Vec<()> = cast::transmute(&mut *self);\n+            let fill = (**repr).fill;\n+            if (**repr).alloc <= fill {\n+                self.reserve_additional(1);\n+            }\n+\n+            push_fast(self, t);\n+        }\n+\n+        // This doesn't bother to make sure we have space.\n+        #[inline] // really pretty please\n+        unsafe fn push_fast<T>(this: &mut ~[T], t: T) {\n+            let repr: **mut Vec<u8> = cast::transmute(this);\n+            let fill = (**repr).fill;\n+            (**repr).fill += mem::nonzero_size_of::<T>();\n+            let p = to_unsafe_ptr(&((**repr).data));\n+            let p = ptr::offset(p, fill as int) as *mut T;\n+            intrinsics::move_val_init(&mut(*p), t);\n+        }\n     }\n \n     #[inline]\n@@ -1746,6 +1822,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n     #[inline]\n+    #[cfg(stage0)]\n     unsafe fn set_len(&mut self, new_len: uint) {\n         if owns_managed::<T>() {\n             let repr: **mut Box<Vec<()>> = cast::transmute(self);\n@@ -1755,6 +1832,13 @@ impl<T> OwnedVector<T> for ~[T] {\n             (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n         }\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    unsafe fn set_len(&mut self, new_len: uint) {\n+        let repr: **mut Vec<()> = cast::transmute(self);\n+        (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n+    }\n }\n \n impl<T> Mutable for ~[T] {\n@@ -2926,6 +3010,7 @@ impl<T> DoubleEndedIterator<T> for MoveIterator<T> {\n }\n \n #[unsafe_destructor]\n+#[cfg(stage0)]\n impl<T> Drop for MoveIterator<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n@@ -2940,6 +3025,18 @@ impl<T> Drop for MoveIterator<T> {\n     }\n }\n \n+#[unsafe_destructor]\n+#[cfg(not(stage0))]\n+impl<T> Drop for MoveIterator<T> {\n+    fn drop(&mut self) {\n+        // destroy the remaining elements\n+        for _x in *self {}\n+        unsafe {\n+            exchange_free(self.allocation as *u8 as *c_char)\n+        }\n+    }\n+}\n+\n /// An iterator that moves out of a vector in reverse order.\n pub type MoveRevIterator<T> = Invert<MoveIterator<T>>;\n "}, {"sha": "8eed28170c57d2d08996ebdfaba46bba86ac85e8", "filename": "src/test/debug-info/managed-pointer-within-unique-vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique-vec.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -17,16 +17,16 @@\n // debugger:run\n // debugger:finish\n \n-// debugger:print unique->val.elements[0]->val\n+// debugger:print unique->elements[0]->val\n // check:$1 = 10\n \n-// debugger:print unique->val.elements[1]->val\n+// debugger:print unique->elements[1]->val\n // check:$2 = 11\n \n-// debugger:print unique->val.elements[2]->val\n+// debugger:print unique->elements[2]->val\n // check:$3 = 12\n \n-// debugger:print unique->val.elements[3]->val\n+// debugger:print unique->elements[3]->val\n // check:$4 = 13\n \n #[allow(unused_variable)];"}, {"sha": "4afc8b235edb6e9cd8d85e15273e9760d5d8d21e", "filename": "src/test/debug-info/managed-pointer-within-unique.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmanaged-pointer-within-unique.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -21,28 +21,22 @@\n // debugger:print *ordinary_unique\n // check:$1 = {-1, -2}\n \n-// debugger:print managed_within_unique.val->x\n+// debugger:print managed_within_unique->x\n // check:$2 = -3\n \n-// debugger:print managed_within_unique.val->y->val\n+// debugger:print managed_within_unique->y->val\n // check:$3 = -4\n \n #[allow(unused_variable)];\n \n-struct ContainsManaged\n-{\n-\tx: int,\n-\ty: @int\n+struct ContainsManaged {\n+    x: int,\n+    y: @int\n }\n \n fn main() {\n+    let ordinary_unique = ~(-1, -2);\n \n-\tlet ordinary_unique = ~(-1, -2);\n-\n-\n-\t// This is a special case: Normally values allocated in the exchange heap are not boxed, unless,\n-\t// however, if they contain managed pointers.\n-\t// This test case verifies that both cases are handled correctly.\n     let managed_within_unique = ~ContainsManaged { x: -3, y: @-4 };\n \n     zzz();"}, {"sha": "cf693d7e35623342f9efc4bcf0b43fa2de3ba905", "filename": "src/test/debug-info/recursive-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Frecursive-struct.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -49,9 +49,9 @@\n // debugger:print stack_managed.next.val->val.value\n // check:$12 = 11\n \n-// debugger:print unique_managed->val.value\n+// debugger:print unique_managed->value\n // check:$13 = 12\n-// debugger:print unique_managed->val.next.val->val.value\n+// debugger:print unique_managed->next.val->val.value\n // check:$14 = 13\n \n // debugger:print box_managed->val.value"}, {"sha": "e244eace65be626078c4f95eb9ca47f138a4bbe6", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -223,13 +223,6 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner().visit_uniq_managed(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner().visit_ptr(mtbl, inner) { return false; }\n@@ -275,13 +268,6 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[@u8]>();\n-        if ! self.inner().visit_evec_uniq_managed(mtbl, inner) { return false; }\n-        self.bump_past::<~[@u8]>();\n-        true\n-    }\n-\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner().visit_evec_slice(mtbl, inner) { return false; }\n@@ -549,15 +535,13 @@ impl TyVisitor for my_visitor {\n \n     fn visit_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq_managed(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n     fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_unboxed_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq_managed(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }"}, {"sha": "f5871facd1da21666312e4ab2d2a56516e9d5d97", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e885e42b1292fe2592488a52c35d54b9fe50fb8/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=0e885e42b1292fe2592488a52c35d54b9fe50fb8", "patch": "@@ -70,7 +70,6 @@ impl TyVisitor for MyVisitor {\n \n     fn visit_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq_managed(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n@@ -83,12 +82,6 @@ impl TyVisitor for MyVisitor {\n         self.types.push(~\"]\");\n         true\n     }\n-    fn visit_evec_uniq_managed(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.types.push(~\"[\");\n-        unsafe { visit_tydesc(inner, &mut *self as &mut TyVisitor) };\n-        self.types.push(~\"]\");\n-        true\n-    }\n     fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }"}]}