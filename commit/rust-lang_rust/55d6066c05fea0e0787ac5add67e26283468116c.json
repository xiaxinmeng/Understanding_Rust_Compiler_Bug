{"sha": "55d6066c05fea0e0787ac5add67e26283468116c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZDYwNjZjMDVmZWEwZTA3ODdhYzVhZGQ2N2UyNjI4MzQ2ODExNmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-19T20:45:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-30T21:02:58Z"}, "message": "remove ROOT_CODE_EXTENT and DUMMY_CODE_EXTENT\n\nInstead, thread around `Option<CodeExtent>` where applicable.", "tree": {"sha": "09a82ff684da81b61ee9904fe6060917eacda34a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09a82ff684da81b61ee9904fe6060917eacda34a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55d6066c05fea0e0787ac5add67e26283468116c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55d6066c05fea0e0787ac5add67e26283468116c", "html_url": "https://github.com/rust-lang/rust/commit/55d6066c05fea0e0787ac5add67e26283468116c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55d6066c05fea0e0787ac5add67e26283468116c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "119c38ea91ffe421a3331a600a2d18618f82bf4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/119c38ea91ffe421a3331a600a2d18618f82bf4f", "html_url": "https://github.com/rust-lang/rust/commit/119c38ea91ffe421a3331a600a2d18618f82bf4f"}], "stats": {"total": 295, "additions": 137, "deletions": 158}, "files": [{"sha": "10712f5ec704790cddd1978801b685f7ee46d0c2", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -69,6 +69,7 @@ use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, Issue32330};\n use ty::error::TypeError;\n+use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n use errors::{DiagnosticBuilder, DiagnosticStyledString};\n \n@@ -183,7 +184,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                let node = fr.scope.node_id(&self.region_maps());\n+                let node = fr.scope.map(|s| s.node_id(&self.region_maps()))\n+                                   .unwrap_or(DUMMY_NODE_ID);\n                 let unknown;\n                 let tag = match self.hir.find(node) {\n                     Some(hir_map::NodeBlock(_)) |"}, {"sha": "f9aab59acaf6cf262c73d0665e8f4094258c1658", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -938,18 +938,19 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 // A \"free\" region can be interpreted as \"some region\n                 // at least as big as the block fr.scope_id\".  So, we can\n                 // reasonably compare free regions and scopes:\n-                let r_id = self.tcx.region_maps().nearest_common_ancestor(fr.scope, s_id);\n-\n-                if r_id == fr.scope {\n-                    // if the free region's scope `fr.scope_id` is bigger than\n-                    // the scope region `s_id`, then the LUB is the free\n-                    // region itself:\n-                    self.tcx.mk_region(ReFree(fr))\n-                } else {\n-                    // otherwise, we don't know what the free region is,\n-                    // so we must conservatively say the LUB is static:\n-                    self.tcx.types.re_static\n+                if let Some(fr_scope) = fr.scope {\n+                    let r_id = self.tcx.region_maps().nearest_common_ancestor(fr_scope, s_id);\n+                    if r_id == fr_scope {\n+                        // if the free region's scope `fr.scope_id` is bigger than\n+                        // the scope region `s_id`, then the LUB is the free\n+                        // region itself:\n+                        return self.tcx.mk_region(ReFree(fr));\n+                    }\n                 }\n+\n+                // otherwise, we don't know what the free region is,\n+                // so we must conservatively say the LUB is static:\n+                self.tcx.types.re_static\n             }\n \n             (&ReScope(a_id), &ReScope(b_id)) => {"}, {"sha": "9701595a9d87296db448dd8de624d994c7734bbd", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -138,9 +138,14 @@ impl FreeRegionMap {\n                 (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n                     tcx.region_maps().is_subscope_of(sub_scope, super_scope),\n \n-                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) =>\n-                    tcx.region_maps().is_subscope_of(sub_scope, fr.scope) ||\n-                    self.is_static(fr),\n+                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) => {\n+                    // 1. It is safe to unwrap `fr.scope` because we\n+                    // should only ever wind up comparing against\n+                    // `ReScope` in the context of a method or fn\n+                    // body, where `fr.scope` should be `Some`.\n+                    tcx.region_maps().is_subscope_of(sub_scope, fr.scope.unwrap() /*1*/) ||\n+                        self.is_static(fr)\n+                }\n \n                 (&ty::ReFree(sub_fr), &ty::ReFree(super_fr)) =>\n                     self.sub_free_region(sub_fr, super_fr),\n@@ -166,9 +171,7 @@ impl FreeRegionMap {\n \n #[cfg(test)]\n fn free_region(index: u32) -> FreeRegion {\n-    use middle::region::DUMMY_CODE_EXTENT;\n-    FreeRegion { scope: DUMMY_CODE_EXTENT,\n-                 bound_region: ty::BoundRegion::BrAnon(index) }\n+    FreeRegion { scope: None, bound_region: ty::BoundRegion::BrAnon(index) }\n }\n \n #[test]"}, {"sha": "508dfe9cfcd8b717721e4c588f6ee01a62d526ff", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -1441,7 +1441,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n-                self.ir.tcx.region_maps().call_site_extent(id, body.value.id),\n+                Some(self.ir.tcx.region_maps().call_site_extent(id, body.value.id)),\n                 &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {"}, {"sha": "92777bb160463df2379612b39d4536aa58a61211", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -796,7 +796,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: self.tcx().region_maps().item_extent(fn_body_id),\n+            scope: Some(self.tcx().region_maps().item_extent(fn_body_id)),\n             bound_region: ty::BrEnv\n         }));\n "}, {"sha": "e381a904478b78d7408e6d4b297b464c3013d941", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 57, "deletions": 86, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -34,7 +34,7 @@ use ty::maps::Providers;\n use hir;\n use hir::def_id::{CrateNum, LOCAL_CRATE};\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n-use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n+use hir::{Body, Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n            RustcDecodable, Copy)]\n@@ -62,12 +62,6 @@ impl fmt::Debug for CodeExtent {\n     }\n }\n \n-/// The root of everything. I should be using NonZero or profiling\n-/// instead of this (probably).\n-pub const ROOT_CODE_EXTENT : CodeExtent = CodeExtent(0);\n-/// A placeholder used in trans to stand for real code extents\n-pub const DUMMY_CODE_EXTENT : CodeExtent = CodeExtent(1);\n-\n /// CodeExtent represents a statically-describable extent that can be\n /// used to bound the lifetime/region for values.\n ///\n@@ -209,14 +203,6 @@ impl CodeExtentData {\n }\n \n impl CodeExtent {\n-    #[inline]\n-    fn into_option(self) -> Option<CodeExtent> {\n-        if self == ROOT_CODE_EXTENT {\n-            None\n-        } else {\n-            Some(self)\n-        }\n-    }\n     pub fn node_id(&self, region_maps: &RegionMaps) -> ast::NodeId {\n         region_maps.code_extent_data(*self).node_id()\n     }\n@@ -265,7 +251,7 @@ pub struct RegionMaps {\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: Vec<CodeExtent>,\n+    scope_map: Vec<Option<CodeExtent>>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n@@ -310,10 +296,10 @@ pub struct Context {\n     root_id: Option<ast::NodeId>,\n \n     /// the scope that contains any new variables declared\n-    var_parent: CodeExtent,\n+    var_parent: Option<CodeExtent>,\n \n     /// region parent of expressions etc\n-    parent: CodeExtent\n+    parent: Option<CodeExtent>,\n }\n \n struct RegionResolutionVisitor<'hir: 'a, 'a> {\n@@ -351,11 +337,6 @@ struct RegionResolutionVisitor<'hir: 'a, 'a> {\n \n \n impl RegionMaps {\n-    /// create a bogus code extent for the regions in astencode types. Nobody\n-    /// really cares about the contents of these.\n-    pub fn bogus_code_extent(&mut self, e: CodeExtentData) -> CodeExtent {\n-        self.intern_code_extent(e, DUMMY_CODE_EXTENT)\n-    }\n     pub fn lookup_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n         match self.code_extent_interner.get(&e) {\n             Some(&d) => d,\n@@ -378,34 +359,18 @@ impl RegionMaps {\n     }\n     pub fn intern_code_extent(&mut self,\n                               e: CodeExtentData,\n-                              parent: CodeExtent) -> CodeExtent {\n+                              parent: Option<CodeExtent>) -> CodeExtent {\n         match self.code_extent_interner.entry(e) {\n-            Entry::Occupied(o) => {\n-                // this can happen when the bogus code extents from tydecode\n-                // have (bogus) NodeId-s that overlap items created during\n-                // inlining.\n-                // We probably shouldn't be creating bogus code extents\n-                // though.\n-                let idx = *o.get();\n-                if parent == DUMMY_CODE_EXTENT {\n-                    info!(\"CodeExtent({}) = {:?} [parent={}] BOGUS!\",\n-                          idx.0, e, parent.0);\n-                } else {\n-                    assert_eq!(self.scope_map[idx.0 as usize],\n-                               DUMMY_CODE_EXTENT);\n-                    info!(\"CodeExtent({}) = {:?} [parent={}] RECLAIMED!\",\n-                          idx.0, e, parent.0);\n-                    self.scope_map[idx.0 as usize] = parent;\n-                }\n-                idx\n+            Entry::Occupied(_) => {\n+                bug!(\"intern_code_extent: already exists\")\n             }\n             Entry::Vacant(v) => {\n                 if self.code_extents.len() > 0xffffffffusize {\n                     bug!() // should pass a sess,\n                            // but this isn't the only place\n                 }\n                 let idx = CodeExtent(self.code_extents.len() as u32);\n-                debug!(\"CodeExtent({}) = {:?} [parent={}]\", idx.0, e, parent.0);\n+                debug!(\"CodeExtent({:?}) = {:?} [parent={:?}]\", idx, e, parent);\n                 self.code_extents.push(e);\n                 self.scope_map.push(parent);\n                 *v.insert(idx)\n@@ -414,7 +379,7 @@ impl RegionMaps {\n     }\n     pub fn intern_node(&mut self,\n                        n: ast::NodeId,\n-                       parent: CodeExtent) -> CodeExtent {\n+                       parent: Option<CodeExtent>) -> CodeExtent {\n         self.intern_code_extent(CodeExtentData::Misc(n), parent)\n     }\n     pub fn code_extent_data(&self, e: CodeExtent) -> CodeExtentData {\n@@ -474,7 +439,7 @@ impl RegionMaps {\n \n     pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map[id.0 as usize].into_option()\n+        self.scope_map[id.0 as usize]\n     }\n \n     #[allow(dead_code)] // used in cfg\n@@ -524,7 +489,7 @@ impl RegionMaps {\n             return Some(s);\n         }\n \n-        let scope_map : &[CodeExtent] = &self.scope_map;\n+        let scope_map : &[Option<CodeExtent>] = &self.scope_map;\n         let code_extents: &[CodeExtentData] = &self.code_extents;\n \n         // else, locate the innermost terminating scope\n@@ -533,7 +498,7 @@ impl RegionMaps {\n         // returned.\n         let mut id = self.node_extent(expr_id);\n \n-        while let Some(p) = scope_map[id.0 as usize].into_option() {\n+        while let Some(p) = scope_map[id.0 as usize] {\n             match code_extents[p.0 as usize] {\n                 CodeExtentData::DestructionScope(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n@@ -595,15 +560,17 @@ impl RegionMaps {\n                                    -> CodeExtent {\n         if scope_a == scope_b { return scope_a; }\n \n-        let mut a_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n+        /// [1] The initial values for `a_buf` and `b_buf` are not used.\n+        /// The `ancestors_of` function will return some prefix that\n+        /// is re-initialized with new values (or else fallback to a\n+        /// heap-allocated vector).\n+        let mut a_buf: [CodeExtent; 32] = [scope_a /* [1] */; 32];\n         let mut a_vec: Vec<CodeExtent> = vec![];\n-        let mut b_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n+        let mut b_buf: [CodeExtent; 32] = [scope_b /* [1] */; 32];\n         let mut b_vec: Vec<CodeExtent> = vec![];\n-        let scope_map : &[CodeExtent] = &self.scope_map;\n-        let a_ancestors = ancestors_of(scope_map,\n-                                       scope_a, &mut a_buf, &mut a_vec);\n-        let b_ancestors = ancestors_of(scope_map,\n-                                       scope_b, &mut b_buf, &mut b_vec);\n+        let scope_map : &[Option<CodeExtent>] = &self.scope_map;\n+        let a_ancestors = ancestors_of(scope_map, scope_a, &mut a_buf, &mut a_vec);\n+        let b_ancestors = ancestors_of(scope_map, scope_b, &mut b_buf, &mut b_vec);\n         let mut a_index = a_ancestors.len() - 1;\n         let mut b_index = b_ancestors.len() - 1;\n \n@@ -656,17 +623,18 @@ impl RegionMaps {\n             }\n         }\n \n-        fn ancestors_of<'a>(scope_map: &[CodeExtent],\n+        fn ancestors_of<'a>(scope_map: &[Option<CodeExtent>],\n                             scope: CodeExtent,\n                             buf: &'a mut [CodeExtent; 32],\n-                            vec: &'a mut Vec<CodeExtent>) -> &'a [CodeExtent] {\n+                            vec: &'a mut Vec<CodeExtent>)\n+                            -> &'a [CodeExtent] {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut scope = scope;\n \n             let mut i = 0;\n             while i < 32 {\n                 buf[i] = scope;\n-                match scope_map[scope.0 as usize].into_option() {\n+                match scope_map[scope.0 as usize] {\n                     Some(superscope) => scope = superscope,\n                     _ => return &buf[..i+1]\n                 }\n@@ -677,7 +645,7 @@ impl RegionMaps {\n             vec.extend_from_slice(buf);\n             loop {\n                 vec.push(scope);\n-                match scope_map[scope.0 as usize].into_option() {\n+                match scope_map[scope.0 as usize] {\n                     Some(superscope) => scope = superscope,\n                     _ => return &*vec\n                 }\n@@ -691,12 +659,12 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n                        var_id: ast::NodeId,\n                        _sp: Span) {\n     match visitor.cx.var_parent {\n-        ROOT_CODE_EXTENT => {\n+        None => {\n             // this can happen in extern fn declarations like\n             //\n             // extern fn isalnum(c: c_int) -> c_int\n         }\n-        parent_scope =>\n+        Some(parent_scope) =>\n             visitor.region_maps.record_var_scope(var_id, parent_scope),\n     }\n }\n@@ -734,8 +702,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk:\n \n     visitor.cx = Context {\n         root_id: prev_cx.root_id,\n-        var_parent: block_extent,\n-        parent: block_extent,\n+        var_parent: Some(block_extent),\n+        parent: Some(block_extent),\n     };\n \n     {\n@@ -760,8 +728,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk:\n                 );\n                 visitor.cx = Context {\n                     root_id: prev_cx.root_id,\n-                    var_parent: stmt_extent,\n-                    parent: stmt_extent,\n+                    var_parent: Some(stmt_extent),\n+                    parent: Some(stmt_extent),\n                 };\n             }\n             visitor.visit_stmt(statement)\n@@ -806,7 +774,7 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, stmt:\n     let stmt_extent = visitor.new_node_extent_with_dtor(stmt_id);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = stmt_extent;\n+    visitor.cx.parent = Some(stmt_extent);\n     intravisit::walk_stmt(visitor, stmt);\n     visitor.cx.parent = prev_parent;\n }\n@@ -816,7 +784,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr:\n \n     let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = expr_extent;\n+    visitor.cx.parent = Some(expr_extent);\n \n     {\n         let terminating_scopes = &mut visitor.terminating_scopes;\n@@ -856,7 +824,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr:\n             }\n \n             hir::ExprMatch(..) => {\n-                visitor.cx.var_parent = expr_extent;\n+                visitor.cx.var_parent = Some(expr_extent);\n             }\n \n             hir::ExprAssignOp(..) | hir::ExprIndex(..) |\n@@ -898,7 +866,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     // scope that will be used for any bindings declared in this\n     // pattern.\n     let blk_scope = visitor.cx.var_parent;\n-    assert!(blk_scope != ROOT_CODE_EXTENT); // locals must be within a block\n+    let blk_scope = blk_scope.expect(\"locals must be within a block\");\n     visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n@@ -1123,8 +1091,8 @@ fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'tcx, 'a\n     let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n     visitor.cx = Context {\n         root_id: None,\n-        var_parent: ROOT_CODE_EXTENT,\n-        parent: ROOT_CODE_EXTENT\n+        var_parent: None,\n+        parent: None,\n     };\n     walk(visitor);\n     visitor.create_item_scope_if_needed(id);\n@@ -1147,8 +1115,8 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n            body_id,\n            visitor.cx.parent);\n \n-    visitor.cx.parent = visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n+    visitor.cx.parent = Some(visitor.new_code_extent(\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id }));\n \n     let fn_decl_scope = visitor.new_code_extent(\n         CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id });\n@@ -1164,8 +1132,8 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n         root_id: Some(body_id.node_id),\n-        parent: ROOT_CODE_EXTENT,\n-        var_parent: fn_decl_scope,\n+        parent: None,\n+        var_parent: Some(fn_decl_scope),\n     };\n \n     intravisit::walk_fn_decl(visitor, decl);\n@@ -1174,8 +1142,8 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n         root_id: Some(body_id.node_id),\n-        parent: fn_decl_scope,\n-        var_parent: fn_decl_scope\n+        parent: Some(fn_decl_scope),\n+        var_parent: Some(fn_decl_scope),\n     };\n     visitor.visit_nested_body(body_id);\n \n@@ -1202,7 +1170,7 @@ impl<'hir, 'a> RegionResolutionVisitor<'hir, 'a> {\n         if self.terminating_scopes.contains(&id) {\n             let ds = self.new_code_extent(\n                 CodeExtentData::DestructionScope(id));\n-            self.region_maps.intern_node(id, ds)\n+            self.region_maps.intern_node(id, Some(ds))\n         } else {\n             self.new_node_extent(id)\n         }\n@@ -1215,7 +1183,7 @@ impl<'hir, 'a> RegionResolutionVisitor<'hir, 'a> {\n         // scopes.\n         let scope = CodeExtentData::DestructionScope(id);\n         if !self.region_maps.code_extent_interner.contains_key(&scope) {\n-            self.region_maps.intern_code_extent(scope, ROOT_CODE_EXTENT);\n+            self.region_maps.intern_code_extent(scope, None);\n         }\n     }\n }\n@@ -1225,6 +1193,15 @@ impl<'hir, 'a> Visitor<'hir> for RegionResolutionVisitor<'hir, 'a> {\n         NestedVisitorMap::OnlyBodies(&self.map)\n     }\n \n+    fn visit_body(&mut self, b: &'hir Body) {\n+        // make sure that every body owner has an item scope, since\n+        // MIR construction wants that\n+        let owner = self.map.body_owner(b.id());\n+        self.create_item_scope_if_needed(owner);\n+\n+        intravisit::walk_body(self, b);\n+    }\n+\n     fn visit_block(&mut self, b: &'hir Block) {\n         resolve_block(self, b);\n     }\n@@ -1285,21 +1262,15 @@ fn region_resolve_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateN\n         shrunk_rvalue_scopes: NodeMap(),\n         fn_tree: NodeMap(),\n     };\n-    let root_extent = maps.bogus_code_extent(\n-        CodeExtentData::DestructionScope(ast::DUMMY_NODE_ID));\n-    assert_eq!(root_extent, ROOT_CODE_EXTENT);\n-    let bogus_extent = maps.bogus_code_extent(\n-        CodeExtentData::Misc(ast::DUMMY_NODE_ID));\n-    assert_eq!(bogus_extent, DUMMY_CODE_EXTENT);\n     {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &mut maps,\n             map: hir_map,\n             cx: Context {\n                 root_id: None,\n-                parent: ROOT_CODE_EXTENT,\n-                var_parent: ROOT_CODE_EXTENT\n+                parent: None,\n+                var_parent: None,\n             },\n             terminating_scopes: NodeSet()\n         };"}, {"sha": "ea1a2f9a982c93d51322d2bb361b4f44faa9b533", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -206,8 +206,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let free_substs = self.construct_free_substs(def_id,\n-            self.region_maps().node_extent(ast::DUMMY_NODE_ID));\n+        let free_substs = self.construct_free_substs(def_id, None);\n         let predicates = self.predicates_of(def_id);\n         let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)"}, {"sha": "d5d17e3c81214901b8f3a6b7cbb9fabced4d7f54", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -23,7 +23,6 @@ use super::util::impl_trait_ref_and_oblig;\n use rustc_data_structures::fx::FxHashMap;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n-use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n@@ -182,7 +181,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n     let penv = tcx.construct_parameter_environment(DUMMY_SP,\n                                                    impl1_def_id,\n-                                                   region::DUMMY_CODE_EXTENT);\n+                                                   None);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);"}, {"sha": "1cf6c3f334f6a76dd9f9bf3987b4f318ad7fa3fa", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n     /// `scope_id`.\n     pub fn liberate_late_bound_regions<T>(self,\n-        all_outlive_scope: region::CodeExtent,\n+        all_outlive_scope: Option<region::CodeExtent>,\n         value: &Binder<T>)\n         -> T\n         where T : TypeFoldable<'tcx>"}, {"sha": "480b8967a79e9e907ac44964f5cfbfbdc01933b2", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -1268,9 +1268,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let kind = if def.is_enum() || def.variants[0].fields.len() == 0{\n                         StructKind::AlwaysSizedUnivariant\n                     } else {\n-                        use middle::region::ROOT_CODE_EXTENT;\n                         let param_env = tcx.construct_parameter_environment(DUMMY_SP,\n-                          def.did, ROOT_CODE_EXTENT);\n+                          def.did, None);\n                         let fields = &def.variants[0].fields;\n                         let last_field = &fields[fields.len()-1];\n                         let always_sized = last_field.ty(tcx, param_env.free_substs)"}, {"sha": "fd0b1308c9572e44ebfc290541fac6d0c4610079", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -23,7 +23,7 @@ use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n-use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n+use middle::region::CodeExtent;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n use traits;\n@@ -46,7 +46,7 @@ use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n use std::mem;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, DUMMY_NODE_ID, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n@@ -1164,22 +1164,24 @@ pub struct ParameterEnvironment<'tcx> {\n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n     /// may specify stronger requirements). This field indicates the\n-    /// region of the callee.\n-    pub implicit_region_bound: &'tcx ty::Region,\n+    /// region of the callee. If it is `None`, then the parameter\n+    /// environment is for an item or something where the \"callee\" is\n+    /// not clear.\n+    pub implicit_region_bound: Option<&'tcx ty::Region>,\n \n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n \n-    /// Scope that is attached to free regions for this scope. This\n-    /// is usually the id of the fn body, but for more abstract scopes\n-    /// like structs we often use the node-id of the struct.\n+    /// Scope that is attached to free regions for this scope. This is\n+    /// usually the id of the fn body, but for more abstract scopes\n+    /// like structs we use None or the item extent.\n     ///\n     /// FIXME(#3696). It would be nice to refactor so that free\n     /// regions don't have this implicit scope and instead introduce\n     /// relationships in the environment.\n-    pub free_id_outlive: CodeExtent,\n+    pub free_id_outlive: Option<CodeExtent>,\n \n     /// A cache for `moves_by_default`.\n     pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n@@ -1220,13 +1222,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let impl_def_id = tcx.hir.local_def_id(impl_id);\n                         tcx.construct_parameter_environment(impl_item.span,\n                                                             impl_def_id,\n-                                                            tcx.region_maps().item_extent(id))\n+                                                            Some(tcx.region_maps().item_extent(id)))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.hir.local_def_id(id),\n-                            tcx.region_maps().call_site_extent(id, body.node_id))\n+                            Some(tcx.region_maps().call_site_extent(id, body.node_id)))\n                     }\n                 }\n             }\n@@ -1239,7 +1241,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let trait_def_id = tcx.hir.local_def_id(trait_id);\n                         tcx.construct_parameter_environment(trait_item.span,\n                                                             trait_def_id,\n-                                                            tcx.region_maps().item_extent(id))\n+                                                            Some(tcx.region_maps().item_extent(id)))\n                     }\n                     hir::TraitItemKind::Method(_, ref body) => {\n                         // Use call-site for extent (unless this is a\n@@ -1255,7 +1257,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             trait_item.span,\n                             tcx.hir.local_def_id(id),\n-                            extent)\n+                            Some(extent))\n                     }\n                 }\n             }\n@@ -1268,7 +1270,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             item.span,\n                             fn_def_id,\n-                            tcx.region_maps().call_site_extent(id, body_id.node_id))\n+                            Some(tcx.region_maps().call_site_extent(id, body_id.node_id)))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n@@ -1280,13 +1282,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n                                                             def_id,\n-                                                            tcx.region_maps().item_extent(id))\n+                                                            Some(tcx.region_maps().item_extent(id)))\n                     }\n                     hir::ItemTrait(..) => {\n                         let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n                                                             def_id,\n-                                                            tcx.region_maps().item_extent(id))\n+                                                            Some(tcx.region_maps().item_extent(id)))\n                     }\n                     _ => {\n                         span_bug!(item.span,\n@@ -1304,7 +1306,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     tcx.construct_parameter_environment(\n                         expr.span,\n                         base_def_id,\n-                        tcx.region_maps().call_site_extent(id, body.node_id))\n+                        Some(tcx.region_maps().call_site_extent(id, body.node_id)))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }\n@@ -1313,14 +1315,14 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                 let def_id = tcx.hir.local_def_id(id);\n                 tcx.construct_parameter_environment(item.span,\n                                                     def_id,\n-                                                    ROOT_CODE_EXTENT)\n+                                                    None)\n             }\n             Some(hir_map::NodeStructCtor(..)) |\n             Some(hir_map::NodeVariant(..)) => {\n                 let def_id = tcx.hir.local_def_id(id);\n                 tcx.construct_parameter_environment(tcx.hir.span(id),\n                                                     def_id,\n-                                                    ROOT_CODE_EXTENT)\n+                                                    None)\n             }\n             it => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n@@ -2439,10 +2441,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty::ParameterEnvironment {\n             free_substs: self.intern_substs(&[]),\n             caller_bounds: Vec::new(),\n-            implicit_region_bound: self.types.re_empty,\n-            // for an empty parameter environment, there ARE no free\n-            // regions, so it shouldn't matter what we use for the free id\n-            free_id_outlive: ROOT_CODE_EXTENT,\n+            implicit_region_bound: None,\n+            free_id_outlive: None,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n@@ -2455,7 +2455,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n     pub fn construct_free_substs(self, def_id: DefId,\n-                                 free_id_outlive: CodeExtent)\n+                                 free_id_outlive: Option<CodeExtent>)\n                                  -> &'gcx Substs<'gcx> {\n \n         let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n@@ -2479,7 +2479,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn construct_parameter_environment(self,\n                                            span: Span,\n                                            def_id: DefId,\n-                                           free_id_outlive: CodeExtent)\n+                                           free_id_outlive: Option<CodeExtent>)\n                                            -> ParameterEnvironment<'gcx>\n     {\n         //\n@@ -2513,16 +2513,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let unnormalized_env = ty::ParameterEnvironment {\n             free_substs: free_substs,\n-            implicit_region_bound: tcx.mk_region(ty::ReScope(free_id_outlive)),\n+            implicit_region_bound: free_id_outlive.map(|f| tcx.mk_region(ty::ReScope(f))),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n         };\n \n-        let cause = traits::ObligationCause::misc(span,\n-                                                  free_id_outlive.node_id(&self.region_maps()));\n+        let body_id = free_id_outlive.map(|f| f.node_id(&self.region_maps()))\n+                                     .unwrap_or(DUMMY_NODE_ID);\n+        let cause = traits::ObligationCause::misc(span, body_id);\n         traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n     }\n "}, {"sha": "02c4bad8e4e1c49a8cdbc783d667b2d130b23951", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -43,8 +43,12 @@ pub struct TypeAndMut<'tcx> {\n          RustcEncodable, RustcDecodable, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n+///\n+/// If `fr.scope` is None, then this is in some context (e.g., an\n+/// impl) where lifetimes are more abstract and the notion of the\n+/// caller/callee stack frames are not applicable.\n pub struct FreeRegion {\n-    pub scope: region::CodeExtent,\n+    pub scope: Option<region::CodeExtent>,\n     pub bound_region: BoundRegion,\n }\n "}, {"sha": "f5cdd40714cdb4e893106feaa6aa7490f67d1e87", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let loan_scope = match *loan_region {\n                     ty::ReScope(scope) => scope,\n \n-                    ty::ReFree(ref fr) => fr.scope,\n+                    ty::ReFree(ref fr) => fr.scope.unwrap_or(self.item_ub),\n \n                     ty::ReStatic => self.item_ub,\n "}, {"sha": "f3a258a8ca58a60d69500457c92dc296f75d4482", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -11,7 +11,7 @@\n use hair::cx::Cx;\n use hair::Pattern;\n \n-use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n+use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n use rustc::util::nodemap::NodeMap;\n@@ -200,11 +200,13 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let tcx = hir.tcx();\n     let ast_expr = &tcx.hir.body(body_id).value;\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n-    let span = tcx.hir.span(tcx.hir.body_owner(body_id));\n+    let owner_id = tcx.hir.body_owner(body_id);\n+    let span = tcx.hir.span(owner_id);\n     let mut builder = Builder::new(hir, span, 0, ty);\n \n-    let extent = tcx.region_maps().temporary_scope(ast_expr.id)\n-                    .unwrap_or(ROOT_CODE_EXTENT);\n+    let region_maps = tcx.region_maps();\n+    let extent = region_maps.temporary_scope(ast_expr.id)\n+                            .unwrap_or(region_maps.item_extent(owner_id));\n     let mut block = START_BLOCK;\n     let _ = builder.in_scope(extent, block, |builder| {\n         let expr = builder.hir.mirror(ast_expr);"}, {"sha": "ad51530b19152b1fe69c018830860055a2d58d39", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -828,7 +828,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n             let region = ty::Region::ReFree(ty::FreeRegion {\n-                scope: cx.tcx.region_maps().node_extent(body_id),\n+                scope: Some(cx.tcx.region_maps().node_extent(body_id)),\n                 bound_region: ty::BoundRegion::BrAnon(0),\n             });\n             let region = cx.tcx.mk_region(region);"}, {"sha": "cbd88733e82deb9ff049cdc5b44ea7d3c255f194", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -253,7 +253,7 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n     let region = ty::Region::ReFree(ty::FreeRegion {\n-        scope: tcx.region_maps().item_extent(body_id.node_id),\n+        scope: Some(tcx.region_maps().item_extent(body_id.node_id)),\n         bound_region: ty::BoundRegion::BrEnv,\n     });\n     let region = tcx.mk_region(region);"}, {"sha": "f2a550ec23a8e2abb04cea2d2dd1a7c433bed7e0", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -11,7 +11,6 @@\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n-use rustc::middle::region::ROOT_CODE_EXTENT;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n@@ -45,8 +44,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"make_shim({:?})\", instance);\n     let did = instance.def_id();\n     let span = tcx.def_span(did);\n-    let param_env =\n-        tcx.construct_parameter_environment(span, did, ROOT_CODE_EXTENT);\n+    let param_env = tcx.construct_parameter_environment(span, did, None);\n \n     let mut result = match instance {\n         ty::InstanceDef::Item(..) =>"}, {"sha": "d672637649e85f3e8f7a3f9475290750fd398fdd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -133,7 +133,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Some(&rl::Region::Free(scope, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                    scope: scope.to_code_extent(&tcx.region_maps()),\n+                    scope: Some(scope.to_code_extent(&tcx.region_maps())),\n                     bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name)\n                 }))\n "}, {"sha": "5d24df136ff19fd6a464a302b14a0b658e9cdeeb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n         let extent = self.tcx.region_maps().call_site_extent(expr.id, body.value.id);\n-        let fn_sig = self.tcx.liberate_late_bound_regions(extent, &sig);\n+        let fn_sig = self.tcx.liberate_late_bound_regions(Some(extent), &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n                                                             body.value.id, &fn_sig);\n "}, {"sha": "8b366fd5a277061e374cbdb0a27128fd01b24df9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -785,7 +785,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let fn_sig =\n                 fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n             let fn_sig =\n-                inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n+                inh.tcx.liberate_late_bound_regions(Some(fn_scope), &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n "}, {"sha": "a6f72898a5495a28c71e8c7b219ff6d256e87af7", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -1614,7 +1614,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // Add in the default bound of fn body that applies to all in\n         // scope type parameters:\n-        param_bounds.push(param_env.implicit_region_bound);\n+        param_bounds.extend(param_env.implicit_region_bound);\n \n         VerifyBound::AnyRegion(param_bounds)\n     }"}, {"sha": "f306d5dd70f29903ae213be1a85c3e3f116980ca", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d6066c05fea0e0787ac5add67e26283468116c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=55d6066c05fea0e0787ac5add67e26283468116c", "patch": "@@ -343,7 +343,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             let mut implied_bounds = vec![];\n             let free_id_outlive = fcx.tcx.region_maps().call_site_extent(item.id, body_id.node_id);\n             this.check_fn_or_method(fcx, item.span, sig, &predicates,\n-                                    free_id_outlive, &mut implied_bounds);\n+                                    Some(free_id_outlive), &mut implied_bounds);\n             implied_bounds\n         })\n     }\n@@ -429,7 +429,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       span: Span,\n                                       sig: ty::PolyFnSig<'tcx>,\n                                       predicates: &ty::InstantiatedPredicates<'tcx>,\n-                                      free_id_outlive: CodeExtent,\n+                                      free_id_outlive: Option<CodeExtent>,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let free_substs = &fcx.parameter_environment.free_substs;\n@@ -453,7 +453,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                          method_sig: &hir::MethodSig,\n                                          method: &ty::AssociatedItem,\n-                                         free_id_outlive: CodeExtent,\n+                                         free_id_outlive: Option<CodeExtent>,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the"}]}