{"sha": "5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMGJlMGQ3MmE4ZmU4N2MxYTAzOGYwMTRiZWI3ZjY0YmEyNDliMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-11T11:42:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-11T11:42:09Z"}, "message": "Auto merge of #40199 - alexcrichton:doc-proc-macro, r=brson\n\nrustbuild: Build documentation for `proc_macro`\n\nThis commit fixes #38749 by building documentation for the `proc_macro` crate by\ndefault for configured hosts. Unfortunately did not turn out to be a trivial\nfix. Currently rustbuild generates documentation into multiple locations: one\nfor std, one for test, and one for rustc. The initial fix for this issue simply\nactually executed `cargo doc -p proc_macro` which was otherwise completely\nelided before.\n\nUnfortunately rustbuild was the left to merge two documentation trees together.\nOne for the standard library and one for the rustc tree (which only had docs for\nthe `proc_macro` crate). Rustdoc itself knows how to merge documentation files\n(specifically around search indexes, etc) but rustbuild was unaware of this, so\nan initial fix ended up destroying the sidebar and the search bar from the\nlibstd docs.\n\nTo solve this issue the method of documentation has been tweaked slightly in\nrustbuild. The build system will not use symlinks (or directory junctions on\nWindows) to generate all documentation into the same location initially. This'll\nrely on rustdoc's logic to weave together all the output and ensure that it ends\nup all consistent.\n\nCloses #38749", "tree": {"sha": "d2f0b2a183c9e18995c6aa408ea8aee5bfd46fe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2f0b2a183c9e18995c6aa408ea8aee5bfd46fe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "html_url": "https://github.com/rust-lang/rust/commit/5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c72b7651f231f589bc81d78fb9602d5a0899213", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c72b7651f231f589bc81d78fb9602d5a0899213", "html_url": "https://github.com/rust-lang/rust/commit/8c72b7651f231f589bc81d78fb9602d5a0899213"}, {"sha": "f846aaf81f000b19d6f0ac5bde55f70bab47ec70", "url": "https://api.github.com/repos/rust-lang/rust/commits/f846aaf81f000b19d6f0ac5bde55f70bab47ec70", "html_url": "https://github.com/rust-lang/rust/commit/f846aaf81f000b19d6f0ac5bde55f70bab47ec70"}], "stats": {"total": 218, "additions": 207, "deletions": 11}, "files": [{"sha": "5a5cfe0c682d40ad585c26b727869b52912f19f1", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "patch": "@@ -19,10 +19,12 @@\n \n use std::fs::{self, File};\n use std::io::prelude::*;\n+use std::io;\n+use std::path::Path;\n use std::process::Command;\n \n use {Build, Compiler, Mode};\n-use util::cp_r;\n+use util::{cp_r, symlink_dir};\n use build_helper::up_to_date;\n \n /// Invoke `rustbook` as compiled in `stage` for `target` for the doc book\n@@ -141,7 +143,22 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n \n-    build.clear_if_dirty(&out_dir, &rustdoc);\n+    // Here what we're doing is creating a *symlink* (directory junction on\n+    // Windows) to the final output location. This is not done as an\n+    // optimization but rather for correctness. We've got three trees of\n+    // documentation, one for std, one for test, and one for rustc. It's then\n+    // our job to merge them all together.\n+    //\n+    // Unfortunately rustbuild doesn't know nearly as well how to merge doc\n+    // trees as rustdoc does itself, so instead of actually having three\n+    // separate trees we just have rustdoc output to the same location across\n+    // all of them.\n+    //\n+    // This way rustdoc generates output directly into the output, and rustdoc\n+    // will also directly handle merging.\n+    let my_out = build.crate_doc_out(target);\n+    build.clear_if_dirty(&my_out, &rustdoc);\n+    t!(symlink_dir_force(&my_out, &out_dir));\n \n     let mut cargo = build.cargo(&compiler, Mode::Libstd, target, \"doc\");\n     cargo.arg(\"--manifest-path\")\n@@ -166,7 +183,7 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n \n \n     build.run(&mut cargo);\n-    cp_r(&out_dir, &out)\n+    cp_r(&my_out, &out);\n }\n \n /// Compile all libtest documentation.\n@@ -187,13 +204,16 @@ pub fn test(build: &Build, stage: u32, target: &str) {\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n \n-    build.clear_if_dirty(&out_dir, &rustdoc);\n+    // See docs in std above for why we symlink\n+    let my_out = build.crate_doc_out(target);\n+    build.clear_if_dirty(&my_out, &rustdoc);\n+    t!(symlink_dir_force(&my_out, &out_dir));\n \n     let mut cargo = build.cargo(&compiler, Mode::Libtest, target, \"doc\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/libtest/Cargo.toml\"));\n     build.run(&mut cargo);\n-    cp_r(&out_dir, &out)\n+    cp_r(&my_out, &out);\n }\n \n /// Generate all compiler documentation.\n@@ -213,15 +233,28 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n     let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n-    if !up_to_date(&rustdoc, &out_dir.join(\"rustc/index.html\")) && out_dir.exists() {\n-        t!(fs::remove_dir_all(&out_dir));\n-    }\n+\n+    // See docs in std above for why we symlink\n+    let my_out = build.crate_doc_out(target);\n+    build.clear_if_dirty(&my_out, &rustdoc);\n+    t!(symlink_dir_force(&my_out, &out_dir));\n+\n     let mut cargo = build.cargo(&compiler, Mode::Librustc, target, \"doc\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n          .arg(\"--features\").arg(build.rustc_features());\n+\n+    // Like with libstd above if compiler docs aren't enabled then we're not\n+    // documenting internal dependencies, so we have a whitelist.\n+    if !build.config.compiler_docs {\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"proc_macro\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+    }\n+\n     build.run(&mut cargo);\n-    cp_r(&out_dir, &out)\n+    cp_r(&my_out, &out);\n }\n \n /// Generates the HTML rendered error-index by running the\n@@ -240,3 +273,19 @@ pub fn error_index(build: &Build, target: &str) {\n \n     build.run(&mut index);\n }\n+\n+fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n+    if let Ok(m) = fs::symlink_metadata(dst) {\n+        if m.file_type().is_dir() {\n+            try!(fs::remove_dir_all(dst));\n+        } else {\n+            // handle directory junctions on windows by falling back to\n+            // `remove_dir`.\n+            try!(fs::remove_file(dst).or_else(|_| {\n+                fs::remove_dir(dst)\n+            }));\n+        }\n+    }\n+\n+    symlink_dir(src, dst)\n+}"}, {"sha": "618e4d67705da646ff756cc13bdb7e3f475f726a", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "patch": "@@ -708,6 +708,13 @@ impl Build {\n         self.out.join(target).join(\"doc\")\n     }\n \n+    /// Output directory for all crate documentation for a target (temporary)\n+    ///\n+    /// The artifacts here are then copied into `doc_out` above.\n+    fn crate_doc_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"crate-docs\")\n+    }\n+\n     /// Returns true if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used."}, {"sha": "39f07459d4267914de8c8314e72ec42d042f14b7", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "patch": "@@ -640,7 +640,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n         rules.doc(&krate.doc_step, path)\n              .dep(|s| s.name(\"librustc-link\"))\n              .host(true)\n-             .default(default && build.config.compiler_docs)\n+             .default(default && build.config.docs)\n              .run(move |s| doc::rustc(build, s.stage, s.target));\n     }\n "}, {"sha": "dab20f44bc361d4e18cdeb0d50fa1236ebe320c2", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "patch": "@@ -16,6 +16,7 @@\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::Instant;\n@@ -183,3 +184,141 @@ impl Drop for TimeIt {\n                  time.subsec_nanos() / 1_000_000);\n     }\n }\n+\n+/// Symlinks two directories, using junctions on Windows and normal symlinks on\n+/// Unix.\n+pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n+    let _ = fs::remove_dir(dest);\n+    return symlink_dir_inner(src, dest);\n+\n+    #[cfg(not(windows))]\n+    fn symlink_dir_inner(src: &Path, dest: &Path) -> io::Result<()> {\n+        use std::os::unix::fs;\n+        fs::symlink(src, dest)\n+    }\n+\n+    // Creating a directory junction on windows involves dealing with reparse\n+    // points and the DeviceIoControl function, and this code is a skeleton of\n+    // what can be found here:\n+    //\n+    // http://www.flexhex.com/docs/articles/hard-links.phtml\n+    //\n+    // Copied from std\n+    #[cfg(windows)]\n+    #[allow(bad_style)]\n+    fn symlink_dir_inner(target: &Path, junction: &Path) -> io::Result<()> {\n+        use std::ptr;\n+        use std::ffi::OsStr;\n+        use std::os::windows::ffi::OsStrExt;\n+\n+        const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n+        const GENERIC_WRITE: DWORD = 0x40000000;\n+        const OPEN_EXISTING: DWORD = 3;\n+        const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n+        const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n+        const FSCTL_SET_REPARSE_POINT: DWORD = 0x900a4;\n+        const IO_REPARSE_TAG_MOUNT_POINT: DWORD = 0xa0000003;\n+        const FILE_SHARE_DELETE: DWORD = 0x4;\n+        const FILE_SHARE_READ: DWORD = 0x1;\n+        const FILE_SHARE_WRITE: DWORD = 0x2;\n+\n+        type BOOL = i32;\n+        type DWORD = u32;\n+        type HANDLE = *mut u8;\n+        type LPCWSTR = *const u16;\n+        type LPDWORD = *mut DWORD;\n+        type LPOVERLAPPED = *mut u8;\n+        type LPSECURITY_ATTRIBUTES = *mut u8;\n+        type LPVOID = *mut u8;\n+        type WCHAR = u16;\n+        type WORD = u16;\n+\n+        #[repr(C)]\n+        struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n+            ReparseTag: DWORD,\n+            ReparseDataLength: DWORD,\n+            Reserved: WORD,\n+            ReparseTargetLength: WORD,\n+            ReparseTargetMaximumLength: WORD,\n+            Reserved1: WORD,\n+            ReparseTarget: WCHAR,\n+        }\n+\n+        extern \"system\" {\n+            fn CreateFileW(lpFileName: LPCWSTR,\n+                           dwDesiredAccess: DWORD,\n+                           dwShareMode: DWORD,\n+                           lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                           dwCreationDisposition: DWORD,\n+                           dwFlagsAndAttributes: DWORD,\n+                           hTemplateFile: HANDLE)\n+                           -> HANDLE;\n+            fn DeviceIoControl(hDevice: HANDLE,\n+                               dwIoControlCode: DWORD,\n+                               lpInBuffer: LPVOID,\n+                               nInBufferSize: DWORD,\n+                               lpOutBuffer: LPVOID,\n+                               nOutBufferSize: DWORD,\n+                               lpBytesReturned: LPDWORD,\n+                               lpOverlapped: LPOVERLAPPED) -> BOOL;\n+        }\n+\n+        fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n+            Ok(s.as_ref().encode_wide().chain(Some(0)).collect())\n+        }\n+\n+        // We're using low-level APIs to create the junction, and these are more\n+        // picky about paths. For example, forward slashes cannot be used as a\n+        // path separator, so we should try to canonicalize the path first.\n+        let target = try!(fs::canonicalize(target));\n+\n+        try!(fs::create_dir(junction));\n+\n+        let path = try!(to_u16s(junction));\n+\n+        unsafe {\n+            let h = CreateFileW(path.as_ptr(),\n+                                GENERIC_WRITE,\n+                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n+                                0 as *mut _,\n+                                OPEN_EXISTING,\n+                                FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n+                                ptr::null_mut());\n+\n+            let mut data = [0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+            let mut db = data.as_mut_ptr()\n+                            as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n+            let buf = &mut (*db).ReparseTarget as *mut _;\n+            let mut i = 0;\n+            // FIXME: this conversion is very hacky\n+            let v = br\"\\??\\\";\n+            let v = v.iter().map(|x| *x as u16);\n+            for c in v.chain(target.as_os_str().encode_wide().skip(4)) {\n+                *buf.offset(i) = c;\n+                i += 1;\n+            }\n+            *buf.offset(i) = 0;\n+            i += 1;\n+            (*db).ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n+            (*db).ReparseTargetMaximumLength = (i * 2) as WORD;\n+            (*db).ReparseTargetLength = ((i - 1) * 2) as WORD;\n+            (*db).ReparseDataLength =\n+                    (*db).ReparseTargetLength as DWORD + 12;\n+\n+            let mut ret = 0;\n+            let res = DeviceIoControl(h as *mut _,\n+                                      FSCTL_SET_REPARSE_POINT,\n+                                      data.as_ptr() as *mut _,\n+                                      (*db).ReparseDataLength + 8,\n+                                      ptr::null_mut(), 0,\n+                                      &mut ret,\n+                                      ptr::null_mut());\n+\n+            if res == 0 {\n+                Err(io::Error::last_os_error())\n+            } else {\n+                Ok(())\n+            }\n+        }\n+    }\n+}"}, {"sha": "b5a713dc38259997b22b54bb351687101fb0c989", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "patch": "@@ -58,6 +58,7 @@ exec docker \\\n   --env DEPLOY_ALT=$DEPLOY_ALT \\\n   --env LOCAL_USER_ID=`id -u` \\\n   --volume \"$HOME/.cargo:/cargo\" \\\n+  --privileged \\\n   --rm \\\n   rust-ci \\\n   /checkout/src/ci/run.sh"}, {"sha": "0d2a467b577027aa79cac6b420bfcd41f9036992", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0be0d72a8fe87c1a038f014beb7f64ba249b29/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=5d0be0d72a8fe87c1a038f014beb7f64ba249b29", "patch": "@@ -21,7 +21,7 @@\n //! This functionality is intended to be expanded over time as more surface\n //! area for macro authors is stabilized.\n //!\n-//! See [the book](../../book/procedural-macros.html) for more.\n+//! See [the book](../book/procedural-macros.html) for more.\n \n #![crate_name = \"proc_macro\"]\n #![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]"}]}