{"sha": "20ced4a720d30568ea1eff0d7ce43941e388df13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwY2VkNGE3MjBkMzA1NjhlYTFlZmYwZDdjZTQzOTQxZTM4OGRmMTM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-19T08:19:31Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-19T08:19:34Z"}, "message": "Replace const_to_ptr with const_to_value.\n\nThis reduces the number of allocations Miri makes drastically. The\n`const_to_ptr` function was a lame hack that allocated for every since simple\nconstant, and all of those are avoided now, except for one extra allocation each\nfor string and bytestring literals which will be fixed in a followup commit.\n\nThere are a number of hacks such as `eval_operand_to_ptr` left over from this\ncommit, which will also be fixed in followup commits.", "tree": {"sha": "5b2c2823e5a242f0b4246f39718bc8b3148ae9b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b2c2823e5a242f0b4246f39718bc8b3148ae9b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20ced4a720d30568ea1eff0d7ce43941e388df13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20ced4a720d30568ea1eff0d7ce43941e388df13", "html_url": "https://github.com/rust-lang/rust/commit/20ced4a720d30568ea1eff0d7ce43941e388df13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20ced4a720d30568ea1eff0d7ce43941e388df13/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "814efe3b05c4b8849cd04a8c680f53dc3845aa69", "url": "https://api.github.com/repos/rust-lang/rust/commits/814efe3b05c4b8849cd04a8c680f53dc3845aa69", "html_url": "https://github.com/rust-lang/rust/commit/814efe3b05c4b8849cd04a8c680f53dc3845aa69"}], "stats": {"total": 284, "additions": 171, "deletions": 113}, "files": [{"sha": "3cae24f34d8c817288f9159180f4a1be69b66623", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 132, "deletions": 96, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/20ced4a720d30568ea1eff0d7ce43941e388df13/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ced4a720d30568ea1eff0d7ce43941e388df13/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=20ced4a720d30568ea1eff0d7ce43941e388df13", "patch": "@@ -1,4 +1,4 @@\n-use rustc::middle::const_val;\n+use rustc::middle::const_val::ConstVal;\n use rustc::hir::def_id::DefId;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n@@ -99,6 +99,12 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub stmt: usize,\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+enum Value {\n+    Ptr(Pointer),\n+    Prim(PrimVal),\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n struct Lvalue {\n     ptr: Pointer,\n@@ -182,45 +188,30 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.stack\n     }\n \n-    // TODO(solson): Try making const_to_primval instead.\n-    fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<'tcx, Pointer> {\n+    fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstFloat};\n-        macro_rules! i2p {\n-            ($i:ident, $n:expr) => {{\n-                let ptr = self.memory.allocate($n, $n)?;\n-                self.memory.write_int(ptr, $i as i64, $n)?;\n-                Ok(ptr)\n-            }}\n-        }\n-        match *const_val {\n-            Float(ConstFloat::F32(f)) => {\n-                let ptr = self.memory.allocate(4, 4)?;\n-                self.memory.write_f32(ptr, f)?;\n-                Ok(ptr)\n-            },\n-            Float(ConstFloat::F64(f)) => {\n-                let ptr = self.memory.allocate(8, 8)?;\n-                self.memory.write_f64(ptr, f)?;\n-                Ok(ptr)\n-            },\n-            Float(ConstFloat::FInfer{..}) |\n-            Integral(ConstInt::Infer(_)) |\n-            Integral(ConstInt::InferSigned(_)) => bug!(\"uninferred constants only exist before typeck\"),\n-            Integral(ConstInt::I8(i)) => i2p!(i, 1),\n-            Integral(ConstInt::U8(i)) => i2p!(i, 1),\n+\n+        let primval = match *const_val {\n+            Integral(ConstInt::I8(i)) => Value::Prim(PrimVal::I8(i)),\n+            Integral(ConstInt::U8(i)) => Value::Prim(PrimVal::U8(i)),\n             Integral(ConstInt::Isize(ConstIsize::Is16(i))) |\n-            Integral(ConstInt::I16(i)) => i2p!(i, 2),\n+            Integral(ConstInt::I16(i)) => Value::Prim(PrimVal::I16(i)),\n             Integral(ConstInt::Usize(ConstUsize::Us16(i))) |\n-            Integral(ConstInt::U16(i)) => i2p!(i, 2),\n+            Integral(ConstInt::U16(i)) => Value::Prim(PrimVal::U16(i)),\n             Integral(ConstInt::Isize(ConstIsize::Is32(i))) |\n-            Integral(ConstInt::I32(i)) => i2p!(i, 4),\n+            Integral(ConstInt::I32(i)) => Value::Prim(PrimVal::I32(i)),\n             Integral(ConstInt::Usize(ConstUsize::Us32(i))) |\n-            Integral(ConstInt::U32(i)) => i2p!(i, 4),\n+            Integral(ConstInt::U32(i)) => Value::Prim(PrimVal::U32(i)),\n             Integral(ConstInt::Isize(ConstIsize::Is64(i))) |\n-            Integral(ConstInt::I64(i)) => i2p!(i, 8),\n+            Integral(ConstInt::I64(i)) => Value::Prim(PrimVal::I64(i)),\n             Integral(ConstInt::Usize(ConstUsize::Us64(i))) |\n-            Integral(ConstInt::U64(i)) => i2p!(i, 8),\n+            Integral(ConstInt::U64(i)) => Value::Prim(PrimVal::U64(i)),\n+            Float(ConstFloat::F32(f)) => Value::Prim(PrimVal::F32(f)),\n+            Float(ConstFloat::F64(f)) => Value::Prim(PrimVal::F64(f)),\n+            Bool(b) => Value::Prim(PrimVal::Bool(b)),\n+            Char(c) => Value::Prim(PrimVal::Char(c)),\n+\n             Str(ref s) => {\n                 let psize = self.memory.pointer_size();\n                 let static_ptr = self.memory.allocate(s.len(), 1)?;\n@@ -229,33 +220,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_bytes(static_ptr, s.as_bytes())?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 self.memory.write_usize(extra, s.len() as u64)?;\n-                Ok(ptr)\n+                Value::Ptr(ptr)\n             }\n+\n             ByteStr(ref bs) => {\n                 let psize = self.memory.pointer_size();\n                 let static_ptr = self.memory.allocate(bs.len(), 1)?;\n                 let ptr = self.memory.allocate(psize, psize)?;\n                 self.memory.write_bytes(static_ptr, bs)?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n-                Ok(ptr)\n+                Value::Ptr(ptr)\n             }\n-            Bool(b) => {\n-                let ptr = self.memory.allocate(1, 1)?;\n-                self.memory.write_bool(ptr, b)?;\n-                Ok(ptr)\n-            }\n-            Char(c) => {\n-                let ptr = self.memory.allocate(4, 4)?;\n-                self.memory.write_uint(ptr, c as u64, 4)?;\n-                Ok(ptr)\n-            },\n-            Struct(_node_id)  => unimplemented!(),\n-            Tuple(_node_id)   => unimplemented!(),\n-            Function(_def_id) => unimplemented!(),\n-            Array(_, _)       => unimplemented!(),\n-            Repeat(_, _)      => unimplemented!(),\n-            Dummy             => unimplemented!(),\n-        }\n+\n+            Struct(_)    => unimplemented!(),\n+            Tuple(_)     => unimplemented!(),\n+            Function(_)  => unimplemented!(),\n+            Array(_, _)  => unimplemented!(),\n+            Repeat(_, _) => unimplemented!(),\n+            Dummy        => unimplemented!(),\n+\n+            Float(ConstFloat::FInfer{..}) |\n+            Integral(ConstInt::Infer(_)) |\n+            Integral(ConstInt::InferSigned(_)) =>\n+                bug!(\"uninferred constants only exist before typeck\"),\n+        };\n+\n+        Ok(primval)\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n@@ -404,15 +394,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         right: &mir::Operand<'tcx>,\n         dest: Pointer,\n     ) -> EvalResult<'tcx, bool> {\n-        let left_ptr = self.eval_operand(left)?;\n-        let left_ty = self.operand_ty(left);\n-        let left_val = self.read_primval(left_ptr, left_ty)?;\n-\n-        let right_ptr = self.eval_operand(right)?;\n-        let right_ty = self.operand_ty(right);\n-        let right_val = self.read_primval(right_ptr, right_ty)?;\n-\n-        let (val, overflow) = primval::binary_op(op, left_val, right_val)?;\n+        let left_primval = self.eval_operand_to_primval(left)?;\n+        let right_primval = self.eval_operand_to_primval(right)?;\n+        let (val, overflow) = primval::binary_op(op, left_primval, right_primval)?;\n         self.memory.write_primval(dest, val)?;\n         Ok(overflow)\n     }\n@@ -424,26 +408,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<'tcx, ()> {\n         for (offset, operand) in offsets.into_iter().zip(operands) {\n-            let src = self.eval_operand(operand)?;\n-            let src_ty = self.operand_ty(operand);\n+            let value = self.eval_operand(operand)?;\n+            let value_ty = self.operand_ty(operand);\n             let field_dest = dest.offset(offset as isize);\n-            self.move_(src, field_dest, src_ty)?;\n+            self.write_value(value, field_dest, value_ty)?;\n         }\n         Ok(())\n     }\n \n-    fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n-        -> EvalResult<'tcx, ()>\n-    {\n+    /// Evaluate an assignment statement.\n+    ///\n+    /// There is no separate `eval_rvalue` function. Instead, the code for handling each rvalue\n+    /// type writes its results directly into the memory specified by the lvalue.\n+    fn eval_rvalue_into_lvalue(\n+        &mut self,\n+        rvalue: &mir::Rvalue<'tcx>,\n+        lvalue: &mir::Lvalue<'tcx>,\n+    ) -> EvalResult<'tcx, ()> {\n         let dest = self.eval_lvalue(lvalue)?.to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n         let dest_layout = self.type_layout(dest_ty);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n-                let src = self.eval_operand(operand)?;\n-                self.move_(src, dest, dest_ty)?;\n+                let value = self.eval_operand(operand)?;\n+                self.write_value(value, dest, dest_ty)?;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n@@ -456,9 +446,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             UnaryOp(un_op, ref operand) => {\n-                let ptr = self.eval_operand(operand)?;\n-                let ty = self.operand_ty(operand);\n-                let val = self.read_primval(ptr, ty)?;\n+                let val = self.eval_operand_to_primval(operand)?;\n                 self.memory.write_primval(dest, primval::unary_op(un_op, val)?)?;\n             }\n \n@@ -499,9 +487,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             if nndiscr == variant as u64 {\n                                 assert_eq!(operands.len(), 1);\n                                 let operand = &operands[0];\n-                                let src = self.eval_operand(operand)?;\n-                                let src_ty = self.operand_ty(operand);\n-                                self.move_(src, dest, src_ty)?;\n+                                let value = self.eval_operand(operand)?;\n+                                let value_ty = self.operand_ty(operand);\n+                                self.write_value(value, dest, value_ty)?;\n                             } else {\n                                 assert_eq!(operands.len(), 0);\n                                 self.memory.write_isize(dest, 0)?;\n@@ -549,15 +537,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Repeat(ref operand, _) => {\n-                let (elem_size, elem_align, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), self.type_align(elem_ty), n),\n+                let (elem_ty, length) = match dest_ty.sty {\n+                    ty::TyArray(elem_ty, n) => (elem_ty, n),\n                     _ => bug!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n-\n-                let src = self.eval_operand(operand)?;\n+                let elem_size = self.type_size(elem_ty);\n+                let value = self.eval_operand(operand)?;\n                 for i in 0..length {\n                     let elem_dest = dest.offset((i * elem_size) as isize);\n-                    self.memory.copy(src, elem_dest, elem_size, elem_align)?;\n+                    self.write_value(value, elem_dest, elem_ty)?;\n                 }\n             }\n \n@@ -604,7 +592,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n-                        let src = self.eval_operand(operand)?;\n+                        let src = self.eval_operand_to_ptr(operand)?;\n                         let src_ty = self.operand_ty(operand);\n                         let dest_ty = self.monomorphize(dest_ty, self.substs());\n                         assert!(self.type_is_fat_ptr(dest_ty));\n@@ -637,7 +625,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     Misc => {\n-                        let src = self.eval_operand(operand)?;\n+                        let src = self.eval_operand_to_ptr(operand)?;\n                         let src_ty = self.operand_ty(operand);\n                         if self.type_is_fat_ptr(src_ty) {\n                             let (data_ptr, _meta_ptr) = self.get_fat_ptr(src);\n@@ -671,7 +659,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     UnsafeFnPointer => match dest_ty.sty {\n                         ty::TyFnPtr(unsafe_fn_ty) => {\n-                            let src = self.eval_operand(operand)?;\n+                            let src = self.eval_operand_to_ptr(operand)?;\n                             let ptr = self.memory.read_ptr(src)?;\n                             let (def_id, substs, _) = self.memory.get_fn(ptr.alloc_id)?;\n                             let fn_ptr = self.memory.create_fn_ptr(def_id, substs, unsafe_fn_ty);\n@@ -761,36 +749,68 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n+    // remove it as soon as PrimVal can represent fat pointers.\n+    fn eval_operand_to_ptr(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Pointer> {\n+        let value = self.eval_operand(op)?;\n+        match value {\n+            Value::Ptr(ptr) => Ok(ptr),\n+            Value::Prim(primval) => {\n+                let ty = self.operand_ty(op);\n+                let size = self.type_size(ty);\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n+                self.memory.write_primval(ptr, primval)?;\n+                Ok(ptr)\n+            }\n+        }\n+    }\n+\n+    fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        let value = self.eval_operand(op)?;\n+        let ty = self.operand_ty(op);\n+        self.value_to_primval(value, ty)\n+    }\n+\n+    fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n-            Consume(ref lvalue) => Ok(self.eval_lvalue(lvalue)?.to_ptr()),\n+            Consume(ref lvalue) => Ok(Value::Ptr(self.eval_lvalue(lvalue)?.to_ptr())),\n+\n             Constant(mir::Constant { ref literal, ty, .. }) => {\n-                use rustc::mir::repr::Literal::*;\n-                match *literal {\n-                    Value { ref value } => Ok(self.const_to_ptr(value)?),\n-                    Item { def_id, substs } => {\n+                use rustc::mir::repr::Literal;\n+                let value = match *literal {\n+                    Literal::Value { ref value } => self.const_to_value(value)?,\n+\n+                    Literal::Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n                             // function items are zero sized\n-                            Ok(self.memory.allocate(0, 0)?)\n+                            Value::Ptr(self.memory.allocate(0, 0)?)\n                         } else {\n                             let cid = ConstantId {\n                                 def_id: def_id,\n                                 substs: substs,\n                                 kind: ConstantKind::Global,\n                             };\n-                            Ok(*self.statics.get(&cid).expect(\"static should have been cached (rvalue)\"))\n+                            let static_ptr = *self.statics.get(&cid)\n+                                .expect(\"static should have been cached (rvalue)\");\n+                            Value::Ptr(static_ptr)\n                         }\n-                    },\n-                    Promoted { index } => {\n+                    }\n+\n+                    Literal::Promoted { index } => {\n                         let cid = ConstantId {\n                             def_id: self.frame().def_id,\n                             substs: self.substs(),\n                             kind: ConstantKind::Promoted(index),\n                         };\n-                        Ok(*self.statics.get(&cid).expect(\"a promoted constant hasn't been precomputed\"))\n-                    },\n-                }\n+                        let static_ptr = *self.statics.get(&cid)\n+                            .expect(\"a promoted constant hasn't been precomputed\");\n+                        Value::Ptr(static_ptr)\n+                    }\n+                };\n+\n+                Ok(value)\n             }\n         }\n     }\n@@ -885,7 +905,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             ty::TySlice(elem_ty) => self.type_size(elem_ty),\n                             _ => bug!(\"indexing expected an array or slice, got {:?}\", base_ty),\n                         };\n-                        let n_ptr = self.eval_operand(operand)?;\n+                        let n_ptr = self.eval_operand_to_ptr(operand)?;\n                         let n = self.memory.read_usize(n_ptr)?;\n                         base.ptr.offset(n as isize * elem_size as isize)\n                     }\n@@ -920,6 +940,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        match value {\n+            Value::Ptr(ptr) => self.read_primval(ptr, ty),\n+\n+            // TODO(solson): Sanity-check the primval type against the input type.\n+            Value::Prim(primval) => Ok(primval),\n+        }\n+    }\n+\n+    fn write_value(&mut self, value: Value, dest: Pointer, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n+        match value {\n+            Value::Ptr(ptr) => self.move_(ptr, dest, dest_ty),\n+            Value::Prim(primval) => self.memory.write_primval(dest, primval),\n+        }\n+    }\n+\n     pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use syntax::ast::{IntTy, UintTy, FloatTy};\n         let val = match (self.memory.pointer_size(), &ty.sty) {"}, {"sha": "6f8a297a6d8f891cbee43b3d34439c3f2ca1b539", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ced4a720d30568ea1eff0d7ce43941e388df13/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ced4a720d30568ea1eff0d7ce43941e388df13/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=20ced4a720d30568ea1eff0d7ce43941e388df13", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         use rustc::mir::repr::StatementKind::*;\n         match stmt.kind {\n-            Assign(ref lvalue, ref rvalue) => self.eval_assignment(lvalue, rvalue)?,\n+            Assign(ref lvalue, ref rvalue) => self.eval_rvalue_into_lvalue(rvalue, lvalue)?,\n             SetDiscriminant { .. } => unimplemented!(),\n \n             // Miri can safely ignore these. Only translation needs them."}, {"sha": "9914fcba4670dcb71d7d3b050bb7b950c0ac02da", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/20ced4a720d30568ea1eff0d7ce43941e388df13/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ced4a720d30568ea1eff0d7ce43941e388df13/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=20ced4a720d30568ea1eff0d7ce43941e388df13", "patch": "@@ -1,18 +1,19 @@\n use rustc::hir::def_id::DefId;\n+use rustc::middle::const_val::ConstVal;\n use rustc::mir::repr as mir;\n use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n-use std::rc::Rc;\n use std::iter;\n-use syntax::{ast, attr};\n+use std::rc::Rc;\n use syntax::codemap::{DUMMY_SP, Span};\n+use syntax::{ast, attr};\n \n-use super::{EvalContext, IntegerExt, StackPopCleanup};\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n+use super::{EvalContext, IntegerExt, StackPopCleanup};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n@@ -32,8 +33,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Goto { target } => self.goto_block(target),\n \n             If { ref cond, targets: (then_target, else_target) } => {\n-                let cond_ptr = self.eval_operand(cond)?;\n-                let cond_val = self.memory.read_bool(cond_ptr)?;\n+                let cond_val = self.eval_operand_to_primval(cond)?\n+                    .expect_bool(\"TerminatorKind::If condition constant was not a bool\");\n                 self.goto_block(if cond_val { then_target } else { else_target });\n             }\n \n@@ -54,9 +55,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n-                for (index, val_const) in values.iter().enumerate() {\n-                    let ptr = self.const_to_ptr(val_const)?;\n-                    let val = self.memory.read_uint(ptr, discr_size)?;\n+                for (index, const_val) in values.iter().enumerate() {\n+                    let val = match const_val {\n+                        &ConstVal::Integral(i) => i.to_u64_unchecked(),\n+                        _ => bug!(\"TerminatorKind::SwitchInt branch constant was not an integer\"),\n+                    };\n                     if discr_val == val {\n                         target_block = targets[index];\n                         break;\n@@ -88,7 +91,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n-                        let ptr = self.eval_operand(func)?;\n+                        let ptr = self.eval_operand_to_ptr(func)?;\n                         let fn_ptr = self.memory.read_ptr(ptr)?;\n                         let (def_id, substs, fn_ty) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         if fn_ty != bare_fn_ty {\n@@ -114,15 +117,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n-                let cond_ptr = self.eval_operand(cond)?;\n-                if expected == self.memory.read_bool(cond_ptr)? {\n+                let cond_val = self.eval_operand_to_primval(cond)?\n+                    .expect_bool(\"TerminatorKind::Assert condition constant was not a bool\");\n+                if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n                     return match *msg {\n                         mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n-                            let len = self.eval_operand(len).expect(\"can't eval len\");\n+                            let len = self.eval_operand_to_ptr(len).expect(\"can't eval len\");\n                             let len = self.memory.read_usize(len).expect(\"can't read len\");\n-                            let index = self.eval_operand(index).expect(\"can't eval index\");\n+                            let index = self.eval_operand_to_ptr(index).expect(\"can't eval index\");\n                             let index = self.memory.read_usize(index).expect(\"can't read index\");\n                             Err(EvalError::ArrayIndexOutOfBounds(terminator.source_info.span, len, index))\n                         },\n@@ -174,7 +178,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let mut arg_srcs = Vec::new();\n                 for arg in args {\n-                    let src = self.eval_operand(arg)?;\n+                    let src = self.eval_operand_to_ptr(arg)?;\n                     let src_ty = self.operand_ty(arg);\n                     arg_srcs.push((src, src_ty));\n                 }\n@@ -271,8 +275,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Pointer,\n         dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n+        // TODO(solson): We can probably remove this _to_ptr easily.\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand(arg))\n+            .map(|arg| self.eval_operand_to_ptr(arg))\n             .collect();\n         let args_ptrs = args_res?;\n         let pointer_size = self.memory.pointer_size();\n@@ -422,8 +427,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             None => name.as_str(),\n         };\n \n+        // TODO(solson): We can probably remove this _to_ptr easily.\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand(arg))\n+            .map(|arg| self.eval_operand_to_ptr(arg))\n             .collect();\n         let args = args_res?;\n "}, {"sha": "267922204af6af3f12c1c6e24bcf3c70c868dbe5", "filename": "src/primval.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/20ced4a720d30568ea1eff0d7ce43941e388df13/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ced4a720d30568ea1eff0d7ce43941e388df13/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=20ced4a720d30568ea1eff0d7ce43941e388df13", "patch": "@@ -20,6 +20,15 @@ pub enum PrimVal {\n     F32(f32), F64(f64),\n }\n \n+impl PrimVal {\n+    pub fn expect_bool(self, error_msg: &str) -> bool {\n+        match self {\n+            PrimVal::Bool(b) => b,\n+            _ => bug!(\"{}\", error_msg),\n+        }\n+    }\n+}\n+\n /// returns the result of the operation and whether the operation overflowed\n pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<'tcx, (PrimVal, bool)> {\n     use rustc::mir::repr::BinOp::*;"}, {"sha": "ac4b3a66744844dac291650b09e4072da1a4c85a", "filename": "tests/compile-fail/oom2.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20ced4a720d30568ea1eff0d7ce43941e388df13/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ced4a720d30568ea1eff0d7ce43941e388df13/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=20ced4a720d30568ea1eff0d7ce43941e388df13", "patch": "@@ -30,6 +30,13 @@ fn bar(i: i32) {\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n     }\n }\n "}]}