{"sha": "f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "node_id": "C_kwDOAAsO6NoAKGYyNDZjMGIxMTZjZGJiYWQ1NzBjMjNjNTc0NWFhMDFmNmYzZjY0YTA", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-10-26T00:01:24Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:24Z"}, "message": "Attribute drop to parent expression of the consume point\n\nThis is needed to handle cases like `[a, b.await, c]`. `ExprUseVisitor`\nconsiders `a` to be consumed when it is passed to the array, but the\narray is not quite live yet at that point. This means we were missing\nthe `a` value across the await point. Attributing drops to the parent\nexpression means we do not consider the value consumed until the\nconsuming expression has finished.\n\nIssue #57478", "tree": {"sha": "632f368ab1d6bf21171f8051f1c7751c39d901bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/632f368ab1d6bf21171f8051f1c7751c39d901bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "html_url": "https://github.com/rust-lang/rust/commit/f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae", "html_url": "https://github.com/rust-lang/rust/commit/f664cfc47cdfaa83a1fd35e6e6a3fcdb692286ae"}], "stats": {"total": 118, "additions": 87, "deletions": 31}, "files": [{"sha": "92dea92a0bcadb96883274ba5c5f5c2028d9cb43", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "patch": "@@ -6,7 +6,7 @@\n use crate::expr_use_visitor::{self, ExprUseVisitor};\n \n use super::FnCtxt;\n-use hir::HirIdMap;\n+use hir::{HirIdMap, Node};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::pluralize;\n use rustc_hir as hir;\n@@ -15,6 +15,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n+use rustc_middle::hir::map::Map;\n use rustc_middle::hir::place::{Place, PlaceBase};\n use rustc_middle::middle::region::{self, YieldData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -225,6 +226,7 @@ pub fn resolve_interior<'a, 'tcx>(\n \n     let mut visitor = {\n         let mut drop_range_visitor = DropRangeVisitor {\n+            hir: fcx.tcx.hir(),\n             consumed_places: <_>::default(),\n             borrowed_places: <_>::default(),\n             drop_ranges: vec![<_>::default()],\n@@ -664,19 +666,28 @@ fn check_must_not_suspend_def(\n }\n \n /// This struct facilitates computing the ranges for which a place is uninitialized.\n-struct DropRangeVisitor {\n-    consumed_places: HirIdSet,\n+struct DropRangeVisitor<'tcx> {\n+    hir: Map<'tcx>,\n+    /// Maps a HirId to a set of HirIds that are dropped by that node.\n+    consumed_places: HirIdMap<HirIdSet>,\n     borrowed_places: HirIdSet,\n     drop_ranges: Vec<HirIdMap<DropRange>>,\n     expr_count: usize,\n }\n \n-impl DropRangeVisitor {\n+impl DropRangeVisitor<'tcx> {\n+    fn mark_consumed(&mut self, consumer: HirId, target: HirId) {\n+        if !self.consumed_places.contains_key(&consumer) {\n+            self.consumed_places.insert(consumer, <_>::default());\n+        }\n+        self.consumed_places.get_mut(&consumer).map(|places| places.insert(target));\n+    }\n+\n     fn record_drop(&mut self, hir_id: HirId) {\n         let drop_ranges = self.drop_ranges.last_mut().unwrap();\n         if self.borrowed_places.contains(&hir_id) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n-        } else if self.consumed_places.contains(&hir_id) {\n+        } else {\n             debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n             drop_ranges.insert(hir_id, DropRange { dropped_at: self.expr_count });\n         }\n@@ -700,15 +711,24 @@ impl DropRangeVisitor {\n     /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n     /// expressions. This method consumes a little deeper into the expression when needed.\n     fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n-        self.record_drop(expr.hir_id);\n-        match expr.kind {\n-            hir::ExprKind::Path(hir::QPath::Resolved(\n-                _,\n-                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n-            )) => {\n-                self.record_drop(*hir_id);\n+        debug!(\"consuming expr {:?}, count={}\", expr.hir_id, self.expr_count);\n+        let places = self\n+            .consumed_places\n+            .get(&expr.hir_id)\n+            .map_or(vec![], |places| places.iter().cloned().collect());\n+        for place in places {\n+            self.record_drop(place);\n+            if let Some(Node::Expr(expr)) = self.hir.find(place) {\n+                match expr.kind {\n+                    hir::ExprKind::Path(hir::QPath::Resolved(\n+                        _,\n+                        hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+                    )) => {\n+                        self.record_drop(*hir_id);\n+                    }\n+                    _ => (),\n+                }\n             }\n-            _ => (),\n         }\n     }\n }\n@@ -721,15 +741,19 @@ fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n     }\n }\n \n-impl<'tcx> expr_use_visitor::Delegate<'tcx> for DropRangeVisitor {\n+impl<'tcx> expr_use_visitor::Delegate<'tcx> for DropRangeVisitor<'tcx> {\n     fn consume(\n         &mut self,\n         place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n         diag_expr_id: hir::HirId,\n     ) {\n-        debug!(\"consume {:?}; diag_expr_id={:?}\", place_with_id, diag_expr_id);\n-        self.consumed_places.insert(place_with_id.hir_id);\n-        place_hir_id(&place_with_id.place).map(|place| self.consumed_places.insert(place));\n+        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n+            Some(parent) => parent,\n+            None => place_with_id.hir_id,\n+        };\n+        debug!(\"consume {:?}; diag_expr_id={:?}, using parent {:?}\", place_with_id, diag_expr_id, parent);\n+        self.mark_consumed(parent, place_with_id.hir_id);\n+        place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n     }\n \n     fn borrow(\n@@ -757,7 +781,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for DropRangeVisitor {\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for DropRangeVisitor {\n+impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n     type Map = intravisit::ErasedMap<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n@@ -766,20 +790,20 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         match expr.kind {\n-            ExprKind::AssignOp(_, lhs, rhs) => {\n+            ExprKind::AssignOp(_op, lhs, rhs) => {\n                 // These operations are weird because their order of evaluation depends on whether\n                 // the operator is overloaded. In a perfect world, we'd just ask the type checker\n                 // whether this is a method call, but we also need to match the expression IDs\n                 // from RegionResolutionVisitor. RegionResolutionVisitor doesn't know the order,\n                 // so it runs both orders and picks the most conservative. We'll mirror that here.\n                 let mut old_count = self.expr_count;\n-                intravisit::walk_expr(self, lhs);\n-                intravisit::walk_expr(self, rhs);\n+                self.visit_expr(lhs);\n+                self.visit_expr(rhs);\n \n                 self.push_drop_scope();\n                 std::mem::swap(&mut old_count, &mut self.expr_count);\n-                intravisit::walk_expr(self, rhs);\n-                intravisit::walk_expr(self, lhs);\n+                self.visit_expr(rhs);\n+                self.visit_expr(lhs);\n \n                 // We should have visited the same number of expressions in either order.\n                 assert_eq!(old_count, self.expr_count);"}, {"sha": "d313691b388577ffb80a60888bf95c513ad5a3aa", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "patch": "@@ -8,8 +8,16 @@ async fn bar<T>() -> () {}\n async fn foo() {\n     bar().await;\n     //~^ ERROR type inside `async fn` body must be known in this context\n+    //~| ERROR type inside `async fn` body must be known in this context\n+    //~| ERROR type inside `async fn` body must be known in this context\n     //~| NOTE cannot infer type for type parameter `T`\n+    //~| NOTE cannot infer type for type parameter `T`\n+    //~| NOTE cannot infer type for type parameter `T`\n+    //~| NOTE the type is part of the `async fn` body because of this `await`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n+    //~| NOTE the type is part of the `async fn` body because of this `await`\n+    //~| NOTE in this expansion of desugaring of `await`\n+    //~| NOTE in this expansion of desugaring of `await`\n     //~| NOTE in this expansion of desugaring of `await`\n }\n fn main() {}"}, {"sha": "6a268bcda62975635bbbea1d1b4b68b8759e72b8", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "patch": "@@ -10,6 +10,30 @@ note: the type is part of the `async fn` body because of this `await`\n LL |     bar().await;\n    |          ^^^^^^\n \n-error: aborting due to previous error\n+error[E0698]: type inside `async fn` body must be known in this context\n+  --> $DIR/unresolved_type_param.rs:9:5\n+   |\n+LL |     bar().await;\n+   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n+   |\n+note: the type is part of the `async fn` body because of this `await`\n+  --> $DIR/unresolved_type_param.rs:9:5\n+   |\n+LL |     bar().await;\n+   |     ^^^^^^^^^^^\n+\n+error[E0698]: type inside `async fn` body must be known in this context\n+  --> $DIR/unresolved_type_param.rs:9:5\n+   |\n+LL |     bar().await;\n+   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n+   |\n+note: the type is part of the `async fn` body because of this `await`\n+  --> $DIR/unresolved_type_param.rs:9:5\n+   |\n+LL |     bar().await;\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0698`."}, {"sha": "81a08579bb7bcdf24b62cc49d11ab6045da67b47", "filename": "src/test/ui/lint/must_not_suspend/dedup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.rs?ref=f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "patch": "@@ -13,7 +13,7 @@ async fn wheeee<T>(t: T) {\n }\n \n async fn yes() {\n-    wheeee(No {}).await; //~ ERROR `No` held across\n+    wheeee(&No {}).await; //~ ERROR `No` held across\n }\n \n fn main() {"}, {"sha": "d15137474527e8e1605581bfcd1a6fa56612a4b9", "filename": "src/test/ui/lint/must_not_suspend/dedup.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f246c0b116cdbbad570c23c5745aa01f6f3f64a0/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fdedup.stderr?ref=f246c0b116cdbbad570c23c5745aa01f6f3f64a0", "patch": "@@ -1,19 +1,19 @@\n error: `No` held across a suspend point, but should not be\n-  --> $DIR/dedup.rs:16:12\n+  --> $DIR/dedup.rs:16:13\n    |\n-LL |     wheeee(No {}).await;\n-   |            ^^^^^ ------ the value is held across this suspend point\n+LL |     wheeee(&No {}).await;\n+   |     --------^^^^^------- the value is held across this suspend point\n    |\n note: the lint level is defined here\n   --> $DIR/dedup.rs:3:9\n    |\n LL | #![deny(must_not_suspend)]\n    |         ^^^^^^^^^^^^^^^^\n help: consider using a block (`{ ... }`) to shrink the value's scope, ending before the suspend point\n-  --> $DIR/dedup.rs:16:12\n+  --> $DIR/dedup.rs:16:13\n    |\n-LL |     wheeee(No {}).await;\n-   |            ^^^^^\n+LL |     wheeee(&No {}).await;\n+   |             ^^^^^\n \n error: aborting due to previous error\n "}]}