{"sha": "3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNWQwZjg5OGMyZjM5OThlNTBjMjE4MGM2MjAyZjE5M2MzYWNkYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-04T14:16:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-04T14:16:13Z"}, "message": "Auto merge of #72882 - marmeladema:save-analysis-hir-tree, r=Xanewok\n\nsave_analysis: work on HIR tree instead of AST\n\nIn order to reduce the uses of `NodeId`s in the compiler, `save_analysis` crate has been reworked to operate on the HIR tree instead of the AST.\n\ncc #50928", "tree": {"sha": "a2607b6c46b42115e7e12d3f6f481bb335e14fed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2607b6c46b42115e7e12d3f6f481bb335e14fed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "html_url": "https://github.com/rust-lang/rust/commit/3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a5cbb0e42f330617a061243f8725d861dd5118b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a5cbb0e42f330617a061243f8725d861dd5118b", "html_url": "https://github.com/rust-lang/rust/commit/2a5cbb0e42f330617a061243f8725d861dd5118b"}, {"sha": "70228f97abaeac7549702503bad10bdb89de00c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/70228f97abaeac7549702503bad10bdb89de00c1", "html_url": "https://github.com/rust-lang/rust/commit/70228f97abaeac7549702503bad10bdb89de00c1"}], "stats": {"total": 1902, "additions": 903, "deletions": 999}, "files": [{"sha": "ccea041699ee18c6ff85acef69d34c94c5e7c739", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "patch": "@@ -346,20 +346,22 @@ pub fn run_compiler(\n \n             queries.global_ctxt()?;\n \n+            // Drop AST after creating GlobalCtxt to free memory\n+            let _timer = sess.prof.generic_activity(\"drop_ast\");\n+            mem::drop(queries.expansion()?.take());\n+\n             if sess.opts.debugging_opts.no_analysis || sess.opts.debugging_opts.ast_json {\n                 return early_exit();\n             }\n \n             if sess.opts.debugging_opts.save_analysis {\n-                let expanded_crate = &queries.expansion()?.peek().0;\n                 let crate_name = queries.crate_name()?.peek().clone();\n                 queries.global_ctxt()?.peek_mut().enter(|tcx| {\n                     let result = tcx.analysis(LOCAL_CRATE);\n \n                     sess.time(\"save_analysis\", || {\n                         save::process_crate(\n                             tcx,\n-                            &expanded_crate,\n                             &crate_name,\n                             &compiler.input(),\n                             None,\n@@ -371,13 +373,7 @@ pub fn run_compiler(\n                     });\n \n                     result\n-                    // AST will be dropped *after* the `after_analysis` callback\n-                    // (needed by the RLS)\n                 })?;\n-            } else {\n-                // Drop AST after creating GlobalCtxt to free memory\n-                let _timer = sess.prof.generic_activity(\"drop_ast\");\n-                mem::drop(queries.expansion()?.take());\n             }\n \n             queries.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n@@ -386,10 +382,6 @@ pub fn run_compiler(\n                 return early_exit();\n             }\n \n-            if sess.opts.debugging_opts.save_analysis {\n-                mem::drop(queries.expansion()?.take());\n-            }\n-\n             queries.ongoing_codegen()?;\n \n             if sess.opts.debugging_opts.print_type_sizes {"}, {"sha": "e642915b86a5e322ccf00d72ce721ee941e40936", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "patch": "@@ -203,6 +203,30 @@ pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility<'_\n     })\n }\n \n+pub fn generic_params_to_string(generic_params: &[GenericParam<'_>]) -> String {\n+    to_string(NO_ANN, |s| s.print_generic_params(generic_params))\n+}\n+\n+pub fn bounds_to_string<'b>(bounds: impl IntoIterator<Item = &'b hir::GenericBound<'b>>) -> String {\n+    to_string(NO_ANN, |s| s.print_bounds(\"\", bounds))\n+}\n+\n+pub fn param_to_string(arg: &hir::Param<'_>) -> String {\n+    to_string(NO_ANN, |s| s.print_param(arg))\n+}\n+\n+pub fn ty_to_string(ty: &hir::Ty<'_>) -> String {\n+    to_string(NO_ANN, |s| s.print_type(ty))\n+}\n+\n+pub fn path_segment_to_string(segment: &hir::PathSegment<'_>) -> String {\n+    to_string(NO_ANN, |s| s.print_path_segment(segment))\n+}\n+\n+pub fn path_to_string(segment: &hir::Path<'_>) -> String {\n+    to_string(NO_ANN, |s| s.print_path(segment, false))\n+}\n+\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) {\n         self.s.cbox(u);"}, {"sha": "a5e61ab9ab033aad25a979aa89e3128c55e4ff72", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 411, "deletions": 505, "changes": 916, "blob_url": "https://github.com/rust-lang/rust/blob/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "patch": "@@ -13,19 +13,19 @@\n //! DumpVisitor walks the AST and processes it, and Dumper is used for\n //! recording the output.\n \n-use rustc_ast::ast::{self, Attribute, NodeId, PatKind};\n-use rustc_ast::ptr::P;\n-use rustc_ast::token;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::walk_list;\n-use rustc_ast_pretty::pprust::{bounds_to_string, generic_params_to_string, ty_to_string};\n+use rustc_ast::ast::{self};\n+use rustc_ast::{token, walk_list};\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir_pretty::{bounds_to_string, generic_params_to_string, ty_to_string};\n+use rustc_middle::hir::map::Map;\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::Input;\n-use rustc_span::source_map::{respan, DUMMY_SP};\n+use rustc_span::source_map::respan;\n use rustc_span::symbol::Ident;\n use rustc_span::*;\n \n@@ -36,7 +36,7 @@ use crate::dumper::{Access, Dumper};\n use crate::sig;\n use crate::span_utils::SpanUtils;\n use crate::{\n-    escape, generated_code, id_from_def_id, id_from_node_id, lower_attributes, PathCollector,\n+    escape, generated_code, id_from_def_id, id_from_hir_id, lower_attributes, PathCollector,\n     SaveContext,\n };\n \n@@ -124,11 +124,11 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.save_ctxt.span_from_span(span)\n     }\n \n-    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n+    fn lookup_def_id(&self, ref_id: hir::HirId) -> Option<DefId> {\n         self.save_ctxt.lookup_def_id(ref_id)\n     }\n \n-    pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n+    pub fn dump_crate_info(&mut self, name: &str, krate: &hir::Crate<'_>) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n             let source_file = Path::new(source_file);\n@@ -151,7 +151,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             },\n             crate_root: crate_root.unwrap_or_else(|| \"<no source>\".to_owned()),\n             external_crates: self.save_ctxt.get_external_crates(),\n-            span: self.span_from_span(krate.span),\n+            span: self.span_from_span(krate.item.span),\n         };\n \n         self.dumper.crate_prelude(data);\n@@ -199,8 +199,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.dumper.compilation_opts(data);\n     }\n \n-    fn write_sub_paths(&mut self, path: &ast::Path) {\n-        for seg in &path.segments {\n+    fn write_sub_paths(&mut self, path: &'tcx hir::Path<'tcx>) {\n+        for seg in path.segments {\n             if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n                 self.dumper.dump_ref(data);\n             }\n@@ -209,31 +209,27 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n+    fn write_sub_paths_truncated(&mut self, path: &'tcx hir::Path<'tcx>) {\n         for seg in &path.segments[..path.segments.len() - 1] {\n             if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n                 self.dumper.dump_ref(data);\n             }\n         }\n     }\n \n-    fn process_formals(&mut self, formals: &'l [ast::Param], qualname: &str) {\n+    fn process_formals(&mut self, formals: &'tcx [hir::Param<'tcx>], qualname: &str) {\n         for arg in formals {\n             self.visit_pat(&arg.pat);\n-            let mut collector = PathCollector::new();\n+            let mut collector = PathCollector::new(self.tcx);\n             collector.visit_pat(&arg.pat);\n \n-            for (id, ident, ..) in collector.collected_idents {\n-                // FIXME(#71104) Should really be using just `node_id_to_hir_id` but\n-                // some `NodeId` do not seem to have a corresponding HirId.\n-                let hir_id = self.tcx.hir().opt_node_id_to_hir_id(id);\n-                let typ =\n-                    match hir_id.and_then(|hir_id| self.save_ctxt.tables.node_type_opt(hir_id)) {\n-                        Some(s) => s.to_string(),\n-                        None => continue,\n-                    };\n+            for (hir_id, ident, ..) in collector.collected_idents {\n+                let typ = match self.save_ctxt.tables.node_type_opt(hir_id) {\n+                    Some(s) => s.to_string(),\n+                    None => continue,\n+                };\n                 if !self.span.filter_generated(ident.span) {\n-                    let id = id_from_node_id(id, &self.save_ctxt);\n+                    let id = id_from_hir_id(hir_id, &self.save_ctxt);\n                     let span = self.span_from_span(ident.span);\n \n                     self.dumper.dump_def(\n@@ -260,75 +256,74 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n     fn process_method(\n         &mut self,\n-        sig: &'l ast::FnSig,\n-        body: Option<&'l ast::Block>,\n-        id: ast::NodeId,\n+        sig: &'tcx hir::FnSig<'tcx>,\n+        body: Option<hir::BodyId>,\n+        hir_id: hir::HirId,\n         ident: Ident,\n-        generics: &'l ast::Generics,\n-        vis: ast::Visibility,\n+        generics: &'tcx hir::Generics<'tcx>,\n+        vis: &hir::Visibility<'tcx>,\n         span: Span,\n     ) {\n-        debug!(\"process_method: {}:{}\", id, ident);\n+        debug!(\"process_method: {}:{}\", hir_id, ident);\n \n         let map = &self.tcx.hir();\n-        let hir_id = map.node_id_to_hir_id(id);\n         self.nest_tables(map.local_def_id(hir_id), |v| {\n-            if let Some(mut method_data) = v.save_ctxt.get_method_data(id, ident, span) {\n-                v.process_formals(&sig.decl.inputs, &method_data.qualname);\n-                v.process_generic_params(&generics, &method_data.qualname, id);\n+            if let Some(mut method_data) = v.save_ctxt.get_method_data(hir_id, ident, span) {\n+                if let Some(body) = body {\n+                    v.process_formals(map.body(body).params, &method_data.qualname);\n+                }\n+                v.process_generic_params(&generics, &method_data.qualname, hir_id);\n \n                 method_data.value = crate::make_signature(&sig.decl, &generics);\n-                method_data.sig = sig::method_signature(id, ident, generics, sig, &v.save_ctxt);\n+                method_data.sig = sig::method_signature(hir_id, ident, generics, sig, &v.save_ctxt);\n \n                 v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, hir_id), method_data);\n             }\n \n             // walk arg and return types\n-            for arg in &sig.decl.inputs {\n-                v.visit_ty(&arg.ty);\n+            for arg in sig.decl.inputs {\n+                v.visit_ty(arg);\n             }\n \n-            if let ast::FnRetTy::Ty(ref ret_ty) = sig.decl.output {\n-                // In async functions, return types are desugared and redefined\n-                // as an `impl Trait` existential type. Because of this, to match\n-                // the definition paths when resolving nested types we need to\n-                // start walking from the newly-created definition.\n-                match sig.header.asyncness {\n-                    ast::Async::Yes { return_impl_trait_id, .. } => {\n-                        let hir_id = map.node_id_to_hir_id(return_impl_trait_id);\n-                        v.nest_tables(map.local_def_id(hir_id), |v| v.visit_ty(ret_ty))\n-                    }\n-                    _ => v.visit_ty(ret_ty),\n-                }\n+            if let hir::FnRetTy::Return(ref ret_ty) = sig.decl.output {\n+                v.visit_ty(ret_ty)\n             }\n \n             // walk the fn body\n             if let Some(body) = body {\n-                v.visit_block(body);\n+                v.visit_expr(&map.body(body).value);\n             }\n         });\n     }\n \n-    fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n+    fn process_struct_field_def(\n+        &mut self,\n+        field: &'tcx hir::StructField<'tcx>,\n+        parent_id: hir::HirId,\n+    ) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(field.id);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, field, hir_id), field_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, field, field.hir_id), field_data);\n         }\n     }\n \n     // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(&mut self, generics: &'l ast::Generics, prefix: &str, id: NodeId) {\n-        for param in &generics.params {\n+    fn process_generic_params(\n+        &mut self,\n+        generics: &'tcx hir::Generics<'tcx>,\n+        prefix: &str,\n+        id: hir::HirId,\n+    ) {\n+        for param in generics.params {\n             match param.kind {\n-                ast::GenericParamKind::Lifetime { .. } => {}\n-                ast::GenericParamKind::Type { .. } => {\n-                    let param_ss = param.ident.span;\n+                hir::GenericParamKind::Lifetime { .. } => {}\n+                hir::GenericParamKind::Type { .. } => {\n+                    let param_ss = param.name.ident().span;\n                     let name = escape(self.span.snippet(param_ss));\n                     // Append $id to name to make sure each one is unique.\n                     let qualname = format!(\"{}::{}${}\", prefix, name, id);\n                     if !self.span.filter_generated(param_ss) {\n-                        let id = id_from_node_id(param.id, &self.save_ctxt);\n+                        let id = id_from_hir_id(param.hir_id, &self.save_ctxt);\n                         let span = self.span_from_span(param_ss);\n \n                         self.dumper.dump_def(\n@@ -350,98 +345,81 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                         );\n                     }\n                 }\n-                ast::GenericParamKind::Const { .. } => {}\n+                hir::GenericParamKind::Const { .. } => {}\n             }\n         }\n         self.visit_generics(generics);\n     }\n \n     fn process_fn(\n         &mut self,\n-        item: &'l ast::Item,\n-        decl: &'l ast::FnDecl,\n-        header: &'l ast::FnHeader,\n-        ty_params: &'l ast::Generics,\n-        body: Option<&'l ast::Block>,\n+        item: &'tcx hir::Item<'tcx>,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n+        _header: &'tcx hir::FnHeader,\n+        ty_params: &'tcx hir::Generics<'tcx>,\n+        body: hir::BodyId,\n     ) {\n         let map = &self.tcx.hir();\n-        let hir_id = map.node_id_to_hir_id(item.id);\n-        self.nest_tables(map.local_def_id(hir_id), |v| {\n+        self.nest_tables(map.local_def_id(item.hir_id), |v| {\n+            let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n-                v.process_formals(&decl.inputs, &fn_data.qualname);\n-                v.process_generic_params(ty_params, &fn_data.qualname, item.id);\n+                v.process_formals(body.params, &fn_data.qualname);\n+                v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id);\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id), fn_data);\n             }\n \n-            for arg in &decl.inputs {\n-                v.visit_ty(&arg.ty)\n+            for arg in decl.inputs {\n+                v.visit_ty(arg)\n             }\n \n-            if let ast::FnRetTy::Ty(ref ret_ty) = decl.output {\n-                if let ast::TyKind::ImplTrait(..) = ret_ty.kind {\n-                    // FIXME: Opaque type desugaring prevents us from easily\n-                    // processing trait bounds. See `visit_ty` for more details.\n-                } else {\n-                    // In async functions, return types are desugared and redefined\n-                    // as an `impl Trait` existential type. Because of this, to match\n-                    // the definition paths when resolving nested types we need to\n-                    // start walking from the newly-created definition.\n-                    match header.asyncness {\n-                        ast::Async::Yes { return_impl_trait_id, .. } => {\n-                            let hir_id = map.node_id_to_hir_id(return_impl_trait_id);\n-                            v.nest_tables(map.local_def_id(hir_id), |v| v.visit_ty(ret_ty))\n-                        }\n-                        _ => v.visit_ty(ret_ty),\n-                    }\n-                }\n+            if let hir::FnRetTy::Return(ref ret_ty) = decl.output {\n+                v.visit_ty(ret_ty)\n             }\n \n-            walk_list!(v, visit_block, body);\n+            v.visit_expr(&body.value);\n         });\n     }\n \n     fn process_static_or_const_item(\n         &mut self,\n-        item: &'l ast::Item,\n-        typ: &'l ast::Ty,\n-        expr: Option<&'l ast::Expr>,\n+        item: &'tcx hir::Item<'tcx>,\n+        typ: &'tcx hir::Ty<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n     ) {\n-        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(item.hir_id), |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id), var_data);\n             }\n             v.visit_ty(&typ);\n-            walk_list!(v, visit_expr, expr);\n+            v.visit_expr(expr);\n         });\n     }\n \n     fn process_assoc_const(\n         &mut self,\n-        id: ast::NodeId,\n+        hir_id: hir::HirId,\n         ident: Ident,\n-        typ: &'l ast::Ty,\n-        expr: Option<&'l ast::Expr>,\n+        typ: &'tcx hir::Ty<'tcx>,\n+        expr: Option<&'tcx hir::Expr<'tcx>>,\n         parent_id: DefId,\n-        vis: ast::Visibility,\n-        attrs: &'l [Attribute],\n+        vis: &hir::Visibility<'tcx>,\n+        attrs: &'tcx [ast::Attribute],\n     ) {\n-        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n         let qualname =\n             format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n \n         if !self.span.filter_generated(ident.span) {\n-            let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n+            let sig = sig::assoc_const_signature(hir_id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n \n             self.dumper.dump_def(\n                 &access_from_vis!(self.save_ctxt, vis, hir_id),\n                 Def {\n                     kind: DefKind::Const,\n-                    id: id_from_node_id(id, &self.save_ctxt),\n+                    id: id_from_hir_id(hir_id, &self.save_ctxt),\n                     span,\n                     name: ident.name.to_string(),\n                     qualname,\n@@ -468,51 +446,51 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     // FIXME tuple structs should generate tuple-specific data.\n     fn process_struct(\n         &mut self,\n-        item: &'l ast::Item,\n-        def: &'l ast::VariantData,\n-        ty_params: &'l ast::Generics,\n+        item: &'tcx hir::Item<'tcx>,\n+        def: &'tcx hir::VariantData<'tcx>,\n+        ty_params: &'tcx hir::Generics<'tcx>,\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        let qualname =\n-            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n+        let qualname = format!(\n+            \"::{}\",\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n+        );\n \n         let kind = match item.kind {\n-            ast::ItemKind::Struct(_, _) => DefKind::Struct,\n-            ast::ItemKind::Union(_, _) => DefKind::Union,\n+            hir::ItemKind::Struct(_, _) => DefKind::Struct,\n+            hir::ItemKind::Union(_, _) => DefKind::Union,\n             _ => unreachable!(),\n         };\n \n         let (value, fields) = match item.kind {\n-            ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, ..), ..)\n-            | ast::ItemKind::Union(ast::VariantData::Struct(ref fields, ..), ..) => {\n+            hir::ItemKind::Struct(hir::VariantData::Struct(ref fields, ..), ..)\n+            | hir::ItemKind::Union(hir::VariantData::Struct(ref fields, ..), ..) => {\n                 let include_priv_fields = !self.save_ctxt.config.pub_only;\n                 let fields_str = fields\n                     .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, f)| {\n+                    .filter_map(|f| {\n                         if include_priv_fields || f.vis.node.is_pub() {\n-                            f.ident.map(|i| i.to_string()).or_else(|| Some(i.to_string()))\n+                            Some(f.ident.to_string())\n                         } else {\n                             None\n                         }\n                     })\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n                 let value = format!(\"{} {{ {} }}\", name, fields_str);\n-                (value, fields.iter().map(|f| id_from_node_id(f.id, &self.save_ctxt)).collect())\n+                (value, fields.iter().map(|f| id_from_hir_id(f.hir_id, &self.save_ctxt)).collect())\n             }\n             _ => (String::new(), vec![]),\n         };\n \n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, hir_id),\n+                &access_from!(self.save_ctxt, item, item.hir_id),\n                 Def {\n                     kind,\n-                    id: id_from_node_id(item.id, &self.save_ctxt),\n+                    id: id_from_hir_id(item.hir_id, &self.save_ctxt),\n                     span,\n                     name,\n                     qualname: qualname.clone(),\n@@ -522,26 +500,26 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     decl_id: None,\n                     docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, &self.save_ctxt),\n-                    attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+                    attributes: lower_attributes(item.attrs.to_vec(), &self.save_ctxt),\n                 },\n             );\n         }\n \n-        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(item.hir_id), |v| {\n             for field in def.fields() {\n-                v.process_struct_field_def(field, item.id);\n+                v.process_struct_field_def(field, item.hir_id);\n                 v.visit_ty(&field.ty);\n             }\n \n-            v.process_generic_params(ty_params, &qualname, item.id);\n+            v.process_generic_params(ty_params, &qualname, item.hir_id);\n         });\n     }\n \n     fn process_enum(\n         &mut self,\n-        item: &'l ast::Item,\n-        enum_definition: &'l ast::EnumDef,\n-        ty_params: &'l ast::Generics,\n+        item: &'tcx hir::Item<'tcx>,\n+        enum_definition: &'tcx hir::EnumDef<'tcx>,\n+        ty_params: &'tcx hir::Generics<'tcx>,\n     ) {\n         let enum_data = self.save_ctxt.get_item_data(item);\n         let enum_data = match enum_data {\n@@ -550,29 +528,22 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        let access = access_from!(self.save_ctxt, item, hir_id);\n+        let access = access_from!(self.save_ctxt, item, item.hir_id);\n \n-        for variant in &enum_definition.variants {\n+        for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n             let qualname = format!(\"{}::{}\", enum_data.qualname, name);\n             let name_span = variant.ident.span;\n \n             match variant.data {\n-                ast::VariantData::Struct(ref fields, ..) => {\n-                    let fields_str = fields\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(i, f)| {\n-                            f.ident.map(|i| i.to_string()).unwrap_or_else(|| i.to_string())\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \");\n+                hir::VariantData::Struct(ref fields, ..) => {\n+                    let fields_str =\n+                        fields.iter().map(|f| f.ident.to_string()).collect::<Vec<_>>().join(\", \");\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n+                        let id = id_from_hir_id(variant.id, &self.save_ctxt);\n+                        let parent = Some(id_from_hir_id(item.hir_id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n                             &access,\n@@ -589,7 +560,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                                 docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n                                 attributes: lower_attributes(\n-                                    variant.attrs.clone(),\n+                                    variant.attrs.to_vec(),\n                                     &self.save_ctxt,\n                                 ),\n                             },\n@@ -598,7 +569,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 }\n                 ref v => {\n                     let mut value = format!(\"{}::{}\", enum_data.name, name);\n-                    if let &ast::VariantData::Tuple(ref fields, _) = v {\n+                    if let &hir::VariantData::Tuple(ref fields, _) = v {\n                         value.push('(');\n                         value.push_str(\n                             &fields\n@@ -611,8 +582,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     }\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n+                        let id = id_from_hir_id(variant.id, &self.save_ctxt);\n+                        let parent = Some(id_from_hir_id(item.hir_id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n                             &access,\n@@ -629,7 +600,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                                 docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n                                 attributes: lower_attributes(\n-                                    variant.attrs.clone(),\n+                                    variant.attrs.to_vec(),\n                                     &self.save_ctxt,\n                                 ),\n                             },\n@@ -640,20 +611,20 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n             for field in variant.data.fields() {\n                 self.process_struct_field_def(field, variant.id);\n-                self.visit_ty(&field.ty);\n+                self.visit_ty(field.ty);\n             }\n         }\n-        self.process_generic_params(ty_params, &enum_data.qualname, item.id);\n+        self.process_generic_params(ty_params, &enum_data.qualname, item.hir_id);\n         self.dumper.dump_def(&access, enum_data);\n     }\n \n     fn process_impl(\n         &mut self,\n-        item: &'l ast::Item,\n-        generics: &'l ast::Generics,\n-        trait_ref: &'l Option<ast::TraitRef>,\n-        typ: &'l ast::Ty,\n-        impl_items: &'l [P<ast::AssocItem>],\n+        item: &'tcx hir::Item<'tcx>,\n+        generics: &'tcx hir::Generics<'tcx>,\n+        trait_ref: &'tcx Option<hir::TraitRef<'tcx>>,\n+        typ: &'tcx hir::Ty<'tcx>,\n+        impl_items: &'tcx [hir::ImplItemRef<'tcx>],\n     ) {\n         if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n             if !self.span.filter_generated(item.span) {\n@@ -667,46 +638,48 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         let map = &self.tcx.hir();\n-        let hir_id = map.node_id_to_hir_id(item.id);\n-        self.nest_tables(map.local_def_id(hir_id), |v| {\n+        self.nest_tables(map.local_def_id(item.hir_id), |v| {\n             v.visit_ty(&typ);\n             if let &Some(ref trait_ref) = trait_ref {\n-                v.process_path(trait_ref.ref_id, &trait_ref.path);\n+                v.process_path(trait_ref.hir_ref_id, &trait_ref.path);\n             }\n-            v.process_generic_params(generics, \"\", item.id);\n+            v.process_generic_params(generics, \"\", item.hir_id);\n             for impl_item in impl_items {\n-                v.process_impl_item(impl_item, map.local_def_id(hir_id).to_def_id());\n+                v.process_impl_item(\n+                    map.impl_item(impl_item.id),\n+                    map.local_def_id(item.hir_id).to_def_id(),\n+                );\n             }\n         });\n     }\n \n     fn process_trait(\n         &mut self,\n-        item: &'l ast::Item,\n-        generics: &'l ast::Generics,\n-        trait_refs: &'l ast::GenericBounds,\n-        methods: &'l [P<ast::AssocItem>],\n+        item: &'tcx hir::Item<'tcx>,\n+        generics: &'tcx hir::Generics<'tcx>,\n+        trait_refs: hir::GenericBounds<'tcx>,\n+        methods: &'tcx [hir::TraitItemRef],\n     ) {\n         let name = item.ident.to_string();\n         let qualname = format!(\n             \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id())\n+            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n         );\n         let mut val = name.clone();\n         if !generics.params.is_empty() {\n-            val.push_str(&generic_params_to_string(&generics.params));\n+            val.push_str(&generic_params_to_string(generics.params));\n         }\n         if !trait_refs.is_empty() {\n             val.push_str(\": \");\n             val.push_str(&bounds_to_string(trait_refs));\n         }\n         if !self.span.filter_generated(item.ident.span) {\n-            let id = id_from_node_id(item.id, &self.save_ctxt);\n+            let id = id_from_hir_id(item.hir_id, &self.save_ctxt);\n             let span = self.span_from_span(item.ident.span);\n-            let children = methods.iter().map(|i| id_from_node_id(i.id, &self.save_ctxt)).collect();\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n+            let children =\n+                methods.iter().map(|i| id_from_hir_id(i.id.hir_id, &self.save_ctxt)).collect();\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, hir_id),\n+                &access_from!(self.save_ctxt, item, item.hir_id),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -719,20 +692,20 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     decl_id: None,\n                     docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, &self.save_ctxt),\n-                    attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+                    attributes: lower_attributes(item.attrs.to_vec(), &self.save_ctxt),\n                 },\n             );\n         }\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n             let trait_ref = match *super_bound {\n-                ast::GenericBound::Trait(ref trait_ref, _) => trait_ref,\n-                ast::GenericBound::Outlives(..) => continue,\n+                hir::GenericBound::Trait(ref trait_ref, _) => trait_ref,\n+                hir::GenericBound::Outlives(..) => continue,\n             };\n \n             let trait_ref = &trait_ref.trait_ref;\n-            if let Some(id) = self.lookup_def_id(trait_ref.ref_id) {\n+            if let Some(id) = self.lookup_def_id(trait_ref.hir_ref_id) {\n                 let sub_span = trait_ref.path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n                     let span = self.span_from_span(sub_span);\n@@ -746,60 +719,57 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                         kind: RelationKind::SuperTrait,\n                         span,\n                         from: id_from_def_id(id),\n-                        to: id_from_node_id(item.id, &self.save_ctxt),\n+                        to: id_from_hir_id(item.hir_id, &self.save_ctxt),\n                     });\n                 }\n             }\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, &qualname, item.id);\n+        self.process_generic_params(generics, &qualname, item.hir_id);\n         for method in methods {\n             let map = &self.tcx.hir();\n-            self.process_trait_item(method, map.local_def_id_from_node_id(item.id).to_def_id())\n+            self.process_trait_item(\n+                map.trait_item(method.id),\n+                map.local_def_id(item.hir_id).to_def_id(),\n+            )\n         }\n     }\n \n-    // `item` is the module in question, represented as an item.\n-    fn process_mod(&mut self, item: &ast::Item) {\n+    // `item` is the module in question, represented as an( item.\n+    fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item, hir_id), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.hir_id), mod_data);\n         }\n     }\n \n-    fn dump_path_ref(&mut self, id: NodeId, path: &ast::Path) {\n+    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::Path<'tcx>) {\n         let path_data = self.save_ctxt.get_path_data(id, path);\n         if let Some(path_data) = path_data {\n             self.dumper.dump_ref(path_data);\n         }\n     }\n \n-    fn process_path(&mut self, id: NodeId, path: &'l ast::Path) {\n+    fn dump_path_segment_ref(&mut self, id: hir::HirId, segment: &hir::PathSegment<'tcx>) {\n+        let segment_data = self.save_ctxt.get_path_segment_data_with_id(segment, id);\n+        if let Some(segment_data) = segment_data {\n+            self.dumper.dump_ref(segment_data);\n+        }\n+    }\n+\n+    fn process_path(&mut self, id: hir::HirId, path: &'tcx hir::Path<'tcx>) {\n         if self.span.filter_generated(path.span) {\n             return;\n         }\n         self.dump_path_ref(id, path);\n \n         // Type arguments\n-        for seg in &path.segments {\n+        for seg in path.segments {\n             if let Some(ref generic_args) = seg.args {\n-                match **generic_args {\n-                    ast::GenericArgs::AngleBracketed(ref data) => {\n-                        for arg in &data.args {\n-                            if let ast::AngleBracketedArg::Arg(ast::GenericArg::Type(ty)) = arg {\n-                                self.visit_ty(ty);\n-                            }\n-                        }\n-                    }\n-                    ast::GenericArgs::Parenthesized(ref data) => {\n-                        for t in &data.inputs {\n-                            self.visit_ty(t);\n-                        }\n-                        if let ast::FnRetTy::Ty(ty) = &data.output {\n-                            self.visit_ty(ty);\n-                        }\n+                for arg in generic_args.args {\n+                    if let hir::GenericArg::Type(ref ty) = arg {\n+                        self.visit_ty(ty);\n                     }\n                 }\n             }\n@@ -810,14 +780,16 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n     fn process_struct_lit(\n         &mut self,\n-        ex: &'l ast::Expr,\n-        path: &'l ast::Path,\n-        fields: &'l [ast::Field],\n-        variant: &'l ty::VariantDef,\n-        base: &'l Option<P<ast::Expr>>,\n+        ex: &'tcx hir::Expr<'tcx>,\n+        path: &'tcx hir::QPath<'tcx>,\n+        fields: &'tcx [hir::Field<'tcx>],\n+        variant: &'tcx ty::VariantDef,\n+        base: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n-            self.write_sub_paths_truncated(path);\n+            if let hir::QPath::Resolved(_, path) = path {\n+                self.write_sub_paths_truncated(path);\n+            }\n             down_cast_data!(struct_lit_data, RefData, ex.span);\n             if !generated_code(ex.span) {\n                 self.dumper.dump_ref(struct_lit_data);\n@@ -837,9 +809,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n     fn process_method_call(\n         &mut self,\n-        ex: &'l ast::Expr,\n-        seg: &'l ast::PathSegment,\n-        args: &'l [P<ast::Expr>],\n+        ex: &'tcx hir::Expr<'tcx>,\n+        seg: &'tcx hir::PathSegment<'tcx>,\n+        args: &'tcx [hir::Expr<'tcx>],\n     ) {\n         debug!(\"process_method_call {:?} {:?}\", ex, ex.span);\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n@@ -850,33 +822,30 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         // Explicit types in the turbo-fish.\n-        if let Some(ref generic_args) = seg.args {\n-            if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n-                for arg in &data.args {\n-                    if let ast::AngleBracketedArg::Arg(ast::GenericArg::Type(ty)) = arg {\n-                        self.visit_ty(ty)\n-                    };\n-                }\n+        if let Some(generic_args) = seg.args {\n+            for arg in generic_args.args {\n+                if let hir::GenericArg::Type(ty) = arg {\n+                    self.visit_ty(&ty)\n+                };\n             }\n         }\n \n         // walk receiver and args\n         walk_list!(self, visit_expr, args);\n     }\n \n-    fn process_pat(&mut self, p: &'l ast::Pat) {\n+    fn process_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         match p.kind {\n-            PatKind::Struct(ref _path, ref fields, _) => {\n+            hir::PatKind::Struct(ref _path, fields, _) => {\n                 // FIXME do something with _path?\n-                let hir_id = self.tcx.hir().node_id_to_hir_id(p.id);\n-                let adt = match self.save_ctxt.tables.node_type_opt(hir_id) {\n+                let adt = match self.save_ctxt.tables.node_type_opt(p.hir_id) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n-                        visit::walk_pat(self, p);\n+                        intravisit::walk_pat(self, p);\n                         return;\n                     }\n                 };\n-                let variant = adt.variant_of_res(self.save_ctxt.get_path_res(p.id));\n+                let variant = adt.variant_of_res(self.save_ctxt.get_path_res(p.hir_id));\n \n                 for field in fields {\n                     if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n@@ -892,22 +861,22 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     self.visit_pat(&field.pat);\n                 }\n             }\n-            _ => visit::walk_pat(self, p),\n+            _ => intravisit::walk_pat(self, p),\n         }\n     }\n \n-    fn process_var_decl(&mut self, pat: &'l ast::Pat) {\n+    fn process_var_decl(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         // The pattern could declare multiple new vars,\n         // we must walk the pattern and collect them all.\n-        let mut collector = PathCollector::new();\n+        let mut collector = PathCollector::new(self.tcx);\n         collector.visit_pat(&pat);\n         self.visit_pat(&pat);\n \n         // Process collected paths.\n         for (id, ident, _) in collector.collected_idents {\n-            match self.save_ctxt.get_path_res(id) {\n+            let res = self.save_ctxt.get_path_res(id);\n+            match res {\n                 Res::Local(hir_id) => {\n-                    let id = self.tcx.hir().hir_id_to_node_id(hir_id);\n                     let typ = self\n                         .save_ctxt\n                         .tables\n@@ -917,8 +886,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n                     // Rust uses the id of the pattern for var lookups, so we'll use it too.\n                     if !self.span.filter_generated(ident.span) {\n-                        let qualname = format!(\"{}${}\", ident.to_string(), id);\n-                        let id = id_from_node_id(id, &self.save_ctxt);\n+                        let qualname = format!(\"{}${}\", ident.to_string(), hir_id);\n+                        let id = id_from_hir_id(hir_id, &self.save_ctxt);\n                         let span = self.span_from_span(ident.span);\n \n                         self.dumper.dump_def(\n@@ -951,7 +920,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     _,\n                 )\n                 | Res::SelfTy(..) => {\n-                    self.dump_path_ref(id, &ast::Path::from_ident(ident));\n+                    self.dump_path_segment_ref(id, &hir::PathSegment::from_ident(ident));\n                 }\n                 def => {\n                     error!(\"unexpected definition kind when processing collected idents: {:?}\", def)\n@@ -960,7 +929,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         for (id, ref path) in collector.collected_paths {\n-            self.process_path(id, path);\n+            if let hir::QPath::Resolved(_, path) = path {\n+                self.process_path(id, path);\n+            }\n         }\n     }\n \n@@ -1007,45 +978,49 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         // }\n     }\n \n-    fn process_trait_item(&mut self, trait_item: &'l ast::AssocItem, trait_id: DefId) {\n+    fn process_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>, trait_id: DefId) {\n         self.process_macro_use(trait_item.span);\n         let vis_span = trait_item.span.shrink_to_lo();\n         match trait_item.kind {\n-            ast::AssocItemKind::Const(_, ref ty, ref expr) => {\n+            hir::TraitItemKind::Const(ref ty, body) => {\n+                let body = body.map(|b| &self.tcx.hir().body(b).value);\n+                let respan = respan(vis_span, hir::VisibilityKind::Public);\n                 self.process_assoc_const(\n-                    trait_item.id,\n+                    trait_item.hir_id,\n                     trait_item.ident,\n                     &ty,\n-                    expr.as_ref().map(|e| &**e),\n+                    body,\n                     trait_id,\n-                    respan(vis_span, ast::VisibilityKind::Public),\n+                    &respan,\n                     &trait_item.attrs,\n                 );\n             }\n-            ast::AssocItemKind::Fn(_, ref sig, ref generics, ref body) => {\n+            hir::TraitItemKind::Fn(ref sig, ref trait_fn) => {\n+                let body =\n+                    if let hir::TraitFn::Provided(body) = trait_fn { Some(*body) } else { None };\n+                let respan = respan(vis_span, hir::VisibilityKind::Public);\n                 self.process_method(\n                     sig,\n-                    body.as_ref().map(|x| &**x),\n-                    trait_item.id,\n+                    body,\n+                    trait_item.hir_id,\n                     trait_item.ident,\n-                    generics,\n-                    respan(vis_span, ast::VisibilityKind::Public),\n+                    &trait_item.generics,\n+                    &respan,\n                     trait_item.span,\n                 );\n             }\n-            ast::AssocItemKind::TyAlias(_, _, ref bounds, ref default_ty) => {\n+            hir::TraitItemKind::Type(ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\n                     \"::{}\",\n-                    self.tcx.def_path_str(\n-                        self.tcx.hir().local_def_id_from_node_id(trait_item.id).to_def_id()\n-                    )\n+                    self.tcx\n+                        .def_path_str(self.tcx.hir().local_def_id(trait_item.hir_id).to_def_id())\n                 );\n \n                 if !self.span.filter_generated(trait_item.ident.span) {\n                     let span = self.span_from_span(trait_item.ident.span);\n-                    let id = id_from_node_id(trait_item.id, &self.save_ctxt);\n+                    let id = id_from_hir_id(trait_item.hir_id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n                         &Access { public: true, reachable: true },\n@@ -1061,13 +1036,16 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                             decl_id: None,\n                             docs: self.save_ctxt.docs_for_attrs(&trait_item.attrs),\n                             sig: sig::assoc_type_signature(\n-                                trait_item.id,\n+                                trait_item.hir_id,\n                                 trait_item.ident,\n                                 Some(bounds),\n                                 default_ty.as_ref().map(|ty| &**ty),\n                                 &self.save_ctxt,\n                             ),\n-                            attributes: lower_attributes(trait_item.attrs.clone(), &self.save_ctxt),\n+                            attributes: lower_attributes(\n+                                trait_item.attrs.to_vec(),\n+                                &self.save_ctxt,\n+                            ),\n                         },\n                     );\n                 }\n@@ -1076,124 +1054,150 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     self.visit_ty(default_ty)\n                 }\n             }\n-            ast::AssocItemKind::MacCall(_) => {}\n         }\n     }\n \n-    fn process_impl_item(&mut self, impl_item: &'l ast::AssocItem, impl_id: DefId) {\n+    fn process_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>, impl_id: DefId) {\n         self.process_macro_use(impl_item.span);\n         match impl_item.kind {\n-            ast::AssocItemKind::Const(_, ref ty, ref expr) => {\n+            hir::ImplItemKind::Const(ref ty, body) => {\n+                let body = self.tcx.hir().body(body);\n                 self.process_assoc_const(\n-                    impl_item.id,\n+                    impl_item.hir_id,\n                     impl_item.ident,\n                     &ty,\n-                    expr.as_deref(),\n+                    Some(&body.value),\n                     impl_id,\n-                    impl_item.vis.clone(),\n+                    &impl_item.vis,\n                     &impl_item.attrs,\n                 );\n             }\n-            ast::AssocItemKind::Fn(_, ref sig, ref generics, ref body) => {\n+            hir::ImplItemKind::Fn(ref sig, body) => {\n                 self.process_method(\n                     sig,\n-                    body.as_deref(),\n-                    impl_item.id,\n+                    Some(body),\n+                    impl_item.hir_id,\n                     impl_item.ident,\n-                    generics,\n-                    impl_item.vis.clone(),\n+                    &impl_item.generics,\n+                    &impl_item.vis,\n                     impl_item.span,\n                 );\n             }\n-            ast::AssocItemKind::TyAlias(_, _, _, None) => {}\n-            ast::AssocItemKind::TyAlias(_, _, _, Some(ref ty)) => {\n+            hir::ImplItemKind::OpaqueTy(..) => {}\n+            hir::ImplItemKind::TyAlias(ref ty) => {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n                 self.visit_ty(ty)\n             }\n-            ast::AssocItemKind::MacCall(_) => {}\n         }\n     }\n \n-    /// Dumps imports in a use tree recursively.\n-    ///\n-    /// A use tree is an import that may contain nested braces (RFC 2128). The `use_tree` parameter\n-    /// is the current use tree under scrutiny, while `id` and `prefix` are its corresponding node\n-    /// ID and path. `root_item` is the topmost use tree in the hierarchy.\n-    ///\n-    /// If `use_tree` is a simple or glob import, it is dumped into the analysis data. Otherwise,\n-    /// each child use tree is dumped recursively.\n-    fn process_use_tree(\n-        &mut self,\n-        use_tree: &'l ast::UseTree,\n-        id: NodeId,\n-        root_item: &'l ast::Item,\n-        prefix: &ast::Path,\n-    ) {\n-        let path = &use_tree.prefix;\n-\n-        // The access is calculated using the current tree ID, but with the root tree's visibility\n-        // (since nested trees don't have their own visibility).\n-        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n-        let access = access_from!(self.save_ctxt, root_item, hir_id);\n-\n-        // The parent `DefId` of a given use tree is always the enclosing item.\n-        let parent = self\n-            .save_ctxt\n-            .tcx\n-            .hir()\n-            .opt_local_def_id_from_node_id(id)\n-            .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n-            .map(id_from_def_id);\n-\n-        match use_tree.kind {\n-            ast::UseTreeKind::Simple(alias, ..) => {\n-                let ident = use_tree.ident();\n-                let path = ast::Path {\n-                    segments: prefix.segments.iter().chain(path.segments.iter()).cloned().collect(),\n-                    span: path.span,\n-                };\n+    pub(crate) fn process_crate(&mut self, krate: &'tcx hir::Crate<'tcx>) {\n+        let id = hir::CRATE_HIR_ID;\n+        let qualname =\n+            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(id).to_def_id()));\n+\n+        let sm = self.tcx.sess.source_map();\n+        let filename = sm.span_to_filename(krate.item.span);\n+        let data_id = id_from_hir_id(id, &self.save_ctxt);\n+        let children = krate\n+            .item\n+            .module\n+            .item_ids\n+            .iter()\n+            .map(|i| id_from_hir_id(i.id, &self.save_ctxt))\n+            .collect();\n+        let span = self.span_from_span(krate.item.span);\n+\n+        self.dumper.dump_def(\n+            &Access { public: true, reachable: true },\n+            Def {\n+                kind: DefKind::Mod,\n+                id: data_id,\n+                name: String::new(),\n+                qualname,\n+                span,\n+                value: filename.to_string(),\n+                children,\n+                parent: None,\n+                decl_id: None,\n+                docs: self.save_ctxt.docs_for_attrs(krate.item.attrs),\n+                sig: None,\n+                attributes: lower_attributes(krate.item.attrs.to_owned(), &self.save_ctxt),\n+            },\n+        );\n+        intravisit::walk_crate(self, krate);\n+    }\n+\n+    fn process_bounds(&mut self, bounds: hir::GenericBounds<'tcx>) {\n+        for bound in bounds {\n+            if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n+                self.process_path(trait_ref.trait_ref.hir_ref_id, &trait_ref.trait_ref.path)\n+            }\n+        }\n+    }\n+}\n \n+impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.tcx.hir())\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+        self.process_macro_use(item.span);\n+        match item.kind {\n+            hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let ref_id = self.lookup_def_id(id).map(id_from_def_id);\n-                    let alias_span = alias.map(|i| self.span_from_span(i.span));\n+                    let access = access_from!(self.save_ctxt, item, item.hir_id);\n+                    let ref_id = self.lookup_def_id(item.hir_id).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n+                    let parent = self\n+                        .save_ctxt\n+                        .tcx\n+                        .hir()\n+                        .opt_local_def_id(item.hir_id)\n+                        .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n+                        .map(id_from_def_id);\n                     self.dumper.import(\n                         &access,\n                         Import {\n                             kind: ImportKind::Use,\n                             ref_id,\n                             span,\n-                            alias_span,\n-                            name: ident.to_string(),\n+                            alias_span: None,\n+                            name: item.ident.to_string(),\n                             value: String::new(),\n                             parent,\n                         },\n                     );\n                     self.write_sub_paths_truncated(&path);\n                 }\n             }\n-            ast::UseTreeKind::Glob => {\n-                let path = ast::Path {\n-                    segments: prefix.segments.iter().chain(path.segments.iter()).cloned().collect(),\n-                    span: path.span,\n-                };\n-\n+            hir::ItemKind::Use(path, hir::UseKind::Glob) => {\n                 // Make a comma-separated list of names of imported modules.\n-                let def_id = self.tcx.hir().local_def_id_from_node_id(id);\n+                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 let names = self.tcx.names_imported_by_glob_use(def_id);\n                 let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) =\n-                    self.span.sub_span_of_token(use_tree.span, token::BinOp(token::Star))\n+                    self.span.sub_span_of_token(item.span, token::BinOp(token::Star))\n                 {\n-                    if !self.span.filter_generated(use_tree.span) {\n+                    if !self.span.filter_generated(item.span) {\n+                        let access = access_from!(self.save_ctxt, item, item.hir_id);\n                         let span = self.span_from_span(sub_span);\n-\n+                        let parent = self\n+                            .save_ctxt\n+                            .tcx\n+                            .hir()\n+                            .opt_local_def_id(item.hir_id)\n+                            .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n+                            .map(id_from_def_id);\n                         self.dumper.import(\n                             &access,\n                             Import {\n@@ -1210,81 +1214,15 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::UseTreeKind::Nested(ref nested_items) => {\n-                let prefix = ast::Path {\n-                    segments: prefix.segments.iter().chain(path.segments.iter()).cloned().collect(),\n-                    span: path.span,\n-                };\n-                for &(ref tree, id) in nested_items {\n-                    self.process_use_tree(tree, id, root_item, &prefix);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn process_bounds(&mut self, bounds: &'l ast::GenericBounds) {\n-        for bound in bounds {\n-            if let ast::GenericBound::Trait(ref trait_ref, _) = *bound {\n-                self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n-    fn visit_mod(&mut self, m: &'l ast::Mod, span: Span, attrs: &[ast::Attribute], id: NodeId) {\n-        // Since we handle explicit modules ourselves in visit_item, this should\n-        // only get called for the root module of a crate.\n-        assert_eq!(id, ast::CRATE_NODE_ID);\n-\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(id).to_def_id())\n-        );\n-\n-        let sm = self.tcx.sess.source_map();\n-        let filename = sm.span_to_filename(span);\n-        let data_id = id_from_node_id(id, &self.save_ctxt);\n-        let children = m.items.iter().map(|i| id_from_node_id(i.id, &self.save_ctxt)).collect();\n-        let span = self.span_from_span(span);\n-\n-        self.dumper.dump_def(\n-            &Access { public: true, reachable: true },\n-            Def {\n-                kind: DefKind::Mod,\n-                id: data_id,\n-                name: String::new(),\n-                qualname,\n-                span,\n-                value: filename.to_string(),\n-                children,\n-                parent: None,\n-                decl_id: None,\n-                docs: self.save_ctxt.docs_for_attrs(attrs),\n-                sig: None,\n-                attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n-            },\n-        );\n-        visit::walk_mod(self, m);\n-    }\n-\n-    fn visit_item(&mut self, item: &'l ast::Item) {\n-        use rustc_ast::ast::ItemKind::*;\n-        self.process_macro_use(item.span);\n-        match item.kind {\n-            Use(ref use_tree) => {\n-                let prefix = ast::Path { segments: vec![], span: DUMMY_SP };\n-                self.process_use_tree(use_tree, item.id, item, &prefix);\n-            }\n-            ExternCrate(_) => {\n+            hir::ItemKind::ExternCrate(_) => {\n                 let name_span = item.ident.span;\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n                     let parent = self\n                         .save_ctxt\n                         .tcx\n                         .hir()\n-                        .opt_local_def_id_from_node_id(item.id)\n+                        .opt_local_def_id(item.hir_id)\n                         .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n                         .map(id_from_def_id);\n                     self.dumper.import(\n@@ -1301,43 +1239,44 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                     );\n                 }\n             }\n-            Fn(_, ref sig, ref ty_params, ref body) => {\n-                self.process_fn(item, &sig.decl, &sig.header, ty_params, body.as_deref())\n+            hir::ItemKind::Fn(ref sig, ref ty_params, body) => {\n+                self.process_fn(item, sig.decl, &sig.header, ty_params, body)\n+            }\n+            hir::ItemKind::Static(ref typ, _, body) => {\n+                let body = self.tcx.hir().body(body);\n+                self.process_static_or_const_item(item, typ, &body.value)\n+            }\n+            hir::ItemKind::Const(ref typ, body) => {\n+                let body = self.tcx.hir().body(body);\n+                self.process_static_or_const_item(item, typ, &body.value)\n             }\n-            Static(ref typ, _, ref e) => self.process_static_or_const_item(item, typ, e.as_deref()),\n-            Const(_, ref typ, ref e) => self.process_static_or_const_item(item, typ, e.as_deref()),\n-            Struct(ref def, ref ty_params) | Union(ref def, ref ty_params) => {\n+            hir::ItemKind::Struct(ref def, ref ty_params)\n+            | hir::ItemKind::Union(ref def, ref ty_params) => {\n                 self.process_struct(item, def, ty_params)\n             }\n-            Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            Impl { ref generics, ref of_trait, ref self_ty, ref items, .. } => {\n+            hir::ItemKind::Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n+            hir::ItemKind::Impl { ref generics, ref of_trait, ref self_ty, ref items, .. } => {\n                 self.process_impl(item, generics, of_trait, &self_ty, items)\n             }\n-            Trait(_, _, ref generics, ref trait_refs, ref methods) => {\n+            hir::ItemKind::Trait(_, _, ref generics, ref trait_refs, methods) => {\n                 self.process_trait(item, generics, trait_refs, methods)\n             }\n-            Mod(ref m) => {\n+            hir::ItemKind::Mod(ref m) => {\n                 self.process_mod(item);\n-                visit::walk_mod(self, m);\n+                intravisit::walk_mod(self, m, item.hir_id);\n             }\n-            TyAlias(_, ref ty_params, _, ref ty) => {\n+            hir::ItemKind::TyAlias(ty, ref generics) => {\n                 let qualname = format!(\n                     \"::{}\",\n-                    self.tcx.def_path_str(\n-                        self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id()\n-                    )\n+                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n                 );\n-                let value = match ty {\n-                    Some(ty) => ty_to_string(&ty),\n-                    None => \"_\".to_string(),\n-                };\n+                let value = ty_to_string(&ty);\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n-                    let id = id_from_node_id(item.id, &self.save_ctxt);\n-                    let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n+                    let id = id_from_hir_id(item.hir_id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item, hir_id),\n+                        &access_from!(self.save_ctxt, item, item.hir_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1350,52 +1289,51 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                             decl_id: None,\n                             docs: self.save_ctxt.docs_for_attrs(&item.attrs),\n                             sig: sig::item_signature(item, &self.save_ctxt),\n-                            attributes: lower_attributes(item.attrs.clone(), &self.save_ctxt),\n+                            attributes: lower_attributes(item.attrs.to_vec(), &self.save_ctxt),\n                         },\n                     );\n                 }\n \n-                walk_list!(self, visit_ty, ty);\n-                self.process_generic_params(ty_params, &qualname, item.id);\n+                self.visit_ty(ty);\n+                self.process_generic_params(generics, &qualname, item.hir_id);\n             }\n-            MacCall(_) => (),\n-            _ => visit::walk_item(self, item),\n+            _ => intravisit::walk_item(self, item),\n         }\n     }\n \n-    fn visit_generics(&mut self, generics: &'l ast::Generics) {\n-        for param in &generics.params {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n+        for param in generics.params {\n             match param.kind {\n-                ast::GenericParamKind::Lifetime { .. } => {}\n-                ast::GenericParamKind::Type { ref default, .. } => {\n-                    self.process_bounds(&param.bounds);\n+                hir::GenericParamKind::Lifetime { .. } => {}\n+                hir::GenericParamKind::Type { ref default, .. } => {\n+                    self.process_bounds(param.bounds);\n                     if let Some(ref ty) = default {\n-                        self.visit_ty(&ty);\n+                        self.visit_ty(ty);\n                     }\n                 }\n-                ast::GenericParamKind::Const { ref ty } => {\n-                    self.process_bounds(&param.bounds);\n-                    self.visit_ty(&ty);\n+                hir::GenericParamKind::Const { ref ty } => {\n+                    self.process_bounds(param.bounds);\n+                    self.visit_ty(ty);\n                 }\n             }\n         }\n-        for pred in &generics.where_clause.predicates {\n-            if let ast::WherePredicate::BoundPredicate(ref wbp) = *pred {\n-                self.process_bounds(&wbp.bounds);\n-                self.visit_ty(&wbp.bounded_ty);\n+        for pred in generics.where_clause.predicates {\n+            if let hir::WherePredicate::BoundPredicate(ref wbp) = *pred {\n+                self.process_bounds(wbp.bounds);\n+                self.visit_ty(wbp.bounded_ty);\n             }\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &'l ast::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         self.process_macro_use(t.span);\n         match t.kind {\n-            ast::TyKind::Path(_, ref path) => {\n+            hir::TyKind::Path(hir::QPath::Resolved(_, path)) => {\n                 if generated_code(t.span) {\n                     return;\n                 }\n \n-                if let Some(id) = self.lookup_def_id(t.id) {\n+                if let Some(id) = self.lookup_def_id(t.hir_id) {\n                     let sub_span = path.segments.last().unwrap().ident.span;\n                     let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {\n@@ -1406,57 +1344,37 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 }\n \n                 self.write_sub_paths_truncated(path);\n-                visit::walk_path(self, path);\n+                intravisit::walk_path(self, path);\n             }\n-            ast::TyKind::Array(ref element, ref length) => {\n-                self.visit_ty(element);\n-                let hir_id = self.tcx.hir().node_id_to_hir_id(length.id);\n-                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n-                    v.visit_expr(&length.value)\n+            hir::TyKind::Array(ref ty, ref anon_const) => {\n+                self.visit_ty(ty);\n+                let map = self.tcx.hir();\n+                self.nest_tables(self.tcx.hir().local_def_id(anon_const.hir_id), |v| {\n+                    v.visit_expr(&map.body(anon_const.body).value)\n                 });\n             }\n-            ast::TyKind::ImplTrait(id, ref bounds) => {\n-                // FIXME: As of writing, the opaque type lowering introduces\n-                // another DefPath scope/segment (used to declare the resulting\n-                // opaque type item).\n-                // However, the synthetic scope does *not* have associated\n-                // typeck tables, which means we can't nest it and we fire an\n-                // assertion when resolving the qualified type paths in trait\n-                // bounds...\n-                // This will panic if called on return type `impl Trait`, which\n-                // we guard against in `process_fn`.\n-                // FIXME(#71104) Should really be using just `node_id_to_hir_id` but\n-                // some `NodeId` do not seem to have a corresponding HirId.\n-                if let Some(hir_id) = self.tcx.hir().opt_node_id_to_hir_id(id) {\n-                    self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n-                        v.process_bounds(bounds)\n-                    });\n-                }\n-            }\n-            _ => visit::walk_ty(self, t),\n+            _ => intravisit::walk_ty(self, t),\n         }\n     }\n \n-    fn visit_expr(&mut self, ex: &'l ast::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n         debug!(\"visit_expr {:?}\", ex.kind);\n         self.process_macro_use(ex.span);\n         match ex.kind {\n-            ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-                let expr_hir_id = self.save_ctxt.tcx.hir().node_id_to_hir_id(ex.id);\n-                let hir_expr = self.save_ctxt.tcx.hir().expect_expr(expr_hir_id);\n+            hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n+                let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.hir_id);\n                 let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n-                        visit::walk_expr(self, ex);\n+                        intravisit::walk_expr(self, ex);\n                         return;\n                     }\n                 };\n-                let node_id = self.save_ctxt.tcx.hir().hir_id_to_node_id(hir_expr.hir_id);\n-                let res = self.save_ctxt.get_path_res(node_id);\n-                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), base)\n+                let res = self.save_ctxt.get_path_res(hir_expr.hir_id);\n+                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *base)\n             }\n-            ast::ExprKind::MethodCall(ref seg, ref args) => self.process_method_call(ex, seg, args),\n-            ast::ExprKind::Field(ref sub_ex, _) => {\n+            hir::ExprKind::MethodCall(ref seg, _, args) => self.process_method_call(ex, seg, args),\n+            hir::ExprKind::Field(ref sub_ex, _) => {\n                 self.visit_expr(&sub_ex);\n \n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n@@ -1466,71 +1384,62 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprKind::Closure(_, _, _, ref decl, ref body, _fn_decl_span) => {\n-                let id = format!(\"${}\", ex.id);\n+            hir::ExprKind::Closure(_, ref decl, body, _fn_decl_span, _) => {\n+                let id = format!(\"${}\", ex.hir_id);\n \n                 // walk arg and return types\n-                for arg in &decl.inputs {\n-                    self.visit_ty(&arg.ty);\n+                for ty in decl.inputs {\n+                    self.visit_ty(ty);\n                 }\n \n-                if let ast::FnRetTy::Ty(ref ret_ty) = decl.output {\n-                    self.visit_ty(&ret_ty);\n+                if let hir::FnRetTy::Return(ref ret_ty) = decl.output {\n+                    self.visit_ty(ret_ty);\n                 }\n \n                 // walk the body\n-                let hir_id = self.tcx.hir().node_id_to_hir_id(ex.id);\n-                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n-                    v.process_formals(&decl.inputs, &id);\n-                    v.visit_expr(body)\n+                let map = self.tcx.hir();\n+                self.nest_tables(self.tcx.hir().local_def_id(ex.hir_id), |v| {\n+                    let body = map.body(body);\n+                    v.process_formals(body.params, &id);\n+                    v.visit_expr(&body.value)\n                 });\n             }\n-            ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) => {\n-                self.process_var_decl(pattern);\n-                debug!(\"for loop, walk sub-expr: {:?}\", subexpression.kind);\n-                self.visit_expr(subexpression);\n-                visit::walk_block(self, block);\n-            }\n-            ast::ExprKind::Let(ref pat, ref scrutinee) => {\n-                self.process_var_decl(pat);\n-                self.visit_expr(scrutinee);\n-            }\n-            ast::ExprKind::Repeat(ref element, ref count) => {\n-                self.visit_expr(element);\n-                let hir_id = self.tcx.hir().node_id_to_hir_id(count.id);\n-                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n-                    v.visit_expr(&count.value)\n+            hir::ExprKind::Repeat(ref expr, ref anon_const) => {\n+                self.visit_expr(expr);\n+                let map = self.tcx.hir();\n+                self.nest_tables(self.tcx.hir().local_def_id(anon_const.hir_id), |v| {\n+                    v.visit_expr(&map.body(anon_const.body).value)\n                 });\n             }\n             // In particular, we take this branch for call and path expressions,\n             // where we'll index the idents involved just by continuing to walk.\n-            _ => visit::walk_expr(self, ex),\n+            _ => intravisit::walk_expr(self, ex),\n         }\n     }\n \n-    fn visit_pat(&mut self, p: &'l ast::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         self.process_macro_use(p.span);\n         self.process_pat(p);\n     }\n \n-    fn visit_arm(&mut self, arm: &'l ast::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         self.process_var_decl(&arm.pat);\n-        if let Some(expr) = &arm.guard {\n+        if let Some(hir::Guard::If(expr)) = &arm.guard {\n             self.visit_expr(expr);\n         }\n         self.visit_expr(&arm.body);\n     }\n \n-    fn visit_path(&mut self, p: &'l ast::Path, id: NodeId) {\n+    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n         self.process_path(id, p);\n     }\n \n-    fn visit_stmt(&mut self, s: &'l ast::Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n         self.process_macro_use(s.span);\n-        visit::walk_stmt(self, s)\n+        intravisit::walk_stmt(self, s)\n     }\n \n-    fn visit_local(&mut self, l: &'l ast::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         self.process_macro_use(l.span);\n         self.process_var_decl(&l.pat);\n \n@@ -1539,43 +1448,40 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n         walk_list!(self, visit_expr, &l.init);\n     }\n \n-    fn visit_foreign_item(&mut self, item: &'l ast::ForeignItem) {\n-        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        let access = access_from!(self.save_ctxt, item, hir_id);\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n+        let access = access_from!(self.save_ctxt, item, item.hir_id);\n \n         match item.kind {\n-            ast::ForeignItemKind::Fn(_, ref sig, ref generics, _) => {\n-                let decl = &sig.decl;\n+            hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(fn_data, DefData, item.span);\n \n-                    self.process_generic_params(generics, &fn_data.qualname, item.id);\n+                    self.process_generic_params(generics, &fn_data.qualname, item.hir_id);\n                     self.dumper.dump_def(&access, fn_data);\n                 }\n \n-                for arg in &decl.inputs {\n-                    self.visit_ty(&arg.ty);\n+                for ty in decl.inputs {\n+                    self.visit_ty(ty);\n                 }\n \n-                if let ast::FnRetTy::Ty(ref ret_ty) = decl.output {\n-                    self.visit_ty(&ret_ty);\n+                if let hir::FnRetTy::Return(ref ret_ty) = decl.output {\n+                    self.visit_ty(ret_ty);\n                 }\n             }\n-            ast::ForeignItemKind::Static(ref ty, _, _) => {\n+            hir::ForeignItemKind::Static(ref ty, _) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n                     self.dumper.dump_def(&access, var_data);\n                 }\n \n                 self.visit_ty(ty);\n             }\n-            ast::ForeignItemKind::TyAlias(..) => {\n+            hir::ForeignItemKind::Type => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n                     self.dumper.dump_def(&access, var_data);\n                 }\n             }\n-            ast::ForeignItemKind::MacCall(..) => {}\n         }\n     }\n }"}, {"sha": "8c7731c18e9c4f7eed5ac7cca1202e9a942f7d3a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 220, "deletions": 253, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "patch": "@@ -9,14 +9,16 @@ mod dumper;\n mod span_utils;\n mod sig;\n \n-use rustc_ast::ast::{self, Attribute, NodeId, PatKind, DUMMY_NODE_ID};\n+use rustc_ast::ast::{self};\n use rustc_ast::util::comments::strip_doc_comment_decoration;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast_pretty::pprust::{self, param_to_string, ty_to_string};\n+use rustc_ast_pretty::pprust::attribute_to_string;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind as HirDefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n+use rustc_hir_pretty::ty_to_string;\n+use rustc_middle::hir::map::Map;\n use rustc_middle::middle::cstore::ExternCrate;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n@@ -129,34 +131,32 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         result\n     }\n \n-    pub fn get_extern_item_data(&self, item: &ast::ForeignItem) -> Option<Data> {\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id())\n-        );\n+    pub fn get_extern_item_data(&self, item: &hir::ForeignItem<'_>) -> Option<Data> {\n+        let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n         match item.kind {\n-            ast::ForeignItemKind::Fn(_, ref sig, ref generics, _) => {\n+            hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::ForeignFunction,\n-                    id: id_from_node_id(item.id, self),\n+                    id: id_from_def_id(def_id),\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(&sig.decl, generics),\n+                    value: make_signature(decl, generics),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::foreign_item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.clone(), self),\n+                    attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            ast::ForeignItemKind::Static(ref ty, _, _) => {\n+            hir::ForeignItemKind::Static(ref ty, _) => {\n                 filter!(self.span_utils, item.ident.span);\n \n-                let id = id_from_node_id(item.id, self);\n+                let id = id_from_def_id(def_id);\n                 let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n@@ -171,28 +171,23 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::foreign_item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.clone(), self),\n+                    attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n             // FIXME(plietar): needs a new DefKind in rls-data\n-            ast::ForeignItemKind::TyAlias(..) => None,\n-            ast::ForeignItemKind::MacCall(..) => None,\n+            hir::ForeignItemKind::Type => None,\n         }\n     }\n \n-    pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n+    pub fn get_item_data(&self, item: &hir::Item<'_>) -> Option<Data> {\n+        let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n         match item.kind {\n-            ast::ItemKind::Fn(_, ref sig, .., ref generics, _) => {\n-                let qualname = format!(\n-                    \"::{}\",\n-                    self.tcx.def_path_str(\n-                        self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id()\n-                    )\n-                );\n+            hir::ItemKind::Fn(ref sig, ref generics, _) => {\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n                 filter!(self.span_utils, item.ident.span);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Function,\n-                    id: id_from_node_id(item.id, self),\n+                    id: id_from_def_id(def_id),\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n@@ -202,20 +197,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.clone(), self),\n+                    attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            ast::ItemKind::Static(ref typ, ..) => {\n-                let qualname = format!(\n-                    \"::{}\",\n-                    self.tcx.def_path_str(\n-                        self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id()\n-                    )\n-                );\n+            hir::ItemKind::Static(ref typ, ..) => {\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n \n                 filter!(self.span_utils, item.ident.span);\n \n-                let id = id_from_node_id(item.id, self);\n+                let id = id_from_def_id(def_id);\n                 let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n@@ -230,19 +220,14 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.clone(), self),\n+                    attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            ast::ItemKind::Const(_, ref typ, _) => {\n-                let qualname = format!(\n-                    \"::{}\",\n-                    self.tcx.def_path_str(\n-                        self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id()\n-                    )\n-                );\n+            hir::ItemKind::Const(ref typ, _) => {\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n                 filter!(self.span_utils, item.ident.span);\n \n-                let id = id_from_node_id(item.id, self);\n+                let id = id_from_def_id(def_id);\n                 let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n@@ -257,16 +242,11 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.clone(), self),\n+                    attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            ast::ItemKind::Mod(ref m) => {\n-                let qualname = format!(\n-                    \"::{}\",\n-                    self.tcx.def_path_str(\n-                        self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id()\n-                    )\n-                );\n+            hir::ItemKind::Mod(ref m) => {\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n \n                 let sm = self.tcx.sess.source_map();\n                 let filename = sm.span_to_filename(m.inner);\n@@ -275,48 +255,43 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::Mod,\n-                    id: id_from_node_id(item.id, self),\n+                    id: id_from_def_id(def_id),\n                     name: item.ident.to_string(),\n                     qualname,\n                     span: self.span_from_span(item.ident.span),\n                     value: filename.to_string(),\n                     parent: None,\n-                    children: m.items.iter().map(|i| id_from_node_id(i.id, self)).collect(),\n+                    children: m.item_ids.iter().map(|i| id_from_hir_id(i.id, self)).collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.clone(), self),\n+                    attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            ast::ItemKind::Enum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, _) => {\n                 let name = item.ident.to_string();\n-                let qualname = format!(\n-                    \"::{}\",\n-                    self.tcx.def_path_str(\n-                        self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id()\n-                    )\n-                );\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n                 filter!(self.span_utils, item.ident.span);\n                 let variants_str =\n                     def.variants.iter().map(|v| v.ident.to_string()).collect::<Vec<_>>().join(\", \");\n                 let value = format!(\"{}::{{{}}}\", name, variants_str);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n-                    id: id_from_node_id(item.id, self),\n+                    id: id_from_def_id(def_id),\n                     span: self.span_from_span(item.ident.span),\n                     name,\n                     qualname,\n                     value,\n                     parent: None,\n-                    children: def.variants.iter().map(|v| id_from_node_id(v.id, self)).collect(),\n+                    children: def.variants.iter().map(|v| id_from_hir_id(v.id, self)).collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(item.attrs.clone(), self),\n+                    attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            ast::ItemKind::Impl { ref of_trait, ref self_ty, ref items, .. } => {\n-                if let ast::TyKind::Path(None, ref path) = self_ty.kind {\n+            hir::ItemKind::Impl { ref of_trait, ref self_ty, ref items, .. } => {\n+                if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = self_ty.kind {\n                     // Common case impl for a struct or something basic.\n                     if generated_code(path.span) {\n                         return None;\n@@ -327,7 +302,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     let impl_id = self.next_impl_id();\n                     let span = self.span_from_span(sub_span);\n \n-                    let type_data = self.lookup_def_id(self_ty.id);\n+                    let type_data = self.lookup_def_id(self_ty.hir_id);\n                     type_data.map(|type_data| {\n                         Data::RelationData(\n                             Relation {\n@@ -336,7 +311,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                                 from: id_from_def_id(type_data),\n                                 to: of_trait\n                                     .as_ref()\n-                                    .and_then(|t| self.lookup_def_id(t.ref_id))\n+                                    .and_then(|t| self.lookup_def_id(t.hir_ref_id))\n                                     .map(id_from_def_id)\n                                     .unwrap_or_else(null_id),\n                             },\n@@ -351,7 +326,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                                 parent: None,\n                                 children: items\n                                     .iter()\n-                                    .map(|i| id_from_node_id(i.id, self))\n+                                    .map(|i| id_from_hir_id(i.id.hir_id, self))\n                                     .collect(),\n                                 docs: String::new(),\n                                 sig: None,\n@@ -370,134 +345,128 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<Def> {\n-        if let Some(ident) = field.ident {\n-            let name = ident.to_string();\n-            let qualname = format!(\n-                \"::{}::{}\",\n-                self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(scope).to_def_id()),\n-                ident\n-            );\n-            filter!(self.span_utils, ident.span);\n-            let def_id = self.tcx.hir().local_def_id_from_node_id(field.id).to_def_id();\n-            let typ = self.tcx.type_of(def_id).to_string();\n-\n-            let id = id_from_node_id(field.id, self);\n-            let span = self.span_from_span(ident.span);\n-\n-            Some(Def {\n-                kind: DefKind::Field,\n-                id,\n-                span,\n-                name,\n-                qualname,\n-                value: typ,\n-                parent: Some(id_from_node_id(scope, self)),\n-                children: vec![],\n-                decl_id: None,\n-                docs: self.docs_for_attrs(&field.attrs),\n-                sig: sig::field_signature(field, self),\n-                attributes: lower_attributes(field.attrs.clone(), self),\n-            })\n-        } else {\n-            None\n-        }\n+    pub fn get_field_data(&self, field: &hir::StructField<'_>, scope: hir::HirId) -> Option<Def> {\n+        let name = field.ident.to_string();\n+        let scope_def_id = self.tcx.hir().local_def_id(scope).to_def_id();\n+        let qualname = format!(\"::{}::{}\", self.tcx.def_path_str(scope_def_id), field.ident);\n+        filter!(self.span_utils, field.ident.span);\n+        let field_def_id = self.tcx.hir().local_def_id(field.hir_id).to_def_id();\n+        let typ = self.tcx.type_of(field_def_id).to_string();\n+\n+        let id = id_from_def_id(field_def_id);\n+        let span = self.span_from_span(field.ident.span);\n+\n+        Some(Def {\n+            kind: DefKind::Field,\n+            id,\n+            span,\n+            name,\n+            qualname,\n+            value: typ,\n+            parent: Some(id_from_def_id(scope_def_id)),\n+            children: vec![],\n+            decl_id: None,\n+            docs: self.docs_for_attrs(&field.attrs),\n+            sig: sig::field_signature(field, self),\n+            attributes: lower_attributes(field.attrs.to_vec(), self),\n+        })\n     }\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, id: ast::NodeId, ident: Ident, span: Span) -> Option<Def> {\n+    pub fn get_method_data(&self, hir_id: hir::HirId, ident: Ident, span: Span) -> Option<Def> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let (qualname, parent_scope, decl_id, docs, attributes) = match self\n-            .tcx\n-            .impl_of_method(self.tcx.hir().local_def_id_from_node_id(id).to_def_id())\n-        {\n-            Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n-                Some(Node::Item(item)) => match item.kind {\n-                    hir::ItemKind::Impl { ref self_ty, .. } => {\n-                        let hir = self.tcx.hir();\n-\n-                        let mut qualname = String::from(\"<\");\n-                        qualname.push_str(&rustc_hir_pretty::id_to_string(&hir, self_ty.hir_id));\n-\n-                        let trait_id = self.tcx.trait_id_of_impl(impl_id);\n+        let def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n+        let (qualname, parent_scope, decl_id, docs, attributes) =\n+            match self.tcx.impl_of_method(def_id) {\n+                Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n+                    Some(Node::Item(item)) => match item.kind {\n+                        hir::ItemKind::Impl { ref self_ty, .. } => {\n+                            let hir = self.tcx.hir();\n+\n+                            let mut qualname = String::from(\"<\");\n+                            qualname\n+                                .push_str(&rustc_hir_pretty::id_to_string(&hir, self_ty.hir_id));\n+\n+                            let trait_id = self.tcx.trait_id_of_impl(impl_id);\n+                            let mut docs = String::new();\n+                            let mut attrs = vec![];\n+                            if let Some(Node::ImplItem(item)) = hir.find(hir_id) {\n+                                docs = self.docs_for_attrs(&item.attrs);\n+                                attrs = item.attrs.to_vec();\n+                            }\n+\n+                            let mut decl_id = None;\n+                            if let Some(def_id) = trait_id {\n+                                // A method in a trait impl.\n+                                qualname.push_str(\" as \");\n+                                qualname.push_str(&self.tcx.def_path_str(def_id));\n+\n+                                decl_id = self\n+                                    .tcx\n+                                    .associated_items(def_id)\n+                                    .filter_by_name_unhygienic(ident.name)\n+                                    .next()\n+                                    .map(|item| item.def_id);\n+                            }\n+                            qualname.push_str(\">\");\n+\n+                            (qualname, trait_id, decl_id, docs, attrs)\n+                        }\n+                        _ => {\n+                            span_bug!(\n+                                span,\n+                                \"Container {:?} for method {} not an impl?\",\n+                                impl_id,\n+                                hir_id\n+                            );\n+                        }\n+                    },\n+                    r => {\n+                        span_bug!(\n+                            span,\n+                            \"Container {:?} for method {} is not a node item {:?}\",\n+                            impl_id,\n+                            hir_id,\n+                            r\n+                        );\n+                    }\n+                },\n+                None => match self.tcx.trait_of_item(def_id) {\n+                    Some(def_id) => {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n-                        if let Some(Node::ImplItem(item)) = hir.find(hir.node_id_to_hir_id(id)) {\n+\n+                        if let Some(Node::TraitItem(item)) = self.tcx.hir().find(hir_id) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }\n \n-                        let mut decl_id = None;\n-                        if let Some(def_id) = trait_id {\n-                            // A method in a trait impl.\n-                            qualname.push_str(\" as \");\n-                            qualname.push_str(&self.tcx.def_path_str(def_id));\n-\n-                            decl_id = self\n-                                .tcx\n-                                .associated_items(def_id)\n-                                .filter_by_name_unhygienic(ident.name)\n-                                .next()\n-                                .map(|item| item.def_id);\n-                        }\n-                        qualname.push_str(\">\");\n-\n-                        (qualname, trait_id, decl_id, docs, attrs)\n+                        (\n+                            format!(\"::{}\", self.tcx.def_path_str(def_id)),\n+                            Some(def_id),\n+                            None,\n+                            docs,\n+                            attrs,\n+                        )\n                     }\n-                    _ => {\n-                        span_bug!(span, \"Container {:?} for method {} not an impl?\", impl_id, id);\n+                    None => {\n+                        debug!(\"could not find container for method {} at {:?}\", hir_id, span);\n+                        // This is not necessarily a bug, if there was a compilation error,\n+                        // the tables we need might not exist.\n+                        return None;\n                     }\n                 },\n-                r => {\n-                    span_bug!(\n-                        span,\n-                        \"Container {:?} for method {} is not a node item {:?}\",\n-                        impl_id,\n-                        id,\n-                        r\n-                    );\n-                }\n-            },\n-            None => match self\n-                .tcx\n-                .trait_of_item(self.tcx.hir().local_def_id_from_node_id(id).to_def_id())\n-            {\n-                Some(def_id) => {\n-                    let mut docs = String::new();\n-                    let mut attrs = vec![];\n-                    let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n-\n-                    if let Some(Node::TraitItem(item)) = self.tcx.hir().find(hir_id) {\n-                        docs = self.docs_for_attrs(&item.attrs);\n-                        attrs = item.attrs.to_vec();\n-                    }\n-\n-                    (\n-                        format!(\"::{}\", self.tcx.def_path_str(def_id)),\n-                        Some(def_id),\n-                        None,\n-                        docs,\n-                        attrs,\n-                    )\n-                }\n-                None => {\n-                    debug!(\"could not find container for method {} at {:?}\", id, span);\n-                    // This is not necessarily a bug, if there was a compilation error,\n-                    // the tables we need might not exist.\n-                    return None;\n-                }\n-            },\n-        };\n+            };\n \n         let qualname = format!(\"{}::{}\", qualname, ident.name);\n \n         filter!(self.span_utils, ident.span);\n \n         Some(Def {\n             kind: DefKind::Method,\n-            id: id_from_node_id(id, self),\n+            id: id_from_def_id(def_id),\n             span: self.span_from_span(ident.span),\n             name: ident.name.to_string(),\n             qualname,\n@@ -512,8 +481,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         })\n     }\n \n-    pub fn get_trait_ref_data(&self, trait_ref: &ast::TraitRef) -> Option<Ref> {\n-        self.lookup_def_id(trait_ref.ref_id).and_then(|def_id| {\n+    pub fn get_trait_ref_data(&self, trait_ref: &hir::TraitRef<'_>) -> Option<Ref> {\n+        self.lookup_def_id(trait_ref.hir_ref_id).and_then(|def_id| {\n             let span = trait_ref.path.span;\n             if generated_code(span) {\n                 return None;\n@@ -525,22 +494,20 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         })\n     }\n \n-    pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n-        let expr_hir_id = self.tcx.hir().node_id_to_hir_id(expr.id);\n-        let hir_node = self.tcx.hir().expect_expr(expr_hir_id);\n+    pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n+        let hir_node = self.tcx.hir().expect_expr(expr.hir_id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().kind == ty::Error {\n             return None;\n         }\n         match expr.kind {\n-            ast::ExprKind::Field(ref sub_ex, ident) => {\n-                let sub_ex_hir_id = self.tcx.hir().node_id_to_hir_id(sub_ex.id);\n-                let hir_node = match self.tcx.hir().find(sub_ex_hir_id) {\n+            hir::ExprKind::Field(ref sub_ex, ident) => {\n+                let hir_node = match self.tcx.hir().find(sub_ex.hir_id) {\n                     Some(Node::Expr(expr)) => expr,\n                     _ => {\n                         debug!(\n                             \"Missing or weird node for sub-expression {} in {:?}\",\n-                            sub_ex.id, expr\n+                            sub_ex.hir_id, expr\n                         );\n                         return None;\n                     }\n@@ -567,7 +534,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprKind::Struct(ref path, ..) => {\n+            hir::ExprKind::Struct(hir::QPath::Resolved(_, path), ..) => {\n                 match self.tables.expr_ty_adjusted(&hir_node).kind {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let sub_span = path.segments.last().unwrap().ident.span;\n@@ -587,9 +554,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprKind::MethodCall(ref seg, ..) => {\n-                let expr_hir_id = self.tcx.hir().definitions().node_id_to_hir_id(expr.id);\n-                let method_id = match self.tables.type_dependent_def_id(expr_hir_id) {\n+            hir::ExprKind::MethodCall(ref seg, ..) => {\n+                let method_id = match self.tables.type_dependent_def_id(expr.hir_id) {\n                     Some(id) => id,\n                     None => {\n                         debug!(\"could not resolve method id for {:?}\", expr);\n@@ -609,8 +575,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     ref_id: def_id.or(decl_id).map(id_from_def_id).unwrap_or_else(null_id),\n                 }))\n             }\n-            ast::ExprKind::Path(_, ref path) => {\n-                self.get_path_data(expr.id, path).map(Data::RefData)\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, path)) => {\n+                self.get_path_data(expr.hir_id, path).map(Data::RefData)\n             }\n             _ => {\n                 // FIXME\n@@ -619,12 +585,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_res(&self, id: NodeId) -> Res {\n-        // FIXME(#71104)\n-        let hir_id = match self.tcx.hir().opt_node_id_to_hir_id(id) {\n-            Some(id) => id,\n-            None => return Res::Err,\n-        };\n+    pub fn get_path_res(&self, hir_id: hir::HirId) -> Res {\n         match self.tcx.hir().get(hir_id) {\n             Node::TraitRef(tr) => tr.path.res,\n \n@@ -638,7 +599,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 Some(res) if res != Res::Err => res,\n                 _ => {\n                     let parent_node = self.tcx.hir().get_parent_node(hir_id);\n-                    self.get_path_res(self.tcx.hir().hir_id_to_node_id(parent_node))\n+                    self.get_path_res(parent_node)\n                 }\n             },\n \n@@ -666,33 +627,24 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Ref> {\n+    pub fn get_path_data(&self, id: hir::HirId, path: &hir::Path<'_>) -> Option<Ref> {\n         path.segments.last().and_then(|seg| {\n             self.get_path_segment_data(seg).or_else(|| self.get_path_segment_data_with_id(seg, id))\n         })\n     }\n \n-    pub fn get_path_segment_data(&self, path_seg: &ast::PathSegment) -> Option<Ref> {\n-        self.get_path_segment_data_with_id(path_seg, path_seg.id)\n+    pub fn get_path_segment_data(&self, path_seg: &hir::PathSegment<'_>) -> Option<Ref> {\n+        self.get_path_segment_data_with_id(path_seg, path_seg.hir_id?)\n     }\n \n-    fn get_path_segment_data_with_id(\n+    pub fn get_path_segment_data_with_id(\n         &self,\n-        path_seg: &ast::PathSegment,\n-        id: NodeId,\n+        path_seg: &hir::PathSegment<'_>,\n+        id: hir::HirId,\n     ) -> Option<Ref> {\n         // Returns true if the path is function type sugar, e.g., `Fn(A) -> B`.\n-        fn fn_type(seg: &ast::PathSegment) -> bool {\n-            if let Some(ref generic_args) = seg.args {\n-                if let ast::GenericArgs::Parenthesized(_) = **generic_args {\n-                    return true;\n-                }\n-            }\n-            false\n-        }\n-\n-        if id == DUMMY_NODE_ID {\n-            return None;\n+        fn fn_type(seg: &hir::PathSegment<'_>) -> bool {\n+            seg.args.map(|args| args.parenthesized).unwrap_or(false)\n         }\n \n         let res = self.get_path_res(id);\n@@ -701,11 +653,9 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         let span = self.span_from_span(span);\n \n         match res {\n-            Res::Local(id) => Some(Ref {\n-                kind: RefKind::Variable,\n-                span,\n-                ref_id: id_from_node_id(self.tcx.hir().hir_id_to_node_id(id), self),\n-            }),\n+            Res::Local(id) => {\n+                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_hir_id(id, self) })\n+            }\n             Res::Def(HirDefKind::Trait, def_id) if fn_type(path_seg) => {\n                 Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) })\n             }\n@@ -791,7 +741,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n \n     pub fn get_field_ref_data(\n         &self,\n-        field_ref: &ast::Field,\n+        field_ref: &hir::Field<'_>,\n         variant: &ty::VariantDef,\n     ) -> Option<Ref> {\n         filter!(self.span_utils, field_ref.ident.span);\n@@ -839,14 +789,14 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         })\n     }\n \n-    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n+    fn lookup_def_id(&self, ref_id: hir::HirId) -> Option<DefId> {\n         match self.get_path_res(ref_id) {\n             Res::PrimTy(_) | Res::SelfTy(..) | Res::Err => None,\n             def => def.opt_def_id(),\n         }\n     }\n \n-    fn docs_for_attrs(&self, attrs: &[Attribute]) -> String {\n+    fn docs_for_attrs(&self, attrs: &[ast::Attribute]) -> String {\n         let mut result = String::new();\n \n         for attr in attrs {\n@@ -890,26 +840,26 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n }\n \n-fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n+fn make_signature(decl: &hir::FnDecl<'_>, generics: &hir::Generics<'_>) -> String {\n     let mut sig = \"fn \".to_owned();\n     if !generics.params.is_empty() {\n         sig.push('<');\n         sig.push_str(\n             &generics\n                 .params\n                 .iter()\n-                .map(|param| param.ident.to_string())\n+                .map(|param| param.name.ident().to_string())\n                 .collect::<Vec<_>>()\n                 .join(\", \"),\n         );\n         sig.push_str(\"> \");\n     }\n     sig.push('(');\n-    sig.push_str(&decl.inputs.iter().map(param_to_string).collect::<Vec<_>>().join(\", \"));\n+    sig.push_str(&decl.inputs.iter().map(ty_to_string).collect::<Vec<_>>().join(\", \"));\n     sig.push(')');\n     match decl.output {\n-        ast::FnRetTy::Default(_) => sig.push_str(\" -> ()\"),\n-        ast::FnRetTy::Ty(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n+        hir::FnRetTy::DefaultReturn(_) => sig.push_str(\" -> ()\"),\n+        hir::FnRetTy::Return(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n     }\n \n     sig\n@@ -918,26 +868,33 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n // An AST visitor for collecting paths (e.g., the names of structs) and formal\n // variables (idents) from patterns.\n struct PathCollector<'l> {\n-    collected_paths: Vec<(NodeId, &'l ast::Path)>,\n-    collected_idents: Vec<(NodeId, Ident, ast::Mutability)>,\n+    tcx: TyCtxt<'l>,\n+    collected_paths: Vec<(hir::HirId, &'l hir::QPath<'l>)>,\n+    collected_idents: Vec<(hir::HirId, Ident, hir::Mutability)>,\n }\n \n impl<'l> PathCollector<'l> {\n-    fn new() -> PathCollector<'l> {\n-        PathCollector { collected_paths: vec![], collected_idents: vec![] }\n+    fn new(tcx: TyCtxt<'l>) -> PathCollector<'l> {\n+        PathCollector { tcx, collected_paths: vec![], collected_idents: vec![] }\n     }\n }\n \n impl<'l> Visitor<'l> for PathCollector<'l> {\n-    fn visit_pat(&mut self, p: &'l ast::Pat) {\n+    type Map = Map<'l>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.tcx.hir())\n+    }\n+\n+    fn visit_pat(&mut self, p: &'l hir::Pat<'l>) {\n         match p.kind {\n-            PatKind::Struct(ref path, ..) => {\n-                self.collected_paths.push((p.id, path));\n+            hir::PatKind::Struct(ref path, ..) => {\n+                self.collected_paths.push((p.hir_id, path));\n             }\n-            PatKind::TupleStruct(ref path, ..) | PatKind::Path(_, ref path) => {\n-                self.collected_paths.push((p.id, path));\n+            hir::PatKind::TupleStruct(ref path, ..) | hir::PatKind::Path(ref path) => {\n+                self.collected_paths.push((p.hir_id, path));\n             }\n-            PatKind::Ident(bm, ident, _) => {\n+            hir::PatKind::Binding(bm, _, ident, _) => {\n                 debug!(\n                     \"PathCollector, visit ident in pat {}: {:?} {:?}\",\n                     ident, p.span, ident.span\n@@ -946,14 +903,18 @@ impl<'l> Visitor<'l> for PathCollector<'l> {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n                     // is still worthwhile.\n-                    ast::BindingMode::ByRef(_) => ast::Mutability::Not,\n-                    ast::BindingMode::ByValue(mt) => mt,\n+                    hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Ref => {\n+                        hir::Mutability::Not\n+                    }\n+                    hir::BindingAnnotation::Mutable | hir::BindingAnnotation::RefMut => {\n+                        hir::Mutability::Mut\n+                    }\n                 };\n-                self.collected_idents.push((p.id, ident, immut));\n+                self.collected_idents.push((p.hir_id, ident, immut));\n             }\n             _ => {}\n         }\n-        visit::walk_pat(self, p);\n+        intravisit::walk_pat(self, p);\n     }\n }\n \n@@ -1035,7 +996,6 @@ impl SaveHandler for CallbackHandler<'_> {\n \n pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n     tcx: TyCtxt<'tcx>,\n-    krate: &ast::Crate,\n     cratename: &str,\n     input: &'l Input,\n     config: Option<Config>,\n@@ -1063,9 +1023,9 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n \n         let mut visitor = DumpVisitor::new(save_ctxt);\n \n-        visitor.dump_crate_info(cratename, krate);\n+        visitor.dump_crate_info(cratename, tcx.hir().krate());\n         visitor.dump_compilation_options(input, cratename);\n-        visit::walk_crate(&mut visitor, krate);\n+        visitor.process_crate(tcx.hir().krate());\n \n         handler.save(&visitor.save_ctxt, &visitor.analysis())\n     })\n@@ -1109,21 +1069,28 @@ fn id_from_def_id(id: DefId) -> rls_data::Id {\n     rls_data::Id { krate: id.krate.as_u32(), index: id.index.as_u32() }\n }\n \n-fn id_from_node_id(id: NodeId, scx: &SaveContext<'_, '_>) -> rls_data::Id {\n-    let def_id = scx.tcx.hir().opt_local_def_id_from_node_id(id);\n+fn id_from_hir_id(id: hir::HirId, scx: &SaveContext<'_, '_>) -> rls_data::Id {\n+    let def_id = scx.tcx.hir().opt_local_def_id(id);\n     def_id.map(|id| id_from_def_id(id.to_def_id())).unwrap_or_else(|| {\n-        // Create a *fake* `DefId` out of a `NodeId` by subtracting the `NodeId`\n-        // out of the maximum u32 value. This will work unless you have *billions*\n-        // of definitions in a single crate (very unlikely to actually happen).\n-        rls_data::Id { krate: LOCAL_CRATE.as_u32(), index: !id.as_u32() }\n+        // Create a *fake* `DefId` out of a `HirId` by combining the owner\n+        // `local_def_index` and the `local_id`.\n+        // This will work unless you have *billions* of definitions in a single\n+        // crate (very unlikely to actually happen).\n+        rls_data::Id {\n+            krate: LOCAL_CRATE.as_u32(),\n+            index: id.owner.local_def_index.as_u32() | id.local_id.as_u32().reverse_bits(),\n+        }\n     })\n }\n \n fn null_id() -> rls_data::Id {\n     rls_data::Id { krate: u32::max_value(), index: u32::max_value() }\n }\n \n-fn lower_attributes(attrs: Vec<Attribute>, scx: &SaveContext<'_, '_>) -> Vec<rls_data::Attribute> {\n+fn lower_attributes(\n+    attrs: Vec<ast::Attribute>,\n+    scx: &SaveContext<'_, '_>,\n+) -> Vec<rls_data::Attribute> {\n     attrs\n         .into_iter()\n         // Only retain real attributes. Doc comments are lowered separately.\n@@ -1133,7 +1100,7 @@ fn lower_attributes(attrs: Vec<Attribute>, scx: &SaveContext<'_, '_>) -> Vec<rls\n             // attribute. First normalize all inner attribute (#![..]) to outer\n             // ones (#[..]), then remove the two leading and the one trailing character.\n             attr.style = ast::AttrStyle::Outer;\n-            let value = pprust::attribute_to_string(&attr);\n+            let value = attribute_to_string(&attr);\n             // This str slicing works correctly, because the leading and trailing characters\n             // are in the ASCII range and thus exactly one byte each.\n             let value = value[2..value.len() - 1].to_string();"}, {"sha": "6fec5cdba8b5925b38e47a960443a0d88a3169d3", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 243, "deletions": 228, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5d0f898c2f3998e50c2180c6202f193c3acdbc/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "patch": "@@ -25,24 +25,26 @@\n //\n // FIXME where clauses need implementing, defs/refs in generics are mostly missing.\n \n-use crate::{id_from_def_id, id_from_node_id, SaveContext};\n+use crate::{id_from_def_id, id_from_hir_id, SaveContext};\n \n use rls_data::{SigElement, Signature};\n \n-use rustc_ast::ast::{self, Extern, NodeId};\n-use rustc_ast_pretty::pprust;\n+use rustc_ast::ast::Mutability;\n+use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n+use rustc_hir_pretty::id_to_string;\n+use rustc_hir_pretty::{bounds_to_string, path_segment_to_string, path_to_string, ty_to_string};\n use rustc_span::symbol::{Ident, Symbol};\n \n-pub fn item_signature(item: &ast::Item, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n+pub fn item_signature(item: &hir::Item<'_>, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n     item.make(0, None, scx).ok()\n }\n \n pub fn foreign_item_signature(\n-    item: &ast::ForeignItem,\n+    item: &hir::ForeignItem<'_>,\n     scx: &SaveContext<'_, '_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -53,26 +55,32 @@ pub fn foreign_item_signature(\n \n /// Signature for a struct or tuple field declaration.\n /// Does not include a trailing comma.\n-pub fn field_signature(field: &ast::StructField, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n+pub fn field_signature(\n+    field: &hir::StructField<'_>,\n+    scx: &SaveContext<'_, '_>,\n+) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n     field.make(0, None, scx).ok()\n }\n \n /// Does not include a trailing comma.\n-pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n+pub fn variant_signature(\n+    variant: &hir::Variant<'_>,\n+    scx: &SaveContext<'_, '_>,\n+) -> Option<Signature> {\n     if !scx.config.signatures {\n         return None;\n     }\n     variant.make(0, None, scx).ok()\n }\n \n pub fn method_signature(\n-    id: NodeId,\n+    id: hir::HirId,\n     ident: Ident,\n-    generics: &ast::Generics,\n-    m: &ast::FnSig,\n+    generics: &hir::Generics<'_>,\n+    m: &hir::FnSig<'_>,\n     scx: &SaveContext<'_, '_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -82,10 +90,10 @@ pub fn method_signature(\n }\n \n pub fn assoc_const_signature(\n-    id: NodeId,\n+    id: hir::HirId,\n     ident: Symbol,\n-    ty: &ast::Ty,\n-    default: Option<&ast::Expr>,\n+    ty: &hir::Ty<'_>,\n+    default: Option<&hir::Expr<'_>>,\n     scx: &SaveContext<'_, '_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -95,10 +103,10 @@ pub fn assoc_const_signature(\n }\n \n pub fn assoc_type_signature(\n-    id: NodeId,\n+    id: hir::HirId,\n     ident: Ident,\n-    bounds: Option<&ast::GenericBounds>,\n-    default: Option<&ast::Ty>,\n+    bounds: Option<hir::GenericBounds<'_>>,\n+    default: Option<&hir::Ty<'_>>,\n     scx: &SaveContext<'_, '_>,\n ) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -110,7 +118,7 @@ pub fn assoc_type_signature(\n type Result = std::result::Result<Signature, &'static str>;\n \n trait Sig {\n-    fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result;\n+    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_, '_>) -> Result;\n }\n \n fn extend_sig(\n@@ -145,49 +153,43 @@ fn text_sig(text: String) -> Signature {\n     Signature { text, defs: vec![], refs: vec![] }\n }\n \n-fn push_extern(text: &mut String, ext: Extern) {\n-    match ext {\n-        Extern::None => {}\n-        Extern::Implicit => text.push_str(\"extern \"),\n-        Extern::Explicit(abi) => text.push_str(&format!(\"extern \\\"{}\\\" \", abi.symbol)),\n-    }\n-}\n-\n-impl Sig for ast::Ty {\n-    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n-        let id = Some(self.id);\n+impl<'hir> Sig for hir::Ty<'hir> {\n+    fn make(\n+        &self,\n+        offset: usize,\n+        _parent_id: Option<hir::HirId>,\n+        scx: &SaveContext<'_, '_>,\n+    ) -> Result {\n+        let id = Some(self.hir_id);\n         match self.kind {\n-            ast::TyKind::Slice(ref ty) => {\n+            hir::TyKind::Slice(ref ty) => {\n                 let nested = ty.make(offset + 1, id, scx)?;\n                 let text = format!(\"[{}]\", nested.text);\n                 Ok(replace_text(nested, text))\n             }\n-            ast::TyKind::Ptr(ref mt) => {\n+            hir::TyKind::Ptr(ref mt) => {\n                 let prefix = match mt.mutbl {\n-                    ast::Mutability::Mut => \"*mut \",\n-                    ast::Mutability::Not => \"*const \",\n+                    hir::Mutability::Mut => \"*mut \",\n+                    hir::Mutability::Not => \"*const \",\n                 };\n                 let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n                 let text = format!(\"{}{}\", prefix, nested.text);\n                 Ok(replace_text(nested, text))\n             }\n-            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n+            hir::TyKind::Rptr(ref lifetime, ref mt) => {\n                 let mut prefix = \"&\".to_owned();\n-                if let &Some(ref l) = lifetime {\n-                    prefix.push_str(&l.ident.to_string());\n-                    prefix.push(' ');\n-                }\n-                if let ast::Mutability::Mut = mt.mutbl {\n+                prefix.push_str(&lifetime.name.ident().to_string());\n+                prefix.push(' ');\n+                if let hir::Mutability::Mut = mt.mutbl {\n                     prefix.push_str(\"mut \");\n                 };\n \n                 let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n                 let text = format!(\"{}{}\", prefix, nested.text);\n                 Ok(replace_text(nested, text))\n             }\n-            ast::TyKind::Never => Ok(text_sig(\"!\".to_owned())),\n-            ast::TyKind::CVarArgs => Ok(text_sig(\"...\".to_owned())),\n-            ast::TyKind::Tup(ref ts) => {\n+            hir::TyKind::Never => Ok(text_sig(\"!\".to_owned())),\n+            hir::TyKind::Tup(ts) => {\n                 let mut text = \"(\".to_owned();\n                 let mut defs = vec![];\n                 let mut refs = vec![];\n@@ -201,12 +203,7 @@ impl Sig for ast::Ty {\n                 text.push(')');\n                 Ok(Signature { text, defs, refs })\n             }\n-            ast::TyKind::Paren(ref ty) => {\n-                let nested = ty.make(offset + 1, id, scx)?;\n-                let text = format!(\"({})\", nested.text);\n-                Ok(replace_text(nested, text))\n-            }\n-            ast::TyKind::BareFn(ref f) => {\n+            hir::TyKind::BareFn(ref f) => {\n                 let mut text = String::new();\n                 if !f.generic_params.is_empty() {\n                     // FIXME defs, bounds on lifetimes\n@@ -215,8 +212,8 @@ impl Sig for ast::Ty {\n                         &f.generic_params\n                             .iter()\n                             .filter_map(|param| match param.kind {\n-                                ast::GenericParamKind::Lifetime { .. } => {\n-                                    Some(param.ident.to_string())\n+                                hir::GenericParamKind::Lifetime { .. } => {\n+                                    Some(param.name.ident().to_string())\n                                 }\n                                 _ => None,\n                             })\n@@ -226,23 +223,22 @@ impl Sig for ast::Ty {\n                     text.push('>');\n                 }\n \n-                if let ast::Unsafe::Yes(_) = f.unsafety {\n+                if let hir::Unsafety::Unsafe = f.unsafety {\n                     text.push_str(\"unsafe \");\n                 }\n-                push_extern(&mut text, f.ext);\n                 text.push_str(\"fn(\");\n \n                 let mut defs = vec![];\n                 let mut refs = vec![];\n-                for i in &f.decl.inputs {\n-                    let nested = i.ty.make(offset + text.len(), Some(i.id), scx)?;\n+                for i in f.decl.inputs {\n+                    let nested = i.make(offset + text.len(), Some(i.hir_id), scx)?;\n                     text.push_str(&nested.text);\n                     text.push(',');\n                     defs.extend(nested.defs.into_iter());\n                     refs.extend(nested.refs.into_iter());\n                 }\n                 text.push(')');\n-                if let ast::FnRetTy::Ty(ref t) = f.decl.output {\n+                if let hir::FnRetTy::Return(ref t) = f.decl.output {\n                     text.push_str(\" -> \");\n                     let nested = t.make(offset + text.len(), None, scx)?;\n                     text.push_str(&nested.text);\n@@ -253,23 +249,19 @@ impl Sig for ast::Ty {\n \n                 Ok(Signature { text, defs, refs })\n             }\n-            ast::TyKind::Path(None, ref path) => path.make(offset, id, scx),\n-            ast::TyKind::Path(Some(ref qself), ref path) => {\n-                let nested_ty = qself.ty.make(offset + 1, id, scx)?;\n-                let prefix = if qself.position == 0 {\n-                    format!(\"<{}>::\", nested_ty.text)\n-                } else if qself.position == 1 {\n-                    let first = pprust::path_segment_to_string(&path.segments[0]);\n-                    format!(\"<{} as {}>::\", nested_ty.text, first)\n-                } else {\n-                    // FIXME handle path instead of elipses.\n-                    format!(\"<{} as ...>::\", nested_ty.text)\n-                };\n+            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.make(offset, id, scx),\n+            hir::TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref path)) => {\n+                let nested_ty = qself.make(offset + 1, id, scx)?;\n+                let prefix = format!(\n+                    \"<{} as {}>::\",\n+                    nested_ty.text,\n+                    path_segment_to_string(&path.segments[0])\n+                );\n \n-                let name = pprust::path_segment_to_string(path.segments.last().ok_or(\"Bad path\")?);\n+                let name = path_segment_to_string(path.segments.last().ok_or(\"Bad path\")?);\n                 let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n                 let id = id_from_def_id(res.def_id());\n-                if path.segments.len() - qself.position == 1 {\n+                if path.segments.len() == 2 {\n                     let start = offset + prefix.len();\n                     let end = start + name.len();\n \n@@ -289,44 +281,60 @@ impl Sig for ast::Ty {\n                     })\n                 }\n             }\n-            ast::TyKind::TraitObject(ref bounds, ..) => {\n+            hir::TyKind::TraitObject(bounds, ..) => {\n                 // FIXME recurse into bounds\n-                let nested = pprust::bounds_to_string(bounds);\n+                let bounds: Vec<hir::GenericBound<'_>> = bounds\n+                    .iter()\n+                    .map(|hir::PolyTraitRef { bound_generic_params, trait_ref, span }| {\n+                        hir::GenericBound::Trait(\n+                            hir::PolyTraitRef {\n+                                bound_generic_params,\n+                                trait_ref: hir::TraitRef {\n+                                    path: trait_ref.path,\n+                                    hir_ref_id: trait_ref.hir_ref_id,\n+                                },\n+                                span: *span,\n+                            },\n+                            hir::TraitBoundModifier::None,\n+                        )\n+                    })\n+                    .collect();\n+                let nested = bounds_to_string(&bounds);\n                 Ok(text_sig(nested))\n             }\n-            ast::TyKind::ImplTrait(_, ref bounds) => {\n-                // FIXME recurse into bounds\n-                let nested = pprust::bounds_to_string(bounds);\n-                Ok(text_sig(format!(\"impl {}\", nested)))\n-            }\n-            ast::TyKind::Array(ref ty, ref v) => {\n+            hir::TyKind::Array(ref ty, ref anon_const) => {\n                 let nested_ty = ty.make(offset + 1, id, scx)?;\n-                let expr = pprust::expr_to_string(&v.value).replace('\\n', \" \");\n+                let expr = id_to_string(&scx.tcx.hir(), anon_const.body.hir_id).replace('\\n', \" \");\n                 let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n                 Ok(replace_text(nested_ty, text))\n             }\n-            ast::TyKind::Typeof(_)\n-            | ast::TyKind::Infer\n-            | ast::TyKind::Err\n-            | ast::TyKind::ImplicitSelf\n-            | ast::TyKind::MacCall(_) => Err(\"Ty\"),\n+            hir::TyKind::Typeof(_)\n+            | hir::TyKind::Infer\n+            | hir::TyKind::Def(..)\n+            | hir::TyKind::Path(..)\n+            | hir::TyKind::Err => Err(\"Ty\"),\n         }\n     }\n }\n \n-impl Sig for ast::Item {\n-    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n-        let id = Some(self.id);\n+impl<'hir> Sig for hir::Item<'hir> {\n+    fn make(\n+        &self,\n+        offset: usize,\n+        _parent_id: Option<hir::HirId>,\n+        scx: &SaveContext<'_, '_>,\n+    ) -> Result {\n+        let id = Some(self.hir_id);\n \n         match self.kind {\n-            ast::ItemKind::Static(ref ty, m, ref expr) => {\n+            hir::ItemKind::Static(ref ty, m, ref body) => {\n                 let mut text = \"static \".to_owned();\n-                if m == ast::Mutability::Mut {\n+                if m == hir::Mutability::Mut {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n+                    id: id_from_hir_id(self.hir_id, scx),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -336,21 +344,19 @@ impl Sig for ast::Item {\n                 let ty = ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty.text);\n \n-                if let Some(expr) = expr {\n-                    text.push_str(\" = \");\n-                    let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n-                    text.push_str(&expr);\n-                }\n+                text.push_str(\" = \");\n+                let expr = id_to_string(&scx.tcx.hir(), body.hir_id).replace('\\n', \" \");\n+                text.push_str(&expr);\n \n                 text.push(';');\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Const(_, ref ty, ref expr) => {\n+            hir::ItemKind::Const(ref ty, ref body) => {\n                 let mut text = \"const \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n+                    id: id_from_hir_id(self.hir_id, scx),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -360,46 +366,43 @@ impl Sig for ast::Item {\n                 let ty = ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty.text);\n \n-                if let Some(expr) = expr {\n-                    text.push_str(\" = \");\n-                    let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n-                    text.push_str(&expr);\n-                }\n+                text.push_str(\" = \");\n+                let expr = id_to_string(&scx.tcx.hir(), body.hir_id).replace('\\n', \" \");\n+                text.push_str(&expr);\n \n                 text.push(';');\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Fn(_, ast::FnSig { ref decl, header }, ref generics, _) => {\n+            hir::ItemKind::Fn(hir::FnSig { ref decl, header }, ref generics, _) => {\n                 let mut text = String::new();\n-                if let ast::Const::Yes(_) = header.constness {\n+                if let hir::Constness::Const = header.constness {\n                     text.push_str(\"const \");\n                 }\n-                if header.asyncness.is_async() {\n+                if hir::IsAsync::Async == header.asyncness {\n                     text.push_str(\"async \");\n                 }\n-                if let ast::Unsafe::Yes(_) = header.unsafety {\n+                if let hir::Unsafety::Unsafe = header.unsafety {\n                     text.push_str(\"unsafe \");\n                 }\n-                push_extern(&mut text, header.ext);\n                 text.push_str(\"fn \");\n \n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+                let mut sig =\n+                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n \n                 sig.text.push('(');\n-                for i in &decl.inputs {\n+                for i in decl.inputs {\n                     // FIXME should descend into patterns to add defs.\n-                    sig.text.push_str(&pprust::pat_to_string(&i.pat));\n                     sig.text.push_str(\": \");\n-                    let nested = i.ty.make(offset + sig.text.len(), Some(i.id), scx)?;\n+                    let nested = i.make(offset + sig.text.len(), Some(i.hir_id), scx)?;\n                     sig.text.push_str(&nested.text);\n                     sig.text.push(',');\n                     sig.defs.extend(nested.defs.into_iter());\n                     sig.refs.extend(nested.refs.into_iter());\n                 }\n                 sig.text.push(')');\n \n-                if let ast::FnRetTy::Ty(ref t) = decl.output {\n+                if let hir::FnRetTy::Return(ref t) = decl.output {\n                     sig.text.push_str(\" -> \");\n                     let nested = t.make(offset + sig.text.len(), None, scx)?;\n                     sig.text.push_str(&nested.text);\n@@ -410,11 +413,11 @@ impl Sig for ast::Item {\n \n                 Ok(sig)\n             }\n-            ast::ItemKind::Mod(ref _mod) => {\n+            hir::ItemKind::Mod(ref _mod) => {\n                 let mut text = \"mod \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n+                    id: id_from_hir_id(self.hir_id, scx),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -424,93 +427,97 @@ impl Sig for ast::Item {\n \n                 Ok(Signature { text, defs, refs: vec![] })\n             }\n-            ast::ItemKind::TyAlias(_, ref generics, _, ref ty) => {\n+            hir::ItemKind::TyAlias(ref ty, ref generics) => {\n                 let text = \"type \".to_owned();\n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+                let mut sig =\n+                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n \n                 sig.text.push_str(\" = \");\n-                let ty = match ty {\n-                    Some(ty) => ty.make(offset + sig.text.len(), id, scx)?,\n-                    None => return Err(\"Ty\"),\n-                };\n+                let ty = ty.make(offset + sig.text.len(), id, scx)?;\n                 sig.text.push_str(&ty.text);\n                 sig.text.push(';');\n \n                 Ok(merge_sigs(sig.text.clone(), vec![sig, ty]))\n             }\n-            ast::ItemKind::Enum(_, ref generics) => {\n+            hir::ItemKind::Enum(_, ref generics) => {\n                 let text = \"enum \".to_owned();\n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+                let mut sig =\n+                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n-            ast::ItemKind::Struct(_, ref generics) => {\n+            hir::ItemKind::Struct(_, ref generics) => {\n                 let text = \"struct \".to_owned();\n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+                let mut sig =\n+                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n-            ast::ItemKind::Union(_, ref generics) => {\n+            hir::ItemKind::Union(_, ref generics) => {\n                 let text = \"union \".to_owned();\n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+                let mut sig =\n+                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n-            ast::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, _) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, ref generics, bounds, _) => {\n                 let mut text = String::new();\n \n-                if is_auto == ast::IsAuto::Yes {\n+                if is_auto == hir::IsAuto::Yes {\n                     text.push_str(\"auto \");\n                 }\n \n-                if let ast::Unsafe::Yes(_) = unsafety {\n+                if let hir::Unsafety::Unsafe = unsafety {\n                     text.push_str(\"unsafe \");\n                 }\n                 text.push_str(\"trait \");\n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+                let mut sig =\n+                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\": \");\n-                    sig.text.push_str(&pprust::bounds_to_string(bounds));\n+                    sig.text.push_str(&bounds_to_string(bounds));\n                 }\n                 // FIXME where clause\n                 sig.text.push_str(\" {}\");\n \n                 Ok(sig)\n             }\n-            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            hir::ItemKind::TraitAlias(ref generics, bounds) => {\n                 let mut text = String::new();\n                 text.push_str(\"trait \");\n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+                let mut sig =\n+                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\" = \");\n-                    sig.text.push_str(&pprust::bounds_to_string(bounds));\n+                    sig.text.push_str(&bounds_to_string(bounds));\n                 }\n                 // FIXME where clause\n                 sig.text.push_str(\";\");\n \n                 Ok(sig)\n             }\n-            ast::ItemKind::Impl {\n+            hir::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n+                defaultness_span: _,\n                 constness,\n                 ref generics,\n                 ref of_trait,\n                 ref self_ty,\n                 items: _,\n             } => {\n                 let mut text = String::new();\n-                if let ast::Defaultness::Default(_) = defaultness {\n+                if let hir::Defaultness::Default { .. } = defaultness {\n                     text.push_str(\"default \");\n                 }\n-                if let ast::Unsafe::Yes(_) = unsafety {\n+                if let hir::Unsafety::Unsafe = unsafety {\n                     text.push_str(\"unsafe \");\n                 }\n                 text.push_str(\"impl\");\n-                if let ast::Const::Yes(_) = constness {\n+                if let hir::Constness::Const = constness {\n                     text.push_str(\" const\");\n                 }\n \n@@ -520,7 +527,7 @@ impl Sig for ast::Item {\n                 text.push(' ');\n \n                 let trait_sig = if let Some(ref t) = *of_trait {\n-                    if let ast::ImplPolarity::Negative(_) = polarity {\n+                    if let hir::ImplPolarity::Negative(_) = polarity {\n                         text.push('!');\n                     }\n                     let trait_sig = t.path.make(offset + text.len(), id, scx)?;\n@@ -540,27 +547,23 @@ impl Sig for ast::Item {\n \n                 // FIXME where clause\n             }\n-            ast::ItemKind::ForeignMod(_) => Err(\"extern mod\"),\n-            ast::ItemKind::GlobalAsm(_) => Err(\"glboal asm\"),\n-            ast::ItemKind::ExternCrate(_) => Err(\"extern crate\"),\n+            hir::ItemKind::ForeignMod(_) => Err(\"extern mod\"),\n+            hir::ItemKind::GlobalAsm(_) => Err(\"glboal asm\"),\n+            hir::ItemKind::ExternCrate(_) => Err(\"extern crate\"),\n+            hir::ItemKind::OpaqueTy(..) => Err(\"opaque type\"),\n             // FIXME should implement this (e.g., pub use).\n-            ast::ItemKind::Use(_) => Err(\"import\"),\n-            ast::ItemKind::MacCall(..) | ast::ItemKind::MacroDef(_) => Err(\"Macro\"),\n+            hir::ItemKind::Use(..) => Err(\"import\"),\n         }\n     }\n }\n \n-impl Sig for ast::Path {\n-    fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n+impl<'hir> Sig for hir::Path<'hir> {\n+    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_, '_>) -> Result {\n         let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n \n         let (name, start, end) = match res {\n             Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => {\n-                return Ok(Signature {\n-                    text: pprust::path_to_string(self),\n-                    defs: vec![],\n-                    refs: vec![],\n-                });\n+                return Ok(Signature { text: path_to_string(self), defs: vec![], refs: vec![] });\n             }\n             Res::Def(DefKind::AssocConst | DefKind::Variant | DefKind::Ctor(..), _) => {\n                 let len = self.segments.len();\n@@ -570,13 +573,13 @@ impl Sig for ast::Path {\n                 // FIXME: really we should descend into the generics here and add SigElements for\n                 // them.\n                 // FIXME: would be nice to have a def for the first path segment.\n-                let seg1 = pprust::path_segment_to_string(&self.segments[len - 2]);\n-                let seg2 = pprust::path_segment_to_string(&self.segments[len - 1]);\n+                let seg1 = path_segment_to_string(&self.segments[len - 2]);\n+                let seg2 = path_segment_to_string(&self.segments[len - 1]);\n                 let start = offset + seg1.len() + 2;\n                 (format!(\"{}::{}\", seg1, seg2), start, start + seg2.len())\n             }\n             _ => {\n-                let name = pprust::path_segment_to_string(self.segments.last().ok_or(\"Bad path\")?);\n+                let name = path_segment_to_string(self.segments.last().ok_or(\"Bad path\")?);\n                 let end = offset + name.len();\n                 (name, offset, end)\n             }\n@@ -588,51 +591,56 @@ impl Sig for ast::Path {\n }\n \n // This does not cover the where clause, which must be processed separately.\n-impl Sig for ast::Generics {\n-    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n+impl<'hir> Sig for hir::Generics<'hir> {\n+    fn make(\n+        &self,\n+        offset: usize,\n+        _parent_id: Option<hir::HirId>,\n+        scx: &SaveContext<'_, '_>,\n+    ) -> Result {\n         if self.params.is_empty() {\n             return Ok(text_sig(String::new()));\n         }\n \n         let mut text = \"<\".to_owned();\n \n         let mut defs = Vec::with_capacity(self.params.len());\n-        for param in &self.params {\n+        for param in self.params {\n             let mut param_text = String::new();\n-            if let ast::GenericParamKind::Const { .. } = param.kind {\n+            if let hir::GenericParamKind::Const { .. } = param.kind {\n                 param_text.push_str(\"const \");\n             }\n-            param_text.push_str(&param.ident.as_str());\n+            param_text.push_str(&param.name.ident().as_str());\n             defs.push(SigElement {\n-                id: id_from_node_id(param.id, scx),\n+                id: id_from_hir_id(param.hir_id, scx),\n                 start: offset + text.len(),\n                 end: offset + text.len() + param_text.as_str().len(),\n             });\n-            if let ast::GenericParamKind::Const { ref ty } = param.kind {\n+            if let hir::GenericParamKind::Const { ref ty } = param.kind {\n                 param_text.push_str(\": \");\n-                param_text.push_str(&pprust::ty_to_string(&ty));\n+                param_text.push_str(&ty_to_string(&ty));\n             }\n             if !param.bounds.is_empty() {\n                 param_text.push_str(\": \");\n                 match param.kind {\n-                    ast::GenericParamKind::Lifetime { .. } => {\n+                    hir::GenericParamKind::Lifetime { .. } => {\n                         let bounds = param\n                             .bounds\n                             .iter()\n                             .map(|bound| match bound {\n-                                ast::GenericBound::Outlives(lt) => lt.ident.to_string(),\n+                                hir::GenericBound::Outlives(lt) => lt.name.ident().to_string(),\n                                 _ => panic!(),\n                             })\n                             .collect::<Vec<_>>()\n                             .join(\" + \");\n                         param_text.push_str(&bounds);\n                         // FIXME add lifetime bounds refs.\n                     }\n-                    ast::GenericParamKind::Type { .. } => {\n-                        param_text.push_str(&pprust::bounds_to_string(&param.bounds));\n+                    hir::GenericParamKind::Type { .. } => {\n+                        param_text.push_str(&bounds_to_string(param.bounds));\n                         // FIXME descend properly into bounds.\n                     }\n-                    ast::GenericParamKind::Const { .. } => {\n+                    hir::GenericParamKind::Const { .. } => {\n                         // Const generics cannot contain bounds.\n                     }\n                 }\n@@ -646,36 +654,44 @@ impl Sig for ast::Generics {\n     }\n }\n \n-impl Sig for ast::StructField {\n-    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n+impl<'hir> Sig for hir::StructField<'hir> {\n+    fn make(\n+        &self,\n+        offset: usize,\n+        _parent_id: Option<hir::HirId>,\n+        scx: &SaveContext<'_, '_>,\n+    ) -> Result {\n         let mut text = String::new();\n-        let mut defs = None;\n-        if let Some(ident) = self.ident {\n-            text.push_str(&ident.to_string());\n-            defs = Some(SigElement {\n-                id: id_from_node_id(self.id, scx),\n-                start: offset,\n-                end: offset + text.len(),\n-            });\n-            text.push_str(\": \");\n-        }\n \n-        let mut ty_sig = self.ty.make(offset + text.len(), Some(self.id), scx)?;\n+        text.push_str(&self.ident.to_string());\n+        let defs = Some(SigElement {\n+            id: id_from_hir_id(self.hir_id, scx),\n+            start: offset,\n+            end: offset + text.len(),\n+        });\n+        text.push_str(\": \");\n+\n+        let mut ty_sig = self.ty.make(offset + text.len(), Some(self.hir_id), scx)?;\n         text.push_str(&ty_sig.text);\n         ty_sig.text = text;\n         ty_sig.defs.extend(defs.into_iter());\n         Ok(ty_sig)\n     }\n }\n \n-impl Sig for ast::Variant {\n-    fn make(&self, offset: usize, parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n+impl<'hir> Sig for hir::Variant<'hir> {\n+    fn make(\n+        &self,\n+        offset: usize,\n+        parent_id: Option<hir::HirId>,\n+        scx: &SaveContext<'_, '_>,\n+    ) -> Result {\n         let mut text = self.ident.to_string();\n         match self.data {\n-            ast::VariantData::Struct(ref fields, r) => {\n+            hir::VariantData::Struct(fields, r) => {\n                 let id = parent_id.unwrap();\n                 let name_def = SigElement {\n-                    id: id_from_node_id(id, scx),\n+                    id: id_from_hir_id(id, scx),\n                     start: offset,\n                     end: offset + text.len(),\n                 };\n@@ -696,9 +712,9 @@ impl Sig for ast::Variant {\n                 text.push('}');\n                 Ok(Signature { text, defs, refs })\n             }\n-            ast::VariantData::Tuple(ref fields, id) => {\n+            hir::VariantData::Tuple(fields, id) => {\n                 let name_def = SigElement {\n-                    id: id_from_node_id(id, scx),\n+                    id: id_from_hir_id(id, scx),\n                     start: offset,\n                     end: offset + text.len(),\n                 };\n@@ -715,9 +731,9 @@ impl Sig for ast::Variant {\n                 text.push(')');\n                 Ok(Signature { text, defs, refs })\n             }\n-            ast::VariantData::Unit(id) => {\n+            hir::VariantData::Unit(id) => {\n                 let name_def = SigElement {\n-                    id: id_from_node_id(id, scx),\n+                    id: id_from_hir_id(id, scx),\n                     start: offset,\n                     end: offset + text.len(),\n                 };\n@@ -727,31 +743,34 @@ impl Sig for ast::Variant {\n     }\n }\n \n-impl Sig for ast::ForeignItem {\n-    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n-        let id = Some(self.id);\n+impl<'hir> Sig for hir::ForeignItem<'hir> {\n+    fn make(\n+        &self,\n+        offset: usize,\n+        _parent_id: Option<hir::HirId>,\n+        scx: &SaveContext<'_, '_>,\n+    ) -> Result {\n+        let id = Some(self.hir_id);\n         match self.kind {\n-            ast::ForeignItemKind::Fn(_, ref sig, ref generics, _) => {\n-                let decl = &sig.decl;\n+            hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n                 let mut text = String::new();\n                 text.push_str(\"fn \");\n \n-                let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n+                let mut sig =\n+                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n \n                 sig.text.push('(');\n-                for i in &decl.inputs {\n-                    // FIXME should descend into patterns to add defs.\n-                    sig.text.push_str(&pprust::pat_to_string(&i.pat));\n+                for i in decl.inputs {\n                     sig.text.push_str(\": \");\n-                    let nested = i.ty.make(offset + sig.text.len(), Some(i.id), scx)?;\n+                    let nested = i.make(offset + sig.text.len(), Some(i.hir_id), scx)?;\n                     sig.text.push_str(&nested.text);\n                     sig.text.push(',');\n                     sig.defs.extend(nested.defs.into_iter());\n                     sig.refs.extend(nested.refs.into_iter());\n                 }\n                 sig.text.push(')');\n \n-                if let ast::FnRetTy::Ty(ref t) = decl.output {\n+                if let hir::FnRetTy::Return(ref t) = decl.output {\n                     sig.text.push_str(\" -> \");\n                     let nested = t.make(offset + sig.text.len(), None, scx)?;\n                     sig.text.push_str(&nested.text);\n@@ -762,14 +781,14 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(sig)\n             }\n-            ast::ForeignItemKind::Static(ref ty, m, _) => {\n+            hir::ForeignItemKind::Static(ref ty, m) => {\n                 let mut text = \"static \".to_owned();\n-                if m == ast::Mutability::Mut {\n+                if m == Mutability::Mut {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n+                    id: id_from_hir_id(self.hir_id, scx),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -781,11 +800,11 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(extend_sig(ty_sig, text, defs, vec![]))\n             }\n-            ast::ForeignItemKind::TyAlias(..) => {\n+            hir::ForeignItemKind::Type => {\n                 let mut text = \"type \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_node_id(self.id, scx),\n+                    id: id_from_hir_id(self.hir_id, scx),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -794,22 +813,21 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(Signature { text, defs, refs: vec![] })\n             }\n-            ast::ForeignItemKind::MacCall(..) => Err(\"macro\"),\n         }\n     }\n }\n \n fn name_and_generics(\n     mut text: String,\n     offset: usize,\n-    generics: &ast::Generics,\n-    id: NodeId,\n+    generics: &hir::Generics<'_>,\n+    id: hir::HirId,\n     name: Ident,\n     scx: &SaveContext<'_, '_>,\n ) -> Result {\n     let name = name.to_string();\n     let def = SigElement {\n-        id: id_from_node_id(id, scx),\n+        id: id_from_hir_id(id, scx),\n         start: offset + text.len(),\n         end: offset + text.len() + name.len(),\n     };\n@@ -821,16 +839,16 @@ fn name_and_generics(\n }\n \n fn make_assoc_type_signature(\n-    id: NodeId,\n+    id: hir::HirId,\n     ident: Ident,\n-    bounds: Option<&ast::GenericBounds>,\n-    default: Option<&ast::Ty>,\n+    bounds: Option<hir::GenericBounds<'_>>,\n+    default: Option<&hir::Ty<'_>>,\n     scx: &SaveContext<'_, '_>,\n ) -> Result {\n     let mut text = \"type \".to_owned();\n     let name = ident.to_string();\n     let mut defs = vec![SigElement {\n-        id: id_from_node_id(id, scx),\n+        id: id_from_hir_id(id, scx),\n         start: text.len(),\n         end: text.len() + name.len(),\n     }];\n@@ -839,7 +857,7 @@ fn make_assoc_type_signature(\n     if let Some(bounds) = bounds {\n         text.push_str(\": \");\n         // FIXME should descend into bounds\n-        text.push_str(&pprust::bounds_to_string(bounds));\n+        text.push_str(&bounds_to_string(bounds));\n     }\n     if let Some(default) = default {\n         text.push_str(\" = \");\n@@ -853,16 +871,16 @@ fn make_assoc_type_signature(\n }\n \n fn make_assoc_const_signature(\n-    id: NodeId,\n+    id: hir::HirId,\n     ident: Symbol,\n-    ty: &ast::Ty,\n-    default: Option<&ast::Expr>,\n+    ty: &hir::Ty<'_>,\n+    default: Option<&hir::Expr<'_>>,\n     scx: &SaveContext<'_, '_>,\n ) -> Result {\n     let mut text = \"const \".to_owned();\n     let name = ident.to_string();\n     let mut defs = vec![SigElement {\n-        id: id_from_node_id(id, scx),\n+        id: id_from_hir_id(id, scx),\n         start: text.len(),\n         end: text.len() + name.len(),\n     }];\n@@ -877,49 +895,46 @@ fn make_assoc_const_signature(\n \n     if let Some(default) = default {\n         text.push_str(\" = \");\n-        text.push_str(&pprust::expr_to_string(default));\n+        text.push_str(&id_to_string(&scx.tcx.hir(), default.hir_id));\n     }\n     text.push(';');\n     Ok(Signature { text, defs, refs })\n }\n \n fn make_method_signature(\n-    id: NodeId,\n+    id: hir::HirId,\n     ident: Ident,\n-    generics: &ast::Generics,\n-    m: &ast::FnSig,\n+    generics: &hir::Generics<'_>,\n+    m: &hir::FnSig<'_>,\n     scx: &SaveContext<'_, '_>,\n ) -> Result {\n     // FIXME code dup with function signature\n     let mut text = String::new();\n-    if let ast::Const::Yes(_) = m.header.constness {\n+    if let hir::Constness::Const = m.header.constness {\n         text.push_str(\"const \");\n     }\n-    if m.header.asyncness.is_async() {\n+    if hir::IsAsync::Async == m.header.asyncness {\n         text.push_str(\"async \");\n     }\n-    if let ast::Unsafe::Yes(_) = m.header.unsafety {\n+    if let hir::Unsafety::Unsafe = m.header.unsafety {\n         text.push_str(\"unsafe \");\n     }\n-    push_extern(&mut text, m.header.ext);\n     text.push_str(\"fn \");\n \n     let mut sig = name_and_generics(text, 0, generics, id, ident, scx)?;\n \n     sig.text.push('(');\n-    for i in &m.decl.inputs {\n-        // FIXME should descend into patterns to add defs.\n-        sig.text.push_str(&pprust::pat_to_string(&i.pat));\n+    for i in m.decl.inputs {\n         sig.text.push_str(\": \");\n-        let nested = i.ty.make(sig.text.len(), Some(i.id), scx)?;\n+        let nested = i.make(sig.text.len(), Some(i.hir_id), scx)?;\n         sig.text.push_str(&nested.text);\n         sig.text.push(',');\n         sig.defs.extend(nested.defs.into_iter());\n         sig.refs.extend(nested.refs.into_iter());\n     }\n     sig.text.push(')');\n \n-    if let ast::FnRetTy::Ty(ref t) = m.decl.output {\n+    if let hir::FnRetTy::Return(ref t) = m.decl.output {\n         sig.text.push_str(\" -> \");\n         let nested = t.make(sig.text.len(), None, scx)?;\n         sig.text.push_str(&nested.text);"}, {"sha": "8d7a7167c15b9154755588c39b22b2336c89ca68", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=3d5d0f898c2f3998e50c2180c6202f193c3acdbc", "patch": "@@ -1 +1 @@\n-Subproject commit 085f24b9ecbc0e90d204cab1c111c4abe4608ce0\n+Subproject commit 8d7a7167c15b9154755588c39b22b2336c89ca68"}]}