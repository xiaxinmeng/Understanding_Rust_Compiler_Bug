{"sha": "751616f062b07f5dee2921f69886bd1a5b1234aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MTYxNmYwNjJiMDdmNWRlZTI5MjFmNjk4ODZiZDFhNWIxMjM0YWE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-28T18:35:52Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-28T18:35:52Z"}, "message": "Merge #352\n\n352: Macro extend selection r=matklad a=matklad\n\nand a bunch of unrelated stuff\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "616bcd980ac69eb5070c1e7a6d90ebee71cb7348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/616bcd980ac69eb5070c1e7a6d90ebee71cb7348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/751616f062b07f5dee2921f69886bd1a5b1234aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/751616f062b07f5dee2921f69886bd1a5b1234aa", "html_url": "https://github.com/rust-lang/rust/commit/751616f062b07f5dee2921f69886bd1a5b1234aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/751616f062b07f5dee2921f69886bd1a5b1234aa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "10e687f281e4850ae258d5dae84dee871e24e8ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/10e687f281e4850ae258d5dae84dee871e24e8ed", "html_url": "https://github.com/rust-lang/rust/commit/10e687f281e4850ae258d5dae84dee871e24e8ed"}, {"sha": "792899587647f5aa0293c2588173677682187c0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/792899587647f5aa0293c2588173677682187c0a", "html_url": "https://github.com/rust-lang/rust/commit/792899587647f5aa0293c2588173677682187c0a"}], "stats": {"total": 228, "additions": 150, "deletions": 78}, "files": [{"sha": "c73a083a43cef20e573298297a58ddaa07e66b02", "filename": "crates/ra_analysis/src/completion/complete_path.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -1,6 +1,6 @@\n use crate::{\n     Cancelable,\n-    completion::{CompletionItem, Completions, CompletionKind, CompletionContext},\n+    completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext},\n };\n \n pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n@@ -12,16 +12,25 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> C\n         Some(it) => it,\n         None => return Ok(()),\n     };\n-    let target_module = match def_id.resolve(ctx.db)? {\n-        hir::Def::Module(it) => it,\n+    match def_id.resolve(ctx.db)? {\n+        hir::Def::Module(module) => {\n+            let module_scope = module.scope(ctx.db)?;\n+            module_scope.entries().for_each(|(name, res)| {\n+                CompletionItem::new(CompletionKind::Reference, name.to_string())\n+                    .from_resolution(ctx.db, res)\n+                    .add_to(acc)\n+            });\n+        }\n+        hir::Def::Enum(e) => e\n+            .variants(ctx.db)?\n+            .into_iter()\n+            .for_each(|(name, _variant)| {\n+                CompletionItem::new(CompletionKind::Reference, name.to_string())\n+                    .kind(CompletionItemKind::EnumVariant)\n+                    .add_to(acc)\n+            }),\n         _ => return Ok(()),\n     };\n-    let module_scope = target_module.scope(ctx.db)?;\n-    module_scope.entries().for_each(|(name, res)| {\n-        CompletionItem::new(CompletionKind::Reference, name.to_string())\n-            .from_resolution(ctx.db, res)\n-            .add_to(acc)\n-    });\n     Ok(())\n }\n \n@@ -92,4 +101,16 @@ mod tests {\n             \"Spam\",\n         );\n     }\n+\n+    #[test]\n+    fn completes_enum_variant() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            enum E { Foo, Bar(i32) }\n+            fn foo() { let _ = E::<|> }\n+            \",\n+            \"Foo;Bar\",\n+        );\n+    }\n }"}, {"sha": "1d294c553aa5f2ea36bf0b51c12050590f1b13b3", "filename": "crates/ra_analysis/src/completion/completion_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -29,6 +29,7 @@ pub enum CompletionItemKind {\n     Function,\n     Struct,\n     Enum,\n+    EnumVariant,\n     Binding,\n     Field,\n }"}, {"sha": "cde6ee1018d73a8ff335a6dcdcc110f18db81698", "filename": "crates/ra_analysis/src/extend_selection.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -1,11 +1,51 @@\n use ra_db::SyntaxDatabase;\n+use ra_syntax::{\n+    SyntaxNodeRef, AstNode,\n+    ast, algo::find_covering_node,\n+};\n \n use crate::{\n     TextRange, FileRange,\n     db::RootDatabase,\n };\n \n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n-    let file = db.source_file(frange.file_id);\n-    ra_editor::extend_selection(&file, frange.range).unwrap_or(frange.range)\n+    let source_file = db.source_file(frange.file_id);\n+    if let Some(macro_call) = find_macro_call(source_file.syntax(), frange.range) {\n+        if let Some(exp) = crate::macros::expand(db, frange.file_id, macro_call) {\n+            if let Some(dst_range) = exp.map_range_forward(frange.range) {\n+                if let Some(dst_range) = ra_editor::extend_selection(exp.source_file(), dst_range) {\n+                    if let Some(src_range) = exp.map_range_back(dst_range) {\n+                        return src_range;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    ra_editor::extend_selection(&source_file, frange.range).unwrap_or(frange.range)\n+}\n+\n+fn find_macro_call(node: SyntaxNodeRef, range: TextRange) -> Option<ast::MacroCall> {\n+    find_covering_node(node, range)\n+        .ancestors()\n+        .find_map(ast::MacroCall::cast)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::mock_analysis::single_file_with_range;\n+    use test_utils::assert_eq_dbg;\n+\n+    #[test]\n+    fn extend_selection_inside_macros() {\n+        let (analysis, frange) = single_file_with_range(\n+            \"\n+            fn main() {\n+                ctry!(foo(|x| <|>x<|>));\n+            }\n+        \",\n+        );\n+        let r = analysis.extend_selection(frange);\n+        assert_eq_dbg(\"[51; 56)\", &r);\n+    }\n }"}, {"sha": "b9feb7fad4d02f0c931aa78344be892b04a93e07", "filename": "crates/ra_analysis/src/macros.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmacros.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -61,4 +61,15 @@ impl MacroExpansion {\n         }\n         None\n     }\n+    pub(crate) fn map_range_forward(&self, src_range: TextRange) -> Option<TextRange> {\n+        for (s_range, t_range) in self.ranges_map.iter() {\n+            if src_range.is_subrange(&s_range) {\n+                let src_at_zero_range = src_range - src_range.start();\n+                let src_range_offset = src_range.start() - s_range.start();\n+                let src_range = src_at_zero_range + src_range_offset + t_range.start();\n+                return Some(src_range);\n+            }\n+        }\n+        None\n+    }\n }"}, {"sha": "9605294046de9e98b0706f0f152461718b336f74", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -1,10 +1,10 @@\n use std::sync::Arc;\n \n use relative_path::RelativePathBuf;\n-use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n+use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n use ra_db::mock::FileMap;\n \n-use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FilePosition, SourceRootId};\n+use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FilePosition, FileRange, SourceRootId};\n \n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n@@ -66,6 +66,12 @@ impl MockAnalysis {\n         self.files.push((path.to_string(), text.to_string()));\n         FilePosition { file_id, offset }\n     }\n+    pub fn add_file_with_range(&mut self, path: &str, text: &str) -> FileRange {\n+        let (range, text) = extract_range(text);\n+        let file_id = FileId((self.files.len() + 1) as u32);\n+        self.files.push((path.to_string(), text.to_string()));\n+        FileRange { file_id, range }\n+    }\n     pub fn id_of(&self, path: &str) -> FileId {\n         let (idx, _) = self\n             .files\n@@ -115,3 +121,10 @@ pub fn single_file_with_position(code: &str) -> (Analysis, FilePosition) {\n     let pos = mock.add_file_with_position(\"/main.rs\", code);\n     (mock.analysis(), pos)\n }\n+\n+/// Creates analysis for a single file, returns range marked with a pair of <|>.\n+pub fn single_file_with_range(code: &str) -> (Analysis, FileRange) {\n+    let mut mock = MockAnalysis::new();\n+    let pos = mock.add_file_with_range(\"/main.rs\", code);\n+    (mock.analysis(), pos)\n+}"}, {"sha": "e839a5a90d2e2bf1a4b96475fa410ed1fffad3a4", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -1,10 +1,10 @@\n use std::sync::Arc;\n \n-use ra_syntax::{SmolStr, ast::{self, NameOwner, StructFlavor}};\n+use ra_syntax::ast::{self, NameOwner, StructFlavor};\n \n use crate::{\n-    DefId, Cancelable,\n-    db::{HirDatabase},\n+    DefId, Cancelable, Name, AsName,\n+    db::HirDatabase,\n     type_ref::TypeRef,\n };\n \n@@ -29,26 +29,26 @@ impl Struct {\n         Ok(db.struct_data(self.def_id)?)\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<SmolStr>> {\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n         Ok(db.struct_data(self.def_id)?.name.clone())\n     }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructData {\n-    name: Option<SmolStr>,\n+    name: Option<Name>,\n     variant_data: Arc<VariantData>,\n }\n \n impl StructData {\n     pub(crate) fn new(struct_def: ast::StructDef) -> StructData {\n-        let name = struct_def.name().map(|n| n.text());\n+        let name = struct_def.name().map(|n| n.as_name());\n         let variant_data = VariantData::new(struct_def.flavor());\n         let variant_data = Arc::new(variant_data);\n         StructData { name, variant_data }\n     }\n \n-    pub fn name(&self) -> Option<&SmolStr> {\n+    pub fn name(&self) -> Option<&Name> {\n         self.name.as_ref()\n     }\n \n@@ -70,27 +70,29 @@ impl Enum {\n         self.def_id\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<SmolStr>> {\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n         Ok(db.enum_data(self.def_id)?.name.clone())\n     }\n+\n+    pub fn variants(&self, db: &impl HirDatabase) -> Cancelable<Vec<(Name, Arc<VariantData>)>> {\n+        Ok(db.enum_data(self.def_id)?.variants.clone())\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n-    name: Option<SmolStr>,\n-    variants: Vec<(SmolStr, Arc<VariantData>)>,\n+    name: Option<Name>,\n+    variants: Vec<(Name, Arc<VariantData>)>,\n }\n \n impl EnumData {\n     pub(crate) fn new(enum_def: ast::EnumDef) -> Self {\n-        let name = enum_def.name().map(|n| n.text());\n+        let name = enum_def.name().map(|n| n.as_name());\n         let variants = if let Some(evl) = enum_def.variant_list() {\n             evl.variants()\n                 .map(|v| {\n                     (\n-                        v.name()\n-                            .map(|n| n.text())\n-                            .unwrap_or_else(|| SmolStr::new(\"[error]\")),\n+                        v.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         Arc::new(VariantData::new(v.flavor())),\n                     )\n                 })\n@@ -105,12 +107,12 @@ impl EnumData {\n /// A single field of an enum variant or struct\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructField {\n-    name: SmolStr,\n+    name: Name,\n     type_ref: TypeRef,\n }\n \n impl StructField {\n-    pub fn name(&self) -> SmolStr {\n+    pub fn name(&self) -> Name {\n         self.name.clone()\n     }\n     pub fn type_ref(&self) -> &TypeRef {\n@@ -134,7 +136,7 @@ impl VariantData {\n                     .fields()\n                     .enumerate()\n                     .map(|(i, fd)| StructField {\n-                        name: SmolStr::new(i.to_string()),\n+                        name: Name::tuple_field_name(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                     })\n                     .collect();\n@@ -144,10 +146,7 @@ impl VariantData {\n                 let fields = fl\n                     .fields()\n                     .map(|fd| StructField {\n-                        name: fd\n-                            .name()\n-                            .map(|n| n.text())\n-                            .unwrap_or_else(|| SmolStr::new(\"[error]\")),\n+                        name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                     })\n                     .collect();\n@@ -157,10 +156,10 @@ impl VariantData {\n         }\n     }\n \n-    pub(crate) fn get_field_type_ref(&self, field_name: &str) -> Option<&TypeRef> {\n+    pub(crate) fn get_field_type_ref(&self, field_name: &Name) -> Option<&TypeRef> {\n         self.fields()\n             .iter()\n-            .find(|f| f.name == field_name)\n+            .find(|f| f.name == *field_name)\n             .map(|f| &f.type_ref)\n     }\n "}, {"sha": "b41a7429a7d1ccce3baf8d9864a200af0e0781bb", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -1,13 +1,10 @@\n use std::sync::Arc;\n \n-use ra_syntax::{\n-    SmolStr,\n-    SyntaxNode,\n-};\n+use ra_syntax::SyntaxNode;\n use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, FileId, Cancelable};\n \n use crate::{\n-    DefLoc, DefId,\n+    DefLoc, DefId, Name,\n     SourceFileItems, SourceItemId,\n     query_definitions,\n     FnScopes,\n@@ -47,7 +44,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::type_for_def;\n     }\n \n-    fn type_for_field(def_id: DefId, field: SmolStr) -> Cancelable<Ty> {\n+    fn type_for_field(def_id: DefId, field: Name) -> Cancelable<Ty> {\n         type TypeForFieldQuery;\n         use fn query_definitions::type_for_field;\n     }"}, {"sha": "24c3469847117e0603ce1f3830f00d2cabffc05f", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -13,8 +13,8 @@ use ra_db::{SourceRootId, FileId, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n-    DefKind, DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n-    Name,\n+    Def, DefKind, DefLoc, DefId,\n+    Name, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n     arena::{Arena, Id},\n };\n \n@@ -139,13 +139,8 @@ impl Module {\n             } else {\n                 return Ok(PerNs::none());\n             };\n-            let module = match curr.loc(db) {\n-                DefLoc {\n-                    kind: DefKind::Module,\n-                    source_root_id,\n-                    module_id,\n-                    ..\n-                } => Module::new(db, source_root_id, module_id)?,\n+            let module = match curr.resolve(db)? {\n+                Def::Module(it) => it,\n                 // TODO here would be the place to handle enum variants...\n                 _ => return Ok(PerNs::none()),\n             };"}, {"sha": "51e8b3da86f4a58e31af945c46b964b95f360d45", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -23,6 +23,18 @@ impl fmt::Debug for Name {\n }\n \n impl Name {\n+    fn new(text: SmolStr) -> Name {\n+        Name { text }\n+    }\n+\n+    pub(crate) fn missing() -> Name {\n+        Name::new(\"[missing name]\".into())\n+    }\n+\n+    pub(crate) fn tuple_field_name(idx: usize) -> Name {\n+        Name::new(idx.to_string().into())\n+    }\n+\n     pub(crate) fn as_known_name(&self) -> Option<KnownName> {\n         let name = match self.text.as_str() {\n             \"isize\" => KnownName::Isize,\n@@ -43,10 +55,6 @@ impl Name {\n         };\n         Some(name)\n     }\n-\n-    fn new(text: SmolStr) -> Name {\n-        Name { text }\n-    }\n }\n \n pub(crate) trait AsName {"}, {"sha": "016d86ee6d47474874f69275c6cfd2a1e570d687", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -5,7 +5,7 @@ use std::{\n \n use rustc_hash::FxHashMap;\n use ra_syntax::{\n-    AstNode, SyntaxNode, SmolStr,\n+    AstNode, SyntaxNode,\n     ast::{self, NameOwner, ModuleItemOwner}\n };\n use ra_db::{SourceRootId, FileId, Cancelable,};\n@@ -39,11 +39,7 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<T\n     ty::type_for_def(db, def_id)\n }\n \n-pub(super) fn type_for_field(\n-    db: &impl HirDatabase,\n-    def_id: DefId,\n-    field: SmolStr,\n-) -> Cancelable<Ty> {\n+pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Cancelable<Ty> {\n     ty::type_for_field(db, def_id, field)\n }\n "}, {"sha": "38720b7b56bfeed20fd22a9ed069295628c72201", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -10,13 +10,12 @@ use rustc_hash::{FxHashMap};\n \n use ra_db::{LocalSyntaxPtr, Cancelable};\n use ra_syntax::{\n-    SmolStr,\n     ast::{self, AstNode, LoopBodyOwner, ArgListOwner, PrefixOp},\n     SyntaxNodeRef\n };\n \n use crate::{\n-    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path,\n+    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path, Name, AsName,\n     db::HirDatabase,\n     adt::VariantData,\n     type_ref::{TypeRef, Mutability},\n@@ -45,7 +44,7 @@ pub enum Ty {\n         /// The DefId of the struct/enum.\n         def_id: DefId,\n         /// The name, for displaying.\n-        name: SmolStr,\n+        name: Name,\n         // later we'll need generic substitutions here\n     },\n \n@@ -276,18 +275,14 @@ pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n pub fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n     Ok(Ty::Adt {\n         def_id: s.def_id(),\n-        name: s\n-            .name(db)?\n-            .unwrap_or_else(|| SmolStr::new(\"[unnamed struct]\")),\n+        name: s.name(db)?.unwrap_or_else(Name::missing),\n     })\n }\n \n pub fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n     Ok(Ty::Adt {\n         def_id: s.def_id(),\n-        name: s\n-            .name(db)?\n-            .unwrap_or_else(|| SmolStr::new(\"[unnamed enum]\")),\n+        name: s.name(db)?.unwrap_or_else(Name::missing),\n     })\n }\n \n@@ -308,11 +303,7 @@ pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n     }\n }\n \n-pub(super) fn type_for_field(\n-    db: &impl HirDatabase,\n-    def_id: DefId,\n-    field: SmolStr,\n-) -> Cancelable<Ty> {\n+pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Cancelable<Ty> {\n     let def = def_id.resolve(db)?;\n     let variant_data = match def {\n         Def::Struct(s) => {\n@@ -559,14 +550,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ast::Expr::FieldExpr(e) => {\n                 let receiver_ty = self.infer_expr_opt(e.expr())?;\n                 if let Some(nr) = e.name_ref() {\n-                    let text = nr.text();\n                     match receiver_ty {\n                         Ty::Tuple(fields) => {\n-                            let i = text.parse::<usize>().ok();\n+                            let i = nr.text().parse::<usize>().ok();\n                             i.and_then(|i| fields.get(i).cloned())\n                                 .unwrap_or(Ty::Unknown)\n                         }\n-                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, text)?,\n+                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, nr.as_name())?,\n                         _ => Ty::Unknown,\n                     }\n                 } else {"}, {"sha": "0d6e6272732fedecf104d1e377db2974eedf085d", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751616f062b07f5dee2921f69886bd1a5b1234aa/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=751616f062b07f5dee2921f69886bd1a5b1234aa", "patch": "@@ -57,6 +57,7 @@ impl Conv for CompletionItemKind {\n             CompletionItemKind::Function => Function,\n             CompletionItemKind::Struct => Struct,\n             CompletionItemKind::Enum => Enum,\n+            CompletionItemKind::EnumVariant => EnumMember,\n             CompletionItemKind::Binding => Variable,\n             CompletionItemKind::Field => Field,\n         }"}]}