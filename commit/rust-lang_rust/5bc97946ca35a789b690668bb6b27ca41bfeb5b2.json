{"sha": "5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYzk3OTQ2Y2EzNWE3ODliNjkwNjY4YmI2YjI3Y2E0MWJmZWI1YjI=", "commit": {"author": {"name": "Joseph Ryan", "email": "josephryan3.14@gmail.com", "date": "2020-06-17T17:41:45Z"}, "committer": {"name": "Joseph Ryan", "email": "josephryan3.14@gmail.com", "date": "2020-07-27T21:00:38Z"}, "message": "Refactor html backend to use generic interface", "tree": {"sha": "cfa69a162517f491fb684790a01af7d156b2ee51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfa69a162517f491fb684790a01af7d156b2ee51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEtei29J14PIgXYsIlGom1QEO7zL0FAl8fQHYACgkQGom1QEO7\nzL3Q8QgAo+XdOfwkyYm7i8BECUehRXcmn9DsGBBT5N58yHbc+qxn4KrYlqf22QML\nXlB91BjHTv6R+cVypj1tCP/wagy85DhdI7bjoqgStbQsRYwL8ibKVlVsdgD6uwyn\nQc3/5Ll+2sINVwqzrUoK+DASFsItONihMn1SvjWS4FxXN3S2v85Ny+SwjgwFybXr\nw9UGui0cOB7ox/GnoFxXUh83fWNKbHVWJyN9R620gMc2Qidr/h32klwN3Cqc7OvV\n30xfjNG+YqcYOKs+pxdLCuDrXyIiVIEdhxx2kV/RkLCx7WKALn5l4IHxXlIVzDvj\nFhy9rJxywGpiePliRhfbHCZ8TnPMZA==\n=mMSf\n-----END PGP SIGNATURE-----", "payload": "tree cfa69a162517f491fb684790a01af7d156b2ee51\nparent c692ed468c8dc4b9f549ef839b4b490e3b84d19c\nauthor Joseph Ryan <josephryan3.14@gmail.com> 1592415705 -0500\ncommitter Joseph Ryan <josephryan3.14@gmail.com> 1595883638 -0500\n\nRefactor html backend to use generic interface\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "html_url": "https://github.com/rust-lang/rust/commit/5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc97946ca35a789b690668bb6b27ca41bfeb5b2/comments", "author": {"login": "P1n3appl3", "id": 9326885, "node_id": "MDQ6VXNlcjkzMjY4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/9326885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P1n3appl3", "html_url": "https://github.com/P1n3appl3", "followers_url": "https://api.github.com/users/P1n3appl3/followers", "following_url": "https://api.github.com/users/P1n3appl3/following{/other_user}", "gists_url": "https://api.github.com/users/P1n3appl3/gists{/gist_id}", "starred_url": "https://api.github.com/users/P1n3appl3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P1n3appl3/subscriptions", "organizations_url": "https://api.github.com/users/P1n3appl3/orgs", "repos_url": "https://api.github.com/users/P1n3appl3/repos", "events_url": "https://api.github.com/users/P1n3appl3/events{/privacy}", "received_events_url": "https://api.github.com/users/P1n3appl3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "P1n3appl3", "id": 9326885, "node_id": "MDQ6VXNlcjkzMjY4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/9326885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P1n3appl3", "html_url": "https://github.com/P1n3appl3", "followers_url": "https://api.github.com/users/P1n3appl3/followers", "following_url": "https://api.github.com/users/P1n3appl3/following{/other_user}", "gists_url": "https://api.github.com/users/P1n3appl3/gists{/gist_id}", "starred_url": "https://api.github.com/users/P1n3appl3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P1n3appl3/subscriptions", "organizations_url": "https://api.github.com/users/P1n3appl3/orgs", "repos_url": "https://api.github.com/users/P1n3appl3/repos", "events_url": "https://api.github.com/users/P1n3appl3/events{/privacy}", "received_events_url": "https://api.github.com/users/P1n3appl3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c692ed468c8dc4b9f549ef839b4b490e3b84d19c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c692ed468c8dc4b9f549ef839b4b490e3b84d19c", "html_url": "https://github.com/rust-lang/rust/commit/c692ed468c8dc4b9f549ef839b4b490e3b84d19c"}], "stats": {"total": 722, "additions": 409, "deletions": 313}, "files": [{"sha": "55827f473858aab02097685c3e309f0b9276fb08", "filename": "src/librustdoc/formats/mod.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5bc97946ca35a789b690668bb6b27ca41bfeb5b2/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc97946ca35a789b690668bb6b27ca41bfeb5b2/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "patch": "@@ -0,0 +1,107 @@\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+use rustc_span::edition::Edition;\n+\n+use crate::clean;\n+use crate::config::{RenderInfo, RenderOptions};\n+use crate::error::Error;\n+\n+pub trait FormatRenderer: Clone {\n+    type Output: FormatRenderer;\n+\n+    fn init(\n+        krate: clean::Crate,\n+        options: RenderOptions,\n+        renderinfo: RenderInfo,\n+        diag: &rustc_errors::Handler,\n+        edition: Edition,\n+        parent: Rc<RefCell<Renderer>>,\n+    ) -> Result<(Self::Output, clean::Crate), Error>;\n+\n+    /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n+    fn item(&mut self, item: clean::Item) -> Result<(), Error>;\n+\n+    /// Renders a module. Doesn't need to handle recursing into children, the driver does that\n+    /// automatically.\n+    fn mod_item_in(\n+        &mut self,\n+        item: &clean::Item,\n+        item_name: &str,\n+        module: &clean::Module,\n+    ) -> Result<(), Error>;\n+\n+    /// Runs after recursively rendering all sub-items of a module.\n+    fn mod_item_out(&mut self) -> Result<(), Error>;\n+\n+    /// Post processing hook for cleanup and dumping output to files.\n+    fn after_krate(&mut self, krate: &clean::Crate) -> Result<(), Error>;\n+\n+    /// Called after everything else to write out errors.\n+    fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error>;\n+}\n+\n+#[derive(Clone)]\n+pub struct Renderer;\n+\n+impl Renderer {\n+    pub fn new() -> Renderer {\n+        Renderer\n+    }\n+\n+    /// Main method for rendering a crate.\n+    pub fn run<T: FormatRenderer + Clone>(\n+        self,\n+        krate: clean::Crate,\n+        options: RenderOptions,\n+        renderinfo: RenderInfo,\n+        diag: &rustc_errors::Handler,\n+        edition: Edition,\n+    ) -> Result<(), Error> {\n+        let rself = Rc::new(RefCell::new(self));\n+        let (mut renderer, mut krate) =\n+            T::init(krate, options, renderinfo, diag, edition, rself.clone())?;\n+        let mut item = match krate.module.take() {\n+            Some(i) => i,\n+            None => return Ok(()),\n+        };\n+\n+        item.name = Some(krate.name.clone());\n+\n+        // Render the crate documentation\n+        let mut work = vec![(renderer.clone(), item)];\n+\n+        while let Some((mut cx, item)) = work.pop() {\n+            if item.is_mod() {\n+                // modules are special because they add a namespace. We also need to\n+                // recurse into the items of the module as well.\n+                let name = item.name.as_ref().unwrap().to_string();\n+                if name.is_empty() {\n+                    panic!(\"Unexpected module with empty name\");\n+                }\n+\n+                let module = match item.inner {\n+                    clean::StrippedItem(box clean::ModuleItem(ref m))\n+                    | clean::ModuleItem(ref m) => m,\n+                    _ => unreachable!(),\n+                };\n+                cx.mod_item_in(&item, &name, module)?;\n+                let module = match item.inner {\n+                    clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n+                    _ => unreachable!(),\n+                };\n+                for it in module.items {\n+                    info!(\"Adding {:?} to worklist\", it.name);\n+                    work.push((cx.clone(), it));\n+                }\n+\n+                cx.mod_item_out()?;\n+            } else if item.name.is_some() {\n+                cx.item(item)?;\n+            }\n+        }\n+\n+        renderer.after_krate(&krate)?;\n+        renderer.after_run(diag)\n+    }\n+}"}, {"sha": "fd32ba66d91d525788b0418061e919a3b3fd5ae4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 298, "deletions": 312, "changes": 610, "blob_url": "https://github.com/rust-lang/rust/blob/5bc97946ca35a789b690668bb6b27ca41bfeb5b2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc97946ca35a789b690668bb6b27ca41bfeb5b2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "patch": "@@ -63,6 +63,7 @@ use crate::config::RenderOptions;\n use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n use crate::error::Error;\n+use crate::formats::{FormatRenderer, Renderer};\n use crate::html::escape::Escape;\n use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::format::Function;\n@@ -98,7 +99,7 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n #[derive(Clone)]\n-struct Context {\n+crate struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub current: Vec<String>,\n@@ -113,6 +114,9 @@ struct Context {\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n     pub cache: Arc<Cache>,\n+    pub parent: Rc<RefCell<Renderer>>,\n+    all: Rc<RefCell<AllTypes>>,\n+    pub errors: Arc<ErrorStorage>,\n }\n \n crate struct SharedContext {\n@@ -390,148 +394,307 @@ pub fn initial_ids() -> Vec<String> {\n     .collect()\n }\n \n-/// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(\n-    mut krate: clean::Crate,\n-    options: RenderOptions,\n-    renderinfo: RenderInfo,\n-    diag: &rustc_errors::Handler,\n-    edition: Edition,\n-) -> Result<(), Error> {\n-    // need to save a copy of the options for rendering the index page\n-    let md_opts = options.clone();\n-    let RenderOptions {\n-        output,\n-        external_html,\n-        id_map,\n-        playground_url,\n-        sort_modules_alphabetically,\n-        themes: style_files,\n-        extension_css,\n-        extern_html_root_urls,\n-        resource_suffix,\n-        static_root_path,\n-        generate_search_filter,\n-        document_private,\n-        ..\n-    } = options;\n-\n-    let src_root = match krate.src {\n-        FileName::Real(ref p) => match p.local_path().parent() {\n-            Some(p) => p.to_path_buf(),\n-            None => PathBuf::new(),\n-        },\n-        _ => PathBuf::new(),\n-    };\n-    let mut errors = Arc::new(ErrorStorage::new());\n-    // If user passed in `--playground-url` arg, we fill in crate name here\n-    let mut playground = None;\n-    if let Some(url) = playground_url {\n-        playground = Some(markdown::Playground { crate_name: Some(krate.name.clone()), url });\n-    }\n-    let mut layout = layout::Layout {\n-        logo: String::new(),\n-        favicon: String::new(),\n-        external_html,\n-        krate: krate.name.clone(),\n-        css_file_extension: extension_css,\n-        generate_search_filter,\n-    };\n-    let mut issue_tracker_base_url = None;\n-    let mut include_sources = true;\n-\n-    // Crawl the crate attributes looking for attributes which control how we're\n-    // going to emit HTML\n-    if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n-        for attr in attrs.lists(sym::doc) {\n-            match (attr.name_or_empty(), attr.value_str()) {\n-                (sym::html_favicon_url, Some(s)) => {\n-                    layout.favicon = s.to_string();\n-                }\n-                (sym::html_logo_url, Some(s)) => {\n-                    layout.logo = s.to_string();\n-                }\n-                (sym::html_playground_url, Some(s)) => {\n-                    playground = Some(markdown::Playground {\n-                        crate_name: Some(krate.name.clone()),\n-                        url: s.to_string(),\n-                    });\n-                }\n-                (sym::issue_tracker_base_url, Some(s)) => {\n-                    issue_tracker_base_url = Some(s.to_string());\n-                }\n-                (sym::html_no_source, None) if attr.is_word() => {\n-                    include_sources = false;\n+impl FormatRenderer for Context {\n+    type Output = Self;\n+\n+    /// Generates the documentation for `crate` into the directory `dst`\n+    fn init(\n+        mut krate: clean::Crate,\n+        options: RenderOptions,\n+        renderinfo: RenderInfo,\n+        _diag: &rustc_errors::Handler,\n+        edition: Edition,\n+        parent: Rc<RefCell<Renderer>>,\n+    ) -> Result<(Context, clean::Crate), Error> {\n+        // need to save a copy of the options for rendering the index page\n+        let md_opts = options.clone();\n+        let RenderOptions {\n+            output,\n+            external_html,\n+            id_map,\n+            playground_url,\n+            sort_modules_alphabetically,\n+            themes: style_files,\n+            extension_css,\n+            extern_html_root_urls,\n+            resource_suffix,\n+            static_root_path,\n+            generate_search_filter,\n+            document_private,\n+            ..\n+        } = options;\n+\n+        let src_root = match krate.src {\n+            FileName::Real(ref p) => match p.local_path().parent() {\n+                Some(p) => p.to_path_buf(),\n+                None => PathBuf::new(),\n+            },\n+            _ => PathBuf::new(),\n+        };\n+        let errors = Arc::new(ErrorStorage::new());\n+        // If user passed in `--playground-url` arg, we fill in crate name here\n+        let mut playground = None;\n+        if let Some(url) = playground_url {\n+            playground = Some(markdown::Playground { crate_name: Some(krate.name.clone()), url });\n+        }\n+        let mut layout = layout::Layout {\n+            logo: String::new(),\n+            favicon: String::new(),\n+            external_html,\n+            krate: krate.name.clone(),\n+            css_file_extension: extension_css,\n+            generate_search_filter,\n+        };\n+        let mut issue_tracker_base_url = None;\n+        let mut include_sources = true;\n+\n+        // Crawl the crate attributes looking for attributes which control how we're\n+        // going to emit HTML\n+        if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n+            for attr in attrs.lists(sym::doc) {\n+                match (attr.name_or_empty(), attr.value_str()) {\n+                    (sym::html_favicon_url, Some(s)) => {\n+                        layout.favicon = s.to_string();\n+                    }\n+                    (sym::html_logo_url, Some(s)) => {\n+                        layout.logo = s.to_string();\n+                    }\n+                    (sym::html_playground_url, Some(s)) => {\n+                        playground = Some(markdown::Playground {\n+                            crate_name: Some(krate.name.clone()),\n+                            url: s.to_string(),\n+                        });\n+                    }\n+                    (sym::issue_tracker_base_url, Some(s)) => {\n+                        issue_tracker_base_url = Some(s.to_string());\n+                    }\n+                    (sym::html_no_source, None) if attr.is_word() => {\n+                        include_sources = false;\n+                    }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n         }\n+        let mut scx = SharedContext {\n+            collapsed: krate.collapsed,\n+            src_root,\n+            include_sources,\n+            local_sources: Default::default(),\n+            issue_tracker_base_url,\n+            layout,\n+            created_dirs: Default::default(),\n+            sort_modules_alphabetically,\n+            style_files,\n+            resource_suffix,\n+            static_root_path,\n+            fs: DocFS::new(&errors),\n+            edition,\n+            codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+            playground,\n+        };\n+\n+        // Add the default themes to the `Vec` of stylepaths\n+        //\n+        // Note that these must be added before `sources::render` is called\n+        // so that the resulting source pages are styled\n+        //\n+        // `light.css` is not disabled because it is the stylesheet that stays loaded\n+        // by the browser as the theme stylesheet. The theme system (hackily) works by\n+        // changing the href to this stylesheet. All other themes are disabled to\n+        // prevent rule conflicts\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n+\n+        let dst = output;\n+        scx.ensure_dir(&dst)?;\n+        krate = sources::render(&dst, &mut scx, krate)?;\n+        let (new_crate, index, cache) =\n+            Cache::from_krate(renderinfo, document_private, &extern_html_root_urls, &dst, krate);\n+        krate = new_crate;\n+        let cache = Arc::new(cache);\n+        let mut cx = Context {\n+            current: Vec::new(),\n+            dst,\n+            render_redirect_pages: false,\n+            id_map: Rc::new(RefCell::new(id_map)),\n+            shared: Arc::new(scx),\n+            cache: cache.clone(),\n+            parent,\n+            all: Rc::new(RefCell::new(AllTypes::new())),\n+            errors,\n+        };\n+\n+        // Freeze the cache now that the index has been built. Put an Arc into TLS\n+        // for future parallelization opportunities\n+        CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n+        CURRENT_DEPTH.with(|s| s.set(0));\n+\n+        // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n+        write_shared(&cx, &krate, index, &md_opts)?;\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+        Ok((cx, krate))\n     }\n-    let mut scx = SharedContext {\n-        collapsed: krate.collapsed,\n-        src_root,\n-        include_sources,\n-        local_sources: Default::default(),\n-        issue_tracker_base_url,\n-        layout,\n-        created_dirs: Default::default(),\n-        sort_modules_alphabetically,\n-        style_files,\n-        resource_suffix,\n-        static_root_path,\n-        fs: DocFS::new(&errors),\n-        edition,\n-        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n-        playground,\n-    };\n \n-    // Add the default themes to the `Vec` of stylepaths\n-    //\n-    // Note that these must be added before `sources::render` is called\n-    // so that the resulting source pages are styled\n-    //\n-    // `light.css` is not disabled because it is the stylesheet that stays loaded\n-    // by the browser as the theme stylesheet. The theme system (hackily) works by\n-    // changing the href to this stylesheet. All other themes are disabled to\n-    // prevent rule conflicts\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n-\n-    let dst = output;\n-    scx.ensure_dir(&dst)?;\n-    krate = sources::render(&dst, &mut scx, krate)?;\n-    let (new_crate, index, cache) =\n-        Cache::from_krate(renderinfo, document_private, &extern_html_root_urls, &dst, krate);\n-    krate = new_crate;\n-    let cache = Arc::new(cache);\n-    let mut cx = Context {\n-        current: Vec::new(),\n-        dst,\n-        render_redirect_pages: false,\n-        id_map: Rc::new(RefCell::new(id_map)),\n-        shared: Arc::new(scx),\n-        cache: cache.clone(),\n-    };\n+    fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error> {\n+        let nb_errors =\n+            Arc::get_mut(&mut self.errors).map_or_else(|| 0, |errors| errors.write_errors(diag));\n+        if nb_errors > 0 {\n+            Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn after_krate(&mut self, krate: &clean::Crate) -> Result<(), Error> {\n+        let final_file = self.dst.join(&krate.name).join(\"all.html\");\n+        let settings_file = self.dst.join(\"settings.html\");\n+        let crate_name = krate.name.clone();\n+\n+        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n+        if !root_path.ends_with('/') {\n+            root_path.push('/');\n+        }\n+        let mut page = layout::Page {\n+            title: \"List of all items in this crate\",\n+            css_class: \"mod\",\n+            root_path: \"../\",\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            description: \"List of all items in this crate\",\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+        let sidebar = if let Some(ref version) = self.cache.crate_version {\n+            format!(\n+                \"<p class='location'>Crate {}</p>\\\n+                     <div class='block version'>\\\n+                         <p>Version {}</p>\\\n+                     </div>\\\n+                     <a id='all-types' href='index.html'><p>Back to index</p></a>\",\n+                crate_name,\n+                Escape(version),\n+            )\n+        } else {\n+            String::new()\n+        };\n+        let all = self.all.replace(AllTypes::new());\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            |buf: &mut Buffer| all.print(buf),\n+            &self.shared.style_files,\n+        );\n+        self.shared.fs.write(&final_file, v.as_bytes())?;\n+\n+        // Generating settings page.\n+        page.title = \"Rustdoc settings\";\n+        page.description = \"Settings of Rustdoc\";\n+        page.root_path = \"./\";\n+\n+        let mut style_files = self.shared.style_files.clone();\n+        let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n+        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            settings(\n+                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n+                &self.shared.resource_suffix,\n+            ),\n+            &style_files,\n+        );\n+        self.shared.fs.write(&settings_file, v.as_bytes())?;\n+        Ok(())\n+    }\n+\n+    fn mod_item_in(\n+        &mut self,\n+        item: &clean::Item,\n+        item_name: &str,\n+        module: &clean::Module,\n+    ) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+        let scx = &self.shared;\n+        self.dst.push(item_name);\n+        self.current.push(item_name.to_owned());\n+\n+        info!(\"Recursing into {}\", self.dst.display());\n+\n+        let buf = self.render_item(item, false);\n+        // buf will be empty if the module is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(\"index.html\");\n+            scx.fs.write(&joint_dst, buf.as_bytes())?;\n+        }\n \n-    // Freeze the cache now that the index has been built. Put an Arc into TLS\n-    // for future parallelization opportunities\n-    CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n-    CURRENT_DEPTH.with(|s| s.set(0));\n+        // Render sidebar-items.js used throughout this module.\n+        if !self.render_redirect_pages {\n+            let items = self.build_sidebar_items(module);\n+            let js_dst = self.dst.join(\"sidebar-items.js\");\n+            let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n+            scx.fs.write(&js_dst, &v)?;\n+        }\n+        Ok(())\n+    }\n \n-    // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n-    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-    write_shared(&cx, &krate, index, &md_opts)?;\n-    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+    fn mod_item_out(&mut self) -> Result<(), Error> {\n+        info!(\"Recursed; leaving {}\", self.dst.display());\n \n-    // And finally render the whole crate's documentation\n-    let ret = cx.krate(krate);\n-    let nb_errors = Arc::get_mut(&mut errors).map_or_else(|| 0, |errors| errors.write_errors(diag));\n-    if ret.is_err() {\n-        ret\n-    } else if nb_errors > 0 {\n-        Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n-    } else {\n+        // Go back to where we were at\n+        self.dst.pop();\n+        self.current.pop();\n+        Ok(())\n+    }\n+\n+    fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+\n+        let buf = self.render_item(&item, true);\n+        // buf will be empty if the item is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            let name = item.name.as_ref().unwrap();\n+            let item_type = item.type_();\n+            let file_name = &item_path(item_type, name);\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(file_name);\n+            self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n+\n+            if !self.render_redirect_pages {\n+                self.all.borrow_mut().append(full_path(self, &item), &item_type);\n+            }\n+            // If the item is a macro, redirect from the old macro URL (with !)\n+            // to the new one (without).\n+            if item_type == ItemType::Macro {\n+                let redir_name = format!(\"{}.{}!.html\", item_type, name);\n+                let redir_dst = self.dst.join(redir_name);\n+                let v = layout::redirect(file_name);\n+                self.shared.fs.write(&redir_dst, v.as_bytes())?;\n+            }\n+        }\n         Ok(())\n     }\n }\n@@ -1291,92 +1454,6 @@ impl Context {\n         \"../\".repeat(self.current.len())\n     }\n \n-    /// Main method for rendering a crate.\n-    ///\n-    /// This currently isn't parallelized, but it'd be pretty easy to add\n-    /// parallelization to this function.\n-    fn krate(self, mut krate: clean::Crate) -> Result<(), Error> {\n-        let mut item = match krate.module.take() {\n-            Some(i) => i,\n-            None => return Ok(()),\n-        };\n-        let final_file = self.dst.join(&krate.name).join(\"all.html\");\n-        let settings_file = self.dst.join(\"settings.html\");\n-\n-        let crate_name = krate.name.clone();\n-        item.name = Some(krate.name);\n-\n-        let mut all = AllTypes::new();\n-\n-        {\n-            // Render the crate documentation\n-            let mut work = vec![(self.clone(), item)];\n-\n-            while let Some((mut cx, item)) = work.pop() {\n-                cx.item(item, &mut all, |cx, item| work.push((cx.clone(), item)))?\n-            }\n-        }\n-\n-        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n-        if !root_path.ends_with('/') {\n-            root_path.push('/');\n-        }\n-        let mut page = layout::Page {\n-            title: \"List of all items in this crate\",\n-            css_class: \"mod\",\n-            root_path: \"../\",\n-            static_root_path: self.shared.static_root_path.as_deref(),\n-            description: \"List of all items in this crate\",\n-            keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.shared.resource_suffix,\n-            extra_scripts: &[],\n-            static_extra_scripts: &[],\n-        };\n-        let sidebar = if let Some(ref version) = self.cache.crate_version {\n-            format!(\n-                \"<p class='location'>Crate {}</p>\\\n-                     <div class='block version'>\\\n-                         <p>Version {}</p>\\\n-                     </div>\\\n-                     <a id='all-types' href='index.html'><p>Back to index</p></a>\",\n-                crate_name,\n-                Escape(version),\n-            )\n-        } else {\n-            String::new()\n-        };\n-        let v = layout::render(\n-            &self.shared.layout,\n-            &page,\n-            sidebar,\n-            |buf: &mut Buffer| all.print(buf),\n-            &self.shared.style_files,\n-        );\n-        self.shared.fs.write(&final_file, v.as_bytes())?;\n-\n-        // Generating settings page.\n-        page.title = \"Rustdoc settings\";\n-        page.description = \"Settings of Rustdoc\";\n-        page.root_path = \"./\";\n-\n-        let mut style_files = self.shared.style_files.clone();\n-        let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n-        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n-        let v = layout::render(\n-            &self.shared.layout,\n-            &page,\n-            sidebar,\n-            settings(\n-                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n-                &self.shared.resource_suffix,\n-            ),\n-            &style_files,\n-        );\n-        self.shared.fs.write(&settings_file, v.as_bytes())?;\n-\n-        Ok(())\n-    }\n-\n     fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n         // A little unfortunate that this is done like this, but it sure\n         // does make formatting *a lot* nicer.\n@@ -1449,97 +1526,6 @@ impl Context {\n         }\n     }\n \n-    /// Non-parallelized version of rendering an item. This will take the input\n-    /// item, render its contents, and then invoke the specified closure with\n-    /// all sub-items which need to be rendered.\n-    ///\n-    /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, all: &mut AllTypes, mut f: F) -> Result<(), Error>\n-    where\n-        F: FnMut(&mut Context, clean::Item),\n-    {\n-        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n-        // if they contain impls for public types. These modules can also\n-        // contain items such as publicly re-exported structures.\n-        //\n-        // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally\n-        // (a flag on the context).\n-        if !self.render_redirect_pages {\n-            self.render_redirect_pages = item.is_stripped();\n-        }\n-\n-        if item.is_mod() {\n-            // modules are special because they add a namespace. We also need to\n-            // recurse into the items of the module as well.\n-            let name = item.name.as_ref().unwrap().to_string();\n-            let scx = &self.shared;\n-            if name.is_empty() {\n-                panic!(\"Unexpected empty destination: {:?}\", self.current);\n-            }\n-            let prev = self.dst.clone();\n-            self.dst.push(&name);\n-            self.current.push(name);\n-\n-            info!(\"Recursing into {}\", self.dst.display());\n-\n-            let buf = self.render_item(&item, false);\n-            // buf will be empty if the module is stripped and there is no redirect for it\n-            if !buf.is_empty() {\n-                self.shared.ensure_dir(&self.dst)?;\n-                let joint_dst = self.dst.join(\"index.html\");\n-                scx.fs.write(&joint_dst, buf.as_bytes())?;\n-            }\n-\n-            let m = match item.inner {\n-                clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n-                _ => unreachable!(),\n-            };\n-\n-            // Render sidebar-items.js used throughout this module.\n-            if !self.render_redirect_pages {\n-                let items = self.build_sidebar_items(&m);\n-                let js_dst = self.dst.join(\"sidebar-items.js\");\n-                let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n-                scx.fs.write(&js_dst, &v)?;\n-            }\n-\n-            for item in m.items {\n-                f(self, item);\n-            }\n-\n-            info!(\"Recursed; leaving {}\", self.dst.display());\n-\n-            // Go back to where we were at\n-            self.dst = prev;\n-            self.current.pop().unwrap();\n-        } else if item.name.is_some() {\n-            let buf = self.render_item(&item, true);\n-            // buf will be empty if the item is stripped and there is no redirect for it\n-            if !buf.is_empty() {\n-                let name = item.name.as_ref().unwrap();\n-                let item_type = item.type_();\n-                let file_name = &item_path(item_type, name);\n-                self.shared.ensure_dir(&self.dst)?;\n-                let joint_dst = self.dst.join(file_name);\n-                self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n-\n-                if !self.render_redirect_pages {\n-                    all.append(full_path(self, &item), &item_type);\n-                }\n-                // If the item is a macro, redirect from the old macro URL (with !)\n-                // to the new one (without).\n-                if item_type == ItemType::Macro {\n-                    let redir_name = format!(\"{}.{}!.html\", item_type, name);\n-                    let redir_dst = self.dst.join(redir_name);\n-                    let v = layout::redirect(file_name);\n-                    self.shared.fs.write(&redir_dst, v.as_bytes())?;\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map: BTreeMap<_, Vec<_>> = BTreeMap::new();"}, {"sha": "715956ea1720c7f34dd328f6bb318787863e5904", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5bc97946ca35a789b690668bb6b27ca41bfeb5b2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc97946ca35a789b690668bb6b27ca41bfeb5b2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "patch": "@@ -66,6 +66,7 @@ mod doctree;\n #[macro_use]\n mod error;\n mod fold;\n+mod formats;\n pub mod html {\n     crate mod escape;\n     crate mod format;\n@@ -512,7 +513,9 @@ fn main_options(options: config::Options) -> i32 {\n         info!(\"going to format\");\n         let (error_format, edition, debugging_options) = diag_opts;\n         let diag = core::new_handler(error_format, None, &debugging_options);\n-        match html::render::run(krate, renderopts, renderinfo, &diag, edition) {\n+        match formats::Renderer::new()\n+            .run::<html::render::Context>(krate, renderopts, renderinfo, &diag, edition)\n+        {\n             Ok(_) => rustc_driver::EXIT_SUCCESS,\n             Err(e) => {\n                 diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error))"}]}