{"sha": "b97ec3924dc5a3718af8b2936fd6cc356e785832", "node_id": "C_kwDOAAsO6NoAKGI5N2VjMzkyNGRjNWEzNzE4YWY4YjI5MzZmZDZjYzM1NmU3ODU4MzI", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-22T15:37:54Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-22T18:49:29Z"}, "message": "`rustc_ast_lowering`: remove `ref` patterns", "tree": {"sha": "3b22dabb2454a7dfa5d54e0a5db2a6a9f4cc36c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b22dabb2454a7dfa5d54e0a5db2a6a9f4cc36c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b97ec3924dc5a3718af8b2936fd6cc356e785832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b97ec3924dc5a3718af8b2936fd6cc356e785832", "html_url": "https://github.com/rust-lang/rust/commit/b97ec3924dc5a3718af8b2936fd6cc356e785832", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b97ec3924dc5a3718af8b2936fd6cc356e785832/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a60363567015323a85b9ee890fd1076573e7d2b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a60363567015323a85b9ee890fd1076573e7d2b8", "html_url": "https://github.com/rust-lang/rust/commit/a60363567015323a85b9ee890fd1076573e7d2b8"}], "stats": {"total": 567, "additions": 267, "deletions": 300}, "files": [{"sha": "2a0338adc9ca4c51be01dd2aa41de1a2ea0ab054", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=b97ec3924dc5a3718af8b2936fd6cc356e785832", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .operands\n             .iter()\n             .map(|(op, op_sp)| {\n-                let lower_reg = |reg| match reg {\n+                let lower_reg = |&reg: &_| match reg {\n                     InlineAsmRegOrRegClass::Reg(reg) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(asm_arch, reg).unwrap_or_else(|error| {\n@@ -152,32 +152,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                 };\n \n-                let op = match *op {\n-                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                let op = match op {\n+                    InlineAsmOperand::In { reg, expr } => hir::InlineAsmOperand::In {\n                         reg: lower_reg(reg),\n                         expr: self.lower_expr(expr),\n                     },\n-                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                    InlineAsmOperand::Out { reg, late, expr } => hir::InlineAsmOperand::Out {\n                         reg: lower_reg(reg),\n-                        late,\n+                        late: *late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr(expr)),\n                     },\n-                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                        hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg),\n-                            late,\n-                            expr: self.lower_expr(expr),\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                    InlineAsmOperand::InOut { reg, late, expr } => hir::InlineAsmOperand::InOut {\n+                        reg: lower_reg(reg),\n+                        late: *late,\n+                        expr: self.lower_expr(expr),\n+                    },\n+                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n                             reg: lower_reg(reg),\n-                            late,\n+                            late: *late,\n                             in_expr: self.lower_expr(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr(expr)),\n                         }\n                     }\n-                    InlineAsmOperand::Const { ref anon_const } => {\n+                    InlineAsmOperand::Const { anon_const } => {\n                         if !self.tcx.features().asm_const {\n                             feature_err(\n                                 &sess.parse_sess,\n@@ -191,7 +189,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             anon_const: self.lower_anon_const(anon_const),\n                         }\n                     }\n-                    InlineAsmOperand::Sym { ref sym } => {\n+                    InlineAsmOperand::Sym { sym } => {\n                         let static_def_id = self\n                             .resolver\n                             .get_partial_res(sym.id)\n@@ -347,7 +345,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                     skip = true;\n \n                                     let idx2 = *o.get();\n-                                    let &(ref op2, op_sp2) = &operands[idx2];\n+                                    let (ref op2, op_sp2) = operands[idx2];\n                                     let Some(asm::InlineAsmRegOrRegClass::Reg(reg2)) = op2.reg() else {\n                                         unreachable!();\n                                     };"}, {"sha": "d310f72f7a3f8f8bdb3527ecf0fa3cc10c0474b9", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=b97ec3924dc5a3718af8b2936fd6cc356e785832", "patch": "@@ -31,16 +31,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut stmts = SmallVec::<[hir::Stmt<'hir>; 8]>::new();\n         let mut expr = None;\n         while let [s, tail @ ..] = ast_stmts {\n-            match s.kind {\n-                StmtKind::Local(ref local) => {\n+            match &s.kind {\n+                StmtKind::Local(local) => {\n                     let hir_id = self.lower_node_id(s.id);\n                     let local = self.lower_local(local);\n                     self.alias_attrs(hir_id, local.hir_id);\n                     let kind = hir::StmtKind::Local(local);\n                     let span = self.lower_span(s.span);\n                     stmts.push(hir::Stmt { hir_id, kind, span });\n                 }\n-                StmtKind::Item(ref it) => {\n+                StmtKind::Item(it) => {\n                     stmts.extend(self.lower_item_ref(it).into_iter().enumerate().map(\n                         |(i, item_id)| {\n                             let hir_id = match i {\n@@ -53,7 +53,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         },\n                     ));\n                 }\n-                StmtKind::Expr(ref e) => {\n+                StmtKind::Expr(e) => {\n                     let e = self.lower_expr(e);\n                     if tail.is_empty() {\n                         expr = Some(e);\n@@ -65,7 +65,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         stmts.push(hir::Stmt { hir_id, kind, span });\n                     }\n                 }\n-                StmtKind::Semi(ref e) => {\n+                StmtKind::Semi(e) => {\n                     let e = self.lower_expr(e);\n                     let hir_id = self.lower_node_id(s.id);\n                     self.alias_attrs(hir_id, e.hir_id);"}, {"sha": "c4ae8b6c881d48d89210776b7cc1bcf6414d2548", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 78, "deletions": 84, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b97ec3924dc5a3718af8b2936fd6cc356e785832", "patch": "@@ -31,20 +31,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         ensure_sufficient_stack(|| {\n-            let kind = match e.kind {\n-                ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n-                ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n-                ExprKind::ConstBlock(ref anon_const) => {\n+            let kind = match &e.kind {\n+                ExprKind::Box(inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n+                ExprKind::Array(exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+                ExprKind::ConstBlock(anon_const) => {\n                     let anon_const = self.lower_anon_const(anon_const);\n                     hir::ExprKind::ConstBlock(anon_const)\n                 }\n-                ExprKind::Repeat(ref expr, ref count) => {\n+                ExprKind::Repeat(expr, count) => {\n                     let expr = self.lower_expr(expr);\n                     let count = self.lower_array_length(count);\n                     hir::ExprKind::Repeat(expr, count)\n                 }\n-                ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n-                ExprKind::Call(ref f, ref args) => {\n+                ExprKind::Tup(elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n+                ExprKind::Call(f, args) => {\n                     if e.attrs.get(0).map_or(false, |a| a.has_name(sym::rustc_box)) {\n                         if let [inner] = &args[..] && e.attrs.len() == 1 {\n                             let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n@@ -61,7 +61,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::ExprKind::Call(f, self.lower_exprs(args))\n                     }\n                 }\n-                ExprKind::MethodCall(box MethodCall { ref seg, ref receiver, ref args, span }) => {\n+                ExprKind::MethodCall(box MethodCall { seg, receiver, args, span }) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n                         e.span,\n                         seg,\n@@ -72,92 +72,88 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let receiver = self.lower_expr(receiver);\n                     let args =\n                         self.arena.alloc_from_iter(args.iter().map(|x| self.lower_expr_mut(x)));\n-                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(span))\n+                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(*span))\n                 }\n-                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n-                    let binop = self.lower_binop(binop);\n+                ExprKind::Binary(binop, lhs, rhs) => {\n+                    let binop = self.lower_binop(*binop);\n                     let lhs = self.lower_expr(lhs);\n                     let rhs = self.lower_expr(rhs);\n                     hir::ExprKind::Binary(binop, lhs, rhs)\n                 }\n-                ExprKind::Unary(op, ref ohs) => {\n-                    let op = self.lower_unop(op);\n+                ExprKind::Unary(op, ohs) => {\n+                    let op = self.lower_unop(*op);\n                     let ohs = self.lower_expr(ohs);\n                     hir::ExprKind::Unary(op, ohs)\n                 }\n                 ExprKind::Lit(token_lit) => {\n-                    let lit_kind = match LitKind::from_token_lit(token_lit) {\n+                    let lit_kind = match LitKind::from_token_lit(*token_lit) {\n                         Ok(lit_kind) => lit_kind,\n                         Err(err) => {\n-                            report_lit_error(&self.tcx.sess.parse_sess, err, token_lit, e.span);\n+                            report_lit_error(&self.tcx.sess.parse_sess, err, *token_lit, e.span);\n                             LitKind::Err\n                         }\n                     };\n                     hir::ExprKind::Lit(respan(self.lower_span(e.span), lit_kind))\n                 }\n-                ExprKind::IncludedBytes(ref bytes) => hir::ExprKind::Lit(respan(\n+                ExprKind::IncludedBytes(bytes) => hir::ExprKind::Lit(respan(\n                     self.lower_span(e.span),\n                     LitKind::ByteStr(bytes.clone()),\n                 )),\n-                ExprKind::Cast(ref expr, ref ty) => {\n+                ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n                         self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Cast(expr, ty)\n                 }\n-                ExprKind::Type(ref expr, ref ty) => {\n+                ExprKind::Type(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n                         self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Type(expr, ty)\n                 }\n-                ExprKind::AddrOf(k, m, ref ohs) => {\n+                ExprKind::AddrOf(k, m, ohs) => {\n                     let ohs = self.lower_expr(ohs);\n-                    hir::ExprKind::AddrOf(k, m, ohs)\n+                    hir::ExprKind::AddrOf(*k, *m, ohs)\n                 }\n-                ExprKind::Let(ref pat, ref scrutinee, span) => {\n+                ExprKind::Let(pat, scrutinee, span) => {\n                     hir::ExprKind::Let(self.arena.alloc(hir::Let {\n                         hir_id: self.next_id(),\n-                        span: self.lower_span(span),\n+                        span: self.lower_span(*span),\n                         pat: self.lower_pat(pat),\n                         ty: None,\n                         init: self.lower_expr(scrutinee),\n                     }))\n                 }\n-                ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                ExprKind::If(cond, then, else_opt) => {\n                     self.lower_expr_if(cond, then, else_opt.as_deref())\n                 }\n-                ExprKind::While(ref cond, ref body, opt_label) => {\n-                    self.with_loop_scope(e.id, |this| {\n-                        let span =\n-                            this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n-                        this.lower_expr_while_in_loop_scope(span, cond, body, opt_label)\n-                    })\n-                }\n-                ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                ExprKind::While(cond, body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                    let span = this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n+                    this.lower_expr_while_in_loop_scope(span, cond, body, *opt_label)\n+                }),\n+                ExprKind::Loop(body, opt_label) => self.with_loop_scope(e.id, |this| {\n                     hir::ExprKind::Loop(\n                         this.lower_block(body, false),\n-                        this.lower_label(opt_label),\n+                        this.lower_label(*opt_label),\n                         hir::LoopSource::Loop,\n                         DUMMY_SP,\n                     )\n                 }),\n-                ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n-                ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n+                ExprKind::TryBlock(body) => self.lower_expr_try_block(body),\n+                ExprKind::Match(expr, arms) => hir::ExprKind::Match(\n                     self.lower_expr(expr),\n                     self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                     hir::MatchSource::Normal,\n                 ),\n-                ExprKind::Async(capture_clause, closure_node_id, ref block) => self\n-                    .make_async_expr(\n-                        capture_clause,\n-                        closure_node_id,\n-                        None,\n-                        block.span,\n-                        hir::AsyncGeneratorKind::Block,\n-                        |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n-                    ),\n-                ExprKind::Await(ref expr) => {\n+                ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n+                    *capture_clause,\n+                    *closure_node_id,\n+                    None,\n+                    block.span,\n+                    hir::AsyncGeneratorKind::Block,\n+                    |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                ),\n+                ExprKind::Await(expr) => {\n                     let dot_await_span = if expr.span.hi() < e.span.hi() {\n                         let span_with_whitespace = self\n                             .tcx\n@@ -173,65 +169,63 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_await(dot_await_span, expr)\n                 }\n                 ExprKind::Closure(box Closure {\n-                    ref binder,\n+                    binder,\n                     capture_clause,\n                     asyncness,\n                     movability,\n-                    ref fn_decl,\n-                    ref body,\n+                    fn_decl,\n+                    body,\n                     fn_decl_span,\n                 }) => {\n                     if let Async::Yes { closure_id, .. } = asyncness {\n                         self.lower_expr_async_closure(\n                             binder,\n-                            capture_clause,\n+                            *capture_clause,\n                             e.id,\n-                            closure_id,\n+                            *closure_id,\n                             fn_decl,\n                             body,\n-                            fn_decl_span,\n+                            *fn_decl_span,\n                         )\n                     } else {\n                         self.lower_expr_closure(\n                             binder,\n-                            capture_clause,\n+                            *capture_clause,\n                             e.id,\n-                            movability,\n+                            *movability,\n                             fn_decl,\n                             body,\n-                            fn_decl_span,\n+                            *fn_decl_span,\n                         )\n                     }\n                 }\n-                ExprKind::Block(ref blk, opt_label) => {\n-                    let opt_label = self.lower_label(opt_label);\n+                ExprKind::Block(blk, opt_label) => {\n+                    let opt_label = self.lower_label(*opt_label);\n                     hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n                 }\n-                ExprKind::Assign(ref el, ref er, span) => {\n-                    self.lower_expr_assign(el, er, span, e.span)\n-                }\n-                ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n-                    self.lower_binop(op),\n+                ExprKind::Assign(el, er, span) => self.lower_expr_assign(el, er, *span, e.span),\n+                ExprKind::AssignOp(op, el, er) => hir::ExprKind::AssignOp(\n+                    self.lower_binop(*op),\n                     self.lower_expr(el),\n                     self.lower_expr(er),\n                 ),\n-                ExprKind::Field(ref el, ident) => {\n-                    hir::ExprKind::Field(self.lower_expr(el), self.lower_ident(ident))\n+                ExprKind::Field(el, ident) => {\n+                    hir::ExprKind::Field(self.lower_expr(el), self.lower_ident(*ident))\n                 }\n-                ExprKind::Index(ref el, ref er) => {\n+                ExprKind::Index(el, er) => {\n                     hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n                 }\n-                ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                ExprKind::Range(Some(e1), Some(e2), RangeLimits::Closed) => {\n                     self.lower_expr_range_closed(e.span, e1, e2)\n                 }\n-                ExprKind::Range(ref e1, ref e2, lims) => {\n-                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n+                ExprKind::Range(e1, e2, lims) => {\n+                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), *lims)\n                 }\n                 ExprKind::Underscore => {\n                     self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n                     hir::ExprKind::Err\n                 }\n-                ExprKind::Path(ref qself, ref path) => {\n+                ExprKind::Path(qself, path) => {\n                     let qpath = self.lower_qpath(\n                         e.id,\n                         qself,\n@@ -241,22 +235,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     hir::ExprKind::Path(qpath)\n                 }\n-                ExprKind::Break(opt_label, ref opt_expr) => {\n+                ExprKind::Break(opt_label, opt_expr) => {\n                     let opt_expr = opt_expr.as_ref().map(|x| self.lower_expr(x));\n-                    hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n+                    hir::ExprKind::Break(self.lower_jump_destination(e.id, *opt_label), opt_expr)\n                 }\n                 ExprKind::Continue(opt_label) => {\n-                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n+                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, *opt_label))\n                 }\n-                ExprKind::Ret(ref e) => {\n+                ExprKind::Ret(e) => {\n                     let e = e.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Ret(e)\n                 }\n-                ExprKind::Yeet(ref sub_expr) => self.lower_expr_yeet(e.span, sub_expr.as_deref()),\n-                ExprKind::InlineAsm(ref asm) => {\n+                ExprKind::Yeet(sub_expr) => self.lower_expr_yeet(e.span, sub_expr.as_deref()),\n+                ExprKind::InlineAsm(asm) => {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n-                ExprKind::Struct(ref se) => {\n+                ExprKind::Struct(se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n@@ -278,10 +272,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         rest,\n                     )\n                 }\n-                ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n+                ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n                 ExprKind::Err => hir::ExprKind::Err,\n-                ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n-                ExprKind::Paren(ref ex) => {\n+                ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n+                ExprKind::Paren(ex) => {\n                     let mut ex = self.lower_expr_mut(ex);\n                     // Include parens in span, but only if it is a super-span.\n                     if e.span.contains(ex.span) {\n@@ -306,8 +300,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Desugar `ExprForLoop`\n                 // from: `[opt_ident]: for <pat> in <head> <body>`\n-                ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n-                    return self.lower_expr_for(e, pat, head, body, opt_label);\n+                ExprKind::ForLoop(pat, head, body, opt_label) => {\n+                    return self.lower_expr_for(e, pat, head, body, *opt_label);\n                 }\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n@@ -358,7 +352,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         args: Vec<AstP<Expr>>,\n         legacy_args_idx: &[usize],\n     ) -> hir::ExprKind<'hir> {\n-        let ExprKind::Path(None, ref mut path) = f.kind else {\n+        let ExprKind::Path(None, path) = &mut f.kind else {\n             unreachable!();\n         };\n \n@@ -552,10 +546,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         let pat = self.lower_pat(&arm.pat);\n         let guard = arm.guard.as_ref().map(|cond| {\n-            if let ExprKind::Let(ref pat, ref scrutinee, span) = cond.kind {\n+            if let ExprKind::Let(pat, scrutinee, span) = &cond.kind {\n                 hir::Guard::IfLet(self.arena.alloc(hir::Let {\n                     hir_id: self.next_id(),\n-                    span: self.lower_span(span),\n+                    span: self.lower_span(*span),\n                     pat: self.lower_pat(pat),\n                     ty: None,\n                     init: self.lower_expr(scrutinee),\n@@ -966,8 +960,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> (hir::ClosureBinder, &'c [GenericParam]) {\n         let (binder, params) = match binder {\n             ClosureBinder::NotPresent => (hir::ClosureBinder::Default, &[][..]),\n-            &ClosureBinder::For { span, ref generic_params } => {\n-                let span = self.lower_span(span);\n+            ClosureBinder::For { span, generic_params } => {\n+                let span = self.lower_span(*span);\n                 (hir::ClosureBinder::For { span }, &**generic_params)\n             }\n         };"}, {"sha": "695a698e0227a15127be2688bf5c2b5b2ea43115", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=b97ec3924dc5a3718af8b2936fd6cc356e785832", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug_assert_eq!(i.owner_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n-            if let ItemKind::Struct(ref struct_def, _) = i.kind {\n+            if let ItemKind::Struct(struct_def, _) = &i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));"}, {"sha": "a1941b5d8d3700f19736161eaf010cd4f43d9d11", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 79, "deletions": 102, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=b97ec3924dc5a3718af8b2936fd6cc356e785832", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             // This is used to track which lifetimes have already been defined,\n             // and which need to be replicated when lowering an async fn.\n             match parent_hir.node().expect_item().kind {\n-                hir::ItemKind::Impl(hir::Impl { ref of_trait, .. }) => {\n+                hir::ItemKind::Impl(hir::Impl { of_trait, .. }) => {\n                     lctx.is_in_trait_impl = of_trait.is_some();\n                 }\n                 _ => {}\n@@ -178,7 +178,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n         let mut node_ids =\n             smallvec![hir::ItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n-        if let ItemKind::Use(ref use_tree) = &i.kind {\n+        if let ItemKind::Use(use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n         node_ids\n@@ -190,8 +190,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         base_id: NodeId,\n         vec: &mut SmallVec<[hir::ItemId; 1]>,\n     ) {\n-        match tree.kind {\n-            UseTreeKind::Nested(ref nested_vec) => {\n+        match &tree.kind {\n+            UseTreeKind::Nested(nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n                     vec.push(hir::ItemId {\n                         owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n@@ -201,8 +201,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             UseTreeKind::Glob => {}\n             UseTreeKind::Simple(_, id1, id2) => {\n-                for (_, &id) in\n-                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n+                for (_, id) in\n+                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), [*id1, *id2])\n                 {\n                     vec.push(hir::ItemId {\n                         owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n@@ -238,26 +238,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         vis_span: Span,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n-        match *i {\n-            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n-            ItemKind::Use(ref use_tree) => {\n+        match i {\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(*orig_name),\n+            ItemKind::Use(use_tree) => {\n                 // Start with an empty prefix.\n                 let prefix = Path { segments: ThinVec::new(), span: use_tree.span, tokens: None };\n \n                 self.lower_use_tree(use_tree, &prefix, id, vis_span, ident, attrs)\n             }\n-            ItemKind::Static(ref t, m, ref e) => {\n+            ItemKind::Static(t, m, e) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n-                hir::ItemKind::Static(ty, m, body_id)\n+                hir::ItemKind::Static(ty, *m, body_id)\n             }\n-            ItemKind::Const(_, ref t, ref e) => {\n+            ItemKind::Const(_, t, e) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n                 hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(box Fn {\n-                sig: FnSig { ref decl, header, span: fn_sig_span },\n-                ref generics,\n-                ref body,\n+                sig: FnSig { decl, header, span: fn_sig_span },\n+                generics,\n+                body,\n                 ..\n             }) => {\n                 self.with_new_scopes(|this| {\n@@ -274,37 +274,30 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let mut itctx = ImplTraitContext::Universal;\n                     let (generics, decl) = this.lower_generics(generics, id, &mut itctx, |this| {\n                         let ret_id = asyncness.opt_return_id();\n-                        this.lower_fn_decl(&decl, Some(id), fn_sig_span, FnDeclKind::Fn, ret_id)\n+                        this.lower_fn_decl(&decl, Some(id), *fn_sig_span, FnDeclKind::Fn, ret_id)\n                     });\n                     let sig = hir::FnSig {\n                         decl,\n-                        header: this.lower_fn_header(header),\n-                        span: this.lower_span(fn_sig_span),\n+                        header: this.lower_fn_header(*header),\n+                        span: this.lower_span(*fn_sig_span),\n                     };\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n-            ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n+            ItemKind::Mod(_, mod_kind) => match mod_kind {\n                 ModKind::Loaded(items, _, spans) => {\n                     hir::ItemKind::Mod(self.lower_mod(items, spans))\n                 }\n                 ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n             },\n-            ItemKind::ForeignMod(ref fm) => hir::ItemKind::ForeignMod {\n+            ItemKind::ForeignMod(fm) => hir::ItemKind::ForeignMod {\n                 abi: fm.abi.map_or(abi::Abi::FALLBACK, |abi| self.lower_abi(abi)),\n                 items: self\n                     .arena\n                     .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n             },\n-            ItemKind::GlobalAsm(ref asm) => {\n-                hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm))\n-            }\n-            ItemKind::TyAlias(box TyAlias {\n-                ref generics,\n-                where_clauses,\n-                ty: Some(ref ty),\n-                ..\n-            }) => {\n+            ItemKind::GlobalAsm(asm) => hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm)),\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: Some(ty), .. }) => {\n                 // We lower\n                 //\n                 // type Foo = impl Trait\n@@ -314,7 +307,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // type Foo = Foo1\n                 // opaque type Foo1: Trait\n                 let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, where_clauses, true);\n+                add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n                 let (generics, ty) = self.lower_generics(\n                     &generics,\n                     id,\n@@ -323,9 +316,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n-            ItemKind::TyAlias(box TyAlias {\n-                ref generics, ref where_clauses, ty: None, ..\n-            }) => {\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: None, .. }) => {\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n                 let (generics, ty) = self.lower_generics(\n@@ -336,7 +327,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n-            ItemKind::Enum(ref enum_definition, ref generics) => {\n+            ItemKind::Enum(enum_definition, generics) => {\n                 let (generics, variants) = self.lower_generics(\n                     generics,\n                     id,\n@@ -349,7 +340,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::Enum(hir::EnumDef { variants }, generics)\n             }\n-            ItemKind::Struct(ref struct_def, ref generics) => {\n+            ItemKind::Struct(struct_def, generics) => {\n                 let (generics, struct_def) = self.lower_generics(\n                     generics,\n                     id,\n@@ -358,7 +349,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::Struct(struct_def, generics)\n             }\n-            ItemKind::Union(ref vdata, ref generics) => {\n+            ItemKind::Union(vdata, generics) => {\n                 let (generics, vdata) = self.lower_generics(\n                     generics,\n                     id,\n@@ -372,10 +363,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 polarity,\n                 defaultness,\n                 constness,\n-                generics: ref ast_generics,\n-                of_trait: ref trait_ref,\n-                self_ty: ref ty,\n-                items: ref impl_items,\n+                generics: ast_generics,\n+                of_trait: trait_ref,\n+                self_ty: ty,\n+                items: impl_items,\n             }) => {\n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n@@ -413,30 +404,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // `defaultness.has_value()` is never called for an `impl`, always `true` in order\n                 // to not cause an assertion failure inside the `lower_defaultness` function.\n                 let has_val = true;\n-                let (defaultness, defaultness_span) = self.lower_defaultness(defaultness, has_val);\n+                let (defaultness, defaultness_span) = self.lower_defaultness(*defaultness, has_val);\n                 let polarity = match polarity {\n                     ImplPolarity::Positive => ImplPolarity::Positive,\n-                    ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(s)),\n+                    ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(*s)),\n                 };\n                 hir::ItemKind::Impl(self.arena.alloc(hir::Impl {\n-                    unsafety: self.lower_unsafety(unsafety),\n+                    unsafety: self.lower_unsafety(*unsafety),\n                     polarity,\n                     defaultness,\n                     defaultness_span,\n-                    constness: self.lower_constness(constness),\n+                    constness: self.lower_constness(*constness),\n                     generics,\n                     of_trait: trait_ref,\n                     self_ty: lowered_ty,\n                     items: new_impl_items,\n                 }))\n             }\n-            ItemKind::Trait(box Trait {\n-                is_auto,\n-                unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n-            }) => {\n+            ItemKind::Trait(box Trait { is_auto, unsafety, generics, bounds, items }) => {\n                 let (generics, (unsafety, items, bounds)) = self.lower_generics(\n                     generics,\n                     id,\n@@ -449,13 +434,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let items = this.arena.alloc_from_iter(\n                             items.iter().map(|item| this.lower_trait_item_ref(item)),\n                         );\n-                        let unsafety = this.lower_unsafety(unsafety);\n+                        let unsafety = this.lower_unsafety(*unsafety);\n                         (unsafety, items, bounds)\n                     },\n                 );\n-                hir::ItemKind::Trait(is_auto, unsafety, generics, bounds, items)\n+                hir::ItemKind::Trait(*is_auto, unsafety, generics, bounds, items)\n             }\n-            ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            ItemKind::TraitAlias(generics, bounds) => {\n                 let (generics, bounds) = self.lower_generics(\n                     generics,\n                     id,\n@@ -469,10 +454,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TraitAlias(generics, bounds)\n             }\n-            ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n+            ItemKind::MacroDef(MacroDef { body, macro_rules }) => {\n                 let body = P(self.lower_delim_args(body));\n                 let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n-                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n+                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules: *macro_rules }, macro_kind)\n             }\n             ItemKind::MacCall(..) => {\n                 panic!(\"`TyMac` should have been expanded by now\")\n@@ -664,8 +649,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let item = hir::ForeignItem {\n             owner_id,\n             ident: self.lower_ident(i.ident),\n-            kind: match i.kind {\n-                ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n+            kind: match &i.kind {\n+                ForeignItemKind::Fn(box Fn { sig, generics, .. }) => {\n                     let fdec = &sig.decl;\n                     let mut itctx = ImplTraitContext::Universal;\n                     let (generics, (fn_dec, fn_args)) =\n@@ -685,10 +670,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n-                ForeignItemKind::Static(ref t, m, _) => {\n+                ForeignItemKind::Static(t, m, _) => {\n                     let ty =\n                         self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n-                    hir::ForeignItemKind::Static(ty, m)\n+                    hir::ForeignItemKind::Static(ty, *m)\n                 }\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::MacCall(_) => panic!(\"macro shouldn't exist here\"),\n@@ -725,33 +710,33 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         parent_id: hir::HirId,\n         vdata: &VariantData,\n     ) -> hir::VariantData<'hir> {\n-        match *vdata {\n-            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+        match vdata {\n+            VariantData::Struct(fields, recovered) => hir::VariantData::Struct(\n                 self.arena\n                     .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_field_def(f))),\n-                recovered,\n+                *recovered,\n             ),\n-            VariantData::Tuple(ref fields, id) => {\n-                let ctor_id = self.lower_node_id(id);\n+            VariantData::Tuple(fields, id) => {\n+                let ctor_id = self.lower_node_id(*id);\n                 self.alias_attrs(ctor_id, parent_id);\n                 hir::VariantData::Tuple(\n                     self.arena.alloc_from_iter(\n                         fields.iter().enumerate().map(|f| self.lower_field_def(f)),\n                     ),\n                     ctor_id,\n-                    self.local_def_id(id),\n+                    self.local_def_id(*id),\n                 )\n             }\n             VariantData::Unit(id) => {\n-                let ctor_id = self.lower_node_id(id);\n+                let ctor_id = self.lower_node_id(*id);\n                 self.alias_attrs(ctor_id, parent_id);\n-                hir::VariantData::Unit(ctor_id, self.local_def_id(id))\n+                hir::VariantData::Unit(ctor_id, self.local_def_id(*id))\n             }\n         }\n     }\n \n     fn lower_field_def(&mut self, (index, f): (usize, &FieldDef)) -> hir::FieldDef<'hir> {\n-        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n+        let ty = if let TyKind::Path(qself, path) = &f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n                 qself,\n@@ -783,13 +768,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         let trait_item_def_id = hir_id.expect_owner();\n \n-        let (generics, kind, has_default) = match i.kind {\n-            AssocItemKind::Const(_, ref ty, ref default) => {\n+        let (generics, kind, has_default) = match &i.kind {\n+            AssocItemKind::Const(_, ty, default) => {\n                 let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n                 (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, body: None, .. }) => {\n+            AssocItemKind::Fn(box Fn { sig, generics, body: None, .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n@@ -801,7 +786,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)), false)\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, body: Some(ref body), .. }) => {\n+            AssocItemKind::Fn(box Fn { sig, generics, body: Some(body), .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let body_id =\n                     self.lower_maybe_async_body(i.span, &sig.decl, asyncness, Some(&body));\n@@ -814,15 +799,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)), true)\n             }\n-            AssocItemKind::Type(box TyAlias {\n-                ref generics,\n-                where_clauses,\n-                ref bounds,\n-                ref ty,\n-                ..\n-            }) => {\n+            AssocItemKind::Type(box TyAlias { generics, where_clauses, bounds, ty, .. }) => {\n                 let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, where_clauses, false);\n+                add_ty_alias_where_clause(&mut generics, *where_clauses, false);\n                 let (generics, kind) = self.lower_generics(\n                     &generics,\n                     i.id,\n@@ -1354,7 +1333,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and\n         // where clauses for `?Sized`.\n         for pred in &generics.where_clause.predicates {\n-            let WherePredicate::BoundPredicate(ref bound_pred) = *pred else {\n+            let WherePredicate::BoundPredicate(bound_pred) = pred else {\n                 continue;\n             };\n             let compute_is_param = || {\n@@ -1515,11 +1494,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {\n-        match *pred {\n+        match pred {\n             WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                ref bound_generic_params,\n-                ref bounded_ty,\n-                ref bounds,\n+                bound_generic_params,\n+                bounded_ty,\n+                bounds,\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                 hir_id: self.next_id(),\n@@ -1532,29 +1511,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                     )\n                 })),\n-                span: self.lower_span(span),\n+                span: self.lower_span(*span),\n                 origin: PredicateOrigin::WhereClause,\n             }),\n-            WherePredicate::RegionPredicate(WhereRegionPredicate {\n-                ref lifetime,\n-                ref bounds,\n-                span,\n-            }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span: self.lower_span(span),\n-                lifetime: self.lower_lifetime(lifetime),\n-                bounds: self.lower_param_bounds(\n-                    bounds,\n-                    &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n-                ),\n-                in_where_clause: true,\n-            }),\n-            WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, span }) => {\n+            WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, span }) => {\n+                hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                    span: self.lower_span(*span),\n+                    lifetime: self.lower_lifetime(lifetime),\n+                    bounds: self.lower_param_bounds(\n+                        bounds,\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                    ),\n+                    in_where_clause: true,\n+                })\n+            }\n+            WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     lhs_ty: self\n                         .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                     rhs_ty: self\n                         .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n-                    span: self.lower_span(span),\n+                    span: self.lower_span(*span),\n                 })\n             }\n         }"}, {"sha": "578b5417c86ec137ecae29ad02acaaf3a2dc613d", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 58, "deletions": 60, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=b97ec3924dc5a3718af8b2936fd6cc356e785832", "patch": "@@ -932,13 +932,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_attr_args(&self, args: &AttrArgs) -> AttrArgs {\n-        match *args {\n+        match args {\n             AttrArgs::Empty => AttrArgs::Empty,\n-            AttrArgs::Delimited(ref args) => AttrArgs::Delimited(self.lower_delim_args(args)),\n+            AttrArgs::Delimited(args) => AttrArgs::Delimited(self.lower_delim_args(args)),\n             // This is an inert key-value attribute - it will never be visible to macros\n             // after it gets lowered to HIR. Therefore, we can extract literals to handle\n             // nonterminals in `#[doc]` (e.g. `#[doc = $e]`).\n-            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(ref expr)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n                 let lit = if let ExprKind::Lit(token_lit) = expr.kind {\n@@ -957,9 +957,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         span: DUMMY_SP,\n                     }\n                 };\n-                AttrArgs::Eq(eq_span, AttrArgsEq::Hir(lit))\n+                AttrArgs::Eq(*eq_span, AttrArgsEq::Hir(lit))\n             }\n-            AttrArgs::Eq(_, AttrArgsEq::Hir(ref lit)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when lowering mac args eq: {:?}\", lit)\n             }\n         }\n@@ -987,12 +987,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n         // lower generic arguments of identifier in constraint\n-        let gen_args = if let Some(ref gen_args) = constraint.gen_args {\n+        let gen_args = if let Some(gen_args) = &constraint.gen_args {\n             let gen_args_ctor = match gen_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n+                GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, ParamMode::Explicit, itctx).0\n                 }\n-                GenericArgs::Parenthesized(ref data) => {\n+                GenericArgs::Parenthesized(data) => {\n                     self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n                     let aba = self.ast_arena.aba.alloc(data.as_angle_bracketed_args());\n                     self.lower_angle_bracketed_parameter_data(aba, ParamMode::Explicit, itctx).0\n@@ -1004,15 +1004,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n         let itctx_tait = &ImplTraitContext::TypeAliasesOpaqueTy;\n \n-        let kind = match constraint.kind {\n-            AssocConstraintKind::Equality { ref term } => {\n+        let kind = match &constraint.kind {\n+            AssocConstraintKind::Equality { term } => {\n                 let term = match term {\n-                    Term::Ty(ref ty) => self.lower_ty(ty, itctx).into(),\n-                    Term::Const(ref c) => self.lower_anon_const(c).into(),\n+                    Term::Ty(ty) => self.lower_ty(ty, itctx).into(),\n+                    Term::Const(c) => self.lower_anon_const(c).into(),\n                 };\n                 hir::TypeBindingKind::Equality { term }\n             }\n-            AssocConstraintKind::Bound { ref bounds } => {\n+            AssocConstraintKind::Bound { bounds } => {\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1122,7 +1122,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => {\n-                match ty.kind {\n+                match &ty.kind {\n                     TyKind::Infer if self.tcx.features().generic_arg_infer => {\n                         return GenericArg::Infer(hir::InferArg {\n                             hir_id: self.lower_node_id(ty.id),\n@@ -1133,7 +1133,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // parsing. We try to resolve that ambiguity by attempting resolution in both the\n                     // type and value namespaces. If we resolved the path in the value namespace, we\n                     // transform it into a generic const argument.\n-                    TyKind::Path(ref qself, ref path) => {\n+                    TyKind::Path(qself, path) => {\n                         if let Some(res) = self\n                             .resolver\n                             .get_partial_res(ty.id)\n@@ -1240,12 +1240,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_ty_direct(&mut self, t: &Ty, itctx: &ImplTraitContext) -> hir::Ty<'hir> {\n-        let kind = match t.kind {\n+        let kind = match &t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n-            TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n-            TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n-            TyKind::Rptr(ref region, ref mt) => {\n+            TyKind::Slice(ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n+            TyKind::Ptr(mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n+            TyKind::Rptr(region, mt) => {\n                 let region = region.unwrap_or_else(|| {\n                     let id = if let Some(LifetimeRes::ElidedAnchor { start, end }) =\n                         self.resolver.get_lifetime_res(t.id)\n@@ -1261,7 +1261,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let lifetime = self.lower_lifetime(&region);\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n-            TyKind::BareFn(ref f) => {\n+            TyKind::BareFn(f) => {\n                 let generic_params = self.lower_lifetime_binder(t.id, &f.generic_params);\n                 hir::TyKind::BareFn(self.arena.alloc(hir::BareFnTy {\n                     generic_params,\n@@ -1272,13 +1272,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }))\n             }\n             TyKind::Never => hir::TyKind::Never,\n-            TyKind::Tup(ref tys) => hir::TyKind::Tup(\n+            TyKind::Tup(tys) => hir::TyKind::Tup(\n                 self.arena.alloc_from_iter(tys.iter().map(|ty| self.lower_ty_direct(ty, itctx))),\n             ),\n-            TyKind::Paren(ref ty) => {\n+            TyKind::Paren(ty) => {\n                 return self.lower_ty_direct(ty, itctx);\n             }\n-            TyKind::Path(ref qself, ref path) => {\n+            TyKind::Path(qself, path) => {\n                 return self.lower_path_ty(t, qself, path, ParamMode::Explicit, itctx);\n             }\n             TyKind::ImplicitSelf => {\n@@ -1298,70 +1298,68 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }),\n                 ))\n             }\n-            TyKind::Array(ref ty, ref length) => {\n+            TyKind::Array(ty, length) => {\n                 hir::TyKind::Array(self.lower_ty(ty, itctx), self.lower_array_length(length))\n             }\n-            TyKind::Typeof(ref expr) => hir::TyKind::Typeof(self.lower_anon_const(expr)),\n-            TyKind::TraitObject(ref bounds, kind) => {\n+            TyKind::Typeof(expr) => hir::TyKind::Typeof(self.lower_anon_const(expr)),\n+            TyKind::TraitObject(bounds, kind) => {\n                 let mut lifetime_bound = None;\n                 let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n                     let bounds =\n-                        this.arena.alloc_from_iter(bounds.iter().filter_map(\n-                            |bound| match *bound {\n-                                GenericBound::Trait(\n-                                    ref ty,\n-                                    TraitBoundModifier::None | TraitBoundModifier::MaybeConst,\n-                                ) => Some(this.lower_poly_trait_ref(ty, itctx)),\n-                                // `~const ?Bound` will cause an error during AST validation\n-                                // anyways, so treat it like `?Bound` as compilation proceeds.\n-                                GenericBound::Trait(\n-                                    _,\n-                                    TraitBoundModifier::Maybe | TraitBoundModifier::MaybeConstMaybe,\n-                                ) => None,\n-                                GenericBound::Outlives(ref lifetime) => {\n-                                    if lifetime_bound.is_none() {\n-                                        lifetime_bound = Some(this.lower_lifetime(lifetime));\n-                                    }\n-                                    None\n+                        this.arena.alloc_from_iter(bounds.iter().filter_map(|bound| match bound {\n+                            GenericBound::Trait(\n+                                ty,\n+                                TraitBoundModifier::None | TraitBoundModifier::MaybeConst,\n+                            ) => Some(this.lower_poly_trait_ref(ty, itctx)),\n+                            // `~const ?Bound` will cause an error during AST validation\n+                            // anyways, so treat it like `?Bound` as compilation proceeds.\n+                            GenericBound::Trait(\n+                                _,\n+                                TraitBoundModifier::Maybe | TraitBoundModifier::MaybeConstMaybe,\n+                            ) => None,\n+                            GenericBound::Outlives(lifetime) => {\n+                                if lifetime_bound.is_none() {\n+                                    lifetime_bound = Some(this.lower_lifetime(lifetime));\n                                 }\n-                            },\n-                        ));\n+                                None\n+                            }\n+                        }));\n                     let lifetime_bound =\n                         lifetime_bound.unwrap_or_else(|| this.elided_dyn_bound(t.span));\n                     (bounds, lifetime_bound)\n                 });\n-                hir::TyKind::TraitObject(bounds, lifetime_bound, kind)\n+                hir::TyKind::TraitObject(bounds, lifetime_bound, *kind)\n             }\n-            TyKind::ImplTrait(def_node_id, ref bounds) => {\n+            TyKind::ImplTrait(def_node_id, bounds) => {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::ReturnPositionOpaqueTy { origin, in_trait } => self\n                         .lower_opaque_impl_trait(\n                             span,\n                             *origin,\n-                            def_node_id,\n+                            *def_node_id,\n                             bounds,\n                             *in_trait,\n                             itctx,\n                         ),\n                     ImplTraitContext::TypeAliasesOpaqueTy => self.lower_opaque_impl_trait(\n                         span,\n                         hir::OpaqueTyOrigin::TyAlias,\n-                        def_node_id,\n+                        *def_node_id,\n                         bounds,\n                         false,\n                         itctx,\n                     ),\n                     ImplTraitContext::Universal => {\n                         self.create_def(\n                             self.current_hir_id_owner.def_id,\n-                            def_node_id,\n+                            *def_node_id,\n                             DefPathData::ImplTrait,\n                         );\n                         let span = t.span;\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         let (param, bounds, path) =\n-                            self.lower_generic_and_bounds(def_node_id, span, ident, bounds);\n+                            self.lower_generic_and_bounds(*def_node_id, span, ident, bounds);\n                         self.impl_trait_defs.push(param);\n                         if let Some(bounds) = bounds {\n                             self.impl_trait_bounds.push(bounds);\n@@ -1740,8 +1738,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 matches!(kind, FnDeclKind::Trait),\n             )\n         } else {\n-            match decl.output {\n-                FnRetTy::Ty(ref ty) => {\n+            match &decl.output {\n+                FnRetTy::Ty(ty) => {\n                     let mut context = match fn_node_id {\n                         Some(fn_node_id) if kind.impl_trait_allowed(self.tcx) => {\n                             let fn_def_id = self.local_def_id(fn_node_id);\n@@ -1763,7 +1761,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     };\n                     hir::FnRetTy::Return(self.lower_ty(ty, &mut context))\n                 }\n-                FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n+                FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(*span)),\n             }\n         };\n \n@@ -1777,18 +1775,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     PatKind::Ident(hir::BindingAnnotation(_, Mutability::Mut), ..)\n                 );\n \n-                match arg.ty.kind {\n+                match &arg.ty.kind {\n                     TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,\n                     TyKind::ImplicitSelf => hir::ImplicitSelfKind::Imm,\n                     // Given we are only considering `ImplicitSelf` types, we needn't consider\n                     // the case where we have a mutable pattern to a reference as that would\n                     // no longer be an `ImplicitSelf`.\n-                    TyKind::Rptr(_, ref mt)\n+                    TyKind::Rptr(_, mt)\n                         if mt.ty.kind.is_implicit_self() && mt.mutbl == ast::Mutability::Mut =>\n                     {\n                         hir::ImplicitSelfKind::MutRef\n                     }\n-                    TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() => {\n+                    TyKind::Rptr(_, mt) if mt.ty.kind.is_implicit_self() => {\n                         hir::ImplicitSelfKind::ImmRef\n                     }\n                     _ => hir::ImplicitSelfKind::None,\n@@ -2179,7 +2177,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         param: &GenericParam,\n     ) -> (hir::ParamName, hir::GenericParamKind<'hir>) {\n-        match param.kind {\n+        match &param.kind {\n             GenericParamKind::Lifetime => {\n                 // AST resolution emitted an error on those parameters, so we lower them using\n                 // `ParamName::Error`.\n@@ -2195,7 +2193,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 (param_name, kind)\n             }\n-            GenericParamKind::Type { ref default, .. } => {\n+            GenericParamKind::Type { default, .. } => {\n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n                         self.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n@@ -2205,7 +2203,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 (hir::ParamName::Plain(self.lower_ident(param.ident)), kind)\n             }\n-            GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n+            GenericParamKind::Const { ty, kw_span: _, default } => {\n                 let ty = self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n                 ("}, {"sha": "16b012630da0e90d847c0961c019666420536230", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=b97ec3924dc5a3718af8b2936fd6cc356e785832", "patch": "@@ -22,16 +22,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ensure_sufficient_stack(|| {\n             // loop here to avoid recursion\n             let node = loop {\n-                match pattern.kind {\n+                match &pattern.kind {\n                     PatKind::Wild => break hir::PatKind::Wild,\n-                    PatKind::Ident(binding_mode, ident, ref sub) => {\n-                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                        break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n+                    PatKind::Ident(binding_mode, ident, sub) => {\n+                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(s));\n+                        break self.lower_pat_ident(pattern, *binding_mode, *ident, lower_sub);\n                     }\n-                    PatKind::Lit(ref e) => {\n+                    PatKind::Lit(e) => {\n                         break hir::PatKind::Lit(self.lower_expr_within_pat(e, false));\n                     }\n-                    PatKind::TupleStruct(ref qself, ref path, ref pats) => {\n+                    PatKind::TupleStruct(qself, path, pats) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -42,12 +42,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n                         break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n                     }\n-                    PatKind::Or(ref pats) => {\n+                    PatKind::Or(pats) => {\n                         break hir::PatKind::Or(\n                             self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat_mut(x))),\n                         );\n                     }\n-                    PatKind::Path(ref qself, ref path) => {\n+                    PatKind::Path(qself, path) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -57,7 +57,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         );\n                         break hir::PatKind::Path(qpath);\n                     }\n-                    PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n+                    PatKind::Struct(qself, path, fields, etc) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -78,32 +78,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 span: self.lower_span(f.span),\n                             }\n                         }));\n-                        break hir::PatKind::Struct(qpath, fs, etc);\n+                        break hir::PatKind::Struct(qpath, fs, *etc);\n                     }\n-                    PatKind::Tuple(ref pats) => {\n+                    PatKind::Tuple(pats) => {\n                         let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n                         break hir::PatKind::Tuple(pats, ddpos);\n                     }\n-                    PatKind::Box(ref inner) => {\n+                    PatKind::Box(inner) => {\n                         break hir::PatKind::Box(self.lower_pat(inner));\n                     }\n-                    PatKind::Ref(ref inner, mutbl) => {\n-                        break hir::PatKind::Ref(self.lower_pat(inner), mutbl);\n+                    PatKind::Ref(inner, mutbl) => {\n+                        break hir::PatKind::Ref(self.lower_pat(inner), *mutbl);\n                     }\n-                    PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                    PatKind::Range(e1, e2, Spanned { node: end, .. }) => {\n                         break hir::PatKind::Range(\n                             e1.as_deref().map(|e| self.lower_expr_within_pat(e, true)),\n                             e2.as_deref().map(|e| self.lower_expr_within_pat(e, true)),\n                             self.lower_range_end(end, e2.is_some()),\n                         );\n                     }\n-                    PatKind::Slice(ref pats) => break self.lower_pat_slice(pats),\n+                    PatKind::Slice(pats) => break self.lower_pat_slice(pats),\n                     PatKind::Rest => {\n                         // If we reach here the `..` pattern is not semantically allowed.\n                         break self.ban_illegal_rest_pat(pattern.span);\n                     }\n                     // return inner to be processed in next loop\n-                    PatKind::Paren(ref inner) => pattern = inner,\n+                    PatKind::Paren(inner) => pattern = inner,\n                     PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", pattern.span),\n                 }\n             };\n@@ -126,20 +126,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // Note that unlike for slice patterns,\n             // where `xs @ ..` is a legal sub-slice pattern,\n             // it is not a legal sub-tuple pattern.\n-            match pat.kind {\n+            match &pat.kind {\n                 // Found a sub-tuple rest pattern\n                 PatKind::Rest => {\n                     rest = Some((idx, pat.span));\n                     break;\n                 }\n                 // Found a sub-tuple pattern `$binding_mode $ident @ ..`.\n                 // This is not allowed as a sub-tuple pattern\n-                PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(_, ident, Some(sub)) if sub.is_rest() => {\n                     let sp = pat.span;\n                     self.tcx.sess.emit_err(SubTupleBinding {\n                         span: sp,\n                         ident_name: ident.name,\n-                        ident,\n+                        ident: *ident,\n                         ctx,\n                     });\n                 }\n@@ -176,7 +176,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut prev_rest_span = None;\n \n         // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n-        let lower_rest_sub = |this: &mut Self, pat, ann, ident, sub| {\n+        let lower_rest_sub = |this: &mut Self, pat, &ann, &ident, sub| {\n             let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n             let node = this.lower_pat_ident(pat, ann, ident, lower_sub);\n             this.pat_with_node_id_of(pat, node)\n@@ -185,7 +185,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut iter = pats.iter();\n         // Lower all the patterns until the first occurrence of a sub-slice pattern.\n         for pat in iter.by_ref() {\n-            match pat.kind {\n+            match &pat.kind {\n                 // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n                 PatKind::Rest => {\n                     prev_rest_span = Some(pat.span);\n@@ -194,7 +194,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(sub)) if sub.is_rest() => {\n                     prev_rest_span = Some(sub.span);\n                     slice = Some(self.arena.alloc(lower_rest_sub(self, pat, ann, ident, sub)));\n                     break;\n@@ -207,9 +207,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Lower all the patterns after the first sub-slice pattern.\n         for pat in iter {\n             // There was a previous subslice pattern; make sure we don't allow more.\n-            let rest_span = match pat.kind {\n+            let rest_span = match &pat.kind {\n                 PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(sub)) if sub.is_rest() => {\n                     // #69103: Lower into `binding @ _` as above to avoid ICEs.\n                     after.push(lower_rest_sub(self, pat, ann, ident, sub));\n                     Some(sub.span)\n@@ -322,13 +322,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // m!(S);\n     // ```\n     fn lower_expr_within_pat(&mut self, expr: &Expr, allow_paths: bool) -> &'hir hir::Expr<'hir> {\n-        match expr.kind {\n+        match &expr.kind {\n             ExprKind::Lit(..)\n             | ExprKind::ConstBlock(..)\n             | ExprKind::IncludedBytes(..)\n             | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n-            ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n+            ExprKind::Unary(UnOp::Neg, inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n                 self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n                 return self.arena.alloc(self.expr_err(expr.span));"}, {"sha": "27b44c0b6a2b275eb6cd39324cff17e3077ff4fb", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97ec3924dc5a3718af8b2936fd6cc356e785832/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=b97ec3924dc5a3718af8b2936fd6cc356e785832", "patch": "@@ -185,12 +185,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         itctx: &ImplTraitContext,\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n-        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            match **generic_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n+        let (mut generic_args, infer_args) = if let Some(generic_args) = segment.args.as_deref() {\n+            match generic_args {\n+                GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n-                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n+                GenericArgs::Parenthesized(data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => {\n                         self.lower_parenthesized_parameter_data(data, itctx)\n                     }"}]}