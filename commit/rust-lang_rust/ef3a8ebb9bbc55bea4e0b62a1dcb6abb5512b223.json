{"sha": "ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmM2E4ZWJiOWJiYzU1YmVhNGUwYjYyYTFkY2I2YWJiNTUxMmIyMjM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-15T15:09:55Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-15T23:57:47Z"}, "message": "librustdoc: move tests into dedicated tests module.", "tree": {"sha": "a99b2fd9c237b0af086a688b88e7e63412410d61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a99b2fd9c237b0af086a688b88e7e63412410d61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "html_url": "https://github.com/rust-lang/rust/commit/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "html_url": "https://github.com/rust-lang/rust/commit/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47"}], "stats": {"total": 3243, "additions": 1624, "deletions": 1619}, "files": [{"sha": "efd061209a50331a0163f842c7f7f27daffe8daf", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 88, "deletions": 89, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -25,26 +25,6 @@ pub struct CrateAttrs {\n     name: Option<~str>\n }\n \n-#[cfg(test)]\n-mod test {\n-    use syntax::ast;\n-    use syntax;\n-\n-    use core::option::None;\n-\n-    pub fn parse_attributes(source: ~str) -> ~[ast::attribute] {\n-        use syntax::parse;\n-        use syntax::parse::attr::parser_attr;\n-        use syntax::codemap;\n-\n-        let parse_sess = syntax::parse::new_parse_sess(None);\n-        let parser = parse::new_parser_from_source_str(\n-            parse_sess, ~[], ~\"-\", codemap::FssNone, @source);\n-\n-        parser.parse_outer_attributes()\n-    }\n-}\n-\n fn doc_metas(\n     attrs: ~[ast::attribute]\n ) -> ~[@ast::meta_item] {\n@@ -66,30 +46,6 @@ pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n     }\n }\n \n-#[test]\n-fn should_extract_crate_name_from_link_attribute() {\n-    let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_crate(attrs);\n-    assert!(attrs.name == Some(~\"snuggles\"));\n-}\n-\n-#[test]\n-fn should_not_extract_crate_name_if_no_link_attribute() {\n-    let source = ~\"\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_crate(attrs);\n-    assert!(attrs.name == None);\n-}\n-\n-#[test]\n-fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n-    let source = ~\"#[link(whatever)]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_crate(attrs);\n-    assert!(attrs.name == None);\n-}\n-\n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n         attr::get_meta_item_value_str(*meta).map(|s| copy **s)\n@@ -101,60 +57,103 @@ pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     }\n }\n \n-#[test]\n-fn parse_desc_should_handle_undocumented_mods() {\n-    let source = ~\"\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_desc(attrs);\n-    assert!(attrs == None);\n-}\n-\n-#[test]\n-fn parse_desc_should_parse_simple_doc_attributes() {\n-    let source = ~\"#[doc = \\\"basic\\\"]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_desc(attrs);\n-    assert!(attrs == Some(~\"basic\"));\n-}\n-\n pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n     do doc_metas(attrs).find |meta| {\n         match attr::get_meta_item_list(*meta) {\n-          Some(metas) => {\n-            let hiddens = attr::find_meta_items_by_name(metas, ~\"hidden\");\n-            !hiddens.is_empty()\n-          }\n-          None => false\n+            Some(metas) => {\n+                let hiddens = attr::find_meta_items_by_name(metas, ~\"hidden\");\n+                !hiddens.is_empty()\n+            }\n+            None => false\n         }\n     }.is_some()\n }\n \n-#[test]\n-fn should_parse_hidden_attribute() {\n-    let source = ~\"#[doc(hidden)]\";\n-    let attrs = test::parse_attributes(source);\n-    assert!(parse_hidden(attrs) == true);\n-}\n+#[cfg(test)]\n+mod test {\n+    use syntax::ast;\n+    use syntax;\n+    use super::{parse_hidden, parse_crate, parse_desc};\n+    use core::prelude::*;\n \n-#[test]\n-fn should_parse_hidden_attribute_with_other_docs() {\n-    let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n-    let attrs = test::parse_attributes(source);\n-    assert!(parse_hidden(attrs) == true);\n-}\n+    fn parse_attributes(source: ~str) -> ~[ast::attribute] {\n+        use syntax::parse;\n+        use syntax::parse::attr::parser_attr;\n+        use syntax::codemap;\n \n-#[test]\n-fn should_not_parse_non_hidden_attribute() {\n-    let source = ~\"#[doc = \\\"\\\"]\";\n-    let attrs = test::parse_attributes(source);\n-    assert!(parse_hidden(attrs) == false);\n-}\n+        let parse_sess = syntax::parse::new_parse_sess(None);\n+        let parser = parse::new_parser_from_source_str(\n+            parse_sess, ~[], ~\"-\", codemap::FssNone, @source);\n+\n+        parser.parse_outer_attributes()\n+    }\n \n-#[test]\n-fn should_concatenate_multiple_doc_comments() {\n-    let source = ~\"/// foo\\n/// bar\";\n-    let desc = parse_desc(test::parse_attributes(source));\n-    assert!(desc == Some(~\"foo\\nbar\"));\n-}\n \n+    #[test]\n+    fn should_extract_crate_name_from_link_attribute() {\n+        let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_crate(attrs);\n+        assert!(attrs.name == Some(~\"snuggles\"));\n+    }\n \n+    #[test]\n+    fn should_not_extract_crate_name_if_no_link_attribute() {\n+        let source = ~\"\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_crate(attrs);\n+        assert!(attrs.name == None);\n+    }\n+\n+    #[test]\n+    fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n+        let source = ~\"#[link(whatever)]\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_crate(attrs);\n+        assert!(attrs.name == None);\n+    }\n+\n+    #[test]\n+    fn parse_desc_should_handle_undocumented_mods() {\n+        let source = ~\"\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_desc(attrs);\n+        assert!(attrs == None);\n+    }\n+\n+    #[test]\n+    fn parse_desc_should_parse_simple_doc_attributes() {\n+        let source = ~\"#[doc = \\\"basic\\\"]\";\n+        let attrs = parse_attributes(source);\n+        let attrs = parse_desc(attrs);\n+        assert!(attrs == Some(~\"basic\"));\n+    }\n+\n+    #[test]\n+    fn should_parse_hidden_attribute() {\n+        let source = ~\"#[doc(hidden)]\";\n+        let attrs = parse_attributes(source);\n+        assert!(parse_hidden(attrs) == true);\n+    }\n+\n+    #[test]\n+    fn should_parse_hidden_attribute_with_other_docs() {\n+        let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n+        let attrs = parse_attributes(source);\n+        assert!(parse_hidden(attrs) == true);\n+    }\n+\n+    #[test]\n+    fn should_not_parse_non_hidden_attribute() {\n+        let source = ~\"#[doc = \\\"\\\"]\";\n+        let attrs = parse_attributes(source);\n+        assert!(parse_hidden(attrs) == false);\n+    }\n+\n+    #[test]\n+    fn should_concatenate_multiple_doc_comments() {\n+        let source = ~\"/// foo\\n/// bar\";\n+        let desc = parse_desc(parse_attributes(source));\n+        assert!(desc == Some(~\"foo\\nbar\"));\n+    }\n+}"}, {"sha": "a666bff18c97c7a494b3314888485d81de4fd595", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 107, "deletions": 106, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -78,12 +78,6 @@ fn fold_crate(\n     }\n }\n \n-#[test]\n-fn should_replace_top_module_name_with_crate_name() {\n-    let doc = test::mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n-    assert!(doc.cratemod().name() == ~\"bond\");\n-}\n-\n fn fold_item(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::ItemDoc\n@@ -113,38 +107,14 @@ fn parse_item_attrs<T:Owned>(\n     parse_attrs: ~fn(a: ~[ast::attribute]) -> T) -> T {\n     do astsrv::exec(srv) |ctxt| {\n         let attrs = match *ctxt.ast_map.get(&id) {\n-          ast_map::node_item(item, _) => copy item.attrs,\n-          ast_map::node_foreign_item(item, _, _, _) => copy item.attrs,\n-          _ => fail!(~\"parse_item_attrs: not an item\")\n+            ast_map::node_item(item, _) => copy item.attrs,\n+            ast_map::node_foreign_item(item, _, _, _) => copy item.attrs,\n+            _ => fail!(~\"parse_item_attrs: not an item\")\n         };\n         parse_attrs(attrs)\n     }\n }\n \n-#[test]\n-fn should_should_extract_mod_attributes() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert!(doc.cratemod().mods()[0].desc() == Some(~\"test\"));\n-}\n-\n-#[test]\n-fn should_extract_top_mod_attributes() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"test\\\"];\");\n-    assert!(doc.cratemod().desc() == Some(~\"test\"));\n-}\n-\n-#[test]\n-fn should_extract_foreign_fn_attributes() {\n-    let doc = test::mk_doc(~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n-}\n-\n-#[test]\n-fn should_extract_fn_attributes() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n-    assert!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n-}\n-\n fn fold_enum(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::EnumDoc\n@@ -174,8 +144,8 @@ fn fold_enum(\n                         }\n                         _ => {\n                             fail!(fmt!(\"Enum variant %s has id that's \\\n-                                       not bound to an enum item\",\n-                                      variant.name))\n+                                        not bound to an enum item\",\n+                                       variant.name))\n                         }\n                     }\n                 }\n@@ -190,19 +160,6 @@ fn fold_enum(\n     }\n }\n \n-#[test]\n-fn should_extract_enum_docs() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"b\\\"]\\\n-                            enum a { v }\");\n-    assert!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n-}\n-\n-#[test]\n-fn should_extract_variant_docs() {\n-    let doc = test::mk_doc(~\"enum a { #[doc = \\\"c\\\"] v }\");\n-    assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n-}\n-\n fn fold_trait(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::TraitDoc\n@@ -225,30 +182,30 @@ fn merge_method_attrs(\n     // Create an assoc list from method name to attributes\n     let attrs: ~[(~str, Option<~str>)] = do astsrv::exec(srv) |ctxt| {\n         match *ctxt.ast_map.get(&item_id) {\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_trait(_, _, ref methods), _\n-          }, _) => {\n-            vec::map(*methods, |method| {\n-                match copy *method {\n-                  ast::required(ty_m) => {\n-                    (to_str(ty_m.ident),\n-                     attr_parser::parse_desc(copy ty_m.attrs))\n-                  }\n-                  ast::provided(m) => {\n-                    (to_str(m.ident), attr_parser::parse_desc(copy m.attrs))\n-                  }\n-                }\n-            })\n-          }\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_impl(_, _, _, ref methods), _\n-          }, _) => {\n-            vec::map(*methods, |method| {\n-                (to_str(method.ident),\n-                 attr_parser::parse_desc(copy method.attrs))\n-            })\n-          }\n-          _ => fail!(~\"unexpected item\")\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_trait(_, _, ref methods), _\n+            }, _) => {\n+                vec::map(*methods, |method| {\n+                    match copy *method {\n+                        ast::required(ty_m) => {\n+                            (to_str(ty_m.ident),\n+                             attr_parser::parse_desc(copy ty_m.attrs))\n+                        }\n+                        ast::provided(m) => {\n+                            (to_str(m.ident), attr_parser::parse_desc(copy m.attrs))\n+                        }\n+                    }\n+                })\n+            }\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_impl(_, _, _, ref methods), _\n+            }, _) => {\n+                vec::map(*methods, |method| {\n+                    (to_str(method.ident),\n+                     attr_parser::parse_desc(copy method.attrs))\n+                })\n+            }\n+            _ => fail!(~\"unexpected item\")\n         }\n     };\n \n@@ -263,22 +220,6 @@ fn merge_method_attrs(\n     }\n }\n \n-#[test]\n-fn should_extract_trait_docs() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"whatever\\\"] trait i { fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n-}\n-\n-#[test]\n-fn should_extract_trait_method_docs() {\n-    let doc = test::mk_doc(\n-        ~\"trait i {\\\n-         #[doc = \\\"desc\\\"]\\\n-         fn f(a: bool) -> bool;\\\n-         }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n-}\n-\n \n fn fold_impl(\n     fold: &fold::Fold<astsrv::Srv>,\n@@ -293,34 +234,94 @@ fn fold_impl(\n     }\n }\n \n-#[test]\n-fn should_extract_impl_docs() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"whatever\\\"] impl int { fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n-}\n-\n-#[test]\n-fn should_extract_impl_method_docs() {\n-    let doc = test::mk_doc(\n-        ~\"impl int {\\\n-         #[doc = \\\"desc\\\"]\\\n-         fn f(a: bool) -> bool { }\\\n-         }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n     use attr_pass::run;\n     use doc;\n     use extract;\n+    use core::prelude::*;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_replace_top_module_name_with_crate_name() {\n+        let doc = mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n+        assert!(doc.cratemod().name() == ~\"bond\");\n+    }\n+\n+    #[test]\n+    fn should_should_extract_mod_attributes() {\n+        let doc = mk_doc(~\"#[doc = \\\"test\\\"] mod a { }\");\n+        assert!(doc.cratemod().mods()[0].desc() == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_top_mod_attributes() {\n+        let doc = mk_doc(~\"#[doc = \\\"test\\\"];\");\n+        assert!(doc.cratemod().desc() == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_foreign_fn_attributes() {\n+        let doc = mk_doc(~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n+        assert!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_fn_attributes() {\n+        let doc = mk_doc(~\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n+        assert!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_enum_docs() {\n+        let doc = mk_doc(~\"#[doc = \\\"b\\\"]\\\n+                                 enum a { v }\");\n+        assert!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_variant_docs() {\n+        let doc = mk_doc(~\"enum a { #[doc = \\\"c\\\"] v }\");\n+        assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_trait_docs() {\n+        let doc = mk_doc(~\"#[doc = \\\"whatever\\\"] trait i { fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_trait_method_docs() {\n+        let doc = mk_doc(\n+            ~\"trait i {\\\n+              #[doc = \\\"desc\\\"]\\\n+              fn f(a: bool) -> bool;\\\n+              }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_impl_docs() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"whatever\\\"] impl int { fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n+    }\n+\n+    #[test]\n+    fn should_extract_impl_method_docs() {\n+        let doc = mk_doc(\n+            ~\"impl int {\\\n+              #[doc = \\\"desc\\\"]\\\n+              fn f(a: bool) -> bool { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n+    }\n }"}, {"sha": "ed1a54c49a731ab07f5f0e2afa41d40e37ab92c7", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 119, "deletions": 119, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -209,7 +209,7 @@ fn parse_output_style(output_style: &str) -> Result<OutputStyle, ~str> {\n     }\n }\n \n-fn maybe_find_pandoc(\n+pub fn maybe_find_pandoc(\n     config: &Config,\n     maybe_pandoc_cmd: Option<~str>,\n     program_output: Process\n@@ -243,140 +243,140 @@ fn maybe_find_pandoc(\n     }\n }\n \n-#[test]\n-fn should_find_pandoc() {\n-    let config = Config {\n-        output_format: PandocHtml,\n-        .. default_config(&Path(\"test\"))\n-    };\n-    let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n-        ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n-    };\n-    let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    assert!(result == result::Ok(Some(~\"pandoc\")));\n-}\n-\n-#[test]\n-fn should_error_with_no_pandoc() {\n-    let config = Config {\n-        output_format: PandocHtml,\n-        .. default_config(&Path(\"test\"))\n-    };\n-    let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n-        ProgramOutput { status: 1, out: ~\"\", err: ~\"\" }\n-    };\n-    let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    assert!(result == result::Err(~\"couldn't find pandoc\"));\n-}\n-\n #[cfg(test)]\n mod test {\n-    use config::{Config, mock_program_output, parse_config_};\n-\n-    use core::result::Result;\n+    use config::*;\n+    use core::prelude::*;\n+    use core::run::ProgramOutput;\n \n-    pub fn parse_config(args: &[~str]) -> Result<Config, ~str> {\n+    fn parse_config(args: &[~str]) -> Result<Config, ~str> {\n         parse_config_(args, mock_program_output)\n     }\n-}\n \n-#[test]\n-fn should_error_with_no_crates() {\n-    let config = test::parse_config(~[~\"rustdoc\"]);\n-    assert!(config.get_err() == ~\"no crates specified\");\n-}\n+    #[test]\n+    fn should_find_pandoc() {\n+        let config = Config {\n+            output_format: PandocHtml,\n+            .. default_config(&Path(\"test\"))\n+        };\n+        let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n+            ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n+        };\n+        let result = maybe_find_pandoc(&config, None, mock_program_output);\n+        assert!(result == result::Ok(Some(~\"pandoc\")));\n+    }\n \n-#[test]\n-fn should_error_with_multiple_crates() {\n-    let config =\n-        test::parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n-    assert!(config.get_err() == ~\"multiple crates specified\");\n-}\n+    #[test]\n+    fn should_error_with_no_pandoc() {\n+        let config = Config {\n+            output_format: PandocHtml,\n+            .. default_config(&Path(\"test\"))\n+        };\n+        let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n+            ProgramOutput { status: 1, out: ~\"\", err: ~\"\" }\n+        };\n+        let result = maybe_find_pandoc(&config, None, mock_program_output);\n+        assert!(result == result::Err(~\"couldn't find pandoc\"));\n+    }\n \n-#[test]\n-fn should_set_output_dir_to_cwd_if_not_provided() {\n-    let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert!(config.get().output_dir == Path(\".\"));\n-}\n+    #[test]\n+    fn should_error_with_no_crates() {\n+        let config = parse_config(~[~\"rustdoc\"]);\n+        assert!(config.get_err() == ~\"no crates specified\");\n+    }\n \n-#[test]\n-fn should_set_output_dir_if_provided() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n-    ]);\n-    assert!(config.get().output_dir == Path(\"snuggles\"));\n-}\n+    #[test]\n+    fn should_error_with_multiple_crates() {\n+        let config =\n+            parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n+        assert!(config.get_err() == ~\"multiple crates specified\");\n+    }\n \n-#[test]\n-fn should_set_output_format_to_pandoc_html_if_not_provided() {\n-    let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert!(config.get().output_format == PandocHtml);\n-}\n+    #[test]\n+    fn should_set_output_dir_to_cwd_if_not_provided() {\n+        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        assert!(config.get().output_dir == Path(\".\"));\n+    }\n \n-#[test]\n-fn should_set_output_format_to_markdown_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n-    ]);\n-    assert!(config.get().output_format == Markdown);\n-}\n+    #[test]\n+    fn should_set_output_dir_if_provided() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n+        ]);\n+        assert!(config.get().output_dir == Path(\"snuggles\"));\n+    }\n \n-#[test]\n-fn should_set_output_format_to_pandoc_html_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n-    ]);\n-    assert!(config.get().output_format == PandocHtml);\n-}\n+    #[test]\n+    fn should_set_output_format_to_pandoc_html_if_not_provided() {\n+        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        assert!(config.get().output_format == PandocHtml);\n+    }\n \n-#[test]\n-fn should_error_on_bogus_format() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n-    ]);\n-    assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n-}\n+    #[test]\n+    fn should_set_output_format_to_markdown_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n+        ]);\n+        assert!(config.get().output_format == Markdown);\n+    }\n \n-#[test]\n-fn should_set_output_style_to_doc_per_mod_by_default() {\n-    let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert!(config.get().output_style == DocPerMod);\n-}\n+    #[test]\n+    fn should_set_output_format_to_pandoc_html_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n+        ]);\n+        assert!(config.get().output_format == PandocHtml);\n+    }\n \n-#[test]\n-fn should_set_output_style_to_one_doc_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n-    ]);\n-    assert!(config.get().output_style == DocPerCrate);\n-}\n+    #[test]\n+    fn should_error_on_bogus_format() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n+        ]);\n+        assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n+    }\n \n-#[test]\n-fn should_set_output_style_to_doc_per_mod_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n-    ]);\n-    assert!(config.get().output_style == DocPerMod);\n-}\n+    #[test]\n+    fn should_set_output_style_to_doc_per_mod_by_default() {\n+        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        assert!(config.get().output_style == DocPerMod);\n+    }\n \n-#[test]\n-fn should_error_on_bogus_output_style() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n-    ]);\n-    assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n-}\n+    #[test]\n+    fn should_set_output_style_to_one_doc_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n+        ]);\n+        assert!(config.get().output_style == DocPerCrate);\n+    }\n \n-#[test]\n-fn should_set_pandoc_command_if_requested() {\n-    let config = test::parse_config(~[\n-        ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n-    ]);\n-    assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n-}\n+    #[test]\n+    fn should_set_output_style_to_doc_per_mod_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n+        ]);\n+        assert!(config.get().output_style == DocPerMod);\n+    }\n \n-#[test]\n-fn should_set_pandoc_command_when_using_pandoc() {\n-    let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n-}\n+    #[test]\n+    fn should_error_on_bogus_output_style() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n+        ]);\n+        assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n+    }\n+\n+    #[test]\n+    fn should_set_pandoc_command_if_requested() {\n+        let config = parse_config(~[\n+            ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n+        ]);\n+        assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n+    }\n+\n+    #[test]\n+    fn should_set_pandoc_command_when_using_pandoc() {\n+        let config = parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n+        assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "5027b24435599b279b684f8a2ed7ffbbe052700a", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 82, "deletions": 81, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -81,44 +81,7 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     }\n }\n \n-#[test]\n-fn should_promote_desc() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n-    assert!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n-}\n-\n-#[test]\n-fn should_promote_trait_method_desc() {\n-    let doc = test::mk_doc(~\"trait i { #[doc = \\\"desc\\\"] fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].brief ==\n-        Some(~\"desc\"));\n-}\n-\n-#[test]\n-fn should_promote_impl_method_desc() {\n-    let doc = test::mk_doc(\n-        ~\"impl int { #[doc = \\\"desc\\\"] fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n-}\n-\n-#[cfg(test)]\n-pub mod test {\n-    use astsrv;\n-    use attr_pass;\n-    use desc_to_brief_pass::run;\n-    use doc;\n-    use extract;\n-\n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            run(srv.clone(), doc)\n-        }\n-    }\n-}\n-\n-fn extract(desc: Option<~str>) -> Option<~str> {\n+pub fn extract(desc: Option<~str>) -> Option<~str> {\n     if desc.is_none() {\n         return None\n     }\n@@ -182,7 +145,7 @@ fn first_sentence_(s: &str) -> ~str {\n     }\n }\n \n-fn paragraphs(s: &str) -> ~[~str] {\n+pub fn paragraphs(s: &str) -> ~[~str] {\n     let mut lines = ~[];\n     for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n@@ -219,80 +182,118 @@ fn paragraphs(s: &str) -> ~[~str] {\n     }\n }\n \n-#[test]\n-fn test_paragraphs_1() {\n-    let paras = paragraphs(~\"1\\n\\n2\");\n-    assert!(paras == ~[~\"1\", ~\"2\"]);\n-}\n+#[cfg(test)]\n+mod test {\n+    use astsrv;\n+    use attr_pass;\n+    use super::{extract, paragraphs, run};\n+    use doc;\n+    use extract;\n+    use core::prelude::*;\n \n-#[test]\n-fn test_paragraphs_2() {\n-    let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n-    assert!(paras == ~[~\"1\\n1\", ~\"2\"]);\n-}\n+    fn mk_doc(source: ~str) -> doc::Doc {\n+        do astsrv::from_str(copy source) |srv| {\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            run(srv.clone(), doc)\n+        }\n+    }\n \n-#[test]\n-fn should_promote_short_descs() {\n-    let desc = Some(~\"desc\");\n-    let brief = extract(copy desc);\n-    assert!(brief == desc);\n-}\n+    #[test]\n+    fn should_promote_desc() {\n+        let doc = mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n+        assert!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_promote_trait_method_desc() {\n+        let doc = mk_doc(~\"trait i { #[doc = \\\"desc\\\"] fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].brief ==\n+                Some(~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_promote_impl_method_desc() {\n+        let doc = mk_doc(\n+            ~\"impl int { #[doc = \\\"desc\\\"] fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n+    }\n \n-#[test]\n-fn should_not_promote_long_descs() {\n-    let desc = Some(~\"Warkworth Castle is a ruined medieval building\n+    #[test]\n+    fn test_paragraphs_1() {\n+        let paras = paragraphs(~\"1\\n\\n2\");\n+        assert!(paras == ~[~\"1\", ~\"2\"]);\n+    }\n+\n+    #[test]\n+    fn test_paragraphs_2() {\n+        let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n+        assert!(paras == ~[~\"1\\n1\", ~\"2\"]);\n+    }\n+\n+    #[test]\n+    fn should_promote_short_descs() {\n+        let desc = Some(~\"desc\");\n+        let brief = extract(copy desc);\n+        assert!(brief == desc);\n+    }\n+\n+    #[test]\n+    fn should_not_promote_long_descs() {\n+        let desc = Some(~\"Warkworth Castle is a ruined medieval building\n in the town of the same name in the English county of Northumberland,\n and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let brief = extract(desc);\n-    assert!(brief == None);\n-}\n+        let brief = extract(desc);\n+        assert!(brief == None);\n+    }\n \n-#[test]\n-fn should_promote_first_sentence() {\n-    let desc = Some(~\"Warkworth Castle is a ruined medieval building\n+    #[test]\n+    fn should_promote_first_sentence() {\n+        let desc = Some(~\"Warkworth Castle is a ruined medieval building\n in the town. of the same name in the English county of Northumberland,\n and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let brief = extract(desc);\n-    assert!(brief == Some(\n-        ~\"Warkworth Castle is a ruined medieval building in the town\"));\n-}\n+        let brief = extract(desc);\n+        assert!(brief == Some(\n+            ~\"Warkworth Castle is a ruined medieval building in the town\"));\n+    }\n \n-#[test]\n-fn should_not_consider_double_period_to_end_sentence() {\n-    let desc = Some(~\"Warkworth..Castle is a ruined medieval building\n+    #[test]\n+    fn should_not_consider_double_period_to_end_sentence() {\n+        let desc = Some(~\"Warkworth..Castle is a ruined medieval building\n in the town. of the same name in the English county of Northumberland,\n and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let brief = extract(desc);\n-    assert!(brief == Some(\n-        ~\"Warkworth..Castle is a ruined medieval building in the town\"));\n-}\n+        let brief = extract(desc);\n+        assert!(brief == Some(\n+            ~\"Warkworth..Castle is a ruined medieval building in the town\"));\n+    }\n \n-#[test]\n-fn should_not_consider_triple_period_to_end_sentence() {\n-    let desc = Some(~\"Warkworth... Castle is a ruined medieval building\n+    #[test]\n+    fn should_not_consider_triple_period_to_end_sentence() {\n+        let desc = Some(~\"Warkworth... Castle is a ruined medieval building\n in the town. of the same name in the English county of Northumberland,\n and the town and castle occupy a loop of the River Coquet, less than a mile\n from England's north-east coast. When the castle was founded is uncertain,\n but traditionally its construction has been ascribed to Prince Henry of\n Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n-    let brief = extract(desc);\n-    assert!(brief == Some(\n-        ~\"Warkworth... Castle is a ruined medieval building in the town\"));\n+        let brief = extract(desc);\n+        assert!(brief == Some(\n+            ~\"Warkworth... Castle is a ruined medieval building in the town\"));\n+    }\n }"}, {"sha": "fa3f7d64324899f3875ebff0179190801adf2c5a", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -182,13 +182,6 @@ fn constdoc_from_const(itemdoc: doc::ItemDoc) -> doc::ConstDoc {\n     }\n }\n \n-#[test]\n-fn should_extract_const_name_and_id() {\n-    let doc = test::mk_doc(~\"static a: int = 0;\");\n-    assert!(doc.cratemod().consts()[0].id() != 0);\n-    assert!(doc.cratemod().consts()[0].name() == ~\"a\");\n-}\n-\n fn enumdoc_from_enum(\n     itemdoc: doc::ItemDoc,\n     variants: ~[ast::variant]\n@@ -213,19 +206,6 @@ fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n     }\n }\n \n-#[test]\n-fn should_extract_enums() {\n-    let doc = test::mk_doc(~\"enum e { v }\");\n-    assert!(doc.cratemod().enums()[0].id() != 0);\n-    assert!(doc.cratemod().enums()[0].name() == ~\"e\");\n-}\n-\n-#[test]\n-fn should_extract_enum_variants() {\n-    let doc = test::mk_doc(~\"enum e { v }\");\n-    assert!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n-}\n-\n fn traitdoc_from_trait(\n     itemdoc: doc::ItemDoc,\n     methods: ~[ast::trait_method]\n@@ -259,18 +239,6 @@ fn traitdoc_from_trait(\n     }\n }\n \n-#[test]\n-fn should_extract_traits() {\n-    let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    assert!(doc.cratemod().traits()[0].name() == ~\"i\");\n-}\n-\n-#[test]\n-fn should_extract_trait_methods() {\n-    let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n-}\n-\n fn impldoc_from_impl(\n     itemdoc: doc::ItemDoc,\n     methods: ~[@ast::method]\n@@ -293,12 +261,6 @@ fn impldoc_from_impl(\n     }\n }\n \n-#[test]\n-fn should_extract_impl_methods() {\n-    let doc = test::mk_doc(~\"impl int { fn f() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n-}\n-\n fn tydoc_from_ty(\n     itemdoc: doc::ItemDoc\n ) -> doc::TyDoc {\n@@ -308,12 +270,6 @@ fn tydoc_from_ty(\n     }\n }\n \n-#[test]\n-fn should_extract_tys() {\n-    let doc = test::mk_doc(~\"type a = int;\");\n-    assert!(doc.cratemod().types()[0].name() == ~\"a\");\n-}\n-\n fn structdoc_from_struct(\n     itemdoc: doc::ItemDoc,\n     struct_def: @ast::struct_def\n@@ -330,18 +286,6 @@ fn structdoc_from_struct(\n     }\n }\n \n-#[test]\n-fn should_extract_structs() {\n-    let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    assert!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n-}\n-\n-#[test]\n-fn should_extract_struct_fields() {\n-    let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    assert!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n@@ -351,47 +295,47 @@ mod test {\n \n     use core::vec;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         let ast = parse::from_str(source);\n         extract(ast, ~\"\")\n     }\n \n     #[test]\n-    pub fn extract_empty_crate() {\n+    fn extract_empty_crate() {\n         let doc = mk_doc(~\"\");\n         assert!(vec::is_empty(doc.cratemod().mods()));\n         assert!(vec::is_empty(doc.cratemod().fns()));\n     }\n \n     #[test]\n-    pub fn extract_mods() {\n+    fn extract_mods() {\n         let doc = mk_doc(~\"mod a { mod b { } mod c { } }\");\n         assert!(doc.cratemod().mods()[0].name() == ~\"a\");\n         assert!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n         assert!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n     }\n \n     #[test]\n-    pub fn extract_fns_from_foreign_mods() {\n+    fn extract_fns_from_foreign_mods() {\n         let doc = mk_doc(~\"extern { fn a(); }\");\n         assert!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n     }\n \n     #[test]\n-    pub fn extract_mods_deep() {\n+    fn extract_mods_deep() {\n         let doc = mk_doc(~\"mod a { mod b { mod c { } } }\");\n         assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() ==\n             ~\"c\");\n     }\n \n     #[test]\n-    pub fn extract_should_set_mod_ast_id() {\n+    fn extract_should_set_mod_ast_id() {\n         let doc = mk_doc(~\"mod a { }\");\n         assert!(doc.cratemod().mods()[0].id() != 0);\n     }\n \n     #[test]\n-    pub fn extract_fns() {\n+    fn extract_fns() {\n         let doc = mk_doc(\n             ~\"fn a() { } \\\n               mod b { fn c() {\n@@ -401,25 +345,81 @@ mod test {\n     }\n \n     #[test]\n-    pub fn extract_should_set_fn_ast_id() {\n+    fn extract_should_set_fn_ast_id() {\n         let doc = mk_doc(~\"fn a() { }\");\n         assert!(doc.cratemod().fns()[0].id() != 0);\n     }\n \n     #[test]\n-    pub fn extract_should_use_default_crate_name() {\n+    fn extract_should_use_default_crate_name() {\n         let source = ~\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n         assert!(doc.cratemod().name() == ~\"burp\");\n     }\n \n     #[test]\n-    pub fn extract_from_seq_srv() {\n+    fn extract_from_seq_srv() {\n         let source = ~\"\";\n         do astsrv::from_str(source) |srv| {\n             let doc = from_srv(srv, ~\"name\");\n             assert!(doc.cratemod().name() == ~\"name\");\n         }\n     }\n+\n+    #[test]\n+    fn should_extract_const_name_and_id() {\n+        let doc = mk_doc(~\"static a: int = 0;\");\n+        assert!(doc.cratemod().consts()[0].id() != 0);\n+        assert!(doc.cratemod().consts()[0].name() == ~\"a\");\n+    }\n+\n+    #[test]\n+    fn should_extract_enums() {\n+        let doc = mk_doc(~\"enum e { v }\");\n+        assert!(doc.cratemod().enums()[0].id() != 0);\n+        assert!(doc.cratemod().enums()[0].name() == ~\"e\");\n+    }\n+\n+    #[test]\n+    fn should_extract_enum_variants() {\n+        let doc = mk_doc(~\"enum e { v }\");\n+        assert!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n+    }\n+\n+    #[test]\n+    fn should_extract_traits() {\n+        let doc = mk_doc(~\"trait i { fn f(); }\");\n+        assert!(doc.cratemod().traits()[0].name() == ~\"i\");\n+    }\n+\n+    #[test]\n+    fn should_extract_trait_methods() {\n+        let doc = mk_doc(~\"trait i { fn f(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n+    }\n+\n+    #[test]\n+    fn should_extract_impl_methods() {\n+        let doc = mk_doc(~\"impl int { fn f() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n+    }\n+\n+    #[test]\n+    fn should_extract_tys() {\n+        let doc = mk_doc(~\"type a = int;\");\n+        assert!(doc.cratemod().types()[0].name() == ~\"a\");\n+    }\n+\n+    #[test]\n+    fn should_extract_structs() {\n+        let doc = mk_doc(~\"struct Foo { field: () }\");\n+        assert!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n+    }\n+\n+    #[test]\n+    fn should_extract_struct_fields() {\n+        let doc = mk_doc(~\"struct Foo { field: () }\");\n+        assert!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n+    }\n }"}, {"sha": "866fbba2be87a9d47186f40302d564c01bbd701d", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 108, "deletions": 108, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -115,7 +115,7 @@ fn item_to_entry(\n     }\n }\n \n-fn pandoc_header_id(header: &str) -> ~str {\n+pub fn pandoc_header_id(header: &str) -> ~str {\n \n     // http://johnmacfarlane.net/pandoc/README.html#headers\n \n@@ -162,110 +162,6 @@ fn pandoc_header_id(header: &str) -> ~str {\n     fn maybe_use_section_id(s: &str) -> ~str { s.to_str() }\n }\n \n-#[test]\n-fn should_remove_punctuation_from_headers() {\n-    assert!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n-        ~\"impl-foo-of-bara\");\n-    assert!(pandoc_header_id(~\"impl of num::num for int\")\n-        == ~\"impl-of-numnum-for-int\");\n-    assert!(pandoc_header_id(~\"impl of num::num for int/&\")\n-        == ~\"impl-of-numnum-for-int\");\n-    assert!(pandoc_header_id(~\"impl of num::num for ^int\")\n-        == ~\"impl-of-numnum-for-int\");\n-    assert!(pandoc_header_id(~\"impl for & condvar\")\n-        == ~\"impl-for-condvar\");\n-    assert!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n-                 == ~\"impl-of-selectt-u-for-left-right\");\n-    assert!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n-                 == ~\"impl-of-conditionself-t-u\");\n-    assert!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n-                 == ~\"impl-of-conditiont-copy-clone\");\n-}\n-\n-#[test]\n-fn should_trim_whitespace_after_removing_punctuation() {\n-    assert!(pandoc_header_id(\"impl foo for ()\") == ~\"impl-foo-for\");\n-}\n-\n-#[test]\n-fn should_index_mod_contents() {\n-    let doc = test::mk_doc(\n-        config::DocPerCrate,\n-        ~\"mod a { } fn b() { }\"\n-    );\n-    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n-        kind: ~\"Module\",\n-        name: ~\"a\",\n-        brief: None,\n-        link: ~\"#module-a\"\n-    });\n-    assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n-        kind: ~\"Function\",\n-        name: ~\"b\",\n-        brief: None,\n-        link: ~\"#function-b\"\n-    });\n-}\n-\n-#[test]\n-fn should_index_mod_contents_multi_page() {\n-    let doc = test::mk_doc(\n-        config::DocPerMod,\n-        ~\"mod a { } fn b() { }\"\n-    );\n-    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n-        kind: ~\"Module\",\n-        name: ~\"a\",\n-        brief: None,\n-        link: ~\"a.html\"\n-    });\n-    assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n-        kind: ~\"Function\",\n-        name: ~\"b\",\n-        brief: None,\n-        link: ~\"#function-b\"\n-    });\n-}\n-\n-#[test]\n-fn should_index_foreign_mod_pages() {\n-    let doc = test::mk_doc(\n-        config::DocPerMod,\n-        ~\"extern mod a { }\"\n-    );\n-    assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n-        kind: ~\"Foreign module\",\n-        name: ~\"a\",\n-        brief: None,\n-        link: ~\"a.html\"\n-    });\n-}\n-\n-#[test]\n-fn should_add_brief_desc_to_index() {\n-    let doc = test::mk_doc(\n-        config::DocPerMod,\n-        ~\"#[doc = \\\"test\\\"] mod a { }\"\n-    );\n-    assert!((&doc.cratemod().index).get().entries[0].brief\n-        == Some(~\"test\"));\n-}\n-\n-#[test]\n-fn should_index_foreign_mod_contents() {\n-    let doc = test::mk_doc(\n-        config::DocPerCrate,\n-        ~\"extern mod a { fn b(); }\"\n-    );\n-    assert!((&doc.cratemod().nmods()[0].index).get().entries[0]\n-        == doc::IndexEntry {\n-        kind: ~\"Function\",\n-        name: ~\"b\",\n-        brief: None,\n-        link: ~\"#function-b\"\n-    });\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n@@ -276,10 +172,10 @@ mod test {\n     use extract;\n     use markdown_index_pass::run;\n     use path_pass;\n+    use super::pandoc_header_id;\n+    use core::prelude::*;\n \n-    use core::path::Path;\n-\n-    pub fn mk_doc(output_style: config::OutputStyle, source: ~str)\n+    fn mk_doc(output_style: config::OutputStyle, source: ~str)\n                -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let config = config::Config {\n@@ -293,4 +189,108 @@ mod test {\n             run(srv.clone(), doc, config)\n         }\n     }\n+\n+    #[test]\n+    fn should_remove_punctuation_from_headers() {\n+        assert!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n+                ~\"impl-foo-of-bara\");\n+        assert!(pandoc_header_id(~\"impl of num::num for int\")\n+                == ~\"impl-of-numnum-for-int\");\n+        assert!(pandoc_header_id(~\"impl of num::num for int/&\")\n+                == ~\"impl-of-numnum-for-int\");\n+        assert!(pandoc_header_id(~\"impl of num::num for ^int\")\n+                == ~\"impl-of-numnum-for-int\");\n+        assert!(pandoc_header_id(~\"impl for & condvar\")\n+                == ~\"impl-for-condvar\");\n+        assert!(pandoc_header_id(~\"impl of Select<T, U> for (Left, Right)\")\n+                == ~\"impl-of-selectt-u-for-left-right\");\n+        assert!(pandoc_header_id(~\"impl of Condition<'self, T, U>\")\n+                == ~\"impl-of-conditionself-t-u\");\n+        assert!(pandoc_header_id(~\"impl of Condition<T: Copy + Clone>\")\n+                == ~\"impl-of-conditiont-copy-clone\");\n+    }\n+\n+    #[test]\n+    fn should_trim_whitespace_after_removing_punctuation() {\n+        assert!(pandoc_header_id(\"impl foo for ()\") == ~\"impl-foo-for\");\n+    }\n+\n+    #[test]\n+    fn should_index_mod_contents() {\n+        let doc = mk_doc(\n+            config::DocPerCrate,\n+            ~\"mod a { } fn b() { }\"\n+        );\n+        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+            kind: ~\"Module\",\n+            name: ~\"a\",\n+            brief: None,\n+            link: ~\"#module-a\"\n+        });\n+        assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+            kind: ~\"Function\",\n+            name: ~\"b\",\n+            brief: None,\n+            link: ~\"#function-b\"\n+        });\n+    }\n+\n+    #[test]\n+    fn should_index_mod_contents_multi_page() {\n+        let doc = mk_doc(\n+            config::DocPerMod,\n+            ~\"mod a { } fn b() { }\"\n+        );\n+        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+            kind: ~\"Module\",\n+            name: ~\"a\",\n+            brief: None,\n+            link: ~\"a.html\"\n+        });\n+        assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+            kind: ~\"Function\",\n+            name: ~\"b\",\n+            brief: None,\n+            link: ~\"#function-b\"\n+        });\n+    }\n+\n+    #[test]\n+    fn should_index_foreign_mod_pages() {\n+        let doc = mk_doc(\n+            config::DocPerMod,\n+            ~\"extern mod a { }\"\n+        );\n+        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+            kind: ~\"Foreign module\",\n+            name: ~\"a\",\n+            brief: None,\n+            link: ~\"a.html\"\n+        });\n+    }\n+\n+    #[test]\n+    fn should_add_brief_desc_to_index() {\n+        let doc = mk_doc(\n+            config::DocPerMod,\n+            ~\"#[doc = \\\"test\\\"] mod a { }\"\n+        );\n+        assert!((&doc.cratemod().index).get().entries[0].brief\n+                == Some(~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_index_foreign_mod_contents() {\n+        let doc = mk_doc(\n+            config::DocPerCrate,\n+            ~\"extern mod a { fn b(); }\"\n+        );\n+        assert!((&doc.cratemod().nmods()[0].index).get().entries[0]\n+                == doc::IndexEntry {\n+                    kind: ~\"Function\",\n+                    name: ~\"b\",\n+                    brief: None,\n+                    link: ~\"#function-b\"\n+                });\n+    }\n }"}, {"sha": "2dfc04e8ec7097aa6aa42704816ff23d803619a0", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 457, "deletions": 461, "changes": 918, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -22,10 +22,6 @@ use markdown_writer::WriterFactory;\n use pass::Pass;\n use sort_pass;\n \n-#[cfg(test)] use config;\n-#[cfg(test)] use markdown_writer;\n-#[cfg(test)] use page_pass;\n-\n use core::cell::Cell;\n use core::str;\n use core::vec;\n@@ -48,8 +44,8 @@ fn run(\n     fn mods_last(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n         fn is_mod(item: &doc::ItemTag) -> bool {\n             match *item {\n-              doc::ModTag(_) => true,\n-              _ => false\n+                doc::ModTag(_) => true,\n+                _ => false\n             }\n         }\n \n@@ -69,33 +65,6 @@ fn run(\n     return doc;\n }\n \n-#[test]\n-fn should_write_modules_last() {\n-    /*\n-    Because the markdown pass writes all modules at the same level of\n-    indentation (it doesn't 'nest' them), we need to make sure that we\n-    write all of the modules contained in each module after all other\n-    types of items, or else the header nesting will end up wrong, with\n-    modules appearing to contain items that they do not.\n-    */\n-    let markdown = test::render(\n-        ~\"mod a { }\\\n-         fn b() { }\\\n-         mod c {\n-         }\\\n-         fn d() { }\"\n-    );\n-\n-    let idx_a = str::find_str(markdown, ~\"# Module `a`\").get();\n-    let idx_b = str::find_str(markdown, ~\"## Function `b`\").get();\n-    let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n-    let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n-\n-    assert!(idx_b < idx_d);\n-    assert!(idx_d < idx_a);\n-    assert!(idx_a < idx_c);\n-}\n-\n struct Ctxt {\n     w: Writer\n }\n@@ -118,72 +87,37 @@ pub fn write_markdown(\n fn write_page(ctxt: &Ctxt, page: &doc::Page) {\n     write_title(ctxt, copy *page);\n     match copy *page {\n-      doc::CratePage(doc) => {\n-        write_crate(ctxt, doc);\n-      }\n-      doc::ItemPage(doc) => {\n-        // We don't write a header for item's pages because their\n-        // header in the html output is created by the page title\n-        write_item_no_header(ctxt, doc);\n-      }\n+        doc::CratePage(doc) => {\n+            write_crate(ctxt, doc);\n+        }\n+        doc::ItemPage(doc) => {\n+            // We don't write a header for item's pages because their\n+            // header in the html output is created by the page title\n+            write_item_no_header(ctxt, doc);\n+        }\n     }\n     ctxt.w.put_done();\n }\n \n-#[test]\n-fn should_request_new_writer_for_each_page() {\n-    // This port will send us a (page, str) pair for every writer\n-    // that was created\n-    let (writer_factory, po) = markdown_writer::future_writer_factory();\n-    let (srv, doc) = test::create_doc_srv(~\"mod a { }\");\n-    // Split the document up into pages\n-    let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n-    write_markdown(doc, writer_factory);\n-    // We expect two pages to have been written\n-    for iter::repeat(2) {\n-        po.recv();\n-    }\n-}\n-\n fn write_title(ctxt: &Ctxt, page: doc::Page) {\n     ctxt.w.put_line(fmt!(\"%% %s\", make_title(page)));\n     ctxt.w.put_line(~\"\");\n }\n \n fn make_title(page: doc::Page) -> ~str {\n     let item = match page {\n-      doc::CratePage(CrateDoc) => {\n-        doc::ModTag(copy CrateDoc.topmod)\n-      }\n-      doc::ItemPage(ItemTag) => {\n-        ItemTag\n-      }\n+        doc::CratePage(CrateDoc) => {\n+            doc::ModTag(copy CrateDoc.topmod)\n+        }\n+        doc::ItemPage(ItemTag) => {\n+            ItemTag\n+        }\n     };\n     let title = markdown_pass::header_text(item);\n     let title = str::replace(title, ~\"`\", ~\"\");\n     return title;\n }\n \n-#[test]\n-fn should_write_title_for_each_page() {\n-    let (writer_factory, po) = markdown_writer::future_writer_factory();\n-    let (srv, doc) = test::create_doc_srv(\n-        ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n-    let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n-    write_markdown(doc, writer_factory);\n-    for iter::repeat(2) {\n-        let (page, markdown) = po.recv();\n-        match page {\n-          doc::CratePage(_) => {\n-            assert!(str::contains(markdown, ~\"% Crate core\"));\n-          }\n-          doc::ItemPage(_) => {\n-            assert!(str::contains(markdown, ~\"% Module a\"));\n-          }\n-        }\n-    }\n-}\n-\n enum Hlvl {\n     H1 = 1,\n     H2 = 2,\n@@ -204,94 +138,94 @@ fn write_header_(ctxt: &Ctxt, lvl: Hlvl, title: ~str) {\n \n pub fn header_kind(doc: doc::ItemTag) -> ~str {\n     match doc {\n-      doc::ModTag(_) => {\n-        if doc.id() == syntax::ast::crate_node_id {\n-            ~\"Crate\"\n-        } else {\n-            ~\"Module\"\n+        doc::ModTag(_) => {\n+            if doc.id() == syntax::ast::crate_node_id {\n+                ~\"Crate\"\n+            } else {\n+                ~\"Module\"\n+            }\n+        }\n+        doc::NmodTag(_) => {\n+            ~\"Foreign module\"\n+        }\n+        doc::FnTag(_) => {\n+            ~\"Function\"\n+        }\n+        doc::ConstTag(_) => {\n+            ~\"Const\"\n+        }\n+        doc::EnumTag(_) => {\n+            ~\"Enum\"\n+        }\n+        doc::TraitTag(_) => {\n+            ~\"Trait\"\n+        }\n+        doc::ImplTag(_) => {\n+            ~\"Implementation\"\n+        }\n+        doc::TyTag(_) => {\n+            ~\"Type\"\n+        }\n+        doc::StructTag(_) => {\n+            ~\"Struct\"\n         }\n-      }\n-      doc::NmodTag(_) => {\n-        ~\"Foreign module\"\n-      }\n-      doc::FnTag(_) => {\n-        ~\"Function\"\n-      }\n-      doc::ConstTag(_) => {\n-        ~\"Const\"\n-      }\n-      doc::EnumTag(_) => {\n-        ~\"Enum\"\n-      }\n-      doc::TraitTag(_) => {\n-        ~\"Trait\"\n-      }\n-      doc::ImplTag(_) => {\n-        ~\"Implementation\"\n-      }\n-      doc::TyTag(_) => {\n-        ~\"Type\"\n-      }\n-      doc::StructTag(_) => {\n-        ~\"Struct\"\n-      }\n     }\n }\n \n pub fn header_name(doc: doc::ItemTag) -> ~str {\n     let fullpath = str::connect(doc.path() + ~[doc.name()], ~\"::\");\n     match &doc {\n-      &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n-        fullpath\n-      }\n-      &doc::NmodTag(_) => {\n-        fullpath\n-      }\n-      &doc::ImplTag(ref doc) => {\n-        assert!(doc.self_ty.is_some());\n-          let bounds = if (&doc.bounds_str).is_some() {\n-              fmt!(\" where %s\", (&doc.bounds_str).get())\n-          } else {\n-              ~\"\"\n-          };\n-        let self_ty = (&doc.self_ty).get();\n-        let mut trait_part = ~\"\";\n-        for doc.trait_types.eachi |i, trait_type| {\n-            if i == 0 {\n-                trait_part += ~\" of \";\n+        &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n+            fullpath\n+        }\n+        &doc::NmodTag(_) => {\n+            fullpath\n+        }\n+        &doc::ImplTag(ref doc) => {\n+            assert!(doc.self_ty.is_some());\n+            let bounds = if (&doc.bounds_str).is_some() {\n+                fmt!(\" where %s\", (&doc.bounds_str).get())\n             } else {\n-                trait_part += ~\", \";\n+                ~\"\"\n+            };\n+            let self_ty = (&doc.self_ty).get();\n+            let mut trait_part = ~\"\";\n+            for doc.trait_types.eachi |i, trait_type| {\n+                if i == 0 {\n+                    trait_part += ~\" of \";\n+                } else {\n+                    trait_part += ~\", \";\n+                }\n+                trait_part += *trait_type;\n             }\n-            trait_part += *trait_type;\n+            fmt!(\"%s for %s%s\", trait_part, self_ty, bounds)\n+        }\n+        _ => {\n+            doc.name()\n         }\n-        fmt!(\"%s for %s%s\", trait_part, self_ty, bounds)\n-      }\n-      _ => {\n-        doc.name()\n-      }\n     }\n }\n \n pub fn header_text(doc: doc::ItemTag) -> ~str {\n     match &doc {\n-      &doc::ImplTag(ref ImplDoc) => {\n-        let header_kind = header_kind(copy doc);\n-          let bounds = if (&ImplDoc.bounds_str).is_some() {\n-              fmt!(\" where `%s`\", (&ImplDoc.bounds_str).get())\n-          } else {\n-              ~\"\"\n-          };\n-        let desc = if ImplDoc.trait_types.is_empty() {\n-            fmt!(\"for `%s`%s\", (&ImplDoc.self_ty).get(), bounds)\n-        } else {\n-            fmt!(\"of `%s` for `%s`%s\",\n-                 ImplDoc.trait_types[0],\n-                 (&ImplDoc.self_ty).get(),\n-                 bounds)\n-        };\n-        return fmt!(\"%s %s\", header_kind, desc);\n-      }\n-      _ => {}\n+        &doc::ImplTag(ref ImplDoc) => {\n+            let header_kind = header_kind(copy doc);\n+            let bounds = if (&ImplDoc.bounds_str).is_some() {\n+                fmt!(\" where `%s`\", (&ImplDoc.bounds_str).get())\n+            } else {\n+                ~\"\"\n+            };\n+            let desc = if ImplDoc.trait_types.is_empty() {\n+                fmt!(\"for `%s`%s\", (&ImplDoc.self_ty).get(), bounds)\n+            } else {\n+                fmt!(\"of `%s` for `%s`%s\",\n+                     ImplDoc.trait_types[0],\n+                     (&ImplDoc.self_ty).get(),\n+                     bounds)\n+            };\n+            return fmt!(\"%s %s\", header_kind, desc);\n+        }\n+        _ => {}\n     }\n \n     header_text_(header_kind(copy doc),\n@@ -323,12 +257,6 @@ fn write_mod(\n     write_mod_contents(ctxt, ModDoc);\n }\n \n-#[test]\n-fn should_write_full_path_to_mod() {\n-    let markdown = test::render(~\"mod a { mod b { mod c { } } }\");\n-    assert!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n-}\n-\n fn write_common(\n     ctxt: &Ctxt,\n     desc: Option<~str>,\n@@ -363,17 +291,6 @@ fn write_section(ctxt: &Ctxt, section: doc::Section) {\n     ctxt.w.put_line(~\"\");\n }\n \n-#[test]\n-fn should_write_sections() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n-}\n-\n fn write_mod_contents(\n     ctxt: &Ctxt,\n     doc: doc::ModDoc\n@@ -402,15 +319,15 @@ fn write_item_(ctxt: &Ctxt, doc: doc::ItemTag, write_header: bool) {\n     }\n \n     match doc {\n-      doc::ModTag(ModDoc) => write_mod(ctxt, ModDoc),\n-      doc::NmodTag(nModDoc) => write_nmod(ctxt, nModDoc),\n-      doc::FnTag(FnDoc) => write_fn(ctxt, FnDoc),\n-      doc::ConstTag(ConstDoc) => write_const(ctxt, ConstDoc),\n-      doc::EnumTag(EnumDoc) => write_enum(ctxt, EnumDoc),\n-      doc::TraitTag(TraitDoc) => write_trait(ctxt, TraitDoc),\n-      doc::ImplTag(ImplDoc) => write_impl(ctxt, ImplDoc),\n-      doc::TyTag(TyDoc) => write_type(ctxt, TyDoc),\n-      doc::StructTag(StructDoc) => put_struct(ctxt, StructDoc),\n+        doc::ModTag(ModDoc) => write_mod(ctxt, ModDoc),\n+        doc::NmodTag(nModDoc) => write_nmod(ctxt, nModDoc),\n+        doc::FnTag(FnDoc) => write_fn(ctxt, FnDoc),\n+        doc::ConstTag(ConstDoc) => write_const(ctxt, ConstDoc),\n+        doc::EnumTag(EnumDoc) => write_enum(ctxt, EnumDoc),\n+        doc::TraitTag(TraitDoc) => write_trait(ctxt, TraitDoc),\n+        doc::ImplTag(ImplDoc) => write_impl(ctxt, ImplDoc),\n+        doc::TyTag(TyDoc) => write_type(ctxt, TyDoc),\n+        doc::StructTag(StructDoc) => put_struct(ctxt, StructDoc),\n     }\n }\n \n@@ -420,17 +337,11 @@ fn write_item_header(ctxt: &Ctxt, doc: doc::ItemTag) {\n \n fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n     match doc {\n-      &doc::ModTag(_) | &doc::NmodTag(_) => H1,\n-      _ => H2\n+        &doc::ModTag(_) | &doc::NmodTag(_) => H1,\n+        _ => H2\n     }\n }\n \n-#[test]\n-fn should_write_crate_description() {\n-    let markdown = test::render(~\"#[doc = \\\"this is the crate\\\"];\");\n-    assert!(str::contains(markdown, ~\"this is the crate\"));\n-}\n-\n fn write_index(ctxt: &Ctxt, index: doc::Index) {\n     if vec::is_empty(index.entries) {\n         return;\n@@ -444,7 +355,7 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n         let id = copy entry.link;\n         if entry.brief.is_some() {\n             ctxt.w.put_line(fmt!(\"* [%s](%s) - %s\",\n-                                   header, id, (&entry.brief).get()));\n+                                 header, id, (&entry.brief).get()));\n         } else {\n             ctxt.w.put_line(fmt!(\"* [%s](%s)\", header, id));\n         }\n@@ -454,37 +365,6 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n     ctxt.w.put_line(~\"\");\n }\n \n-#[test]\n-fn should_write_index() {\n-    let markdown = test::render(~\"mod a { } mod b { }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n-         * [Module `b`](#module-b)\\n\\n\"\n-    ));\n-}\n-\n-#[test]\n-fn should_write_index_brief() {\n-    let markdown = test::render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n-}\n-\n-#[test]\n-fn should_not_write_index_if_no_entries() {\n-    let markdown = test::render(~\"\");\n-    assert!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_index_for_foreign_mods() {\n-    let markdown = test::render(~\"extern mod a { fn a(); }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n-    ));\n-}\n-\n fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n@@ -497,27 +377,6 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n     }\n }\n \n-#[test]\n-fn should_write_foreign_mods() {\n-    let markdown = test::render(~\"#[doc = \\\"test\\\"] extern mod a { }\");\n-    assert!(str::contains(markdown, ~\"Foreign module `a`\"));\n-    assert!(str::contains(markdown, ~\"test\"));\n-}\n-\n-#[test]\n-fn should_write_foreign_fns() {\n-    let markdown = test::render(\n-        ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert!(str::contains(markdown, ~\"test\"));\n-}\n-\n-#[test]\n-fn should_write_foreign_fn_headers() {\n-    let markdown = test::render(\n-        ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert!(str::contains(markdown, ~\"## Function `a`\"));\n-}\n-\n fn write_fn(\n     ctxt: &Ctxt,\n     doc: doc::FnDoc\n@@ -542,11 +401,11 @@ fn write_fnlike(\n \n fn write_sig(ctxt: &Ctxt, sig: Option<~str>) {\n     match sig {\n-      Some(sig) => {\n-        ctxt.w.put_line(code_block_indent(sig));\n-        ctxt.w.put_line(~\"\");\n-      }\n-      None => fail!(~\"unimplemented\")\n+        Some(sig) => {\n+            ctxt.w.put_line(code_block_indent(sig));\n+            ctxt.w.put_line(~\"\");\n+        }\n+        None => fail!(~\"unimplemented\")\n     }\n }\n \n@@ -558,51 +417,6 @@ fn code_block_indent(s: ~str) -> ~str {\n     str::connect(indented, \"\\n\")\n }\n \n-#[test]\n-fn write_markdown_should_write_function_header() {\n-    let markdown = test::render(~\"fn func() { }\");\n-    assert!(str::contains(markdown, ~\"## Function `func`\"));\n-}\n-\n-#[test]\n-fn should_write_the_function_signature() {\n-    let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    assert!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n-}\n-\n-#[test]\n-fn should_insert_blank_line_after_fn_signature() {\n-    let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    assert!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_correctly_indent_fn_signature() {\n-    let doc = test::create_doc(~\"fn a() { }\");\n-    let doc = doc::Doc{\n-        pages: ~[\n-            doc::CratePage(doc::CrateDoc{\n-                topmod: doc::ModDoc{\n-                    items: ~[doc::FnTag(doc::SimpleItemDoc{\n-                        sig: Some(~\"line 1\\nline 2\"),\n-                        .. copy doc.cratemod().fns()[0]\n-                    })],\n-                    .. doc.cratemod()\n-                },\n-                .. doc.CrateDoc()\n-            })\n-        ]\n-    };\n-    let markdown = test::write_markdown_str(doc);\n-    assert!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n-}\n-\n-#[test]\n-fn should_leave_blank_line_between_fn_header_and_sig() {\n-    let markdown = test::render(~\"fn a() { }\");\n-    assert!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n-}\n-\n fn write_const(\n     ctxt: &Ctxt,\n     doc: doc::ConstDoc\n@@ -611,20 +425,6 @@ fn write_const(\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n-#[test]\n-fn should_write_const_header() {\n-    let markdown = test::render(~\"static a: bool = true;\");\n-    assert!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_const_description() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"b\\\"]\\\n-         static a: bool = true;\");\n-    assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n-}\n-\n fn write_enum(\n     ctxt: &Ctxt,\n     doc: doc::EnumDoc\n@@ -633,19 +433,6 @@ fn write_enum(\n     write_variants(ctxt, doc.variants);\n }\n \n-#[test]\n-fn should_write_enum_header() {\n-    let markdown = test::render(~\"enum a { b }\");\n-    assert!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_enum_description() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"b\\\"] enum a { b }\");\n-    assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n-}\n-\n fn write_variants(\n     ctxt: &Ctxt,\n     docs: &[doc::VariantDoc]\n@@ -667,46 +454,13 @@ fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n     assert!(doc.sig.is_some());\n     let sig = (&doc.sig).get();\n     match copy doc.desc {\n-      Some(desc) => {\n-        ctxt.w.put_line(fmt!(\"* `%s` - %s\", sig, desc));\n-      }\n-      None => {\n-        ctxt.w.put_line(fmt!(\"* `%s`\", sig));\n-      }\n-    }\n-}\n-\n-#[test]\n-fn should_write_variant_list() {\n-    let markdown = test::render(\n-        ~\"enum a { \\\n-         #[doc = \\\"test\\\"] b, \\\n-         #[doc = \\\"test\\\"] c }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n#### Variants\\n\\\n-         \\n* `b` - test\\\n-         \\n* `c` - test\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_variant_list_without_descs() {\n-    let markdown = test::render(~\"enum a { b, c }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n#### Variants\\n\\\n-         \\n* `b`\\\n-         \\n* `c`\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_variant_list_with_signatures() {\n-    let markdown = test::render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n-    assert!(str::contains(\n-        markdown,\n-        ~\"\\n\\n#### Variants\\n\\\n-         \\n* `b(int)`\\\n-         \\n* `c(int)` - a\\n\\n\"));\n+        Some(desc) => {\n+            ctxt.w.put_line(fmt!(\"* `%s` - %s\", sig, desc));\n+        }\n+        None => {\n+            ctxt.w.put_line(fmt!(\"* `%s`\", sig));\n+        }\n+    }\n }\n \n fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n@@ -730,78 +484,11 @@ fn write_method(ctxt: &Ctxt, doc: doc::MethodDoc) {\n     );\n }\n \n-#[test]\n-fn should_write_trait_header() {\n-    let markdown = test::render(~\"trait i { fn a(); }\");\n-    assert!(str::contains(markdown, ~\"## Trait `i`\"));\n-}\n-\n-#[test]\n-fn should_write_trait_desc() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-    assert!(str::contains(markdown, ~\"desc\"));\n-}\n-\n-#[test]\n-fn should_write_trait_method_header() {\n-    let markdown = test::render(\n-        ~\"trait i { fn a(); }\");\n-    assert!(str::contains(markdown, ~\"### Method `a`\"));\n-}\n-\n-#[test]\n-fn should_write_trait_method_signature() {\n-    let markdown = test::render(\n-        ~\"trait i { fn a(&self); }\");\n-    assert!(str::contains(markdown, ~\"\\n    fn a(&self)\"));\n-}\n-\n fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n-#[test]\n-fn should_write_impl_header() {\n-    let markdown = test::render(~\"impl int { fn a() { } }\");\n-    assert!(str::contains(markdown, ~\"## Implementation for `int`\"));\n-}\n-\n-#[test]\n-fn should_write_impl_header_with_bounds() {\n-    let markdown = test::render(~\"impl <T> int<T> { }\");\n-    assert!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n-}\n-\n-#[test]\n-fn should_write_impl_header_with_trait() {\n-    let markdown = test::render(~\"impl j for int { fn a() { } }\");\n-    assert!(str::contains(markdown,\n-        ~\"## Implementation of `j` for `int`\"));\n-}\n-\n-#[test]\n-fn should_write_impl_desc() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-    assert!(str::contains(markdown, ~\"desc\"));\n-}\n-\n-#[test]\n-fn should_write_impl_method_header() {\n-    let markdown = test::render(\n-        ~\"impl int { fn a() { } }\");\n-    assert!(str::contains(markdown, ~\"### Method `a`\"));\n-}\n-\n-#[test]\n-fn should_write_impl_method_signature() {\n-    let markdown = test::render(\n-        ~\"impl int { fn a(&mut self) { } }\");\n-    assert!(str::contains(markdown, ~\"\\n    fn a(&mut self)\"));\n-}\n-\n fn write_type(\n     ctxt: &Ctxt,\n     doc: doc::TyDoc\n@@ -810,25 +497,6 @@ fn write_type(\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n-#[test]\n-fn should_write_type_header() {\n-    let markdown = test::render(~\"type t = int;\");\n-    assert!(str::contains(markdown, ~\"## Type `t`\"));\n-}\n-\n-#[test]\n-fn should_write_type_desc() {\n-    let markdown = test::render(\n-        ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-    assert!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n-}\n-\n-#[test]\n-fn should_write_type_signature() {\n-    let markdown = test::render(~\"type t = int;\");\n-    assert!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n-}\n-\n fn put_struct(\n     ctxt: &Ctxt,\n     doc: doc::StructDoc\n@@ -837,12 +505,6 @@ fn put_struct(\n     write_common(ctxt, doc.desc(), doc.sections());\n }\n \n-#[test]\n-fn should_put_struct_header() {\n-    let markdown = test::render(~\"struct S { field: () }\");\n-    assert!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n@@ -855,22 +517,21 @@ mod test {\n     use markdown_pass::{mk_pass, write_markdown};\n     use markdown_writer;\n     use path_pass;\n+    use page_pass;\n     use sectionalize_pass;\n     use trim_pass;\n     use tystr_pass;\n     use unindent_pass;\n+    use core::prelude::*;\n \n-    use core::path::Path;\n-    use core::str;\n-\n-    pub fn render(source: ~str) -> ~str {\n+    fn render(source: ~str) -> ~str {\n         let (srv, doc) = create_doc_srv(source);\n         let markdown = write_markdown_str_srv(srv, doc);\n         debug!(\"markdown: %s\", markdown);\n         markdown\n     }\n \n-    pub fn create_doc_srv(source: ~str) -> (astsrv::Srv, doc::Doc) {\n+    fn create_doc_srv(source: ~str) -> (astsrv::Srv, doc::Doc) {\n         do astsrv::from_str(source) |srv| {\n \n             let config = config::Config {\n@@ -901,20 +562,20 @@ mod test {\n         }\n     }\n \n-    pub fn create_doc(source: ~str) -> doc::Doc {\n+    fn create_doc(source: ~str) -> doc::Doc {\n         let (_, doc) = create_doc_srv(source);\n         doc\n     }\n \n-    pub fn write_markdown_str(\n+    fn write_markdown_str(\n         doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         write_markdown(doc, writer_factory);\n         return po.recv().second();\n     }\n \n-    pub fn write_markdown_str_srv(\n+    fn write_markdown_str_srv(\n         srv: astsrv::Srv,\n         doc: doc::Doc\n     ) -> ~str {\n@@ -925,14 +586,349 @@ mod test {\n     }\n \n     #[test]\n-    pub fn write_markdown_should_write_mod_headers() {\n+    fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n         assert!(str::contains(markdown, ~\"# Module `moo`\"));\n     }\n \n     #[test]\n-    pub fn should_leave_blank_line_after_header() {\n+    fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n         assert!(str::contains(markdown, ~\"Module `morp`\\n\\n\"));\n     }\n+\n+    #[test]\n+    fn should_write_modules_last() {\n+        /*\n+        Because the markdown pass writes all modules at the same level of\n+        indentation (it doesn't 'nest' them), we need to make sure that we\n+        write all of the modules contained in each module after all other\n+        types of items, or else the header nesting will end up wrong, with\n+        modules appearing to contain items that they do not.\n+        */\n+        let markdown = render(\n+            ~\"mod a { }\\\n+              fn b() { }\\\n+              mod c {\n+}\\\n+              fn d() { }\"\n+        );\n+\n+        let idx_a = str::find_str(markdown, ~\"# Module `a`\").get();\n+        let idx_b = str::find_str(markdown, ~\"## Function `b`\").get();\n+        let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n+        let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n+\n+        assert!(idx_b < idx_d);\n+        assert!(idx_d < idx_a);\n+        assert!(idx_a < idx_c);\n+    }\n+\n+    #[test]\n+    fn should_request_new_writer_for_each_page() {\n+        // This port will send us a (page, str) pair for every writer\n+        // that was created\n+        let (writer_factory, po) = markdown_writer::future_writer_factory();\n+        let (srv, doc) = create_doc_srv(~\"mod a { }\");\n+        // Split the document up into pages\n+        let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n+        write_markdown(doc, writer_factory);\n+        // We expect two pages to have been written\n+        for iter::repeat(2) {\n+            po.recv();\n+        }\n+    }\n+\n+    #[test]\n+    fn should_write_title_for_each_page() {\n+        let (writer_factory, po) = markdown_writer::future_writer_factory();\n+        let (srv, doc) = create_doc_srv(\n+            ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n+        let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n+        write_markdown(doc, writer_factory);\n+        for iter::repeat(2) {\n+            let (page, markdown) = po.recv();\n+            match page {\n+                doc::CratePage(_) => {\n+                    assert!(str::contains(markdown, ~\"% Crate core\"));\n+                }\n+                doc::ItemPage(_) => {\n+                    assert!(str::contains(markdown, ~\"% Module a\"));\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn should_write_full_path_to_mod() {\n+        let markdown = render(~\"mod a { mod b { mod c { } } }\");\n+        assert!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_sections() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_crate_description() {\n+        let markdown = render(~\"#[doc = \\\"this is the crate\\\"];\");\n+        assert!(str::contains(markdown, ~\"this is the crate\"));\n+    }\n+\n+\n+    #[test]\n+    fn should_write_index() {\n+        let markdown = render(~\"mod a { } mod b { }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n+              * [Module `b`](#module-b)\\n\\n\"\n+        ));\n+    }\n+\n+    #[test]\n+    fn should_write_index_brief() {\n+        let markdown = render(~\"#[doc = \\\"test\\\"] mod a { }\");\n+        assert!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_not_write_index_if_no_entries() {\n+        let markdown = render(~\"\");\n+        assert!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_index_for_foreign_mods() {\n+        let markdown = render(~\"extern mod a { fn a(); }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n+        ));\n+    }\n+\n+    #[test]\n+    fn should_write_foreign_mods() {\n+        let markdown = render(~\"#[doc = \\\"test\\\"] extern mod a { }\");\n+        assert!(str::contains(markdown, ~\"Foreign module `a`\"));\n+        assert!(str::contains(markdown, ~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_write_foreign_fns() {\n+        let markdown = render(\n+            ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n+        assert!(str::contains(markdown, ~\"test\"));\n+    }\n+\n+    #[test]\n+    fn should_write_foreign_fn_headers() {\n+        let markdown = render(\n+            ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n+        assert!(str::contains(markdown, ~\"## Function `a`\"));\n+    }\n+\n+    #[test]\n+    fn write_markdown_should_write_function_header() {\n+        let markdown = render(~\"fn func() { }\");\n+        assert!(str::contains(markdown, ~\"## Function `func`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_the_function_signature() {\n+        let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n+        assert!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_insert_blank_line_after_fn_signature() {\n+        let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n+        assert!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_correctly_indent_fn_signature() {\n+        let doc = create_doc(~\"fn a() { }\");\n+        let doc = doc::Doc{\n+            pages: ~[\n+                doc::CratePage(doc::CrateDoc{\n+                    topmod: doc::ModDoc{\n+                        items: ~[doc::FnTag(doc::SimpleItemDoc{\n+                            sig: Some(~\"line 1\\nline 2\"),\n+                            .. copy doc.cratemod().fns()[0]\n+                        })],\n+                        .. doc.cratemod()\n+                    },\n+                    .. doc.CrateDoc()\n+                })\n+            ]\n+        };\n+        let markdown = write_markdown_str(doc);\n+        assert!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n+    }\n+\n+    #[test]\n+    fn should_leave_blank_line_between_fn_header_and_sig() {\n+        let markdown = render(~\"fn a() { }\");\n+        assert!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n+    }\n+\n+    #[test]\n+    fn should_write_const_header() {\n+        let markdown = render(~\"static a: bool = true;\");\n+        assert!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_const_description() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"b\\\"]\\\n+              static a: bool = true;\");\n+        assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_enum_header() {\n+        let markdown = render(~\"enum a { b }\");\n+        assert!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_enum_description() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"b\\\"] enum a { b }\");\n+        assert!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_variant_list() {\n+        let markdown = render(\n+            ~\"enum a { \\\n+              #[doc = \\\"test\\\"] b, \\\n+              #[doc = \\\"test\\\"] c }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n#### Variants\\n\\\n+              \\n* `b` - test\\\n+              \\n* `c` - test\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_variant_list_without_descs() {\n+        let markdown = render(~\"enum a { b, c }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n#### Variants\\n\\\n+              \\n* `b`\\\n+              \\n* `c`\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_variant_list_with_signatures() {\n+        let markdown = render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n+        assert!(str::contains(\n+            markdown,\n+            ~\"\\n\\n#### Variants\\n\\\n+              \\n* `b(int)`\\\n+              \\n* `c(int)` - a\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_trait_header() {\n+        let markdown = render(~\"trait i { fn a(); }\");\n+        assert!(str::contains(markdown, ~\"## Trait `i`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_trait_desc() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n+        assert!(str::contains(markdown, ~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_write_trait_method_header() {\n+        let markdown = render(\n+            ~\"trait i { fn a(); }\");\n+        assert!(str::contains(markdown, ~\"### Method `a`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_trait_method_signature() {\n+        let markdown = render(\n+            ~\"trait i { fn a(&self); }\");\n+        assert!(str::contains(markdown, ~\"\\n    fn a(&self)\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_header() {\n+        let markdown = render(~\"impl int { fn a() { } }\");\n+        assert!(str::contains(markdown, ~\"## Implementation for `int`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_header_with_bounds() {\n+        let markdown = render(~\"impl <T> int<T> { }\");\n+        assert!(str::contains(markdown, ~\"## Implementation for `int<T>` where `<T>`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_header_with_trait() {\n+        let markdown = render(~\"impl j for int { fn a() { } }\");\n+        assert!(str::contains(markdown,\n+                              ~\"## Implementation of `j` for `int`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_desc() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n+        assert!(str::contains(markdown, ~\"desc\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_method_header() {\n+        let markdown = render(\n+            ~\"impl int { fn a() { } }\");\n+        assert!(str::contains(markdown, ~\"### Method `a`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_impl_method_signature() {\n+        let markdown = render(\n+            ~\"impl int { fn a(&mut self) { } }\");\n+        assert!(str::contains(markdown, ~\"\\n    fn a(&mut self)\"));\n+    }\n+\n+    #[test]\n+    fn should_write_type_header() {\n+        let markdown = render(~\"type t = int;\");\n+        assert!(str::contains(markdown, ~\"## Type `t`\"));\n+    }\n+\n+    #[test]\n+    fn should_write_type_desc() {\n+        let markdown = render(\n+            ~\"#[doc = \\\"desc\\\"] type t = int;\");\n+        assert!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_write_type_signature() {\n+        let markdown = render(~\"type t = int;\");\n+        assert!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n+    }\n+\n+    #[test]\n+    fn should_put_struct_header() {\n+        let markdown = render(~\"struct S { field: () }\");\n+        assert!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n+    }\n }"}, {"sha": "fcf7011cbc309bcefbc1cc6557faef539bb950f6", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 63, "deletions": 60, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -182,7 +182,7 @@ fn generic_writer(process: ~fn(markdown: ~str)) -> Writer {\n     result\n }\n \n-fn make_local_filename(\n+pub fn make_local_filename(\n     config: config::Config,\n     page: doc::Page\n ) -> Path {\n@@ -218,65 +218,6 @@ pub fn make_filename(\n     Path(filename).with_filetype(ext)\n }\n \n-#[test]\n-fn should_use_markdown_file_name_based_off_crate() {\n-    let config = config::Config {\n-        output_dir: Path(\"output/dir\"),\n-        output_format: config::Markdown,\n-        output_style: config::DocPerCrate,\n-        .. config::default_config(&Path(\"input/test.rc\"))\n-    };\n-    let doc = test::mk_doc(~\"test\", ~\"\");\n-    let page = doc::CratePage(doc.CrateDoc());\n-    let filename = make_local_filename(config, page);\n-    assert!(filename.to_str() == ~\"output/dir/test.md\");\n-}\n-\n-#[test]\n-fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n-    let config = config::Config {\n-        output_dir: Path(\"output/dir\"),\n-        output_format: config::PandocHtml,\n-        output_style: config::DocPerMod,\n-        .. config::default_config(&Path(\"input/test.rc\"))\n-    };\n-    let doc = test::mk_doc(~\"\", ~\"\");\n-    let page = doc::CratePage(doc.CrateDoc());\n-    let filename = make_local_filename(config, page);\n-    assert!(filename.to_str() == ~\"output/dir/index.html\");\n-}\n-\n-#[test]\n-fn should_name_mod_file_names_by_path() {\n-    let config = config::Config {\n-        output_dir: Path(\"output/dir\"),\n-        output_format: config::PandocHtml,\n-        output_style: config::DocPerMod,\n-        .. config::default_config(&Path(\"input/test.rc\"))\n-    };\n-    let doc = test::mk_doc(~\"\", ~\"mod a { mod b { } }\");\n-    let modb = copy doc.cratemod().mods()[0].mods()[0];\n-    let page = doc::ItemPage(doc::ModTag(modb));\n-    let filename = make_local_filename(config, page);\n-    assert!(filename == Path(\"output/dir/a_b.html\"));\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use doc;\n-    use extract;\n-    use path_pass;\n-\n-    pub fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv.clone(), copy name);\n-            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n-            doc\n-        }\n-    }\n-}\n-\n fn write_file(path: &Path, s: ~str) {\n     use core::io::WriterUtil;\n \n@@ -322,3 +263,65 @@ fn future_writer() -> (Writer, future::Future<~str>) {\n     };\n     (writer, future)\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use astsrv;\n+    use doc;\n+    use extract;\n+    use path_pass;\n+    use config;\n+    use super::make_local_filename;\n+    use core::prelude::*;\n+\n+    fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n+        do astsrv::from_str(source) |srv| {\n+            let doc = extract::from_srv(srv.clone(), copy name);\n+            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n+            doc\n+        }\n+    }\n+\n+    #[test]\n+    fn should_use_markdown_file_name_based_off_crate() {\n+        let config = config::Config {\n+            output_dir: Path(\"output/dir\"),\n+            output_format: config::Markdown,\n+            output_style: config::DocPerCrate,\n+            .. config::default_config(&Path(\"input/test.rc\"))\n+        };\n+        let doc = mk_doc(~\"test\", ~\"\");\n+        let page = doc::CratePage(doc.CrateDoc());\n+        let filename = make_local_filename(config, page);\n+        assert!(filename.to_str() == ~\"output/dir/test.md\");\n+    }\n+\n+    #[test]\n+    fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n+        let config = config::Config {\n+            output_dir: Path(\"output/dir\"),\n+            output_format: config::PandocHtml,\n+            output_style: config::DocPerMod,\n+            .. config::default_config(&Path(\"input/test.rc\"))\n+        };\n+        let doc = mk_doc(~\"\", ~\"\");\n+        let page = doc::CratePage(doc.CrateDoc());\n+        let filename = make_local_filename(config, page);\n+        assert!(filename.to_str() == ~\"output/dir/index.html\");\n+    }\n+\n+    #[test]\n+    fn should_name_mod_file_names_by_path() {\n+        let config = config::Config {\n+            output_dir: Path(\"output/dir\"),\n+            output_format: config::PandocHtml,\n+            output_style: config::DocPerMod,\n+            .. config::default_config(&Path(\"input/test.rc\"))\n+        };\n+        let doc = mk_doc(~\"\", ~\"mod a { mod b { } }\");\n+        let modb = copy doc.cratemod().mods()[0].mods()[0];\n+        let page = doc::ItemPage(doc::ModTag(modb));\n+        let filename = make_local_filename(config, page);\n+        assert!(filename == Path(\"output/dir/a_b.html\"));\n+    }\n+}"}, {"sha": "c620e20530e66aeff6c869bcc842bd03ebafc444", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -149,36 +149,16 @@ fn fold_nmod(\n     return doc;\n }\n \n-#[test]\n-fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n-    let doc = test::mk_doc_(\n-        config::DocPerCrate,\n-        ~\"mod a { } mod b { mod c { } }\"\n-    );\n-    assert!(doc.pages.len() == 1u);\n-}\n-\n-#[test]\n-fn should_make_a_page_for_every_mod() {\n-    let doc = test::mk_doc(~\"mod a { }\");\n-    assert!(doc.pages.mods()[0].name() == ~\"a\");\n-}\n-\n-#[test]\n-fn should_remove_mods_from_containing_mods() {\n-    let doc = test::mk_doc(~\"mod a { }\");\n-    assert!(vec::is_empty(doc.cratemod().mods()));\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n     use config;\n     use doc;\n     use extract;\n     use page_pass::run;\n+    use core::vec;\n \n-    pub fn mk_doc_(\n+    fn mk_doc_(\n         output_style: config::OutputStyle,\n         source: ~str\n     ) -> doc::Doc {\n@@ -188,7 +168,28 @@ mod test {\n         }\n     }\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         mk_doc_(config::DocPerMod, copy source)\n     }\n+\n+    #[test]\n+    fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n+        let doc = mk_doc_(\n+            config::DocPerCrate,\n+            ~\"mod a { } mod b { mod c { } }\"\n+        );\n+        assert!(doc.pages.len() == 1u);\n+    }\n+\n+    #[test]\n+    fn should_make_a_page_for_every_mod() {\n+        let doc = mk_doc(~\"mod a { }\");\n+        assert!(doc.pages.mods()[0].name() == ~\"a\");\n+    }\n+\n+    #[test]\n+    fn should_remove_mods_from_containing_mods() {\n+        let doc = mk_doc(~\"mod a { }\");\n+        assert!(vec::is_empty(doc.cratemod().mods()));\n+    }\n }"}, {"sha": "a50f1f51765f96dcdb12df72547a465b9dde50de", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -61,25 +61,25 @@ fn is_hidden(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     }\n }\n \n-#[test]\n-fn should_prune_hidden_items() {\n-    use core::vec;\n-\n-    let doc = test::mk_doc(~\"#[doc(hidden)] mod a { }\");\n-    assert!(vec::is_empty(doc.cratemod().mods()))\n-}\n-\n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use astsrv;\n     use doc;\n     use extract;\n     use prune_hidden_pass::run;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_prune_hidden_items() {\n+        use core::vec;\n+\n+        let doc = mk_doc(~\"#[doc(hidden)] mod a { }\");\n+        assert!(vec::is_empty(doc.cratemod().mods()))\n+    }\n }"}, {"sha": "0578169e257d4e2eaf799bb249792da6b0ea0646", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -154,106 +154,106 @@ fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     }\n }\n \n-#[test]\n-fn should_prune_items_without_pub_modifier() {\n-    let doc = test::mk_doc(~\"mod a { }\");\n-    assert!(vec::is_empty(doc.cratemod().mods()));\n-}\n-\n-#[test]\n-fn should_not_prune_trait_impls() {\n-    // Impls are more complicated\n-    let doc = test::mk_doc(\n-        ~\" \\\n-          trait Foo { } \\\n-          impl Foo for int { } \\\n-          \");\n-    assert!(!doc.cratemod().impls().is_empty());\n-}\n-\n-#[test]\n-fn should_prune_associated_methods_without_vis_modifier_on_impls_without_vis_modifier() {\n-    let doc = test::mk_doc(\n-        ~\"impl Foo {\\\n-          pub fn bar() { }\\\n-          fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_priv_associated_methods_on_impls_without_vis_modifier() {\n-    let doc = test::mk_doc(\n-        ~\"impl Foo {\\\n-          pub fn bar() { }\\\n-          priv fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_priv_associated_methods_on_pub_impls() {\n-    let doc = test::mk_doc(\n-        ~\"pub impl Foo {\\\n-          fn bar() { }\\\n-          priv fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_associated_methods_without_vis_modifier_on_priv_impls() {\n-    let doc = test::mk_doc(\n-        ~\"priv impl Foo {\\\n-          pub fn bar() { }\\\n-          fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_priv_associated_methods_on_priv_impls() {\n-    let doc = test::mk_doc(\n-        ~\"priv impl Foo {\\\n-          pub fn bar() { }\\\n-          priv fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls()[0].methods.len() == 1);\n-}\n-\n-#[test]\n-fn should_prune_associated_impls_with_no_pub_methods() {\n-    let doc = test::mk_doc(\n-        ~\"priv impl Foo {\\\n-          fn baz() { }\\\n-          }\");\n-    assert!(doc.cratemod().impls().is_empty());\n-}\n-\n-#[test]\n-fn should_not_prune_associated_impls_with_pub_methods() {\n-    let doc = test::mk_doc(\n-        ~\" \\\n-          impl Foo { pub fn bar() { } } \\\n-          \");\n-    assert!(!doc.cratemod().impls().is_empty());\n-}\n-\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use astsrv;\n     use doc;\n     use extract;\n     use tystr_pass;\n     use prune_private_pass::run;\n+    use core::vec;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = tystr_pass::run(srv.clone(), doc);\n             run(srv.clone(), doc)\n         }\n     }\n-}\n \n+    #[test]\n+    fn should_prune_items_without_pub_modifier() {\n+        let doc = mk_doc(~\"mod a { }\");\n+        assert!(vec::is_empty(doc.cratemod().mods()));\n+    }\n+\n+    #[test]\n+    fn should_not_prune_trait_impls() {\n+        // Impls are more complicated\n+        let doc = mk_doc(\n+            ~\" \\\n+              trait Foo { } \\\n+              impl Foo for int { } \\\n+              \");\n+        assert!(!doc.cratemod().impls().is_empty());\n+    }\n+\n+    #[test]\n+    fn should_prune_associated_methods_without_vis_modifier_on_impls_without_vis_modifier() {\n+        let doc = mk_doc(\n+            ~\"impl Foo {\\\n+              pub fn bar() { }\\\n+              fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_priv_associated_methods_on_impls_without_vis_modifier() {\n+        let doc = mk_doc(\n+            ~\"impl Foo {\\\n+              pub fn bar() { }\\\n+              priv fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_priv_associated_methods_on_pub_impls() {\n+        let doc = mk_doc(\n+            ~\"pub impl Foo {\\\n+              fn bar() { }\\\n+              priv fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_associated_methods_without_vis_modifier_on_priv_impls() {\n+        let doc = mk_doc(\n+            ~\"priv impl Foo {\\\n+              pub fn bar() { }\\\n+              fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_priv_associated_methods_on_priv_impls() {\n+        let doc = mk_doc(\n+            ~\"priv impl Foo {\\\n+              pub fn bar() { }\\\n+              priv fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls()[0].methods.len() == 1);\n+    }\n+\n+    #[test]\n+    fn should_prune_associated_impls_with_no_pub_methods() {\n+        let doc = mk_doc(\n+            ~\"priv impl Foo {\\\n+              fn baz() { }\\\n+              }\");\n+        assert!(doc.cratemod().impls().is_empty());\n+    }\n+\n+    #[test]\n+    fn should_not_prune_associated_impls_with_pub_methods() {\n+        let doc = mk_doc(\n+            ~\" \\\n+              impl Foo { pub fn bar() { } } \\\n+              \");\n+        assert!(!doc.cratemod().impls().is_empty());\n+    }\n+}"}, {"sha": "1cf43043004cf21dab5e7334d22c7388850fdad1", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 90, "deletions": 87, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -160,106 +160,109 @@ fn parse_header(line: ~str) -> Option<~str> {\n     }\n }\n \n-#[test]\n-fn should_create_section_headers() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(str::contains(\n-        doc.cratemod().mods()[0].item.sections[0].header,\n-        ~\"Header\"));\n-}\n-\n-#[test]\n-fn should_create_section_bodies() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(str::contains(\n-        doc.cratemod().mods()[0].item.sections[0].body,\n-        ~\"Body\"));\n-}\n \n-#[test]\n-fn should_not_create_sections_from_indented_headers() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\n\\\n-         Text\\n             # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n-}\n-\n-#[test]\n-fn should_remove_section_text_from_main_desc() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         Description\\n\\n\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(!str::contains(\n-        doc.cratemod().mods()[0].desc().get(),\n-        ~\"Header\"));\n-    assert!(!str::contains(\n-        doc.cratemod().mods()[0].desc().get(),\n-        ~\"Body\"));\n-}\n-\n-#[test]\n-fn should_eliminate_desc_if_it_is_just_whitespace() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         mod a {\n-         }\");\n-    assert!(doc.cratemod().mods()[0].desc() == None);\n-}\n-\n-#[test]\n-fn should_sectionalize_trait_methods() {\n-    let doc = test::mk_doc(\n-        ~\"trait i {\n-         #[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n-}\n-\n-#[test]\n-fn should_sectionalize_impl_methods() {\n-    let doc = test::mk_doc(\n-        ~\"impl bool {\n-         #[doc = \\\"\\\n-         # Header\\n\\\n-         Body\\\"]\\\n-         fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n-}\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use astsrv;\n     use attr_pass;\n     use doc;\n     use extract;\n     use sectionalize_pass::run;\n+    use core::prelude::*;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             run(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_create_section_headers() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(str::contains(\n+            doc.cratemod().mods()[0].item.sections[0].header,\n+            ~\"Header\"));\n+    }\n+\n+    #[test]\n+    fn should_create_section_bodies() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(str::contains(\n+            doc.cratemod().mods()[0].item.sections[0].body,\n+            ~\"Body\"));\n+    }\n+\n+    #[test]\n+    fn should_not_create_sections_from_indented_headers() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\n\\\n+              Text\\n             # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n+    }\n+\n+    #[test]\n+    fn should_remove_section_text_from_main_desc() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              Description\\n\\n\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(!str::contains(\n+            doc.cratemod().mods()[0].desc().get(),\n+            ~\"Header\"));\n+        assert!(!str::contains(\n+            doc.cratemod().mods()[0].desc().get(),\n+            ~\"Body\"));\n+    }\n+\n+    #[test]\n+    fn should_eliminate_desc_if_it_is_just_whitespace() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              mod a {\n+}\");\n+        assert!(doc.cratemod().mods()[0].desc() == None);\n+    }\n+\n+    #[test]\n+    fn should_sectionalize_trait_methods() {\n+        let doc = mk_doc(\n+            ~\"trait i {\n+#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n+    }\n+\n+    #[test]\n+    fn should_sectionalize_impl_methods() {\n+        let doc = mk_doc(\n+            ~\"impl bool {\n+#[doc = \\\"\\\n+              # Header\\n\\\n+              Body\\\"]\\\n+              fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n+    }\n }"}, {"sha": "785428f00775d1796b55dca83117b87323464f1b", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 155, "deletions": 155, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -137,181 +137,181 @@ fn fold_impl(\n     }\n }\n \n-#[test]\n-fn should_execute_op_on_enum_brief() {\n-    let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    assert!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n-}\n+#[cfg(test)]\n+mod test {\n+    use astsrv;\n+    use attr_pass;\n+    use desc_to_brief_pass;\n+    use doc;\n+    use extract;\n+    use sectionalize_pass;\n+    use text_pass::mk_pass;\n \n-#[test]\n-fn should_execute_op_on_enum_desc() {\n-    let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    assert!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n-}\n+    use core::prelude::*;\n \n-#[test]\n-fn should_execute_op_on_variant_desc() {\n-    let doc = test::mk_doc(~\"enum a { #[doc = \\\" a \\\"] b }\");\n-    assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n-}\n+    fn mk_doc(source: ~str) -> doc::Doc {\n+        do astsrv::from_str(copy source) |srv| {\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n+            let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n+            (mk_pass(~\"\", |s| str::trim(s).to_owned() ).f)(srv.clone(), doc)\n+        }\n+    }\n \n-#[test]\n-fn should_execute_op_on_trait_brief() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_enum_brief() {\n+        let doc = mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n+        assert!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_trait_desc() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_enum_desc() {\n+        let doc = mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n+        assert!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_trait_method_brief() {\n-    let doc = test::mk_doc(\n-        ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_variant_desc() {\n+        let doc = mk_doc(~\"enum a { #[doc = \\\" a \\\"] b }\");\n+        assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_trait_method_desc() {\n-    let doc = test::mk_doc(\n-        ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_trait_brief() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_impl_brief() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_trait_desc() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_impl_desc() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_trait_method_brief() {\n+        let doc = mk_doc(\n+            ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_impl_method_brief() {\n-    let doc = test::mk_doc(\n-        ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_trait_method_desc() {\n+        let doc = mk_doc(\n+            ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_impl_method_desc() {\n-    let doc = test::mk_doc(\n-        ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_impl_brief() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_type_brief() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    assert!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_impl_desc() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_op_on_type_desc() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    assert!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n-}\n+    #[test]\n+    fn should_execute_op_on_impl_method_brief() {\n+        let doc = mk_doc(\n+            ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_on_item_section_headers() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         #    Header    \\n\\\n-         Body\\\"]\\\n-         fn a() { }\");\n-    assert!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n-}\n+    #[test]\n+    fn should_execute_op_on_impl_method_desc() {\n+        let doc = mk_doc(\n+            ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_on_item_section_bodies() {\n-    let doc = test::mk_doc(\n-        ~\"#[doc = \\\"\\\n-         # Header\\n\\\n-         Body      \\\"]\\\n-         fn a() { }\");\n-    assert!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n-}\n+    #[test]\n+    fn should_execute_op_on_type_brief() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] type t = int;\");\n+        assert!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_on_trait_method_section_headers() {\n-    let doc = test::mk_doc(\n-        ~\"trait i {\n-         #[doc = \\\"\\\n-         # Header    \\n\\\n-         Body\\\"]\\\n-         fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].sections[0].header\n-        == ~\"Header\");\n-}\n+    #[test]\n+    fn should_execute_op_on_type_desc() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\" a \\\"] type t = int;\");\n+        assert!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n+    }\n \n-#[test]\n-fn should_execute_on_trait_method_section_bodies() {\n-    let doc = test::mk_doc(\n-        ~\"trait i {\n-         #[doc = \\\"\\\n-         # Header\\n\\\n-         Body     \\\"]\\\n-         fn a(); }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].sections[0].body ==\n-        ~\"Body\");\n-}\n+    #[test]\n+    fn should_execute_on_item_section_headers() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              #    Header    \\n\\\n+              Body\\\"]\\\n+              fn a() { }\");\n+        assert!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n+    }\n \n-#[test]\n-fn should_execute_on_impl_method_section_headers() {\n-    let doc = test::mk_doc(\n-        ~\"impl bool {\n-         #[doc = \\\"\\\n-         # Header   \\n\\\n-         Body\\\"]\\\n-         fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].sections[0].header\n-        == ~\"Header\");\n-}\n+    #[test]\n+    fn should_execute_on_item_section_bodies() {\n+        let doc = mk_doc(\n+            ~\"#[doc = \\\"\\\n+              # Header\\n\\\n+              Body      \\\"]\\\n+              fn a() { }\");\n+        assert!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n+    }\n \n-#[test]\n-fn should_execute_on_impl_method_section_bodies() {\n-    let doc = test::mk_doc(\n-        ~\"impl bool {\n-         #[doc = \\\"\\\n-         # Header\\n\\\n-         Body    \\\"]\\\n-         fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].sections[0].body ==\n-        ~\"Body\");\n-}\n+    #[test]\n+    fn should_execute_on_trait_method_section_headers() {\n+        let doc = mk_doc(\n+            ~\"trait i {\n+#[doc = \\\"\\\n+              # Header    \\n\\\n+              Body\\\"]\\\n+              fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].sections[0].header\n+                == ~\"Header\");\n+    }\n \n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use attr_pass;\n-    use desc_to_brief_pass;\n-    use doc;\n-    use extract;\n-    use sectionalize_pass;\n-    use text_pass::mk_pass;\n+    #[test]\n+    fn should_execute_on_trait_method_section_bodies() {\n+        let doc = mk_doc(\n+            ~\"trait i {\n+#[doc = \\\"\\\n+              # Header\\n\\\n+              Body     \\\"]\\\n+              fn a(); }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].sections[0].body ==\n+                ~\"Body\");\n+    }\n \n-    use core::str;\n+    #[test]\n+    fn should_execute_on_impl_method_section_headers() {\n+        let doc = mk_doc(\n+            ~\"impl bool {\n+#[doc = \\\"\\\n+              # Header   \\n\\\n+              Body\\\"]\\\n+              fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].sections[0].header\n+                == ~\"Header\");\n+    }\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n-            (mk_pass(~\"\", |s| str::trim(s).to_owned() ).f)(srv.clone(), doc)\n-        }\n+    #[test]\n+    fn should_execute_on_impl_method_section_bodies() {\n+        let doc = mk_doc(\n+            ~\"impl bool {\n+#[doc = \\\"\\\n+              # Header\\n\\\n+              Body    \\\"]\\\n+              fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].sections[0].body ==\n+                ~\"Body\");\n     }\n }"}, {"sha": "e56a5f18ac6f7fc0b42e2ae7289e0103fc84e732", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -22,16 +22,6 @@ pub fn mk_pass() -> Pass {\n     text_pass::mk_pass(~\"trim\", |s| s.trim().to_owned() )\n }\n \n-#[test]\n-fn should_trim_text() {\n-    use core::option::Some;\n-\n-    let doc = test::mk_doc(~\"#[doc = \\\" desc \\\"] \\\n-                            mod m {\n-                            }\");\n-    assert!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n-}\n-\n #[cfg(test)]\n mod test {\n     use astsrv;\n@@ -40,11 +30,21 @@ mod test {\n     use extract;\n     use trim_pass::mk_pass;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             (mk_pass().f)(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_trim_text() {\n+        use core::option::Some;\n+\n+        let doc = mk_doc(~\"#[doc = \\\" desc \\\"] \\\n+                                 mod m {\n+}\");\n+        assert!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n+    }\n }"}, {"sha": "c0562d306398a53d980dff449754fae6655a9e59", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 156, "deletions": 155, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=ef3a8ebb9bbc55bea4e0b62a1dcb6abb5512b223", "patch": "@@ -67,35 +67,22 @@ fn fold_fn(\n fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n         match *ctxt.ast_map.get(&fn_id) {\n-          ast_map::node_item(@ast::item {\n-            ident: ident,\n-            node: ast::item_fn(ref decl, purity, _, ref tys, _), _\n-          }, _) |\n-          ast_map::node_foreign_item(@ast::foreign_item {\n-            ident: ident,\n-            node: ast::foreign_item_fn(ref decl, purity, ref tys), _\n-          }, _, _, _) => {\n-            Some(pprust::fun_to_str(decl, purity, ident, None, tys,\n-                                    extract::interner()))\n-          }\n-          _ => fail!(~\"get_fn_sig: fn_id not bound to a fn item\")\n+            ast_map::node_item(@ast::item {\n+                ident: ident,\n+                node: ast::item_fn(ref decl, purity, _, ref tys, _), _\n+            }, _) |\n+            ast_map::node_foreign_item(@ast::foreign_item {\n+                ident: ident,\n+                node: ast::foreign_item_fn(ref decl, purity, ref tys), _\n+            }, _, _, _) => {\n+                Some(pprust::fun_to_str(decl, purity, ident, None, tys,\n+                                        extract::interner()))\n+            }\n+            _ => fail!(~\"get_fn_sig: fn_id not bound to a fn item\")\n         }\n     }\n }\n \n-#[test]\n-fn should_add_fn_sig() {\n-    let doc = test::mk_doc(~\"fn a<T>() -> int { }\");\n-    assert!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n-}\n-\n-#[test]\n-fn should_add_foreign_fn_sig() {\n-    let doc = test::mk_doc(~\"extern mod a { fn a<T>() -> int; }\");\n-    assert!(doc.cratemod().nmods()[0].fns[0].sig ==\n-        Some(~\"fn a<T>() -> int\"));\n-}\n-\n fn fold_const(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::ConstDoc\n@@ -119,12 +106,6 @@ fn fold_const(\n     }\n }\n \n-#[test]\n-fn should_add_const_types() {\n-    let doc = test::mk_doc(~\"static a: bool = true;\");\n-    assert!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n-}\n-\n fn fold_enum(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::EnumDoc\n@@ -163,13 +144,6 @@ fn fold_enum(\n     }\n }\n \n-#[test]\n-fn should_add_variant_sigs() {\n-    let doc = test::mk_doc(~\"enum a { b(int) }\");\n-    assert!(doc.cratemod().enums()[0].variants[0].sig ==\n-        Some(~\"b(int)\"));\n-}\n-\n fn fold_trait(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::TraitDoc\n@@ -200,73 +174,66 @@ fn get_method_sig(\n ) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n         match *ctxt.ast_map.get(&item_id) {\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_trait(_, _, ref methods), _\n-          }, _) => {\n-            match vec::find(*methods, |method| {\n-                match copy *method {\n-                  ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n-                  ast::provided(m) => to_str(m.ident) == method_name,\n-                }\n-            }) {\n-                Some(method) => {\n-                  match method {\n-                    ast::required(ty_m) => {\n-                      Some(pprust::fun_to_str(\n-                          &ty_m.decl,\n-                          ty_m.purity,\n-                          ty_m.ident,\n-                          Some(ty_m.self_ty.node),\n-                          &ty_m.generics,\n-                          extract::interner()\n-                      ))\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_trait(_, _, ref methods), _\n+            }, _) => {\n+                match vec::find(*methods, |method| {\n+                    match copy *method {\n+                        ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n+                        ast::provided(m) => to_str(m.ident) == method_name,\n                     }\n-                    ast::provided(m) => {\n-                      Some(pprust::fun_to_str(\n-                          &m.decl,\n-                          m.purity,\n-                          m.ident,\n-                          Some(m.self_ty.node),\n-                          &m.generics,\n-                          extract::interner()\n-                      ))\n+                }) {\n+                    Some(method) => {\n+                        match method {\n+                            ast::required(ty_m) => {\n+                                Some(pprust::fun_to_str(\n+                                    &ty_m.decl,\n+                                    ty_m.purity,\n+                                    ty_m.ident,\n+                                    Some(ty_m.self_ty.node),\n+                                    &ty_m.generics,\n+                                    extract::interner()\n+                                ))\n+                            }\n+                            ast::provided(m) => {\n+                                Some(pprust::fun_to_str(\n+                                    &m.decl,\n+                                    m.purity,\n+                                    m.ident,\n+                                    Some(m.self_ty.node),\n+                                    &m.generics,\n+                                    extract::interner()\n+                                ))\n+                            }\n+                        }\n                     }\n-                  }\n+                    _ => fail!(~\"method not found\")\n                 }\n-                _ => fail!(~\"method not found\")\n             }\n-          }\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_impl(_, _, _, ref methods), _\n-          }, _) => {\n-            match vec::find(*methods, |method| {\n-                to_str(method.ident) == method_name\n-            }) {\n-                Some(method) => {\n-                    Some(pprust::fun_to_str(\n-                        &method.decl,\n-                        method.purity,\n-                        method.ident,\n-                        Some(method.self_ty.node),\n-                        &method.generics,\n-                        extract::interner()\n-                    ))\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_impl(_, _, _, ref methods), _\n+            }, _) => {\n+                match vec::find(*methods, |method| {\n+                    to_str(method.ident) == method_name\n+                }) {\n+                    Some(method) => {\n+                        Some(pprust::fun_to_str(\n+                            &method.decl,\n+                            method.purity,\n+                            method.ident,\n+                            Some(method.self_ty.node),\n+                            &method.generics,\n+                            extract::interner()\n+                        ))\n+                    }\n+                    None => fail!(~\"method not found\")\n                 }\n-                None => fail!(~\"method not found\")\n             }\n-          }\n-          _ => fail!(~\"get_method_sig: item ID not bound to trait or impl\")\n+            _ => fail!(~\"get_method_sig: item ID not bound to trait or impl\")\n         }\n     }\n }\n \n-#[test]\n-fn should_add_trait_method_sigs() {\n-    let doc = test::mk_doc(~\"trait i { fn a<T>(&mut self) -> int; }\");\n-    assert!(doc.cratemod().traits()[0].methods[0].sig\n-        == Some(~\"fn a<T>(&mut self) -> int\"));\n-}\n-\n fn fold_impl(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::ImplDoc\n@@ -305,37 +272,6 @@ fn fold_impl(\n     }\n }\n \n-#[test]\n-fn should_add_impl_bounds() {\n-    let doc = test::mk_doc(~\"impl<T, U: Copy, V: Copy + Clone> Option<T, U, V> { }\");\n-    assert!(doc.cratemod().impls()[0].bounds_str == Some(~\"<T, U: Copy, V: Copy + Clone>\"));\n-}\n-\n-#[test]\n-fn should_add_impl_trait_types() {\n-    let doc = test::mk_doc(~\"impl j for int { fn a<T>() { } }\");\n-    assert!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n-}\n-\n-#[test]\n-fn should_not_add_impl_trait_types_if_none() {\n-    let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    assert!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n-}\n-\n-#[test]\n-fn should_add_impl_self_ty() {\n-    let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    assert!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n-}\n-\n-#[test]\n-fn should_add_impl_method_sigs() {\n-    let doc = test::mk_doc(~\"impl int { fn a<T>(&self) -> int { fail!() } }\");\n-    assert!(doc.cratemod().impls()[0].methods[0].sig\n-        == Some(~\"fn a<T>(&self) -> int\"));\n-}\n-\n fn fold_type(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::TyDoc\n@@ -369,12 +305,6 @@ fn fold_type(\n     }\n }\n \n-#[test]\n-fn should_add_type_signatures() {\n-    let doc = test::mk_doc(~\"type t<T> = int;\");\n-    assert!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n-}\n-\n fn fold_struct(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::StructDoc\n@@ -422,38 +352,109 @@ fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n     }\n }\n \n-#[test]\n-fn should_add_struct_defs() {\n-    let doc = test::mk_doc(~\"struct S { field: () }\");\n-    assert!((&doc.cratemod().structs()[0].sig).get().contains(\n-        \"struct S {\"));\n-}\n-\n-#[test]\n-fn should_not_serialize_struct_drop_blocks() {\n-    // All we care about are the fields\n-    let doc = test::mk_doc(~\"struct S { field: (), drop { } }\");\n-    assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n-}\n-\n-#[test]\n-fn should_not_serialize_struct_attrs() {\n-    // All we care about are the fields\n-    let doc = test::mk_doc(~\"#[wut] struct S { field: () }\");\n-    assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n-}\n-\n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use astsrv;\n     use doc;\n     use extract;\n     use tystr_pass::run;\n+    use core::prelude::*;\n \n-    pub fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");\n             run(srv.clone(), doc)\n         }\n     }\n+\n+    #[test]\n+    fn should_add_fn_sig() {\n+        let doc = mk_doc(~\"fn a<T>() -> int { }\");\n+        assert!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_foreign_fn_sig() {\n+        let doc = mk_doc(~\"extern mod a { fn a<T>() -> int; }\");\n+        assert!(doc.cratemod().nmods()[0].fns[0].sig ==\n+                Some(~\"fn a<T>() -> int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_const_types() {\n+        let doc = mk_doc(~\"static a: bool = true;\");\n+        assert!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n+    }\n+\n+    #[test]\n+    fn should_add_variant_sigs() {\n+        let doc = mk_doc(~\"enum a { b(int) }\");\n+        assert!(doc.cratemod().enums()[0].variants[0].sig ==\n+                Some(~\"b(int)\"));\n+    }\n+\n+    #[test]\n+    fn should_add_trait_method_sigs() {\n+        let doc = mk_doc(~\"trait i { fn a<T>(&mut self) -> int; }\");\n+        assert!(doc.cratemod().traits()[0].methods[0].sig\n+                == Some(~\"fn a<T>(&mut self) -> int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_impl_bounds() {\n+        let doc = mk_doc(~\"impl<T, U: Copy, V: Copy + Clone> Option<T, U, V> { }\");\n+        assert!(doc.cratemod().impls()[0].bounds_str == Some(~\"<T, U: Copy, V: Copy + Clone>\"));\n+    }\n+\n+    #[test]\n+    fn should_add_impl_trait_types() {\n+        let doc = mk_doc(~\"impl j for int { fn a<T>() { } }\");\n+        assert!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n+    }\n+\n+    #[test]\n+    fn should_not_add_impl_trait_types_if_none() {\n+        let doc = mk_doc(~\"impl int { fn a() { } }\");\n+        assert!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n+    }\n+\n+    #[test]\n+    fn should_add_impl_self_ty() {\n+        let doc = mk_doc(~\"impl int { fn a() { } }\");\n+        assert!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_impl_method_sigs() {\n+        let doc = mk_doc(~\"impl int { fn a<T>(&self) -> int { fail!() } }\");\n+        assert!(doc.cratemod().impls()[0].methods[0].sig\n+                == Some(~\"fn a<T>(&self) -> int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_type_signatures() {\n+        let doc = mk_doc(~\"type t<T> = int;\");\n+        assert!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n+    }\n+\n+    #[test]\n+    fn should_add_struct_defs() {\n+        let doc = mk_doc(~\"struct S { field: () }\");\n+        assert!((&doc.cratemod().structs()[0].sig).get().contains(\n+            \"struct S {\"));\n+    }\n+\n+    #[test]\n+    fn should_not_serialize_struct_drop_blocks() {\n+        // All we care about are the fields\n+        let doc = mk_doc(~\"struct S { field: (), drop { } }\");\n+        assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n+    }\n+\n+    #[test]\n+    fn should_not_serialize_struct_attrs() {\n+        // All we care about are the fields\n+        let doc = mk_doc(~\"#[wut] struct S { field: () }\");\n+        assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n+    }\n }"}]}