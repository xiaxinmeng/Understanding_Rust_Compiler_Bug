{"sha": "787cd5493a1078a12587d1ce83b2ff85ac667990", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4N2NkNTQ5M2ExMDc4YTEyNTg3ZDFjZTgzYjJmZjg1YWM2Njc5OTA=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-05T19:27:00Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-07T16:48:41Z"}, "message": "Make traits::util::* free functions.", "tree": {"sha": "67f8ad2e3ec67c36e97dd73033d7b0572732369c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67f8ad2e3ec67c36e97dd73033d7b0572732369c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/787cd5493a1078a12587d1ce83b2ff85ac667990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/787cd5493a1078a12587d1ce83b2ff85ac667990", "html_url": "https://github.com/rust-lang/rust/commit/787cd5493a1078a12587d1ce83b2ff85ac667990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/787cd5493a1078a12587d1ce83b2ff85ac667990/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56a0aec07fa998e43702216a7e18133af481c076", "url": "https://api.github.com/repos/rust-lang/rust/commits/56a0aec07fa998e43702216a7e18133af481c076", "html_url": "https://github.com/rust-lang/rust/commit/56a0aec07fa998e43702216a7e18133af481c076"}], "stats": {"total": 363, "additions": 189, "deletions": 174}, "files": [{"sha": "a2ccfc5de8abccb5aacaf5ba569da38a0ed1f596", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -64,6 +64,10 @@ pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n+pub use self::util::{\n+    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n+    predicate_for_trait_def, upcast_choices,\n+};\n pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n };"}, {"sha": "79e1b6444a9b717ee7121501c96db7105d4e9a69", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -1057,7 +1057,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     node_item.item.defaultness.has_value()\n                 } else {\n                     node_item.item.defaultness.is_default()\n-                        || selcx.tcx().impl_is_default(node_item.node.def_id())\n+                        || super::util::impl_is_default(selcx.tcx(), node_item.node.def_id())\n                 };\n \n                 // Only reveal a specializable default if we're past type-checking\n@@ -1263,26 +1263,30 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n \n     let gen_def_id = tcx.lang_items().gen_trait().unwrap();\n \n-    let predicate = tcx\n-        .generator_trait_ref_and_outputs(gen_def_id, obligation.predicate.self_ty(), gen_sig)\n-        .map_bound(|(trait_ref, yield_ty, return_ty)| {\n-            let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n-            let ty = if name == sym::Return {\n-                return_ty\n-            } else if name == sym::Yield {\n-                yield_ty\n-            } else {\n-                bug!()\n-            };\n+    let predicate = super::util::generator_trait_ref_and_outputs(\n+        tcx,\n+        gen_def_id,\n+        obligation.predicate.self_ty(),\n+        gen_sig,\n+    )\n+    .map_bound(|(trait_ref, yield_ty, return_ty)| {\n+        let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n+        let ty = if name == sym::Return {\n+            return_ty\n+        } else if name == sym::Yield {\n+            yield_ty\n+        } else {\n+            bug!()\n+        };\n \n-            ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy {\n-                    substs: trait_ref.substs,\n-                    item_def_id: obligation.predicate.item_def_id,\n-                },\n-                ty: ty,\n-            }\n-        });\n+        ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                substs: trait_ref.substs,\n+                item_def_id: obligation.predicate.item_def_id,\n+            },\n+            ty: ty,\n+        }\n+    });\n \n     confirm_param_env_candidate(selcx, obligation, predicate)\n         .with_addl_obligations(vtable.nested)\n@@ -1349,21 +1353,21 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n     // the `Output` associated type is declared on `FnOnce`\n     let fn_once_def_id = tcx.lang_items().fn_once_trait().unwrap();\n \n-    let predicate = tcx\n-        .closure_trait_ref_and_return_type(\n-            fn_once_def_id,\n-            obligation.predicate.self_ty(),\n-            fn_sig,\n-            flag,\n-        )\n-        .map_bound(|(trait_ref, ret_type)| ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy::from_ref_and_name(\n-                tcx,\n-                trait_ref,\n-                Ident::with_dummy_span(FN_OUTPUT_NAME),\n-            ),\n-            ty: ret_type,\n-        });\n+    let predicate = super::util::closure_trait_ref_and_return_type(\n+        tcx,\n+        fn_once_def_id,\n+        obligation.predicate.self_ty(),\n+        fn_sig,\n+        flag,\n+    )\n+    .map_bound(|(trait_ref, ret_type)| ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy::from_ref_and_name(\n+            tcx,\n+            trait_ref,\n+            Ident::with_dummy_span(FN_OUTPUT_NAME),\n+        ),\n+        ty: ret_type,\n+    });\n \n     confirm_param_env_candidate(selcx, obligation, predicate)\n }"}, {"sha": "3a9ed633740bfaf3537211f732c74fa1f2b610e3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -11,6 +11,7 @@ use super::coherence::{self, Conflict};\n use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::util;\n+use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::DerivedObligationCause;\n use super::Selection;\n use super::SelectionResult;\n@@ -2651,7 +2652,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             recursion_depth,\n                             &skol_ty,\n                         );\n-                    let skol_obligation = self.tcx().predicate_for_trait_def(\n+                    let skol_obligation = predicate_for_trait_def(\n+                        self.tcx(),\n                         param_env,\n                         cause.clone(),\n                         trait_def_id,\n@@ -2988,7 +2990,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // we pass over, we sum up the set of number of vtable\n             // entries, so that we can compute the offset for the selected\n             // trait.\n-            vtable_base = nonmatching.map(|t| tcx.count_own_vtable_entries(t)).sum();\n+            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n         }\n \n         VtableObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n@@ -3003,15 +3005,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder; it is reintroduced below.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n-        let trait_ref = self\n-            .tcx()\n-            .closure_trait_ref_and_return_type(\n-                obligation.predicate.def_id(),\n-                self_ty,\n-                sig,\n-                util::TupleArgumentsFlag::Yes,\n-            )\n-            .map_bound(|(trait_ref, _)| trait_ref);\n+        let trait_ref = closure_trait_ref_and_return_type(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            self_ty,\n+            sig,\n+            util::TupleArgumentsFlag::Yes,\n+        )\n+        .map_bound(|(trait_ref, _)| trait_ref);\n \n         let Normalized { value: trait_ref, obligations } = project::normalize_with_depth(\n             self,\n@@ -3381,7 +3382,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested.extend(obligations);\n \n                 // Construct the nested `Field<T>: Unsize<Field<U>>` predicate.\n-                nested.push(tcx.predicate_for_trait_def(\n+                nested.push(predicate_for_trait_def(\n+                    tcx,\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n@@ -3416,7 +3418,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested.extend(obligations);\n \n                 // Construct the nested `T: Unsize<U>` predicate.\n-                nested.push(tcx.predicate_for_trait_def(\n+                nested.push(predicate_for_trait_def(\n+                    tcx,\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n@@ -3627,14 +3630,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // in fact unparameterized (or at least does not reference any\n         // regions bound in the obligation). Still probably some\n         // refactoring could make this nicer.\n-        self.tcx()\n-            .closure_trait_ref_and_return_type(\n-                obligation.predicate.def_id(),\n-                obligation.predicate.skip_binder().self_ty(), // (1)\n-                closure_type,\n-                util::TupleArgumentsFlag::No,\n-            )\n-            .map_bound(|(trait_ref, _)| trait_ref)\n+        closure_trait_ref_and_return_type(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            obligation.predicate.skip_binder().self_ty(), // (1)\n+            closure_type,\n+            util::TupleArgumentsFlag::No,\n+        )\n+        .map_bound(|(trait_ref, _)| trait_ref)\n     }\n \n     fn generator_trait_ref_unnormalized(\n@@ -3651,13 +3654,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // regions bound in the obligation). Still probably some\n         // refactoring could make this nicer.\n \n-        self.tcx()\n-            .generator_trait_ref_and_outputs(\n-                obligation.predicate.def_id(),\n-                obligation.predicate.skip_binder().self_ty(), // (1)\n-                gen_sig,\n-            )\n-            .map_bound(|(trait_ref, ..)| trait_ref)\n+        super::util::generator_trait_ref_and_outputs(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            obligation.predicate.skip_binder().self_ty(), // (1)\n+            gen_sig,\n+        )\n+        .map_bound(|(trait_ref, ..)| trait_ref)\n     }\n \n     /// Returns the obligations that are implied by instantiating an"}, {"sha": "8355239af87a4a5d785e3a68fd11d48dfd0a7f08", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 100, "deletions": 102, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -548,123 +548,121 @@ pub fn predicate_for_trait_ref<'tcx>(\n     Obligation { cause, param_env, recursion_depth, predicate: trait_ref.to_predicate() }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn predicate_for_trait_def(\n-        self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-        trait_def_id: DefId,\n-        recursion_depth: usize,\n-        self_ty: Ty<'tcx>,\n-        params: &[GenericArg<'tcx>],\n-    ) -> PredicateObligation<'tcx> {\n-        let trait_ref =\n-            ty::TraitRef { def_id: trait_def_id, substs: self.mk_substs_trait(self_ty, params) };\n-        predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n-    }\n-\n-    /// Casts a trait reference into a reference to one of its super\n-    /// traits; returns `None` if `target_trait_def_id` is not a\n-    /// supertrait.\n-    pub fn upcast_choices(\n-        self,\n-        source_trait_ref: ty::PolyTraitRef<'tcx>,\n-        target_trait_def_id: DefId,\n-    ) -> Vec<ty::PolyTraitRef<'tcx>> {\n-        if source_trait_ref.def_id() == target_trait_def_id {\n-            return vec![source_trait_ref]; // Shortcut the most common case.\n-        }\n+pub fn predicate_for_trait_def(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    trait_def_id: DefId,\n+    recursion_depth: usize,\n+    self_ty: Ty<'tcx>,\n+    params: &[GenericArg<'tcx>],\n+) -> PredicateObligation<'tcx> {\n+    let trait_ref =\n+        ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(self_ty, params) };\n+    predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n+}\n \n-        supertraits(self, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n+/// Casts a trait reference into a reference to one of its super\n+/// traits; returns `None` if `target_trait_def_id` is not a\n+/// supertrait.\n+pub fn upcast_choices(\n+    tcx: TyCtxt<'tcx>,\n+    source_trait_ref: ty::PolyTraitRef<'tcx>,\n+    target_trait_def_id: DefId,\n+) -> Vec<ty::PolyTraitRef<'tcx>> {\n+    if source_trait_ref.def_id() == target_trait_def_id {\n+        return vec![source_trait_ref]; // Shortcut the most common case.\n     }\n \n-    /// Given a trait `trait_ref`, returns the number of vtable entries\n-    /// that come from `trait_ref`, excluding its supertraits. Used in\n-    /// computing the vtable base for an upcast trait of a trait object.\n-    pub fn count_own_vtable_entries(self, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n-        let mut entries = 0;\n-        // Count number of methods and add them to the total offset.\n-        // Skip over associated types and constants.\n-        for trait_item in self.associated_items(trait_ref.def_id()) {\n-            if trait_item.kind == ty::AssocKind::Method {\n-                entries += 1;\n-            }\n+    supertraits(tcx, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n+}\n+\n+/// Given a trait `trait_ref`, returns the number of vtable entries\n+/// that come from `trait_ref`, excluding its supertraits. Used in\n+/// computing the vtable base for an upcast trait of a trait object.\n+pub fn count_own_vtable_entries(tcx: TyCtxt<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n+    let mut entries = 0;\n+    // Count number of methods and add them to the total offset.\n+    // Skip over associated types and constants.\n+    for trait_item in tcx.associated_items(trait_ref.def_id()) {\n+        if trait_item.kind == ty::AssocKind::Method {\n+            entries += 1;\n         }\n-        entries\n     }\n+    entries\n+}\n \n-    /// Given an upcast trait object described by `object`, returns the\n-    /// index of the method `method_def_id` (which should be part of\n-    /// `object.upcast_trait_ref`) within the vtable for `object`.\n-    pub fn get_vtable_index_of_object_method<N>(\n-        self,\n-        object: &super::VtableObjectData<'tcx, N>,\n-        method_def_id: DefId,\n-    ) -> usize {\n-        // Count number of methods preceding the one we are selecting and\n-        // add them to the total offset.\n-        // Skip over associated types and constants.\n-        let mut entries = object.vtable_base;\n-        for trait_item in self.associated_items(object.upcast_trait_ref.def_id()) {\n-            if trait_item.def_id == method_def_id {\n-                // The item with the ID we were given really ought to be a method.\n-                assert_eq!(trait_item.kind, ty::AssocKind::Method);\n-                return entries;\n-            }\n-            if trait_item.kind == ty::AssocKind::Method {\n-                entries += 1;\n-            }\n+/// Given an upcast trait object described by `object`, returns the\n+/// index of the method `method_def_id` (which should be part of\n+/// `object.upcast_trait_ref`) within the vtable for `object`.\n+pub fn get_vtable_index_of_object_method<N>(\n+    tcx: TyCtxt<'tcx>,\n+    object: &super::VtableObjectData<'tcx, N>,\n+    method_def_id: DefId,\n+) -> usize {\n+    // Count number of methods preceding the one we are selecting and\n+    // add them to the total offset.\n+    // Skip over associated types and constants.\n+    let mut entries = object.vtable_base;\n+    for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()) {\n+        if trait_item.def_id == method_def_id {\n+            // The item with the ID we were given really ought to be a method.\n+            assert_eq!(trait_item.kind, ty::AssocKind::Method);\n+            return entries;\n+        }\n+        if trait_item.kind == ty::AssocKind::Method {\n+            entries += 1;\n         }\n-\n-        bug!(\"get_vtable_index_of_object_method: {:?} was not found\", method_def_id);\n     }\n \n-    pub fn closure_trait_ref_and_return_type(\n-        self,\n-        fn_trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        sig: ty::PolyFnSig<'tcx>,\n-        tuple_arguments: TupleArgumentsFlag,\n-    ) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)> {\n-        let arguments_tuple = match tuple_arguments {\n-            TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n-            TupleArgumentsFlag::Yes => self.intern_tup(sig.skip_binder().inputs()),\n-        };\n-        let trait_ref = ty::TraitRef {\n-            def_id: fn_trait_def_id,\n-            substs: self.mk_substs_trait(self_ty, &[arguments_tuple.into()]),\n-        };\n-        ty::Binder::bind((trait_ref, sig.skip_binder().output()))\n-    }\n+    bug!(\"get_vtable_index_of_object_method: {:?} was not found\", method_def_id);\n+}\n \n-    pub fn generator_trait_ref_and_outputs(\n-        self,\n-        fn_trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        sig: ty::PolyGenSig<'tcx>,\n-    ) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n-        let trait_ref =\n-            ty::TraitRef { def_id: fn_trait_def_id, substs: self.mk_substs_trait(self_ty, &[]) };\n-        ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n-    }\n+pub fn closure_trait_ref_and_return_type(\n+    tcx: TyCtxt<'tcx>,\n+    fn_trait_def_id: DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: ty::PolyFnSig<'tcx>,\n+    tuple_arguments: TupleArgumentsFlag,\n+) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)> {\n+    let arguments_tuple = match tuple_arguments {\n+        TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n+        TupleArgumentsFlag::Yes => tcx.intern_tup(sig.skip_binder().inputs()),\n+    };\n+    let trait_ref = ty::TraitRef {\n+        def_id: fn_trait_def_id,\n+        substs: tcx.mk_substs_trait(self_ty, &[arguments_tuple.into()]),\n+    };\n+    ty::Binder::bind((trait_ref, sig.skip_binder().output()))\n+}\n \n-    pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n-        match self.hir().as_local_hir_id(node_item_def_id) {\n-            Some(hir_id) => {\n-                let item = self.hir().expect_item(hir_id);\n-                if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.kind {\n-                    defaultness.is_default()\n-                } else {\n-                    false\n-                }\n+pub fn generator_trait_ref_and_outputs(\n+    tcx: TyCtxt<'tcx>,\n+    fn_trait_def_id: DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: ty::PolyGenSig<'tcx>,\n+) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n+    let trait_ref =\n+        ty::TraitRef { def_id: fn_trait_def_id, substs: tcx.mk_substs_trait(self_ty, &[]) };\n+    ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n+}\n+\n+pub fn impl_is_default(tcx: TyCtxt<'_>, node_item_def_id: DefId) -> bool {\n+    match tcx.hir().as_local_hir_id(node_item_def_id) {\n+        Some(hir_id) => {\n+            let item = tcx.hir().expect_item(hir_id);\n+            if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.kind {\n+                defaultness.is_default()\n+            } else {\n+                false\n             }\n-            None => self.impl_defaultness(node_item_def_id).is_default(),\n         }\n+        None => tcx.impl_defaultness(node_item_def_id).is_default(),\n     }\n+}\n \n-    pub fn impl_item_is_final(self, assoc_item: &ty::AssocItem) -> bool {\n-        assoc_item.defaultness.is_final() && !self.impl_is_default(assoc_item.container.id())\n-    }\n+pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n+    assoc_item.defaultness.is_final() && !impl_is_default(tcx, assoc_item.container.id())\n }\n \n pub enum TupleArgumentsFlag {"}, {"sha": "9be50d19a5030e45b0e56a959ab9cff5ac1945c6", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -411,7 +411,7 @@ fn resolve_associated_item<'tcx>(\n             substs: rcvr_substs,\n         }),\n         traits::VtableObject(ref data) => {\n-            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n+            let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n             Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n         }\n         traits::VtableBuiltin(..) => {"}, {"sha": "9631f8004f6a383b4342256d59a198cc26759e7e", "filename": "src/librustc_mir/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -3,6 +3,7 @@ use crate::const_eval::const_variant_index;\n use rustc::infer::InferCtxt;\n use rustc::lint;\n use rustc::mir::Field;\n+use rustc::traits::predicate_for_trait_def;\n use rustc::traits::{ObligationCause, PredicateObligation};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n@@ -129,7 +130,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // not *yet* implement `PartialEq`. So for now we leave this here.\n                 let ty_is_partial_eq: bool = {\n                     let partial_eq_trait_id = self.tcx().lang_items().eq_trait().unwrap();\n-                    let obligation: PredicateObligation<'_> = self.tcx().predicate_for_trait_def(\n+                    let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n+                        self.tcx(),\n                         self.param_env,\n                         ObligationCause::misc(self.span, self.id),\n                         partial_eq_trait_id,"}, {"sha": "36ad6ea1bc9955f834eaadc042a367335721ea5f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -544,7 +544,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // and almost never more than 3. By using a SmallVec we avoid an\n         // allocation, at the (very small) cost of (occasionally) having to\n         // shift subsequent elements down when removing the front element.\n-        let mut queue: SmallVec<[_; 4]> = smallvec![self.tcx.predicate_for_trait_def(\n+        let mut queue: SmallVec<[_; 4]> = smallvec![traits::predicate_for_trait_def(\n+            self.tcx,\n             self.fcx.param_env,\n             cause,\n             coerce_unsized_did,"}, {"sha": "636ea5b87d6596ff64af85eda498138d588270ea", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -596,7 +596,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         target_trait_def_id: DefId,\n     ) -> ty::PolyTraitRef<'tcx> {\n         let upcast_trait_refs =\n-            self.tcx.upcast_choices(source_trait_ref.clone(), target_trait_def_id);\n+            traits::upcast_choices(self.tcx, source_trait_ref.clone(), target_trait_def_id);\n \n         // must be exactly one trait ref or we'd get an ambig error etc\n         if upcast_trait_refs.len() != 1 {"}, {"sha": "647c56112b24968e855f4106a9c9972bcfe90663", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -1901,7 +1901,7 @@ fn check_specialization_validity<'tcx>(\n         match parent_item {\n             // Parent impl exists, and contains the parent item we're trying to specialize, but\n             // doesn't mark it `default`.\n-            Some(parent_item) if tcx.impl_item_is_final(&parent_item) => {\n+            Some(parent_item) if traits::impl_item_is_final(tcx, &parent_item) => {\n                 Some(Err(parent_impl.def_id()))\n             }\n \n@@ -1912,7 +1912,7 @@ fn check_specialization_validity<'tcx>(\n             // grandparent. In that case, if parent is a `default impl`, inherited items use the\n             // \"defaultness\" from the grandparent, else they are final.\n             None => {\n-                if tcx.impl_is_default(parent_impl.def_id()) {\n+                if traits::impl_is_default(tcx, parent_impl.def_id()) {\n                     None\n                 } else {\n                     Some(Err(parent_impl.def_id()))\n@@ -2076,7 +2076,7 @@ fn check_impl_items_against_trait<'tcx>(\n             .map(|node_item| !node_item.node.is_from_trait())\n             .unwrap_or(false);\n \n-        if !is_implemented && !tcx.impl_is_default(impl_id) {\n+        if !is_implemented && !traits::impl_is_default(tcx, impl_id) {\n             if !trait_item.defaultness.has_value() {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {"}, {"sha": "5a80b762f745a8613c29d13e65cde14107210b5f", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787cd5493a1078a12587d1ce83b2ff85ac667990/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=787cd5493a1078a12587d1ce83b2ff85ac667990", "patch": "@@ -7,6 +7,7 @@ use rustc::middle::lang_items::UnsizeTraitLangItem;\n use rustc::middle::region;\n \n use rustc::infer;\n+use rustc::traits::predicate_for_trait_def;\n use rustc::traits::{self, ObligationCause, TraitEngine};\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n use rustc::ty::util::CopyImplementationError;\n@@ -284,7 +285,8 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n                         let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n \n                         for field in coerced_fields {\n-                            let predicate = tcx.predicate_for_trait_def(\n+                            let predicate = predicate_for_trait_def(\n+                                tcx,\n                                 param_env,\n                                 cause.clone(),\n                                 dispatch_from_dyn_trait,\n@@ -543,7 +545,8 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-        let predicate = tcx.predicate_for_trait_def(\n+        let predicate = predicate_for_trait_def(\n+            tcx,\n             param_env,\n             cause,\n             trait_def_id,"}]}