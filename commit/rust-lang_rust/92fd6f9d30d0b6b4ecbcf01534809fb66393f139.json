{"sha": "92fd6f9d30d0b6b4ecbcf01534809fb66393f139", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZmQ2ZjlkMzBkMGI2YjRlY2JjZjAxNTM0ODA5ZmI2NjM5M2YxMzk=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-01-17T23:00:51Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-01-18T00:40:43Z"}, "message": "Inline `expand_node`.\n\nThis requires restructuring things a little so that there is only one\ncallsite, ensuring that inlinining doesn't cause unnecessary code bloat.\n\nThis reduces instruction counts for the `unicode_normalization`\nbenchmark by up to 4%.", "tree": {"sha": "dd09e0c22e265d8a27823dce17dd1fb62246e6a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd09e0c22e265d8a27823dce17dd1fb62246e6a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92fd6f9d30d0b6b4ecbcf01534809fb66393f139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92fd6f9d30d0b6b4ecbcf01534809fb66393f139", "html_url": "https://github.com/rust-lang/rust/commit/92fd6f9d30d0b6b4ecbcf01534809fb66393f139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92fd6f9d30d0b6b4ecbcf01534809fb66393f139/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55768330a9046d240c5e542419d808626106a0aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/55768330a9046d240c5e542419d808626106a0aa", "html_url": "https://github.com/rust-lang/rust/commit/55768330a9046d240c5e542419d808626106a0aa"}], "stats": {"total": 23, "additions": 14, "deletions": 9}, "files": [{"sha": "545192a1f211355135b2ddf9189791bc6a9fa027", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/92fd6f9d30d0b6b4ecbcf01534809fb66393f139/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fd6f9d30d0b6b4ecbcf01534809fb66393f139/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=92fd6f9d30d0b6b4ecbcf01534809fb66393f139", "patch": "@@ -188,32 +188,37 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={:?}\", constraint);\n-            match *constraint {\n+            let (a_region, b_vid, b_data, retain) = match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n-                    (self.expand_node(a_region, b_vid, b_data), false)\n+                    (a_region, b_vid, b_data, false)\n                 }\n                 Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n-                    VarValue::ErrorValue => (false, false),\n+                    VarValue::ErrorValue => return (false, false),\n                     VarValue::Value(a_region) => {\n-                        let b_node = var_values.value_mut(b_vid);\n-                        let changed = self.expand_node(a_region, b_vid, b_node);\n-                        let retain = match *b_node {\n+                        let b_data = var_values.value_mut(b_vid);\n+                        let retain = match *b_data {\n                             VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n                             _ => true\n                         };\n-                        (changed, retain)\n+                        (a_region, b_vid, b_data, retain)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n-                    (false, false)\n+                    return (false, false)\n                 }\n-            }\n+            };\n+\n+            let changed = self.expand_node(a_region, b_vid, b_data);\n+            (changed, retain)\n         })\n     }\n \n+    // This function is very hot in some workloads. There's a single callsite\n+    // so always inlining is ok even though it's large.\n+    #[inline(always)]\n     fn expand_node(\n         &self,\n         a_region: Region<'tcx>,"}]}