{"sha": "955549955f0143191de9c68ea4bee01823ebebf7", "node_id": "C_kwDOAAsO6NoAKDk1NTU0OTk1NWYwMTQzMTkxZGU5YzY4ZWE0YmVlMDE4MjNlYmViZjc", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-03-07T07:08:25Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-03-08T06:33:38Z"}, "message": "Check that a query has not completed and is not executing before starting it", "tree": {"sha": "82052e84c698296b89b5bbdfa3fbaa4523a2ff90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82052e84c698296b89b5bbdfa3fbaa4523a2ff90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/955549955f0143191de9c68ea4bee01823ebebf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/955549955f0143191de9c68ea4bee01823ebebf7", "html_url": "https://github.com/rust-lang/rust/commit/955549955f0143191de9c68ea4bee01823ebebf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/955549955f0143191de9c68ea4bee01823ebebf7/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38b96553112dce3de630890701f17d86e265f6ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/38b96553112dce3de630890701f17d86e265f6ba", "html_url": "https://github.com/rust-lang/rust/commit/38b96553112dce3de630890701f17d86e265f6ba"}], "stats": {"total": 27, "additions": 21, "deletions": 6}, "files": [{"sha": "7588b651587e3d947f53a43ed08981bb20d8ce51", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/955549955f0143191de9c68ea4bee01823ebebf7/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955549955f0143191de9c68ea4bee01823ebebf7/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=955549955f0143191de9c68ea4bee01823ebebf7", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::profiling::TimingGuard;\n #[cfg(parallel_compiler)]\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n@@ -178,16 +178,13 @@ where\n     fn try_start<'b, Qcx>(\n         qcx: &'b Qcx,\n         state: &'b QueryState<K, Qcx::DepKind>,\n+        mut state_lock: LockGuard<'b, FxHashMap<K, QueryResult<Qcx::DepKind>>>,\n         span: Span,\n         key: K,\n     ) -> TryGetJob<'b, K, D>\n     where\n         Qcx: QueryContext + HasDepContext<DepKind = D>,\n     {\n-        #[cfg(parallel_compiler)]\n-        let mut state_lock = state.active.get_shard_by_value(&key).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut state_lock = state.active.lock();\n         let lock = &mut *state_lock;\n         let current_job_id = qcx.current_query_job();\n \n@@ -362,7 +359,25 @@ where\n     Qcx: QueryContext,\n {\n     let state = query.query_state(qcx);\n-    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, span, key) {\n+    #[cfg(parallel_compiler)]\n+    let state_lock = state.active.get_shard_by_value(&key).lock();\n+    #[cfg(not(parallel_compiler))]\n+    let state_lock = state.active.lock();\n+\n+    // For the parallel compiler we need to check both the query cache and query state structures\n+    // while holding the state lock to ensure that 1) the query has not yet completed and 2) the\n+    // query is not still executing. Without checking the query cache here, we can end up\n+    // re-executing the query since `try_start` only checks that the query is not currently\n+    // executing, but another thread may have already completed the query and stores it result\n+    // in the query cache.\n+    if cfg!(parallel_compiler) && qcx.dep_context().sess().threads() > 1 {\n+        if let Some((value, index)) = query.query_cache(qcx).lookup(&key) {\n+            qcx.dep_context().profiler().query_cache_hit(index.into());\n+            return (value, Some(index));\n+        }\n+    }\n+\n+    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, state_lock, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n             let (result, dep_node_index) = execute_job(query, qcx, key.clone(), dep_node, job.id);\n             let cache = query.query_cache(qcx);"}]}