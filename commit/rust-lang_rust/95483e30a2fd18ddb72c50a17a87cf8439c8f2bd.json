{"sha": "95483e30a2fd18ddb72c50a17a87cf8439c8f2bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NDgzZTMwYTJmZDE4ZGRiNzJjNTBhMTdhODdjZjg0MzljOGYyYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-08T08:26:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-08T08:26:30Z"}, "message": "auto merge of #12086 : huonw/rust/safe-json, r=kballard\n\nThe lexer and json were using `transmute(-1): char` as a sentinel value for EOF, which is invalid since `char` is strictly a unicode codepoint.\r\n\r\nFixing this allows for range asserts on chars since they always lie between 0 and 0x10FFFF.", "tree": {"sha": "4510ca2aed050f97a950954d5ba0d8b14cd0d066", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4510ca2aed050f97a950954d5ba0d8b14cd0d066"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd", "html_url": "https://github.com/rust-lang/rust/commit/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2c1a8164905e4130200287d5c38063f242a2ab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c1a8164905e4130200287d5c38063f242a2ab1", "html_url": "https://github.com/rust-lang/rust/commit/b2c1a8164905e4130200287d5c38063f242a2ab1"}, {"sha": "5e2de79b3054a815a45b9f4c641d7f1356f2291b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e2de79b3054a815a45b9f4c641d7f1356f2291b", "html_url": "https://github.com/rust-lang/rust/commit/5e2de79b3054a815a45b9f4c641d7f1356f2291b"}], "stats": {"total": 557, "additions": 301, "deletions": 256}, "files": [{"sha": "3938f1a89942b6593492bb653d3543592ebd45c8", "filename": "src/libextra/json.rs", "status": "modified", "additions": 139, "deletions": 139, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=95483e30a2fd18ddb72c50a17a87cf8439c8f2bd", "patch": "@@ -229,7 +229,6 @@ fn main() {\n */\n \n use std::char;\n-use std::cast::transmute;\n use std::f64;\n use std::hashmap::HashMap;\n use std::io;\n@@ -718,7 +717,7 @@ impl Json {\n \n pub struct Parser<T> {\n     priv rdr: T,\n-    priv ch: char,\n+    priv ch: Option<char>,\n     priv line: uint,\n     priv col: uint,\n }\n@@ -728,7 +727,7 @@ impl<T: Iterator<char>> Parser<T> {\n     pub fn new(rdr: T) -> Parser<T> {\n         let mut p = Parser {\n             rdr: rdr,\n-            ch: '\\x00',\n+            ch: Some('\\x00'),\n             line: 1,\n             col: 0,\n         };\n@@ -756,27 +755,26 @@ impl<T: Iterator<char>> Parser<T> {\n }\n \n impl<T : Iterator<char>> Parser<T> {\n-    // FIXME: #8971: unsound\n-    fn eof(&self) -> bool { self.ch == unsafe { transmute(-1u32) } }\n-\n+    fn eof(&self) -> bool { self.ch.is_none() }\n+    fn ch_or_null(&self) -> char { self.ch.unwrap_or('\\x00') }\n     fn bump(&mut self) {\n-        match self.rdr.next() {\n-            Some(ch) => self.ch = ch,\n-            None() => self.ch = unsafe { transmute(-1u32) }, // FIXME: #8971: unsound\n-        }\n+        self.ch = self.rdr.next();\n \n-        if self.ch == '\\n' {\n+        if self.ch_is('\\n') {\n             self.line += 1u;\n             self.col = 1u;\n         } else {\n             self.col += 1u;\n         }\n     }\n \n-    fn next_char(&mut self) -> char {\n+    fn next_char(&mut self) -> Option<char> {\n         self.bump();\n         self.ch\n     }\n+    fn ch_is(&self, c: char) -> bool {\n+        self.ch == Some(c)\n+    }\n \n     fn error<T>(&self, msg: ~str) -> Result<T, Error> {\n         Err(Error { line: self.line, col: self.col, msg: msg })\n@@ -787,31 +785,32 @@ impl<T : Iterator<char>> Parser<T> {\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n \n-        match self.ch {\n-          'n' => self.parse_ident(\"ull\", Null),\n-          't' => self.parse_ident(\"rue\", Boolean(true)),\n-          'f' => self.parse_ident(\"alse\", Boolean(false)),\n-          '0' .. '9' | '-' => self.parse_number(),\n-          '\"' =>\n-            match self.parse_str() {\n-              Ok(s) => Ok(String(s)),\n-              Err(e) => Err(e),\n+        match self.ch_or_null() {\n+            'n' => self.parse_ident(\"ull\", Null),\n+            't' => self.parse_ident(\"rue\", Boolean(true)),\n+            'f' => self.parse_ident(\"alse\", Boolean(false)),\n+            '0' .. '9' | '-' => self.parse_number(),\n+            '\"' => {\n+                match self.parse_str() {\n+                    Ok(s) => Ok(String(s)),\n+                    Err(e) => Err(e),\n+                }\n             },\n-          '[' => self.parse_list(),\n-          '{' => self.parse_object(),\n-          _ => self.error(~\"invalid syntax\")\n+            '[' => self.parse_list(),\n+            '{' => self.parse_object(),\n+            _ => self.error(~\"invalid syntax\"),\n         }\n     }\n \n     fn parse_whitespace(&mut self) {\n-        while self.ch == ' ' ||\n-              self.ch == '\\n' ||\n-              self.ch == '\\t' ||\n-              self.ch == '\\r' { self.bump(); }\n+        while self.ch_is(' ') ||\n+              self.ch_is('\\n') ||\n+              self.ch_is('\\t') ||\n+              self.ch_is('\\r') { self.bump(); }\n     }\n \n     fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n-        if ident.chars().all(|c| c == self.next_char()) {\n+        if ident.chars().all(|c| Some(c) == self.next_char()) {\n             self.bump();\n             Ok(value)\n         } else {\n@@ -822,7 +821,7 @@ impl<T : Iterator<char>> Parser<T> {\n     fn parse_number(&mut self) -> Result<Json, Error> {\n         let mut neg = 1.0;\n \n-        if self.ch == '-' {\n+        if self.ch_is('-') {\n             self.bump();\n             neg = -1.0;\n         }\n@@ -832,14 +831,14 @@ impl<T : Iterator<char>> Parser<T> {\n           Err(e) => return Err(e)\n         };\n \n-        if self.ch == '.' {\n+        if self.ch_is('.') {\n             match self.parse_decimal(res) {\n               Ok(r) => res = r,\n               Err(e) => return Err(e)\n             }\n         }\n \n-        if self.ch == 'e' || self.ch == 'E' {\n+        if self.ch_is('e') || self.ch_is('E') {\n             match self.parse_exponent(res) {\n               Ok(r) => res = r,\n               Err(e) => return Err(e)\n@@ -852,55 +851,54 @@ impl<T : Iterator<char>> Parser<T> {\n     fn parse_integer(&mut self) -> Result<f64, Error> {\n         let mut res = 0.0;\n \n-        match self.ch {\n-          '0' => {\n-            self.bump();\n-\n-            // There can be only one leading '0'.\n-            match self.ch {\n-              '0' .. '9' => return self.error(~\"invalid number\"),\n-              _ => ()\n-            }\n-          }\n-          '1' .. '9' => {\n-            while !self.eof() {\n-                match self.ch {\n-                  '0' .. '9' => {\n-                    res *= 10.0;\n-                    res += ((self.ch as int) - ('0' as int)) as f64;\n+        match self.ch_or_null() {\n+            '0' => {\n+                self.bump();\n \n-                    self.bump();\n-                  }\n-                  _ => break\n+                // There can be only one leading '0'.\n+                match self.ch_or_null() {\n+                    '0' .. '9' => return self.error(~\"invalid number\"),\n+                    _ => ()\n+                }\n+            },\n+            '1' .. '9' => {\n+                while !self.eof() {\n+                    match self.ch_or_null() {\n+                        c @ '0' .. '9' => {\n+                            res *= 10.0;\n+                            res += ((c as int) - ('0' as int)) as f64;\n+\n+                            self.bump();\n+                        }\n+                        _ => break,\n+                    }\n                 }\n             }\n-          }\n-          _ => return self.error(~\"invalid number\")\n+            _ => return self.error(~\"invalid number\"),\n         }\n-\n         Ok(res)\n     }\n \n     fn parse_decimal(&mut self, res: f64) -> Result<f64, Error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n-        match self.ch {\n-          '0' .. '9' => (),\n-          _ => return self.error(~\"invalid number\")\n+        match self.ch_or_null() {\n+            '0' .. '9' => (),\n+             _ => return self.error(~\"invalid number\")\n         }\n \n         let mut res = res;\n         let mut dec = 1.0;\n         while !self.eof() {\n-            match self.ch {\n-              '0' .. '9' => {\n-                dec /= 10.0;\n-                res += (((self.ch as int) - ('0' as int)) as f64) * dec;\n+            match self.ch_or_null() {\n+                c @ '0' .. '9' => {\n+                    dec /= 10.0;\n+                    res += (((c as int) - ('0' as int)) as f64) * dec;\n \n-                self.bump();\n-              }\n-              _ => break\n+                    self.bump();\n+                }\n+                _ => break,\n             }\n         }\n \n@@ -913,27 +911,27 @@ impl<T : Iterator<char>> Parser<T> {\n         let mut exp = 0u;\n         let mut neg_exp = false;\n \n-        match self.ch {\n-          '+' => self.bump(),\n-          '-' => { self.bump(); neg_exp = true; }\n-          _ => ()\n+        if self.ch_is('+') {\n+            self.bump();\n+        } else if self.ch_is('-') {\n+            self.bump();\n+            neg_exp = true;\n         }\n \n         // Make sure a digit follows the exponent place.\n-        match self.ch {\n-          '0' .. '9' => (),\n-          _ => return self.error(~\"invalid number\")\n+        match self.ch_or_null() {\n+            '0' .. '9' => (),\n+            _ => return self.error(~\"invalid number\")\n         }\n-\n         while !self.eof() {\n-            match self.ch {\n-              '0' .. '9' => {\n-                exp *= 10u;\n-                exp += (self.ch as uint) - ('0' as uint);\n+            match self.ch_or_null() {\n+                c @ '0' .. '9' => {\n+                    exp *= 10;\n+                    exp += (c as uint) - ('0' as uint);\n \n-                self.bump();\n-              }\n-              _ => break\n+                    self.bump();\n+                }\n+                _ => break\n             }\n         }\n \n@@ -958,56 +956,55 @@ impl<T : Iterator<char>> Parser<T> {\n             }\n \n             if escape {\n-                match self.ch {\n-                  '\"' => res.push_char('\"'),\n-                  '\\\\' => res.push_char('\\\\'),\n-                  '/' => res.push_char('/'),\n-                  'b' => res.push_char('\\x08'),\n-                  'f' => res.push_char('\\x0c'),\n-                  'n' => res.push_char('\\n'),\n-                  'r' => res.push_char('\\r'),\n-                  't' => res.push_char('\\t'),\n-                  'u' => {\n-                      // Parse \\u1234.\n-                      let mut i = 0u;\n-                      let mut n = 0u;\n-                      while i < 4u {\n-                          match self.next_char() {\n-                            '0' .. '9' => {\n-                              n = n * 16u + (self.ch as uint)\n-                                          - ('0'     as uint);\n-                            },\n-                            'a' | 'A' => n = n * 16u + 10u,\n-                            'b' | 'B' => n = n * 16u + 11u,\n-                            'c' | 'C' => n = n * 16u + 12u,\n-                            'd' | 'D' => n = n * 16u + 13u,\n-                            'e' | 'E' => n = n * 16u + 14u,\n-                            'f' | 'F' => n = n * 16u + 15u,\n-                            _ => return self.error(\n-                                   ~\"invalid \\\\u escape (unrecognized hex)\")\n-                          }\n-                          i += 1u;\n-                      }\n-\n-                      // Error out if we didn't parse 4 digits.\n-                      if i != 4u {\n-                          return self.error(\n-                            ~\"invalid \\\\u escape (not four digits)\");\n-                      }\n-\n-                      res.push_char(char::from_u32(n as u32).unwrap());\n-                  }\n-                  _ => return self.error(~\"invalid escape\")\n+                match self.ch_or_null() {\n+                    '\"' => res.push_char('\"'),\n+                    '\\\\' => res.push_char('\\\\'),\n+                    '/' => res.push_char('/'),\n+                    'b' => res.push_char('\\x08'),\n+                    'f' => res.push_char('\\x0c'),\n+                    'n' => res.push_char('\\n'),\n+                    'r' => res.push_char('\\r'),\n+                    't' => res.push_char('\\t'),\n+                    'u' => {\n+                        // Parse \\u1234.\n+                        let mut i = 0u;\n+                        let mut n = 0u;\n+                        while i < 4u && !self.eof() {\n+                            self.bump();\n+                            n = match self.ch_or_null() {\n+                                c @ '0' .. '9' => n * 16u + (c as uint) - ('0' as uint),\n+                                'a' | 'A' => n * 16u + 10u,\n+                                'b' | 'B' => n * 16u + 11u,\n+                                'c' | 'C' => n * 16u + 12u,\n+                                'd' | 'D' => n * 16u + 13u,\n+                                'e' | 'E' => n * 16u + 14u,\n+                                'f' | 'F' => n * 16u + 15u,\n+                                _ => return self.error(\n+                                    ~\"invalid \\\\u escape (unrecognized hex)\")\n+                            };\n+\n+                            i += 1u;\n+                        }\n+\n+                        // Error out if we didn't parse 4 digits.\n+                        if i != 4u {\n+                            return self.error(\n+                                ~\"invalid \\\\u escape (not four digits)\");\n+                        }\n+\n+                        res.push_char(char::from_u32(n as u32).unwrap());\n+                    }\n+                    _ => return self.error(~\"invalid escape\"),\n                 }\n                 escape = false;\n-            } else if self.ch == '\\\\' {\n+            } else if self.ch_is('\\\\') {\n                 escape = true;\n             } else {\n-                if self.ch == '\"' {\n-                    self.bump();\n-                    return Ok(res);\n+                match self.ch {\n+                    Some('\"') => { self.bump(); return Ok(res); },\n+                    Some(c) => res.push_char(c),\n+                    None => unreachable!()\n                 }\n-                res.push_char(self.ch);\n             }\n         }\n     }\n@@ -1018,7 +1015,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n         let mut values = ~[];\n \n-        if self.ch == ']' {\n+        if self.ch_is(']') {\n             self.bump();\n             return Ok(List(values));\n         }\n@@ -1034,10 +1031,13 @@ impl<T : Iterator<char>> Parser<T> {\n                 return self.error(~\"EOF while parsing list\");\n             }\n \n-            match self.ch {\n-              ',' => self.bump(),\n-              ']' => { self.bump(); return Ok(List(values)); }\n-              _ => return self.error(~\"expected `,` or `]`\")\n+            if self.ch_is(',') {\n+                self.bump();\n+            } else if self.ch_is(']') {\n+                self.bump();\n+                return Ok(List(values));\n+            } else {\n+                return self.error(~\"expected `,` or `]`\")\n             }\n         };\n     }\n@@ -1048,15 +1048,15 @@ impl<T : Iterator<char>> Parser<T> {\n \n         let mut values = ~TreeMap::new();\n \n-        if self.ch == '}' {\n+        if self.ch_is('}') {\n           self.bump();\n           return Ok(Object(values));\n         }\n \n         while !self.eof() {\n             self.parse_whitespace();\n \n-            if self.ch != '\"' {\n+            if !self.ch_is('\"') {\n                 return self.error(~\"key must be a string\");\n             }\n \n@@ -1067,7 +1067,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n             self.parse_whitespace();\n \n-            if self.ch != ':' {\n+            if !self.ch_is(':') {\n                 if self.eof() { break; }\n                 return self.error(~\"expected `:`\");\n             }\n@@ -1079,13 +1079,13 @@ impl<T : Iterator<char>> Parser<T> {\n             }\n             self.parse_whitespace();\n \n-            match self.ch {\n-              ',' => self.bump(),\n-              '}' => { self.bump(); return Ok(Object(values)); }\n-              _ => {\n-                  if self.eof() { break; }\n-                  return self.error(~\"expected `,` or `}`\");\n-              }\n+            match self.ch_or_null() {\n+                ',' => self.bump(),\n+                '}' => { self.bump(); return Ok(Object(values)); },\n+                _ => {\n+                    if self.eof() { break; }\n+                    return self.error(~\"expected `,` or `}`\");\n+                }\n             }\n         }\n "}, {"sha": "e7ebc2ef526c4bf5d77b483065185dddf4e2b4b5", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=95483e30a2fd18ddb72c50a17a87cf8439c8f2bd", "patch": "@@ -545,7 +545,11 @@ fn load<'a>(bcx: &'a Block<'a>, llptr: ValueRef, ty: ty::t) -> ValueRef {\n     if type_is_zero_size(bcx.ccx(), ty) {\n         C_undef(type_of::type_of(bcx.ccx(), ty))\n     } else if ty::type_is_bool(ty) {\n-        LoadRangeAssert(bcx, llptr, 0, 2, lib::llvm::True)\n+        LoadRangeAssert(bcx, llptr, 0, 2, lib::llvm::False)\n+    } else if ty::type_is_char(ty) {\n+        // a char is a unicode codepoint, and so takes values from 0\n+        // to 0x10FFFF inclusive only.\n+        LoadRangeAssert(bcx, llptr, 0, 0x10FFFF + 1, lib::llvm::False)\n     } else {\n         Load(bcx, llptr)\n     }"}, {"sha": "138f9d7164067571bd0f99e1269e65e1d45c5935", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=95483e30a2fd18ddb72c50a17a87cf8439c8f2bd", "patch": "@@ -12,7 +12,7 @@ use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n use diagnostic;\n use parse::lexer::{is_whitespace, with_str_from, Reader};\n-use parse::lexer::{StringReader, bump, is_eof, nextch, TokenAndSpan};\n+use parse::lexer::{StringReader, bump, is_eof, nextch_is, TokenAndSpan};\n use parse::lexer::{is_line_non_doc_comment, is_block_non_doc_comment};\n use parse::lexer;\n use parse::token;\n@@ -136,11 +136,11 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n \n fn read_to_eol(rdr: &StringReader) -> ~str {\n     let mut val = ~\"\";\n-    while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n-        val.push_char(rdr.curr.get());\n+    while !rdr.curr_is('\\n') && !is_eof(rdr) {\n+        val.push_char(rdr.curr.get().unwrap());\n         bump(rdr);\n     }\n-    if rdr.curr.get() == '\\n' { bump(rdr); }\n+    if rdr.curr_is('\\n') { bump(rdr); }\n     return val;\n }\n \n@@ -152,7 +152,7 @@ fn read_one_line_comment(rdr: &StringReader) -> ~str {\n }\n \n fn consume_non_eol_whitespace(rdr: &StringReader) {\n-    while is_whitespace(rdr.curr.get()) && rdr.curr.get() != '\\n' &&\n+    while is_whitespace(rdr.curr.get()) && !rdr.curr_is('\\n') &&\n             !is_eof(rdr) {\n         bump(rdr);\n     }\n@@ -171,7 +171,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut ~[Comment]) {\n fn consume_whitespace_counting_blank_lines(rdr: &StringReader,\n                                            comments: &mut ~[Comment]) {\n     while is_whitespace(rdr.curr.get()) && !is_eof(rdr) {\n-        if rdr.col.get() == CharPos(0u) && rdr.curr.get() == '\\n' {\n+        if rdr.col.get() == CharPos(0u) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         bump(rdr);\n@@ -196,7 +196,7 @@ fn read_line_comments(rdr: &StringReader, code_to_the_left: bool,\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n-    while rdr.curr.get() == '/' && nextch(rdr) == '/' {\n+    while rdr.curr_is('/') && nextch_is(rdr, '/') {\n         let line = read_one_line_comment(rdr);\n         debug!(\"{}\", line);\n         if is_doc_comment(line) { // doc-comments are not put in comments\n@@ -261,9 +261,9 @@ fn read_block_comment(rdr: &StringReader,\n     let mut curr_line = ~\"/*\";\n \n     // doc-comments are not really comments, they are attributes\n-    if rdr.curr.get() == '*' || rdr.curr.get() == '!' {\n-        while !(rdr.curr.get() == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n-            curr_line.push_char(rdr.curr.get());\n+    if rdr.curr_is('*') || rdr.curr_is('!') {\n+        while !(rdr.curr_is('*') && nextch_is(rdr, '/')) && !is_eof(rdr) {\n+            curr_line.push_char(rdr.curr.get().unwrap());\n             bump(rdr);\n         }\n         if !is_eof(rdr) {\n@@ -281,20 +281,20 @@ fn read_block_comment(rdr: &StringReader,\n             if is_eof(rdr) {\n                 rdr.fatal(~\"unterminated block comment\");\n             }\n-            if rdr.curr.get() == '\\n' {\n+            if rdr.curr_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n                                                      col);\n                 curr_line = ~\"\";\n                 bump(rdr);\n             } else {\n-                curr_line.push_char(rdr.curr.get());\n-                if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n+                curr_line.push_char(rdr.curr.get().unwrap());\n+                if rdr.curr_is('/') && nextch_is(rdr, '*') {\n                     bump(rdr);\n                     bump(rdr);\n                     curr_line.push_char('*');\n                     level += 1;\n                 } else {\n-                    if rdr.curr.get() == '*' && nextch(rdr) == '/' {\n+                    if rdr.curr_is('*') && nextch_is(rdr, '/') {\n                         bump(rdr);\n                         bump(rdr);\n                         curr_line.push_char('/');\n@@ -310,28 +310,28 @@ fn read_block_comment(rdr: &StringReader,\n \n     let mut style = if code_to_the_left { Trailing } else { Isolated };\n     consume_non_eol_whitespace(rdr);\n-    if !is_eof(rdr) && rdr.curr.get() != '\\n' && lines.len() == 1u {\n+    if !is_eof(rdr) && !rdr.curr_is('\\n') && lines.len() == 1u {\n         style = Mixed;\n     }\n     debug!(\"<<< block comment\");\n     comments.push(Comment {style: style, lines: lines, pos: p});\n }\n \n fn peeking_at_comment(rdr: &StringReader) -> bool {\n-    return ((rdr.curr.get() == '/' && nextch(rdr) == '/') ||\n-         (rdr.curr.get() == '/' && nextch(rdr) == '*')) ||\n-         (rdr.curr.get() == '#' && nextch(rdr) == '!');\n+    return (rdr.curr_is('/') && nextch_is(rdr, '/')) ||\n+         (rdr.curr_is('/') && nextch_is(rdr, '*')) ||\n+         (rdr.curr_is('#') && nextch_is(rdr, '!'));\n }\n \n fn consume_comment(rdr: &StringReader,\n                    code_to_the_left: bool,\n                    comments: &mut ~[Comment]) {\n     debug!(\">>> consume comment\");\n-    if rdr.curr.get() == '/' && nextch(rdr) == '/' {\n+    if rdr.curr_is('/') && nextch_is(rdr, '/') {\n         read_line_comments(rdr, code_to_the_left, comments);\n-    } else if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n+    } else if rdr.curr_is('/') && nextch_is(rdr, '*') {\n         read_block_comment(rdr, code_to_the_left, comments);\n-    } else if rdr.curr.get() == '#' && nextch(rdr) == '!' {\n+    } else if rdr.curr_is('#') && nextch_is(rdr, '!') {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n     } else { fail!(); }\n     debug!(\"<<< consume comment\");\n@@ -363,7 +363,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         loop {\n             let mut code_to_the_left = !first_read;\n             consume_non_eol_whitespace(&rdr);\n-            if rdr.curr.get() == '\\n' {\n+            if rdr.curr_is('\\n') {\n                 code_to_the_left = false;\n                 consume_whitespace_counting_blank_lines(&rdr, &mut comments);\n             }"}, {"sha": "f6ebfbfcc3b2e17cb9cb0e8c962b8306bfa8bb21", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 135, "deletions": 94, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95483e30a2fd18ddb72c50a17a87cf8439c8f2bd/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=95483e30a2fd18ddb72c50a17a87cf8439c8f2bd", "patch": "@@ -16,7 +16,6 @@ use ext::tt::transcribe::{dup_tt_reader, tt_next_token};\n use parse::token;\n use parse::token::{str_to_ident};\n \n-use std::cast::transmute;\n use std::cell::{Cell, RefCell};\n use std::char;\n use std::num::from_str_radix;\n@@ -48,13 +47,19 @@ pub struct StringReader {\n     // The column of the next character to read\n     col: Cell<CharPos>,\n     // The last character to be read\n-    curr: Cell<char>,\n+    curr: Cell<Option<char>>,\n     filemap: @codemap::FileMap,\n     /* cached: */\n     peek_tok: RefCell<token::Token>,\n     peek_span: RefCell<Span>,\n }\n \n+impl StringReader {\n+    pub fn curr_is(&self, c: char) -> bool {\n+        self.curr.get() == Some(c)\n+    }\n+}\n+\n pub fn new_string_reader(span_diagnostic: @SpanHandler,\n                          filemap: @codemap::FileMap)\n                       -> StringReader {\n@@ -74,7 +79,7 @@ pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n         pos: Cell::new(filemap.start_pos),\n         last_pos: Cell::new(filemap.start_pos),\n         col: Cell::new(CharPos(0)),\n-        curr: Cell::new(initial_char),\n+        curr: Cell::new(Some(initial_char)),\n         filemap: filemap,\n         /* dummy values; not read */\n         peek_tok: RefCell::new(token::EOF),\n@@ -246,14 +251,12 @@ pub fn bump(rdr: &StringReader) {\n     rdr.last_pos.set(rdr.pos.get());\n     let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if current_byte_offset < (rdr.filemap.src).len() {\n-        assert!(rdr.curr.get() != unsafe {\n-            transmute(-1u32)\n-        }); // FIXME: #8971: unsound\n-        let last_char = rdr.curr.get();\n+        assert!(rdr.curr.get().is_some());\n+        let last_char = rdr.curr.get().unwrap();\n         let next = rdr.filemap.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n-        rdr.curr.set(next.ch);\n+        rdr.curr.set(Some(next.ch));\n         rdr.col.set(rdr.col.get() + CharPos(1u));\n         if last_char == '\\n' {\n             rdr.filemap.next_line(rdr.last_pos.get());\n@@ -265,37 +268,50 @@ pub fn bump(rdr: &StringReader) {\n                 Pos::from_uint(current_byte_offset), byte_offset_diff);\n         }\n     } else {\n-        rdr.curr.set(unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n+        rdr.curr.set(None);\n     }\n }\n pub fn is_eof(rdr: &StringReader) -> bool {\n-    rdr.curr.get() == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n+    rdr.curr.get().is_none()\n }\n-pub fn nextch(rdr: &StringReader) -> char {\n+pub fn nextch(rdr: &StringReader) -> Option<char> {\n     let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if offset < (rdr.filemap.src).len() {\n-        return rdr.filemap.src.char_at(offset);\n-    } else { return unsafe { transmute(-1u32) }; } // FIXME: #8971: unsound\n+        Some(rdr.filemap.src.char_at(offset))\n+    } else {\n+        None\n+    }\n+}\n+pub fn nextch_is(rdr: &StringReader, c: char) -> bool {\n+    nextch(rdr) == Some(c)\n }\n \n-fn hex_digit_val(c: char) -> int {\n-    if in_range(c, '0', '9') { return (c as int) - ('0' as int); }\n-    if in_range(c, 'a', 'f') { return (c as int) - ('a' as int) + 10; }\n-    if in_range(c, 'A', 'F') { return (c as int) - ('A' as int) + 10; }\n+fn hex_digit_val(c: Option<char>) -> int {\n+    let d = c.unwrap_or('\\x00');\n+\n+    if in_range(c, '0', '9') { return (d as int) - ('0' as int); }\n+    if in_range(c, 'a', 'f') { return (d as int) - ('a' as int) + 10; }\n+    if in_range(c, 'A', 'F') { return (d as int) - ('A' as int) + 10; }\n     fail!();\n }\n \n-pub fn is_whitespace(c: char) -> bool {\n-    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n+pub fn is_whitespace(c: Option<char>) -> bool {\n+    match c.unwrap_or('\\x00') { // None can be null for now... it's not whitespace\n+        ' ' | '\\n' | '\\t' | '\\r' => true,\n+        _ => false\n+    }\n }\n \n-fn in_range(c: char, lo: char, hi: char) -> bool {\n-    return lo <= c && c <= hi\n+fn in_range(c: Option<char>, lo: char, hi: char) -> bool {\n+    match c {\n+        Some(c) => lo <= c && c <= hi,\n+        _ => false\n+    }\n }\n \n-fn is_dec_digit(c: char) -> bool { return in_range(c, '0', '9'); }\n+fn is_dec_digit(c: Option<char>) -> bool { return in_range(c, '0', '9'); }\n \n-fn is_hex_digit(c: char) -> bool {\n+fn is_hex_digit(c: Option<char>) -> bool {\n     return in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n             in_range(c, 'A', 'F');\n }\n@@ -317,15 +333,15 @@ pub fn is_line_non_doc_comment(s: &str) -> bool {\n // returns a Some(sugared-doc-attr) if one exists, None otherwise\n fn consume_any_line_comment(rdr: &StringReader)\n                          -> Option<TokenAndSpan> {\n-    if rdr.curr.get() == '/' {\n+    if rdr.curr_is('/') {\n         match nextch(rdr) {\n-          '/' => {\n+          Some('/') => {\n             bump(rdr);\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n-            if rdr.curr.get() == '/' || rdr.curr.get() == '!' {\n+            if rdr.curr_is('/') || rdr.curr_is('!') {\n                 let start_bpos = rdr.pos.get() - BytePos(3);\n-                while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n+                while !rdr.curr_is('\\n') && !is_eof(rdr) {\n                     bump(rdr);\n                 }\n                 let ret = with_str_from(rdr, start_bpos, |string| {\n@@ -344,16 +360,16 @@ fn consume_any_line_comment(rdr: &StringReader)\n                     return ret;\n                 }\n             } else {\n-                while rdr.curr.get() != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n             }\n             // Restart whitespace munch.\n             return consume_whitespace_and_comments(rdr);\n           }\n-          '*' => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n+          Some('*') => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n           _ => ()\n         }\n-    } else if rdr.curr.get() == '#' {\n-        if nextch(rdr) == '!' {\n+    } else if rdr.curr_is('#') {\n+        if nextch_is(rdr, '!') {\n             // I guess this is the only way to figure out if\n             // we're at the beginning of the file...\n             let cmap = @CodeMap::new();\n@@ -363,7 +379,7 @@ fn consume_any_line_comment(rdr: &StringReader)\n             }\n             let loc = cmap.lookup_char_pos_adj(rdr.last_pos.get());\n             if loc.line == 1u && loc.col == CharPos(0u) {\n-                while rdr.curr.get() != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n             }\n         }\n@@ -378,7 +394,7 @@ pub fn is_block_non_doc_comment(s: &str) -> bool {\n // might return a sugared-doc-attr\n fn consume_block_comment(rdr: &StringReader) -> Option<TokenAndSpan> {\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n-    let is_doc_comment = rdr.curr.get() == '*' || rdr.curr.get() == '!';\n+    let is_doc_comment = rdr.curr_is('*') || rdr.curr_is('!');\n     let start_bpos = rdr.pos.get() - BytePos(if is_doc_comment {3} else {2});\n \n     let mut level: int = 1;\n@@ -390,11 +406,11 @@ fn consume_block_comment(rdr: &StringReader) -> Option<TokenAndSpan> {\n                 ~\"unterminated block comment\"\n             };\n             fatal_span(rdr, start_bpos, rdr.last_pos.get(), msg);\n-        } else if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n+        } else if rdr.curr_is('/') && nextch_is(rdr, '*') {\n             level += 1;\n             bump(rdr);\n             bump(rdr);\n-        } else if rdr.curr.get() == '*' && nextch(rdr) == '/' {\n+        } else if rdr.curr_is('*') && nextch_is(rdr, '/') {\n             level -= 1;\n             bump(rdr);\n             bump(rdr);\n@@ -424,12 +440,13 @@ fn consume_block_comment(rdr: &StringReader) -> Option<TokenAndSpan> {\n }\n \n fn scan_exponent(rdr: &StringReader, start_bpos: BytePos) -> Option<~str> {\n-    let mut c = rdr.curr.get();\n+    // \\x00 hits the `return None` case immediately, so this is fine.\n+    let mut c = rdr.curr.get().unwrap_or('\\x00');\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n         rslt.push_char(c);\n         bump(rdr);\n-        c = rdr.curr.get();\n+        c = rdr.curr.get().unwrap_or('\\x00');\n         if c == '-' || c == '+' {\n             rslt.push_char(c);\n             bump(rdr);\n@@ -448,10 +465,10 @@ fn scan_digits(rdr: &StringReader, radix: uint) -> ~str {\n     let mut rslt = ~\"\";\n     loop {\n         let c = rdr.curr.get();\n-        if c == '_' { bump(rdr); continue; }\n-        match char::to_digit(c, radix) {\n+        if c == Some('_') { bump(rdr); continue; }\n+        match c.and_then(|cc| char::to_digit(cc, radix)) {\n           Some(_) => {\n-            rslt.push_char(c);\n+            rslt.push_char(c.unwrap());\n             bump(rdr);\n           }\n           _ => return rslt\n@@ -476,7 +493,7 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n     let mut num_str;\n     let mut base = 10u;\n     let mut c = c;\n-    let mut n = nextch(rdr);\n+    let mut n = nextch(rdr).unwrap_or('\\x00');\n     let start_bpos = rdr.last_pos.get();\n     if c == '0' && n == 'x' {\n         bump(rdr);\n@@ -492,7 +509,7 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n         base = 2u;\n     }\n     num_str = scan_digits(rdr, base);\n-    c = rdr.curr.get();\n+    c = rdr.curr.get().unwrap_or('\\x00');\n     nextch(rdr);\n     if c == 'u' || c == 'i' {\n         enum Result { Signed(ast::IntTy), Unsigned(ast::UintTy) }\n@@ -502,13 +519,13 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n             else { Unsigned(ast::TyU) }\n         };\n         bump(rdr);\n-        c = rdr.curr.get();\n+        c = rdr.curr.get().unwrap_or('\\x00');\n         if c == '8' {\n             bump(rdr);\n             tp = if signed { Signed(ast::TyI8) }\n                       else { Unsigned(ast::TyU8) };\n         }\n-        n = nextch(rdr);\n+        n = nextch(rdr).unwrap_or('\\x00');\n         if c == '1' && n == '6' {\n             bump(rdr);\n             bump(rdr);\n@@ -541,8 +558,7 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n         }\n     }\n     let mut is_float = false;\n-    if rdr.curr.get() == '.' && !(ident_start(nextch(rdr)) || nextch(rdr) ==\n-                                  '.') {\n+    if rdr.curr_is('.') && !(ident_start(nextch(rdr)) || nextch_is(rdr, '.')) {\n         is_float = true;\n         bump(rdr);\n         let dec_part = scan_digits(rdr, 10u);\n@@ -557,10 +573,10 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n       None => ()\n     }\n \n-    if rdr.curr.get() == 'f' {\n+    if rdr.curr_is('f') {\n         bump(rdr);\n-        c = rdr.curr.get();\n-        n = nextch(rdr);\n+        c = rdr.curr.get().unwrap_or('\\x00');\n+        n = nextch(rdr).unwrap_or('\\x00');\n         if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n@@ -602,33 +618,42 @@ fn scan_numeric_escape(rdr: &StringReader, n_hex_digits: uint) -> char {\n     let mut accum_int = 0;\n     let mut i = n_hex_digits;\n     let start_bpos = rdr.last_pos.get();\n-    while i != 0u {\n+    while i != 0u && !is_eof(rdr) {\n         let n = rdr.curr.get();\n         if !is_hex_digit(n) {\n             fatal_span_char(rdr, rdr.last_pos.get(), rdr.pos.get(),\n                             ~\"illegal character in numeric character escape\",\n-                            n);\n+                            n.unwrap());\n         }\n         bump(rdr);\n         accum_int *= 16;\n         accum_int += hex_digit_val(n);\n         i -= 1u;\n     }\n+    if i != 0 && is_eof(rdr) {\n+        fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n+                   ~\"unterminated numeric character escape\");\n+    }\n+\n     match char::from_u32(accum_int as u32) {\n         Some(x) => x,\n         None => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"illegal numeric character escape\")\n     }\n }\n \n-fn ident_start(c: char) -> bool {\n+fn ident_start(c: Option<char>) -> bool {\n+    let c = match c { Some(c) => c, None => return false };\n+\n     (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n         || c == '_'\n         || (c > '\\x7f' && char::is_XID_start(c))\n }\n \n-fn ident_continue(c: char) -> bool {\n+fn ident_continue(c: Option<char>) -> bool {\n+    let c = match c { Some(c) => c, None => return false };\n+\n     (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n         || (c >= '0' && c <= '9')\n@@ -641,7 +666,7 @@ fn ident_continue(c: char) -> bool {\n // EFFECT: updates the interner\n fn next_token_inner(rdr: &StringReader) -> token::Token {\n     let c = rdr.curr.get();\n-    if ident_start(c) && nextch(rdr) != '\"' && nextch(rdr) != '#' {\n+    if ident_start(c) && !nextch_is(rdr, '\"') && !nextch_is(rdr, '#') {\n         // Note: r as in r\" or r#\" is part of a raw string literal,\n         // not an identifier, and is handled further down.\n \n@@ -654,24 +679,24 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n             if string == \"_\" {\n                 token::UNDERSCORE\n             } else {\n-                let is_mod_name = rdr.curr.get() == ':' && nextch(rdr) == ':';\n+                let is_mod_name = rdr.curr_is(':') && nextch_is(rdr, ':');\n \n                 // FIXME: perform NFKC normalization here. (Issue #2253)\n                 token::IDENT(str_to_ident(string), is_mod_name)\n             }\n         })\n     }\n     if is_dec_digit(c) {\n-        return scan_number(c, rdr);\n+        return scan_number(c.unwrap(), rdr);\n     }\n     fn binop(rdr: &StringReader, op: token::BinOp) -> token::Token {\n         bump(rdr);\n-        if rdr.curr.get() == '=' {\n+        if rdr.curr_is('=') {\n             bump(rdr);\n             return token::BINOPEQ(op);\n         } else { return token::BINOP(op); }\n     }\n-    match c {\n+    match c.expect(\"next_token_inner called at EOF\") {\n \n \n \n@@ -682,9 +707,9 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       ',' => { bump(rdr); return token::COMMA; }\n       '.' => {\n           bump(rdr);\n-          return if rdr.curr.get() == '.' {\n+          return if rdr.curr_is('.') {\n               bump(rdr);\n-              if rdr.curr.get() == '.' {\n+              if rdr.curr_is('.') {\n                   bump(rdr);\n                   token::DOTDOTDOT\n               } else {\n@@ -705,7 +730,7 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       '~' => { bump(rdr); return token::TILDE; }\n       ':' => {\n         bump(rdr);\n-        if rdr.curr.get() == ':' {\n+        if rdr.curr_is(':') {\n             bump(rdr);\n             return token::MOD_SEP;\n         } else { return token::COLON; }\n@@ -720,10 +745,10 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       // Multi-byte tokens.\n       '=' => {\n         bump(rdr);\n-        if rdr.curr.get() == '=' {\n+        if rdr.curr_is('=') {\n             bump(rdr);\n             return token::EQEQ;\n-        } else if rdr.curr.get() == '>' {\n+        } else if rdr.curr_is('>') {\n             bump(rdr);\n             return token::FAT_ARROW;\n         } else {\n@@ -732,19 +757,19 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       }\n       '!' => {\n         bump(rdr);\n-        if rdr.curr.get() == '=' {\n+        if rdr.curr_is('=') {\n             bump(rdr);\n             return token::NE;\n         } else { return token::NOT; }\n       }\n       '<' => {\n         bump(rdr);\n-        match rdr.curr.get() {\n+        match rdr.curr.get().unwrap_or('\\x00') {\n           '=' => { bump(rdr); return token::LE; }\n           '<' => { return binop(rdr, token::SHL); }\n           '-' => {\n             bump(rdr);\n-            match rdr.curr.get() {\n+            match rdr.curr.get().unwrap_or('\\x00') {\n               '>' => { bump(rdr); return token::DARROW; }\n               _ => { return token::LARROW; }\n             }\n@@ -754,7 +779,7 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       }\n       '>' => {\n         bump(rdr);\n-        match rdr.curr.get() {\n+        match rdr.curr.get().unwrap_or('\\x00') {\n           '=' => { bump(rdr); return token::GE; }\n           '>' => { return binop(rdr, token::SHR); }\n           _ => { return token::GT; }\n@@ -764,12 +789,14 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n         // Either a character constant 'a' OR a lifetime name 'abc\n         bump(rdr);\n         let start = rdr.last_pos.get();\n-        let mut c2 = rdr.curr.get();\n+\n+        // the eof will be picked up by the final `'` check below\n+        let mut c2 = rdr.curr.get().unwrap_or('\\x00');\n         bump(rdr);\n \n         // If the character is an ident start not followed by another single\n         // quote, then this is a lifetime name:\n-        if ident_start(c2) && rdr.curr.get() != '\\'' {\n+        if ident_start(Some(c2)) && !rdr.curr_is('\\'') {\n             while ident_continue(rdr.curr.get()) {\n                 bump(rdr);\n             }\n@@ -798,19 +825,24 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n                 let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n-                    'n' => { c2 = '\\n'; }\n-                    'r' => { c2 = '\\r'; }\n-                    't' => { c2 = '\\t'; }\n-                    '\\\\' => { c2 = '\\\\'; }\n-                    '\\'' => { c2 = '\\''; }\n-                    '\"' => { c2 = '\"'; }\n-                    '0' => { c2 = '\\x00'; }\n-                    'x' => { c2 = scan_numeric_escape(rdr, 2u); }\n-                    'u' => { c2 = scan_numeric_escape(rdr, 4u); }\n-                    'U' => { c2 = scan_numeric_escape(rdr, 8u); }\n-                    c2 => {\n-                        fatal_span_char(rdr, escaped_pos, rdr.last_pos.get(),\n-                                        ~\"unknown character escape\", c2);\n+                    None => {}\n+                    Some(e) => {\n+                        c2 = match e {\n+                            'n' => '\\n',\n+                            'r' => '\\r',\n+                            't' => '\\t',\n+                            '\\\\' => '\\\\',\n+                            '\\'' => '\\'',\n+                            '\"' => '\"',\n+                            '0' => '\\x00',\n+                            'x' => scan_numeric_escape(rdr, 2u),\n+                            'u' => scan_numeric_escape(rdr, 4u),\n+                            'U' => scan_numeric_escape(rdr, 8u),\n+                            c2 => {\n+                                fatal_span_char(rdr, escaped_pos, rdr.last_pos.get(),\n+                                                ~\"unknown character escape\", c2)\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -820,7 +852,7 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n             }\n             _ => {}\n         }\n-        if rdr.curr.get() != '\\'' {\n+        if !rdr.curr_is('\\'') {\n             fatal_span_verbose(rdr,\n                                // Byte offsetting here is okay because the\n                                // character before position `start` is an\n@@ -836,17 +868,22 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n         let mut accum_str = ~\"\";\n         let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n-        while rdr.curr.get() != '\"' {\n+        while !rdr.curr_is('\"') {\n             if is_eof(rdr) {\n                 fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated double quote string\");\n             }\n \n-            let ch = rdr.curr.get();\n+            let ch = rdr.curr.get().unwrap();\n             bump(rdr);\n             match ch {\n               '\\\\' => {\n-                let escaped = rdr.curr.get();\n+                if is_eof(rdr) {\n+                    fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n+                           ~\"unterminated double quote string\");\n+                }\n+\n+                let escaped = rdr.curr.get().unwrap();\n                 let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n@@ -883,15 +920,19 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n         let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n         let mut hash_count = 0u;\n-        while rdr.curr.get() == '#' {\n+        while rdr.curr_is('#') {\n             bump(rdr);\n             hash_count += 1;\n         }\n-        if rdr.curr.get() != '\"' {\n+\n+        if is_eof(rdr) {\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n+                       ~\"unterminated raw string\");\n+        } else if !rdr.curr_is('\"') {\n             fatal_span_char(rdr, start_bpos, rdr.last_pos.get(),\n                             ~\"only `#` is allowed in raw string delimitation; \\\n                               found illegal character\",\n-                            rdr.curr.get());\n+                            rdr.curr.get().unwrap());\n         }\n         bump(rdr);\n         let content_start_bpos = rdr.last_pos.get();\n@@ -901,11 +942,11 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n                 fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated raw string\");\n             }\n-            if rdr.curr.get() == '\"' {\n+            if rdr.curr_is('\"') {\n                 content_end_bpos = rdr.last_pos.get();\n                 for _ in range(0, hash_count) {\n                     bump(rdr);\n-                    if rdr.curr.get() != '#' {\n+                    if !rdr.curr_is('#') {\n                         continue 'outer;\n                     }\n                 }\n@@ -921,22 +962,22 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n         return token::LIT_STR_RAW(str_content, hash_count);\n       }\n       '-' => {\n-        if nextch(rdr) == '>' {\n+        if nextch_is(rdr, '>') {\n             bump(rdr);\n             bump(rdr);\n             return token::RARROW;\n         } else { return binop(rdr, token::MINUS); }\n       }\n       '&' => {\n-        if nextch(rdr) == '&' {\n+        if nextch_is(rdr, '&') {\n             bump(rdr);\n             bump(rdr);\n             return token::ANDAND;\n         } else { return binop(rdr, token::AND); }\n       }\n       '|' => {\n         match nextch(rdr) {\n-          '|' => { bump(rdr); bump(rdr); return token::OROR; }\n+          Some('|') => { bump(rdr); bump(rdr); return token::OROR; }\n           _ => { return binop(rdr, token::OR); }\n         }\n       }"}]}