{"sha": "4594f0f67aad77839d5a41353224fee186bfcda9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1OTRmMGY2N2FhZDc3ODM5ZDVhNDEzNTMyMjRmZWUxODZiZmNkYTk=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-03-05T17:09:14Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-03-05T17:11:52Z"}, "message": "Fix panic on string slicing error to truncate the string\n\nThe string may be arbitrarily long, but we want to limit the panic\nmessage to a reasonable length. Truncate the string if it is too long\n(simply to char boundary).\n\nAlso add details to the start <= end message. I think it's ok to flesh\nout the code here, since it's in a cold function.", "tree": {"sha": "0eb1684d1a6de19110ef4e92a9acdfee2883b629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eb1684d1a6de19110ef4e92a9acdfee2883b629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4594f0f67aad77839d5a41353224fee186bfcda9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4594f0f67aad77839d5a41353224fee186bfcda9", "html_url": "https://github.com/rust-lang/rust/commit/4594f0f67aad77839d5a41353224fee186bfcda9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4594f0f67aad77839d5a41353224fee186bfcda9/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c97524bef9e59a80875110b402b3fc8c139d4d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97524bef9e59a80875110b402b3fc8c139d4d64", "html_url": "https://github.com/rust-lang/rust/commit/c97524bef9e59a80875110b402b3fc8c139d4d64"}], "stats": {"total": 44, "additions": 41, "deletions": 3}, "files": [{"sha": "462700318d7f33963b08f593b0a53f6d035b5985", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4594f0f67aad77839d5a41353224fee186bfcda9/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4594f0f67aad77839d5a41353224fee186bfcda9/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=4594f0f67aad77839d5a41353224fee186bfcda9", "patch": "@@ -346,6 +346,26 @@ fn test_slice_fail() {\n     &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n }\n \n+const LOREM_PARAGRAPH: &'static str = \"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\";\n+\n+// check the panic includes the prefix of the sliced string\n+#[test]\n+#[should_panic(expected=\"Lorem ipsum dolor sit amet\")]\n+fn test_slice_fail_truncated_1() {\n+    &LOREM_PARAGRAPH[..1024];\n+}\n+// check the truncation in the panic message\n+#[test]\n+#[should_panic(expected=\"luctus, im`[...] do not lie on character boundary\")]\n+fn test_slice_fail_truncated_2() {\n+    &LOREM_PARAGRAPH[..1024];\n+}\n+\n #[test]\n fn test_slice_from() {\n     assert_eq!(&\"abcd\"[0..], \"abcd\");"}, {"sha": "b6f3e8e7583613bf77f35c6f2d53ab279ec359ec", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4594f0f67aad77839d5a41353224fee186bfcda9/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4594f0f67aad77839d5a41353224fee186bfcda9/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=4594f0f67aad77839d5a41353224fee186bfcda9", "patch": "@@ -1591,12 +1591,30 @@ pub trait StrExt {\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n+// truncate `&str` to length at most equal to `max`\n+// return `true` if it were truncated, and the new str.\n+fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n+    if max >= s.len() {\n+        (false, s)\n+    } else {\n+        while !s.is_char_boundary(max) {\n+            max -= 1;\n+        }\n+        (true, &s[..max])\n+    }\n+}\n+\n #[inline(never)]\n #[cold]\n fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n-    assert!(begin <= end);\n-    panic!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n-          begin, end, s);\n+    const MAX_DISPLAY_LENGTH: usize = 256;\n+    let (truncated, s) = truncate_to_char_boundary(s, MAX_DISPLAY_LENGTH);\n+    let ellipsis = if truncated { \"[...]\" } else { \"\" };\n+\n+    assert!(begin <= end, \"begin <= end ({} <= {}) when slicing `{}`{}\",\n+            begin, end, s, ellipsis);\n+    panic!(\"index {} and/or {} in `{}`{} do not lie on character boundary\",\n+          begin, end, s, ellipsis);\n }\n \n #[stable(feature = \"core\", since = \"1.6.0\")]"}]}