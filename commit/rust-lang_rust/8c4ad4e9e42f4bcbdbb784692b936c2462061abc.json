{"sha": "8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNGFkNGU5ZTQyZjRiY2JkYmI3ODQ2OTJiOTM2YzI0NjIwNjFhYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-04T20:28:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-04T20:28:57Z"}, "message": "Auto merge of #54649 - nikomatsakis:universes-refactor-1, r=scalexm\n\nadopt \"placeholders\" to represent universally quantified regions\n\nThis does a few preliminary refactorings that lay some groundwork for moving towards universe integration. Two things, primarily:\n\n- Rename from \"skolemized\" to \"placeholder\"\n- When instantiating `for<'a, 'b, 'c>`, just create one universe for all 3 regions, and distinguish them from one another using the `BoundRegion`.\n    - This is more accurate, and I think that in general we'll be moving towards a model of separating \"binder\" (universe, debruijn index) from \"index within binder\" in a number of places.\n    - In principle, it feels the current setup of making lots of universes could lead to us doing the wrong thing, but I've actually not been able to come up with an example where this is so.\n\nr? @scalexm\ncc @arielb1", "tree": {"sha": "eb1826efe59cbdbcb0f3cf757c8a51bbc4b8b4c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb1826efe59cbdbcb0f3cf757c8a51bbc4b8b4c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "html_url": "https://github.com/rust-lang/rust/commit/8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a57f1c9c955177e2a7563dd59f9e3a70458e2be1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a57f1c9c955177e2a7563dd59f9e3a70458e2be1", "html_url": "https://github.com/rust-lang/rust/commit/a57f1c9c955177e2a7563dd59f9e3a70458e2be1"}, {"sha": "85b99561c62ec9ff9ccd884ed3ac8206d0d1c381", "url": "https://api.github.com/repos/rust-lang/rust/commits/85b99561c62ec9ff9ccd884ed3ac8206d0d1c381", "html_url": "https://github.com/rust-lang/rust/commit/85b99561c62ec9ff9ccd884ed3ac8206d0d1c381"}], "stats": {"total": 3430, "additions": 1883, "deletions": 1547}, "files": [{"sha": "3ff0034fbbee7d850988e443c87c9922861c36e0", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -131,7 +131,7 @@ for ty::RegionKind {\n             }\n             ty::ReLateBound(..) |\n             ty::ReVar(..) |\n-            ty::ReSkolemized(..) => {\n+            ty::RePlaceholder(..) => {\n                 bug!(\"StableHasher: unexpected region {:?}\", *self)\n             }\n         }"}, {"sha": "1119c928a89aeaf557b0e843909f116f1325d44e", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -224,7 +224,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n             ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReScope(_)\n-            | ty::ReSkolemized(..)\n+            | ty::RePlaceholder(..)\n             | ty::ReEmpty\n             | ty::ReErased => {\n                 if self.canonicalize_region_mode.other_free_regions {"}, {"sha": "de8f57ee796661446670dad90ec2804b6663e0f3", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -458,9 +458,10 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 return Ok(r);\n             }\n \n-            // Always make a fresh region variable for skolemized regions;\n-            // the higher-ranked decision procedures rely on this.\n-            ty::ReSkolemized(..) => { }\n+            // Always make a fresh region variable for placeholder\n+            // regions; the higher-ranked decision procedures rely on\n+            // this.\n+            ty::RePlaceholder(..) => { }\n \n             // For anything else, we make a region variable, unless we\n             // are *equating*, in which case it's just wasteful."}, {"sha": "8b4669c89fe83598161d4114d72d6f7465f17f23", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -142,12 +142,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-            // FIXME(#13998) ReSkolemized should probably print like\n+            // FIXME(#13998) RePlaceholder should probably print like\n             // ReFree rather than dumping Debug output on the user.\n             //\n             // We shouldn't really be having unification failures with ReVar\n             // and ReLateBound though.\n-            ty::ReSkolemized(..) | ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+            ty::RePlaceholder(..) | ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n                 (format!(\"lifetime {:?}\", region), None)\n             }\n "}, {"sha": "969d260d97e218d2989717c604682c9f9234e438", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::ReFree(_) |\n             ty::ReScope(_) |\n             ty::ReVar(_) |\n-            ty::ReSkolemized(..) |\n+            ty::RePlaceholder(..) |\n             ty::ReEmpty |\n             ty::ReErased => {\n                 // replace all free regions with 'erased"}, {"sha": "b1ac8bae4fb986bbbfd8239c7d8173a542e95a82", "filename": "src/librustc/infer/higher_ranked/README.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -72,11 +72,11 @@ the same lifetime, but not the reverse.\n Here is the algorithm we use to perform the subtyping check:\n \n 1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with skolemized\n-   equivalents. A \"skolemized\" region is just a new fresh region\n+2. Replace all bound regions in the supertype with placeholder\n+   equivalents. A \"placeholder\" region is just a new fresh region\n    name.\n 3. Check that the parameter and return types match as normal\n-4. Ensure that no skolemized regions 'leak' into region variables\n+4. Ensure that no placeholder regions 'leak' into region variables\n    visible from \"the outside\"\n \n Let's walk through some examples and see how this algorithm plays out.\n@@ -95,7 +95,7 @@ like so:\n Here the upper case `&A` indicates a *region variable*, that is, a\n region whose value is being inferred by the system. I also replaced\n `&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate skolemized region names. We can assume they don't appear\n+to indicate placeholder region names. We can assume they don't appear\n elsewhere. Note that neither the sub- nor the supertype bind any\n region names anymore (as indicated by the absence of `<` and `>`).\n \n@@ -133,7 +133,7 @@ match. This will ultimately require (as before) that `'a` <= `&x`\n must hold: but this does not hold. `self` and `x` are both distinct\n free regions. So the subtype check fails.\n \n-#### Checking for skolemization leaks\n+#### Checking for placeholder leaks\n \n You may be wondering about that mysterious last step in the algorithm.\n So far it has not been relevant. The purpose of that last step is to\n@@ -159,7 +159,7 @@ Now we compare the return types, which are covariant, and hence we have:\n \n     fn(&'A T) <: for<'b> fn(&'b T)?\n \n-Here we skolemize the bound region in the supertype to yield:\n+Here we replace the bound region in the supertype with a placeholder to yield:\n \n     fn(&'A T) <: fn(&'x T)?\n \n@@ -175,23 +175,23 @@ region `x` and think that everything is happy. In fact, this behavior\n is *necessary*, it was key to the first example we walked through.\n \n The difference between this example and the first one is that the variable\n-`A` already existed at the point where the skolemization occurred. In\n+`A` already existed at the point where the placeholders were added. In\n the first example, you had two functions:\n \n     for<'a> fn(&'a T) <: for<'b> fn(&'b T)\n \n and hence `&A` and `&x` were created \"together\". In general, the\n-intention of the skolemized names is that they are supposed to be\n+intention of the placeholder names is that they are supposed to be\n fresh names that could never be equal to anything from the outside.\n But when inference comes into play, we might not be respecting this\n rule.\n \n So the way we solve this is to add a fourth step that examines the\n-constraints that refer to skolemized names. Basically, consider a\n+constraints that refer to placeholder names. Basically, consider a\n non-directed version of the constraint graph. Let `Tainted(x)` be the\n-set of all things reachable from a skolemized variable `x`.\n+set of all things reachable from a placeholder variable `x`.\n `Tainted(x)` should not contain any regions that existed before the\n-step at which the skolemization was performed. So this case here\n+step at which the placeholders were created. So this case here\n would fail because `&x` was created alone, but is relatable to `&A`.\n \n ## Computing the LUB and GLB"}, {"sha": "e77d20665bf3bd7b510f3138624bbd4ffee2bbc2", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 116, "deletions": 103, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -15,7 +15,7 @@ use super::{CombinedSnapshot,\n             InferCtxt,\n             HigherRankedType,\n             SubregionOrigin,\n-            SkolemizationMap};\n+            PlaceholderMap};\n use super::combine::CombineFields;\n use super::region_constraints::{TaintDirections};\n \n@@ -51,32 +51,34 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         return self.infcx.commit_if_ok(|snapshot| {\n             let span = self.trace.cause.span;\n \n-            // First, we instantiate each bound region in the subtype with a fresh\n-            // region variable.\n+            // First, we instantiate each bound region in the supertype with a\n+            // fresh placeholder region.\n+            let (b_prime, placeholder_map) =\n+                self.infcx.replace_late_bound_regions_with_placeholders(b);\n+\n+            // Next, we instantiate each bound region in the subtype\n+            // with a fresh region variable. These region variables --\n+            // but no other pre-existing region variables -- can name\n+            // the placeholders.\n             let (a_prime, _) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span,\n                     HigherRankedType,\n                     a);\n \n-            // Second, we instantiate each bound region in the supertype with a\n-            // fresh concrete region.\n-            let (b_prime, skol_map) =\n-                self.infcx.skolemize_late_bound_regions(b);\n-\n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n             let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n \n             // Presuming type comparison succeeds, we need to check\n-            // that the skolemized regions do not \"leak\".\n-            self.infcx.leak_check(!a_is_expected, span, &skol_map, snapshot)?;\n+            // that the placeholder regions do not \"leak\".\n+            self.infcx.leak_check(!a_is_expected, span, &placeholder_map, snapshot)?;\n \n-            // We are finished with the skolemized regions now so pop\n+            // We are finished with the placeholder regions now so pop\n             // them off.\n-            self.infcx.pop_skolemized(skol_map, snapshot);\n+            self.infcx.pop_placeholders(placeholder_map, snapshot);\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n@@ -112,68 +114,68 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // created as part of this type comparison\".\n         return self.infcx.commit_if_ok(|snapshot| {\n             // First, we instantiate each bound region in the matcher\n-            // with a skolemized region.\n-            let ((a_match, a_value), skol_map) =\n-                self.infcx.skolemize_late_bound_regions(a_pair);\n+            // with a placeholder region.\n+            let ((a_match, a_value), placeholder_map) =\n+                self.infcx.replace_late_bound_regions_with_placeholders(a_pair);\n \n             debug!(\"higher_ranked_match: a_match={:?}\", a_match);\n-            debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n+            debug!(\"higher_ranked_match: placeholder_map={:?}\", placeholder_map);\n \n             // Equate types now that bound regions have been replaced.\n             self.equate(a_is_expected).relate(&a_match, &b_match)?;\n \n-            // Map each skolemized region to a vector of other regions that it\n+            // Map each placeholder region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n-            // skolemized regions from `skol_map`.)\n-            let skol_resolution_map: FxHashMap<_, _> =\n-                skol_map\n+            // placeholder regions from `placeholder_map`.)\n+            let placeholder_resolution_map: FxHashMap<_, _> =\n+                placeholder_map\n                 .iter()\n-                .map(|(&br, &skol)| {\n+                .map(|(&br, &placeholder)| {\n                     let tainted_regions =\n                         self.infcx.tainted_regions(snapshot,\n-                                                   skol,\n+                                                   placeholder,\n                                                    TaintDirections::incoming()); // [1]\n \n-                    // [1] this routine executes after the skolemized\n+                    // [1] this routine executes after the placeholder\n                     // regions have been *equated* with something\n                     // else, so examining the incoming edges ought to\n                     // be enough to collect all constraints\n \n-                    (skol, (br, tainted_regions))\n+                    (placeholder, (br, tainted_regions))\n                 })\n                 .collect();\n \n-            // For each skolemized region, pick a representative -- which can\n+            // For each placeholder region, pick a representative -- which can\n             // be any region from the sets above, except for other members of\n-            // `skol_map`. There should always be a representative if things\n+            // `placeholder_map`. There should always be a representative if things\n             // are properly well-formed.\n-            let skol_representatives: FxHashMap<_, _> =\n-                skol_resolution_map\n+            let placeholder_representatives: FxHashMap<_, _> =\n+                placeholder_resolution_map\n                 .iter()\n-                .map(|(&skol, &(_, ref regions))| {\n+                .map(|(&placeholder, &(_, ref regions))| {\n                     let representative =\n                         regions.iter()\n-                               .filter(|&&r| !skol_resolution_map.contains_key(r))\n+                               .filter(|&&r| !placeholder_resolution_map.contains_key(r))\n                                .cloned()\n                                .next()\n                                .unwrap_or_else(|| {\n                                    bug!(\"no representative region for `{:?}` in `{:?}`\",\n-                                        skol, regions)\n+                                        placeholder, regions)\n                                });\n \n-                    (skol, representative)\n+                    (placeholder, representative)\n                 })\n                 .collect();\n \n-            // Equate all the members of each skolemization set with the\n+            // Equate all the members of each placeholder set with the\n             // representative.\n-            for (skol, &(_br, ref regions)) in &skol_resolution_map {\n-                let representative = &skol_representatives[skol];\n+            for (placeholder, &(_br, ref regions)) in &placeholder_resolution_map {\n+                let representative = &placeholder_representatives[placeholder];\n                 debug!(\"higher_ranked_match: \\\n-                        skol={:?} representative={:?} regions={:?}\",\n-                       skol, representative, regions);\n+                        placeholder={:?} representative={:?} regions={:?}\",\n+                       placeholder, representative, regions);\n                 for region in regions.iter()\n-                                     .filter(|&r| !skol_resolution_map.contains_key(r))\n+                                     .filter(|&r| !placeholder_resolution_map.contains_key(r))\n                                      .filter(|&r| r != representative)\n                 {\n                     let origin = SubregionOrigin::Subtype(self.trace.clone());\n@@ -184,18 +186,18 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            // Replace the skolemized regions appearing in value with\n+            // Replace the placeholder regions appearing in value with\n             // their representatives\n             let a_value =\n                 fold_regions_in(\n                     self.tcx(),\n                     &a_value,\n-                    |r, _| skol_representatives.get(&r).cloned().unwrap_or(r));\n+                    |r, _| placeholder_representatives.get(&r).cloned().unwrap_or(r));\n \n             debug!(\"higher_ranked_match: value={:?}\", a_value);\n \n-            // We are now done with these skolemized variables.\n-            self.infcx.pop_skolemized(skol_map, snapshot);\n+            // We are now done with these placeholder variables.\n+            self.infcx.pop_placeholders(placeholder_map, snapshot);\n \n             Ok(HrMatchResult { value: a_value })\n         });\n@@ -500,7 +502,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n          * started. This is used in the sub/lub/glb computations. The\n          * idea here is that when we are computing lub/glb of two\n          * regions, we sometimes create intermediate region variables.\n-         * Those region variables may touch some of the skolemized or\n+         * Those region variables may touch some of the placeholder or\n          * other \"forbidden\" regions we created to replace bound\n          * regions, but they don't really represent an \"external\"\n          * constraint.\n@@ -527,10 +529,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n          * we're not careful, it will succeed.\n          *\n          * The reason is that when we walk through the subtyping\n-         * algorithm, we begin by replacing `'a` with a skolemized\n+         * algorithm, we begin by replacing `'a` with a placeholder\n          * variable `'1`. We then have `fn(_#0t) <: fn(&'1 int)`. This\n          * can be made true by unifying `_#0t` with `&'1 int`. In the\n-         * process, we create a fresh variable for the skolemized\n+         * process, we create a fresh variable for the placeholder\n          * region, `'$2`, and hence we have that `_#0t == &'$2\n          * int`. However, because `'$2` was created during the sub\n          * computation, if we're not careful we will erroneously\n@@ -568,33 +570,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_vars\n     }\n \n-    /// Replace all regions bound by `binder` with skolemized regions and\n+    /// Replace all regions bound by `binder` with placeholder regions and\n     /// return a map indicating which bound-region was replaced with what\n-    /// skolemized region. This is the first step of checking subtyping\n+    /// placeholder region. This is the first step of checking subtyping\n     /// when higher-ranked things are involved.\n     ///\n     /// **Important:** you must call this function from within a snapshot.\n     /// Moreover, before committing the snapshot, you must eventually call\n-    /// either `plug_leaks` or `pop_skolemized` to remove the skolemized\n+    /// either `plug_leaks` or `pop_placeholders` to remove the placeholder\n     /// regions. If you rollback the snapshot (or are using a probe), then\n     /// the pop occurs as part of the rollback, so an explicit call is not\n     /// needed (but is also permitted).\n     ///\n-    /// For more information about how skolemization for HRTBs works, see\n+    /// For more information about how placeholders and HRTBs work, see\n     /// the [rustc guide].\n     ///\n     /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/traits/hrtb.html\n-    pub fn skolemize_late_bound_regions<T>(&self,\n-                                           binder: &ty::Binder<T>)\n-                                           -> (T, SkolemizationMap<'tcx>)\n-        where T : TypeFoldable<'tcx>\n+    pub fn replace_late_bound_regions_with_placeholders<T>(\n+        &self,\n+        binder: &ty::Binder<T>,\n+    ) -> (T, PlaceholderMap<'tcx>)\n+    where\n+        T : TypeFoldable<'tcx>,\n     {\n+        let new_universe = self.create_subuniverse();\n+\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.universe.set(self.universe().subuniverse());\n-            self.tcx.mk_region(ty::ReSkolemized(self.universe(), br))\n+            self.tcx.mk_region(ty::RePlaceholder(ty::Placeholder {\n+                universe: new_universe,\n+                name: br,\n+            }))\n         });\n \n-        debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n+        debug!(\"replace_late_bound_regions_with_placeholders(binder={:?}, result={:?}, map={:?})\",\n                binder,\n                result,\n                map);\n@@ -603,19 +611,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Searches the region constraints created since `snapshot` was started\n-    /// and checks to determine whether any of the skolemized regions created\n-    /// in `skol_map` would \"escape\" -- meaning that they are related to\n+    /// and checks to determine whether any of the placeholder regions created\n+    /// in `placeholder_map` would \"escape\" -- meaning that they are related to\n     /// other regions in some way. If so, the higher-ranked subtyping doesn't\n     /// hold. See `README.md` for more details.\n     pub fn leak_check(&self,\n                       overly_polymorphic: bool,\n                       _span: Span,\n-                      skol_map: &SkolemizationMap<'tcx>,\n+                      placeholder_map: &PlaceholderMap<'tcx>,\n                       snapshot: &CombinedSnapshot<'a, 'tcx>)\n                       -> RelateResult<'tcx, ()>\n     {\n-        debug!(\"leak_check: skol_map={:?}\",\n-               skol_map);\n+        debug!(\"leak_check: placeholder_map={:?}\",\n+               placeholder_map);\n \n         // If the user gave `-Zno-leak-check`, then skip the leak\n         // check completely. This is wildly unsound and also not\n@@ -630,14 +638,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n-        for (&skol_br, &skol) in skol_map {\n-            // The inputs to a skolemized variable can only\n+        for (&placeholder_br, &placeholder) in placeholder_map {\n+            // The inputs to a placeholder variable can only\n             // be itself or other new variables.\n             let incoming_taints = self.tainted_regions(snapshot,\n-                                                       skol,\n+                                                       placeholder,\n                                                        TaintDirections::both());\n             for &tainted_region in &incoming_taints {\n-                // Each skolemized should only be relatable to itself\n+                // Each placeholder should only be relatable to itself\n                 // or new variables:\n                 match *tainted_region {\n                     ty::ReVar(vid) => {\n@@ -646,31 +654,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     _ => {\n-                        if tainted_region == skol { continue; }\n+                        if tainted_region == placeholder { continue; }\n                     }\n                 };\n \n                 debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n-                       skol,\n-                       skol_br,\n+                       placeholder,\n+                       placeholder_br,\n                        tainted_region);\n \n                 return Err(if overly_polymorphic {\n                     debug!(\"Overly polymorphic!\");\n-                    TypeError::RegionsOverlyPolymorphic(skol_br, tainted_region)\n+                    TypeError::RegionsOverlyPolymorphic(placeholder_br, tainted_region)\n                 } else {\n                     debug!(\"Not as polymorphic!\");\n-                    TypeError::RegionsInsufficientlyPolymorphic(skol_br, tainted_region)\n+                    TypeError::RegionsInsufficientlyPolymorphic(placeholder_br, tainted_region)\n                 })\n             }\n         }\n \n         Ok(())\n     }\n \n-    /// This code converts from skolemized regions back to late-bound\n+    /// This code converts from placeholder regions back to late-bound\n     /// regions. It works by replacing each region in the taint set of a\n-    /// skolemized region with a bound-region. The bound region will be bound\n+    /// placeholder region with a bound-region. The bound region will be bound\n     /// by the outer-most binder in `value`; the caller must ensure that there is\n     /// such a binder and it is the right place.\n     ///\n@@ -687,7 +695,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///         where A : Clone\n     ///     { ... }\n     ///\n-    /// Here we will have replaced `'a` with a skolemized region\n+    /// Here we will have replaced `'a` with a placeholder region\n     /// `'0`. This means that our substitution will be `{A=>&'0\n     /// int, R=>&'0 int}`.\n     ///\n@@ -697,65 +705,65 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// to the depth of the predicate, in this case 1, so that the final\n     /// predicate is `for<'a> &'a int : Clone`.\n     pub fn plug_leaks<T>(&self,\n-                         skol_map: SkolemizationMap<'tcx>,\n+                         placeholder_map: PlaceholderMap<'tcx>,\n                          snapshot: &CombinedSnapshot<'a, 'tcx>,\n                          value: T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n-               skol_map,\n+        debug!(\"plug_leaks(placeholder_map={:?}, value={:?})\",\n+               placeholder_map,\n                value);\n \n-        if skol_map.is_empty() {\n+        if placeholder_map.is_empty() {\n             return value;\n         }\n \n-        // Compute a mapping from the \"taint set\" of each skolemized\n+        // Compute a mapping from the \"taint set\" of each placeholder\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n-            skol_map\n+        let inv_placeholder_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n+            placeholder_map\n             .iter()\n-            .flat_map(|(&skol_br, &skol)| {\n-                self.tainted_regions(snapshot, skol, TaintDirections::both())\n+            .flat_map(|(&placeholder_br, &placeholder)| {\n+                self.tainted_regions(snapshot, placeholder, TaintDirections::both())\n                     .into_iter()\n-                    .map(move |tainted_region| (tainted_region, skol_br))\n+                    .map(move |tainted_region| (tainted_region, placeholder_br))\n             })\n             .collect();\n \n-        debug!(\"plug_leaks: inv_skol_map={:?}\",\n-               inv_skol_map);\n+        debug!(\"plug_leaks: inv_placeholder_map={:?}\",\n+               inv_placeholder_map);\n \n         // Remove any instantiated type variables from `value`; those can hide\n         // references to regions from the `fold_regions` code below.\n         let value = self.resolve_type_vars_if_possible(&value);\n \n-        // Map any skolemization byproducts back to a late-bound\n+        // Map any placeholder byproducts back to a late-bound\n         // region. Put that late-bound region at whatever the outermost\n         // binder is that we encountered in `value`. The caller is\n         // responsible for ensuring that (a) `value` contains at least one\n         // binder and (b) that binder is the one we want to use.\n         let result = self.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n-            match inv_skol_map.get(&r) {\n+            match inv_placeholder_map.get(&r) {\n                 None => r,\n                 Some(br) => {\n                     // It is the responsibility of the caller to ensure\n-                    // that each skolemized region appears within a\n+                    // that each placeholder region appears within a\n                     // binder. In practice, this routine is only used by\n-                    // trait checking, and all of the skolemized regions\n+                    // trait checking, and all of the placeholder regions\n                     // appear inside predicates, which always have\n                     // binders, so this assert is satisfied.\n                     assert!(current_depth > ty::INNERMOST);\n \n-                    // since leak-check passed, this skolemized region\n+                    // since leak-check passed, this placeholder region\n                     // should only have incoming edges from variables\n                     // (which ought not to escape the snapshot, but we\n                     // don't check that) or itself\n                     assert!(\n                         match *r {\n                             ty::ReVar(_) => true,\n-                            ty::ReSkolemized(_, ref br1) => br == br1,\n+                            ty::RePlaceholder(index) => index.name == *br,\n                             _ => false,\n                         },\n                         \"leak-check would have us replace {:?} with {:?}\",\n@@ -769,31 +777,36 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        self.pop_skolemized(skol_map, snapshot);\n+        self.pop_placeholders(placeholder_map, snapshot);\n \n         debug!(\"plug_leaks: result={:?}\", result);\n \n         result\n     }\n \n-    /// Pops the skolemized regions found in `skol_map` from the region\n-    /// inference context. Whenever you create skolemized regions via\n-    /// `skolemize_late_bound_regions`, they must be popped before you\n+    /// Pops the placeholder regions found in `placeholder_map` from the region\n+    /// inference context. Whenever you create placeholder regions via\n+    /// `replace_late_bound_regions_with_placeholders`, they must be popped before you\n     /// commit the enclosing snapshot (if you do not commit, e.g. within a\n     /// probe or as a result of an error, then this is not necessary, as\n     /// popping happens as part of the rollback).\n     ///\n     /// Note: popping also occurs implicitly as part of `leak_check`.\n-    pub fn pop_skolemized(&self,\n-                          skol_map: SkolemizationMap<'tcx>,\n-                          snapshot: &CombinedSnapshot<'a, 'tcx>) {\n-        debug!(\"pop_skolemized({:?})\", skol_map);\n-        let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n+    pub fn pop_placeholders(\n+        &self,\n+        placeholder_map: PlaceholderMap<'tcx>,\n+        snapshot: &CombinedSnapshot<'a, 'tcx>,\n+    ) {\n+        debug!(\"pop_placeholders({:?})\", placeholder_map);\n+        let placeholder_regions: FxHashSet<_> = placeholder_map.values().cloned().collect();\n         self.borrow_region_constraints()\n-            .pop_skolemized(self.universe(), &skol_regions, &snapshot.region_constraints_snapshot);\n+            .pop_placeholders(\n+                &placeholder_regions,\n+                &snapshot.region_constraints_snapshot,\n+            );\n         self.universe.set(snapshot.universe);\n-        if !skol_map.is_empty() {\n-            self.projection_cache.borrow_mut().rollback_skolemized(\n+        if !placeholder_map.is_empty() {\n+            self.projection_cache.borrow_mut().rollback_placeholder(\n                 &snapshot.projection_cache_snapshot);\n         }\n     }"}, {"sha": "caba8b514f7972498bf54aa3623312ae2d374840", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -28,7 +28,7 @@ use std::u32;\n use ty::fold::TypeFoldable;\n use ty::{self, Ty, TyCtxt};\n use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n+use ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n use ty::{Region, RegionVid};\n \n mod graphviz;\n@@ -341,7 +341,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (&ReSkolemized(..), _) | (_, &ReSkolemized(..)) => if a == b {\n+            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => if a == b {\n                 a\n             } else {\n                 tcx.types.re_static"}, {"sha": "291b46edccfb2342b6b9f981fd4865d1d95ba4b7", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -229,9 +229,10 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     universe: Cell<ty::UniverseIndex>,\n }\n \n-/// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n-/// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n+/// A map returned by `replace_late_bound_regions_with_placeholders()`\n+/// indicating the placeholder region that each late-bound region was\n+/// replaced with.\n+pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n /// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n@@ -405,12 +406,14 @@ pub enum RegionVariableOrigin {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum NLLRegionVariableOrigin {\n-    // During NLL region processing, we create variables for free\n-    // regions that we encounter in the function signature and\n-    // elsewhere. This origin indices we've got one of those.\n+    /// During NLL region processing, we create variables for free\n+    /// regions that we encounter in the function signature and\n+    /// elsewhere. This origin indices we've got one of those.\n     FreeRegion,\n \n-    BoundRegion(ty::UniverseIndex),\n+    /// \"Universal\" instantiation of a higher-ranked region (e.g.,\n+    /// from a `for<'a> T` binder). Meant to represent \"any region\".\n+    Placeholder(ty::Placeholder),\n \n     Existential,\n }\n@@ -419,7 +422,7 @@ impl NLLRegionVariableOrigin {\n     pub fn is_universal(self) -> bool {\n         match self {\n             NLLRegionVariableOrigin::FreeRegion => true,\n-            NLLRegionVariableOrigin::BoundRegion(..) => true,\n+            NLLRegionVariableOrigin::Placeholder(..) => true,\n             NLLRegionVariableOrigin::Existential => false,\n         }\n     }\n@@ -913,13 +916,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     a,\n                     b,\n                 },\n-                skol_map,\n-            ) = self.skolemize_late_bound_regions(predicate);\n+                placeholder_map,\n+            ) = self.replace_late_bound_regions_with_placeholders(predicate);\n \n             let cause_span = cause.span;\n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n-            self.leak_check(false, cause_span, &skol_map, snapshot)?;\n-            self.pop_skolemized(skol_map, snapshot);\n+            self.leak_check(false, cause_span, &placeholder_map, snapshot)?;\n+            self.pop_placeholders(placeholder_map, snapshot);\n             Ok(ok.unit())\n         }))\n     }\n@@ -930,14 +933,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n-                self.skolemize_late_bound_regions(predicate);\n+            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n+                self.replace_late_bound_regions_with_placeholders(predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)\n             });\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, cause.span, &skol_map, snapshot)?;\n-            Ok(self.pop_skolemized(skol_map, snapshot))\n+            self.leak_check(false, cause.span, &placeholder_map, snapshot)?;\n+            Ok(self.pop_placeholders(placeholder_map, snapshot))\n         })\n     }\n "}, {"sha": "525ae03dfaf934eca8931a5ff93353fd5efa90f4", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 43, "deletions": 75, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -10,19 +10,19 @@\n \n //! See README.md\n \n-use self::UndoLogEntry::*;\n use self::CombineMapType::*;\n+use self::UndoLogEntry::*;\n \n-use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n use super::unify_key;\n+use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n \n-use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::unify as ut;\n-use ty::{self, Ty, TyCtxt};\n-use ty::{Region, RegionVid};\n use ty::ReStatic;\n+use ty::{self, Ty, TyCtxt};\n use ty::{BrFresh, ReLateBound, ReVar};\n+use ty::{Region, RegionVid};\n \n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem, u32};\n@@ -306,10 +306,10 @@ pub struct RegionSnapshot {\n     any_unifications: bool,\n }\n \n-/// When working with skolemized regions, we often wish to find all of\n-/// the regions that are either reachable from a skolemized region, or\n-/// which can reach a skolemized region, or both. We call such regions\n-/// *tained* regions.  This struct allows you to decide what set of\n+/// When working with placeholder regions, we often wish to find all of\n+/// the regions that are either reachable from a placeholder region, or\n+/// which can reach a placeholder region, or both. We call such regions\n+/// *tainted* regions.  This struct allows you to decide what set of\n /// tainted regions you want.\n #[derive(Debug)]\n pub struct TaintDirections {\n@@ -495,13 +495,12 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    pub fn new_region_var(&mut self,\n-                          universe: ty::UniverseIndex,\n-                          origin: RegionVariableOrigin) -> RegionVid {\n-        let vid = self.var_infos.push(RegionVariableInfo {\n-            origin,\n-            universe,\n-        });\n+    pub fn new_region_var(\n+        &mut self,\n+        universe: ty::UniverseIndex,\n+        origin: RegionVariableOrigin,\n+    ) -> RegionVid {\n+        let vid = self.var_infos.push(RegionVariableInfo { origin, universe });\n \n         let u_vid = self.unification_table\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n@@ -511,8 +510,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n         debug!(\n             \"created new region variable {:?} with origin {:?}\",\n-            vid,\n-            origin\n+            vid, origin\n         );\n         return vid;\n     }\n@@ -527,51 +525,25 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         self.var_infos[vid].origin\n     }\n \n-    /// Removes all the edges to/from the skolemized regions that are\n+    /// Removes all the edges to/from the placeholder regions that are\n     /// in `skols`. This is used after a higher-ranked operation\n-    /// completes to remove all trace of the skolemized regions\n+    /// completes to remove all trace of the placeholder regions\n     /// created in that time.\n-    pub fn pop_skolemized(\n+    pub fn pop_placeholders(\n         &mut self,\n-        skolemization_count: ty::UniverseIndex,\n-        skols: &FxHashSet<ty::Region<'tcx>>,\n+        placeholders: &FxHashSet<ty::Region<'tcx>>,\n         snapshot: &RegionSnapshot,\n     ) {\n-        debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n+        debug!(\"pop_placeholders(placeholders={:?})\", placeholders);\n \n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n-        assert!(\n-            skolemization_count.as_usize() >= skols.len(),\n-            \"popping more skolemized variables than actually exist, \\\n-             sc now = {:?}, skols.len = {:?}\",\n-            skolemization_count,\n-            skols.len()\n-        );\n-\n-        let last_to_pop = skolemization_count.subuniverse();\n-        let first_to_pop = ty::UniverseIndex::from(last_to_pop.as_u32() - skols.len() as u32);\n-\n-        debug_assert! {\n-            skols.iter()\n-                 .all(|&k| match *k {\n-                     ty::ReSkolemized(universe, _) =>\n-                         universe >= first_to_pop &&\n-                         universe < last_to_pop,\n-                     _ =>\n-                         false\n-                 }),\n-            \"invalid skolemization keys or keys out of range ({:?}..{:?}): {:?}\",\n-            first_to_pop,\n-            last_to_pop,\n-            skols\n-        }\n \n         let constraints_to_kill: Vec<usize> = self.undo_log\n             .iter()\n             .enumerate()\n             .rev()\n-            .filter(|&(_, undo_entry)| kill_constraint(skols, undo_entry))\n+            .filter(|&(_, undo_entry)| kill_constraint(placeholders, undo_entry))\n             .map(|(index, _)| index)\n             .collect();\n \n@@ -583,20 +555,20 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         return;\n \n         fn kill_constraint<'tcx>(\n-            skols: &FxHashSet<ty::Region<'tcx>>,\n+            placeholders: &FxHashSet<ty::Region<'tcx>>,\n             undo_entry: &UndoLogEntry<'tcx>,\n         ) -> bool {\n             match undo_entry {\n                 &AddConstraint(Constraint::VarSubVar(..)) => false,\n-                &AddConstraint(Constraint::RegSubVar(a, _)) => skols.contains(&a),\n-                &AddConstraint(Constraint::VarSubReg(_, b)) => skols.contains(&b),\n+                &AddConstraint(Constraint::RegSubVar(a, _)) => placeholders.contains(&a),\n+                &AddConstraint(Constraint::VarSubReg(_, b)) => placeholders.contains(&b),\n                 &AddConstraint(Constraint::RegSubReg(a, b)) => {\n-                    skols.contains(&a) || skols.contains(&b)\n+                    placeholders.contains(&a) || placeholders.contains(&b)\n                 }\n                 &AddGiven(..) => false,\n                 &AddVerify(_) => false,\n                 &AddCombination(_, ref two_regions) => {\n-                    skols.contains(&two_regions.a) || skols.contains(&two_regions.b)\n+                    placeholders.contains(&two_regions.a) || placeholders.contains(&two_regions.b)\n                 }\n                 &AddVar(..) | &OpenSnapshot | &Purged | &CommitedSnapshot => false,\n             }\n@@ -713,9 +685,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // cannot add constraints once regions are resolved\n         debug!(\n             \"RegionConstraintCollector: make_subregion({:?}, {:?}) due to {:?}\",\n-            sub,\n-            sup,\n-            origin\n+            sub, sup, origin\n         );\n \n         match (sub, sup) {\n@@ -854,19 +824,19 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     fn universe(&self, region: Region<'tcx>) -> ty::UniverseIndex {\n         match *region {\n-            ty::ReScope(..) |\n-            ty::ReStatic |\n-            ty::ReEmpty |\n-            ty::ReErased |\n-            ty::ReFree(..) |\n-            ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n-            ty::ReSkolemized(universe, _) => universe,\n-            ty::ReClosureBound(vid) |\n-            ty::ReVar(vid) => self.var_universe(vid),\n-            ty::ReLateBound(..) =>\n-                bug!(\"universe(): encountered bound region {:?}\", region),\n-            ty::ReCanonical(..) =>\n-                bug!(\"region_universe(): encountered canonical region {:?}\", region),\n+            ty::ReScope(..)\n+            | ty::ReStatic\n+            | ty::ReEmpty\n+            | ty::ReErased\n+            | ty::ReFree(..)\n+            | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::RePlaceholder(placeholder) => placeholder.universe,\n+            ty::ReClosureBound(vid) | ty::ReVar(vid) => self.var_universe(vid),\n+            ty::ReLateBound(..) => bug!(\"universe(): encountered bound region {:?}\", region),\n+            ty::ReCanonical(..) => bug!(\n+                \"region_universe(): encountered canonical region {:?}\",\n+                region\n+            ),\n         }\n     }\n \n@@ -886,7 +856,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// relations are considered. For example, one can say that only\n     /// \"incoming\" edges to `r0` are desired, in which case one will\n     /// get the set of regions `{r|r <= r0}`. This is used when\n-    /// checking whether skolemized regions are being improperly\n+    /// checking whether placeholder regions are being improperly\n     /// related to other regions.\n     pub fn tainted(\n         &self,\n@@ -897,9 +867,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     ) -> FxHashSet<ty::Region<'tcx>> {\n         debug!(\n             \"tainted(mark={:?}, r0={:?}, directions={:?})\",\n-            mark,\n-            r0,\n-            directions\n+            mark, r0, directions\n         );\n \n         // `result_set` acts as a worklist: we explore all outgoing"}, {"sha": "7add8ef05ee78377340d2bc9bfe6f90ea68f582a", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -117,7 +117,7 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n \n-    // For the purposes of this check, we don't bring any skolemized\n+    // For the purposes of this check, we don't bring any placeholder\n     // types into scope; instead, we replace the generic types with\n     // fresh type variables, and hence we do our evaluations in an\n     // empty environment."}, {"sha": "7c1f87fbf3fefe1f25e2f488e1952e1e485ae8e1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -206,15 +206,15 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n \n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|snapshot| {\n-        let (skol_predicate, skol_map) =\n-            infcx.skolemize_late_bound_regions(&obligation.predicate);\n+        let (placeholder_predicate, placeholder_map) =\n+            infcx.replace_late_bound_regions_with_placeholders(&obligation.predicate);\n \n-        let skol_obligation = obligation.with(skol_predicate);\n+        let skol_obligation = obligation.with(placeholder_predicate);\n         let r = match project_and_unify_type(selcx, &skol_obligation) {\n             Ok(result) => {\n                 let span = obligation.cause.span;\n-                match infcx.leak_check(false, span, &skol_map, snapshot) {\n-                    Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, result)),\n+                match infcx.leak_check(false, span, &placeholder_map, snapshot) {\n+                    Ok(()) => Ok(infcx.plug_leaks(placeholder_map, snapshot, result)),\n                     Err(e) => {\n                         debug!(\"poly_project_and_unify_type: leak check encountered error {:?}\", e);\n                         Err(MismatchedProjectionTypes { err: e })\n@@ -1571,11 +1571,11 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n \n // # Cache\n \n-/// The projection cache. Unlike the standard caches, this can\n-/// include infcx-dependent type variables - therefore, we have to roll\n-/// the cache back each time we roll a snapshot back, to avoid assumptions\n-/// on yet-unresolved inference variables. Types with skolemized regions\n-/// also have to be removed when the respective snapshot ends.\n+/// The projection cache. Unlike the standard caches, this can include\n+/// infcx-dependent type variables - therefore, we have to roll the\n+/// cache back each time we roll a snapshot back, to avoid assumptions\n+/// on yet-unresolved inference variables. Types with placeholder\n+/// regions also have to be removed when the respective snapshot ends.\n ///\n /// Because of that, projection cache entries can be \"stranded\" and left\n /// inaccessible when type variables inside the key are resolved. We make no\n@@ -1661,7 +1661,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n         self.map.rollback_to(&snapshot.snapshot);\n     }\n \n-    pub fn rollback_skolemized(&mut self, snapshot: &ProjectionCacheSnapshot) {\n+    pub fn rollback_placeholder(&mut self, snapshot: &ProjectionCacheSnapshot) {\n         self.map.partial_rollback(&snapshot.snapshot, &|k| k.ty.has_re_skol());\n     }\n "}, {"sha": "82d881e10b1688304313581adbd9d1977485650b", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1379, "deletions": 1134, "changes": 2513, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc"}, {"sha": "2c713c0f7f1aacba204236ff10315f49a859e62c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -184,7 +184,7 @@ pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return false;\n     }\n \n-    // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n+    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n     let penv = tcx.param_env(impl1_def_id);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n "}, {"sha": "a1edf67e47552215e02420ed32196b145feb5d36", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -218,9 +218,9 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::IntVar(_)) => \"integral variable\".to_string(),\n             ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n             ty::Infer(ty::CanonicalTy(_)) |\n-            ty::Infer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n-            ty::Infer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n-            ty::Infer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n+            ty::Infer(ty::FreshTy(_)) => \"fresh type\".to_string(),\n+            ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".to_string(),\n+            ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".to_string(),\n             ty::Projection(_) => \"associated type\".to_string(),\n             ty::UnnormalizedProjection(_) => \"non-normalized associated type\".to_string(),\n             ty::Param(ref p) => {"}, {"sha": "1c5ff85d69ba6d0428d4471bc16589a249cbd145", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -667,12 +667,14 @@ pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n /// we already use the term \"free region\". It refers to the regions that we use to represent bound\n /// regions on a fn definition while we are typechecking its body.\n ///\n-/// To clarify, conceptually there is no particular difference between an \"escaping\" region and a\n-/// \"free\" region. However, there is a big difference in practice. Basically, when \"entering\" a\n-/// binding level, one is generally required to do some sort of processing to a bound region, such\n-/// as replacing it with a fresh/skolemized region, or making an entry in the environment to\n-/// represent the scope to which it is attached, etc. An escaping region represents a bound region\n-/// for which this processing has not yet been done.\n+/// To clarify, conceptually there is no particular difference between\n+/// an \"escaping\" region and a \"free\" region. However, there is a big\n+/// difference in practice. Basically, when \"entering\" a binding\n+/// level, one is generally required to do some sort of processing to\n+/// a bound region, such as replacing it with a fresh/placeholder\n+/// region, or making an entry in the environment to represent the\n+/// scope to which it is attached, etc. An escaping region represents\n+/// a bound region for which this processing has not yet been done.\n struct HasEscapingRegionsVisitor {\n     /// Anything bound by `outer_index` or \"above\" is escaping\n     outer_index: ty::DebruijnIndex,"}, {"sha": "08a9f08519b7ebbdbb955b11ac2516e8faac021f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -1479,18 +1479,17 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// region `'a` is in a subuniverse U2 of U1, because we can name it\n /// inside the fn type but not outside.\n ///\n-/// Universes are related to **skolemization** -- which is a way of\n-/// doing type- and trait-checking around these \"forall\" binders (also\n-/// called **universal quantification**). The idea is that when, in\n-/// the body of `bar`, we refer to `T` as a type, we aren't referring\n-/// to any type in particular, but rather a kind of \"fresh\" type that\n-/// is distinct from all other types we have actually declared. This\n-/// is called a **skolemized** type, and we use universes to talk\n-/// about this. In other words, a type name in universe 0 always\n-/// corresponds to some \"ground\" type that the user declared, but a\n-/// type name in a non-zero universe is a skolemized type -- an\n-/// idealized representative of \"types in general\" that we use for\n-/// checking generic functions.\n+/// Universes are used to do type- and trait-checking around these\n+/// \"forall\" binders (also called **universal quantification**). The\n+/// idea is that when, in the body of `bar`, we refer to `T` as a\n+/// type, we aren't referring to any type in particular, but rather a\n+/// kind of \"fresh\" type that is distinct from all other types we have\n+/// actually declared. This is called a **placeholder** type, and we\n+/// use universes to talk about this. In other words, a type name in\n+/// universe 0 always corresponds to some \"ground\" type that the user\n+/// declared, but a type name in a non-zero universe is a placeholder\n+/// type -- an idealized representative of \"types in general\" that we\n+/// use for checking generic functions.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct UniverseIndex(u32);\n \n@@ -1553,6 +1552,18 @@ impl From<u32> for UniverseIndex {\n     }\n }\n \n+/// The \"placeholder index\" fully defines a placeholder region.\n+/// Placeholder regions are identified by both a **universe** as well\n+/// as a \"bound-region\" within that universe. The `bound_region` is\n+/// basically a name -- distinct bound regions within the same\n+/// universe are just two regions with an unknown relationship to one\n+/// another.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n+pub struct Placeholder {\n+    pub universe: UniverseIndex,\n+    pub name: BoundRegion,\n+}\n+\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point."}, {"sha": "db0756fb1905324b9d29dbc8bd3019f36768898c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -709,7 +709,7 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     /// Object types don't have a self-type specified. Therefore, when\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n-    /// or some skolemized type.\n+    /// or some placeholder type.\n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>  {\n         // otherwise the escaping regions would be captured by the binder\n@@ -732,7 +732,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     /// Object types don't have a self-type specified. Therefore, when\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n-    /// or some skolemized type.\n+    /// or some placeholder type.\n     pub fn with_self_ty(&self, tcx: TyCtxt<'_, '_, 'tcx>,\n                         self_ty: Ty<'tcx>)\n                         -> ty::PolyTraitRef<'tcx>  {\n@@ -743,7 +743,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// Binder is a binder for higher-ranked lifetimes. It is part of the\n /// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n-/// Binder<TraitRef>`). Note that when we skolemize, instantiate,\n+/// Binder<TraitRef>`). Note that when we instantiate,\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n@@ -1066,23 +1066,22 @@ pub type Region<'tcx> = &'tcx RegionKind;\n ///\n /// Unlike Param-s, bound regions are not supposed to exist \"in the wild\"\n /// outside their binder, e.g. in types passed to type inference, and\n-/// should first be substituted (by skolemized regions, free regions,\n+/// should first be substituted (by placeholder regions, free regions,\n /// or region variables).\n ///\n-/// ## Skolemized and Free Regions\n+/// ## Placeholder and Free Regions\n ///\n /// One often wants to work with bound regions without knowing their precise\n /// identity. For example, when checking a function, the lifetime of a borrow\n /// can end up being assigned to some region parameter. In these cases,\n /// it must be ensured that bounds on the region can't be accidentally\n /// assumed without being checked.\n ///\n-/// The process of doing that is called \"skolemization\". The bound regions\n-/// are replaced by skolemized markers, which don't satisfy any relation\n-/// not explicitly provided.\n+/// To do this, we replace the bound regions with placeholder markers,\n+/// which don't satisfy any relation not explicitly provided.\n ///\n-/// There are 2 kinds of skolemized regions in rustc: `ReFree` and\n-/// `ReSkolemized`. When checking an item's body, `ReFree` is supposed\n+/// There are 2 kinds of placeholder regions in rustc: `ReFree` and\n+/// `RePlaceholder`. When checking an item's body, `ReFree` is supposed\n /// to be used. These also support explicit bounds: both the internally-stored\n /// *scope*, which the region is assumed to outlive, as well as other\n /// relations stored in the `FreeRegionMap`. Note that these relations\n@@ -1091,14 +1090,14 @@ pub type Region<'tcx> = &'tcx RegionKind;\n ///\n /// When working with higher-ranked types, some region relations aren't\n /// yet known, so you can't just call `resolve_regions_and_report_errors`.\n-/// `ReSkolemized` is designed for this purpose. In these contexts,\n+/// `RePlaceholder` is designed for this purpose. In these contexts,\n /// there's also the risk that some inference variable laying around will\n-/// get unified with your skolemized region: if you want to check whether\n+/// get unified with your placeholder region: if you want to check whether\n /// `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a`\n-/// with a skolemized region `'%a`, the variable `'_` would just be\n-/// instantiated to the skolemized region `'%a`, which is wrong because\n+/// with a placeholder region `'%a`, the variable `'_` would just be\n+/// instantiated to the placeholder region `'%a`, which is wrong because\n /// the inference variable is supposed to satisfy the relation\n-/// *for every value of the skolemized region*. To ensure that doesn't\n+/// *for every value of the placeholder region*. To ensure that doesn't\n /// happen, you can use `leak_check`. This is more clearly explained\n /// by the [rustc guide].\n ///\n@@ -1132,9 +1131,9 @@ pub enum RegionKind {\n     /// A region variable.  Should not exist after typeck.\n     ReVar(RegionVid),\n \n-    /// A skolemized region - basically the higher-ranked version of ReFree.\n+    /// A placeholder region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(ty::UniverseIndex, BoundRegion),\n+    RePlaceholder(ty::Placeholder),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1338,7 +1337,7 @@ impl RegionKind {\n             RegionKind::ReScope(..) => false,\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n-            RegionKind::ReSkolemized(_, br) => br.is_named(),\n+            RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n             RegionKind::ReEmpty => false,\n             RegionKind::ReErased => false,\n             RegionKind::ReClosureBound(..) => false,\n@@ -1410,7 +1409,7 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n             }\n-            ty::ReSkolemized(..) => {\n+            ty::RePlaceholder(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_SKOL;\n             }"}, {"sha": "8c1482652ee29908053c4db23fc76a42b294ddb4", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -520,7 +520,7 @@ pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n-    // a skolemized type.\n+    // a placeholder type.\n     let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n     let predicates = existential_predicates.iter().filter_map(|predicate| {"}, {"sha": "33534ab27f1470e125e0ba0afc6de37f4fa804aa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -803,7 +803,7 @@ define_print! {\n                 }\n                 ty::ReLateBound(_, br) |\n                 ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-                ty::ReSkolemized(_, br) => {\n+                ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                     write!(f, \"{}\", br)\n                 }\n                 ty::ReScope(scope) if cx.identify_regions => {\n@@ -872,8 +872,8 @@ define_print! {\n                     write!(f, \"'?{}\", c.index())\n                 }\n \n-                ty::ReSkolemized(universe, ref bound_region) => {\n-                    write!(f, \"ReSkolemized({:?}, {:?})\", universe, bound_region)\n+                ty::RePlaceholder(placeholder) => {\n+                    write!(f, \"RePlaceholder({:?})\", placeholder)\n                 }\n \n                 ty::ReEmpty => write!(f, \"ReEmpty\"),"}, {"sha": "34ee03b895f9f6615522f5a4cf5e54f558950dd6", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -426,7 +426,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // These cannot exist in borrowck\n             RegionKind::ReVar(..) |\n             RegionKind::ReCanonical(..) |\n-            RegionKind::ReSkolemized(..) |\n+            RegionKind::RePlaceholder(..) |\n             RegionKind::ReClosureBound(..) |\n             RegionKind::ReErased => span_bug!(borrow_span,\n                                               \"unexpected region in borrowck {:?}\","}, {"sha": "1f83c30a3876a215b7a9c8fa584bc334bea2496a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReClosureBound(..) |\n                     ty::ReLateBound(..) |\n                     ty::ReVar(..) |\n-                    ty::ReSkolemized(..) |\n+                    ty::RePlaceholder(..) |\n                     ty::ReErased => {\n                         span_bug!(\n                             cmt.span,"}, {"sha": "1589d62300cab3f0d8e16710b0953d5c315d459b", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -1789,9 +1789,11 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n         // lifetimes without names with the value `'0`.\n         match ty.sty {\n             ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _)\n-            | ty::TyKind::Ref(ty::RegionKind::ReSkolemized(_, br), _, _) => {\n-                with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty))\n-            }\n+            | ty::TyKind::Ref(\n+                ty::RegionKind::RePlaceholder(ty::Placeholder { name: br, .. }),\n+                _,\n+                _,\n+            ) => with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty)),\n             _ => format!(\"{}\", ty),\n         }\n     }\n@@ -1801,7 +1803,8 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         match ty.sty {\n             ty::TyKind::Ref(region, _, _) => match region {\n-                ty::RegionKind::ReLateBound(_, br) | ty::RegionKind::ReSkolemized(_, br) => {\n+                ty::RegionKind::ReLateBound(_, br)\n+                | ty::RegionKind::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                     with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region))\n                 }\n                 _ => format!(\"{}\", region),"}, {"sha": "723b0e6fff6f8d4219d6c17814f6cf7eb19541e8", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -107,6 +107,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // Run the MIR type-checker.\n     let MirTypeckResults {\n         constraints,\n+        placeholder_indices,\n         universal_region_relations,\n     } = type_check::type_check(\n         infcx,\n@@ -122,6 +123,8 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         elements,\n     );\n \n+    let placeholder_indices = Rc::new(placeholder_indices);\n+\n     if let Some(all_facts) = &mut all_facts {\n         all_facts\n             .universal_region\n@@ -150,6 +153,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let mut regioncx = RegionInferenceContext::new(\n         var_origins,\n         universal_regions,\n+        placeholder_indices,\n         universal_region_relations,\n         mir,\n         outlives_constraints,"}, {"sha": "3a545d9adbfcee457a062295a505d9f1803f9f83", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -274,7 +274,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             ty::ReLateBound(..)\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n-            | ty::ReSkolemized(..)\n+            | ty::RePlaceholder(..)\n             | ty::ReEmpty\n             | ty::ReErased\n             | ty::ReClosureBound(..)"}, {"sha": "4a8f011b606b739e6796223498abd09180c41431", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -11,7 +11,7 @@\n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::constraints::graph::NormalConstraintGraph;\n use borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, OutlivesConstraint};\n-use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n+use borrow_check::nll::region_infer::values::{PlaceholderIndices, RegionElement, ToElementIndex};\n use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n@@ -183,6 +183,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn new(\n         var_infos: VarInfos,\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n+        placeholder_indices: Rc<PlaceholderIndices>,\n         universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n         _mir: &Mir<'tcx>,\n         outlives_constraints: ConstraintSet,\n@@ -196,19 +197,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|info| RegionDefinition::new(info.universe, info.origin))\n             .collect();\n \n-        // Compute the max universe used anywhere amongst the regions.\n-        let max_universe = definitions\n-            .iter()\n-            .map(|d| d.universe)\n-            .max()\n-            .unwrap_or(ty::UniverseIndex::ROOT);\n-\n         let constraints = Rc::new(outlives_constraints); // freeze constraints\n         let constraint_graph = Rc::new(constraints.graph(definitions.len()));\n         let fr_static = universal_regions.fr_static;\n         let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph, fr_static));\n \n-        let mut scc_values = RegionValues::new(elements, universal_regions.len(), max_universe);\n+        let mut scc_values =\n+            RegionValues::new(elements, universal_regions.len(), &placeholder_indices);\n \n         for region in liveness_constraints.rows() {\n             let scc = constraint_sccs.scc(region);\n@@ -329,17 +324,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.scc_values.add_element(scc, variable);\n                 }\n \n-                NLLRegionVariableOrigin::BoundRegion(ui) => {\n-                    // Each placeholder region X outlives its\n-                    // associated universe but nothing else. Every\n-                    // placeholder region is always in a universe that\n-                    // contains `ui` -- but when placeholder regions\n-                    // are placed into an SCC, that SCC may include\n-                    // things from other universes that do not include\n-                    // `ui`.\n+                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                    // Each placeholder region is only visible from\n+                    // its universe `ui` and its superuniverses. So we\n+                    // can't just add it into `scc` unless the\n+                    // universe of the scc can name this region.\n                     let scc_universe = self.scc_universes[scc];\n-                    if ui.is_subset_of(scc_universe) {\n-                        self.scc_values.add_element(scc, ui);\n+                    if placeholder.universe.is_subset_of(scc_universe) {\n+                        self.scc_values.add_element(scc, placeholder);\n                     } else {\n                         self.add_incompatible_universe(scc);\n                     }\n@@ -544,8 +536,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // B's value, and check whether all of them are nameable\n         // from universe_a\n         self.scc_values\n-            .subuniverses_contained_in(scc_b)\n-            .all(|u| u.is_subset_of(universe_a))\n+            .placeholders_contained_in(scc_b)\n+            .all(|p| p.universe.is_subset_of(universe_a))\n     }\n \n     /// Extend `scc` so that it can outlive some placeholder region\n@@ -1076,8 +1068,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     );\n                 }\n \n-                NLLRegionVariableOrigin::BoundRegion(universe) => {\n-                    self.check_bound_universal_region(infcx, mir, mir_def_id, fr, universe);\n+                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                    self.check_bound_universal_region(infcx, mir, mir_def_id, fr, placeholder);\n                 }\n \n                 NLLRegionVariableOrigin::Existential => {\n@@ -1113,7 +1105,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         assert!(self.scc_universes[longer_fr_scc] == ty::UniverseIndex::ROOT);\n         debug_assert!(\n             self.scc_values\n-                .subuniverses_contained_in(longer_fr_scc)\n+                .placeholders_contained_in(longer_fr_scc)\n                 .next()\n                 .is_none()\n         );\n@@ -1181,9 +1173,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         _mir_def_id: DefId,\n         longer_fr: RegionVid,\n-        universe: ty::UniverseIndex,\n+        placeholder: ty::Placeholder,\n     ) {\n-        debug!(\"check_bound_universal_region(fr={:?})\", longer_fr);\n+        debug!(\n+            \"check_bound_universal_region(fr={:?}, placeholder={:?})\",\n+            longer_fr, placeholder,\n+        );\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n \n@@ -1196,7 +1191,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .find(|element| match element {\n                     RegionElement::Location(_) => true,\n                     RegionElement::RootUniversalRegion(_) => true,\n-                    RegionElement::SubUniversalRegion(ui) => *ui != universe,\n+                    RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n                 })\n         } {\n             Some(v) => v,\n@@ -1207,10 +1202,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let error_region = match error_element {\n             RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n             RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::SubUniversalRegion(error_ui) => self.definitions\n+            RegionElement::PlaceholderRegion(error_placeholder) => self.definitions\n                 .iter_enumerated()\n                 .filter_map(|(r, definition)| match definition.origin {\n-                    NLLRegionVariableOrigin::BoundRegion(ui) if error_ui == ui => Some(r),\n+                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n                     _ => None,\n                 })\n                 .next()"}, {"sha": "07372c19c46c936040bd8bf44f8615f7c5f90fab", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 85, "deletions": 37, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -11,6 +11,7 @@\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::bit_set::{HybridBitSet, SparseBitMatrix};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -31,8 +32,7 @@ crate struct RegionValueElements {\n impl RegionValueElements {\n     crate fn new(mir: &Mir<'_>) -> Self {\n         let mut num_points = 0;\n-        let statements_before_block: IndexVec<BasicBlock, usize> = mir\n-            .basic_blocks()\n+        let statements_before_block: IndexVec<BasicBlock, usize> = mir.basic_blocks()\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;\n@@ -48,7 +48,7 @@ impl RegionValueElements {\n \n         let mut basic_blocks = IndexVec::with_capacity(num_points);\n         for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-            basic_blocks.extend((0 .. bb_data.statements.len() + 1).map(|_| bb));\n+            basic_blocks.extend((0..bb_data.statements.len() + 1).map(|_| bb));\n         }\n \n         Self {\n@@ -85,7 +85,10 @@ impl RegionValueElements {\n         let block = self.basic_blocks[index];\n         let start_index = self.statements_before_block[block];\n         let statement_index = index.index() - start_index;\n-        Location { block, statement_index }\n+        Location {\n+            block,\n+            statement_index,\n+        }\n     }\n \n     /// Sometimes we get point-indices back from bitsets that may be\n@@ -103,13 +106,15 @@ impl RegionValueElements {\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {\n-        let Location { block, statement_index } = self.to_location(index);\n+        let Location {\n+            block,\n+            statement_index,\n+        } = self.to_location(index);\n         if statement_index == 0 {\n             // If this is a basic block head, then the predecessors are\n             // the the terminators of other basic blocks\n             stack.extend(\n-                mir\n-                    .predecessors_for(block)\n+                mir.predecessors_for(block)\n                     .iter()\n                     .map(|&pred_bb| mir.terminator_loc(pred_bb))\n                     .map(|pred_loc| self.point_from_location(pred_loc)),\n@@ -127,10 +132,7 @@ newtype_index! {\n     pub struct PointIndex { DEBUG_FORMAT = \"PointIndex({})\" }\n }\n \n-/// A single integer representing a (non-zero) `UniverseIndex`.\n-/// Computed just by subtracting one from `UniverseIndex`; this is\n-/// because the `0` value for `UniverseIndex` represents the root\n-/// universe, and we don't need/want a bit for that one.\n+/// A single integer representing a `ty::Placeholder`.\n newtype_index! {\n     pub struct PlaceholderIndex { DEBUG_FORMAT = \"PlaceholderIndex({})\" }\n }\n@@ -148,7 +150,7 @@ crate enum RegionElement {\n \n     /// A subuniverse from a subuniverse (e.g., instantiated from a\n     /// `for<'a> fn(&'a u32)` type).\n-    SubUniversalRegion(ty::UniverseIndex),\n+    PlaceholderRegion(ty::Placeholder),\n }\n \n /// When we initially compute liveness, we use a bit matrix storing\n@@ -185,7 +187,10 @@ impl<N: Idx> LivenessValues<N> {\n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns true if any of them are newly added.\n     crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n-        debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n+        debug!(\n+            \"LivenessValues::add_elements(row={:?}, locations={:?})\",\n+            row, locations\n+        );\n         self.points.union_into_row(row, locations)\n     }\n \n@@ -214,6 +219,52 @@ impl<N: Idx> LivenessValues<N> {\n     }\n }\n \n+/// Maps from `ty::Placeholder` values that are used in the rest of\n+/// rustc to the internal `PlaceholderIndex` values that are used in\n+/// NLL.\n+#[derive(Default)]\n+crate struct PlaceholderIndices {\n+    to_index: FxHashMap<ty::Placeholder, PlaceholderIndex>,\n+    from_index: IndexVec<PlaceholderIndex, ty::Placeholder>,\n+}\n+\n+impl PlaceholderIndices {\n+    crate fn insert(&mut self, placeholder: ty::Placeholder) -> PlaceholderIndex {\n+        let PlaceholderIndices {\n+            to_index,\n+            from_index,\n+        } = self;\n+        *to_index\n+            .entry(placeholder)\n+            .or_insert_with(|| from_index.push(placeholder))\n+    }\n+\n+    crate fn lookup_index(&self, placeholder: ty::Placeholder) -> PlaceholderIndex {\n+        self.to_index[&placeholder]\n+    }\n+\n+    crate fn lookup_placeholder(&self, placeholder: PlaceholderIndex) -> ty::Placeholder {\n+        self.from_index[placeholder]\n+    }\n+\n+    crate fn len(&self) -> usize {\n+        self.from_index.len()\n+    }\n+}\n+\n+impl ::std::iter::FromIterator<ty::Placeholder> for PlaceholderIndices {\n+    fn from_iter<I>(iter: I) -> Self\n+    where\n+        I: IntoIterator<Item = ty::Placeholder>,\n+    {\n+        let mut result = Self::default();\n+        iter.into_iter().for_each(|p| {\n+            result.insert(p);\n+        });\n+        result\n+    }\n+}\n+\n /// Stores the full values for a set of regions (in contrast to\n /// `LivenessValues`, which only stores those points in the where a\n /// region is live). The full value for a region may contain points in\n@@ -235,6 +286,7 @@ impl<N: Idx> LivenessValues<N> {\n #[derive(Clone)]\n crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n+    placeholder_indices: Rc<PlaceholderIndices>,\n     points: SparseBitMatrix<N, PointIndex>,\n     free_regions: SparseBitMatrix<N, RegionVid>,\n \n@@ -250,12 +302,13 @@ impl<N: Idx> RegionValues<N> {\n     crate fn new(\n         elements: &Rc<RegionValueElements>,\n         num_universal_regions: usize,\n-        max_universe: ty::UniverseIndex,\n+        placeholder_indices: &Rc<PlaceholderIndices>,\n     ) -> Self {\n-        let num_placeholders = max_universe.as_usize();\n+        let num_placeholders = placeholder_indices.len();\n         Self {\n             elements: elements.clone(),\n             points: SparseBitMatrix::new(elements.num_points),\n+            placeholder_indices: placeholder_indices.clone(),\n             free_regions: SparseBitMatrix::new(num_universal_regions),\n             placeholders: SparseBitMatrix::new(num_placeholders),\n         }\n@@ -313,14 +366,11 @@ impl<N: Idx> RegionValues<N> {\n \n     /// Returns the locations contained within a given region `r`.\n     crate fn locations_outlived_by<'a>(&'a self, r: N) -> impl Iterator<Item = Location> + 'a {\n-        self.points\n-            .row(r)\n-            .into_iter()\n-            .flat_map(move |set| {\n-                set.iter()\n-                    .take_while(move |&p| self.elements.point_in_range(p))\n-                    .map(move |p| self.elements.to_location(p))\n-            })\n+        self.points.row(r).into_iter().flat_map(move |set| {\n+            set.iter()\n+                .take_while(move |&p| self.elements.point_in_range(p))\n+                .map(move |p| self.elements.to_location(p))\n+        })\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n@@ -335,32 +385,30 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    crate fn subuniverses_contained_in<'a>(\n+    crate fn placeholders_contained_in<'a>(\n         &'a self,\n         r: N,\n-    ) -> impl Iterator<Item = ty::UniverseIndex> + 'a {\n+    ) -> impl Iterator<Item = ty::Placeholder> + 'a {\n         self.placeholders\n             .row(r)\n             .into_iter()\n             .flat_map(|set| set.iter())\n-            .map(|p| ty::UniverseIndex::from_u32((p.index() + 1) as u32))\n+            .map(move |p| self.placeholder_indices.lookup_placeholder(p))\n     }\n \n     /// Returns all the elements contained in a given region's value.\n     crate fn elements_contained_in<'a>(&'a self, r: N) -> impl Iterator<Item = RegionElement> + 'a {\n         let points_iter = self.locations_outlived_by(r).map(RegionElement::Location);\n \n-        let free_regions_iter = self\n-            .universal_regions_outlived_by(r)\n+        let free_regions_iter = self.universal_regions_outlived_by(r)\n             .map(RegionElement::RootUniversalRegion);\n \n-        let subuniverses_iter = self\n-            .subuniverses_contained_in(r)\n-            .map(RegionElement::SubUniversalRegion);\n+        let placeholder_universes_iter = self.placeholders_contained_in(r)\n+            .map(RegionElement::PlaceholderRegion);\n \n         points_iter\n             .chain(free_regions_iter)\n-            .chain(subuniverses_iter)\n+            .chain(placeholder_universes_iter)\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n@@ -397,14 +445,14 @@ impl ToElementIndex for RegionVid {\n     }\n }\n \n-impl ToElementIndex for ty::UniverseIndex {\n+impl ToElementIndex for ty::Placeholder {\n     fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n-        let index = PlaceholderIndex::new(self.as_usize() - 1);\n+        let index = values.placeholder_indices.lookup_index(self);\n         values.placeholders.insert(row, index)\n     }\n \n     fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n-        let index = PlaceholderIndex::new(self.as_usize() - 1);\n+        let index = values.placeholder_indices.lookup_index(self);\n         values.placeholders.contains(row, index)\n     }\n }\n@@ -467,15 +515,15 @@ fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String\n                 result.push_str(&format!(\"{:?}\", fr));\n             }\n \n-            RegionElement::SubUniversalRegion(ur) => {\n+            RegionElement::PlaceholderRegion(placeholder) => {\n                 if let Some((location1, location2)) = open_location {\n                     push_sep(&mut result);\n                     push_location_range(&mut result, location1, location2);\n                     open_location = None;\n                 }\n \n                 push_sep(&mut result);\n-                result.push_str(&format!(\"{:?}\", ur));\n+                result.push_str(&format!(\"{:?}\", placeholder));\n             }\n         }\n     }"}, {"sha": "99ac80862b13e695a28ac1990bfcc41b9adb0cff", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -15,7 +15,9 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n+use borrow_check::nll::region_infer::values::LivenessValues;\n+use borrow_check::nll::region_infer::values::PlaceholderIndices;\n+use borrow_check::nll::region_infer::values::RegionValueElements;\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::renumber;\n use borrow_check::nll::type_check::free_region_relations::{\n@@ -42,13 +44,13 @@ use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n-use std::{fmt, iter};\n use std::rc::Rc;\n+use std::{fmt, iter};\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n \n-use rustc_data_structures::fx::FxHashSet;\n use either::Either;\n+use rustc_data_structures::fx::FxHashSet;\n \n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n@@ -128,6 +130,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         outlives_constraints: ConstraintSet::default(),\n         type_tests: Vec::default(),\n     };\n+    let mut placeholder_indices = PlaceholderIndices::default();\n \n     let CreateResult {\n         universal_region_relations,\n@@ -147,6 +150,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         borrow_set,\n         all_facts,\n         constraints: &mut constraints,\n+        placeholder_indices: &mut placeholder_indices,\n     };\n \n     type_check_internal(\n@@ -162,12 +166,15 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             cx.equate_inputs_and_outputs(mir, universal_regions, &normalized_inputs_and_output);\n             liveness::generate(cx, mir, elements, flow_inits, move_data, location_table);\n \n-            cx.borrowck_context.as_mut().map(|bcx| translate_outlives_facts(bcx));\n+            cx.borrowck_context\n+                .as_mut()\n+                .map(|bcx| translate_outlives_facts(bcx));\n         },\n     );\n \n     MirTypeckResults {\n         constraints,\n+        placeholder_indices,\n         universal_region_relations,\n     }\n }\n@@ -210,21 +217,25 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n fn translate_outlives_facts(cx: &mut BorrowCheckContext) {\n     if let Some(facts) = cx.all_facts {\n         let location_table = cx.location_table;\n-        facts.outlives.extend(\n-            cx.constraints.outlives_constraints.iter().flat_map(|constraint: &OutlivesConstraint| {\n-                if let Some(from_location) = constraint.locations.from_location() {\n-                    Either::Left(iter::once((\n-                        constraint.sup,\n-                        constraint.sub,\n-                        location_table.mid_index(from_location),\n-                    )))\n-                } else {\n-                    Either::Right(location_table.all_points().map(move |location| {\n-                       (constraint.sup, constraint.sub, location)\n-                    }))\n-                }\n-            })\n-        );\n+        facts\n+            .outlives\n+            .extend(cx.constraints.outlives_constraints.iter().flat_map(\n+                |constraint: &OutlivesConstraint| {\n+                    if let Some(from_location) = constraint.locations.from_location() {\n+                        Either::Left(iter::once((\n+                            constraint.sup,\n+                            constraint.sub,\n+                            location_table.mid_index(from_location),\n+                        )))\n+                    } else {\n+                        Either::Right(\n+                            location_table\n+                                .all_points()\n+                                .map(move |location| (constraint.sup, constraint.sub, location)),\n+                        )\n+                    }\n+                },\n+            ));\n     }\n }\n \n@@ -718,10 +729,12 @@ struct BorrowCheckContext<'a, 'tcx: 'a> {\n     all_facts: &'a mut Option<AllFacts>,\n     borrow_set: &'a BorrowSet<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n+    placeholder_indices: &'a mut PlaceholderIndices,\n }\n \n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n+    crate placeholder_indices: PlaceholderIndices,\n     crate universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n "}, {"sha": "4e8dbf8498e2a643b421333590d132e72f04ff37", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 67, "deletions": 36, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -146,18 +146,27 @@ trait TypeRelatingDelegate<'tcx> {\n     /// delegate.\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n \n-    /// Creates a new region variable representing an instantiated\n-    /// higher-ranked region; this will be either existential or\n-    /// universal depending on the context.  So e.g. if you have\n-    /// `for<'a> fn(..) <: for<'b> fn(..)`, then we will first\n-    /// instantiate `'b` with a universally quantitifed region and\n-    /// then `'a` with an existentially quantified region (the order\n-    /// is important so that the existential region `'a` can see the\n-    /// universal one).\n-    fn next_region_var(\n-        &mut self,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> ty::Region<'tcx>;\n+    /// Creates a new universe index. Used when instantiating placeholders.\n+    fn next_subuniverse(&mut self) -> ty::UniverseIndex;\n+\n+    /// Creates a new region variable representing a higher-ranked\n+    /// region that is instantiated existentially. This creates an\n+    /// inference variable, typically.\n+    ///\n+    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// we will invoke this method to instantiate `'a` with an\n+    /// inference variable (though `'b` would be instantiated first,\n+    /// as a placeholder).\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx>;\n+\n+    /// Creates a new region variable representing a\n+    /// higher-ranked region that is instantiated universally.\n+    /// This creates a new region placeholder, typically.\n+    ///\n+    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// we will invoke this method to instantiate `'b` with a\n+    /// placeholder region.\n+    fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx>;\n \n     /// Creates a new existential region in the given universe. This\n     /// is used when handling subtyping and type variables -- if we\n@@ -197,15 +206,20 @@ impl NllTypeRelatingDelegate<'me, 'bccx, 'gcx, 'tcx> {\n }\n \n impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n-    fn next_region_var(\n-        &mut self,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> ty::Region<'tcx> {\n-        let origin = if universally_quantified.0 {\n-            NLLRegionVariableOrigin::BoundRegion(self.infcx.create_subuniverse())\n-        } else {\n-            NLLRegionVariableOrigin::Existential\n-        };\n+    fn next_subuniverse(&mut self) -> ty::UniverseIndex {\n+        self.infcx.create_subuniverse()\n+    }\n+\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+        let origin = NLLRegionVariableOrigin::Existential;\n+        self.infcx.next_nll_region_var(origin)\n+    }\n+\n+    fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx> {\n+        let origin = NLLRegionVariableOrigin::Placeholder(placeholder);\n+        if let Some(borrowck_context) = &mut self.borrowck_context {\n+            borrowck_context.placeholder_indices.insert(placeholder);\n+        }\n         self.infcx.next_nll_region_var(origin)\n     }\n \n@@ -286,12 +300,37 @@ where\n         universally_quantified: UniversallyQuantified,\n     ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n+\n+        // Create a callback that creates (via the delegate) either an\n+        // existential or placeholder region as needed.\n+        let mut next_region = {\n+            let delegate = &mut self.delegate;\n+            let mut lazy_universe = None;\n+            move |br: ty::BoundRegion| {\n+                if universally_quantified.0 {\n+                    // The first time this closure is called, create a\n+                    // new universe for the placeholders we will make\n+                    // from here out.\n+                    let universe = lazy_universe.unwrap_or_else(|| {\n+                        let universe = delegate.next_subuniverse();\n+                        lazy_universe = Some(universe);\n+                        universe\n+                    });\n+\n+                    let placeholder = ty::Placeholder { universe, name: br };\n+                    delegate.next_placeholder_region(placeholder)\n+                } else {\n+                    delegate.next_existential_region_var()\n+                }\n+            }\n+        };\n+\n         value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            delegate: &mut self.delegate,\n+            next_region: &mut next_region,\n             target_index: ty::INNERMOST,\n-            universally_quantified,\n             bound_region_scope: &mut scope,\n         });\n+\n         scope\n     }\n \n@@ -604,21 +643,14 @@ where\n /// binder depth, and finds late-bound regions targeting the\n /// `for<..`>.  For each of those, it creates an entry in\n /// `bound_region_scope`.\n-struct ScopeInstantiator<'me, 'tcx: 'me, D>\n-where\n-    D: TypeRelatingDelegate<'tcx> + 'me,\n-{\n-    delegate: &'me mut D,\n+struct ScopeInstantiator<'me, 'tcx: 'me> {\n+    next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n-    universally_quantified: UniversallyQuantified,\n     bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n }\n \n-impl<'me, 'tcx, D> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n+impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n@@ -629,9 +661,8 @@ where\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         let ScopeInstantiator {\n-            universally_quantified,\n             bound_region_scope,\n-            delegate,\n+            next_region,\n             ..\n         } = self;\n \n@@ -640,7 +671,7 @@ where\n                 bound_region_scope\n                     .map\n                     .entry(*br)\n-                    .or_insert_with(|| delegate.next_region_var(*universally_quantified));\n+                    .or_insert_with(|| next_region(*br));\n             }\n \n             _ => {}"}, {"sha": "695812faafff10bed688e8c16ff30c80b2215fa8", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -128,14 +128,14 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // We create a mapping `dummy_substs` that maps from the impl type\n     // parameters to fresh types and regions. For type parameters,\n     // this is the identity transform, but we could as well use any\n-    // skolemized types. For regions, we convert from bound to free\n+    // placeholder types. For regions, we convert from bound to free\n     // regions (Note: but only early-bound regions, i.e., those\n     // declared on the impl or used in type parameter bounds).\n     //\n     //     impl_to_skol_substs = {'i => 'i0, U => U0, N => N0 }\n     //\n     // Now we can apply skol_substs to the type of the impl method\n-    // to yield a new function type in terms of our fresh, skolemized\n+    // to yield a new function type in terms of our fresh, placeholder\n     // types:\n     //\n     //     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n@@ -163,15 +163,15 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // We do this by creating a parameter environment which contains a\n     // substitution corresponding to impl_to_skol_substs. We then build\n     // trait_to_skol_substs and use it to convert the predicates contained\n-    // in the trait_m.generics to the skolemized form.\n+    // in the trait_m.generics to the placeholder form.\n     //\n     // Finally we register each of these predicates as an obligation in\n     // a fresh FulfillmentCtxt, and invoke select_all_or_error.\n \n-    // Create mapping from impl to skolemized.\n+    // Create mapping from impl to placeholder.\n     let impl_to_skol_substs = Substs::identity_for_item(tcx, impl_m.def_id);\n \n-    // Create mapping from trait to skolemized.\n+    // Create mapping from trait to placeholder.\n     let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n                                                                impl_m.container.id(),\n                                                                trait_to_impl_substs);\n@@ -212,7 +212,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     hybrid_preds.predicates.extend(\n         trait_m_predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n-    // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n+    // Construct trait parameter environment and then shift it into the placeholder viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n@@ -259,7 +259,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // any associated types appearing in the fn arguments or return\n         // type.\n \n-        // Compute skolemized form of impl and trait method tys.\n+        // Compute placeholder form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n         let (impl_sig, _) =\n@@ -894,7 +894,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // method.\n         let impl_c_node_id = tcx.hir.as_local_node_id(impl_c.def_id).unwrap();\n \n-        // Compute skolemized form of impl and trait const tys.\n+        // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n         let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_impl_substs);\n         let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);"}, {"sha": "96b75c4792d759486f8966789592149271d3a2d3", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -170,7 +170,7 @@ fn is_free_region<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, region: Region<'_>) -> bool\n         | RegionKind::ReCanonical(..)\n         | RegionKind::ReScope(..)\n         | RegionKind::ReVar(..)\n-        | RegionKind::ReSkolemized(..)\n+        | RegionKind::RePlaceholder(..)\n         | RegionKind::ReFree(..) => {\n             bug!(\"unexpected region in outlives inference: {:?}\", region);\n         }"}, {"sha": "32a591777db5b57362ea53be5499f71d118d1cd6", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -431,7 +431,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::ReClosureBound(..) |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n-            ty::ReSkolemized(..) |\n+            ty::RePlaceholder(..) |\n             ty::ReEmpty |\n             ty::ReErased => {\n                 // We don't expect to see anything but 'static or bound"}, {"sha": "28f8ebff6ffdd385d15f7aa777da0b500aa3ffc2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -1258,7 +1258,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             ty::ReFree(..) |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n-            ty::ReSkolemized(..) |\n+            ty::RePlaceholder(..) |\n             ty::ReEmpty |\n             ty::ReClosureBound(_) |\n             ty::ReCanonical(_) |"}, {"sha": "3dac45139ac0febb500f6faf6c54ff2e839c9675", "filename": "src/test/run-pass/project-cache-issue-37154.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Ftest%2Frun-pass%2Fproject-cache-issue-37154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ad4e9e42f4bcbdbb784692b936c2462061abc/src%2Ftest%2Frun-pass%2Fproject-cache-issue-37154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproject-cache-issue-37154.rs?ref=8c4ad4e9e42f4bcbdbb784692b936c2462061abc", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(dead_code)]\n // Regression test for #37154: the problem here was that the cache\n-// results in a false error because it was caching skolemized results\n-// even after those skolemized regions had been popped.\n+// results in a false error because it was caching placeholder results\n+// even after those placeholder regions had been popped.\n \n trait Foo {\n     fn method(&self) {}"}]}