{"sha": "0396aace27eea97c3603e9683e921807dff2a314", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzOTZhYWNlMjdlZWE5N2MzNjAzZTk2ODNlOTIxODA3ZGZmMmEzMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-27T12:45:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-27T12:45:16Z"}, "message": "Auto merge of #63639 - Mark-Simulacrum:rustdoc-clean-3, r=GuillaumeGomez\n\nrustdoc: general cleanup", "tree": {"sha": "63738c21ee84a4cf506fb0e46cf25ac68657515c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63738c21ee84a4cf506fb0e46cf25ac68657515c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0396aace27eea97c3603e9683e921807dff2a314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0396aace27eea97c3603e9683e921807dff2a314", "html_url": "https://github.com/rust-lang/rust/commit/0396aace27eea97c3603e9683e921807dff2a314", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0396aace27eea97c3603e9683e921807dff2a314/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e0afdad28c4d1154176df6d35a14e738ec311af", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0afdad28c4d1154176df6d35a14e738ec311af", "html_url": "https://github.com/rust-lang/rust/commit/7e0afdad28c4d1154176df6d35a14e738ec311af"}, {"sha": "b0fab966fad61cac073d1494e0539961e1c442a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0fab966fad61cac073d1494e0539961e1c442a0", "html_url": "https://github.com/rust-lang/rust/commit/b0fab966fad61cac073d1494e0539961e1c442a0"}], "stats": {"total": 949, "additions": 442, "deletions": 507}, "files": [{"sha": "ed82c522779eb1f0420c6a49cd7a7898bfc0f632", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 77, "deletions": 102, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -136,94 +136,88 @@ pub struct Crate {\n     pub collapsed: bool,\n }\n \n-impl Clean<Crate> for hir::Crate {\n-    // note that self here is ignored in favor of `cx.tcx.hir().krate()` since\n-    // that gets around tying self's lifetime to the '_ in cx.\n-    fn clean(&self, cx: &DocContext<'_>) -> Crate {\n-        use crate::visit_lib::LibEmbargoVisitor;\n-\n-        let v = crate::visit_ast::RustdocVisitor::new(&cx);\n-        let module = v.visit(cx.tcx.hir().krate());\n-\n-        {\n-            let mut r = cx.renderinfo.borrow_mut();\n-            r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-            r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-            r.owned_box_did = cx.tcx.lang_items().owned_box();\n-        }\n-\n-        let mut externs = Vec::new();\n-        for &cnum in cx.tcx.crates().iter() {\n-            externs.push((cnum, cnum.clean(cx)));\n-            // Analyze doc-reachability for extern items\n-            LibEmbargoVisitor::new(cx).visit_lib(cnum);\n-        }\n-        externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n-\n-        // Clean the crate, translating the entire libsyntax AST to one that is\n-        // understood by rustdoc.\n-        let mut module = module.clean(cx);\n-        let mut masked_crates = FxHashSet::default();\n-\n-        match module.inner {\n-            ModuleItem(ref module) => {\n-                for it in &module.items {\n-                    // `compiler_builtins` should be masked too, but we can't apply\n-                    // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n-                    if it.is_extern_crate()\n-                        && (it.attrs.has_doc_flag(sym::masked)\n-                            || cx.tcx.is_compiler_builtins(it.def_id.krate))\n-                    {\n-                        masked_crates.insert(it.def_id.krate);\n-                    }\n+pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n+    use crate::visit_lib::LibEmbargoVisitor;\n+\n+    let krate = cx.tcx.hir().krate();\n+    let module = crate::visit_ast::RustdocVisitor::new(&mut cx).visit(krate);\n+\n+    let mut r = cx.renderinfo.get_mut();\n+    r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n+    r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n+    r.owned_box_did = cx.tcx.lang_items().owned_box();\n+\n+    let mut externs = Vec::new();\n+    for &cnum in cx.tcx.crates().iter() {\n+        externs.push((cnum, cnum.clean(cx)));\n+        // Analyze doc-reachability for extern items\n+        LibEmbargoVisitor::new(&mut cx).visit_lib(cnum);\n+    }\n+    externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n+\n+    // Clean the crate, translating the entire libsyntax AST to one that is\n+    // understood by rustdoc.\n+    let mut module = module.clean(cx);\n+    let mut masked_crates = FxHashSet::default();\n+\n+    match module.inner {\n+        ModuleItem(ref module) => {\n+            for it in &module.items {\n+                // `compiler_builtins` should be masked too, but we can't apply\n+                // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n+                if it.is_extern_crate()\n+                    && (it.attrs.has_doc_flag(sym::masked)\n+                        || cx.tcx.is_compiler_builtins(it.def_id.krate))\n+                {\n+                    masked_crates.insert(it.def_id.krate);\n                 }\n             }\n-            _ => unreachable!(),\n         }\n+        _ => unreachable!(),\n+    }\n \n-        let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n-        {\n-            let m = match module.inner {\n-                ModuleItem(ref mut m) => m,\n-                _ => unreachable!(),\n-            };\n-            m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n-                Item {\n-                    source: Span::empty(),\n-                    name: Some(prim.to_url_str().to_string()),\n-                    attrs: attrs.clone(),\n-                    visibility: Some(Public),\n-                    stability: get_stability(cx, def_id),\n-                    deprecation: get_deprecation(cx, def_id),\n-                    def_id,\n-                    inner: PrimitiveItem(prim),\n-                }\n-            }));\n-            m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n-                Item {\n-                    source: Span::empty(),\n-                    name: Some(kw.clone()),\n-                    attrs: attrs,\n-                    visibility: Some(Public),\n-                    stability: get_stability(cx, def_id),\n-                    deprecation: get_deprecation(cx, def_id),\n-                    def_id,\n-                    inner: KeywordItem(kw),\n-                }\n-            }));\n-        }\n+    let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n+    {\n+        let m = match module.inner {\n+            ModuleItem(ref mut m) => m,\n+            _ => unreachable!(),\n+        };\n+        m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n+            Item {\n+                source: Span::empty(),\n+                name: Some(prim.to_url_str().to_string()),\n+                attrs: attrs.clone(),\n+                visibility: Some(Public),\n+                stability: get_stability(cx, def_id),\n+                deprecation: get_deprecation(cx, def_id),\n+                def_id,\n+                inner: PrimitiveItem(prim),\n+            }\n+        }));\n+        m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n+            Item {\n+                source: Span::empty(),\n+                name: Some(kw.clone()),\n+                attrs: attrs,\n+                visibility: Some(Public),\n+                stability: get_stability(cx, def_id),\n+                deprecation: get_deprecation(cx, def_id),\n+                def_id,\n+                inner: KeywordItem(kw),\n+            }\n+        }));\n+    }\n \n-        Crate {\n-            name,\n-            version: None,\n-            src,\n-            module: Some(module),\n-            externs,\n-            primitives,\n-            external_traits: cx.external_traits.clone(),\n-            masked_crates,\n-            collapsed: false,\n-        }\n+    Crate {\n+        name,\n+        version: None,\n+        src,\n+        module: Some(module),\n+        externs,\n+        primitives,\n+        external_traits: cx.external_traits.clone(),\n+        masked_crates,\n+        collapsed: false,\n     }\n }\n \n@@ -572,23 +566,6 @@ pub enum ItemEnum {\n }\n \n impl ItemEnum {\n-    pub fn generics(&self) -> Option<&Generics> {\n-        Some(match *self {\n-            ItemEnum::StructItem(ref s) => &s.generics,\n-            ItemEnum::EnumItem(ref e) => &e.generics,\n-            ItemEnum::FunctionItem(ref f) => &f.generics,\n-            ItemEnum::TypedefItem(ref t, _) => &t.generics,\n-            ItemEnum::OpaqueTyItem(ref t, _) => &t.generics,\n-            ItemEnum::TraitItem(ref t) => &t.generics,\n-            ItemEnum::ImplItem(ref i) => &i.generics,\n-            ItemEnum::TyMethodItem(ref i) => &i.generics,\n-            ItemEnum::MethodItem(ref i) => &i.generics,\n-            ItemEnum::ForeignFunctionItem(ref f) => &f.generics,\n-            ItemEnum::TraitAliasItem(ref ta) => &ta.generics,\n-            _ => return None,\n-        })\n-    }\n-\n     pub fn is_associated(&self) -> bool {\n         match *self {\n             ItemEnum::TypedefItem(_, _) |\n@@ -1541,8 +1518,6 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n                 (self.name.to_string(), GenericParamDefKind::Lifetime)\n             }\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n-                cx.renderinfo.borrow_mut().external_param_names\n-                             .insert(self.def_id, self.name.clean(cx));\n                 let default = if has_default {\n                     Some(cx.tcx.type_of(self.def_id).clean(cx))\n                 } else {"}, {"sha": "45ebaa115063a7c91ca07cdb1bb53aacdf36aae1", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -30,7 +30,7 @@ use std::rc::Rc;\n \n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::clean;\n-use crate::clean::{Clean, MAX_DEF_ID, AttributesExt};\n+use crate::clean::{MAX_DEF_ID, AttributesExt};\n use crate::html::render::RenderInfo;\n \n use crate::passes;\n@@ -363,7 +363,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             let mut renderinfo = RenderInfo::default();\n             renderinfo.access_levels = access_levels;\n \n-            let ctxt = DocContext {\n+            let mut ctxt = DocContext {\n                 tcx,\n                 resolver,\n                 cstore: compiler.cstore().clone(),\n@@ -383,7 +383,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             };\n             debug!(\"crate: {:?}\", tcx.hir().krate());\n \n-            let mut krate = tcx.hir().krate().clean(&ctxt);\n+            let mut krate = clean::krate(&mut ctxt);\n \n             fn report_deprecated_attr(name: &str, diag: &errors::Handler) {\n                 let mut msg = diag.struct_warn(&format!(\"the `#![doc({})]` attribute is \\"}, {"sha": "313734e3fdd6b339a85a1f88eafcadff830b0960", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 69, "deletions": 77, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -6,6 +6,7 @@\n //! them in the future to instead emit any format desired.\n \n use std::borrow::Cow;\n+use std::cell::Cell;\n use std::fmt;\n \n use rustc::hir::def_id::DefId;\n@@ -15,7 +16,7 @@ use rustc::hir;\n \n use crate::clean::{self, PrimitiveType};\n use crate::html::item_type::ItemType;\n-use crate::html::render::{self, cache, CURRENT_LOCATION_KEY};\n+use crate::html::render::{self, cache, CURRENT_DEPTH};\n \n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n@@ -36,13 +37,8 @@ pub struct AsyncSpace(pub hir::IsAsync);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n-/// Similar to VisSpace, but used for mutability\n-#[derive(Copy, Clone)]\n-pub struct RawMutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n-/// Wrapper struct for emitting a comma-separated list of items\n-pub struct CommaSep<'a, T>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n pub struct DefaultSpace(pub bool);\n \n@@ -71,11 +67,6 @@ pub struct WhereClause<'a>{\n     pub end_newline: bool,\n }\n \n-pub struct HRef<'a> {\n-    pub did: DefId,\n-    pub text: &'a str,\n-}\n-\n impl<'a> VisSpace<'a> {\n     pub fn get(self) -> &'a Option<clean::Visibility> {\n         let VisSpace(v) = self; v\n@@ -94,14 +85,14 @@ impl ConstnessSpace {\n     }\n }\n \n-impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for (i, item) in self.0.iter().enumerate() {\n+fn comma_sep<T: fmt::Display>(items: &[T]) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        for (i, item) in items.iter().enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n             fmt::Display::fmt(item, f)?;\n         }\n         Ok(())\n-    }\n+    })\n }\n \n impl<'a> fmt::Display for GenericBounds<'a> {\n@@ -168,9 +159,9 @@ impl fmt::Display for clean::Generics {\n             return Ok(());\n         }\n         if f.alternate() {\n-            write!(f, \"<{:#}>\", CommaSep(&real_params))\n+            write!(f, \"<{:#}>\", comma_sep(&real_params))\n         } else {\n-            write!(f, \"&lt;{}&gt;\", CommaSep(&real_params))\n+            write!(f, \"&lt;{}&gt;\", comma_sep(&real_params))\n         }\n     }\n }\n@@ -268,9 +259,9 @@ impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if !self.generic_params.is_empty() {\n             if f.alternate() {\n-                write!(f, \"for<{:#}> \", CommaSep(&self.generic_params))?;\n+                write!(f, \"for<{:#}> \", comma_sep(&self.generic_params))?;\n             } else {\n-                write!(f, \"for&lt;{}&gt; \", CommaSep(&self.generic_params))?;\n+                write!(f, \"for&lt;{}&gt; \", comma_sep(&self.generic_params))?;\n             }\n         }\n         if f.alternate() {\n@@ -407,16 +398,16 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n         return None\n     }\n \n-    let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n+    let depth = CURRENT_DEPTH.with(|l| l.get());\n     let (fqp, shortty, mut url) = match cache.paths.get(&did) {\n         Some(&(ref fqp, shortty)) => {\n-            (fqp, shortty, \"../\".repeat(loc.len()))\n+            (fqp, shortty, \"../\".repeat(depth))\n         }\n         None => {\n             let &(ref fqp, shortty) = cache.external_paths.get(&did)?;\n             (fqp, shortty, match cache.extern_locations[&did.krate] {\n                 (.., render::Remote(ref s)) => s.to_string(),\n-                (.., render::Local) => \"../\".repeat(loc.len()),\n+                (.., render::Local) => \"../\".repeat(depth),\n                 (.., render::Unknown) => return None,\n             })\n         }\n@@ -452,19 +443,18 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.args)?;\n+        write!(w, \"{}{:#}\", &last.name, last.args)?;\n     } else {\n         let path = if use_absolute {\n-            match href(did) {\n-                Some((_, _, fqp)) => {\n-                    format!(\"{}::{}\",\n-                            fqp[..fqp.len() - 1].join(\"::\"),\n-                            HRef::new(did, fqp.last().unwrap()))\n-                }\n-                None => HRef::new(did, &last.name).to_string(),\n+            if let Some((_, _, fqp)) = href(did) {\n+                format!(\"{}::{}\",\n+                        fqp[..fqp.len() - 1].join(\"::\"),\n+                        anchor(did, fqp.last().unwrap()))\n+            } else {\n+                last.name.to_string()\n             }\n         } else {\n-            HRef::new(did, &last.name).to_string()\n+            anchor(did, &last.name).to_string()\n         };\n         write!(w, \"{}{}\", path, last.args)?;\n     }\n@@ -479,7 +469,7 @@ fn primitive_link(f: &mut fmt::Formatter<'_>,\n     if !f.alternate() {\n         match m.primitive_locations.get(&prim) {\n             Some(&def_id) if def_id.is_local() => {\n-                let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                let len = CURRENT_DEPTH.with(|s| s.get());\n                 let len = if len == 0 {0} else {len - 1};\n                 write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}primitive.{}.html\\\">\",\n                        \"../\".repeat(len),\n@@ -492,7 +482,7 @@ fn primitive_link(f: &mut fmt::Formatter<'_>,\n                         Some((cname, s.to_string()))\n                     }\n                     (ref cname, _, render::Local) => {\n-                        let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                        let len = CURRENT_DEPTH.with(|s| s.get());\n                         Some((cname, \"../\".repeat(len)))\n                     }\n                     (.., render::Unknown) => None,\n@@ -516,38 +506,30 @@ fn primitive_link(f: &mut fmt::Formatter<'_>,\n }\n \n /// Helper to render type parameters\n-fn tybounds(w: &mut fmt::Formatter<'_>,\n-            param_names: &Option<Vec<clean::GenericBound>>) -> fmt::Result {\n-    match *param_names {\n-        Some(ref params) => {\n-            for param in params {\n-                write!(w, \" + \")?;\n-                fmt::Display::fmt(param, w)?;\n+fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        match *param_names {\n+            Some(ref params) => {\n+                for param in params {\n+                    write!(f, \" + \")?;\n+                    fmt::Display::fmt(param, f)?;\n+                }\n+                Ok(())\n             }\n-            Ok(())\n+            None => Ok(())\n         }\n-        None => Ok(())\n-    }\n-}\n-\n-impl<'a> HRef<'a> {\n-    pub fn new(did: DefId, text: &'a str) -> HRef<'a> {\n-        HRef { did: did, text: text }\n-    }\n+    })\n }\n \n-impl<'a> fmt::Display for HRef<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match href(self.did) {\n-            Some((url, shortty, fqp)) => if !f.alternate() {\n-                write!(f, \"<a class=\\\"{}\\\" href=\\\"{}\\\" title=\\\"{} {}\\\">{}</a>\",\n-                       shortty, url, shortty, fqp.join(\"::\"), self.text)\n-            } else {\n-                write!(f, \"{}\", self.text)\n-            },\n-            _ => write!(f, \"{}\", self.text),\n+pub fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        if let Some((url, short_ty, fqp)) = href(did) {\n+            write!(f, r#\"<a class=\"{}\" href=\"{}\" title=\"{} {}\">{}</a>\"#,\n+                short_ty, url, short_ty, fqp.join(\"::\"), text)\n+        } else {\n+            write!(f, \"{}\", text)\n         }\n-    }\n+    })\n }\n \n fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) -> fmt::Result {\n@@ -561,7 +543,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             }\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n             resolved_path(f, did, path, is_generic, use_absolute)?;\n-            tybounds(f, param_names)\n+            fmt::Display::fmt(&tybounds(param_names), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n         clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n@@ -570,12 +552,12 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 write!(f, \"{}{:#}fn{:#}{:#}\",\n                        UnsafetySpace(decl.unsafety),\n                        AbiSpace(decl.abi),\n-                       CommaSep(&decl.generic_params),\n+                       comma_sep(&decl.generic_params),\n                        decl.decl)\n             } else {\n                 write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n-                write!(f, \"{}{}\", CommaSep(&decl.generic_params), decl.decl)\n+                write!(f, \"{}{}\", comma_sep(&decl.generic_params), decl.decl)\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -589,7 +571,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 }\n                 many => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                    fmt::Display::fmt(&CommaSep(many), f)?;\n+                    fmt::Display::fmt(&comma_sep(many), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n@@ -607,19 +589,22 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n         clean::CVarArgs => primitive_link(f, PrimitiveType::CVarArgs, \"...\"),\n         clean::RawPointer(m, ref t) => {\n+            let m = match m {\n+                clean::Immutable => \"const\",\n+                clean::Mutable => \"mut\",\n+            };\n             match **t {\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n                     if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n+                                       &format!(\"*{} {:#}\", m, t))\n                     } else {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}{}\", RawMutableSpace(m), t))\n+                                       &format!(\"*{} {}\", m, t))\n                     }\n                 }\n                 _ => {\n-                    primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                   &format!(\"*{}\", RawMutableSpace(m)))?;\n+                    primitive_link(f, clean::PrimitiveType::RawPointer, &format!(\"*{} \", m))?;\n                     fmt::Display::fmt(t, f)\n                 }\n             }\n@@ -1047,15 +1032,6 @@ impl fmt::Display for MutableSpace {\n     }\n }\n \n-impl fmt::Display for RawMutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            RawMutableSpace(clean::Immutable) => write!(f, \"const \"),\n-            RawMutableSpace(clean::Mutable) => write!(f, \"mut \"),\n-        }\n-    }\n-}\n-\n impl fmt::Display for AbiSpace {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n@@ -1075,3 +1051,19 @@ impl fmt::Display for DefaultSpace {\n         }\n     }\n }\n+\n+crate fn display_fn(\n+    f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n+) -> impl fmt::Display {\n+    WithFormatter(Cell::new(Some(f)))\n+}\n+\n+struct WithFormatter<F>(Cell<Option<F>>);\n+\n+impl<F> fmt::Display for WithFormatter<F>\n+    where F: FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (self.0.take()).unwrap()(f)\n+    }\n+}"}, {"sha": "74413a7f905d45fc0bf5c7bc92aac504bcf18efe", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -785,10 +785,6 @@ impl MarkdownSummaryLine<'_> {\n }\n \n pub fn plain_summary_line(md: &str) -> String {\n-    plain_summary_line_full(md, false)\n-}\n-\n-pub fn plain_summary_line_full(md: &str, limit_length: bool) -> String {\n     struct ParserWrapper<'a> {\n         inner: Parser<'a>,\n         is_in: isize,\n@@ -834,21 +830,7 @@ pub fn plain_summary_line_full(md: &str, limit_length: bool) -> String {\n             s.push_str(&t);\n         }\n     }\n-    if limit_length && s.chars().count() > 60 {\n-        let mut len = 0;\n-        let mut ret = s.split_whitespace()\n-                       .take_while(|p| {\n-                           // + 1 for the added character after the word.\n-                           len += p.chars().count() + 1;\n-                           len < 60\n-                       })\n-                       .collect::<Vec<_>>()\n-                       .join(\" \");\n-        ret.push('\u2026');\n-        ret\n-    } else {\n-        s\n-    }\n+    s\n }\n \n pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {"}, {"sha": "2a4a2fcea58389f51c475f1c7d61b3ce2a808cd4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 89, "deletions": 289, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -28,7 +28,7 @@\n pub use self::ExternalLocation::*;\n \n use std::borrow::Cow;\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n use std::default::Default;\n@@ -72,6 +72,7 @@ use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n use crate::html::{highlight, layout, static_files};\n+use crate::html::sources;\n \n use minifier;\n \n@@ -173,7 +174,7 @@ struct Context {\n     playground: Option<markdown::Playground>,\n }\n \n-struct SharedContext {\n+crate struct SharedContext {\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     pub src_root: PathBuf,\n@@ -218,7 +219,7 @@ struct SharedContext {\n }\n \n impl SharedContext {\n-    fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n+    crate fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n         if !dirs.contains(dst) {\n             try_err!(self.fs.create_dir_all(dst), dst);\n@@ -281,11 +282,6 @@ impl Impl {\n /// rendering threads.\n #[derive(Default)]\n pub struct Cache {\n-    /// Mapping of typaram ids to the name of the type parameter. This is used\n-    /// when pretty-printing a type (so pretty-printing doesn't have to\n-    /// painfully maintain a context like this)\n-    pub param_names: FxHashMap<DefId, String>,\n-\n     /// Maps a type ID to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n@@ -381,26 +377,13 @@ pub struct Cache {\n pub struct RenderInfo {\n     pub inlined: FxHashSet<DefId>,\n     pub external_paths: crate::core::ExternalPaths,\n-    pub external_param_names: FxHashMap<DefId, String>,\n     pub exact_paths: FxHashMap<DefId, Vec<String>>,\n     pub access_levels: AccessLevels<DefId>,\n     pub deref_trait_did: Option<DefId>,\n     pub deref_mut_trait_did: Option<DefId>,\n     pub owned_box_did: Option<DefId>,\n }\n \n-/// Helper struct to render all source code to HTML pages\n-struct SourceCollector<'a> {\n-    scx: &'a mut SharedContext,\n-\n-    /// Root destination to place all HTML output into\n-    dst: PathBuf,\n-}\n-\n-/// Wrapper struct to render the source code of a file. This will do things like\n-/// adding line numbers to the left-hand side.\n-struct Source<'a>(&'a str);\n-\n // Helper structs for rendering items/sidebars and carrying along contextual\n // information\n \n@@ -496,7 +479,7 @@ impl ToJson for IndexItemFunctionType {\n }\n \n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n-thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> = RefCell::new(Vec::new()));\n+thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n pub fn initial_ids() -> Vec<String> {\n     [\n@@ -612,7 +595,7 @@ pub fn run(mut krate: clean::Crate,\n     }\n     let dst = output;\n     scx.ensure_dir(&dst)?;\n-    krate = render_sources(&dst, &mut scx, krate)?;\n+    krate = sources::render(&dst, &mut scx, krate)?;\n     let mut cx = Context {\n         current: Vec::new(),\n         dst,\n@@ -628,7 +611,6 @@ pub fn run(mut krate: clean::Crate,\n     let RenderInfo {\n         inlined: _,\n         external_paths,\n-        external_param_names,\n         exact_paths,\n         access_levels,\n         deref_trait_did,\n@@ -662,7 +644,6 @@ pub fn run(mut krate: clean::Crate,\n         deref_mut_trait_did,\n         owned_box_did,\n         masked_crates: mem::take(&mut krate.masked_crates),\n-        param_names: external_param_names,\n         aliases: Default::default(),\n     };\n \n@@ -714,7 +695,7 @@ pub fn run(mut krate: clean::Crate,\n     // for future parallelization opportunities\n     let cache = Arc::new(cache);\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n-    CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n+    CURRENT_DEPTH.with(|s| s.set(0));\n \n     // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n     Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n@@ -751,7 +732,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 ty: item.type_(),\n                 name: item.name.clone().unwrap(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n-                desc: plain_summary_line_short(item.doc_value()),\n+                desc: shorten(plain_summary_line(item.doc_value())),\n                 parent: Some(did),\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item),\n@@ -789,7 +770,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     }\n \n     let crate_doc = krate.module.as_ref().map(|module| {\n-        plain_summary_line_short(module.doc_value())\n+        shorten(plain_summary_line(module.doc_value()))\n     }).unwrap_or(String::new());\n \n     let mut crate_data = BTreeMap::new();\n@@ -1293,18 +1274,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n     Ok(())\n }\n \n-fn render_sources(dst: &Path, scx: &mut SharedContext,\n-                  krate: clean::Crate) -> Result<clean::Crate, Error> {\n-    info!(\"emitting source files\");\n-    let dst = dst.join(\"src\").join(&krate.name);\n-    scx.ensure_dir(&dst)?;\n-    let mut folder = SourceCollector {\n-        dst,\n-        scx,\n-    };\n-    Ok(folder.fold_crate(krate))\n-}\n-\n fn write_minify(fs:&DocFS, dst: PathBuf, contents: &str, enable_minification: bool\n                 ) -> Result<(), Error> {\n     if enable_minification {\n@@ -1384,33 +1353,6 @@ fn write_minify_replacer<W: Write>(\n     }\n }\n \n-/// Takes a path to a source file and cleans the path to it. This canonicalizes\n-/// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n-/// static HTML tree. Each component in the cleaned path will be passed as an\n-/// argument to `f`. The very last component of the path (ie the file name) will\n-/// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-fn clean_srcpath<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n-where\n-    F: FnMut(&OsStr),\n-{\n-    // make it relative, if possible\n-    let p = p.strip_prefix(src_root).unwrap_or(p);\n-\n-    let mut iter = p.components().peekable();\n-\n-    while let Some(c) = iter.next() {\n-        if !keep_filename && iter.peek().is_none() {\n-            break;\n-        }\n-\n-        match c {\n-            Component::ParentDir => f(\"up\".as_ref()),\n-            Component::Normal(c) => f(c),\n-            _ => continue,\n-        }\n-    }\n-}\n-\n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n@@ -1444,102 +1386,6 @@ fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Pat\n     }).next().unwrap_or(Unknown) // Well, at least we tried.\n }\n \n-impl<'a> DocFolder for SourceCollector<'a> {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        // If we're including source files, and we haven't seen this file yet,\n-        // then we need to render it out to the filesystem.\n-        if self.scx.include_sources\n-            // skip all invalid or macro spans\n-            && item.source.filename.is_real()\n-            // skip non-local items\n-            && item.def_id.is_local() {\n-\n-            // If it turns out that we couldn't read this file, then we probably\n-            // can't read any of the files (generating html output from json or\n-            // something like that), so just don't include sources for the\n-            // entire crate. The other option is maintaining this mapping on a\n-            // per-file basis, but that's probably not worth it...\n-            self.scx\n-                .include_sources = match self.emit_source(&item.source.filename) {\n-                Ok(()) => true,\n-                Err(e) => {\n-                    println!(\"warning: source code was requested to be rendered, \\\n-                              but processing `{}` had an error: {}\",\n-                             item.source.filename, e);\n-                    println!(\"         skipping rendering of source code\");\n-                    false\n-                }\n-            };\n-        }\n-        self.fold_item_recur(item)\n-    }\n-}\n-\n-impl<'a> SourceCollector<'a> {\n-    /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n-        let p = match *filename {\n-            FileName::Real(ref file) => file,\n-            _ => return Ok(()),\n-        };\n-        if self.scx.local_sources.contains_key(&**p) {\n-            // We've already emitted this source\n-            return Ok(());\n-        }\n-\n-        let contents = try_err!(fs::read_to_string(&p), &p);\n-\n-        // Remove the utf-8 BOM if any\n-        let contents = if contents.starts_with(\"\\u{feff}\") {\n-            &contents[3..]\n-        } else {\n-            &contents[..]\n-        };\n-\n-        // Create the intermediate directories\n-        let mut cur = self.dst.clone();\n-        let mut root_path = String::from(\"../../\");\n-        let mut href = String::new();\n-        clean_srcpath(&self.scx.src_root, &p, false, |component| {\n-            cur.push(component);\n-            root_path.push_str(\"../\");\n-            href.push_str(&component.to_string_lossy());\n-            href.push('/');\n-        });\n-        self.scx.ensure_dir(&cur)?;\n-        let mut fname = p.file_name()\n-                         .expect(\"source has no filename\")\n-                         .to_os_string();\n-        fname.push(\".html\");\n-        cur.push(&fname);\n-        href.push_str(&fname.to_string_lossy());\n-\n-        let mut v = Vec::new();\n-        let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n-                                               .to_string_lossy());\n-        let desc = format!(\"Source to the Rust file `{}`.\", filename);\n-        let page = layout::Page {\n-            title: &title,\n-            css_class: \"source\",\n-            root_path: &root_path,\n-            static_root_path: self.scx.static_root_path.as_deref(),\n-            description: &desc,\n-            keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.scx.resource_suffix,\n-            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n-            static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n-        };\n-        try_err!(layout::render(&mut v, &self.scx.layout,\n-                       &page, &(\"\"), &Source(contents),\n-                       self.scx.css_file_extension.is_some(),\n-                       &self.scx.themes,\n-                       self.scx.generate_search_filter), &cur);\n-        self.scx.fs.write(&cur, &v)?;\n-        self.scx.local_sources.insert(p.clone(), href);\n-        Ok(())\n-    }\n-}\n-\n impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.def_id.is_local() {\n@@ -1565,12 +1411,6 @@ impl DocFolder for Cache {\n             }\n         }\n \n-        // Register any generics to their corresponding string. This is used\n-        // when pretty-printing types.\n-        if let Some(generics) = item.inner.generics() {\n-            self.generics(generics);\n-        }\n-\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = item.inner {\n@@ -1642,7 +1482,7 @@ impl DocFolder for Cache {\n                             ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\"),\n-                            desc: plain_summary_line_short(item.doc_value()),\n+                            desc: shorten(plain_summary_line(item.doc_value())),\n                             parent,\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item),\n@@ -1803,18 +1643,6 @@ impl DocFolder for Cache {\n }\n \n impl Cache {\n-    fn generics(&mut self, generics: &clean::Generics) {\n-        for param in &generics.params {\n-            match param.kind {\n-                clean::GenericParamDefKind::Lifetime => {}\n-                clean::GenericParamDefKind::Type { did, .. } |\n-                clean::GenericParamDefKind::Const { did, .. } => {\n-                    self.param_names.insert(did, param.name.clone());\n-                }\n-            }\n-        }\n-    }\n-\n     fn add_aliases(&mut self, item: &clean::Item) {\n         if item.def_id.index == CRATE_DEF_INDEX {\n             return\n@@ -1836,7 +1664,7 @@ impl Cache {\n                                 ty: item.type_(),\n                                 name: item_name.to_string(),\n                                 path: path.clone(),\n-                                desc: plain_summary_line_short(item.doc_value()),\n+                                desc: shorten(plain_summary_line(item.doc_value())),\n                                 parent: None,\n                                 parent_idx: None,\n                                 search_type: get_index_search_type(&item),\n@@ -2057,31 +1885,6 @@ impl Context {\n         \"../\".repeat(self.current.len())\n     }\n \n-    /// Recurse in the directory structure and change the \"root path\" to make\n-    /// sure it always points to the top (relatively).\n-    fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n-        F: FnOnce(&mut Context) -> T,\n-    {\n-        if s.is_empty() {\n-            panic!(\"Unexpected empty destination: {:?}\", self.current);\n-        }\n-        let prev = self.dst.clone();\n-        self.dst.push(&s);\n-        self.current.push(s);\n-\n-        info!(\"Recursing into {}\", self.dst.display());\n-\n-        let ret = f(self);\n-\n-        info!(\"Recursed; leaving {}\", self.dst.display());\n-\n-        // Go back to where we were at\n-        self.dst = prev;\n-        self.current.pop().unwrap();\n-\n-        ret\n-    }\n-\n     /// Main method for rendering a crate.\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n@@ -2175,8 +1978,8 @@ impl Context {\n                    -> io::Result<()> {\n         // A little unfortunate that this is done like this, but it sure\n         // does make formatting *a lot* nicer.\n-        CURRENT_LOCATION_KEY.with(|slot| {\n-            *slot.borrow_mut() = self.current.clone();\n+        CURRENT_DEPTH.with(|slot| {\n+            slot.set(self.current.len());\n         });\n \n         let mut title = if it.is_primitive() || it.is_keyword() {\n@@ -2262,42 +2065,50 @@ impl Context {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             let name = item.name.as_ref().unwrap().to_string();\n-            let mut item = Some(item);\n-            let scx = self.shared.clone();\n-            self.recurse(name, |this| {\n-                let item = item.take().unwrap();\n-\n-                let mut buf = Vec::new();\n-                this.render_item(&mut buf, &item, false).unwrap();\n-                // buf will be empty if the module is stripped and there is no redirect for it\n-                if !buf.is_empty() {\n-                    this.shared.ensure_dir(&this.dst)?;\n-                    let joint_dst = this.dst.join(\"index.html\");\n-                    scx.fs.write(&joint_dst, buf)?;\n-                }\n+            let scx = &self.shared;\n+            if name.is_empty() {\n+                panic!(\"Unexpected empty destination: {:?}\", self.current);\n+            }\n+            let prev = self.dst.clone();\n+            self.dst.push(&name);\n+            self.current.push(name);\n \n-                let m = match item.inner {\n-                    clean::StrippedItem(box clean::ModuleItem(m)) |\n-                    clean::ModuleItem(m) => m,\n-                    _ => unreachable!()\n-                };\n+            info!(\"Recursing into {}\", self.dst.display());\n \n-                // Render sidebar-items.js used throughout this module.\n-                if !this.render_redirect_pages {\n-                    let items = this.build_sidebar_items(&m);\n-                    let js_dst = this.dst.join(\"sidebar-items.js\");\n-                    let mut v = Vec::new();\n-                    try_err!(write!(&mut v, \"initSidebarItems({});\",\n-                                    as_json(&items)), &js_dst);\n-                    scx.fs.write(&js_dst, &v)?;\n-                }\n+            let mut buf = Vec::new();\n+            self.render_item(&mut buf, &item, false).unwrap();\n+            // buf will be empty if the module is stripped and there is no redirect for it\n+            if !buf.is_empty() {\n+                self.shared.ensure_dir(&self.dst)?;\n+                let joint_dst = self.dst.join(\"index.html\");\n+                scx.fs.write(&joint_dst, buf)?;\n+            }\n \n-                for item in m.items {\n-                    f(this, item);\n-                }\n+            let m = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(m)) |\n+                clean::ModuleItem(m) => m,\n+                _ => unreachable!()\n+            };\n+\n+            // Render sidebar-items.js used throughout this module.\n+            if !self.render_redirect_pages {\n+                let items = self.build_sidebar_items(&m);\n+                let js_dst = self.dst.join(\"sidebar-items.js\");\n+                let mut v = Vec::new();\n+                try_err!(write!(&mut v, \"initSidebarItems({});\",\n+                                as_json(&items)), &js_dst);\n+                scx.fs.write(&js_dst, &v)?;\n+            }\n+\n+            for item in m.items {\n+                f(self, item);\n+            }\n \n-                Ok(())\n-            })?;\n+            info!(\"Recursed; leaving {}\", self.dst.display());\n+\n+            // Go back to where we were at\n+            self.dst = prev;\n+            self.current.pop().unwrap();\n         } else if item.name.is_some() {\n             let mut buf = Vec::new();\n             self.render_item(&mut buf, &item, true).unwrap();\n@@ -2399,7 +2210,7 @@ impl<'a> Item<'a> {\n                 (_, _, Unknown) => return None,\n             };\n \n-            clean_srcpath(&src_root, file, false, |component| {\n+            sources::clean_path(&src_root, file, false, |component| {\n                 path.push_str(&component.to_string_lossy());\n                 path.push('/');\n             });\n@@ -2549,29 +2360,39 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n     s\n }\n \n-fn shorter(s: Option<&str>) -> String {\n-    match s {\n-        Some(s) => s.lines()\n-            .skip_while(|s| s.chars().all(|c| c.is_whitespace()))\n-            .take_while(|line|{\n-            (*line).chars().any(|chr|{\n-                !chr.is_whitespace()\n-            })\n-        }).collect::<Vec<_>>().join(\"\\n\"),\n-        None => String::new()\n-    }\n-}\n-\n #[inline]\n fn plain_summary_line(s: Option<&str>) -> String {\n-    let line = shorter(s).replace(\"\\n\", \" \");\n-    markdown::plain_summary_line_full(&line[..], false)\n-}\n-\n-#[inline]\n-fn plain_summary_line_short(s: Option<&str>) -> String {\n-    let line = shorter(s).replace(\"\\n\", \" \");\n-    markdown::plain_summary_line_full(&line[..], true)\n+    let s = s.unwrap_or(\"\");\n+    // This essentially gets the first paragraph of text in one line.\n+    let mut line = s.lines()\n+        .skip_while(|line| line.chars().all(|c| c.is_whitespace()))\n+        .take_while(|line| line.chars().any(|c| !c.is_whitespace()))\n+        .fold(String::new(), |mut acc, line| {\n+            acc.push_str(line);\n+            acc.push(' ');\n+            acc\n+        });\n+    // remove final whitespace\n+    line.pop();\n+    markdown::plain_summary_line(&line[..])\n+}\n+\n+fn shorten(s: String) -> String {\n+    if s.chars().count() > 60 {\n+        let mut len = 0;\n+        let mut ret = s.split_whitespace()\n+                        .take_while(|p| {\n+                            // + 1 for the added character after the word.\n+                            len += p.chars().count() + 1;\n+                            len < 60\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\" \");\n+        ret.push('\u2026');\n+        ret\n+    } else {\n+        s\n+    }\n }\n \n fn document(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item) -> fmt::Result {\n@@ -2816,19 +2637,19 @@ fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n \n         match myitem.inner {\n             clean::ExternCrateItem(ref name, ref src) => {\n-                use crate::html::format::HRef;\n+                use crate::html::format::anchor;\n \n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n                                VisSpace(&myitem.visibility),\n-                               HRef::new(myitem.def_id, src),\n+                               anchor(myitem.def_id, src),\n                                name)?\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n                                VisSpace(&myitem.visibility),\n-                               HRef::new(myitem.def_id, name))?\n+                               anchor(myitem.def_id, name))?\n                     }\n                 }\n                 write!(w, \"</code></td></tr>\")?;\n@@ -5048,27 +4869,6 @@ fn sidebar_foreign_type(fmt: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::\n     Ok(())\n }\n \n-impl<'a> fmt::Display for Source<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let Source(s) = *self;\n-        let lines = s.lines().count();\n-        let mut cols = 0;\n-        let mut tmp = lines;\n-        while tmp > 0 {\n-            cols += 1;\n-            tmp /= 10;\n-        }\n-        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n-        for i in 1..=lines {\n-            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n-        }\n-        write!(fmt, \"</pre>\")?;\n-        write!(fmt, \"{}\",\n-               highlight::render_with_highlighting(s, None, None, None))?;\n-        Ok(())\n-    }\n-}\n-\n fn item_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n@@ -5125,7 +4925,7 @@ fn item_keyword(w: &mut fmt::Formatter<'_>, cx: &Context,\n     document(w, cx, it)\n }\n \n-const BASIC_KEYWORDS: &'static str = \"rust, rustlang, rust-lang\";\n+crate const BASIC_KEYWORDS: &'static str = \"rust, rustlang, rust-lang\";\n \n fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())"}, {"sha": "c1f1f59d9149a715e3d5235f3ede1e2d600a7956", "filename": "src/librustdoc/html/sources.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -0,0 +1,187 @@\n+use crate::clean;\n+use crate::docfs::PathError;\n+use crate::fold::DocFolder;\n+use crate::html::layout;\n+use crate::html::render::{Error, SharedContext, BASIC_KEYWORDS};\n+use crate::html::highlight;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::path::{Component, Path, PathBuf};\n+use std::fmt;\n+use syntax::source_map::FileName;\n+\n+crate fn render(dst: &Path, scx: &mut SharedContext,\n+                  krate: clean::Crate) -> Result<clean::Crate, Error> {\n+    info!(\"emitting source files\");\n+    let dst = dst.join(\"src\").join(&krate.name);\n+    scx.ensure_dir(&dst)?;\n+    let mut folder = SourceCollector {\n+        dst,\n+        scx,\n+    };\n+    Ok(folder.fold_crate(krate))\n+}\n+\n+/// Helper struct to render all source code to HTML pages\n+struct SourceCollector<'a> {\n+    scx: &'a mut SharedContext,\n+\n+    /// Root destination to place all HTML output into\n+    dst: PathBuf,\n+}\n+\n+impl<'a> DocFolder for SourceCollector<'a> {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        // If we're including source files, and we haven't seen this file yet,\n+        // then we need to render it out to the filesystem.\n+        if self.scx.include_sources\n+            // skip all invalid or macro spans\n+            && item.source.filename.is_real()\n+            // skip non-local items\n+            && item.def_id.is_local() {\n+\n+            // If it turns out that we couldn't read this file, then we probably\n+            // can't read any of the files (generating html output from json or\n+            // something like that), so just don't include sources for the\n+            // entire crate. The other option is maintaining this mapping on a\n+            // per-file basis, but that's probably not worth it...\n+            self.scx\n+                .include_sources = match self.emit_source(&item.source.filename) {\n+                Ok(()) => true,\n+                Err(e) => {\n+                    println!(\"warning: source code was requested to be rendered, \\\n+                              but processing `{}` had an error: {}\",\n+                             item.source.filename, e);\n+                    println!(\"         skipping rendering of source code\");\n+                    false\n+                }\n+            };\n+        }\n+        self.fold_item_recur(item)\n+    }\n+}\n+\n+impl<'a> SourceCollector<'a> {\n+    /// Renders the given filename into its corresponding HTML source file.\n+    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n+        let p = match *filename {\n+            FileName::Real(ref file) => file,\n+            _ => return Ok(()),\n+        };\n+        if self.scx.local_sources.contains_key(&**p) {\n+            // We've already emitted this source\n+            return Ok(());\n+        }\n+\n+        let contents = match fs::read_to_string(&p) {\n+            Ok(contents) => contents,\n+            Err(e) => {\n+                return Err(Error::new(e, &p));\n+            }\n+        };\n+\n+        // Remove the utf-8 BOM if any\n+        let contents = if contents.starts_with(\"\\u{feff}\") {\n+            &contents[3..]\n+        } else {\n+            &contents[..]\n+        };\n+\n+        // Create the intermediate directories\n+        let mut cur = self.dst.clone();\n+        let mut root_path = String::from(\"../../\");\n+        let mut href = String::new();\n+        clean_path(&self.scx.src_root, &p, false, |component| {\n+            cur.push(component);\n+            root_path.push_str(\"../\");\n+            href.push_str(&component.to_string_lossy());\n+            href.push('/');\n+        });\n+        self.scx.ensure_dir(&cur)?;\n+        let mut fname = p.file_name()\n+                         .expect(\"source has no filename\")\n+                         .to_os_string();\n+        fname.push(\".html\");\n+        cur.push(&fname);\n+        href.push_str(&fname.to_string_lossy());\n+\n+        let mut v = Vec::new();\n+        let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n+                                               .to_string_lossy());\n+        let desc = format!(\"Source to the Rust file `{}`.\", filename);\n+        let page = layout::Page {\n+            title: &title,\n+            css_class: \"source\",\n+            root_path: &root_path,\n+            static_root_path: self.scx.static_root_path.as_deref(),\n+            description: &desc,\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.scx.resource_suffix,\n+            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n+            static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n+        };\n+        let result = layout::render(&mut v, &self.scx.layout,\n+                       &page, &(\"\"), &Source(contents),\n+                       self.scx.css_file_extension.is_some(),\n+                       &self.scx.themes,\n+                       self.scx.generate_search_filter);\n+        if let Err(e) = result {\n+            return Err(Error::new(e, &cur));\n+        }\n+        self.scx.fs.write(&cur, &v)?;\n+        self.scx.local_sources.insert(p.clone(), href);\n+        Ok(())\n+    }\n+}\n+\n+/// Takes a path to a source file and cleans the path to it. This canonicalizes\n+/// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n+/// static HTML tree. Each component in the cleaned path will be passed as an\n+/// argument to `f`. The very last component of the path (ie the file name) will\n+/// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n+pub fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+where\n+    F: FnMut(&OsStr),\n+{\n+    // make it relative, if possible\n+    let p = p.strip_prefix(src_root).unwrap_or(p);\n+\n+    let mut iter = p.components().peekable();\n+\n+    while let Some(c) = iter.next() {\n+        if !keep_filename && iter.peek().is_none() {\n+            break;\n+        }\n+\n+        match c {\n+            Component::ParentDir => f(\"up\".as_ref()),\n+            Component::Normal(c) => f(c),\n+            _ => continue,\n+        }\n+    }\n+}\n+\n+/// Wrapper struct to render the source code of a file. This will do things like\n+/// adding line numbers to the left-hand side.\n+struct Source<'a>(&'a str);\n+\n+impl<'a> fmt::Display for Source<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let Source(s) = *self;\n+        let lines = s.lines().count();\n+        let mut cols = 0;\n+        let mut tmp = lines;\n+        while tmp > 0 {\n+            cols += 1;\n+            tmp /= 10;\n+        }\n+        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n+        for i in 1..=lines {\n+            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n+        }\n+        write!(fmt, \"</pre>\")?;\n+        write!(fmt, \"{}\",\n+               highlight::render_with_highlighting(s, None, None, None))?;\n+        Ok(())\n+    }\n+}"}, {"sha": "968578f957c5c85c462b5292258b9abccf7df952", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -67,6 +67,7 @@ pub mod html {\n     crate mod render;\n     crate mod static_files;\n     crate mod toc;\n+    crate mod sources;\n }\n mod markdown;\n mod passes;"}, {"sha": "ee330cb32111e545d7b24bc1255ccdb1457d6cea", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -41,7 +41,7 @@ fn def_id_to_path(\n // framework from syntax?.\n \n pub struct RustdocVisitor<'a, 'tcx> {\n-    cx: &'a core::DocContext<'tcx>,\n+    cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n@@ -51,7 +51,7 @@ pub struct RustdocVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn new(\n-        cx: &'a core::DocContext<'tcx>\n+        cx: &'a mut core::DocContext<'tcx>\n     ) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n@@ -84,7 +84,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         );\n         module.is_crate = true;\n \n-        self.cx.renderinfo.borrow_mut().exact_paths = self.exact_paths;\n+        self.cx.renderinfo.get_mut().exact_paths = self.exact_paths;\n \n         module\n     }\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 Res::Def(DefKind::ForeignTy, did) |\n                 Res::Def(DefKind::TyAlias, did) if !self_is_hidden => {\n                     self.cx.renderinfo\n-                        .borrow_mut()\n+                        .get_mut()\n                         .access_levels.map\n                         .insert(did, AccessLevel::Public);\n                 },"}, {"sha": "b229b5f6884d82381fd1657f24db7d00162eef2f", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0396aace27eea97c3603e9683e921807dff2a314/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=0396aace27eea97c3603e9683e921807dff2a314", "patch": "@@ -1,22 +1,20 @@\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n-use rustc::ty::Visibility;\n+use rustc::ty::{TyCtxt, Visibility};\n use rustc::util::nodemap::FxHashSet;\n use syntax::symbol::sym;\n \n-use std::cell::RefMut;\n-\n use crate::clean::{AttributesExt, NestedAttributesExt};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'tcx> {\n-    cx: &'a crate::core::DocContext<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     // Accessibility levels for reachable nodes\n-    access_levels: RefMut<'a, AccessLevels<DefId>>,\n+    access_levels: &'a mut AccessLevels<DefId>,\n     // Previous accessibility level, None means unreachable\n     prev_level: Option<AccessLevel>,\n     // Keeps track of already visited modules, in case a module re-exports its parent\n@@ -25,13 +23,13 @@ pub struct LibEmbargoVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n     pub fn new(\n-        cx: &'a crate::core::DocContext<'tcx>\n+        cx: &'a mut crate::core::DocContext<'tcx>\n     ) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n-            cx,\n-            access_levels: RefMut::map(cx.renderinfo.borrow_mut(), |ri| &mut ri.access_levels),\n+            tcx: cx.tcx,\n+            access_levels: &mut cx.renderinfo.get_mut().access_levels,\n             prev_level: Some(AccessLevel::Public),\n-            visited_mods: FxHashSet::default()\n+            visited_mods: FxHashSet::default(),\n         }\n     }\n \n@@ -43,7 +41,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n     // Updates node level and returns the updated level\n     fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let is_hidden = self.cx.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden);\n+        let is_hidden = self.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden);\n \n         let old_level = self.access_levels.map.get(&did).cloned();\n         // Accessibility levels can only grow\n@@ -60,9 +58,9 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        for item in self.cx.tcx.item_children(def_id).iter() {\n+        for item in self.tcx.item_children(def_id).iter() {\n             if let Some(def_id) = item.res.opt_def_id() {\n-                if self.cx.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index) ||\n+                if self.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index) ||\n                     item.vis == Visibility::Public {\n                     self.visit_item(item.res);\n                 }\n@@ -72,7 +70,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, res: Res) {\n         let def_id = res.def_id();\n-        let vis = self.cx.tcx.visibility(def_id);\n+        let vis = self.tcx.visibility(def_id);\n         let inherited_item_level = if vis == Visibility::Public {\n             self.prev_level\n         } else {"}]}