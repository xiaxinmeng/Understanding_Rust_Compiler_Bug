{"sha": "6727c6fb569afec52b87052b99f066b8f49827c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3MjdjNmZiNTY5YWZlYzUyYjg3MDUyYjk5ZjA2NmI4ZjQ5ODI3YzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-13T00:22:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-13T00:22:58Z"}, "message": "auto merge of #4881 : bjz/rust/incoming, r=catamorphism", "tree": {"sha": "a9d4c2f5ccc9d0df3695c4c46371ff57a7774f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9d4c2f5ccc9d0df3695c4c46371ff57a7774f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6727c6fb569afec52b87052b99f066b8f49827c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6727c6fb569afec52b87052b99f066b8f49827c4", "html_url": "https://github.com/rust-lang/rust/commit/6727c6fb569afec52b87052b99f066b8f49827c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6727c6fb569afec52b87052b99f066b8f49827c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91c59f5c9a6d1fe72a18768b074fcb16542e0ca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/91c59f5c9a6d1fe72a18768b074fcb16542e0ca1", "html_url": "https://github.com/rust-lang/rust/commit/91c59f5c9a6d1fe72a18768b074fcb16542e0ca1"}, {"sha": "48b2141b83bd3afe6aee3adf170ef6e985ab1353", "url": "https://api.github.com/repos/rust-lang/rust/commits/48b2141b83bd3afe6aee3adf170ef6e985ab1353", "html_url": "https://github.com/rust-lang/rust/commit/48b2141b83bd3afe6aee3adf170ef6e985ab1353"}], "stats": {"total": 1135, "additions": 1044, "deletions": 91}, "files": [{"sha": "7bf64d5b6684b5a9f57fcc0a12c88557dd068f35", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -199,7 +199,7 @@ pub use vec::{OwnedVector, OwnedCopyableVector};\n pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n \n-pub use num::Num;\n+pub use num::{Num, NumCast};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "6bea9e81197d3932faff1999900fbfa95e5d9cc0", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 82, "deletions": 5, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -14,6 +14,7 @@ use cmath;\n use cmp;\n use libc::{c_float, c_int};\n use num;\n+use num::NumCast;\n use option::Option;\n use from_str;\n use to_str;\n@@ -283,11 +284,6 @@ impl f32: num::Num {\n     pure fn modulo(&self, other: &f32) -> f32 { return *self % *other; }\n     #[inline(always)]\n     pure fn neg(&self)                -> f32 { return -*self;        }\n-\n-    #[inline(always)]\n-    pure fn to_int(&self)         -> int { return *self as int; }\n-    #[inline(always)]\n-    static pure fn from_int(n: int) -> f32 { return n as f32;    }\n }\n \n impl f32: num::Zero {\n@@ -300,6 +296,30 @@ impl f32: num::One {\n     static pure fn one() -> f32 { 1.0 }\n }\n \n+pub impl f32: NumCast {\n+    /**\n+     * Cast `n` to an `f32`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> f32 { n.to_f32() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self          }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n #[abi=\"rust-intrinsic\"]\n pub extern {\n     fn floorf32(val: f32) -> f32;\n@@ -545,6 +565,63 @@ impl f32: num::FromStrRadix {\n     }\n }\n \n+#[test]\n+pub fn test_num() {\n+    let ten: f32 = num::cast(10);\n+    let two: f32 = num::cast(2);\n+\n+    assert (ten.add(&two)    == num::cast(12));\n+    assert (ten.sub(&two)    == num::cast(8));\n+    assert (ten.mul(&two)    == num::cast(20));\n+    assert (ten.div(&two)    == num::cast(5));\n+    assert (ten.modulo(&two) == num::cast(0));\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u     == 20f32.to_uint());\n+    assert (20u8    == 20f32.to_u8());\n+    assert (20u16   == 20f32.to_u16());\n+    assert (20u32   == 20f32.to_u32());\n+    assert (20u64   == 20f32.to_u64());\n+    assert (20i     == 20f32.to_int());\n+    assert (20i8    == 20f32.to_i8());\n+    assert (20i16   == 20f32.to_i16());\n+    assert (20i32   == 20f32.to_i32());\n+    assert (20i64   == 20f32.to_i64());\n+    assert (20f     == 20f32.to_float());\n+    assert (20f32   == 20f32.to_f32());\n+    assert (20f64   == 20f32.to_f64());\n+\n+    assert (20f32 == NumCast::from(20u));\n+    assert (20f32 == NumCast::from(20u8));\n+    assert (20f32 == NumCast::from(20u16));\n+    assert (20f32 == NumCast::from(20u32));\n+    assert (20f32 == NumCast::from(20u64));\n+    assert (20f32 == NumCast::from(20i));\n+    assert (20f32 == NumCast::from(20i8));\n+    assert (20f32 == NumCast::from(20i16));\n+    assert (20f32 == NumCast::from(20i32));\n+    assert (20f32 == NumCast::from(20i64));\n+    assert (20f32 == NumCast::from(20f));\n+    assert (20f32 == NumCast::from(20f32));\n+    assert (20f32 == NumCast::from(20f64));\n+\n+    assert (20f32 == num::cast(20u));\n+    assert (20f32 == num::cast(20u8));\n+    assert (20f32 == num::cast(20u16));\n+    assert (20f32 == num::cast(20u32));\n+    assert (20f32 == num::cast(20u64));\n+    assert (20f32 == num::cast(20i));\n+    assert (20f32 == num::cast(20i8));\n+    assert (20f32 == num::cast(20i16));\n+    assert (20f32 == num::cast(20i32));\n+    assert (20f32 == num::cast(20i64));\n+    assert (20f32 == num::cast(20f));\n+    assert (20f32 == num::cast(20f32));\n+    assert (20f32 == num::cast(20f64));\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "7cde210265324a3a6f64b9cb703eaadb0bb9da54", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 80, "deletions": 3, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -15,6 +15,7 @@ use cmp;\n use libc::{c_double, c_int};\n use libc;\n use num;\n+use num::NumCast;\n use option::Option;\n use to_str;\n use from_str;\n@@ -307,11 +308,30 @@ impl f64: num::Num {\n     pure fn modulo(&self, other: &f64) -> f64 { return *self % *other; }\n     #[inline(always)]\n     pure fn neg(&self)                -> f64 { return -*self;        }\n+}\n \n+pub impl f64: NumCast {\n+    /**\n+     * Cast `n` to an `f64`\n+     */\n     #[inline(always)]\n-    pure fn to_int(&self)         -> int { return *self as int; }\n-    #[inline(always)]\n-    static pure fn from_int(n: int) -> f64 { return n as f64;    }\n+    static pure fn from<N:NumCast>(n: N) -> f64 { n.to_f64() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self          }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n }\n \n impl f64: num::Zero {\n@@ -569,6 +589,63 @@ impl f64: num::FromStrRadix {\n     }\n }\n \n+#[test]\n+pub fn test_num() {\n+    let ten: f64 = num::cast(10);\n+    let two: f64 = num::cast(2);\n+\n+    assert (ten.add(&two)    == num::cast(12));\n+    assert (ten.sub(&two)    == num::cast(8));\n+    assert (ten.mul(&two)    == num::cast(20));\n+    assert (ten.div(&two)    == num::cast(5));\n+    assert (ten.modulo(&two) == num::cast(0));\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20f64.to_uint());\n+    assert (20u8  == 20f64.to_u8());\n+    assert (20u16 == 20f64.to_u16());\n+    assert (20u32 == 20f64.to_u32());\n+    assert (20u64 == 20f64.to_u64());\n+    assert (20i   == 20f64.to_int());\n+    assert (20i8  == 20f64.to_i8());\n+    assert (20i16 == 20f64.to_i16());\n+    assert (20i32 == 20f64.to_i32());\n+    assert (20i64 == 20f64.to_i64());\n+    assert (20f   == 20f64.to_float());\n+    assert (20f32 == 20f64.to_f32());\n+    assert (20f64 == 20f64.to_f64());\n+\n+    assert (20f64 == NumCast::from(20u));\n+    assert (20f64 == NumCast::from(20u8));\n+    assert (20f64 == NumCast::from(20u16));\n+    assert (20f64 == NumCast::from(20u32));\n+    assert (20f64 == NumCast::from(20u64));\n+    assert (20f64 == NumCast::from(20i));\n+    assert (20f64 == NumCast::from(20i8));\n+    assert (20f64 == NumCast::from(20i16));\n+    assert (20f64 == NumCast::from(20i32));\n+    assert (20f64 == NumCast::from(20i64));\n+    assert (20f64 == NumCast::from(20f));\n+    assert (20f64 == NumCast::from(20f32));\n+    assert (20f64 == NumCast::from(20f64));\n+\n+    assert (20f64 == num::cast(20u));\n+    assert (20f64 == num::cast(20u8));\n+    assert (20f64 == num::cast(20u16));\n+    assert (20f64 == num::cast(20u32));\n+    assert (20f64 == num::cast(20u64));\n+    assert (20f64 == num::cast(20i));\n+    assert (20f64 == num::cast(20i8));\n+    assert (20f64 == num::cast(20i16));\n+    assert (20f64 == num::cast(20i32));\n+    assert (20f64 == num::cast(20i64));\n+    assert (20f64 == num::cast(20f));\n+    assert (20f64 == num::cast(20f32));\n+    assert (20f64 == num::cast(20f64));\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "74bf50737f563645240e23549673aebd6b199ebb", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 78, "deletions": 20, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -26,7 +26,7 @@ use cmp::{Eq, Ord};\n use cmp;\n use f64;\n use num;\n-use num::Num::from_int;\n+use num::NumCast;\n use option::{None, Option, Some};\n use str;\n use uint;\n@@ -417,11 +417,6 @@ impl float: num::Num {\n     pure fn modulo(&self, other: &float) -> float { return *self % *other; }\n     #[inline(always)]\n     pure fn neg(&self)                  -> float { return -*self;        }\n-\n-    #[inline(always)]\n-    pure fn to_int(&self)         -> int   { return *self as int; }\n-    #[inline(always)]\n-    static pure fn from_int(&self, n: int) -> float { return n as float;  }\n }\n \n impl float: num::Zero {\n@@ -434,6 +429,30 @@ impl float: num::One {\n     static pure fn one() -> float { 1.0 }\n }\n \n+pub impl float: NumCast {\n+    /**\n+     * Cast `n` to a `float`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> float { n.to_float() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self          }\n+}\n+\n impl float: num::Round {\n     #[inline(always)]\n     pure fn round(&self, mode: num::RoundMode) -> float {\n@@ -657,21 +676,60 @@ pub fn test_round() {\n }\n \n #[test]\n-pub fn test_traits() {\n-    fn test<U:num::Num cmp::Eq>(ten: &U) {\n-        assert (ten.to_int() == 10);\n-\n-        let two: U = from_int(2);\n-        assert (two.to_int() == 2);\n-\n-        assert (ten.add(&two) == from_int(12));\n-        assert (ten.sub(&two) == from_int(8));\n-        assert (ten.mul(&two) == from_int(20));\n-        assert (ten.div(&two) == from_int(5));\n-        assert (ten.modulo(&two) == from_int(0));\n-    }\n+pub fn test_num() {\n+    let ten: float = num::cast(10);\n+    let two: float = num::cast(2);\n \n-    test(&10.0);\n+    assert (ten.add(&two)    == num::cast(12));\n+    assert (ten.sub(&two)    == num::cast(8));\n+    assert (ten.mul(&two)    == num::cast(20));\n+    assert (ten.div(&two)    == num::cast(5));\n+    assert (ten.modulo(&two) == num::cast(0));\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20f.to_uint());\n+    assert (20u8  == 20f.to_u8());\n+    assert (20u16 == 20f.to_u16());\n+    assert (20u32 == 20f.to_u32());\n+    assert (20u64 == 20f.to_u64());\n+    assert (20i   == 20f.to_int());\n+    assert (20i8  == 20f.to_i8());\n+    assert (20i16 == 20f.to_i16());\n+    assert (20i32 == 20f.to_i32());\n+    assert (20i64 == 20f.to_i64());\n+    assert (20f   == 20f.to_float());\n+    assert (20f32 == 20f.to_f32());\n+    assert (20f64 == 20f.to_f64());\n+\n+    assert (20f == NumCast::from(20u));\n+    assert (20f == NumCast::from(20u8));\n+    assert (20f == NumCast::from(20u16));\n+    assert (20f == NumCast::from(20u32));\n+    assert (20f == NumCast::from(20u64));\n+    assert (20f == NumCast::from(20i));\n+    assert (20f == NumCast::from(20i8));\n+    assert (20f == NumCast::from(20i16));\n+    assert (20f == NumCast::from(20i32));\n+    assert (20f == NumCast::from(20i64));\n+    assert (20f == NumCast::from(20f));\n+    assert (20f == NumCast::from(20f32));\n+    assert (20f == NumCast::from(20f64));\n+\n+    assert (20f == num::cast(20u));\n+    assert (20f == num::cast(20u8));\n+    assert (20f == num::cast(20u16));\n+    assert (20f == num::cast(20u32));\n+    assert (20f == num::cast(20u64));\n+    assert (20f == num::cast(20i));\n+    assert (20f == num::cast(20i8));\n+    assert (20f == num::cast(20i16));\n+    assert (20f == num::cast(20i32));\n+    assert (20f == num::cast(20i64));\n+    assert (20f == num::cast(20f));\n+    assert (20f == num::cast(20f32));\n+    assert (20f == num::cast(20f64));\n }\n \n "}, {"sha": "b616a08246b67f61130b7c8fca142672228feb17", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -17,7 +17,6 @@ use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num;\n-use num::Num::from_int;\n use prelude::*;\n use str;\n use uint;\n@@ -184,11 +183,6 @@ impl T: num::Num {\n     pure fn modulo(&self, other: &T) -> T { return *self % *other; }\n     #[inline(always)]\n     pure fn neg(&self)              -> T { return -*self;        }\n-\n-    #[inline(always)]\n-    pure fn to_int(&self)         -> int { return *self as int; }\n-    #[inline(always)]\n-    static pure fn from_int(n: int) -> T   { return n as T;      }\n }\n \n impl T: num::Zero {\n@@ -411,22 +405,15 @@ fn test_int_from_str_overflow() {\n }\n \n #[test]\n-fn test_interfaces() {\n-    fn test<U:num::Num cmp::Eq>(ten: U) {\n-        assert (ten.to_int() == 10);\n-\n-        let two: U = from_int(2);\n-        assert (two.to_int() == 2);\n-\n-        assert (ten.add(&two) == from_int(12));\n-        assert (ten.sub(&two) == from_int(8));\n-        assert (ten.mul(&two) == from_int(20));\n-        assert (ten.div(&two) == from_int(5));\n-        assert (ten.modulo(&two) == from_int(0));\n-        assert (ten.neg() == from_int(-10));\n-    }\n-\n-    test(10 as T);\n+pub fn test_num() {\n+    let ten: T = num::cast(10);\n+    let two: T = num::cast(2);\n+\n+    assert (ten.add(&two)    == num::cast(12));\n+    assert (ten.sub(&two)    == num::cast(8));\n+    assert (ten.mul(&two)    == num::cast(20));\n+    assert (ten.div(&two)    == num::cast(5));\n+    assert (ten.modulo(&two) == num::cast(0));\n }\n \n #[test]"}, {"sha": "572cce92ea1d71eaa81557edfb2c79daa079d374", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,7 +10,78 @@\n \n //! Operations and constants for `i16`\n \n+use num::NumCast;\n+\n mod inst {\n     pub type T = i16;\n     pub const bits: uint = ::u16::bits;\n }\n+\n+pub impl i16: NumCast {\n+    /**\n+     * Cast `n` to a `i16`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> i16 { n.to_i16() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self          }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20i16.to_uint());\n+    assert (20u8  == 20i16.to_u8());\n+    assert (20u16 == 20i16.to_u16());\n+    assert (20u32 == 20i16.to_u32());\n+    assert (20u64 == 20i16.to_u64());\n+    assert (20i   == 20i16.to_int());\n+    assert (20i8  == 20i16.to_i8());\n+    assert (20i16 == 20i16.to_i16());\n+    assert (20i32 == 20i16.to_i32());\n+    assert (20i64 == 20i16.to_i64());\n+    assert (20f   == 20i16.to_float());\n+    assert (20f32 == 20i16.to_f32());\n+    assert (20f64 == 20i16.to_f64());\n+\n+    assert (20i16 == NumCast::from(20u));\n+    assert (20i16 == NumCast::from(20u8));\n+    assert (20i16 == NumCast::from(20u16));\n+    assert (20i16 == NumCast::from(20u32));\n+    assert (20i16 == NumCast::from(20u64));\n+    assert (20i16 == NumCast::from(20i));\n+    assert (20i16 == NumCast::from(20i8));\n+    assert (20i16 == NumCast::from(20i16));\n+    assert (20i16 == NumCast::from(20i32));\n+    assert (20i16 == NumCast::from(20i64));\n+    assert (20i16 == NumCast::from(20f));\n+    assert (20i16 == NumCast::from(20f32));\n+    assert (20i16 == NumCast::from(20f64));\n+\n+    assert (20i16 == num::cast(20u));\n+    assert (20i16 == num::cast(20u8));\n+    assert (20i16 == num::cast(20u16));\n+    assert (20i16 == num::cast(20u32));\n+    assert (20i16 == num::cast(20u64));\n+    assert (20i16 == num::cast(20i));\n+    assert (20i16 == num::cast(20i8));\n+    assert (20i16 == num::cast(20i16));\n+    assert (20i16 == num::cast(20i32));\n+    assert (20i16 == num::cast(20i64));\n+    assert (20i16 == num::cast(20f));\n+    assert (20i16 == num::cast(20f32));\n+    assert (20i16 == num::cast(20f64));\n+}\n\\ No newline at end of file"}, {"sha": "de2e467d02ab1848781f5aaddd8380420e6aa24c", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,7 +10,78 @@\n \n //! Operations and constants for `i32`\n \n+use num::NumCast;\n+\n mod inst {\n     pub type T = i32;\n     pub const bits: uint = ::u32::bits;\n }\n+\n+pub impl i32: NumCast {\n+    /**\n+     * Cast `n` to a `i32`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> i32 { n.to_i32() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self          }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20i32.to_uint());\n+    assert (20u8  == 20i32.to_u8());\n+    assert (20u16 == 20i32.to_u16());\n+    assert (20u32 == 20i32.to_u32());\n+    assert (20u64 == 20i32.to_u64());\n+    assert (20i   == 20i32.to_int());\n+    assert (20i8  == 20i32.to_i8());\n+    assert (20i16 == 20i32.to_i16());\n+    assert (20i32 == 20i32.to_i32());\n+    assert (20i64 == 20i32.to_i64());\n+    assert (20f   == 20i32.to_float());\n+    assert (20f32 == 20i32.to_f32());\n+    assert (20f64 == 20i32.to_f64());\n+\n+    assert (20i32 == NumCast::from(20u));\n+    assert (20i32 == NumCast::from(20u8));\n+    assert (20i32 == NumCast::from(20u16));\n+    assert (20i32 == NumCast::from(20u32));\n+    assert (20i32 == NumCast::from(20u64));\n+    assert (20i32 == NumCast::from(20i));\n+    assert (20i32 == NumCast::from(20i8));\n+    assert (20i32 == NumCast::from(20i16));\n+    assert (20i32 == NumCast::from(20i32));\n+    assert (20i32 == NumCast::from(20i64));\n+    assert (20i32 == NumCast::from(20f));\n+    assert (20i32 == NumCast::from(20f32));\n+    assert (20i32 == NumCast::from(20f64));\n+\n+    assert (20i32 == num::cast(20u));\n+    assert (20i32 == num::cast(20u8));\n+    assert (20i32 == num::cast(20u16));\n+    assert (20i32 == num::cast(20u32));\n+    assert (20i32 == num::cast(20u64));\n+    assert (20i32 == num::cast(20i));\n+    assert (20i32 == num::cast(20i8));\n+    assert (20i32 == num::cast(20i16));\n+    assert (20i32 == num::cast(20i32));\n+    assert (20i32 == num::cast(20i64));\n+    assert (20i32 == num::cast(20f));\n+    assert (20i32 == num::cast(20f32));\n+    assert (20i32 == num::cast(20f64));\n+}\n\\ No newline at end of file"}, {"sha": "d7413920a64f19743fe65eb7bbc81473c5a5c6f9", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,7 +10,78 @@\n \n //! Operations and constants for `i64`\n \n+use num::NumCast;\n+\n mod inst {\n     pub type T = i64;\n     pub const bits: uint = ::u64::bits;\n }\n+\n+pub impl i64: NumCast {\n+    /**\n+     * Cast `n` to a `i64`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> i64 { n.to_i64() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self          }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20i64.to_uint());\n+    assert (20u8  == 20i64.to_u8());\n+    assert (20u16 == 20i64.to_u16());\n+    assert (20u32 == 20i64.to_u32());\n+    assert (20u64 == 20i64.to_u64());\n+    assert (20i   == 20i64.to_int());\n+    assert (20i8  == 20i64.to_i8());\n+    assert (20i16 == 20i64.to_i16());\n+    assert (20i32 == 20i64.to_i32());\n+    assert (20i64 == 20i64.to_i64());\n+    assert (20f   == 20i64.to_float());\n+    assert (20f32 == 20i64.to_f32());\n+    assert (20f64 == 20i64.to_f64());\n+\n+    assert (20i64 == NumCast::from(20u));\n+    assert (20i64 == NumCast::from(20u8));\n+    assert (20i64 == NumCast::from(20u16));\n+    assert (20i64 == NumCast::from(20u32));\n+    assert (20i64 == NumCast::from(20u64));\n+    assert (20i64 == NumCast::from(20i));\n+    assert (20i64 == NumCast::from(20i8));\n+    assert (20i64 == NumCast::from(20i16));\n+    assert (20i64 == NumCast::from(20i32));\n+    assert (20i64 == NumCast::from(20i64));\n+    assert (20i64 == NumCast::from(20f));\n+    assert (20i64 == NumCast::from(20f32));\n+    assert (20i64 == NumCast::from(20f64));\n+\n+    assert (20i64 == num::cast(20u));\n+    assert (20i64 == num::cast(20u8));\n+    assert (20i64 == num::cast(20u16));\n+    assert (20i64 == num::cast(20u32));\n+    assert (20i64 == num::cast(20u64));\n+    assert (20i64 == num::cast(20i));\n+    assert (20i64 == num::cast(20i8));\n+    assert (20i64 == num::cast(20i16));\n+    assert (20i64 == num::cast(20i32));\n+    assert (20i64 == num::cast(20i64));\n+    assert (20i64 == num::cast(20f));\n+    assert (20i64 == num::cast(20f32));\n+    assert (20i64 == num::cast(20f64));\n+}"}, {"sha": "f2577020128bd030842a9f703ee03a13ff95aede", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,7 +10,78 @@\n \n //! Operations and constants for `i8`\n \n+use num::NumCast;\n+\n mod inst {\n     pub type T = i8;\n     pub const bits: uint = ::u8::bits;\n }\n+\n+pub impl i8: NumCast {\n+    /**\n+     * Cast `n` to a `i8`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> i8 { n.to_i8() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self          }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20i8.to_uint());\n+    assert (20u8  == 20i8.to_u8());\n+    assert (20u16 == 20i8.to_u16());\n+    assert (20u32 == 20i8.to_u32());\n+    assert (20u64 == 20i8.to_u64());\n+    assert (20i   == 20i8.to_int());\n+    assert (20i8  == 20i8.to_i8());\n+    assert (20i16 == 20i8.to_i16());\n+    assert (20i32 == 20i8.to_i32());\n+    assert (20i64 == 20i8.to_i64());\n+    assert (20f   == 20i8.to_float());\n+    assert (20f32 == 20i8.to_f32());\n+    assert (20f64 == 20i8.to_f64());\n+\n+    assert (20i8 == NumCast::from(20u));\n+    assert (20i8 == NumCast::from(20u8));\n+    assert (20i8 == NumCast::from(20u16));\n+    assert (20i8 == NumCast::from(20u32));\n+    assert (20i8 == NumCast::from(20u64));\n+    assert (20i8 == NumCast::from(20i));\n+    assert (20i8 == NumCast::from(20i8));\n+    assert (20i8 == NumCast::from(20i16));\n+    assert (20i8 == NumCast::from(20i32));\n+    assert (20i8 == NumCast::from(20i64));\n+    assert (20i8 == NumCast::from(20f));\n+    assert (20i8 == NumCast::from(20f32));\n+    assert (20i8 == NumCast::from(20f64));\n+\n+    assert (20i8 == num::cast(20u));\n+    assert (20i8 == num::cast(20u8));\n+    assert (20i8 == num::cast(20u16));\n+    assert (20i8 == num::cast(20u32));\n+    assert (20i8 == num::cast(20u64));\n+    assert (20i8 == num::cast(20i));\n+    assert (20i8 == num::cast(20i8));\n+    assert (20i8 == num::cast(20i16));\n+    assert (20i8 == num::cast(20i32));\n+    assert (20i8 == num::cast(20i64));\n+    assert (20i8 == num::cast(20f));\n+    assert (20i8 == num::cast(20f32));\n+    assert (20i8 == num::cast(20f64));\n+}"}, {"sha": "4ba1570e1359ab3dbdcbf84758c18ddb730b75cf", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for `int`\n \n+use num::NumCast;\n+\n pub use self::inst::pow;\n \n mod inst {\n@@ -55,3 +57,72 @@ mod inst {\n         assert (::int::min_value + ::int::max_value + 1 == 0);\n     }\n }\n+\n+pub impl int: NumCast {\n+    /**\n+     * Cast `n` to a `int`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> int { n.to_int() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self          }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20i.to_uint());\n+    assert (20u8  == 20i.to_u8());\n+    assert (20u16 == 20i.to_u16());\n+    assert (20u32 == 20i.to_u32());\n+    assert (20u64 == 20i.to_u64());\n+    assert (20i   == 20i.to_int());\n+    assert (20i8  == 20i.to_i8());\n+    assert (20i16 == 20i.to_i16());\n+    assert (20i32 == 20i.to_i32());\n+    assert (20i64 == 20i.to_i64());\n+    assert (20f   == 20i.to_float());\n+    assert (20f32 == 20i.to_f32());\n+    assert (20f64 == 20i.to_f64());\n+\n+    assert (20i == NumCast::from(20u));\n+    assert (20i == NumCast::from(20u8));\n+    assert (20i == NumCast::from(20u16));\n+    assert (20i == NumCast::from(20u32));\n+    assert (20i == NumCast::from(20u64));\n+    assert (20i == NumCast::from(20i));\n+    assert (20i == NumCast::from(20i8));\n+    assert (20i == NumCast::from(20i16));\n+    assert (20i == NumCast::from(20i32));\n+    assert (20i == NumCast::from(20i64));\n+    assert (20i == NumCast::from(20f));\n+    assert (20i == NumCast::from(20f32));\n+    assert (20i == NumCast::from(20f64));\n+\n+    assert (20i == num::cast(20u));\n+    assert (20i == num::cast(20u8));\n+    assert (20i == num::cast(20u16));\n+    assert (20i == num::cast(20u32));\n+    assert (20i == num::cast(20u64));\n+    assert (20i == num::cast(20i));\n+    assert (20i == num::cast(20i8));\n+    assert (20i == num::cast(20i16));\n+    assert (20i == num::cast(20i32));\n+    assert (20i == num::cast(20i64));\n+    assert (20i == num::cast(20f));\n+    assert (20i == num::cast(20f32));\n+    assert (20i == num::cast(20f64));\n+}"}, {"sha": "eb722b441c7a6d78b670ba5b8317a112cb5111f9", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -24,9 +24,6 @@ pub trait Num {\n     pure fn div(&self, other: &Self) -> Self;\n     pure fn modulo(&self, other: &Self) -> Self;\n     pure fn neg(&self) -> Self;\n-\n-    pure fn to_int(&self) -> int;\n-    static pure fn from_int(n: int) -> Self;\n }\n \n pub trait IntConvertible {\n@@ -50,6 +47,44 @@ pub trait Round {\n     pure fn fract(&self) -> Self;\n }\n \n+/**\n+ * Cast a number the the enclosing type\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let twenty: f32 = num::cast(0x14);\n+ * assert twenty == 20f32;\n+ * ~~~\n+ */\n+#[inline(always)]\n+pub pure fn cast<T:NumCast, U:NumCast>(n: T) -> U {\n+    NumCast::from(n)\n+}\n+\n+/**\n+ * An interface for generic numeric type casts\n+ */\n+pub trait NumCast {\n+    static pure fn from<T:NumCast>(n: T) -> Self;\n+\n+    pure fn to_u8(&self) -> u8;\n+    pure fn to_u16(&self) -> u16;\n+    pure fn to_u32(&self) -> u32;\n+    pure fn to_u64(&self) -> u64;\n+    pure fn to_uint(&self) -> uint;\n+\n+    pure fn to_i8(&self) -> i8;\n+    pure fn to_i16(&self) -> i16;\n+    pure fn to_i32(&self) -> i32;\n+    pure fn to_i64(&self) -> i64;\n+    pure fn to_int(&self) -> int;\n+\n+    pure fn to_f32(&self) -> f32;\n+    pure fn to_f64(&self) -> f64;\n+    pure fn to_float(&self) -> float;\n+}\n+\n pub enum RoundMode {\n     RoundDown,\n     RoundUp,\n@@ -135,16 +170,16 @@ pub pure fn is_neg_zero<T: Num One Zero Eq>(num: &T) -> bool {\n  * - If code written to use this function doesn't care about it, it's\n  *   probably assuming that `x^0` always equals `1`.\n  */\n-pub pure fn pow_with_uint<T: Num One Zero Copy>(radix: uint,\n-                                                pow: uint) -> T {\n+pub pure fn pow_with_uint<T: Num NumCast One Zero Copy>(radix: uint,\n+                                                        pow: uint) -> T {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n \n     if pow   == 0u { return _1; }\n     if radix == 0u { return _0; }\n     let mut my_pow     = pow;\n     let mut total      = _1;\n-    let mut multiplier = Num::from_int(radix as int);\n+    let mut multiplier = cast(radix as int);\n     while (my_pow > 0u) {\n         if my_pow % 2u == 1u {\n             total *= multiplier;\n@@ -217,7 +252,7 @@ pub enum SignFormat {\n  * those special values, and `special` is `false`, because then the\n  * algorithm just does normal calculations on them.\n  */\n-pub pure fn to_str_bytes_common<T: Num Zero One Eq Ord Round Copy>(\n+pub pure fn to_str_bytes_common<T: Num NumCast Zero One Eq Ord Round Copy>(\n         num: &T, radix: uint, special: bool, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n     if radix as int <  2 {\n@@ -250,7 +285,7 @@ pub pure fn to_str_bytes_common<T: Num Zero One Eq Ord Round Copy>(\n     let neg = *num < _0 || (negative_zero && *num == _0\n                             && special && is_neg_zero(num));\n     let mut buf: ~[u8] = ~[];\n-    let radix_gen      = Num::from_int::<T>(radix as int);\n+    let radix_gen: T   = cast(radix as int);\n \n     let mut deccum;\n \n@@ -439,7 +474,7 @@ pub pure fn to_str_bytes_common<T: Num Zero One Eq Ord Round Copy>(\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub pure fn to_str_common<T: Num Zero One Eq Ord Round Copy>(\n+pub pure fn to_str_common<T: Num NumCast Zero One Eq Ord Round Copy>(\n         num: &T, radix: uint, special: bool, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n     let (bytes, special) = to_str_bytes_common(num, radix, special,\n@@ -494,7 +529,7 @@ priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Could accept option to allow ignoring underscores, allowing for numbers\n  *   formated like `FF_AE_FF_FF`.\n  */\n-pub pure fn from_str_bytes_common<T: Num Zero One Ord Copy>(\n+pub pure fn from_str_bytes_common<T: Num NumCast Zero One Ord Copy>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool\n         ) -> Option<T> {\n@@ -519,7 +554,7 @@ pub pure fn from_str_bytes_common<T: Num Zero One Ord Copy>(\n \n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n-    let radix_gen: T = Num::from_int(radix as int);\n+    let radix_gen: T = cast(radix as int);\n \n     let len = buf.len();\n \n@@ -570,9 +605,9 @@ pub pure fn from_str_bytes_common<T: Num Zero One Ord Copy>(\n \n                 // add/subtract current digit depending on sign\n                 if accum_positive {\n-                    accum += Num::from_int(digit as int);\n+                    accum += cast(digit as int);\n                 } else {\n-                    accum -= Num::from_int(digit as int);\n+                    accum -= cast(digit as int);\n                 }\n \n                 // Detect overflow by comparing to last value\n@@ -609,11 +644,13 @@ pub pure fn from_str_bytes_common<T: Num Zero One Ord Copy>(\n                     // Decrease power one order of magnitude\n                     power /= radix_gen;\n \n+                    let digit_t: T = cast(digit);\n+\n                     // add/subtract current digit depending on sign\n                     if accum_positive {\n-                        accum += Num::from_int::<T>(digit as int) * power;\n+                        accum += digit_t * power;\n                     } else {\n-                        accum -= Num::from_int::<T>(digit as int) * power;\n+                        accum -= digit_t * power;\n                     }\n \n                     // Detect overflow by comparing to last value\n@@ -679,7 +716,7 @@ pub pure fn from_str_bytes_common<T: Num Zero One Ord Copy>(\n  * `from_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub pure fn from_str_common<T: Num Zero One Ord Copy>(\n+pub pure fn from_str_common<T: Num NumCast Zero One Ord Copy>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool\n         ) -> Option<T> {"}, {"sha": "0a219660fb94698a3a29777ed4af543b4c3f8f13", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -146,11 +146,6 @@ impl T: num::Num {\n     pure fn modulo(&self, other: &T) -> T { return *self % *other; }\n     #[inline(always)]\n     pure fn neg(&self)              -> T { return -*self;        }\n-\n-    #[inline(always)]\n-    pure fn to_int(&self)         -> int { return *self as int; }\n-    #[inline(always)]\n-    static pure fn from_int(n: int) -> T   { return n as T;      }\n }\n \n impl T: num::Zero {\n@@ -409,6 +404,18 @@ pub fn test_ranges() {\n     }\n }\n \n+#[test]\n+pub fn test_num() {\n+    let ten: T = num::cast(10);\n+    let two: T = num::cast(2);\n+\n+    assert (ten.add(&two)    == num::cast(12));\n+    assert (ten.sub(&two)    == num::cast(8));\n+    assert (ten.mul(&two)    == num::cast(20));\n+    assert (ten.div(&two)    == num::cast(5));\n+    assert (ten.modulo(&two) == num::cast(0));\n+}\n+\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]"}, {"sha": "e2e8e2bc9fce206fca9f779680d78c0035f20a04", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,9 +10,80 @@\n \n //! Operations and constants for `u16`\n \n+use num::NumCast;\n+\n mod inst {\n     pub type T = u16;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i16;\n     pub const bits: uint = 16;\n }\n+\n+pub impl u16: NumCast {\n+    /**\n+     * Cast `n` to a `u16`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> u16 { n.to_u16() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self          }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20u16.to_uint());\n+    assert (20u8  == 20u16.to_u8());\n+    assert (20u16 == 20u16.to_u16());\n+    assert (20u32 == 20u16.to_u32());\n+    assert (20u64 == 20u16.to_u64());\n+    assert (20i   == 20u16.to_int());\n+    assert (20i8  == 20u16.to_i8());\n+    assert (20i16 == 20u16.to_i16());\n+    assert (20i32 == 20u16.to_i32());\n+    assert (20i64 == 20u16.to_i64());\n+    assert (20f   == 20u16.to_float());\n+    assert (20f32 == 20u16.to_f32());\n+    assert (20f64 == 20u16.to_f64());\n+\n+    assert (20u16 == NumCast::from(20u));\n+    assert (20u16 == NumCast::from(20u8));\n+    assert (20u16 == NumCast::from(20u16));\n+    assert (20u16 == NumCast::from(20u32));\n+    assert (20u16 == NumCast::from(20u64));\n+    assert (20u16 == NumCast::from(20i));\n+    assert (20u16 == NumCast::from(20i8));\n+    assert (20u16 == NumCast::from(20i16));\n+    assert (20u16 == NumCast::from(20i32));\n+    assert (20u16 == NumCast::from(20i64));\n+    assert (20u16 == NumCast::from(20f));\n+    assert (20u16 == NumCast::from(20f32));\n+    assert (20u16 == NumCast::from(20f64));\n+\n+    assert (20u16 == num::cast(20u));\n+    assert (20u16 == num::cast(20u8));\n+    assert (20u16 == num::cast(20u16));\n+    assert (20u16 == num::cast(20u32));\n+    assert (20u16 == num::cast(20u64));\n+    assert (20u16 == num::cast(20i));\n+    assert (20u16 == num::cast(20i8));\n+    assert (20u16 == num::cast(20i16));\n+    assert (20u16 == num::cast(20i32));\n+    assert (20u16 == num::cast(20i64));\n+    assert (20u16 == num::cast(20f));\n+    assert (20u16 == num::cast(20f32));\n+    assert (20u16 == num::cast(20f64));\n+}\n\\ No newline at end of file"}, {"sha": "ac2727bff0996d697f5396a964b7b2c764022515", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,9 +10,80 @@\n \n //! Operations and constants for `u32`\n \n+use num::NumCast;\n+\n mod inst {\n     pub type T = u32;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i32;\n     pub const bits: uint = 32;\n+}\n+\n+pub impl u32: NumCast {\n+    /**\n+     * Cast `n` to a `u32`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> u32 { n.to_u32() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self          }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20u64.to_uint());\n+    assert (20u8  == 20u64.to_u8());\n+    assert (20u16 == 20u64.to_u16());\n+    assert (20u32 == 20u64.to_u32());\n+    assert (20u64 == 20u64.to_u64());\n+    assert (20i   == 20u64.to_int());\n+    assert (20i8  == 20u64.to_i8());\n+    assert (20i16 == 20u64.to_i16());\n+    assert (20i32 == 20u64.to_i32());\n+    assert (20i64 == 20u64.to_i64());\n+    assert (20f   == 20u64.to_float());\n+    assert (20f32 == 20u64.to_f32());\n+    assert (20f64 == 20u64.to_f64());\n+\n+    assert (20u64 == NumCast::from(20u));\n+    assert (20u64 == NumCast::from(20u8));\n+    assert (20u64 == NumCast::from(20u16));\n+    assert (20u64 == NumCast::from(20u32));\n+    assert (20u64 == NumCast::from(20u64));\n+    assert (20u64 == NumCast::from(20i));\n+    assert (20u64 == NumCast::from(20i8));\n+    assert (20u64 == NumCast::from(20i16));\n+    assert (20u64 == NumCast::from(20i32));\n+    assert (20u64 == NumCast::from(20i64));\n+    assert (20u64 == NumCast::from(20f));\n+    assert (20u64 == NumCast::from(20f32));\n+    assert (20u64 == NumCast::from(20f64));\n+\n+    assert (20u64 == num::cast(20u));\n+    assert (20u64 == num::cast(20u8));\n+    assert (20u64 == num::cast(20u16));\n+    assert (20u64 == num::cast(20u32));\n+    assert (20u64 == num::cast(20u64));\n+    assert (20u64 == num::cast(20i));\n+    assert (20u64 == num::cast(20i8));\n+    assert (20u64 == num::cast(20i16));\n+    assert (20u64 == num::cast(20i32));\n+    assert (20u64 == num::cast(20i64));\n+    assert (20u64 == num::cast(20f));\n+    assert (20u64 == num::cast(20f32));\n+    assert (20u64 == num::cast(20f64));\n }\n\\ No newline at end of file"}, {"sha": "345f81c147c778772f88abcaa48c70cfdd7e9859", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,9 +10,80 @@\n \n //! Operations and constants for `u64`\n \n+use num::NumCast;\n+\n mod inst {\n     pub type T = u64;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i64;\n     pub const bits: uint = 64;\n+}\n+\n+pub impl u64: num::NumCast {\n+    /**\n+     * Cast `n` to a `u64`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> u64 { n.to_u64() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self          }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20u64.to_uint());\n+    assert (20u8  == 20u64.to_u8());\n+    assert (20u16 == 20u64.to_u16());\n+    assert (20u32 == 20u64.to_u32());\n+    assert (20u64 == 20u64.to_u64());\n+    assert (20i   == 20u64.to_int());\n+    assert (20i8  == 20u64.to_i8());\n+    assert (20i16 == 20u64.to_i16());\n+    assert (20i32 == 20u64.to_i32());\n+    assert (20i64 == 20u64.to_i64());\n+    assert (20f   == 20u64.to_float());\n+    assert (20f32 == 20u64.to_f32());\n+    assert (20f64 == 20u64.to_f64());\n+\n+    assert (20u64 == NumCast::from(20u));\n+    assert (20u64 == NumCast::from(20u8));\n+    assert (20u64 == NumCast::from(20u16));\n+    assert (20u64 == NumCast::from(20u32));\n+    assert (20u64 == NumCast::from(20u64));\n+    assert (20u64 == NumCast::from(20i));\n+    assert (20u64 == NumCast::from(20i8));\n+    assert (20u64 == NumCast::from(20i16));\n+    assert (20u64 == NumCast::from(20i32));\n+    assert (20u64 == NumCast::from(20i64));\n+    assert (20u64 == NumCast::from(20f));\n+    assert (20u64 == NumCast::from(20f32));\n+    assert (20u64 == NumCast::from(20f64));\n+\n+    assert (20u64 == num::cast(20u));\n+    assert (20u64 == num::cast(20u8));\n+    assert (20u64 == num::cast(20u16));\n+    assert (20u64 == num::cast(20u32));\n+    assert (20u64 == num::cast(20u64));\n+    assert (20u64 == num::cast(20i));\n+    assert (20u64 == num::cast(20i8));\n+    assert (20u64 == num::cast(20i16));\n+    assert (20u64 == num::cast(20i32));\n+    assert (20u64 == num::cast(20i64));\n+    assert (20u64 == num::cast(20f));\n+    assert (20u64 == num::cast(20f32));\n+    assert (20u64 == num::cast(20f64));\n }\n\\ No newline at end of file"}, {"sha": "71be36d90196148564e7c9e0c73cfb4adb83c8e8", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -12,6 +12,8 @@\n \n pub use self::inst::is_ascii;\n \n+use num::NumCast;\n+\n mod inst {\n     pub type T = u8;\n     #[allow(non_camel_case_types)]\n@@ -23,3 +25,72 @@ mod inst {\n \n     pub pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n }\n+\n+pub impl u8: NumCast {\n+    /**\n+     * Cast `n` to a `u8`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> u8 { n.to_u8() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self          }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u     == 20u8.to_uint());\n+    assert (20u8    == 20u8.to_u8());\n+    assert (20u16   == 20u8.to_u16());\n+    assert (20u32   == 20u8.to_u32());\n+    assert (20u64   == 20u8.to_u64());\n+    assert (20i     == 20u8.to_int());\n+    assert (20i8    == 20u8.to_i8());\n+    assert (20i16   == 20u8.to_i16());\n+    assert (20i32   == 20u8.to_i32());\n+    assert (20i64   == 20u8.to_i64());\n+    assert (20f     == 20u8.to_float());\n+    assert (20f32   == 20u8.to_f32());\n+    assert (20f64   == 20u8.to_f64());\n+\n+    assert (20u8 == NumCast::from(20u));\n+    assert (20u8 == NumCast::from(20u8));\n+    assert (20u8 == NumCast::from(20u16));\n+    assert (20u8 == NumCast::from(20u32));\n+    assert (20u8 == NumCast::from(20u64));\n+    assert (20u8 == NumCast::from(20i));\n+    assert (20u8 == NumCast::from(20i8));\n+    assert (20u8 == NumCast::from(20i16));\n+    assert (20u8 == NumCast::from(20i32));\n+    assert (20u8 == NumCast::from(20i64));\n+    assert (20u8 == NumCast::from(20f));\n+    assert (20u8 == NumCast::from(20f32));\n+    assert (20u8 == NumCast::from(20f64));\n+\n+    assert (20u8 == num::cast(20u));\n+    assert (20u8 == num::cast(20u8));\n+    assert (20u8 == num::cast(20u16));\n+    assert (20u8 == num::cast(20u32));\n+    assert (20u8 == num::cast(20u64));\n+    assert (20u8 == num::cast(20i));\n+    assert (20u8 == num::cast(20i8));\n+    assert (20u8 == num::cast(20i16));\n+    assert (20u8 == num::cast(20i32));\n+    assert (20u8 == num::cast(20i64));\n+    assert (20u8 == num::cast(20f));\n+    assert (20u8 == num::cast(20f32));\n+    assert (20u8 == num::cast(20f64));\n+}\n\\ No newline at end of file"}, {"sha": "66689f18dfe9986b4687a9c7dd91c44e3c4d70e6", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -10,6 +10,8 @@\n \n //! Operations and constants for `uint`\n \n+use num::NumCast;\n+\n pub use self::inst::{\n     div_ceil, div_round, div_floor, iterate,\n     next_power_of_two\n@@ -206,3 +208,72 @@ pub mod inst {\n         assert (accum == 10);\n     }\n }\n+\n+pub impl uint: NumCast {\n+    /**\n+     * Cast `n` to a `uint`\n+     */\n+    #[inline(always)]\n+    static pure fn from<N:NumCast>(n: N) -> uint { n.to_uint() }\n+\n+    #[inline(always)] pure fn to_u8(&self)    -> u8    { *self as u8    }\n+    #[inline(always)] pure fn to_u16(&self)   -> u16   { *self as u16   }\n+    #[inline(always)] pure fn to_u32(&self)   -> u32   { *self as u32   }\n+    #[inline(always)] pure fn to_u64(&self)   -> u64   { *self as u64   }\n+    #[inline(always)] pure fn to_uint(&self)  -> uint  { *self          }\n+\n+    #[inline(always)] pure fn to_i8(&self)    -> i8    { *self as i8    }\n+    #[inline(always)] pure fn to_i16(&self)   -> i16   { *self as i16   }\n+    #[inline(always)] pure fn to_i32(&self)   -> i32   { *self as i32   }\n+    #[inline(always)] pure fn to_i64(&self)   -> i64   { *self as i64   }\n+    #[inline(always)] pure fn to_int(&self)   -> int   { *self as int   }\n+\n+    #[inline(always)] pure fn to_f32(&self)   -> f32   { *self as f32   }\n+    #[inline(always)] pure fn to_f64(&self)   -> f64   { *self as f64   }\n+    #[inline(always)] pure fn to_float(&self) -> float { *self as float }\n+}\n+\n+#[test]\n+fn test_numcast() {\n+    assert (20u   == 20u.to_uint());\n+    assert (20u8  == 20u.to_u8());\n+    assert (20u16 == 20u.to_u16());\n+    assert (20u32 == 20u.to_u32());\n+    assert (20u64 == 20u.to_u64());\n+    assert (20i   == 20u.to_int());\n+    assert (20i8  == 20u.to_i8());\n+    assert (20i16 == 20u.to_i16());\n+    assert (20i32 == 20u.to_i32());\n+    assert (20i64 == 20u.to_i64());\n+    assert (20f   == 20u.to_float());\n+    assert (20f32 == 20u.to_f32());\n+    assert (20f64 == 20u.to_f64());\n+\n+    assert (20u == NumCast::from(20u));\n+    assert (20u == NumCast::from(20u8));\n+    assert (20u == NumCast::from(20u16));\n+    assert (20u == NumCast::from(20u32));\n+    assert (20u == NumCast::from(20u64));\n+    assert (20u == NumCast::from(20i));\n+    assert (20u == NumCast::from(20i8));\n+    assert (20u == NumCast::from(20i16));\n+    assert (20u == NumCast::from(20i32));\n+    assert (20u == NumCast::from(20i64));\n+    assert (20u == NumCast::from(20f));\n+    assert (20u == NumCast::from(20f32));\n+    assert (20u == NumCast::from(20f64));\n+\n+    assert (20u == num::cast(20u));\n+    assert (20u == num::cast(20u8));\n+    assert (20u == num::cast(20u16));\n+    assert (20u == num::cast(20u32));\n+    assert (20u == num::cast(20u64));\n+    assert (20u == num::cast(20i));\n+    assert (20u == num::cast(20i8));\n+    assert (20u == num::cast(20i16));\n+    assert (20u == num::cast(20i32));\n+    assert (20u == num::cast(20i64));\n+    assert (20u == num::cast(20f));\n+    assert (20u == num::cast(20f32));\n+    assert (20u == num::cast(20f64));\n+}\n\\ No newline at end of file"}, {"sha": "5b4726d482d9e9072cdce99d5c4bee74148f272d", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -29,7 +29,7 @@ pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n-pub use num::Num;\n+pub use num::{Num, NumCast};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "c7a049b2f34e0ed272ec34a861b04b7569f92d83", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -11,16 +11,16 @@\n // except according to those terms.\n \n use cmp::{Eq, Ord};\n-use num::Num::from_int;\n+use num::NumCast::from;\n \n extern mod std;\n use std::cmp::FuzzyEq;\n \n-pub trait NumExt: Num Eq Ord {}\n+pub trait NumExt: Num NumCast Eq Ord {}\n \n pub trait FloatExt: NumExt FuzzyEq<Self> {}\n \n-fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > from_int(1) }\n-fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > from_int(1) }\n+fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > from(1) }\n+fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > from(1) }\n \n pub fn main() {}"}, {"sha": "1996e05618a0d319d373047d2d0aedca4690ecef", "filename": "src/test/run-pass/trait-inheritance-num0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -12,17 +12,17 @@\n \n // Extending Num and using inherited static methods\n \n-use Num::from_int;\n+use num::NumCast::from;\n \n trait Num {\n     static fn from_int(i: int) -> Self;\n     fn gt(&self, other: &Self) -> bool;\n }\n \n-pub trait NumExt: Num { }\n+pub trait NumExt: Num NumCast { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n-    n.gt(&from_int(1))\n+    n.gt(&from(1))\n }\n \n pub fn main() {}"}, {"sha": "a9cbd4e622c40c43780b0cad5cf3a3c609dead94", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -11,12 +11,12 @@\n // Using the real Num from core\n \n use cmp::Ord;\n-use num::Num::from_int;\n+use num::NumCast::from;\n \n-pub trait NumExt: Num Ord { }\n+pub trait NumExt: Num NumCast Ord { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n-    *n > from_int(1)\n+    *n > from(1)\n }\n \n pub fn main() {}"}, {"sha": "6829990bc5acda05db889d2c7316ce38bd28c378", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -13,7 +13,7 @@\n // A more complex example of numeric extensions\n \n use cmp::{Eq, Ord};\n-use num::Num::from_int;\n+use num::NumCast::from;\n \n extern mod std;\n use std::cmp::FuzzyEq;\n@@ -38,7 +38,7 @@ pub impl f64: TypeExt {}\n pub impl float: TypeExt {}\n \n \n-pub trait NumExt: TypeExt Eq Ord Num {}\n+pub trait NumExt: TypeExt Eq Ord Num NumCast {}\n \n pub impl u8: NumExt {}\n pub impl u16: NumExt {}"}, {"sha": "32775164d35ef48b82370dc00242d163f6e6450b", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use cmp::{Eq, Ord};\n-use num::Num::from_int;\n+use num::NumCast::from;\n \n-pub trait NumExt: Eq Ord Num {}\n+pub trait NumExt: Eq Ord Num NumCast {}\n \n pub impl f32: NumExt {}\n \n-fn num_eq_one<T:NumExt>(n: T) { io::println(fmt!(\"%?\", n == from_int(1))) }\n+fn num_eq_one<T:NumExt>(n: T) { io::println(fmt!(\"%?\", n == from(1))) }\n \n pub fn main() {\n     num_eq_one(1f32); // you need to actually use the function to trigger the ICE"}, {"sha": "13c75224e5f884fd8cc03b6b77b289f092ca91d1", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6727c6fb569afec52b87052b99f066b8f49827c4/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=6727c6fb569afec52b87052b99f066b8f49827c4", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use cmp::{Eq, Ord};\n-use num::Num::from_int;\n+use num::NumCast::from;\n \n-pub trait NumExt: Eq Num {}\n+pub trait NumExt: Eq Num NumCast {}\n \n pub impl f32: NumExt {}\n pub impl int: NumExt {}\n \n fn num_eq_one<T:NumExt>() -> T {\n-    from_int(1)\n+    from(1)\n }\n \n pub fn main() {"}]}