{"sha": "ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNGM3NzBmOGJhMzY0ODU3Yjk3YThjNTFjM2VkYTE0MTIwYjlhYzU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-11T06:01:31Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-11T06:01:31Z"}, "message": "rustc: fix the fallout from moving mutability into VstoreSlice and RegionTraitStore.", "tree": {"sha": "3560933dbfa4fcd2ef7143f0f701bd41c8cc87e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3560933dbfa4fcd2ef7143f0f701bd41c8cc87e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "html_url": "https://github.com/rust-lang/rust/commit/ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a62eba7abf5fe16dc79ae506f9582f0b3b9380c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a62eba7abf5fe16dc79ae506f9582f0b3b9380c5", "html_url": "https://github.com/rust-lang/rust/commit/a62eba7abf5fe16dc79ae506f9582f0b3b9380c5"}], "stats": {"total": 887, "additions": 409, "deletions": 478}, "files": [{"sha": "f99b45ffc69dd9a6098ede9fcce6503ae93b4a0e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -232,18 +232,6 @@ pub fn write_type(ecx: &EncodeContext,\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_vstore(ecx: &EncodeContext,\n-                    ebml_w: &mut Encoder,\n-                    vstore: ty::Vstore) {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_str,\n-        tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n-    };\n-    tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n-}\n-\n fn encode_type(ecx: &EncodeContext,\n                ebml_w: &mut Encoder,\n                typ: ty::t) {"}, {"sha": "3076d900a13c81e57997e14fa87027776a8d53b8", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -145,7 +145,8 @@ fn parse_sigil(st: &mut PState) -> ast::Sigil {\n     }\n }\n \n-fn parse_vstore(st: &mut PState, conv: conv_did) -> ty::Vstore {\n+fn parse_vstore<M>(st: &mut PState, conv: conv_did,\n+                   parse_mut: |&mut PState| -> M) -> ty::Vstore<M> {\n     assert_eq!(next(st), '/');\n \n     let c = peek(st);\n@@ -156,16 +157,16 @@ fn parse_vstore(st: &mut PState, conv: conv_did) -> ty::Vstore {\n     }\n \n     match next(st) {\n-      '~' => ty::VstoreUniq,\n-      '&' => ty::VstoreSlice(parse_region(st, conv)),\n-      c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n+        '~' => ty::VstoreUniq,\n+        '&' => ty::VstoreSlice(parse_region(st, conv), parse_mut(st)),\n+        c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n     }\n }\n \n fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n-        '&' => ty::RegionTraitStore(parse_region(st, conv)),\n+        '&' => ty::RegionTraitStore(parse_region(st, conv), parse_mutability(st)),\n         c => st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\", c))\n     }\n }\n@@ -327,10 +328,9 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let def = parse_def(st, NominalType, |x,y| conv(x,y));\n         let substs = parse_substs(st, |x,y| conv(x,y));\n         let store = parse_trait_store(st, |x,y| conv(x,y));\n-        let mt = parse_mutability(st);\n         let bounds = parse_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, def, substs, store, mt, bounds.builtin_bounds);\n+        return ty::mk_trait(st.tcx, def, substs, store, bounds.builtin_bounds);\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n@@ -350,12 +350,12 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_rptr(st.tcx, r, mt);\n       }\n       'V' => {\n-        let mt = parse_mt(st, |x,y| conv(x,y));\n-        let v = parse_vstore(st, |x,y| conv(x,y));\n-        return ty::mk_vec(st.tcx, mt, v);\n+        let ty = parse_ty(st, |x,y| conv(x,y));\n+        let v = parse_vstore(st, |x,y| conv(x,y), parse_mutability);\n+        return ty::mk_vec(st.tcx, ty, v);\n       }\n       'v' => {\n-        let v = parse_vstore(st, |x,y| conv(x,y));\n+        let v = parse_vstore(st, |x,y| conv(x,y), |_| ());\n         return ty::mk_str(st.tcx, v);\n       }\n       'T' => {"}, {"sha": "6bdc7aa388f35b9d690070d22f970ff20479410a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -204,14 +204,17 @@ fn enc_bound_region(w: &mut MemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_vstore(w: &mut MemWriter, cx: &ctxt, v: ty::Vstore) {\n+pub fn enc_vstore<M>(w: &mut MemWriter, cx: &ctxt,\n+                     v: ty::Vstore<M>,\n+                     enc_mut: |&mut MemWriter, M|) {\n     mywrite!(w, \"/\");\n     match v {\n         ty::VstoreFixed(u) => mywrite!(w, \"{}|\", u),\n         ty::VstoreUniq => mywrite!(w, \"~\"),\n-        ty::VstoreSlice(r) => {\n+        ty::VstoreSlice(r, m) => {\n             mywrite!(w, \"&\");\n             enc_region(w, cx, r);\n+            enc_mut(w, m);\n         }\n     }\n }\n@@ -224,9 +227,10 @@ pub fn enc_trait_ref(w: &mut MemWriter, cx: &ctxt, s: &ty::TraitRef) {\n pub fn enc_trait_store(w: &mut MemWriter, cx: &ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => mywrite!(w, \"~\"),\n-        ty::RegionTraitStore(re) => {\n+        ty::RegionTraitStore(re, m) => {\n             mywrite!(w, \"&\");\n             enc_region(w, cx, re);\n+            enc_mutability(w, m);\n         }\n     }\n }\n@@ -266,11 +270,10 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, mutability, bounds }) => {\n+        ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, bounds }) => {\n             mywrite!(w, \"x[{}|\", (cx.ds)(def_id));\n             enc_substs(w, cx, substs);\n             enc_trait_store(w, cx, store);\n-            enc_mutability(w, mutability);\n             let bounds = ty::ParamBounds {builtin_bounds: bounds,\n                                           trait_bounds: Vec::new()};\n             enc_bounds(w, cx, &bounds);\n@@ -289,14 +292,14 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_region(w, cx, r);\n             enc_mt(w, cx, mt);\n         }\n-        ty::ty_vec(mt, v) => {\n+        ty::ty_vec(ty, v) => {\n             mywrite!(w, \"V\");\n-            enc_mt(w, cx, mt);\n-            enc_vstore(w, cx, v);\n+            enc_ty(w, cx, ty);\n+            enc_vstore(w, cx, v, enc_mutability);\n         }\n         ty::ty_str(v) => {\n             mywrite!(w, \"v\");\n-            enc_vstore(w, cx, v);\n+            enc_vstore(w, cx, v, |_, ()| {});\n         }\n         ty::ty_closure(ref f) => {\n             mywrite!(w, \"f\");"}, {"sha": "3cc2b7b47db9957539eff6a47fdaf5b8a00b5f00", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -513,6 +513,17 @@ impl tr for ty::BoundRegion {\n     }\n }\n \n+impl tr for ty::TraitStore {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::TraitStore {\n+        match *self {\n+            ty::RegionTraitStore(r, m) => {\n+                ty::RegionTraitStore(r.tr(xcx), m)\n+            }\n+            ty::UniqTraitStore => ty::UniqTraitStore\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n@@ -823,7 +834,6 @@ impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n \n trait ebml_writer_helpers {\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t);\n-    fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::Vstore);\n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]);\n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n@@ -840,10 +850,6 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n \n-    fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::Vstore) {\n-        self.emit_opaque(|this| Ok(e::write_vstore(ecx, this, vstore)));\n-    }\n-\n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n         self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n@@ -903,14 +909,12 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n                     })\n                 }\n \n-                ty::AutoObject(sigil, region, m, b, def_id, ref substs) => {\n-                    this.emit_enum_variant(\"AutoObject\", 2, 6, |this| {\n-                        this.emit_enum_variant_arg(0, |this| sigil.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| region.encode(this));\n-                        this.emit_enum_variant_arg(2, |this| m.encode(this));\n-                        this.emit_enum_variant_arg(3, |this| b.encode(this));\n-                        this.emit_enum_variant_arg(4, |this| def_id.encode(this));\n-                        this.emit_enum_variant_arg(5, |this| Ok(this.emit_substs(ecx, substs)))\n+                ty::AutoObject(store, b, def_id, ref substs) => {\n+                    this.emit_enum_variant(\"AutoObject\", 2, 4, |this| {\n+                        this.emit_enum_variant_arg(0, |this| store.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| b.encode(this));\n+                        this.emit_enum_variant_arg(2, |this| def_id.encode(this));\n+                        this.emit_enum_variant_arg(3, |this| Ok(this.emit_substs(ecx, substs)))\n                     })\n                 }\n             }\n@@ -1279,25 +1283,16 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         ty::AutoDerefRef(auto_deref_ref.tr(xcx))\n                     }\n                     2 => {\n-                        let sigil: ast::Sigil =\n+                        let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-                        let region: Option<ty::Region> =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n-                        let m: ast::Mutability =\n-                            this.read_enum_variant_arg(2, |this| Decodable::decode(this)).unwrap();\n                         let b: ty::BuiltinBounds =\n-                            this.read_enum_variant_arg(3, |this| Decodable::decode(this)).unwrap();\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n                         let def_id: ast::DefId =\n-                            this.read_enum_variant_arg(4, |this| Decodable::decode(this)).unwrap();\n-                        let substs = this.read_enum_variant_arg(5, |this| Ok(this.read_substs(xcx)))\n+                            this.read_enum_variant_arg(2, |this| Decodable::decode(this)).unwrap();\n+                        let substs = this.read_enum_variant_arg(3, |this| Ok(this.read_substs(xcx)))\n                                     .unwrap();\n \n-                        let region = match region {\n-                            Some(r) => Some(r.tr(xcx)),\n-                            None => None\n-                        };\n-\n-                        ty::AutoObject(sigil, region, m, b, def_id.tr(xcx), substs)\n+                        ty::AutoObject(store.tr(xcx), b, def_id.tr(xcx), substs)\n                     }\n                     _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n                 })"}, {"sha": "a5da9e7f9d0e57fca91df8c78df5bd9c9eedbe54", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -176,18 +176,17 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_ptr(OwnedPtr))\n         }\n \n-        ty::ty_rptr(r, mt) |\n-        ty::ty_vec(mt, ty::VstoreSlice(r)) => {\n+        ty::ty_rptr(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n             Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n-\n-        ty::ty_trait(~ty::TyTrait { store: ty::RegionTraitStore(r), mutability: m, .. }) => {\n-            let kind = ty::BorrowKind::from_mutbl(m);\n+        ty::ty_vec(_, ty::VstoreSlice(r, mutbl)) |\n+        ty::ty_trait(~ty::TyTrait { store: ty::RegionTraitStore(r, mutbl), .. }) => {\n+            let kind = ty::BorrowKind::from_mutbl(mutbl);\n             Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n-        ty::ty_str(ty::VstoreSlice(r)) |\n+        ty::ty_str(ty::VstoreSlice(r, ())) |\n         ty::ty_closure(~ty::ClosureTy {sigil: ast::BorrowedSigil,\n                                       region: r, ..}) => {\n             Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n@@ -799,7 +798,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         //!   the implicit index deref, if any (see above)\n \n         let element_ty = match ty::index(base_cmt.ty) {\n-          Some(ref mt) => mt.ty,\n+          Some(ty) => ty,\n           None => {\n             self.tcx().sess.span_bug(\n                 elt.span(),\n@@ -882,8 +881,8 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n              */\n \n             match ty::get(slice_ty).sty {\n-                ty::ty_vec(slice_mt, ty::VstoreSlice(slice_r)) => {\n-                    (slice_mt.mutbl, slice_r)\n+                ty::ty_vec(_, ty::VstoreSlice(slice_r, mutbl)) => {\n+                    (mutbl, slice_r)\n                 }\n \n                 ty::ty_rptr(_, ref mt) => {"}, {"sha": "393e35141b4ec4dff2151ad2ca550929761500e4", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -1109,10 +1109,8 @@ fn extract_vec_elems<'a>(\n         let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n         let slice_len_offset = C_uint(bcx.ccx(), elem_count - 1u);\n         let slice_len = Sub(bcx, len, slice_len_offset);\n-        let slice_ty = ty::mk_vec(bcx.tcx(),\n-            ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n-            ty::VstoreSlice(ty::ReStatic)\n-        );\n+        let slice_ty = ty::mk_vec(bcx.tcx(), vt.unit_ty,\n+                                  ty::VstoreSlice(ty::ReStatic, ast::MutImmutable));\n         let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n         Store(bcx, slice_begin,\n               GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));"}, {"sha": "aa75ab57caf3d3545e68892bbb019413c01a9fb2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -657,10 +657,10 @@ pub fn iter_structural_ty<'r,\n               }\n           })\n       }\n-      ty::ty_str(ty::VstoreFixed(_)) |\n-      ty::ty_vec(_, ty::VstoreFixed(_)) => {\n-        let (base, len) = tvec::get_base_and_byte_len(cx, av, t);\n+      ty::ty_str(ty::VstoreFixed(n)) |\n+      ty::ty_vec(_, ty::VstoreFixed(n)) => {\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        let (base, len) = tvec::get_fixed_base_and_byte_len(cx, av, unit_ty, n);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n       ty::ty_tup(ref args) => {"}, {"sha": "67fc8f7949a19eb9d7efd7a9e710a1b4bda6c683", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -434,20 +434,14 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                           \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n-                  ty::ty_vec(_, vstore) | ty::ty_str(vstore) =>\n-                      match vstore {\n-                      ty::VstoreFixed(u) =>\n-                          (bv, C_uint(cx, u)),\n-\n-                      ty::VstoreSlice(_) => {\n-                          let e1 = const_get_elt(cx, bv, [0]);\n-                          (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n-                      },\n-                      _ => cx.sess().span_bug(base.span,\n-                                              \"index-expr base must be fixed-size or slice\")\n+                  ty::ty_vec(_, ty::VstoreFixed(u)) => (bv, C_uint(cx, u)),\n+                  ty::ty_vec(_, ty::VstoreSlice(..)) |\n+                  ty::ty_str(ty::VstoreSlice(..)) => {\n+                    let e1 = const_get_elt(cx, bv, [0]);\n+                    (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                   },\n-                  _ =>  cx.sess().span_bug(base.span,\n-                                           \"index-expr base must be a vector or string type\")\n+                  _ => cx.sess().span_bug(base.span,\n+                        \"index-expr base must be a fixed-size vector or a slice\")\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;"}, {"sha": "ab6e89de3967c5480260f4aa0be87efc41d1721d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -2049,7 +2049,6 @@ fn trait_metadata(cx: &CrateContext,\n                   trait_type: ty::t,\n                   substs: &ty::substs,\n                   trait_store: ty::TraitStore,\n-                  mutability: ast::Mutability,\n                   _: &ty::BuiltinBounds)\n                -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait type is\n@@ -2058,7 +2057,6 @@ fn trait_metadata(cx: &CrateContext,\n     let last = ty::with_path(cx.tcx(), def_id, |mut path| path.last().unwrap());\n     let ident_string = token::get_name(last.name());\n     let name = ppaux::trait_store_to_str(cx.tcx(), trait_store) +\n-               ppaux::mutability_to_str(mutability) +\n                ident_string.get();\n     // Add type and region parameters\n     let name = ppaux::parameterized(cx.tcx(), name, &substs.regions,\n@@ -2071,13 +2069,13 @@ fn trait_metadata(cx: &CrateContext,\n \n     let trait_llvm_type = type_of::type_of(cx, trait_type);\n \n-    return composite_type_metadata(cx,\n-                                   trait_llvm_type,\n-                                   name,\n-                                   [],\n-                                   containing_scope,\n-                                   file_metadata,\n-                                   definition_span);\n+    composite_type_metadata(cx,\n+                            trait_llvm_type,\n+                            name,\n+                            [],\n+                            containing_scope,\n+                            file_metadata,\n+                            definition_span)\n }\n \n fn type_metadata(cx: &CrateContext,\n@@ -2135,7 +2133,7 @@ fn type_metadata(cx: &CrateContext,\n                     let vec_metadata = vec_metadata(cx, i8_t, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n-                ty::VstoreSlice(_region) => {\n+                ty::VstoreSlice(..) => {\n                     vec_slice_metadata(cx, t, i8_t, usage_site_span)\n                 }\n             }\n@@ -2146,17 +2144,17 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_box(typ) => {\n             create_pointer_to_box_metadata(cx, t, typ)\n         },\n-        ty::ty_vec(ref mt, ref vstore) => {\n+        ty::ty_vec(ty, ref vstore) => {\n             match *vstore {\n                 ty::VstoreFixed(len) => {\n-                    fixed_vec_metadata(cx, mt.ty, len, usage_site_span)\n+                    fixed_vec_metadata(cx, ty, len, usage_site_span)\n                 }\n                 ty::VstoreUniq => {\n-                    let vec_metadata = vec_metadata(cx, mt.ty, usage_site_span);\n+                    let vec_metadata = vec_metadata(cx, ty, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n-                ty::VstoreSlice(_) => {\n-                    vec_slice_metadata(cx, t, mt.ty, usage_site_span)\n+                ty::VstoreSlice(..) => {\n+                    vec_slice_metadata(cx, t, ty, usage_site_span)\n                 }\n             }\n         },\n@@ -2174,10 +2172,8 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, &closurety.sig, usage_site_span)\n         },\n-        ty::ty_trait(~ty::TyTrait { def_id, ref substs,\n-                                store: trait_store, mutability,\n-                                ref bounds }) => {\n-            trait_metadata(cx, def_id, t, substs, trait_store, mutability, bounds)\n+        ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, ref bounds }) => {\n+            trait_metadata(cx, def_id, t, substs, store, bounds)\n         },\n         ty::ty_struct(def_id, ref substs) => {\n             if ty::type_is_simd(cx.tcx(), t) {"}, {"sha": "4515b5d086eab90184465428d6774be660f669e2", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -263,9 +263,8 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n-        let slice_ty = ty::mk_vec(tcx,\n-                                  ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n-                                  ty::VstoreSlice(ty::ReStatic));\n+        let slice_ty = ty::mk_vec(tcx, unit_ty,\n+                                  ty::VstoreSlice(ty::ReStatic, ast::MutImmutable));\n \n         let scratch = rvalue_scratch_datum(bcx, slice_ty, \"__adjust\");\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));"}, {"sha": "f4b6ed235e87a368b78f17729f9bd37c2357002d", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -93,7 +93,7 @@ fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n             }\n         }\n \n-        ty::ty_vec(mt, ty::VstoreUniq) if !ty::type_needs_drop(tcx, mt.ty) =>\n+        ty::ty_vec(ty, ty::VstoreUniq) if !ty::type_needs_drop(tcx, ty) =>\n             ty::mk_uniq(tcx, ty::mk_i8()),\n \n         _ => t"}, {"sha": "5764d017fa3559cba8a8c844224a0634d7e8fb26", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -54,7 +54,7 @@ impl<'a> Reflector<'a> {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n-        let str_vstore = ty::VstoreSlice(ty::ReStatic);\n+        let str_vstore = ty::VstoreSlice(ty::ReStatic, ());\n         let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n         let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n         let len = C_uint(bcx.ccx(), s.get().len());\n@@ -121,16 +121,16 @@ impl<'a> Reflector<'a> {\n         self.visit(\"leave_\" + bracket_name, extra);\n     }\n \n-    pub fn vstore_name_and_extra(&mut self,\n-                                 t: ty::t,\n-                                 vstore: ty::Vstore)\n-                                 -> (~str, Vec<ValueRef> ) {\n+    pub fn vstore_name_and_extra<M>(&mut self,\n+                                    t: ty::t,\n+                                    vstore: ty::Vstore<M>)\n+                                    -> (~str, Vec<ValueRef> ) {\n         match vstore {\n             ty::VstoreFixed(n) => {\n                 let extra = (vec!(self.c_uint(n))).append(self.c_size_and_align(t).as_slice());\n                 (~\"fixed\", extra)\n             }\n-            ty::VstoreSlice(_) => (~\"slice\", Vec::new()),\n+            ty::VstoreSlice(..) => (~\"slice\", Vec::new()),\n             ty::VstoreUniq => (~\"uniq\", Vec::new()),\n         }\n     }\n@@ -168,9 +168,15 @@ impl<'a> Reflector<'a> {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               self.visit(~\"estr_\" + name, extra.as_slice())\n           }\n-          ty::ty_vec(ref mt, vst) => {\n+          ty::ty_vec(ty, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n-              let extra = extra.append(self.c_mt(mt).as_slice());\n+              let extra = extra.append(self.c_mt(&ty::mt {\n+                  ty: ty,\n+                  mutbl: match vst {\n+                      ty::VstoreSlice(_, m) => m,\n+                      _ => ast::MutImmutable\n+                  }\n+              }).as_slice());\n               self.visit(~\"evec_\" + name, extra.as_slice())\n           }\n           // Should remove mt from box and uniq."}, {"sha": "85962eb0d62ec2e93bf2adc73b11c302e19ad6fc", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -162,9 +162,7 @@ pub fn trans_slice_vstore<'a>(\n         llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n \n         // Arrange for the backing array to be cleaned up.\n-        let fixed_ty = ty::mk_vec(bcx.tcx(),\n-                                  ty::mt {ty: vt.unit_ty,\n-                                          mutbl: ast::MutMutable},\n+        let fixed_ty = ty::mk_vec(bcx.tcx(), vt.unit_ty,\n                                   ty::VstoreFixed(count));\n         let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n         let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n@@ -445,44 +443,22 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_base_and_byte_len(bcx: &Block,\n-                             llval: ValueRef,\n-                             vec_ty: ty::t)\n-                             -> (ValueRef, ValueRef) {\n+pub fn get_fixed_base_and_byte_len(bcx: &Block,\n+                                   llval: ValueRef,\n+                                   unit_ty: ty::t,\n+                                   vec_length: uint)\n+                                   -> (ValueRef, ValueRef) {\n     /*!\n-     * Converts a vector into the slice pair.  The vector should be\n-     * stored in `llval` which should be by ref. If you have a datum,\n-     * you would probably prefer to call\n-     * `Datum::get_base_and_byte_len()`.\n+     * Converts a fixed-length vector into the slice pair.\n+     * The vector should be stored in `llval` which should be by ref.\n      */\n \n     let ccx = bcx.ccx();\n-    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n-\n-    let vstore = match ty::get(vec_ty).sty {\n-        ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n-        _ => ty::VstoreUniq\n-    };\n+    let vt = vec_types(bcx, unit_ty);\n \n-    match vstore {\n-        ty::VstoreFixed(n) => {\n-            let base = GEPi(bcx, llval, [0u, 0u]);\n-            let len = Mul(bcx, C_uint(ccx, n), vt.llunit_size);\n-            (base, len)\n-        }\n-        ty::VstoreSlice(_) => {\n-            assert!(!type_is_immediate(bcx.ccx(), vec_ty));\n-            let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n-            let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n-            let len = Mul(bcx, count, vt.llunit_size);\n-            (base, len)\n-        }\n-        ty::VstoreUniq => {\n-            assert!(type_is_immediate(bcx.ccx(), vec_ty));\n-            let body = Load(bcx, llval);\n-            (get_dataptr(bcx, body), get_fill(bcx, body))\n-        }\n-    }\n+    let base = GEPi(bcx, llval, [0u, 0u]);\n+    let len = Mul(bcx, C_uint(ccx, vec_length), vt.llunit_size);\n+    (base, len)\n }\n \n pub fn get_base_and_len(bcx: &Block,\n@@ -501,7 +477,15 @@ pub fn get_base_and_len(bcx: &Block,\n     let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n \n     let vstore = match ty::get(vec_ty).sty {\n-        ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n+        ty::ty_vec(_, vst) => vst,\n+        ty::ty_str(vst) => {\n+            // Convert from immutable-only-Vstore to Vstore.\n+            match vst {\n+                ty::VstoreFixed(n) => ty::VstoreFixed(n),\n+                ty::VstoreSlice(r, ()) => ty::VstoreSlice(r, ast::MutImmutable),\n+                ty::VstoreUniq => ty::VstoreUniq\n+            }\n+        }\n         _ => ty::VstoreUniq\n     };\n \n@@ -510,7 +494,7 @@ pub fn get_base_and_len(bcx: &Block,\n             let base = GEPi(bcx, llval, [0u, 0u]);\n             (base, C_uint(ccx, n))\n         }\n-        ty::VstoreSlice(_) => {\n+        ty::VstoreSlice(..) => {\n             assert!(!type_is_immediate(bcx.ccx(), vec_ty));\n             let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n             let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));"}, {"sha": "071eb083d4fdc2873d7d5050717a82d919e5289b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -133,8 +133,8 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_trait(..) => Type::opaque_trait(cx),\n \n         ty::ty_str(ty::VstoreFixed(size)) => Type::array(&Type::i8(cx), size as u64),\n-        ty::ty_vec(mt, ty::VstoreFixed(size)) => {\n-            Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n+        ty::ty_vec(ty, ty::VstoreFixed(size)) => {\n+            Type::array(&sizing_type_of(cx, ty), size as u64)\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) => {\n@@ -217,19 +217,19 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_uniq(typ) => {\n           type_of(cx, typ).ptr_to()\n       }\n-      ty::ty_vec(ref mt, ty::VstoreUniq) => {\n-          Type::vec(cx, &type_of(cx, mt.ty)).ptr_to()\n+      ty::ty_vec(ty, ty::VstoreUniq) => {\n+          Type::vec(cx, &type_of(cx, ty)).ptr_to()\n       }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n       ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n \n-      ty::ty_vec(ref mt, ty::VstoreSlice(_)) => {\n-          let p_ty = type_of(cx, mt.ty).ptr_to();\n+      ty::ty_vec(ty, ty::VstoreSlice(..)) => {\n+          let p_ty = type_of(cx, ty).ptr_to();\n           let u_ty = Type::uint_from_ty(cx, ast::TyU);\n           Type::struct_(cx, [p_ty, u_ty], false)\n       }\n \n-      ty::ty_str(ty::VstoreSlice(_)) => {\n+      ty::ty_str(ty::VstoreSlice(..)) => {\n           // This means we get a nicer name in the output\n           cx.tn.find_type(\"str_slice\").unwrap()\n       }\n@@ -238,8 +238,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           Type::array(&Type::i8(cx), (n + 1u) as u64)\n       }\n \n-      ty::ty_vec(ref mt, ty::VstoreFixed(n)) => {\n-          Type::array(&type_of(cx, mt.ty), n as u64)\n+      ty::ty_vec(ty, ty::VstoreFixed(n)) => {\n+          Type::array(&type_of(cx, ty), n as u64)\n       }\n \n       ty::ty_bare_fn(_) => {"}, {"sha": "c6a6b1e5184578d2003887b8261335791bc7ef17", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 54, "deletions": 82, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -27,7 +27,7 @@ use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n-use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n+use util::ppaux::{trait_store_to_str, ty_to_str};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n@@ -216,8 +216,7 @@ pub enum Variance {\n pub enum AutoAdjustment {\n     AutoAddEnv(ty::Region, ast::Sigil),\n     AutoDerefRef(AutoDerefRef),\n-    AutoObject(ast::Sigil, Option<ty::Region>,\n-               ast::Mutability,\n+    AutoObject(ty::TraitStore,\n                ty::BuiltinBounds,\n                ast::DefId, /* Trait ID */\n                ty::substs /* Trait substitutions */)\n@@ -818,7 +817,7 @@ pub enum type_err {\n     terr_regions_no_overlap(Region, Region),\n     terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n-    terr_vstores_differ(terr_vstore_kind, expected_found<Vstore>),\n+    terr_vstores_differ(terr_vstore_kind, expected_found<Vstore<()>>),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n     terr_in_field(@type_err, ast::Ident),\n     terr_sorts(expected_found<t>),\n@@ -1184,12 +1183,12 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         return f;\n     }\n     match &st {\n-      &ty_str(VstoreSlice(r)) => {\n+      &ty_str(VstoreSlice(r, ())) => {\n         flags |= rflags(r);\n       }\n-      &ty_vec(ref mt, VstoreSlice(r)) => {\n+      &ty_vec(ty, VstoreSlice(r, _)) => {\n         flags |= rflags(r);\n-        flags |= get(mt.ty).flags;\n+        flags |= get(ty).flags;\n       }\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_str(_) => {}\n@@ -1209,16 +1208,16 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_trait(~ty::TyTrait { ref substs, .. }) => {\n           flags |= sflags(substs);\n           match st {\n-              ty_trait(~ty::TyTrait { store: RegionTraitStore(r), .. }) => {\n+              ty_trait(~ty::TyTrait { store: RegionTraitStore(r, _), .. }) => {\n                     flags |= rflags(r);\n                 }\n               _ => {}\n           }\n       }\n-      &ty_box(tt) | &ty_uniq(tt) => {\n+      &ty_box(tt) | &ty_uniq(tt) | &ty_vec(tt, _) => {\n         flags |= get(tt).flags\n       }\n-      &ty_vec(ref m, _) | &ty_ptr(ref m) => {\n+      &ty_ptr(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n@@ -1347,8 +1346,8 @@ pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n #[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_str(cx: &ctxt, t: Vstore) -> t {\n-    mk_t(cx, ty_str(t))\n+pub fn mk_str(cx: &ctxt, v: Vstore<()>) -> t {\n+    mk_t(cx, ty_str(v))\n }\n \n pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: substs) -> t {\n@@ -1383,8 +1382,8 @@ pub fn mk_nil_ptr(cx: &ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec(cx: &ctxt, tm: mt, t: Vstore) -> t {\n-    mk_t(cx, ty_vec(tm, t))\n+pub fn mk_vec(cx: &ctxt, ty: t, v: Vstore) -> t {\n+    mk_t(cx, ty_vec(ty, v))\n }\n \n pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n@@ -1420,15 +1419,13 @@ pub fn mk_trait(cx: &ctxt,\n                 did: ast::DefId,\n                 substs: substs,\n                 store: TraitStore,\n-                mutability: ast::Mutability,\n                 bounds: BuiltinBounds)\n              -> t {\n     // take a copy of substs so that we own the vectors inside\n     let inner = ~TyTrait {\n         def_id: did,\n         substs: substs,\n         store: store,\n-        mutability: mutability,\n         bounds: bounds\n     };\n     mk_t(cx, ty_trait(inner))\n@@ -1465,8 +1462,8 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_str(_) | ty_self(_) |\n         ty_infer(_) | ty_param(_) | ty_err => {}\n-        ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n-        ty_vec(ref tm, _) | ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n+        ty_box(ty) | ty_uniq(ty) | ty_vec(ty, _) => maybe_walk_ty(ty, f),\n+        ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n@@ -1605,7 +1602,7 @@ pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) | ty_trait(..) |\n       ty_vec(_, VstoreFixed(_)) | ty_str(VstoreFixed(_)) |\n-      ty_vec(_, VstoreSlice(_)) | ty_str(VstoreSlice(_))\n+      ty_vec(_, VstoreSlice(..)) | ty_str(VstoreSlice(..))\n       => true,\n       _ => false\n     }\n@@ -1621,7 +1618,7 @@ pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_str(_) => mk_mach_uint(ast::TyU8),\n-        ty_vec(mt, _) => mt.ty,\n+        ty_vec(ty, _) => ty,\n         _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n }\n@@ -2073,8 +2070,8 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 tc_ty(cx, typ, cache).owned_pointer()\n             }\n \n-            ty_trait(~ty::TyTrait { store, mutability, bounds, .. }) => {\n-                object_contents(cx, store, mutability, bounds)\n+            ty_trait(~ty::TyTrait { store, bounds, .. }) => {\n+                object_contents(cx, store, bounds)\n             }\n \n             ty_ptr(ref mt) => {\n@@ -2086,20 +2083,19 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                     borrowed_contents(r, mt.mutbl))\n             }\n \n-            ty_vec(mt, VstoreUniq) => {\n-                tc_mt(cx, mt, cache).owned_pointer()\n+            ty_vec(ty, VstoreUniq) => {\n+                tc_ty(cx, ty, cache).owned_pointer()\n             }\n \n-            ty_vec(ref mt, VstoreSlice(r)) => {\n-                tc_ty(cx, mt.ty, cache).reference(\n-                    borrowed_contents(r, mt.mutbl))\n+            ty_vec(ty, VstoreSlice(r, mutbl)) => {\n+                tc_ty(cx, ty, cache).reference(borrowed_contents(r, mutbl))\n             }\n \n-            ty_vec(mt, VstoreFixed(_)) => {\n-                tc_mt(cx, mt, cache)\n+            ty_vec(ty, VstoreFixed(_)) => {\n+                tc_ty(cx, ty, cache)\n             }\n \n-            ty_str(VstoreSlice(r)) => {\n+            ty_str(VstoreSlice(r, ())) => {\n                 borrowed_contents(r, ast::MutImmutable)\n             }\n \n@@ -2223,9 +2219,8 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         // even more stuff.\n         let st = match cty.sigil {\n             ast::BorrowedSigil =>\n-                object_contents(cx, RegionTraitStore(cty.region), MutMutable, cty.bounds),\n-            ast::OwnedSigil =>\n-                object_contents(cx, UniqTraitStore, MutImmutable, cty.bounds),\n+                object_contents(cx, RegionTraitStore(cty.region, MutMutable), cty.bounds),\n+            ast::OwnedSigil => object_contents(cx, UniqTraitStore, cty.bounds),\n             ast::ManagedSigil => unreachable!()\n         };\n \n@@ -2246,18 +2241,16 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n     fn object_contents(cx: &ctxt,\n                        store: TraitStore,\n-                       mutbl: ast::Mutability,\n                        bounds: BuiltinBounds)\n                        -> TypeContents {\n         // These are the type contents of the (opaque) interior\n-        let contents = TC::ReachesMutable.when(mutbl == ast::MutMutable) |\n-            kind_bounds_to_contents(cx, bounds, []);\n+        let contents = kind_bounds_to_contents(cx, bounds, []);\n \n         match store {\n             UniqTraitStore => {\n                 contents.owned_pointer()\n             }\n-            RegionTraitStore(r) => {\n+            RegionTraitStore(r, mutbl) => {\n                 contents.reference(borrowed_contents(r, mutbl))\n             }\n         }\n@@ -2336,7 +2329,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             // normal vectors, since they don't necessarily have the\n             // possibilty to have length zero.\n             ty_vec(_, VstoreFixed(0)) => false, // don't need no contents\n-            ty_vec(mt, VstoreFixed(_)) => type_requires(cx, seen, r_ty, mt.ty),\n+            ty_vec(ty, VstoreFixed(_)) => type_requires(cx, seen, r_ty, ty),\n \n             ty_nil |\n             ty_bot |\n@@ -2473,8 +2466,8 @@ pub fn is_type_representable(cx: &ctxt, ty: t) -> Representability {\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n-            ty_vec(mt, VstoreFixed(_)) => {\n-                type_structurally_recursive(cx, seen, mt.ty)\n+            ty_vec(ty, VstoreFixed(_)) => {\n+                type_structurally_recursive(cx, seen, ty)\n             }\n \n             // Push struct and enum def-ids onto `seen` before recursing.\n@@ -2626,11 +2619,11 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n     }\n }\n \n-// Returns the type and mutability of t[i]\n-pub fn index(t: t) -> Option<mt> {\n+// Returns the type of t[i]\n+pub fn index(t: t) -> Option<t> {\n     match get(t).sty {\n-        ty_vec(mt, _) => Some(mt),\n-        ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n+        ty_vec(ty, _) => Some(ty),\n+        ty_str(_) => Some(mk_u8()),\n         _ => None\n     }\n }\n@@ -2735,8 +2728,8 @@ pub fn ty_region(tcx: &ctxt,\n                  ty: t) -> Region {\n     match get(ty).sty {\n         ty_rptr(r, _) => r,\n-        ty_vec(_, VstoreSlice(r)) => r,\n-        ty_str(VstoreSlice(r)) => r,\n+        ty_vec(_, VstoreSlice(r, _)) => r,\n+        ty_str(VstoreSlice(r, ())) => r,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n@@ -2934,14 +2927,8 @@ pub fn adjust_ty(cx: &ctxt,\n                     }\n                 }\n \n-                AutoObject(ref sigil, ref region, m, b, def_id, ref substs) => {\n-                    trait_adjustment_to_ty(cx,\n-                                           sigil,\n-                                           region,\n-                                           def_id,\n-                                           substs,\n-                                           m,\n-                                           b)\n+                AutoObject(store, bounds, def_id, ref substs) => {\n+                    mk_trait(cx, def_id, substs.clone(), store, bounds)\n                 }\n             }\n         }\n@@ -2952,12 +2939,12 @@ pub fn adjust_ty(cx: &ctxt,\n                   r: Region, m: ast::Mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n-            ty_vec(mt, _) => {\n-                ty::mk_vec(cx, mt {ty: mt.ty, mutbl: m}, VstoreSlice(r))\n+            ty_vec(ty, _) => {\n+                ty::mk_vec(cx, ty, VstoreSlice(r, m))\n             }\n \n             ty_str(_) => {\n-                ty::mk_str(cx, VstoreSlice(r))\n+                ty::mk_str(cx, VstoreSlice(r, ()))\n             }\n \n             ref s => {\n@@ -2993,7 +2980,7 @@ pub fn adjust_ty(cx: &ctxt,\n         match get(ty).sty {\n             ty_trait(~ty::TyTrait {def_id, ref substs, bounds, .. }) => {\n                 ty::mk_trait(cx, def_id, substs.clone(),\n-                             RegionTraitStore(r), m, bounds)\n+                             RegionTraitStore(r, m), bounds)\n             }\n             ref s => {\n                 cx.sess.span_bug(\n@@ -3005,19 +2992,6 @@ pub fn adjust_ty(cx: &ctxt,\n     }\n }\n \n-pub fn trait_adjustment_to_ty(cx: &ctxt, sigil: &ast::Sigil, region: &Option<Region>,\n-                              def_id: ast::DefId, substs: &substs, m: ast::Mutability,\n-                              bounds: BuiltinBounds) -> t {\n-\n-    let trait_store = match *sigil {\n-        BorrowedSigil => RegionTraitStore(region.expect(\"expected valid region\")),\n-        OwnedSigil => UniqTraitStore,\n-        ManagedSigil => unreachable!()\n-    };\n-\n-    mk_trait(cx, def_id, substs.clone(), trait_store, m, bounds)\n-}\n-\n impl AutoRef {\n     pub fn map_region(&self, f: |Region| -> Region) -> AutoRef {\n         match *self {\n@@ -3416,8 +3390,8 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n         terr_vstores_differ(k, ref values) => {\n             format!(\"{} storage differs: expected `{}` but found `{}`\",\n                  terr_vstore_kind_to_str(k),\n-                 vstore_to_str(cx, (*values).expected),\n-                 vstore_to_str(cx, (*values).found))\n+                 (*values).expected.repr(cx),\n+                 (*values).found.repr(cx))\n         }\n         terr_trait_stores_differ(_, ref values) => {\n             format!(\"trait storage differs: expected `{}` but found `{}`\",\n@@ -4208,10 +4182,10 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n             return t_norm;\n         }\n \n-        fn fold_vstore(&mut self, vstore: Vstore) -> Vstore {\n+        fn fold_vstore<M>(&mut self, vstore: Vstore<M>) -> Vstore<M> {\n             match vstore {\n                 VstoreFixed(..) | VstoreUniq => vstore,\n-                VstoreSlice(_) => VstoreSlice(ReStatic)\n+                VstoreSlice(_, m) => VstoreSlice(ReStatic, m)\n             }\n         }\n \n@@ -4396,8 +4370,7 @@ pub fn visitor_object_ty(tcx: &ctxt,\n         mk_trait(tcx,\n                  trait_ref.def_id,\n                  trait_ref.substs.clone(),\n-                 RegionTraitStore(region),\n-                 ast::MutMutable,\n+                 RegionTraitStore(region, ast::MutMutable),\n                  EmptyBuiltinBounds())))\n }\n \n@@ -4646,9 +4619,8 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_uniq(_) => {\n                 byte!(10);\n             }\n-            ty_vec(m, v) => {\n+            ty_vec(_, v) => {\n                 byte!(11);\n-                mt(&mut state, m);\n                 hash!(v);\n             }\n             ty_ptr(m) => {\n@@ -4673,17 +4645,17 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                 hash!(c.bounds);\n                 region(&mut state, c.region);\n             }\n-            ty_trait(~ty::TyTrait { def_id: d, store, mutability: m, bounds, .. }) => {\n+            ty_trait(~ty::TyTrait { def_id: d, store, bounds, .. }) => {\n                 byte!(17);\n                 did(&mut state, d);\n                 match store {\n                     UniqTraitStore => byte!(0),\n-                    RegionTraitStore(r) => {\n+                    RegionTraitStore(r, m) => {\n                         byte!(1)\n                         region(&mut state, r);\n+                        hash!(m);\n                     }\n                 }\n-                hash!(m);\n                 hash!(bounds);\n             }\n             ty_struct(d, _) => {"}, {"sha": "cd23a15f6ede98e0cef9ebcadf715272c05a9643", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -69,7 +69,7 @@ pub trait TypeFolder {\n         r\n     }\n \n-    fn fold_vstore(&mut self, vstore: ty::Vstore) -> ty::Vstore {\n+    fn fold_vstore<M>(&mut self, vstore: ty::Vstore<M>) -> ty::Vstore<M> {\n         super_fold_vstore(self, vstore)\n     }\n \n@@ -148,18 +148,17 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_ptr(ref tm) => {\n             ty::ty_ptr(this.fold_mt(tm))\n         }\n-        ty::ty_vec(ref tm, vst) => {\n-            ty::ty_vec(this.fold_mt(tm), this.fold_vstore(vst))\n+        ty::ty_vec(ty, vst) => {\n+            ty::ty_vec(this.fold_ty(ty), this.fold_vstore(vst))\n         }\n         ty::ty_enum(tid, ref substs) => {\n             ty::ty_enum(tid, this.fold_substs(substs))\n         }\n-        ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, mutability, bounds }) => {\n+        ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, bounds }) => {\n             ty::ty_trait(~ty::TyTrait{\n                 def_id: def_id,\n                 substs: this.fold_substs(substs),\n                 store: this.fold_trait_store(store),\n-                mutability: mutability,\n                 bounds: bounds\n             })\n         }\n@@ -193,22 +192,24 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_vstore<T:TypeFolder>(this: &mut T,\n-                                       vstore: ty::Vstore)\n-                                       -> ty::Vstore {\n+pub fn super_fold_vstore<T:TypeFolder, M>(this: &mut T,\n+                                          vstore: ty::Vstore<M>)\n+                                          -> ty::Vstore<M> {\n     match vstore {\n         ty::VstoreFixed(i) => ty::VstoreFixed(i),\n         ty::VstoreUniq => ty::VstoreUniq,\n-        ty::VstoreSlice(r) => ty::VstoreSlice(this.fold_region(r)),\n+        ty::VstoreSlice(r, m) => ty::VstoreSlice(this.fold_region(r), m),\n     }\n }\n \n pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n                                             trait_store: ty::TraitStore)\n                                             -> ty::TraitStore {\n     match trait_store {\n-        ty::UniqTraitStore      => ty::UniqTraitStore,\n-        ty::RegionTraitStore(r) => ty::RegionTraitStore(this.fold_region(r)),\n+        ty::UniqTraitStore => ty::UniqTraitStore,\n+        ty::RegionTraitStore(r, m) => {\n+            ty::RegionTraitStore(this.fold_region(r), m)\n+        }\n     }\n }\n "}, {"sha": "c0cdbdf23f7997bcf47c7e9ea04447a4296d164d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -372,18 +372,6 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n \n-    fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(\n-        this: &AC, rscope: &RS, ty: &ast::Ty) -> ty::mt {\n-\n-        ty::mt {ty: ast_ty_to_ty(this, rscope, ty), mutbl: ast::MutImmutable}\n-    }\n-\n-    fn ast_mt_to_mt<AC:AstConv, RS:RegionScope>(\n-        this: &AC, rscope: &RS, mt: &ast::MutTy) -> ty::mt {\n-\n-        ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n-    }\n-\n     enum PointerTy {\n         Box,\n         VStore(ty::Vstore)\n@@ -408,41 +396,44 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                   RS:RegionScope>(\n                   this: &AC,\n                   rscope: &RS,\n-                  a_seq_ty: &ast::MutTy,\n+                  a_seq_ty: &ast::Ty,\n                   ptr_ty: PointerTy,\n-                  constr: |ty::mt| -> ty::t)\n+                  constr: |ty::t| -> ty::t)\n                   -> ty::t {\n         let tcx = this.tcx();\n         debug!(\"mk_pointer(ptr_ty={:?})\", ptr_ty);\n \n-        match a_seq_ty.ty.node {\n+        match a_seq_ty.node {\n             ast::TyVec(ty) => {\n-                let vst = ptr_ty.expect_vstore(tcx, a_seq_ty.ty.span, \"vectors\");\n-                let mut mt = ast_ty_to_mt(this, rscope, ty);\n-                if a_seq_ty.mutbl == ast::MutMutable {\n-                    mt.mutbl = ast::MutMutable;\n-                }\n+                let vst = ptr_ty.expect_vstore(tcx, a_seq_ty.span, \"vectors\");\n                 debug!(\"&[]: vst={:?}\", vst);\n-                return ty::mk_vec(tcx, mt, vst);\n+                return ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, ty), vst);\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 // Note that the \"bounds must be empty if path is not a trait\"\n                 // restriction is enforced in the below case for ty_path, which\n                 // will run after this as long as the path isn't a trait.\n                 match tcx.def_map.borrow().find(&id) {\n-                    Some(&ast::DefPrimTy(ast::TyStr)) if\n-                            a_seq_ty.mutbl == ast::MutImmutable => {\n+                    Some(&ast::DefPrimTy(ast::TyStr)) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         let vst = ptr_ty.expect_vstore(tcx, path.span, \"strings\");\n-                        return ty::mk_str(tcx, vst);\n+                        match vst {\n+                            ty::VstoreUniq => {\n+                                return ty::mk_str(tcx, ty::VstoreUniq);\n+                            }\n+                            ty::VstoreSlice(r, ast::MutImmutable) => {\n+                                return ty::mk_str(tcx, ty::VstoreSlice(r, ()));\n+                            }\n+                            _ => {}\n+                        }\n                     }\n                     Some(&ast::DefTrait(trait_def_id)) => {\n                         let result = ast_path_to_trait_ref(\n                             this, rscope, trait_def_id, None, path);\n                         let trait_store = match ptr_ty {\n                             VStore(ty::VstoreUniq) => ty::UniqTraitStore,\n-                            VStore(ty::VstoreSlice(r)) => {\n-                                ty::RegionTraitStore(r)\n+                            VStore(ty::VstoreSlice(r, m)) => {\n+                                ty::RegionTraitStore(r, m)\n                             }\n                             _ => {\n                                 tcx.sess.span_err(\n@@ -457,7 +448,6 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             result.def_id,\n                                             result.substs.clone(),\n                                             trait_store,\n-                                            a_seq_ty.mutbl,\n                                             bounds);\n                     }\n                     _ => {}\n@@ -466,8 +456,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             _ => {}\n         }\n \n-        let seq_ty = ast_mt_to_mt(this, rscope, a_seq_ty);\n-        return constr(seq_ty);\n+        constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n     }\n \n     let tcx = this.tcx();\n@@ -490,27 +479,28 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyNil => ty::mk_nil(),\n             ast::TyBot => ty::mk_bot(),\n             ast::TyBox(ty) => {\n-                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, Box, |tmt| ty::mk_box(tcx, tmt.ty))\n+                mk_pointer(this, rscope, ty, Box, |ty| ty::mk_box(tcx, ty))\n             }\n             ast::TyUniq(ty) => {\n-                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, VStore(ty::VstoreUniq),\n-                           |tmt| ty::mk_uniq(tcx, tmt.ty))\n+                mk_pointer(this, rscope, ty, VStore(ty::VstoreUniq),\n+                           |ty| ty::mk_uniq(tcx, ty))\n             }\n             ast::TyVec(ty) => {\n                 tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n                 // return /something/ so they can at least get more errors\n-                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty), ty::VstoreUniq)\n+                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, ty), ty::VstoreUniq)\n             }\n             ast::TyPtr(ref mt) => {\n-                ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n+                ty::mk_ptr(tcx, ty::mt {\n+                    ty: ast_ty_to_ty(this, rscope, mt.ty),\n+                    mutbl: mt.mutbl\n+                })\n             }\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt, VStore(ty::VstoreSlice(r)),\n-                           |tmt| ty::mk_rptr(tcx, r, tmt))\n+                mk_pointer(this, rscope, &*mt.ty, VStore(ty::VstoreSlice(r, mt.mutbl)),\n+                           |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n             }\n             ast::TyTup(ref fields) => {\n                 let flds = fields.iter()\n@@ -535,7 +525,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n                         // Use corresponding trait store to figure out default bounds\n                         // if none were specified.\n-                        ast::BorrowedSigil => ty::RegionTraitStore(ty::ReEmpty), // dummy region\n+                        ast::BorrowedSigil => {\n+                            // dummy region\n+                            ty::RegionTraitStore(ty::ReEmpty, ast::MutMutable)\n+                        }\n                         ast::OwnedSigil    => ty::UniqTraitStore,\n                         ast::ManagedSigil  => return ty::mk_err()\n                     });\n@@ -611,10 +604,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, ty),\n                                            ty::VstoreFixed(i as uint)),\n                             const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, ty),\n                                            ty::VstoreFixed(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n@@ -851,7 +844,7 @@ fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyPar\n             builtin_bounds\n         },\n         // &'static Trait is sugar for &'static Trait:'static.\n-        (&None, ty::RegionTraitStore(ty::ReStatic)) => {\n+        (&None, ty::RegionTraitStore(ty::ReStatic, _)) => {\n             let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundStatic); set\n         }\n         // No bounds are automatically applied for &'r Trait or ~Trait"}, {"sha": "7b8d77196d6415c46fde84d7a33956f9658a77d0", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -615,12 +615,12 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n \n-        let (elt_type, region_var) = match *structure_of(fcx,\n-                                                         pat.span,\n-                                                         expected) {\n-          ty::ty_vec(mt, vstore) => {\n-            let region_var = match vstore {\n-                ty::VstoreSlice(r) => r,\n+        let (elt_type, region_var, mutbl) = match *structure_of(fcx,\n+                                                                pat.span,\n+                                                                expected) {\n+          ty::ty_vec(ty, vstore) => {\n+            match vstore {\n+                ty::VstoreSlice(r, m) => (ty, r, m),\n                 ty::VstoreUniq => {\n                     fcx.type_error_message(pat.span,\n                                            |_| {\n@@ -629,13 +629,12 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                                            },\n                                            expected,\n                                            None);\n-                    default_region_var\n+                    (ty, default_region_var, ast::MutImmutable)\n                 }\n                 ty::VstoreFixed(_) => {\n-                    default_region_var\n+                    (ty, default_region_var, ast::MutImmutable)\n                 }\n-            };\n-            (mt, region_var)\n+            }\n           }\n           _ => {\n               for &elt in before.iter() {\n@@ -662,20 +661,20 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           }\n         };\n         for elt in before.iter() {\n-            check_pat(pcx, *elt, elt_type.ty);\n+            check_pat(pcx, *elt, elt_type);\n         }\n         match slice {\n             Some(slice_pat) => {\n                 let slice_ty = ty::mk_vec(tcx,\n-                    ty::mt {ty: elt_type.ty, mutbl: elt_type.mutbl},\n-                    ty::VstoreSlice(region_var)\n+                    elt_type,\n+                    ty::VstoreSlice(region_var, mutbl)\n                 );\n                 check_pat(pcx, slice_pat, slice_ty);\n             }\n             None => ()\n         }\n         for elt in after.iter() {\n-            check_pat(pcx, *elt, elt_type.ty);\n+            check_pat(pcx, *elt, elt_type);\n         }\n         fcx.write_ty(pat.id, expected);\n       }"}, {"sha": "2839a5259b91a29d1e8fcb4b0dfd9ae208399bc5", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -264,12 +264,12 @@ fn construct_transformed_self_ty_for_object(\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n                     let r = r.subst(tcx, &substs); // handle Early-Bound lifetime\n                     ty::mk_trait(tcx, trait_def_id, substs,\n-                                 RegionTraitStore(r), mt.mutbl,\n+                                 RegionTraitStore(r, mt.mutbl),\n                                  ty::EmptyBuiltinBounds())\n                 }\n                 ty::ty_uniq(_) => { // must be SelfUniq\n                     ty::mk_trait(tcx, trait_def_id, substs,\n-                                 UniqTraitStore, ast::MutImmutable,\n+                                 UniqTraitStore,\n                                  ty::EmptyBuiltinBounds())\n                 }\n                 _ => {\n@@ -770,22 +770,21 @@ impl<'a> LookupContext<'a> {\n                      autoderefs: autoderefs+1,\n                      autoref: Some(ty::AutoPtr(region, self_mt.mutbl))})\n             }\n-            ty::ty_vec(self_mt, VstoreSlice(_)) => {\n+            ty::ty_vec(self_ty, VstoreSlice(_, mutbl)) => {\n                 let region =\n                     self.infcx().next_region_var(infer::Autoref(self.span));\n-                (ty::mk_vec(tcx, self_mt, VstoreSlice(region)),\n+                (ty::mk_vec(tcx, self_ty, VstoreSlice(region, mutbl)),\n                  ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n-                     autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))})\n+                     autoref: Some(ty::AutoBorrowVec(region, mutbl))})\n             }\n             ty::ty_trait(~ty::TyTrait {\n-                def_id, ref substs, store: ty::RegionTraitStore(_), mutability: mutbl, bounds\n+                def_id, ref substs, store: ty::RegionTraitStore(_, mutbl), bounds\n             }) => {\n                 let region =\n                     self.infcx().next_region_var(infer::Autoref(self.span));\n                 (ty::mk_trait(tcx, def_id, substs.clone(),\n-                              ty::RegionTraitStore(region),\n-                              mutbl, bounds),\n+                              ty::RegionTraitStore(region, mutbl), bounds),\n                  ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n                      autoref: Some(ty::AutoBorrowObj(region, mutbl))})\n@@ -821,25 +820,21 @@ impl<'a> LookupContext<'a> {\n         let tcx = self.tcx();\n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n-            ty_vec(mt, VstoreUniq) |\n-            ty_vec(mt, VstoreSlice(_)) |\n-            ty_vec(mt, VstoreFixed(_)) => {\n+            ty_vec(ty, VstoreUniq) |\n+            ty_vec(ty, VstoreSlice(..)) |\n+            ty_vec(ty, VstoreFixed(_)) => {\n                 // First try to borrow to a slice\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [MutImmutable, MutMutable],\n-                    |m,r| ty::mk_vec(tcx,\n-                                     ty::mt {ty:mt.ty, mutbl:m},\n-                                     VstoreSlice(r)));\n+                    |m,r| ty::mk_vec(tcx, ty, VstoreSlice(r, m)));\n \n                 if entry.is_some() { return entry; }\n \n                 // Then try to borrow to a slice *and* borrow a pointer.\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVecRef, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| {\n-                        let slice_ty = ty::mk_vec(tcx,\n-                                                  ty::mt {ty:mt.ty, mutbl:m},\n-                                                  VstoreSlice(r));\n+                        let slice_ty = ty::mk_vec(tcx, ty, VstoreSlice(r, m));\n                         // NB: we do not try to autoref to a mutable\n                         // pointer. That would be creating a pointer\n                         // to a temporary pointer (the borrowed\n@@ -853,14 +848,14 @@ impl<'a> LookupContext<'a> {\n             ty_str(VstoreFixed(_)) => {\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [MutImmutable],\n-                    |_m,r| ty::mk_str(tcx, VstoreSlice(r)));\n+                    |_m,r| ty::mk_str(tcx, VstoreSlice(r, ())));\n \n                 if entry.is_some() { return entry; }\n \n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVecRef, autoderefs, [MutImmutable],\n                     |m,r| {\n-                        let slice_ty = ty::mk_str(tcx, VstoreSlice(r));\n+                        let slice_ty = ty::mk_str(tcx, VstoreSlice(r, ()));\n                         ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n                     })\n             }\n@@ -870,9 +865,9 @@ impl<'a> LookupContext<'a> {\n \n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n-                    |trt_mut, reg| {\n+                    |m, r| {\n                         ty::mk_trait(tcx, trt_did, trt_substs.clone(),\n-                                     RegionTraitStore(reg), trt_mut, b)\n+                                     RegionTraitStore(r, m), b)\n                     })\n             }\n \n@@ -1303,7 +1298,7 @@ impl<'a> LookupContext<'a> {\n                     }\n \n                     ty::ty_trait(~ty::TyTrait {\n-                        def_id: self_did, store: RegionTraitStore(_), mutability: self_m, ..\n+                        def_id: self_did, store: RegionTraitStore(_, self_m), ..\n                     }) => {\n                         mutability_matches(self_m, m) &&\n                         rcvr_matches_object(self_did, candidate)"}, {"sha": "12b9b977e6ea9d8eca36221eb11d8fd1950d3070", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -1287,10 +1287,10 @@ pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_str(tcx, ty::VstoreSlice(ty::ReStatic)),\n+        ast::LitStr(..) => ty::mk_str(tcx, ty::VstoreSlice(ty::ReStatic, ())),\n         ast::LitBinary(..) => {\n-            ty::mk_vec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n-                       ty::VstoreSlice(ty::ReStatic))\n+            ty::mk_vec(tcx, ty::mk_u8(),\n+                       ty::VstoreSlice(ty::ReStatic, ast::MutImmutable))\n         }\n         ast::LitChar(_) => ty::mk_char(),\n         ast::LitInt(_, t) => ty::mk_mach_int(t),\n@@ -2479,17 +2479,17 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprVstore(ev, vst) => {\n         let typ = match ev.node {\n           ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n-            ty::mk_str(tcx, tt)\n+            let v = ast_expr_vstore_to_vstore(fcx, ev, vst, ());\n+            ty::mk_str(tcx, v)\n           }\n           ast::ExprVec(ref args) => {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n-            let mut any_error = false;\n-            let mut any_bot = false;\n             let mutability = match vst {\n                 ast::ExprVstoreMutSlice => ast::MutMutable,\n                 _ => ast::MutImmutable,\n             };\n+            let v = ast_expr_vstore_to_vstore(fcx, ev, vst, mutability);\n+            let mut any_error = false;\n+            let mut any_bot = false;\n             let t: ty::t = fcx.infcx().next_ty_var();\n             for e in args.iter() {\n                 check_expr_has_type(fcx, *e, t);\n@@ -2506,26 +2506,26 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             } else if any_bot {\n                 ty::mk_bot()\n             } else {\n-                ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n+                ty::mk_vec(tcx, t, v)\n             }\n           }\n           ast::ExprRepeat(element, count_expr) => {\n             check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n             let _ = ty::eval_repeat_count(fcx, count_expr);\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mutability = match vst {\n                 ast::ExprVstoreMutSlice => ast::MutMutable,\n                 _ => ast::MutImmutable,\n             };\n-            let t: ty::t = fcx.infcx().next_ty_var();\n+            let v = ast_expr_vstore_to_vstore(fcx, ev, vst, mutability);\n+            let t = fcx.infcx().next_ty_var();\n             check_expr_has_type(fcx, element, t);\n             let arg_t = fcx.expr_ty(element);\n             if ty::type_is_error(arg_t) {\n                 ty::mk_err()\n             } else if ty::type_is_bot(arg_t) {\n                 ty::mk_bot()\n             } else {\n-                ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n+                ty::mk_vec(tcx, t, v)\n             }\n           }\n           _ =>\n@@ -3022,8 +3022,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         for e in args.iter() {\n             check_expr_has_type(fcx, *e, t);\n         }\n-        let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n-                             ty::VstoreFixed(args.len()));\n+        let typ = ty::mk_vec(tcx, t, ty::VstoreFixed(args.len()));\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(element, count_expr) => {\n@@ -3039,8 +3038,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_bot(id);\n         }\n         else {\n-            let t = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n-                               ty::VstoreFixed(count));\n+            let t = ty::mk_vec(tcx, t, ty::VstoreFixed(count));\n             fcx.write_ty(id, t);\n         }\n       }\n@@ -3108,9 +3106,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n-                  Some(mt) => {\n+                  Some(ty) => {\n                       check_expr_has_type(fcx, idx, ty::mk_uint());\n-                      fcx.write_ty(id, mt.ty);\n+                      fcx.write_ty(id, ty);\n                       fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n                   None => {\n@@ -3852,33 +3850,33 @@ pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-pub fn ast_expr_vstore_to_vstore(fcx: &FnCtxt,\n-                                 e: &ast::Expr,\n-                                 v: ast::ExprVstore)\n-                              -> ty::Vstore {\n+pub fn ast_expr_vstore_to_vstore<M>(fcx: &FnCtxt,\n+                                    e: &ast::Expr,\n+                                    v: ast::ExprVstore,\n+                                    m: M)\n+                                    -> ty::Vstore<M> {\n     match v {\n         ast::ExprVstoreUniq => ty::VstoreUniq,\n         ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n             match e.node {\n                 ast::ExprLit(..) => {\n                     // string literals and *empty slices* live in static memory\n-                    ty::VstoreSlice(ty::ReStatic)\n+                    ty::VstoreSlice(ty::ReStatic, m)\n                 }\n                 ast::ExprVec(ref elements) if elements.len() == 0 => {\n                     // string literals and *empty slices* live in static memory\n-                    ty::VstoreSlice(ty::ReStatic)\n+                    ty::VstoreSlice(ty::ReStatic, m)\n                 }\n                 ast::ExprRepeat(..) |\n                 ast::ExprVec(..) => {\n                     // vector literals are temporaries on the stack\n                     match fcx.tcx().region_maps.temporary_scope(e.id) {\n                         Some(scope) => {\n-                            let r = ty::ReScope(scope);\n-                            ty::VstoreSlice(r)\n+                            ty::VstoreSlice(ty::ReScope(scope), m)\n                         }\n                         None => {\n                             // this slice occurs in a static somewhere\n-                            ty::VstoreSlice(ty::ReStatic)\n+                            ty::VstoreSlice(ty::ReStatic, m)\n                         }\n                     }\n                 }"}, {"sha": "d1a6c069f23073c9393bb7ed245a65d73e63c716", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -419,7 +419,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                         infer::AutoBorrow(expr.span));\n                 }\n             }\n-            ty::AutoObject(ast::BorrowedSigil, Some(trait_region), _, _, _, _) => {\n+            ty::AutoObject(ty::RegionTraitStore(trait_region, _), _, _, _) => {\n                 // Determine if we are casting `expr` to an trait\n                 // instance.  If so, we have to be sure that the type of\n                 // the source obeys the trait's region bound.\n@@ -540,7 +540,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // explaining how it goes about doing that.\n             let target_ty = rcx.resolve_node_type(expr.id);\n             match ty::get(target_ty).sty {\n-                ty::ty_trait(~ty::TyTrait { store: ty::RegionTraitStore(trait_region), .. }) => {\n+                ty::ty_trait(~ty::TyTrait {\n+                    store: ty::RegionTraitStore(trait_region, _), ..\n+                }) => {\n                     let source_ty = rcx.resolve_expr_type_adjusted(source);\n                     constrain_regions_in_type(\n                         rcx,\n@@ -923,8 +925,8 @@ fn constrain_index(rcx: &mut Rcx,\n \n     let r_index_expr = ty::ReScope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n-        ty::ty_str(ty::VstoreSlice(r_ptr)) |\n-        ty::ty_vec(_, ty::VstoreSlice(r_ptr)) => {\n+        ty::ty_str(ty::VstoreSlice(r_ptr, ())) |\n+        ty::ty_vec(_, ty::VstoreSlice(r_ptr, _)) => {\n             rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n                             r_index_expr, r_ptr);\n         }"}, {"sha": "44478376fd534005dc757450a7a5515e7a49230f", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -100,11 +100,11 @@ pub fn relate_nested_regions(tcx: &ty::ctxt,\n \n         fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n             match ty::get(ty).sty {\n-                ty::ty_rptr(r, ref mt) |\n-                ty::ty_vec(ref mt, ty::VstoreSlice(r)) => {\n+                ty::ty_rptr(r, ty::mt {ty, ..}) |\n+                ty::ty_vec(ty, ty::VstoreSlice(r, _)) => {\n                     self.relate(r);\n                     self.stack.push(r);\n-                    ty_fold::super_fold_ty(self, mt.ty);\n+                    ty_fold::super_fold_ty(self, ty);\n                     self.stack.pop().unwrap();\n                 }\n "}, {"sha": "cc8a2b82772cb910f55d426f94428af3f486fa60", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -468,8 +468,7 @@ fn fixup_substs(vcx: &VtableContext,\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n-                         ty::RegionTraitStore(ty::ReStatic),\n-                         ast::MutImmutable,\n+                         ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n                          ty::EmptyBuiltinBounds());\n     fixup_ty(vcx, span, t, is_early).map(|t_f| {\n         match ty::get(t_f).sty {\n@@ -532,8 +531,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       match ty::get(target_ty).sty {\n           // Bounds of type's contents are not checked here, but in kind.rs.\n           ty::ty_trait(~ty::TyTrait {\n-              def_id: target_def_id, substs: ref target_substs, store: store,\n-              mutability: target_mutbl, bounds: _bounds\n+              def_id: target_def_id, substs: ref target_substs, store, ..\n           }) => {\n               fn mutability_allowed(a_mutbl: ast::Mutability,\n                                     b_mutbl: ast::Mutability) -> bool {\n@@ -547,15 +545,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n               let ty = structurally_resolved_type(fcx, ex.span,\n                                                   fcx.expr_ty(src));\n               match (&ty::get(ty).sty, store) {\n-                  (&ty::ty_uniq(..), ty::UniqTraitStore)\n-                    if !mutability_allowed(ast::MutImmutable,\n-                                           target_mutbl) => {\n-                      fcx.tcx().sess.span_err(ex.span,\n-                                              format!(\"types differ in mutability\"));\n-                  }\n-\n-                  (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..))\n-                    if !mutability_allowed(mt.mutbl, target_mutbl) => {\n+                  (&ty::ty_rptr(_, mt), ty::RegionTraitStore(_, mutbl))\n+                    if !mutability_allowed(mt.mutbl, mutbl) => {\n                       fcx.tcx().sess.span_err(ex.span,\n                                               format!(\"types differ in mutability\"));\n                   }\n@@ -598,7 +589,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                       // regions.\n                       match (&ty::get(ty).sty, store) {\n                           (&ty::ty_rptr(ra, _),\n-                           ty::RegionTraitStore(rb)) => {\n+                           ty::RegionTraitStore(rb, _)) => {\n                               infer::mk_subr(fcx.infcx(),\n                                              false,\n                                              infer::RelateObjectBound(\n@@ -618,7 +609,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                ty::ty_sort_str(fcx.tcx(), ty)));\n                   }\n \n-                  (_, ty::RegionTraitStore(_)) => {\n+                  (_, ty::RegionTraitStore(..)) => {\n                       fcx.ccx.tcx.sess.span_err(\n                           ex.span,\n                           format!(\"can only cast an &-pointer \\\n@@ -716,10 +707,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                         }\n                     }\n                 }\n-                AutoObject(ref sigil,\n-                           ref region,\n-                           m,\n-                           b,\n+                AutoObject(store,\n+                           bounds,\n                            def_id,\n                            ref substs) => {\n                     debug!(\"doing trait adjustment for expr {} {} \\\n@@ -728,13 +717,9 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                            ex.repr(fcx.tcx()),\n                            is_early);\n \n-                    let object_ty = ty::trait_adjustment_to_ty(cx.tcx,\n-                                                               sigil,\n-                                                               region,\n-                                                               def_id,\n-                                                               substs,\n-                                                               m,\n-                                                               b);\n+                    let object_ty = ty::mk_trait(cx.tcx, def_id,\n+                                                 substs.clone(),\n+                                                 store, bounds);\n                     resolve_object_cast(ex, object_ty);\n                 }\n                 AutoAddEnv(..) => {}"}, {"sha": "6c260ee1321d1c1d091ed2ac25e412ee4efc8a35", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -108,15 +108,15 @@ impl<'f> Coerce<'f> {\n                 });\n             }\n \n-            ty::ty_str(VstoreSlice(_)) => {\n+            ty::ty_str(VstoreSlice(..)) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_string(a, sty_a, b)\n                 });\n             }\n \n-            ty::ty_vec(mt_b, VstoreSlice(_)) => {\n+            ty::ty_vec(_, VstoreSlice(_, mutbl_b)) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_borrowed_vector(a, sty_a, b, mt_b)\n+                    self.coerce_borrowed_vector(a, sty_a, b, mutbl_b)\n                 });\n             }\n \n@@ -133,13 +133,13 @@ impl<'f> Coerce<'f> {\n             }\n \n             ty::ty_trait(~ty::TyTrait {\n-                def_id, ref substs, store: ty::UniqTraitStore, mutability: m, bounds\n+                def_id, ref substs, store: ty::UniqTraitStore, bounds\n             }) => {\n                 let result = self.unpack_actual_value(a, |sty_a| {\n                     match *sty_a {\n                         ty::ty_uniq(..) => {\n                             self.coerce_object(a, sty_a, b, def_id, substs,\n-                                               ty::UniqTraitStore, m, bounds)\n+                                               ty::UniqTraitStore, bounds)\n                         }\n                         _ => Err(ty::terr_mismatch)\n                     }\n@@ -152,13 +152,13 @@ impl<'f> Coerce<'f> {\n             }\n \n             ty::ty_trait(~ty::TyTrait {\n-                def_id, ref substs, store: ty::RegionTraitStore(region), mutability: m, bounds\n+                def_id, ref substs, store: ty::RegionTraitStore(region, m), bounds\n             }) => {\n                 let result = self.unpack_actual_value(a, |sty_a| {\n                     match *sty_a {\n                         ty::ty_rptr(..) => {\n                             self.coerce_object(a, sty_a, b, def_id, substs,\n-                                               ty::RegionTraitStore(region), m, bounds)\n+                                               ty::RegionTraitStore(region, m), bounds)\n                         }\n                         _ => self.coerce_borrowed_object(a, sty_a, b, m)\n                     }\n@@ -267,7 +267,7 @@ impl<'f> Coerce<'f> {\n         };\n \n         let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n-        let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, VstoreSlice(r_a));\n+        let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, VstoreSlice(r_a, ()));\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n@@ -279,7 +279,7 @@ impl<'f> Coerce<'f> {\n                                   a: ty::t,\n                                   sty_a: &ty::sty,\n                                   b: ty::t,\n-                                  mt_b: ty::mt)\n+                                  mutbl_b: ast::Mutability)\n                                   -> CoerceResult {\n         debug!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.get_ref().infcx), sty_a,\n@@ -288,19 +288,18 @@ impl<'f> Coerce<'f> {\n         let sub = Sub(*self.get_ref());\n         let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n         let ty_inner = match *sty_a {\n-            ty::ty_vec(mt, _) => mt.ty,\n+            ty::ty_vec(ty, _) => ty,\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n-        let a_borrowed = ty::mk_vec(self.get_ref().infcx.tcx,\n-                                    mt {ty: ty_inner, mutbl: mt_b.mutbl},\n-                                    VstoreSlice(r_borrow));\n+        let a_borrowed = ty::mk_vec(self.get_ref().infcx.tcx, ty_inner,\n+                                    VstoreSlice(r_borrow, mutbl_b));\n         if_ok!(sub.tys(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n-            autoref: Some(AutoBorrowVec(r_borrow, mt_b.mutbl))\n+            autoref: Some(AutoBorrowVec(r_borrow, mutbl_b))\n         })))\n     }\n \n@@ -320,7 +319,7 @@ impl<'f> Coerce<'f> {\n         let a_borrowed = match *sty_a {\n             ty::ty_trait(~ty::TyTrait { def_id, ref substs, bounds, .. }) => {\n                 ty::mk_trait(tcx, def_id, substs.clone(),\n-                             ty::RegionTraitStore(r_a), b_mutbl, bounds)\n+                             ty::RegionTraitStore(r_a, b_mutbl), bounds)\n             }\n             _ => {\n                 return self.subtype(a, b);\n@@ -442,21 +441,13 @@ impl<'f> Coerce<'f> {\n                          trait_def_id: ast::DefId,\n                          trait_substs: &ty::substs,\n                          trait_store: ty::TraitStore,\n-                         m: ast::Mutability,\n                          bounds: ty::BuiltinBounds) -> CoerceResult {\n \n         debug!(\"coerce_object(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.get_ref().infcx), sty_a,\n                b.inf_str(self.get_ref().infcx));\n \n-        let (sigil, region) = match trait_store {\n-            ty::UniqTraitStore => (ast::OwnedSigil, None),\n-            ty::RegionTraitStore(region) => (ast::BorrowedSigil, Some(region))\n-        };\n-\n-        let adjustment = @ty::AutoObject(sigil, region, m, bounds,\n-                                         trait_def_id, trait_substs.clone());\n-\n-        Ok(Some(adjustment))\n+        Ok(Some(@ty::AutoObject(trait_store, bounds,\n+                                trait_def_id, trait_substs.clone())))\n     }\n }"}, {"sha": "bbef8077ffc3356458e76b13868795d463eae37f", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -263,16 +263,16 @@ pub trait Combine {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n \n     fn vstores(&self,\n-               vk: ty::terr_vstore_kind,\n-               a: ty::Vstore,\n-               b: ty::Vstore)\n-               -> cres<ty::Vstore> {\n+                vk: ty::terr_vstore_kind,\n+                a: ty::Vstore<()>,\n+                b: ty::Vstore<()>)\n+                -> cres<ty::Vstore<()>> {\n         debug!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n-            (ty::VstoreSlice(a_r), ty::VstoreSlice(b_r)) => {\n+            (ty::VstoreSlice(a_r, _), ty::VstoreSlice(b_r, _)) => {\n                 self.contraregions(a_r, b_r).and_then(|r| {\n-                    Ok(ty::VstoreSlice(r))\n+                    Ok(ty::VstoreSlice(r, ()))\n                 })\n             }\n \n@@ -294,9 +294,10 @@ pub trait Combine {\n         debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n-            (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n+            (ty::RegionTraitStore(a_r, a_m),\n+             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n                 self.contraregions(a_r, b_r).and_then(|r| {\n-                    Ok(ty::RegionTraitStore(r))\n+                    Ok(ty::RegionTraitStore(r, a_m))\n                 })\n             }\n \n@@ -480,7 +481,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n       (&ty::ty_trait(ref a_),\n        &ty::ty_trait(ref b_))\n-      if a_.def_id == b_.def_id && a_.mutability == b_.mutability => {\n+      if a_.def_id == b_.def_id => {\n           debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n           let substs = if_ok!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n           let s = if_ok!(this.trait_stores(ty::terr_trait, a_.store, b_.store));\n@@ -489,7 +490,6 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n                           a_.def_id,\n                           substs.clone(),\n                           s,\n-                          a_.mutability,\n                           bounds))\n       }\n \n@@ -517,10 +517,34 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n           Ok(ty::mk_rptr(tcx, r, mt))\n       }\n \n-      (&ty::ty_vec(ref a_mt, vs_a), &ty::ty_vec(ref b_mt, vs_b)) => {\n-        this.mts(a_mt, b_mt).and_then(|mt| {\n+      (&ty::ty_vec(a_inner, vs_a), &ty::ty_vec(b_inner, vs_b)) => {\n+        // This could be nicer if we didn't have to go through .mts(a, b).\n+        let (vs_a, mutbl_a) = match vs_a {\n+            ty::VstoreFixed(n) => (ty::VstoreFixed(n), ast::MutImmutable),\n+            ty::VstoreSlice(r, m) => (ty::VstoreSlice(r, ()), m),\n+            ty::VstoreUniq => (ty::VstoreUniq, ast::MutImmutable)\n+        };\n+        let (vs_b, mutbl_b) = match vs_b {\n+            ty::VstoreFixed(n) => (ty::VstoreFixed(n), ast::MutImmutable),\n+            ty::VstoreSlice(r, m) => (ty::VstoreSlice(r, ()), m),\n+            ty::VstoreUniq => (ty::VstoreUniq, ast::MutImmutable)\n+        };\n+        let a_mt = ty::mt {\n+            ty: a_inner,\n+            mutbl: mutbl_a\n+        };\n+        let b_mt = ty::mt {\n+            ty: b_inner,\n+            mutbl: mutbl_b\n+        };\n+        this.mts(&a_mt, &b_mt).and_then(|mt| {\n             this.vstores(ty::terr_vec, vs_a, vs_b).and_then(|vs| {\n-                Ok(ty::mk_vec(tcx, mt, vs))\n+                let store = match vs {\n+                    ty::VstoreFixed(n) => ty::VstoreFixed(n),\n+                    ty::VstoreSlice(r, _) => ty::VstoreSlice(r, mt.mutbl),\n+                    ty::VstoreUniq => ty::VstoreUniq\n+                };\n+                Ok(ty::mk_vec(tcx, mt.ty, store))\n             })\n         })\n       }"}, {"sha": "d80a2518055898823b4d1dbb13a74ed8ed9100fe", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -680,7 +680,6 @@ impl<'a> InferCtxt<'a> {\n                                   trait_ref.def_id,\n                                   trait_ref.substs.clone(),\n                                   ty::UniqTraitStore,\n-                                  ast::MutImmutable,\n                                   ty::EmptyBuiltinBounds());\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {"}, {"sha": "a0817360e394d0d5db3776dc00562f7a25e76d77", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -645,9 +645,16 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_vstore(vstore, variance);\n             }\n \n-            ty::ty_vec(ref mt, vstore) => {\n+            ty::ty_vec(ty, vstore) => {\n                 self.add_constraints_from_vstore(vstore, variance);\n-                self.add_constraints_from_mt(mt, variance);\n+                let mt = ty::mt {\n+                    ty: ty,\n+                    mutbl: match vstore {\n+                        ty::VstoreSlice(_, m) => m,\n+                        _ => ast::MutImmutable\n+                    }\n+                };\n+                self.add_constraints_from_mt(&mt, variance);\n             }\n \n             ty::ty_uniq(typ) | ty::ty_box(typ) => {\n@@ -718,11 +725,11 @@ impl<'a> ConstraintContext<'a> {\n \n     /// Adds constraints appropriate for a vector with Vstore `vstore`\n     /// appearing in a context with ambient variance `variance`\n-    fn add_constraints_from_vstore(&mut self,\n-                                   vstore: ty::Vstore,\n-                                   variance: VarianceTermPtr<'a>) {\n+    fn add_constraints_from_vstore<M>(&mut self,\n+                                      vstore: ty::Vstore<M>,\n+                                      variance: VarianceTermPtr<'a>) {\n         match vstore {\n-            ty::VstoreSlice(r) => {\n+            ty::VstoreSlice(r, _) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(r, contra);\n             }"}, {"sha": "e74bacebeab0630f7becf51b74ddd98b4245daac", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4c770f8ba364857b97a8c51c3eda14120b9ac5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ee4c770f8ba364857b97a8c51c3eda14120b9ac5", "patch": "@@ -197,36 +197,14 @@ pub fn mutability_to_str(m: ast::Mutability) -> ~str {\n }\n \n pub fn mt_to_str(cx: &ctxt, m: &mt) -> ~str {\n-    mt_to_str_wrapped(cx, \"\", m, \"\")\n-}\n-\n-pub fn mt_to_str_wrapped(cx: &ctxt, before: &str, m: &mt, after: &str) -> ~str {\n-    let mstr = mutability_to_str(m.mutbl);\n-    return format!(\"{}{}{}{}\", mstr, before, ty_to_str(cx, m.ty), after);\n-}\n-\n-pub fn vstore_to_str(cx: &ctxt, vs: ty::Vstore) -> ~str {\n-    match vs {\n-        ty::VstoreFixed(n) => format!(\"{}\", n),\n-        ty::VstoreUniq => ~\"~\",\n-        ty::VstoreSlice(r) => region_ptr_to_str(cx, r)\n-    }\n+    format!(\"{}{}\", mutability_to_str(m.mutbl), ty_to_str(cx, m.ty))\n }\n \n pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n         ty::UniqTraitStore => ~\"~\",\n-        ty::RegionTraitStore(r) => region_ptr_to_str(cx, r)\n-    }\n-}\n-\n-pub fn vstore_ty_to_str(cx: &ctxt, mt: &mt, vs: ty::Vstore) -> ~str {\n-    match vs {\n-        ty::VstoreFixed(_) => {\n-            format!(\"[{}, .. {}]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n-        }\n-        _ => {\n-            format!(\"{}{}\", vstore_to_str(cx, vs), mt_to_str_wrapped(cx, \"[\", mt, \"]\"))\n+        ty::RegionTraitStore(r, m) => {\n+            format!(\"{}{}\", region_ptr_to_str(cx, r), mutability_to_str(m))\n         }\n     }\n }\n@@ -432,20 +410,32 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n                       false)\n       }\n       ty_trait(~ty::TyTrait {\n-          def_id: did, ref substs, store: s, mutability: mutbl, ref bounds\n+          def_id: did, ref substs, store, ref bounds\n       }) => {\n         let base = ty::item_path_str(cx, did);\n         let ty = parameterized(cx, base, &substs.regions,\n                                substs.tps.as_slice(), did, true);\n         let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n         let bound_str = bounds.repr(cx);\n-        format!(\"{}{}{}{}{}\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n-                           bound_sep, bound_str)\n+        format!(\"{}{}{}{}\", trait_store_to_str(cx, store), ty, bound_sep, bound_str)\n+      }\n+      ty_vec(ty, vs) => {\n+        match vs {\n+            ty::VstoreFixed(n) => {\n+                format!(\"[{}, .. {}]\", ty_to_str(cx, ty), n)\n+            }\n+            _ => {\n+                format!(\"{}[{}]\", vs.repr(cx), ty_to_str(cx, ty))\n+            }\n+        }\n       }\n-      ty_vec(ref mt, vs) => {\n-        vstore_ty_to_str(cx, mt, vs)\n+      ty_str(vs) => {\n+        match vs {\n+            ty::VstoreFixed(n) => format!(\"str/{}\", n),\n+            ty::VstoreUniq => ~\"~str\",\n+            ty::VstoreSlice(r, ()) => format!(\"{}str\", region_ptr_to_str(cx, r))\n+        }\n       }\n-      ty_str(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\")\n     }\n }\n \n@@ -878,16 +868,29 @@ impl Repr for ty::RegionVid {\n \n impl Repr for ty::TraitStore {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n-        match self {\n-            &ty::UniqTraitStore => ~\"~Trait\",\n-            &ty::RegionTraitStore(r) => format!(\"&{} Trait\", r.repr(tcx))\n-        }\n+        trait_store_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::Vstore {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n-        vstore_to_str(tcx, *self)\n+        match *self {\n+            ty::VstoreFixed(n) => format!(\"{}\", n),\n+            ty::VstoreUniq => ~\"~\",\n+            ty::VstoreSlice(r, m) => {\n+                format!(\"{}{}\", region_ptr_to_str(tcx, r), mutability_to_str(m))\n+            }\n+        }\n+    }\n+}\n+\n+impl Repr for ty::Vstore<()> {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n+        match *self {\n+            ty::VstoreFixed(n) => format!(\"{}\", n),\n+            ty::VstoreUniq => ~\"~\",\n+            ty::VstoreSlice(r, ()) => region_ptr_to_str(tcx, r)\n+        }\n     }\n }\n "}]}