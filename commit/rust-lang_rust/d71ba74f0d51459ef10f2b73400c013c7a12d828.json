{"sha": "d71ba74f0d51459ef10f2b73400c013c7a12d828", "node_id": "C_kwDOAAsO6NoAKGQ3MWJhNzRmMGQ1MTQ1OWVmMTBmMmI3MzQwMGMwMTNjN2ExMmQ4Mjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-11T12:07:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-11T12:07:53Z"}, "message": "Auto merge of #88798 - sunfishcode:sunfishcode/windows-null-handles, r=joshtriplett\n\nFix assertion failures in `OwnedHandle` with `windows_subsystem`.\n\nAs discussed in #88576, raw handle values in Windows can be null, such\nas in `windows_subsystem` mode, or when consoles are detached from a\nprocess. So, don't use `NonNull` to hold them, don't assert that they're\nnot null, and remove `OwnedHandle`'s `repr(transparent)`. Introduce a\nnew `HandleOrNull` type, similar to `HandleOrInvalid`, to cover the FFI\nuse case.\n\nr? `@joshtriplett`", "tree": {"sha": "b61b563d6d33e3526d920dccfbbac384a7a5fa4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b61b563d6d33e3526d920dccfbbac384a7a5fa4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d71ba74f0d51459ef10f2b73400c013c7a12d828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d71ba74f0d51459ef10f2b73400c013c7a12d828", "html_url": "https://github.com/rust-lang/rust/commit/d71ba74f0d51459ef10f2b73400c013c7a12d828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d71ba74f0d51459ef10f2b73400c013c7a12d828/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62efba8a050c64249dab942951bb28f710208bc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/62efba8a050c64249dab942951bb28f710208bc8", "html_url": "https://github.com/rust-lang/rust/commit/62efba8a050c64249dab942951bb28f710208bc8"}, {"sha": "5d79870aec85d2a2e15b9cac808cae21b5bcbce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d79870aec85d2a2e15b9cac808cae21b5bcbce9", "html_url": "https://github.com/rust-lang/rust/commit/5d79870aec85d2a2e15b9cac808cae21b5bcbce9"}], "stats": {"total": 135, "additions": 85, "deletions": 50}, "files": [{"sha": "1527f5b6b07e0d05afc2b78fe6b4784b59644889", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 85, "deletions": 50, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/d71ba74f0d51459ef10f2b73400c013c7a12d828/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d71ba74f0d51459ef10f2b73400c013c7a12d828/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=d71ba74f0d51459ef10f2b73400c013c7a12d828", "patch": "@@ -4,12 +4,10 @@\n \n use super::raw::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n use crate::convert::TryFrom;\n-use crate::ffi::c_void;\n use crate::fmt;\n use crate::fs;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n-use crate::ptr::NonNull;\n use crate::sys::c;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n@@ -20,32 +18,32 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n ///\n /// This uses `repr(transparent)` and has the representation of a host handle,\n /// so it can be used in FFI in places where a handle is passed as an argument,\n-/// it is not captured or consumed, and it is never null.\n+/// it is not captured or consumed.\n ///\n /// Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is\n /// sometimes a valid handle value. See [here] for the full story.\n ///\n+/// And, it *may* have the value `NULL` (0), which can occur when consoles are\n+/// detached from processes, or when `windows_subsystem` is used.\n+///\n /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n #[derive(Copy, Clone)]\n #[repr(transparent)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct BorrowedHandle<'handle> {\n-    handle: NonNull<c_void>,\n+    handle: RawHandle,\n     _phantom: PhantomData<&'handle OwnedHandle>,\n }\n \n /// An owned handle.\n ///\n /// This closes the handle on drop.\n ///\n-/// This uses `repr(transparent)` and has the representation of a host handle,\n-/// so it can be used in FFI in places where a handle is passed as a consumed\n-/// argument or returned as an owned value, and is never null.\n-///\n /// Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is\n-/// sometimes a valid handle value. See [here] for the full story. For APIs\n-/// like `CreateFileW` which report errors with `INVALID_HANDLE_VALUE` instead\n-/// of null, use [`HandleOrInvalid`] instead of `Option<OwnedHandle>`.\n+/// sometimes a valid handle value. See [here] for the full story.\n+///\n+/// And, it *may* have the value `NULL` (0), which can occur when consoles are\n+/// detached from processes, or when `windows_subsystem` is used.\n ///\n /// `OwnedHandle` uses [`CloseHandle`] to close its handle on drop. As such,\n /// it must not be used with handles to open registry keys which need to be\n@@ -55,12 +53,31 @@ pub struct BorrowedHandle<'handle> {\n /// [`RegCloseKey`]: https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey\n ///\n /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n-#[repr(transparent)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct OwnedHandle {\n-    handle: NonNull<c_void>,\n+    handle: RawHandle,\n }\n \n+/// FFI type for handles in return values or out parameters, where `NULL` is used\n+/// as a sentry value to indicate errors, such as in the return value of `CreateThread`. This uses\n+/// `repr(transparent)` and has the representation of a host handle, so that it can be used in such\n+/// FFI declarations.\n+///\n+/// The only thing you can usefully do with a `HandleOrNull` is to convert it into an\n+/// `OwnedHandle` using its [`TryFrom`] implementation; this conversion takes care of the check for\n+/// `NULL`. This ensures that such FFI calls cannot start using the handle without\n+/// checking for `NULL` first.\n+///\n+/// This type concerns any value other than `NULL` to be valid, including `INVALID_HANDLE_VALUE`.\n+/// This is because APIs that use `NULL` as their sentry value don't treat `INVALID_HANDLE_VALUE`\n+/// as special.\n+///\n+/// If this holds a valid handle, it will close the handle on drop.\n+#[repr(transparent)]\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+#[derive(Debug)]\n+pub struct HandleOrNull(OwnedHandle);\n+\n /// FFI type for handles in return values or out parameters, where `INVALID_HANDLE_VALUE` is used\n /// as a sentry value to indicate errors, such as in the return value of `CreateFileW`. This uses\n /// `repr(transparent)` and has the representation of a host handle, so that it can be used in such\n@@ -71,21 +88,27 @@ pub struct OwnedHandle {\n /// `INVALID_HANDLE_VALUE`. This ensures that such FFI calls cannot start using the handle without\n /// checking for `INVALID_HANDLE_VALUE` first.\n ///\n+/// This type concerns any value other than `INVALID_HANDLE_VALUE` to be valid, including `NULL`.\n+/// This is because APIs that use `INVALID_HANDLE_VALUE` as their sentry value may return `NULL`\n+/// under `windows_subsystem = \"windows\"` or other situations where I/O devices are detached.\n+///\n /// If this holds a valid handle, it will close the handle on drop.\n #[repr(transparent)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n #[derive(Debug)]\n-pub struct HandleOrInvalid(Option<OwnedHandle>);\n+pub struct HandleOrInvalid(OwnedHandle);\n \n // The Windows [`HANDLE`] type may be transferred across and shared between\n // thread boundaries (despite containing a `*mut void`, which in general isn't\n // `Send` or `Sync`).\n //\n // [`HANDLE`]: std::os::windows::raw::HANDLE\n unsafe impl Send for OwnedHandle {}\n+unsafe impl Send for HandleOrNull {}\n unsafe impl Send for HandleOrInvalid {}\n unsafe impl Send for BorrowedHandle<'_> {}\n unsafe impl Sync for OwnedHandle {}\n+unsafe impl Sync for HandleOrNull {}\n unsafe impl Sync for HandleOrInvalid {}\n unsafe impl Sync for BorrowedHandle<'_> {}\n \n@@ -95,18 +118,29 @@ impl BorrowedHandle<'_> {\n     /// # Safety\n     ///\n     /// The resource pointed to by `handle` must be a valid open handle, it\n-    /// must remain open for the duration of the returned `BorrowedHandle`, and\n-    /// it must not be null.\n+    /// must remain open for the duration of the returned `BorrowedHandle`.\n     ///\n     /// Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is\n     /// sometimes a valid handle value. See [here] for the full story.\n     ///\n+    /// And, it *may* have the value `NULL` (0), which can occur when consoles are\n+    /// detached from processes, or when `windows_subsystem` is used.\n+    ///\n     /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[inline]\n     #[unstable(feature = \"io_safety\", issue = \"87074\")]\n     pub unsafe fn borrow_raw_handle(handle: RawHandle) -> Self {\n-        assert!(!handle.is_null());\n-        Self { handle: NonNull::new_unchecked(handle), _phantom: PhantomData }\n+        Self { handle, _phantom: PhantomData }\n+    }\n+}\n+\n+impl TryFrom<HandleOrNull> for OwnedHandle {\n+    type Error = ();\n+\n+    #[inline]\n+    fn try_from(handle_or_null: HandleOrNull) -> Result<Self, ()> {\n+        let owned_handle = handle_or_null.0;\n+        if owned_handle.handle.is_null() { Err(()) } else { Ok(owned_handle) }\n     }\n }\n \n@@ -115,44 +149,29 @@ impl TryFrom<HandleOrInvalid> for OwnedHandle {\n \n     #[inline]\n     fn try_from(handle_or_invalid: HandleOrInvalid) -> Result<Self, ()> {\n-        // In theory, we ought to be able to assume that the pointer here is\n-        // never null, use `OwnedHandle` rather than `Option<OwnedHandle>`, and\n-        // obviate the the panic path here.  Unfortunately, Win32 documentation\n-        // doesn't explicitly guarantee this anywhere.\n-        //\n-        // APIs like [`CreateFileW`] itself have `HANDLE` arguments where a\n-        // null handle indicates an absent value, which wouldn't work if null\n-        // were a valid handle value, so it seems very unlikely that it could\n-        // ever return null. But who knows?\n-        //\n-        // [`CreateFileW`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew\n-        let owned_handle = handle_or_invalid.0.expect(\"A `HandleOrInvalid` was null!\");\n-        if owned_handle.handle.as_ptr() == c::INVALID_HANDLE_VALUE {\n-            Err(())\n-        } else {\n-            Ok(owned_handle)\n-        }\n+        let owned_handle = handle_or_invalid.0;\n+        if owned_handle.handle == c::INVALID_HANDLE_VALUE { Err(()) } else { Ok(owned_handle) }\n     }\n }\n \n impl AsRawHandle for BorrowedHandle<'_> {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.handle.as_ptr()\n+        self.handle\n     }\n }\n \n impl AsRawHandle for OwnedHandle {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.handle.as_ptr()\n+        self.handle\n     }\n }\n \n impl IntoRawHandle for OwnedHandle {\n     #[inline]\n     fn into_raw_handle(self) -> RawHandle {\n-        let handle = self.handle.as_ptr();\n+        let handle = self.handle;\n         forget(self);\n         handle\n     }\n@@ -161,9 +180,6 @@ impl IntoRawHandle for OwnedHandle {\n impl FromRawHandle for OwnedHandle {\n     /// Constructs a new instance of `Self` from the given raw handle.\n     ///\n-    /// Use `HandleOrInvalid` instead of `Option<OwnedHandle>` for APIs that\n-    /// use `INVALID_HANDLE_VALUE` to indicate failure.\n-    ///\n     /// # Safety\n     ///\n     /// The resource pointed to by `handle` must be open and suitable for\n@@ -180,8 +196,28 @@ impl FromRawHandle for OwnedHandle {\n     /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[inline]\n     unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n-        assert!(!handle.is_null());\n-        Self { handle: NonNull::new_unchecked(handle) }\n+        Self { handle }\n+    }\n+}\n+\n+impl FromRawHandle for HandleOrNull {\n+    /// Constructs a new instance of `Self` from the given `RawHandle` returned\n+    /// from a Windows API that uses null to indicate failure, such as\n+    /// `CreateThread`.\n+    ///\n+    /// Use `HandleOrInvalid` instead of `HandleOrNull` for APIs that\n+    /// use `INVALID_HANDLE_VALUE` to indicate failure.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `handle` must be either open and otherwise\n+    /// unowned, or null. Note that not all Windows APIs use null for errors;\n+    /// see [here] for the full story.\n+    ///\n+    /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n+    #[inline]\n+    unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n+        Self(OwnedHandle::from_raw_handle(handle))\n     }\n }\n \n@@ -190,29 +226,28 @@ impl FromRawHandle for HandleOrInvalid {\n     /// from a Windows API that uses `INVALID_HANDLE_VALUE` to indicate\n     /// failure, such as `CreateFileW`.\n     ///\n-    /// Use `Option<OwnedHandle>` instead of `HandleOrInvalid` for APIs that\n+    /// Use `HandleOrNull` instead of `HandleOrInvalid` for APIs that\n     /// use null to indicate failure.\n     ///\n     /// # Safety\n     ///\n     /// The resource pointed to by `handle` must be either open and otherwise\n-    /// unowned, or equal to `INVALID_HANDLE_VALUE` (-1). It must not be null.\n-    /// Note that not all Windows APIs use `INVALID_HANDLE_VALUE` for errors;\n-    /// see [here] for the full story.\n+    /// unowned, null, or equal to `INVALID_HANDLE_VALUE` (-1). Note that not\n+    /// all Windows APIs use `INVALID_HANDLE_VALUE` for errors; see [here] for\n+    /// the full story.\n     ///\n     /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[inline]\n     unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n-        // We require non-null here to catch errors earlier.\n-        Self(Some(OwnedHandle::from_raw_handle(handle)))\n+        Self(OwnedHandle::from_raw_handle(handle))\n     }\n }\n \n impl Drop for OwnedHandle {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            let _ = c::CloseHandle(self.handle.as_ptr());\n+            let _ = c::CloseHandle(self.handle);\n         }\n     }\n }"}]}