{"sha": "dd9f31d000a33c52383f9af9e1dbf44f754590c3", "node_id": "C_kwDOAAsO6NoAKGRkOWYzMWQwMDBhMzNjNTIzODNmOWFmOWUxZGJmNDRmNzU0NTkwYzM", "commit": {"author": {"name": "5225225", "email": "5225225@mailbox.org", "date": "2022-05-23T15:44:05Z"}, "committer": {"name": "5225225", "email": "5225225@mailbox.org", "date": "2022-05-24T13:26:52Z"}, "message": "Add flag for stricter checks on uninit/zeroed", "tree": {"sha": "f97b95ae7cddfa1997909d3cef9c41b5f7d05512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f97b95ae7cddfa1997909d3cef9c41b5f7d05512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd9f31d000a33c52383f9af9e1dbf44f754590c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9f31d000a33c52383f9af9e1dbf44f754590c3", "html_url": "https://github.com/rust-lang/rust/commit/dd9f31d000a33c52383f9af9e1dbf44f754590c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd9f31d000a33c52383f9af9e1dbf44f754590c3/comments", "author": {"login": "5225225", "id": 8584210, "node_id": "MDQ6VXNlcjg1ODQyMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/8584210?v=4", "gravatar_id": "", "url": "https://api.github.com/users/5225225", "html_url": "https://github.com/5225225", "followers_url": "https://api.github.com/users/5225225/followers", "following_url": "https://api.github.com/users/5225225/following{/other_user}", "gists_url": "https://api.github.com/users/5225225/gists{/gist_id}", "starred_url": "https://api.github.com/users/5225225/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/5225225/subscriptions", "organizations_url": "https://api.github.com/users/5225225/orgs", "repos_url": "https://api.github.com/users/5225225/repos", "events_url": "https://api.github.com/users/5225225/events{/privacy}", "received_events_url": "https://api.github.com/users/5225225/received_events", "type": "User", "site_admin": false}, "committer": {"login": "5225225", "id": 8584210, "node_id": "MDQ6VXNlcjg1ODQyMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/8584210?v=4", "gravatar_id": "", "url": "https://api.github.com/users/5225225", "html_url": "https://github.com/5225225", "followers_url": "https://api.github.com/users/5225225/followers", "following_url": "https://api.github.com/users/5225225/following{/other_user}", "gists_url": "https://api.github.com/users/5225225/gists{/gist_id}", "starred_url": "https://api.github.com/users/5225225/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/5225225/subscriptions", "organizations_url": "https://api.github.com/users/5225225/orgs", "repos_url": "https://api.github.com/users/5225225/repos", "events_url": "https://api.github.com/users/5225225/events{/privacy}", "received_events_url": "https://api.github.com/users/5225225/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43d9f3859e0204e764161ee085a360274b5f3e9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/43d9f3859e0204e764161ee085a360274b5f3e9a", "html_url": "https://github.com/rust-lang/rust/commit/43d9f3859e0204e764161ee085a360274b5f3e9a"}], "stats": {"total": 142, "additions": 116, "deletions": 26}, "files": [{"sha": "6937e658ed5ee8a8abe7e5909637fe6611251905", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=dd9f31d000a33c52383f9af9e1dbf44f754590c3", "patch": "@@ -58,6 +58,7 @@ pub(crate) use llvm::codegen_llvm_intrinsic_call;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_target::abi::InitKind;\n \n use crate::prelude::*;\n use cranelift_codegen::ir::AtomicRmwOp;\n@@ -671,7 +672,12 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true) {\n+            if intrinsic == sym::assert_zero_valid\n+                && !layout.might_permit_raw_init(\n+                    fx,\n+                    InitKind::Zero,\n+                    fx.tcx.sess.opts.debugging_opts.strict_init_checks) {\n+\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,\n@@ -682,7 +688,12 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false) {\n+            if intrinsic == sym::assert_uninit_valid\n+                && !layout.might_permit_raw_init(\n+                    fx,\n+                    InitKind::Uninit,\n+                    fx.tcx.sess.opts.debugging_opts.strict_init_checks) {\n+\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,"}, {"sha": "03ef6d50d44cdf84343b067fe659f0759586552a", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=dd9f31d000a33c52383f9af9e1dbf44f754590c3", "patch": "@@ -22,7 +22,7 @@ use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_symbol_mangling::typeid_for_fnabi;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n-use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n+use rustc_target::abi::{self, HasDataLayout, InitKind, WrappingRange};\n use rustc_target::spec::abi::Abi;\n \n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n@@ -521,6 +521,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         source_info: mir::SourceInfo,\n         target: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n+        strict_validity: bool,\n     ) -> bool {\n         // Emit a panic or a no-op for `assert_*` intrinsics.\n         // These are intrinsics that compile to panics so that we can get a message\n@@ -543,8 +544,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let layout = bx.layout_of(ty);\n             let do_panic = match intrinsic {\n                 Inhabited => layout.abi.is_uninhabited(),\n-                ZeroValid => !layout.might_permit_raw_init(bx, /*zero:*/ true),\n-                UninitValid => !layout.might_permit_raw_init(bx, /*zero:*/ false),\n+                ZeroValid => !layout.might_permit_raw_init(bx, InitKind::Zero, strict_validity),\n+                UninitValid => !layout.might_permit_raw_init(bx, InitKind::Uninit, strict_validity),\n             };\n             if do_panic {\n                 let msg_str = with_no_visible_paths!({\n@@ -678,6 +679,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             source_info,\n             target,\n             cleanup,\n+            self.cx.tcx().sess.opts.debugging_opts.strict_init_checks,\n         ) {\n             return;\n         }"}, {"sha": "bf1cf816ddd0b3385286ab71efdadb03cc73bdd0", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=dd9f31d000a33c52383f9af9e1dbf44f754590c3", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::layout::LayoutOf as _;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, Align, Primitive, Size};\n+use rustc_target::abi::{Abi, Align, InitKind, Primitive, Size};\n \n use super::{\n     util::ensure_monomorphic_enough, CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy,\n@@ -408,7 +408,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     )?;\n                 }\n                 if intrinsic_name == sym::assert_zero_valid\n-                    && !layout.might_permit_raw_init(self, /*zero:*/ true)\n+                    && !layout.might_permit_raw_init(\n+                        self,\n+                        InitKind::Zero,\n+                        self.tcx.sess.opts.debugging_opts.strict_init_checks,\n+                    )\n                 {\n                     M::abort(\n                         self,\n@@ -419,7 +423,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     )?;\n                 }\n                 if intrinsic_name == sym::assert_uninit_valid\n-                    && !layout.might_permit_raw_init(self, /*zero:*/ false)\n+                    && !layout.might_permit_raw_init(\n+                        self,\n+                        InitKind::Uninit,\n+                        self.tcx.sess.opts.debugging_opts.strict_init_checks,\n+                    )\n                 {\n                     M::abort(\n                         self,"}, {"sha": "66198dff2ae3df518f64c290f6a16e368905035f", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=dd9f31d000a33c52383f9af9e1dbf44f754590c3", "patch": "@@ -1495,6 +1495,8 @@ options! {\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n     stack_protector: StackProtector = (StackProtector::None, parse_stack_protector, [TRACKED],\n         \"control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\"),\n+    strict_init_checks: bool = (false, parse_bool, [TRACKED],\n+        \"control if mem::uninitialized and mem::zeroed panic on more UB\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n     split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [UNTRACKED],"}, {"sha": "a771369c80789448c90f8c7cc726fd2721528382", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9f31d000a33c52383f9af9e1dbf44f754590c3/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=dd9f31d000a33c52383f9af9e1dbf44f754590c3", "patch": "@@ -894,6 +894,15 @@ impl Scalar {\n             Scalar::Union { .. } => true,\n         }\n     }\n+\n+    /// Returns `true` if this type can be left uninit.\n+    #[inline]\n+    pub fn is_uninit_valid(&self) -> bool {\n+        match *self {\n+            Scalar::Initialized { .. } => false,\n+            Scalar::Union { .. } => true,\n+        }\n+    }\n }\n \n /// Describes how the fields of a type are located in memory.\n@@ -1355,6 +1364,14 @@ pub struct PointeeInfo {\n     pub address_space: AddressSpace,\n }\n \n+/// Used in `might_permit_raw_init` to indicate the kind of initialisation\n+/// that is checked to be valid\n+#[derive(Copy, Clone, Debug)]\n+pub enum InitKind {\n+    Zero,\n+    Uninit,\n+}\n+\n /// Trait that needs to be implemented by the higher-level type representation\n /// (e.g. `rustc_middle::ty::Ty`), to provide `rustc_target::abi` functionality.\n pub trait TyAbiInterface<'a, C>: Sized {\n@@ -1461,26 +1478,37 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n \n     /// Determines if this type permits \"raw\" initialization by just transmuting some\n     /// memory into an instance of `T`.\n-    /// `zero` indicates if the memory is zero-initialized, or alternatively\n-    /// left entirely uninitialized.\n+    ///\n+    /// `init_kind` indicates if the memory is zero-initialized or left uninitialized.\n+    ///\n+    /// `strict` is an opt-in debugging flag added in #97323 that enables more checks.\n+    ///\n     /// This is conservative: in doubt, it will answer `true`.\n     ///\n     /// FIXME: Once we removed all the conservatism, we could alternatively\n     /// create an all-0/all-undef constant and run the const value validator to see if\n     /// this is a valid value for the given type.\n-    pub fn might_permit_raw_init<C>(self, cx: &C, zero: bool) -> bool\n+    pub fn might_permit_raw_init<C>(self, cx: &C, init_kind: InitKind, strict: bool) -> bool\n     where\n         Self: Copy,\n         Ty: TyAbiInterface<'a, C>,\n         C: HasDataLayout,\n     {\n         let scalar_allows_raw_init = move |s: Scalar| -> bool {\n-            if zero {\n-                // The range must contain 0.\n-                s.valid_range(cx).contains(0)\n-            } else {\n-                // The range must include all values.\n-                s.is_always_valid(cx)\n+            match init_kind {\n+                InitKind::Zero => {\n+                    // The range must contain 0.\n+                    s.valid_range(cx).contains(0)\n+                }\n+                InitKind::Uninit => {\n+                    if strict {\n+                        // The type must be allowed to be uninit (which means \"is a union\").\n+                        s.is_uninit_valid()\n+                    } else {\n+                        // The range must include all values.\n+                        s.is_always_valid(cx)\n+                    }\n+                }\n             }\n         };\n \n@@ -1500,12 +1528,19 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         // If we have not found an error yet, we need to recursively descend into fields.\n         match &self.fields {\n             FieldsShape::Primitive | FieldsShape::Union { .. } => {}\n-            FieldsShape::Array { .. } => {\n-                // FIXME(#66151): For now, we are conservative and do not check arrays.\n+            FieldsShape::Array { count, .. } => {\n+                // FIXME(#66151): For now, we are conservative and do not check arrays by default.\n+                if strict\n+                    && *count > 0\n+                    && !self.field(cx, 0).might_permit_raw_init(cx, init_kind, strict)\n+                {\n+                    // Found non empty array with a type that is unhappy about this kind of initialization\n+                    return false;\n+                }\n             }\n             FieldsShape::Arbitrary { offsets, .. } => {\n                 for idx in 0..offsets.len() {\n-                    if !self.field(cx, idx).might_permit_raw_init(cx, zero) {\n+                    if !self.field(cx, idx).might_permit_raw_init(cx, init_kind, strict) {\n                         // We found a field that is unhappy with this kind of initialization.\n                         return false;\n                     }"}, {"sha": "3ffd35ecdb8da7b8543b82313ecd61ed5bc24455", "filename": "src/test/ui/intrinsics/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dd9f31d000a33c52383f9af9e1dbf44f754590c3/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9f31d000a33c52383f9af9e1dbf44f754590c3/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs?ref=dd9f31d000a33c52383f9af9e1dbf44f754590c3", "patch": "@@ -1,8 +1,9 @@\n // run-pass\n // needs-unwind\n // ignore-wasm32-bare compiled with panic=abort by default\n-// revisions: mir thir\n+// revisions: mir thir strict\n // [thir]compile-flags: -Zthir-unsafeck\n+// [strict]compile-flags: -Zstrict-init-checks\n // ignore-tidy-linelength\n \n // This test checks panic emitted from `mem::{uninitialized,zeroed}`.\n@@ -54,6 +55,8 @@ enum LR_NonZero {\n     Right(num::NonZeroI64),\n }\n \n+struct ZeroSized;\n+\n fn test_panic_msg<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n     let err = panic::catch_unwind(op).err();\n     assert_eq!(\n@@ -228,11 +231,40 @@ fn main() {\n         let _val = mem::zeroed::<[!; 0]>();\n         let _val = mem::uninitialized::<MaybeUninit<bool>>();\n         let _val = mem::uninitialized::<[!; 0]>();\n+        let _val = mem::uninitialized::<()>();\n+        let _val = mem::uninitialized::<ZeroSized>();\n+\n+        if cfg!(strict) {\n+            test_panic_msg(\n+                || mem::uninitialized::<i32>(),\n+                \"attempted to leave type `i32` uninitialized, which is invalid\"\n+            );\n+\n+            test_panic_msg(\n+                || mem::uninitialized::<*const ()>(),\n+                \"attempted to leave type `*const ()` uninitialized, which is invalid\"\n+            );\n+\n+            test_panic_msg(\n+                || mem::uninitialized::<[i32; 1]>(),\n+                \"attempted to leave type `[i32; 1]` uninitialized, which is invalid\"\n+            );\n+\n+            test_panic_msg(\n+                || mem::zeroed::<NonNull<()>>(),\n+                \"attempted to zero-initialize type `core::ptr::non_null::NonNull<()>`, which is invalid\"\n+            );\n \n-        // These are UB because they have not been officially blessed, but we await the resolution\n-        // of <https://github.com/rust-lang/unsafe-code-guidelines/issues/71> before doing\n-        // anything about that.\n-        let _val = mem::uninitialized::<i32>();\n-        let _val = mem::uninitialized::<*const ()>();\n+            test_panic_msg(\n+                || mem::zeroed::<[NonNull<()>; 1]>(),\n+                \"attempted to zero-initialize type `[core::ptr::non_null::NonNull<()>; 1]`, which is invalid\"\n+            );\n+        } else {\n+            // These are UB because they have not been officially blessed, but we await the resolution\n+            // of <https://github.com/rust-lang/unsafe-code-guidelines/issues/71> before doing\n+            // anything about that.\n+            let _val = mem::uninitialized::<i32>();\n+            let _val = mem::uninitialized::<*const ()>();\n+        }\n     }\n }"}]}