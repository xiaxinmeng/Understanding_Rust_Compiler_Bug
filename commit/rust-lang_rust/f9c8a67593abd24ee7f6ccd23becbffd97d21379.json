{"sha": "f9c8a67593abd24ee7f6ccd23becbffd97d21379", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YzhhNjc1OTNhYmQyNGVlN2Y2Y2NkMjNiZWNiZmZkOTdkMjEzNzk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-15T10:01:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-15T10:01:01Z"}, "message": "Rollup merge of #72879 - RalfJung:miri-tctx-at, r=oli-obk\n\nMiri: avoid tracking current location three times\n\nMiri tracks the current instruction to execute in the call stack, but it also additionally has two `TyCtxtAt` that carry a `Span` that also tracks the current instruction. That is quite silly, so this PR uses `TyCtxt` instead, and then uses a method for computing the current span when a `TyCtxtAt` is needed. Having less redundant (semi-)global state seems like a good improvement to me. :D\n\nTo keep the ConstProp errors the same, I had to add the option to `error_to_const_error` to overwrite the span. Also for some reason this changes cycle errors a bit -- not sure if we are now better or worse as giving those queries the right span. (It is unfortunately quite easy to accidentally use `DUMMY_SP` by calling the query on a `TyCtxt` instead of a `TyCtxtAt`.)\n\nr? @oli-obk @eddyb", "tree": {"sha": "991e8fa98b1c948cb6219028c68b0fabda05c95b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/991e8fa98b1c948cb6219028c68b0fabda05c95b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9c8a67593abd24ee7f6ccd23becbffd97d21379", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe50bdCRBK7hj4Ov3rIwAAdHIIAIqDQ5Jd8Q87kU7w+ylPjxm+\nSN6Q8K3quArbJEaAogaHrG1hCCXfDBISBMtqRU+k4kFExCxQsY1WEstNnV3QSwAq\nt5OS/wxOVgteNUQUjfFZqI89uXLCDBafUy9xi/yA1UEPT703qZL+l1KyV2643uZ8\nIQjJJ7JZeIREvWp4qHdN3R1MsBP5DSYf78pKTTYdivmNm0uN1ru+YYAR1vmi5gGV\nP7S+0ioG/3d/OiCj7QbyGlFN5km9vLSzTDCCwWbAWnJWSdgrqy56RFIoNKJbYjWZ\nSdQX7+65momGGSsNxr4Z/rdPIyPqYUAhE9Bw/BdsFe4bf49gyRCWcn9ZPJDm8O0=\n=B/GK\n-----END PGP SIGNATURE-----\n", "payload": "tree 991e8fa98b1c948cb6219028c68b0fabda05c95b\nparent d97e8ca33524399620aef1c0053f8b593bfbf521\nparent 2210abea71270867fe2c69782f282c654e106fac\nauthor Ralf Jung <post@ralfj.de> 1592215261 +0200\ncommitter GitHub <noreply@github.com> 1592215261 +0200\n\nRollup merge of #72879 - RalfJung:miri-tctx-at, r=oli-obk\n\nMiri: avoid tracking current location three times\n\nMiri tracks the current instruction to execute in the call stack, but it also additionally has two `TyCtxtAt` that carry a `Span` that also tracks the current instruction. That is quite silly, so this PR uses `TyCtxt` instead, and then uses a method for computing the current span when a `TyCtxtAt` is needed. Having less redundant (semi-)global state seems like a good improvement to me. :D\n\nTo keep the ConstProp errors the same, I had to add the option to `error_to_const_error` to overwrite the span. Also for some reason this changes cycle errors a bit -- not sure if we are now better or worse as giving those queries the right span. (It is unfortunately quite easy to accidentally use `DUMMY_SP` by calling the query on a `TyCtxt` instead of a `TyCtxtAt`.)\n\nr? @oli-obk @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c8a67593abd24ee7f6ccd23becbffd97d21379", "html_url": "https://github.com/rust-lang/rust/commit/f9c8a67593abd24ee7f6ccd23becbffd97d21379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9c8a67593abd24ee7f6ccd23becbffd97d21379/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d97e8ca33524399620aef1c0053f8b593bfbf521", "url": "https://api.github.com/repos/rust-lang/rust/commits/d97e8ca33524399620aef1c0053f8b593bfbf521", "html_url": "https://github.com/rust-lang/rust/commit/d97e8ca33524399620aef1c0053f8b593bfbf521"}, {"sha": "2210abea71270867fe2c69782f282c654e106fac", "url": "https://api.github.com/repos/rust-lang/rust/commits/2210abea71270867fe2c69782f282c654e106fac", "html_url": "https://github.com/rust-lang/rust/commit/2210abea71270867fe2c69782f282c654e106fac"}], "stats": {"total": 264, "additions": 141, "deletions": 123}, "files": [{"sha": "ff284b709c2cfeee5c3170353719f1e9962c26b5", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -705,6 +705,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n+    // FIXME: use `TyCtxtAt` instead of separate `Span`.\n     pub fn is_freeze(\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "5deae94fe0c8e785086b005f72b626051e1e9d43", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n \n use rustc_middle::mir::AssertKind;\n-use rustc_span::Symbol;\n+use rustc_span::{Span, Symbol};\n \n use super::InterpCx;\n use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n@@ -53,8 +53,9 @@ impl Error for ConstEvalErrKind {}\n pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n     ecx: &InterpCx<'mir, 'tcx, M>,\n     error: InterpErrorInfo<'tcx>,\n+    span: Option<Span>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n     let stacktrace = ecx.generate_stacktrace();\n-    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n+    ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n }"}, {"sha": "d62300b3f55414b198bfce5da10eede285c61366", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -27,7 +27,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     body: &'mir mir::Body<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n-    let tcx = ecx.tcx.tcx;\n+    let tcx = *ecx.tcx;\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n@@ -81,13 +81,14 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n pub(super) fn mk_eval_cx<'mir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    span: Span,\n+    root_span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n     can_access_statics: bool,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n     InterpCx::new(\n-        tcx.at(span),\n+        tcx,\n+        root_span,\n         param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics },\n@@ -163,7 +164,7 @@ pub(super) fn op_to_const<'tcx>(\n                         0,\n                     ),\n                 };\n-                let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+                let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();\n                 ConstValue::Slice { data, start, end: start + len }\n@@ -212,7 +213,7 @@ fn validate_and_turn_into_const<'tcx>(\n     })();\n \n     val.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error);\n+        let err = error_to_const_error(&ecx, error, None);\n         err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n@@ -299,9 +300,9 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let is_static = tcx.is_static(def_id);\n \n-    let span = tcx.def_span(cid.instance.def_id());\n     let mut ecx = InterpCx::new(\n-        tcx.at(span),\n+        tcx,\n+        tcx.def_span(cid.instance.def_id()),\n         key.param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics: is_static },\n@@ -311,12 +312,15 @@ pub fn const_eval_raw_provider<'tcx>(\n     res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n         .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         .map_err(|error| {\n-            let err = error_to_const_error(&ecx, error);\n+            let err = error_to_const_error(&ecx, error, None);\n             // errors in statics are always emitted as fatal errors\n             if is_static {\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`\n                 // an error must be reported.\n-                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+                let v = err.report_as_error(\n+                    ecx.tcx.at(ecx.cur_span()),\n+                    \"could not evaluate static initializer\",\n+                );\n \n                 // If this is `Reveal:All`, then we need to make sure an error is reported but if\n                 // this is `Reveal::UserFacing`, then it's expected that we could get a\n@@ -372,13 +376,16 @@ pub fn const_eval_raw_provider<'tcx>(\n                         // anything else (array lengths, enum initializers, constant patterns) are\n                         // reported as hard errors\n                         } else {\n-                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n+                            err.report_as_error(\n+                                ecx.tcx.at(ecx.cur_span()),\n+                                \"evaluation of constant value failed\",\n+                            )\n                         }\n                     }\n                 }\n             } else {\n                 // use of broken constant from other crate\n-                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n+                err.report_as_error(ecx.tcx.at(ecx.cur_span()), \"could not evaluate constant\")\n             }\n         })\n }"}, {"sha": "cfe856abe36dda2ca6c6c073417d1c864c711138", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -268,11 +268,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n                 // u64 cast is from usize to u64, which is always good\n-                let val = Immediate::new_slice(\n-                    ptr,\n-                    length.eval_usize(self.tcx.tcx, self.param_env),\n-                    self,\n-                );\n+                let val =\n+                    Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n             (&ty::Dynamic(..), &ty::Dynamic(..)) => {"}, {"sha": "22f4691c22b3de81226fe406c8fafd6c427c04bd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -33,6 +33,8 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n+    /// The span in this is the \"root\" of the evaluation, i.e., the const\n+    /// we are evaluating (if this is CTFE).\n     pub tcx: TyCtxtAt<'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n@@ -202,7 +204,7 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = InterpResult<'tcx, TyAndLayout<'tcx>>;\n \n@@ -285,24 +287,28 @@ pub(super) fn from_known_layout<'tcx>(\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn new(\n-        tcx: TyCtxtAt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+        root_span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n         memory_extra: M::MemoryExtra,\n     ) -> Self {\n         InterpCx {\n             machine,\n-            tcx,\n+            tcx: tcx.at(root_span),\n             param_env,\n             memory: Memory::new(tcx, memory_extra),\n             vtables: FxHashMap::default(),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn set_span(&mut self, span: Span) {\n-        self.tcx.span = span;\n-        self.memory.tcx.span = span;\n+    pub fn cur_span(&self) -> Span {\n+        self.stack()\n+            .last()\n+            .and_then(|f| f.current_source_info())\n+            .map(|si| si.span)\n+            .unwrap_or(self.tcx.span)\n     }\n \n     #[inline(always)]\n@@ -385,7 +391,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n+        ty.is_freeze(*self.tcx, self.param_env, self.tcx.span)\n     }\n \n     pub fn load_mir(\n@@ -554,7 +560,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let size = size.align_to(align);\n \n                 // Check if this brought us over the size limit.\n-                if size.bytes() >= self.tcx.data_layout().obj_size_bound() {\n+                if size.bytes() >= self.tcx.data_layout.obj_size_bound() {\n                     throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n@@ -570,7 +576,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let elem = layout.field(self, 0)?;\n \n                 // Make sure the slice is not too big.\n-                let size = elem.size.checked_mul(len, &*self.tcx).ok_or_else(|| {\n+                let size = elem.size.checked_mul(len, self).ok_or_else(|| {\n                     err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n                 })?;\n                 Ok(Some((size, elem.align.abi)))"}, {"sha": "3c724c79b4082448860d9fc256c272537a8342e6", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -111,7 +111,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx.tcx, ecx.param_env, ecx.tcx.span));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(*ecx.tcx, ecx.param_env, ecx.tcx.span));\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n@@ -253,8 +253,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                         // caused (by somehow getting a mutable reference in a `const`).\n                         if ref_mutability == Mutability::Mut {\n                             match referenced_ty.kind {\n-                                ty::Array(_, n)\n-                                    if n.eval_usize(tcx.tcx, self.ecx.param_env) == 0 => {}\n+                                ty::Array(_, n) if n.eval_usize(*tcx, self.ecx.param_env) == 0 => {}\n                                 ty::Slice(_)\n                                     if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n                                         == 0 => {}"}, {"sha": "47e5b8b4fcec453a7be7951569878d52c76fa863", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -347,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let elem = args[2];\n                 let input = args[0];\n-                let (len, e_ty) = input.layout.ty.simd_size_and_type(self.tcx.tcx);\n+                let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n                     \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n@@ -374,7 +374,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n-                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx.tcx);\n+                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n                     \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\","}, {"sha": "8af1a8ac608ac8f2a56f4bb61d0c4d455a2a037b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -14,7 +14,7 @@ use std::ptr;\n \n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_middle::ty::{self, query::TyCtxtAt, Instance, ParamEnv};\n+use rustc_middle::ty::{self, Instance, ParamEnv, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n@@ -115,7 +115,7 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub tcx: TyCtxtAt<'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n@@ -126,7 +126,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'tcx>, extra: M::MemoryExtra) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             extra_fn_ptr_map: FxHashMap::default(),\n@@ -425,7 +425,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// `M::tag_allocation`.\n     fn get_global_alloc(\n         memory_extra: &M::MemoryExtra,\n-        tcx: TyCtxtAt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n@@ -455,7 +455,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     throw_unsup!(ReadForeignStatic(def_id))\n                 }\n                 trace!(\"get_global_alloc: Need to compute {:?}\", def_id);\n-                let instance = Instance::mono(tcx.tcx, def_id);\n+                let instance = Instance::mono(tcx, def_id);\n                 let gid = GlobalId { instance, promoted: None };\n                 // Use the raw query here to break validation cycles. Later uses of the static\n                 // will call the full query anyway.\n@@ -664,14 +664,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n         // Cannot be a closure because it is generic in `Tag`, `Extra`.\n         fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n-            tcx: TyCtxtAt<'tcx>,\n+            tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Tag, Extra>,\n         ) {\n             for &(_, target_id) in alloc.relocations().values() {\n                 allocs_to_print.push_back(target_id);\n             }\n-            pretty::write_allocation(tcx.tcx, alloc, &mut std::io::stderr()).unwrap();\n+            pretty::write_allocation(tcx, alloc, &mut std::io::stderr()).unwrap();\n         }\n \n         allocs.sort();\n@@ -820,7 +820,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 return Ok(());\n             }\n         };\n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n         self.get_raw_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n     }\n \n@@ -846,7 +846,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 return Ok(());\n             }\n         };\n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n         let allocation = self.get_raw_mut(ptr.alloc_id)?;\n \n         for idx in 0..len {\n@@ -888,7 +888,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let relocations =\n             self.get_raw(src.alloc_id)?.prepare_relocation_copy(self, src, size, dest, length);\n \n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n \n         // This checks relocation edges on the src.\n         let src_bytes ="}, {"sha": "38f5988d0eb3fd82eb27768994647d9c219f1d72", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -651,12 +651,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n-                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n+                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n                         substs\n-                            .discriminants(def_id, self.tcx.tcx)\n+                            .discriminants(def_id, *self.tcx)\n                             .find(|(_, var)| var.val == discr_bits)\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),"}, {"sha": "24b191e9b535ab6c2daf9f56db6813b69186dc5b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -404,7 +404,10 @@ where\n                     // to get some code to work that probably ought to work.\n                     field_layout.align.abi\n                 }\n-                None => bug!(\"Cannot compute offset for extern type field at non-0 offset\"),\n+                None => span_bug!(\n+                    self.cur_span(),\n+                    \"cannot compute offset for extern type field at non-0 offset\"\n+                ),\n             };\n             (base.meta, offset.align_to(align))\n         } else {\n@@ -440,7 +443,11 @@ where\n                 assert!(!field_layout.is_unsized());\n                 base.offset(offset, MemPlaceMeta::None, field_layout, self)\n             }\n-            _ => bug!(\"`mplace_index` called on non-array type {:?}\", base.layout.ty),\n+            _ => span_bug!(\n+                self.cur_span(),\n+                \"`mplace_index` called on non-array type {:?}\",\n+                base.layout.ty\n+            ),\n         }\n     }\n \n@@ -454,7 +461,7 @@ where\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n             FieldsShape::Array { stride, .. } => stride,\n-            _ => bug!(\"mplace_array_fields: expected an array layout\"),\n+            _ => span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\"),\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n@@ -484,7 +491,9 @@ where\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n             FieldsShape::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n-            _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n+            _ => {\n+                span_bug!(self.cur_span(), \"unexpected layout of index access: {:#?}\", base.layout)\n+            }\n         };\n \n         // Compute meta and new layout\n@@ -497,7 +506,9 @@ where\n                 let len = Scalar::from_machine_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n-            _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n+            _ => {\n+                span_bug!(self.cur_span(), \"cannot subslice non-array type: `{:?}`\", base.layout.ty)\n+            }\n         };\n         let layout = self.layout_of(ty)?;\n         base.offset(from_offset, meta, layout, self)\n@@ -768,20 +779,22 @@ where\n             None => return Ok(()), // zero-sized access\n         };\n \n-        let tcx = &*self.tcx;\n+        let tcx = *self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n         match value {\n             Immediate::Scalar(scalar) => {\n                 match dest.layout.abi {\n                     Abi::Scalar(_) => {} // fine\n-                    _ => {\n-                        bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\", dest.layout)\n-                    }\n+                    _ => span_bug!(\n+                        self.cur_span(),\n+                        \"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n+                        dest.layout\n+                    ),\n                 }\n                 self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(\n-                    tcx,\n+                    &tcx,\n                     ptr,\n                     scalar,\n                     dest.layout.size,\n@@ -793,7 +806,8 @@ where\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = match dest.layout.abi {\n                     Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\n+                    _ => span_bug!(\n+                        self.cur_span(),\n                         \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                         dest.layout\n                     ),\n@@ -806,8 +820,8 @@ where\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n-                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(tcx, ptr, a_val, a_size)?;\n-                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(tcx, b_ptr, b_val, b_size)\n+                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(&tcx, ptr, a_val, a_size)?;\n+                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(&tcx, b_ptr, b_val, b_size)\n             }\n         }\n     }\n@@ -841,9 +855,9 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n+        if !mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n             span_bug!(\n-                self.tcx.span,\n+                self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n                 src.layout.ty,\n                 dest.layout.ty,\n@@ -898,7 +912,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n+        if mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }\n@@ -910,7 +924,7 @@ where\n             // on `typeck_tables().has_errors` at all const eval entry points.\n             debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n             self.tcx.sess.delay_span_bug(\n-                self.tcx.span,\n+                self.cur_span(),\n                 \"size-changing transmute, should have been caught by transmute checking\",\n             );\n             throw_inval!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));"}, {"sha": "16c6396799e634eedbb067b7409966875ccb2208", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -76,7 +76,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", stmt);\n-        self.set_span(stmt.source_info.span);\n \n         use rustc_middle::mir::StatementKind::*;\n \n@@ -279,7 +278,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", terminator.kind);\n-        self.set_span(terminator.source_info.span);\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {"}, {"sha": "a1d124bb7602ebb1408107d5840e90e073e56fbb", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -2,7 +2,7 @@ use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n-use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size};\n+use rustc_target::abi::{Align, LayoutOf, Size};\n \n use super::{FnVal, InterpCx, Machine, MemoryKind};\n \n@@ -49,8 +49,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi.bytes();\n \n+        let tcx = *self.tcx;\n         let ptr_size = self.pointer_size();\n-        let ptr_align = self.tcx.data_layout.pointer_align.abi;\n+        let ptr_align = tcx.data_layout.pointer_align.abi;\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         // If you touch this code, be sure to also make the corresponding changes to\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n@@ -60,33 +61,32 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ptr_align,\n             MemoryKind::Vtable,\n         );\n-        let tcx = &*self.tcx;\n \n-        let drop = Instance::resolve_drop_in_place(*tcx, ty);\n+        let drop = Instance::resolve_drop_in_place(tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n         // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n         let vtable_alloc = self.memory.get_raw_mut(vtable.alloc_id)?;\n-        vtable_alloc.write_ptr_sized(tcx, vtable, drop.into())?;\n+        vtable_alloc.write_ptr_sized(&tcx, vtable, drop.into())?;\n \n-        let size_ptr = vtable.offset(ptr_size, tcx)?;\n-        vtable_alloc.write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n-        let align_ptr = vtable.offset(ptr_size * 2, tcx)?;\n-        vtable_alloc.write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n+        let size_ptr = vtable.offset(ptr_size, &tcx)?;\n+        vtable_alloc.write_ptr_sized(&tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n+        let align_ptr = vtable.offset(ptr_size * 2, &tcx)?;\n+        vtable_alloc.write_ptr_sized(&tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n                 let instance =\n-                    ty::Instance::resolve_for_vtable(*tcx, self.param_env, def_id, substs)\n+                    ty::Instance::resolve_for_vtable(tcx, self.param_env, def_id, substs)\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 // We cannot use `vtable_allic` as we are creating fn ptrs in this loop.\n-                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), tcx)?;\n+                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &tcx)?;\n                 self.memory.get_raw_mut(vtable.alloc_id)?.write_ptr_sized(\n-                    tcx,\n+                    &tcx,\n                     method_ptr,\n                     fn_ptr.into(),\n                 )?;\n@@ -171,7 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n-        if size >= self.tcx.data_layout().obj_size_bound() {\n+        if size >= self.tcx.data_layout.obj_size_bound() {\n             throw_ub_format!(\n                 \"invalid vtable: \\\n                 size is bigger than largest supported object\""}, {"sha": "d50f052d405bc78d8e4ddb1335ab645c995a7433", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -313,7 +313,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine::new(), ());\n+        let mut ecx = InterpCx::new(tcx, span, param_env, ConstPropMachine::new(), ());\n         let can_const_prop = CanConstProp::check(body);\n \n         let ret = ecx\n@@ -404,9 +404,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         match self.ecx.eval_const_to_op(c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n-                // Make sure errors point at the constant.\n-                self.ecx.set_span(c.span);\n-                let err = error_to_const_error(&self.ecx, error);\n+                let tcx = self.ecx.tcx.at(c.span);\n+                let err = error_to_const_error(&self.ecx, error, Some(c.span));\n                 if let Some(lint_root) = self.lint_root(source_info) {\n                     let lint_only = match c.literal.val {\n                         // Promoteds must lint and not error as the user didn't ask for them\n@@ -418,17 +417,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     if lint_only {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n                         // generic functions using associated constants of the generic parameters.\n-                        err.report_as_lint(\n-                            self.ecx.tcx,\n-                            \"erroneous constant used\",\n-                            lint_root,\n-                            Some(c.span),\n-                        );\n+                        err.report_as_lint(tcx, \"erroneous constant used\", lint_root, Some(c.span));\n                     } else {\n-                        err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                        err.report_as_error(tcx, \"erroneous constant used\");\n                     }\n                 } else {\n-                    err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                    err.report_as_error(tcx, \"erroneous constant used\");\n                 }\n                 None\n             }\n@@ -851,7 +845,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n-        self.ecx.set_span(source_info.span);\n         self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n@@ -864,7 +857,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         if let Some(value) = self.get_const(place) {\n                             if self.should_const_prop(value) {\n                                 trace!(\"replacing {:?} with {:?}\", rval, value);\n-                                self.replace_with_const(rval, value, statement.source_info);\n+                                self.replace_with_const(rval, value, source_info);\n                                 if can_const_prop == ConstPropMode::FullConstProp\n                                     || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n                                 {\n@@ -927,7 +920,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n     fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n         let source_info = terminator.source_info;\n-        self.ecx.set_span(source_info.span);\n         self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n         match &mut terminator.kind {"}, {"sha": "3386e6e588e7120105e272edf2fb7131ec97c52e", "filename": "src/test/ui/consts/const-eval/infinite_loop.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -23,10 +23,10 @@ LL |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/infinite_loop.rs:8:20\n+  --> $DIR/infinite_loop.rs:8:17\n    |\n LL |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n-   |                    ^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0aa30665f590769d70e73c7f09e30b043c3be9fc", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -17,8 +17,8 @@ LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n note: ...which requires const-evaluating `std::mem::size_of`...\n   --> $SRC_DIR/libcore/mem/mod.rs:LL:COL\n    |\n-LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | pub const fn size_of<T>() -> usize {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires const-evaluating + checking `std::intrinsics::size_of`...\n   --> $SRC_DIR/libcore/intrinsics.rs:LL:COL\n    |"}, {"sha": "8c2190b4e591f87624bbed87cd95288ffe9bfba9", "filename": "src/test/ui/consts/const_limit/const_eval_limit_reached.stderr", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -1,15 +1,18 @@\n error: any use of this value will cause an error\n-  --> $DIR/const_eval_limit_reached.rs:8:11\n+  --> $DIR/const_eval_limit_reached.rs:8:5\n    |\n-LL | / const X: usize = {\n-LL | |     let mut x = 0;\n-LL | |     while x != 1000 {\n-   | |           ^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n-LL | |\n-...  |\n-LL | |     x\n-LL | | };\n-   | |__-\n+LL |  / const X: usize = {\n+LL |  |     let mut x = 0;\n+LL |  |     while x != 1000 {\n+   |  |_____^\n+LL | ||\n+LL | ||         x += 1;\n+LL | ||     }\n+   | ||_____^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n+LL |  |\n+LL |  |     x\n+LL |  | };\n+   |  |__-\n    |\n    = note: `#[deny(const_err)]` on by default\n "}, {"sha": "9042c6f6be1912c0d85a60db229eddbff965230f", "filename": "src/test/ui/consts/recursive-zst-static.default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -1,8 +1,8 @@\n error[E0391]: cycle detected when const-evaluating `FOO`\n-  --> $DIR/recursive-zst-static.rs:10:18\n+  --> $DIR/recursive-zst-static.rs:10:1\n    |\n LL | static FOO: () = FOO;\n-   |                  ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `FOO`...\n   --> $DIR/recursive-zst-static.rs:10:1"}, {"sha": "9042c6f6be1912c0d85a60db229eddbff965230f", "filename": "src/test/ui/consts/recursive-zst-static.unleash.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -1,8 +1,8 @@\n error[E0391]: cycle detected when const-evaluating `FOO`\n-  --> $DIR/recursive-zst-static.rs:10:18\n+  --> $DIR/recursive-zst-static.rs:10:1\n    |\n LL | static FOO: () = FOO;\n-   |                  ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `FOO`...\n   --> $DIR/recursive-zst-static.rs:10:1"}, {"sha": "55f42d84f9cb032ca28e49be253c6c0ecbae6a7a", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -1,11 +1,11 @@\n // build-fail\n \n pub const unsafe fn fake_type<T>() -> T {\n-    hint_unreachable()\n+    hint_unreachable() //~ ERROR evaluation of constant value failed\n }\n \n pub const unsafe fn hint_unreachable() -> ! {\n-    fake_type() //~ ERROR evaluation of constant value failed\n+    fake_type()\n }\n \n trait Const {"}, {"sha": "fc908b2b2225f130de39aba07c194bc2f67b5443", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -1,9 +1,10 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/uninhabited-const-issue-61744.rs:8:5\n+  --> $DIR/uninhabited-const-issue-61744.rs:4:5\n    |\n LL |     hint_unreachable()\n-   |     ------------------\n+   |     ^^^^^^^^^^^^^^^^^^\n    |     |\n+   |     reached the configured maximum number of stack frames\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n@@ -71,9 +72,8 @@ LL |     hint_unreachable()\n    |     inside `fake_type::<i32>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n ...\n LL |     fake_type()\n-   |     ^^^^^^^^^^^\n+   |     -----------\n    |     |\n-   |     reached the configured maximum number of stack frames\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5"}, {"sha": "de0c579f6308990f401fd99c5c1180267c993814", "filename": "src/test/ui/infinite/infinite-recursion-const-fn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -1,14 +1,14 @@\n error[E0391]: cycle detected when const-evaluating `a`\n-  --> $DIR/infinite-recursion-const-fn.rs:3:25\n+  --> $DIR/infinite-recursion-const-fn.rs:3:1\n    |\n LL | const fn a() -> usize { b() }\n-   |                         ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `b`...\n-  --> $DIR/infinite-recursion-const-fn.rs:4:25\n+  --> $DIR/infinite-recursion-const-fn.rs:4:1\n    |\n LL | const fn b() -> usize { a() }\n-   |                         ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires const-evaluating `a`, completing the cycle\n note: cycle used when const-evaluating `ARR::{{constant}}#0`\n   --> $DIR/infinite-recursion-const-fn.rs:5:18"}, {"sha": "093606e100cb3fa300003ba5799a603837ea05f9", "filename": "src/test/ui/recursion/recursive-static-definition.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -1,8 +1,8 @@\n error[E0391]: cycle detected when const-evaluating `FOO`\n-  --> $DIR/recursive-static-definition.rs:1:23\n+  --> $DIR/recursive-static-definition.rs:1:1\n    |\n LL | pub static FOO: u32 = FOO;\n-   |                       ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `FOO`...\n   --> $DIR/recursive-static-definition.rs:1:1"}, {"sha": "50dfce3448c341e7caee2515d367803ced13bdbd", "filename": "src/test/ui/write-to-static-mut-in-static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9c8a67593abd24ee7f6ccd23becbffd97d21379/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr?ref=f9c8a67593abd24ee7f6ccd23becbffd97d21379", "patch": "@@ -5,10 +5,10 @@ LL | pub static mut B: () = unsafe { A = 1; };\n    |                                 ^^^^^ modifying a static's initial value from another static's initializer\n \n error[E0391]: cycle detected when const-evaluating `C`\n-  --> $DIR/write-to-static-mut-in-static.rs:5:34\n+  --> $DIR/write-to-static-mut-in-static.rs:5:1\n    |\n LL | pub static mut C: u32 = unsafe { C = 1; 0 };\n-   |                                  ^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `C`...\n   --> $DIR/write-to-static-mut-in-static.rs:5:1"}]}