{"sha": "d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YmRiM2ZkY2JkODhlYjE2ZTFhNjY2OTIzNjEyMmM0MWVkMmFlZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-30T12:42:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-30T12:42:44Z"}, "message": "Auto merge of #66887 - dtolnay:rollup-uxowp8d, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #66818 (Format libstd/os with rustfmt)\n - #66819 (Format libstd/sys with rustfmt)\n - #66820 (Format libstd with rustfmt)\n - #66847 (Allow any identifier as format arg name)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "33974ee0e3d5976f284b056e03e6ef529d15e563", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33974ee0e3d5976f284b056e03e6ef529d15e563"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "html_url": "https://github.com/rust-lang/rust/commit/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f1bbd69e13c9e04a4c2b75612bc0c31af972439", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1bbd69e13c9e04a4c2b75612bc0c31af972439", "html_url": "https://github.com/rust-lang/rust/commit/8f1bbd69e13c9e04a4c2b75612bc0c31af972439"}, {"sha": "b14d9c21203ea79035bf4a8a8a68ad34658a265f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b14d9c21203ea79035bf4a8a8a68ad34658a265f", "html_url": "https://github.com/rust-lang/rust/commit/b14d9c21203ea79035bf4a8a8a68ad34658a265f"}], "stats": {"total": 11548, "additions": 6132, "deletions": 5416}, "files": [{"sha": "900c6ed5ff32235d487ec6a187a0f8970ad8ef9f", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -442,20 +442,9 @@ impl<'a> Parser<'a> {\n             Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => {\n+                Some(&(_, c)) if rustc_lexer::is_id_start(c) => {\n                     Some(ArgumentNamed(Symbol::intern(self.word())))\n                 }\n-                Some(&(pos, c)) if c == '_' => {\n-                    let invalid_name = self.string(pos);\n-                    self.err_with_note(format!(\"invalid argument name `{}`\", invalid_name),\n-                                       \"invalid argument name\",\n-                                       \"argument names cannot start with an underscore\",\n-                                        self.to_span_index(pos).to(\n-                                            self.to_span_index(pos + invalid_name.len())\n-                                        ),\n-                                        );\n-                    Some(ArgumentNamed(Symbol::intern(invalid_name)))\n-                },\n \n                 // This is an `ArgumentNext`.\n                 // Record the fact and do the resolution after parsing the\n@@ -611,22 +600,34 @@ impl<'a> Parser<'a> {\n     /// Rust identifier, except that it can't start with `_` character.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c != '_' && rustc_lexer::is_id_start(c) => {\n+            Some(&(pos, c)) if rustc_lexer::is_id_start(c) => {\n                 self.cur.next();\n                 pos\n             }\n             _ => {\n-                return &self.input[..0];\n+                return \"\";\n             }\n         };\n+        let mut end = None;\n         while let Some(&(pos, c)) = self.cur.peek() {\n             if rustc_lexer::is_id_continue(c) {\n                 self.cur.next();\n             } else {\n-                return &self.input[start..pos];\n+                end = Some(pos);\n+                break;\n             }\n         }\n-        &self.input[start..self.input.len()]\n+        let end = end.unwrap_or(self.input.len());\n+        let word = &self.input[start..end];\n+        if word == \"_\" {\n+            self.err_with_note(\n+                \"invalid argument name `_`\",\n+                \"invalid argument name\",\n+                \"argument name cannot be a single underscore\",\n+                self.to_span_index(start).to(self.to_span_index(end)),\n+            );\n+        }\n+        word\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal"}, {"sha": "41bdfea53e5599d77a5432d02087e41b962875ff", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -17,7 +17,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::ascii::{EscapeDefault, escape_default};\n+pub use core::ascii::{escape_default, EscapeDefault};\n \n /// Extension methods for ASCII-subset only operations.\n ///"}, {"sha": "5ba1c940251dc3b92233fd62c59d301009ad39e7", "filename": "src/libstd/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbacktrace.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -95,10 +95,10 @@ use crate::env;\n use crate::fmt;\n use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sync::Mutex;\n-use crate::sys_common::backtrace::{output_filename, lock};\n+use crate::sys_common::backtrace::{lock, output_filename};\n use crate::vec::Vec;\n-use backtrace_rs as backtrace;\n use backtrace::BytesOrWideString;\n+use backtrace_rs as backtrace;\n \n /// A captured OS thread stack backtrace.\n ///"}, {"sha": "bf646cbae47db81fc26fba47cf6c56dba18eeee7", "filename": "src/libstd/benches/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fbenches%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fbenches%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbenches%2Fhash%2Fmap.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n #![cfg(test)]\n \n-use test::Bencher;\n use std::collections::HashMap;\n+use test::Bencher;\n \n #[bench]\n fn new_drop(b: &mut Bencher) {"}, {"sha": "522b8b25144f42073dfa727dc0f2eed831e67a2f", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -413,20 +413,20 @@\n #[doc(hidden)]\n pub use crate::ops::Bound;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc_crate::collections::{BinaryHeap, BTreeMap, BTreeSet};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc_crate::collections::{LinkedList, VecDeque};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::collections::{binary_heap, btree_map, btree_set};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::collections::{linked_list, vec_deque};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc_crate::collections::{BTreeMap, BTreeSet, BinaryHeap};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc_crate::collections::{LinkedList, VecDeque};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_map::HashMap;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_set::HashSet;\n \n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n pub use alloc_crate::collections::TryReserveError;\n \n mod hash;"}, {"sha": "cf71b61b917a748e42d0ac5dcaf29d4c9da3444d", "filename": "src/libstd/env.rs", "status": "modified", "additions": 94, "deletions": 67, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -78,7 +78,9 @@ pub fn set_current_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// [`std::env::vars`]: fn.vars.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct Vars { inner: VarsOs }\n+pub struct Vars {\n+    inner: VarsOs,\n+}\n \n /// An iterator over a snapshot of the environment variables of this process.\n ///\n@@ -87,7 +89,9 @@ pub struct Vars { inner: VarsOs }\n ///\n /// [`std::env::vars_os`]: fn.vars_os.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct VarsOs { inner: os_imp::Env }\n+pub struct VarsOs {\n+    inner: os_imp::Env,\n+}\n \n /// Returns an iterator of (variable, value) pairs of strings, for all the\n /// environment variables of the current process.\n@@ -147,11 +151,11 @@ pub fn vars_os() -> VarsOs {\n impl Iterator for Vars {\n     type Item = (String, String);\n     fn next(&mut self) -> Option<(String, String)> {\n-        self.inner.next().map(|(a, b)| {\n-            (a.into_string().unwrap(), b.into_string().unwrap())\n-        })\n+        self.inner.next().map(|(a, b)| (a.into_string().unwrap(), b.into_string().unwrap()))\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n     }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -164,8 +168,12 @@ impl fmt::Debug for Vars {\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for VarsOs {\n     type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -239,9 +247,8 @@ pub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> {\n }\n \n fn _var_os(key: &OsStr) -> Option<OsString> {\n-    os_imp::getenv(key).unwrap_or_else(|e| {\n-        panic!(\"failed to get environment variable `{:?}`: {}\", key, e)\n-    })\n+    os_imp::getenv(key)\n+        .unwrap_or_else(|e| panic!(\"failed to get environment variable `{:?}`: {}\", key, e))\n }\n \n /// The error type for operations interacting with environment variables.\n@@ -321,8 +328,7 @@ pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) {\n \n fn _set_var(k: &OsStr, v: &OsStr) {\n     os_imp::setenv(k, v).unwrap_or_else(|e| {\n-        panic!(\"failed to set environment variable `{:?}` to `{:?}`: {}\",\n-               k, v, e)\n+        panic!(\"failed to set environment variable `{:?}` to `{:?}`: {}\", k, v, e)\n     })\n }\n \n@@ -363,9 +369,8 @@ pub fn remove_var<K: AsRef<OsStr>>(k: K) {\n }\n \n fn _remove_var(k: &OsStr) {\n-    os_imp::unsetenv(k).unwrap_or_else(|e| {\n-        panic!(\"failed to remove environment variable `{:?}`: {}\", k, e)\n-    })\n+    os_imp::unsetenv(k)\n+        .unwrap_or_else(|e| panic!(\"failed to remove environment variable `{:?}`: {}\", k, e))\n }\n \n /// An iterator that splits an environment variable into paths according to\n@@ -379,7 +384,9 @@ fn _remove_var(k: &OsStr) {\n /// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n /// [`std::env::split_paths`]: fn.split_paths.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n+pub struct SplitPaths<'a> {\n+    inner: os_imp::SplitPaths<'a>,\n+}\n \n /// Parses input according to platform conventions for the `PATH`\n /// environment variable.\n@@ -412,8 +419,12 @@ pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths<'_> {\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl<'a> Iterator for SplitPaths<'a> {\n     type Item = PathBuf;\n-    fn next(&mut self) -> Option<PathBuf> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<PathBuf> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -430,7 +441,7 @@ impl fmt::Debug for SplitPaths<'_> {\n #[derive(Debug)]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub struct JoinPathsError {\n-    inner: os_imp::JoinPathsError\n+    inner: os_imp::JoinPathsError,\n }\n \n /// Joins a collection of [`Path`]s appropriately for the `PATH`\n@@ -499,11 +510,11 @@ pub struct JoinPathsError {\n /// [`env::split_paths`]: fn.split_paths.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: IntoIterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: IntoIterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n-    os_imp::join_paths(paths.into_iter()).map_err(|e| {\n-        JoinPathsError { inner: e }\n-    })\n+    os_imp::join_paths(paths.into_iter()).map_err(|e| JoinPathsError { inner: e })\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n@@ -515,7 +526,9 @@ impl fmt::Display for JoinPathsError {\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Error for JoinPathsError {\n-    fn description(&self) -> &str { self.inner.description() }\n+    fn description(&self) -> &str {\n+        self.inner.description()\n+    }\n }\n \n /// Returns the path of the current user's home directory if known.\n@@ -549,9 +562,11 @@ impl Error for JoinPathsError {\n ///     None => println!(\"Impossible to get your home dir!\"),\n /// }\n /// ```\n-#[rustc_deprecated(since = \"1.29.0\",\n+#[rustc_deprecated(\n+    since = \"1.29.0\",\n     reason = \"This function's behavior is unexpected and probably not what you want. \\\n-              Consider using the home_dir function from https://crates.io/crates/dirs instead.\")]\n+              Consider using the home_dir function from https://crates.io/crates/dirs instead.\"\n+)]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn home_dir() -> Option<PathBuf> {\n     os_imp::home_dir()\n@@ -674,7 +689,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n /// [`String`]: ../string/struct.String.html\n /// [`std::env::args`]: ./fn.args.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct Args { inner: ArgsOs }\n+pub struct Args {\n+    inner: ArgsOs,\n+}\n \n /// An iterator over the arguments of a process, yielding an [`OsString`] value\n /// for each argument.\n@@ -689,7 +706,9 @@ pub struct Args { inner: ArgsOs }\n /// [`OsString`]: ../ffi/struct.OsString.html\n /// [`std::env::args_os`]: ./fn.args_os.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct ArgsOs { inner: sys::args::Args }\n+pub struct ArgsOs {\n+    inner: sys::args::Args,\n+}\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n@@ -769,13 +788,19 @@ impl Iterator for Args {\n     fn next(&mut self) -> Option<String> {\n         self.inner.next().map(|s| s.into_string().unwrap())\n     }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.inner.len() }\n-    fn is_empty(&self) -> bool { self.inner.is_empty() }\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+    fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n }\n \n #[stable(feature = \"env_iterators\", since = \"1.12.0\")]\n@@ -788,9 +813,7 @@ impl DoubleEndedIterator for Args {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Args {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Args\")\n-            .field(\"inner\", &self.inner.inner.inner_debug())\n-            .finish()\n+        f.debug_struct(\"Args\").field(\"inner\", &self.inner.inner.inner_debug()).finish()\n     }\n }\n \n@@ -803,27 +826,35 @@ impl !Sync for ArgsOs {}\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for ArgsOs {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<OsString> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl ExactSizeIterator for ArgsOs {\n-    fn len(&self) -> usize { self.inner.len() }\n-    fn is_empty(&self) -> bool { self.inner.is_empty() }\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+    fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n }\n \n #[stable(feature = \"env_iterators\", since = \"1.12.0\")]\n impl DoubleEndedIterator for ArgsOs {\n-    fn next_back(&mut self) -> Option<OsString> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for ArgsOs {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"ArgsOs\")\n-            .field(\"inner\", &self.inner.inner_debug())\n-            .finish()\n+        f.debug_struct(\"ArgsOs\").field(\"inner\", &self.inner.inner_debug()).finish()\n     }\n }\n \n@@ -1033,20 +1064,21 @@ mod tests {\n         use crate::path::PathBuf;\n \n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n+            split_paths(unparsed).collect::<Vec<_>>()\n+                == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));\n         assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n         assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n         assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n         assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n-        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n-                            &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n+        assert!(check_parse(r\"c:\\;c:\\Program Files\\\", &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n         assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n-        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n-                            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n+        assert!(check_parse(\n+            r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n+            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]\n+        ));\n     }\n \n     #[test]\n@@ -1055,8 +1087,8 @@ mod tests {\n         use crate::path::PathBuf;\n \n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n+            split_paths(unparsed).collect::<Vec<_>>()\n+                == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));\n@@ -1072,15 +1104,12 @@ mod tests {\n         use crate::ffi::OsStr;\n \n         fn test_eq(input: &[&str], output: &str) -> bool {\n-            &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::new(output)\n+            &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n-                         \"/bin:/usr/bin:/usr/local/bin\"));\n-        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n-                         \":/bin:::/usr/bin:\"));\n+        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"], \"/bin:/usr/bin:/usr/local/bin\"));\n+        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"], \":/bin:::/usr/bin:\"));\n         assert!(join_paths([\"/te:st\"].iter().cloned()).is_err());\n     }\n \n@@ -1090,27 +1119,25 @@ mod tests {\n         use crate::ffi::OsStr;\n \n         fn test_eq(input: &[&str], output: &str) -> bool {\n-            &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::new(output)\n+            &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"],\n-                        r\"c:\\windows;c:\\\"));\n-        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n-                        r\";c:\\windows;;;c:\\;\"));\n-        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"],\n-                        r#\"\"c:\\te;st\";c:\\\"#));\n+        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"], r\"c:\\windows;c:\\\"));\n+        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"], r\";c:\\windows;;;c:\\;\"));\n+        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"], r#\"\"c:\\te;st\";c:\\\"#));\n         assert!(join_paths([r#\"c:\\te\"st\"#].iter().cloned()).is_err());\n     }\n \n     #[test]\n     fn args_debug() {\n         assert_eq!(\n             format!(\"Args {{ inner: {:?} }}\", args().collect::<Vec<_>>()),\n-            format!(\"{:?}\", args()));\n+            format!(\"{:?}\", args())\n+        );\n         assert_eq!(\n             format!(\"ArgsOs {{ inner: {:?} }}\", args_os().collect::<Vec<_>>()),\n-            format!(\"{:?}\", args_os()));\n+            format!(\"{:?}\", args_os())\n+        );\n     }\n }"}, {"sha": "54e0caeddaa0bc68f537450106a254f498124b87", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -14,15 +14,15 @@ use crate::intrinsics;\n use crate::sys::cmath;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f32::consts;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f32::{DIGITS, EPSILON, MANTISSA_DIGITS, RADIX};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f32::{INFINITY, MAX_10_EXP, NAN, NEG_INFINITY};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n+pub use core::f32::{MAX, MIN, MIN_POSITIVE};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::consts;\n+pub use core::f32::{MAX_EXP, MIN_10_EXP, MIN_EXP};\n \n #[cfg(not(test))]\n #[lang = \"f32_runtime\"]\n@@ -142,7 +142,9 @@ impl f32 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn fract(self) -> f32 { self - self.trunc() }\n+    pub fn fract(self) -> f32 {\n+        self - self.trunc()\n+    }\n \n     /// Computes the absolute value of `self`. Returns `NAN` if the\n     /// number is `NAN`.\n@@ -192,11 +194,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn signum(self) -> f32 {\n-        if self.is_nan() {\n-            NAN\n-        } else {\n-            1.0_f32.copysign(self)\n-        }\n+        if self.is_nan() { NAN } else { 1.0_f32.copysign(self) }\n     }\n \n     /// Returns a number composed of the magnitude of `self` and the sign of\n@@ -277,7 +275,7 @@ impl f32 {\n     pub fn div_euclid(self, rhs: f32) -> f32 {\n         let q = (self / rhs).trunc();\n         if self % rhs < 0.0 {\n-            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n+            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 };\n         }\n         q\n     }\n@@ -310,14 +308,9 @@ impl f32 {\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n     pub fn rem_euclid(self, rhs: f32) -> f32 {\n         let r = self % rhs;\n-        if r < 0.0 {\n-            r + rhs.abs()\n-        } else {\n-            r\n-        }\n+        if r < 0.0 { r + rhs.abs() } else { r }\n     }\n \n-\n     /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n@@ -383,11 +376,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sqrt(self) -> f32 {\n-        if self < 0.0 {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf32(self) }\n-        }\n+        if self < 0.0 { NAN } else { unsafe { intrinsics::sqrtf32(self) } }\n     }\n \n     /// Returns `e^(self)`, (the exponential function).\n@@ -486,7 +475,9 @@ impl f32 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n+    pub fn log(self, base: f32) -> f32 {\n+        self.ln() / base.ln()\n+    }\n \n     /// Returns the base 2 logarithm of the number.\n     ///\n@@ -559,14 +550,16 @@ impl f32 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    #[rustc_deprecated(since = \"1.10.0\",\n-                       reason = \"you probably meant `(self - other).abs()`: \\\n-                                 this operation is `(self - other).max(0.0)` \\\n-                                 except that `abs_sub` also propagates NaNs (also \\\n-                                 known as `fdimf` in C). If you truly need the positive \\\n-                                 difference, consider using that expression or the C function \\\n-                                 `fdimf`, depending on how you wish to handle NaN (please consider \\\n-                                 filing an issue describing your use-case too).\")]\n+    #[rustc_deprecated(\n+        since = \"1.10.0\",\n+        reason = \"you probably meant `(self - other).abs()`: \\\n+                  this operation is `(self - other).max(0.0)` \\\n+                  except that `abs_sub` also propagates NaNs (also \\\n+                  known as `fdimf` in C). If you truly need the positive \\\n+                  difference, consider using that expression or the C function \\\n+                  `fdimf`, depending on how you wish to handle NaN (please consider \\\n+                  filing an issue describing your use-case too).\"\n+    )]\n     pub fn abs_sub(self, other: f32) -> f32 {\n         unsafe { cmath::fdimf(self, other) }\n     }\n@@ -967,11 +960,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f32 {\n-        if self < 1.0 {\n-            crate::f32::NAN\n-        } else {\n-            (self + ((self * self) - 1.0).sqrt()).ln()\n-        }\n+        if self < 1.0 { crate::f32::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n     }\n \n     /// Inverse hyperbolic tangent function.\n@@ -1022,19 +1011,22 @@ impl f32 {\n     pub fn clamp(self, min: f32, max: f32) -> f32 {\n         assert!(min <= max);\n         let mut x = self;\n-        if x < min { x = min; }\n-        if x > max { x = max; }\n+        if x < min {\n+            x = min;\n+        }\n+        if x > max {\n+            x = max;\n+        }\n         x\n     }\n-\n }\n \n #[cfg(test)]\n mod tests {\n     use crate::f32;\n     use crate::f32::*;\n-    use crate::num::*;\n     use crate::num::FpCategory as Fp;\n+    use crate::num::*;\n \n     #[test]\n     fn test_num_f32() {\n@@ -1279,7 +1271,7 @@ mod tests {\n         assert_eq!((-0f32).abs(), 0f32);\n         assert_eq!((-1f32).abs(), 1f32);\n         assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f32/NEG_INFINITY).abs(), 0f32);\n+        assert_eq!((1f32 / NEG_INFINITY).abs(), 0f32);\n         assert!(NAN.abs().is_nan());\n     }\n \n@@ -1291,7 +1283,7 @@ mod tests {\n         assert_eq!((-0f32).signum(), -1f32);\n         assert_eq!((-1f32).signum(), -1f32);\n         assert_eq!(NEG_INFINITY.signum(), -1f32);\n-        assert_eq!((1f32/NEG_INFINITY).signum(), -1f32);\n+        assert_eq!((1f32 / NEG_INFINITY).signum(), -1f32);\n         assert!(NAN.signum().is_nan());\n     }\n \n@@ -1303,7 +1295,7 @@ mod tests {\n         assert!(!(-0f32).is_sign_positive());\n         assert!(!(-1f32).is_sign_positive());\n         assert!(!NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f32/NEG_INFINITY).is_sign_positive());\n+        assert!(!(1f32 / NEG_INFINITY).is_sign_positive());\n         assert!(NAN.is_sign_positive());\n         assert!(!(-NAN).is_sign_positive());\n     }\n@@ -1316,7 +1308,7 @@ mod tests {\n         assert!((-0f32).is_sign_negative());\n         assert!((-1f32).is_sign_negative());\n         assert!(NEG_INFINITY.is_sign_negative());\n-        assert!((1f32/NEG_INFINITY).is_sign_negative());\n+        assert!((1f32 / NEG_INFINITY).is_sign_negative());\n         assert!(!NAN.is_sign_negative());\n         assert!((-NAN).is_sign_negative());\n     }"}, {"sha": "aa32e5fb998bc54cfa577f0b0747ab5808007274", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -14,15 +14,15 @@ use crate::intrinsics;\n use crate::sys::cmath;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f64::consts;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f64::{DIGITS, EPSILON, MANTISSA_DIGITS, RADIX};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f64::{INFINITY, MAX_10_EXP, NAN, NEG_INFINITY};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n+pub use core::f64::{MAX, MIN, MIN_POSITIVE};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::consts;\n+pub use core::f64::{MAX_EXP, MIN_10_EXP, MIN_EXP};\n \n #[cfg(not(test))]\n #[lang = \"f64_runtime\"]\n@@ -120,7 +120,9 @@ impl f64 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn fract(self) -> f64 { self - self.trunc() }\n+    pub fn fract(self) -> f64 {\n+        self - self.trunc()\n+    }\n \n     /// Computes the absolute value of `self`. Returns `NAN` if the\n     /// number is `NAN`.\n@@ -170,11 +172,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn signum(self) -> f64 {\n-        if self.is_nan() {\n-            NAN\n-        } else {\n-            1.0_f64.copysign(self)\n-        }\n+        if self.is_nan() { NAN } else { 1.0_f64.copysign(self) }\n     }\n \n     /// Returns a number composed of the magnitude of `self` and the sign of\n@@ -286,11 +284,7 @@ impl f64 {\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n     pub fn rem_euclid(self, rhs: f64) -> f64 {\n         let r = self % rhs;\n-        if r < 0.0 {\n-            r + rhs.abs()\n-        } else {\n-            r\n-        }\n+        if r < 0.0 { r + rhs.abs() } else { r }\n     }\n \n     /// Raises a number to an integer power.\n@@ -348,11 +342,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sqrt(self) -> f64 {\n-        if self < 0.0 {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf64(self) }\n-        }\n+        if self < 0.0 { NAN } else { unsafe { intrinsics::sqrtf64(self) } }\n     }\n \n     /// Returns `e^(self)`, (the exponential function).\n@@ -413,7 +403,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn ln(self) -> f64 {\n-        self.log_wrapper(|n| { unsafe { intrinsics::logf64(n) } })\n+        self.log_wrapper(|n| unsafe { intrinsics::logf64(n) })\n     }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n@@ -435,7 +425,9 @@ impl f64 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n+    pub fn log(self, base: f64) -> f64 {\n+        self.ln() / base.ln()\n+    }\n \n     /// Returns the base 2 logarithm of the number.\n     ///\n@@ -455,9 +447,9 @@ impl f64 {\n     pub fn log2(self) -> f64 {\n         self.log_wrapper(|n| {\n             #[cfg(target_os = \"android\")]\n-                return crate::sys::android::log2f64(n);\n+            return crate::sys::android::log2f64(n);\n             #[cfg(not(target_os = \"android\"))]\n-                return unsafe { intrinsics::log2f64(n) };\n+            return unsafe { intrinsics::log2f64(n) };\n         })\n     }\n \n@@ -477,7 +469,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn log10(self) -> f64 {\n-        self.log_wrapper(|n| { unsafe { intrinsics::log10f64(n) } })\n+        self.log_wrapper(|n| unsafe { intrinsics::log10f64(n) })\n     }\n \n     /// The positive difference of two numbers.\n@@ -500,14 +492,16 @@ impl f64 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    #[rustc_deprecated(since = \"1.10.0\",\n-    reason = \"you probably meant `(self - other).abs()`: \\\n-                                 this operation is `(self - other).max(0.0)` \\\n-                                 except that `abs_sub` also propagates NaNs (also \\\n-                                 known as `fdim` in C). If you truly need the positive \\\n-                                 difference, consider using that expression or the C function \\\n-                                 `fdim`, depending on how you wish to handle NaN (please consider \\\n-                                 filing an issue describing your use-case too).\")]\n+    #[rustc_deprecated(\n+        since = \"1.10.0\",\n+        reason = \"you probably meant `(self - other).abs()`: \\\n+                  this operation is `(self - other).max(0.0)` \\\n+                  except that `abs_sub` also propagates NaNs (also \\\n+                  known as `fdim` in C). If you truly need the positive \\\n+                  difference, consider using that expression or the C function \\\n+                  `fdim`, depending on how you wish to handle NaN (please consider \\\n+                  filing an issue describing your use-case too).\"\n+    )]\n     pub fn abs_sub(self, other: f64) -> f64 {\n         unsafe { cmath::fdim(self, other) }\n     }\n@@ -888,11 +882,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f64 {\n-        if self < 1.0 {\n-            NAN\n-        } else {\n-            (self + ((self * self) - 1.0).sqrt()).ln()\n-        }\n+        if self < 1.0 { NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n     }\n \n     /// Inverse hyperbolic tangent function.\n@@ -943,8 +933,12 @@ impl f64 {\n     pub fn clamp(self, min: f64, max: f64) -> f64 {\n         assert!(min <= max);\n         let mut x = self;\n-        if x < min { x = min; }\n-        if x > max { x = max; }\n+        if x < min {\n+            x = min;\n+        }\n+        if x > max {\n+            x = max;\n+        }\n         x\n     }\n \n@@ -978,8 +972,8 @@ impl f64 {\n mod tests {\n     use crate::f64;\n     use crate::f64::*;\n-    use crate::num::*;\n     use crate::num::FpCategory as Fp;\n+    use crate::num::*;\n \n     #[test]\n     fn test_num_f64() {"}, {"sha": "72f7367c9dcdbd11838235ddaad663eda8e62f25", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -155,21 +155,23 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::c_str::{CString, CStr, NulError, IntoStringError};\n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n-pub use self::c_str::{FromBytesWithNulError};\n+pub use self::c_str::FromBytesWithNulError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::c_str::{CStr, CString, IntoStringError, NulError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::os_str::{OsString, OsStr};\n+pub use self::os_str::{OsStr, OsString};\n \n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub use core::ffi::c_void;\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n pub use core::ffi::{VaList, VaListImpl};\n \n mod c_str;"}, {"sha": "e5cf022f0444e338a27622bb3ea07a2020cfe9aa", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 204, "deletions": 131, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -9,12 +9,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::fmt;\n use crate::ffi::OsString;\n-use crate::io::{self, SeekFrom, Seek, Read, Initializer, Write, IoSlice, IoSliceMut};\n+use crate::fmt;\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n use crate::path::{Path, PathBuf};\n use crate::sys::fs as fs_imp;\n-use crate::sys_common::{AsInnerMut, FromInner, AsInner, IntoInner};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n use crate::time::SystemTime;\n \n /// A reference to an open file on the filesystem.\n@@ -585,9 +585,7 @@ impl File {\n     /// ```\n     #[stable(feature = \"file_try_clone\", since = \"1.9.0\")]\n     pub fn try_clone(&self) -> io::Result<File> {\n-        Ok(File {\n-            inner: self.inner.duplicate()?\n-        })\n+        Ok(File { inner: self.inner.duplicate()? })\n     }\n \n     /// Changes the permissions on the underlying file.\n@@ -629,7 +627,9 @@ impl File {\n }\n \n impl AsInner<fs_imp::File> for File {\n-    fn as_inner(&self) -> &fs_imp::File { &self.inner }\n+    fn as_inner(&self) -> &fs_imp::File {\n+        &self.inner\n+    }\n }\n impl FromInner<fs_imp::File> for File {\n     fn from_inner(f: fs_imp::File) -> File {\n@@ -674,7 +674,9 @@ impl Write for File {\n         self.inner.write_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.flush()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Seek for File {\n@@ -707,7 +709,9 @@ impl Write for &File {\n         self.inner.write_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.flush()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Seek for &File {\n@@ -748,7 +752,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&mut self, read: bool) -> &mut OpenOptions {\n-        self.0.read(read); self\n+        self.0.read(read);\n+        self\n     }\n \n     /// Sets the option for write access.\n@@ -768,7 +773,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&mut self, write: bool) -> &mut OpenOptions {\n-        self.0.write(write); self\n+        self.0.write(write);\n+        self\n     }\n \n     /// Sets the option for the append mode.\n@@ -814,7 +820,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, append: bool) -> &mut OpenOptions {\n-        self.0.append(append); self\n+        self.0.append(append);\n+        self\n     }\n \n     /// Sets the option for truncating a previous file.\n@@ -833,7 +840,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions {\n-        self.0.truncate(truncate); self\n+        self.0.truncate(truncate);\n+        self\n     }\n \n     /// Sets the option for creating a new file.\n@@ -856,7 +864,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn create(&mut self, create: bool) -> &mut OpenOptions {\n-        self.0.create(create); self\n+        self.0.create(create);\n+        self\n     }\n \n     /// Sets the option to always create a new file.\n@@ -889,7 +898,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"expand_open_options2\", since = \"1.9.0\")]\n     pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions {\n-        self.0.create_new(create_new); self\n+        self.0.create_new(create_new);\n+        self\n     }\n \n     /// Opens a file at `path` with the options specified by `self`.\n@@ -946,11 +956,15 @@ impl OpenOptions {\n }\n \n impl AsInner<fs_imp::OpenOptions> for OpenOptions {\n-    fn as_inner(&self) -> &fs_imp::OpenOptions { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::OpenOptions {\n+        &self.0\n+    }\n }\n \n impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n-    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions { &mut self.0 }\n+    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions {\n+        &mut self.0\n+    }\n }\n \n impl Metadata {\n@@ -994,7 +1008,9 @@ impl Metadata {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_dir(&self) -> bool { self.file_type().is_dir() }\n+    pub fn is_dir(&self) -> bool {\n+        self.file_type().is_dir()\n+    }\n \n     /// Returns `true` if this metadata is for a regular file. The\n     /// result is mutually exclusive to the result of\n@@ -1017,7 +1033,9 @@ impl Metadata {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_file(&self) -> bool { self.file_type().is_file() }\n+    pub fn is_file(&self) -> bool {\n+        self.file_type().is_file()\n+    }\n \n     /// Returns the size of the file, in bytes, this metadata is for.\n     ///\n@@ -1034,7 +1052,9 @@ impl Metadata {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> u64 { self.0.size() }\n+    pub fn len(&self) -> u64 {\n+        self.0.size()\n+    }\n \n     /// Returns the permissions of the file this metadata is for.\n     ///\n@@ -1170,11 +1190,15 @@ impl fmt::Debug for Metadata {\n }\n \n impl AsInner<fs_imp::FileAttr> for Metadata {\n-    fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::FileAttr {\n+        &self.0\n+    }\n }\n \n impl FromInner<fs_imp::FileAttr> for Metadata {\n-    fn from_inner(attr: fs_imp::FileAttr) -> Metadata { Metadata(attr) }\n+    fn from_inner(attr: fs_imp::FileAttr) -> Metadata {\n+        Metadata(attr)\n+    }\n }\n \n impl Permissions {\n@@ -1194,7 +1218,9 @@ impl Permissions {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn readonly(&self) -> bool { self.0.readonly() }\n+    pub fn readonly(&self) -> bool {\n+        self.0.readonly()\n+    }\n \n     /// Modifies the readonly flag for this set of permissions. If the\n     /// `readonly` argument is `true`, using the resulting `Permission` will\n@@ -1256,7 +1282,9 @@ impl FileType {\n     /// }\n     /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n-    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+    pub fn is_dir(&self) -> bool {\n+        self.0.is_dir()\n+    }\n \n     /// Tests whether this file type represents a regular file.\n     /// The result is  mutually exclusive to the results of\n@@ -1280,7 +1308,9 @@ impl FileType {\n     /// }\n     /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n-    pub fn is_file(&self) -> bool { self.0.is_file() }\n+    pub fn is_file(&self) -> bool {\n+        self.0.is_file()\n+    }\n \n     /// Tests whether this file type represents a symbolic link.\n     /// The result is mutually exclusive to the results of\n@@ -1314,11 +1344,15 @@ impl FileType {\n     /// }\n     /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n-    pub fn is_symlink(&self) -> bool { self.0.is_symlink() }\n+    pub fn is_symlink(&self) -> bool {\n+        self.0.is_symlink()\n+    }\n }\n \n impl AsInner<fs_imp::FileType> for FileType {\n-    fn as_inner(&self) -> &fs_imp::FileType { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::FileType {\n+        &self.0\n+    }\n }\n \n impl FromInner<fs_imp::FilePermissions> for Permissions {\n@@ -1328,7 +1362,9 @@ impl FromInner<fs_imp::FilePermissions> for Permissions {\n }\n \n impl AsInner<fs_imp::FilePermissions> for Permissions {\n-    fn as_inner(&self) -> &fs_imp::FilePermissions { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::FilePermissions {\n+        &self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1370,7 +1406,9 @@ impl DirEntry {\n     ///\n     /// The exact text, of course, depends on what files you have in `.`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn path(&self) -> PathBuf { self.0.path() }\n+    pub fn path(&self) -> PathBuf {\n+        self.0.path()\n+    }\n \n     /// Returns the metadata for the file that this entry points at.\n     ///\n@@ -1468,14 +1506,14 @@ impl DirEntry {\n #[stable(feature = \"dir_entry_debug\", since = \"1.13.0\")]\n impl fmt::Debug for DirEntry {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"DirEntry\")\n-            .field(&self.path())\n-            .finish()\n+        f.debug_tuple(\"DirEntry\").field(&self.path()).finish()\n     }\n }\n \n impl AsInner<fs_imp::DirEntry> for DirEntry {\n-    fn as_inner(&self) -> &fs_imp::DirEntry { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::DirEntry {\n+        &self.0\n+    }\n }\n \n /// Removes a file from the filesystem.\n@@ -1744,9 +1782,11 @@ pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.1.0\",\n-             reason = \"replaced with std::os::unix::fs::symlink and \\\n-                       std::os::windows::fs::{symlink_file, symlink_dir}\")]\n+#[rustc_deprecated(\n+    since = \"1.1.0\",\n+    reason = \"replaced with std::os::unix::fs::symlink and \\\n+              std::os::windows::fs::{symlink_file, symlink_dir}\"\n+)]\n pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     fs_imp::symlink(src.as_ref(), dst.as_ref())\n }\n@@ -2089,8 +2129,7 @@ pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n /// }\n /// ```\n #[stable(feature = \"set_permissions\", since = \"1.1.0\")]\n-pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions)\n-                                       -> io::Result<()> {\n+pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result<()> {\n     fs_imp::set_perm(path.as_ref(), perm.0)\n }\n \n@@ -2107,10 +2146,7 @@ impl DirBuilder {\n     /// ```\n     #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n     pub fn new() -> DirBuilder {\n-        DirBuilder {\n-            inner: fs_imp::DirBuilder::new(),\n-            recursive: false,\n-        }\n+        DirBuilder { inner: fs_imp::DirBuilder::new(), recursive: false }\n     }\n \n     /// Indicates that directories should be created recursively, creating all\n@@ -2157,16 +2193,12 @@ impl DirBuilder {\n     }\n \n     fn _create(&self, path: &Path) -> io::Result<()> {\n-        if self.recursive {\n-            self.create_dir_all(path)\n-        } else {\n-            self.inner.mkdir(path)\n-        }\n+        if self.recursive { self.create_dir_all(path) } else { self.inner.mkdir(path) }\n     }\n \n     fn create_dir_all(&self, path: &Path) -> io::Result<()> {\n         if path == Path::new(\"\") {\n-            return Ok(())\n+            return Ok(());\n         }\n \n         match self.inner.mkdir(path) {\n@@ -2177,7 +2209,9 @@ impl DirBuilder {\n         }\n         match path.parent() {\n             Some(p) => self.create_dir_all(p)?,\n-            None => return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\")),\n+            None => {\n+                return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\"));\n+            }\n         }\n         match self.inner.mkdir(path) {\n             Ok(()) => Ok(()),\n@@ -2201,48 +2235,62 @@ mod tests {\n     use crate::io::{ErrorKind, SeekFrom};\n     use crate::path::Path;\n     use crate::str;\n-    use crate::sys_common::io::test::{TempDir, tmpdir};\n+    use crate::sys_common::io::test::{tmpdir, TempDir};\n     use crate::thread;\n \n     use rand::{rngs::StdRng, RngCore, SeedableRng};\n \n-    #[cfg(windows)]\n-    use crate::os::windows::fs::{symlink_dir, symlink_file};\n-    #[cfg(windows)]\n-    use crate::sys::fs::symlink_junction;\n     #[cfg(unix)]\n     use crate::os::unix::fs::symlink as symlink_dir;\n     #[cfg(unix)]\n     use crate::os::unix::fs::symlink as symlink_file;\n     #[cfg(unix)]\n     use crate::os::unix::fs::symlink as symlink_junction;\n+    #[cfg(windows)]\n+    use crate::os::windows::fs::{symlink_dir, symlink_file};\n+    #[cfg(windows)]\n+    use crate::sys::fs::symlink_junction;\n \n-    macro_rules! check { ($e:expr) => (\n-        match $e {\n-            Ok(t) => t,\n-            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n-        }\n-    ) }\n+    macro_rules! check {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n+            }\n+        };\n+    }\n \n     #[cfg(windows)]\n-    macro_rules! error { ($e:expr, $s:expr) => (\n-        match $e {\n-            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-            Err(ref err) => assert!(err.raw_os_error() == Some($s),\n-                                    format!(\"`{}` did not have a code of `{}`\", err, $s))\n-        }\n-    ) }\n+    macro_rules! error {\n+        ($e:expr, $s:expr) => {\n+            match $e {\n+                Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n+                Err(ref err) => assert!(\n+                    err.raw_os_error() == Some($s),\n+                    format!(\"`{}` did not have a code of `{}`\", err, $s)\n+                ),\n+            }\n+        };\n+    }\n \n     #[cfg(unix)]\n-    macro_rules! error { ($e:expr, $s:expr) => ( error_contains!($e, $s) ) }\n-\n-    macro_rules! error_contains { ($e:expr, $s:expr) => (\n-        match $e {\n-            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-            Err(ref err) => assert!(err.to_string().contains($s),\n-                                    format!(\"`{}` did not contain `{}`\", err, $s))\n-        }\n-    ) }\n+    macro_rules! error {\n+        ($e:expr, $s:expr) => {\n+            error_contains!($e, $s)\n+        };\n+    }\n+\n+    macro_rules! error_contains {\n+        ($e:expr, $s:expr) => {\n+            match $e {\n+                Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n+                Err(ref err) => assert!(\n+                    err.to_string().contains($s),\n+                    format!(\"`{}` did not contain `{}`\", err, $s)\n+                ),\n+            }\n+        };\n+    }\n \n     // Several test fail on windows if the user does not have permission to\n     // create symlinks (the `SeCreateSymbolicLinkPrivilege`). Instead of\n@@ -2251,7 +2299,9 @@ mod tests {\n     // tests most of the time, but at least we do if the user has the right\n     // permissions.\n     pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n-        if cfg!(unix) { return true }\n+        if cfg!(unix) {\n+            return true;\n+        }\n         let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n \n         match symlink_file(r\"nonexisting_target\", link) {\n@@ -2276,7 +2326,7 @@ mod tests {\n             let mut read_buf = [0; 1028];\n             let read_str = match check!(read_stream.read(&mut read_buf)) {\n                 0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(&read_buf[..n]).unwrap().to_string()\n+                n => str::from_utf8(&read_buf[..n]).unwrap().to_string(),\n             };\n             assert_eq!(read_str, message);\n         }\n@@ -2363,9 +2413,9 @@ mod tests {\n \n     #[test]\n     fn file_test_io_seek_and_write() {\n-        let initial_msg =   \"food-is-yummy\";\n-        let overwrite_msg =    \"-the-bar!!\";\n-        let final_msg =     \"foo-the-bar!!\";\n+        let initial_msg = \"food-is-yummy\";\n+        let overwrite_msg = \"-the-bar!!\";\n+        let final_msg = \"foo-the-bar!!\";\n         let seek_idx = 3;\n         let mut read_mem = [0; 13];\n         let tmpdir = tmpdir();\n@@ -2388,7 +2438,7 @@ mod tests {\n     #[test]\n     fn file_test_io_seek_shakedown() {\n         //                   01234567890123\n-        let initial_msg =   \"qwer-asdf-zxcv\";\n+        let initial_msg = \"qwer-asdf-zxcv\";\n         let chunk_one: &str = \"qwer\";\n         let chunk_two: &str = \"asdf\";\n         let chunk_three: &str = \"zxcv\";\n@@ -2497,13 +2547,11 @@ mod tests {\n         check!(fs::create_dir(filename));\n         let mask = 0o7777;\n \n-        check!(fs::set_permissions(filename,\n-                                   fs::Permissions::from_mode(0)));\n+        check!(fs::set_permissions(filename, fs::Permissions::from_mode(0)));\n         let metadata0 = check!(fs::metadata(filename));\n         assert_eq!(mask & metadata0.permissions().mode(), 0);\n \n-        check!(fs::set_permissions(filename,\n-                                   fs::Permissions::from_mode(0o1777)));\n+        check!(fs::set_permissions(filename, fs::Permissions::from_mode(0o1777)));\n         let metadata1 = check!(fs::metadata(filename));\n         assert_eq!(mask & metadata1.permissions().mode(), 0o1777);\n     }\n@@ -2568,8 +2616,7 @@ mod tests {\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n         {\n             let mut opts = OpenOptions::new();\n-            let mut fs = check!(opts.read(true).write(true)\n-                                    .create(true).open(filename));\n+            let mut fs = check!(opts.read(true).write(true).create(true).open(filename));\n             let msg = \"hw\";\n             fs.write(msg.as_bytes()).unwrap();\n \n@@ -2703,7 +2750,7 @@ mod tests {\n             for _ in 0..40 {\n                 dir = dir.join(\"a\");\n             }\n-            let mut join = vec!();\n+            let mut join = vec![];\n             for _ in 0..8 {\n                 let dir = dir.clone();\n                 join.push(thread::spawn(move || {\n@@ -2771,7 +2818,9 @@ mod tests {\n     #[cfg(windows)]\n     fn recursive_rmdir_of_file_symlink() {\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         let f1 = tmpdir.join(\"f1\");\n         let f2 = tmpdir.join(\"f2\");\n@@ -2854,8 +2903,7 @@ mod tests {\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n         assert_eq!(v, b\"hello\");\n \n-        assert_eq!(check!(input.metadata()).permissions(),\n-                   check!(out.metadata()).permissions());\n+        assert_eq!(check!(input.metadata()).permissions(), check!(out.metadata()).permissions());\n     }\n \n     #[test]\n@@ -2865,7 +2913,8 @@ mod tests {\n \n         check!(File::create(&out));\n         match fs::copy(&*out, tmpdir.path()) {\n-            Ok(..) => panic!(), Err(..) => {}\n+            Ok(..) => panic!(),\n+            Err(..) => {}\n         }\n     }\n \n@@ -2890,7 +2939,8 @@ mod tests {\n         let out = tmpdir.join(\"out\");\n \n         match fs::copy(tmpdir.path(), &out) {\n-            Ok(..) => panic!(), Err(..) => {}\n+            Ok(..) => panic!(),\n+            Err(..) => {}\n         }\n         assert!(!out.exists());\n     }\n@@ -2938,7 +2988,9 @@ mod tests {\n     #[test]\n     fn copy_file_follows_dst_symlink() {\n         let tmp = tmpdir();\n-        if !got_symlink_permission(&tmp) { return };\n+        if !got_symlink_permission(&tmp) {\n+            return;\n+        };\n \n         let in_path = tmp.join(\"in.txt\");\n         let out_path = tmp.join(\"out.txt\");\n@@ -2958,16 +3010,17 @@ mod tests {\n     #[test]\n     fn symlinks_work() {\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n         check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n         check!(symlink_file(&input, &out));\n         assert!(check!(out.symlink_metadata()).file_type().is_symlink());\n-        assert_eq!(check!(fs::metadata(&out)).len(),\n-                   check!(fs::metadata(&input)).len());\n+        assert_eq!(check!(fs::metadata(&out)).len(), check!(fs::metadata(&input)).len());\n         let mut v = Vec::new();\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n         assert_eq!(v, b\"foobar\".to_vec());\n@@ -2977,31 +3030,40 @@ mod tests {\n     fn symlink_noexist() {\n         // Symlinks can point to things that don't exist\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         // Use a relative path for testing. Symlinks get normalized by Windows,\n         // so we may not get the same path back for absolute paths\n         check!(symlink_file(&\"foo\", &tmpdir.join(\"bar\")));\n-        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))).to_str().unwrap(),\n-                   \"foo\");\n+        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))).to_str().unwrap(), \"foo\");\n     }\n \n     #[test]\n     fn read_link() {\n         if cfg!(windows) {\n             // directory symlink\n-            assert_eq!(check!(fs::read_link(r\"C:\\Users\\All Users\")).to_str().unwrap(),\n-                       r\"C:\\ProgramData\");\n+            assert_eq!(\n+                check!(fs::read_link(r\"C:\\Users\\All Users\")).to_str().unwrap(),\n+                r\"C:\\ProgramData\"\n+            );\n             // junction\n-            assert_eq!(check!(fs::read_link(r\"C:\\Users\\Default User\")).to_str().unwrap(),\n-                       r\"C:\\Users\\Default\");\n+            assert_eq!(\n+                check!(fs::read_link(r\"C:\\Users\\Default User\")).to_str().unwrap(),\n+                r\"C:\\Users\\Default\"\n+            );\n             // junction with special permissions\n-            assert_eq!(check!(fs::read_link(r\"C:\\Documents and Settings\\\")).to_str().unwrap(),\n-                       r\"C:\\Users\");\n+            assert_eq!(\n+                check!(fs::read_link(r\"C:\\Documents and Settings\\\")).to_str().unwrap(),\n+                r\"C:\\Users\"\n+            );\n         }\n         let tmpdir = tmpdir();\n         let link = tmpdir.join(\"link\");\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n         check!(symlink_file(&\"foo\", &link));\n         assert_eq!(check!(fs::read_link(&link)).to_str().unwrap(), \"foo\");\n     }\n@@ -3023,10 +3085,8 @@ mod tests {\n \n         check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n         check!(fs::hard_link(&input, &out));\n-        assert_eq!(check!(fs::metadata(&out)).len(),\n-                   check!(fs::metadata(&input)).len());\n-        assert_eq!(check!(fs::metadata(&out)).len(),\n-                   check!(input.metadata()).len());\n+        assert_eq!(check!(fs::metadata(&out)).len(), check!(fs::metadata(&input)).len());\n+        assert_eq!(check!(fs::metadata(&out)).len(), check!(input.metadata()).len());\n         let mut v = Vec::new();\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n         assert_eq!(v, b\"foobar\".to_vec());\n@@ -3134,15 +3194,22 @@ mod tests {\n     #[test]\n     fn open_flavors() {\n         use crate::fs::OpenOptions as OO;\n-        fn c<T: Clone>(t: &T) -> T { t.clone() }\n+        fn c<T: Clone>(t: &T) -> T {\n+            t.clone()\n+        }\n \n         let tmpdir = tmpdir();\n \n-        let mut r = OO::new(); r.read(true);\n-        let mut w = OO::new(); w.write(true);\n-        let mut rw = OO::new(); rw.read(true).write(true);\n-        let mut a = OO::new(); a.append(true);\n-        let mut ra = OO::new(); ra.read(true).append(true);\n+        let mut r = OO::new();\n+        r.read(true);\n+        let mut w = OO::new();\n+        w.write(true);\n+        let mut rw = OO::new();\n+        rw.read(true).write(true);\n+        let mut a = OO::new();\n+        a.append(true);\n+        let mut ra = OO::new();\n+        ra.read(true).append(true);\n \n         #[cfg(windows)]\n         let invalid_options = 87; // ERROR_INVALID_PARAMETER\n@@ -3201,7 +3268,7 @@ mod tests {\n \n         // Test opening a file without setting an access mode\n         let mut blank = OO::new();\n-         error!(blank.create(true).open(&tmpdir.join(\"f\")), invalid_options);\n+        error!(blank.create(true).open(&tmpdir.join(\"f\")), invalid_options);\n \n         // Test write works\n         check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foobar\".as_bytes()));\n@@ -3279,8 +3346,10 @@ mod tests {\n         assert!(v == &bytes[..]);\n \n         check!(fs::write(&tmpdir.join(\"not-utf8\"), &[0xFF]));\n-        error_contains!(fs::read_to_string(&tmpdir.join(\"not-utf8\")),\n-                        \"stream did not contain valid UTF-8\");\n+        error_contains!(\n+            fs::read_to_string(&tmpdir.join(\"not-utf8\")),\n+            \"stream did not contain valid UTF-8\"\n+        );\n \n         let s = \"\ud800\udc41\ud800\udc13\ud800\udc20\ud800\udc34\ud800\udc0d\";\n         check!(fs::write(&tmpdir.join(\"utf8\"), s.as_bytes()));\n@@ -3292,11 +3361,9 @@ mod tests {\n     fn file_try_clone() {\n         let tmpdir = tmpdir();\n \n-        let mut f1 = check!(OpenOptions::new()\n-                                       .read(true)\n-                                       .write(true)\n-                                       .create(true)\n-                                       .open(&tmpdir.join(\"test\")));\n+        let mut f1 = check!(\n+            OpenOptions::new().read(true).write(true).create(true).open(&tmpdir.join(\"test\"))\n+        );\n         let mut f2 = check!(f1.try_clone());\n \n         check!(f1.write_all(b\"hello world\"));\n@@ -3341,7 +3408,9 @@ mod tests {\n     #[test]\n     fn realpath_works() {\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n         let file = tmpdir.join(\"test\");\n@@ -3366,7 +3435,9 @@ mod tests {\n     #[test]\n     fn realpath_works_tricky() {\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n         let a = tmpdir.join(\"a\");\n@@ -3452,7 +3523,9 @@ mod tests {\n         assert!(junction.is_dir());\n         assert!(b.exists());\n \n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n         check!(symlink_dir(&target, &link));\n         check!(fs::create_dir_all(&d));\n         assert!(link.is_dir());\n@@ -3482,8 +3555,8 @@ mod tests {\n             // Not always available\n             match (a.created(), b.created()) {\n                 (Ok(t1), Ok(t2)) => assert!(t1 <= t2),\n-                (Err(e1), Err(e2)) if e1.kind() == ErrorKind::Other &&\n-                                      e2.kind() == ErrorKind::Other => {}\n+                (Err(e1), Err(e2))\n+                    if e1.kind() == ErrorKind::Other && e2.kind() == ErrorKind::Other => {}\n                 (a, b) => panic!(\n                     \"creation time must be always supported or not supported: {:?} {:?}\",\n                     a, b,"}, {"sha": "8e81b292f6fa38fc1315b494d3f71d6d23ad468e", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 80, "deletions": 67, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -5,8 +5,9 @@ use crate::io::prelude::*;\n use crate::cmp;\n use crate::error;\n use crate::fmt;\n-use crate::io::{self, Initializer, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom, IoSlice,\n-        IoSliceMut};\n+use crate::io::{\n+    self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom, DEFAULT_BUF_SIZE,\n+};\n use crate::memchr;\n \n /// The `BufReader<R>` struct adds buffering to any reader.\n@@ -100,12 +101,7 @@ impl<R: Read> BufReader<R> {\n             let mut buffer = Vec::with_capacity(capacity);\n             buffer.set_len(capacity);\n             inner.initializer().initialize(&mut buffer);\n-            BufReader {\n-                inner,\n-                buf: buffer.into_boxed_slice(),\n-                pos: 0,\n-                cap: 0,\n-            }\n+            BufReader { inner, buf: buffer.into_boxed_slice(), pos: 0, cap: 0 }\n         }\n     }\n }\n@@ -130,7 +126,9 @@ impl<R> BufReader<R> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &R { &self.inner }\n+    pub fn get_ref(&self) -> &R {\n+        &self.inner\n+    }\n \n     /// Gets a mutable reference to the underlying reader.\n     ///\n@@ -151,7 +149,9 @@ impl<R> BufReader<R> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n+    pub fn get_mut(&mut self) -> &mut R {\n+        &mut self.inner\n+    }\n \n     /// Returns a reference to the internally buffered data.\n     ///\n@@ -199,7 +199,9 @@ impl<R> BufReader<R> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> R { self.inner }\n+    pub fn into_inner(self) -> R {\n+        self.inner\n+    }\n \n     /// Invalidates all data in the internal buffer.\n     #[inline]\n@@ -220,17 +222,17 @@ impl<R: Seek> BufReader<R> {\n         if offset < 0 {\n             if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n                 self.pos = new_pos as usize;\n-                return Ok(())\n+                return Ok(());\n             }\n         } else {\n             if let Some(new_pos) = pos.checked_add(offset as u64) {\n                 if new_pos <= self.cap as u64 {\n                     self.pos = new_pos as usize;\n-                    return Ok(())\n+                    return Ok(());\n                 }\n             }\n         }\n-        self.seek(SeekFrom::Current(offset)).map(|_|())\n+        self.seek(SeekFrom::Current(offset)).map(|_| ())\n     }\n }\n \n@@ -293,7 +295,10 @@ impl<R: Read> BufRead for BufReader<R> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n+impl<R> fmt::Debug for BufReader<R>\n+where\n+    R: fmt::Debug,\n+{\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufReader\")\n             .field(\"reader\", &self.inner)\n@@ -483,11 +488,7 @@ impl<W: Write> BufWriter<W> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n-        BufWriter {\n-            inner: Some(inner),\n-            buf: Vec::with_capacity(capacity),\n-            panicked: false,\n-        }\n+        BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n     }\n \n     fn flush_buf(&mut self) -> io::Result<()> {\n@@ -501,14 +502,16 @@ impl<W: Write> BufWriter<W> {\n \n             match r {\n                 Ok(0) => {\n-                    ret = Err(Error::new(ErrorKind::WriteZero,\n-                                         \"failed to write the buffered data\"));\n+                    ret =\n+                        Err(Error::new(ErrorKind::WriteZero, \"failed to write the buffered data\"));\n                     break;\n                 }\n                 Ok(n) => written += n,\n                 Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => { ret = Err(e); break }\n-\n+                Err(e) => {\n+                    ret = Err(e);\n+                    break;\n+                }\n             }\n         }\n         if written > 0 {\n@@ -531,7 +534,9 @@ impl<W: Write> BufWriter<W> {\n     /// let reference = buffer.get_ref();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.as_ref().unwrap()\n+    }\n \n     /// Gets a mutable reference to the underlying writer.\n     ///\n@@ -549,7 +554,9 @@ impl<W: Write> BufWriter<W> {\n     /// let reference = buffer.get_mut();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n+    pub fn get_mut(&mut self) -> &mut W {\n+        self.inner.as_mut().unwrap()\n+    }\n \n     /// Returns a reference to the internally buffered data.\n     ///\n@@ -592,7 +599,7 @@ impl<W: Write> BufWriter<W> {\n     pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n         match self.flush_buf() {\n             Err(e) => Err(IntoInnerError(self, e)),\n-            Ok(()) => Ok(self.inner.take().unwrap())\n+            Ok(()) => Ok(self.inner.take().unwrap()),\n         }\n     }\n }\n@@ -634,7 +641,10 @@ impl<W: Write> Write for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n+impl<W: Write> fmt::Debug for BufWriter<W>\n+where\n+    W: fmt::Debug,\n+{\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufWriter\")\n             .field(\"writer\", &self.inner.as_ref().unwrap())\n@@ -693,7 +703,9 @@ impl<W> IntoInnerError<W> {\n     /// };\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn error(&self) -> &Error { &self.1 }\n+    pub fn error(&self) -> &Error {\n+        &self.1\n+    }\n \n     /// Returns the buffered writer instance which generated the error.\n     ///\n@@ -726,12 +738,16 @@ impl<W> IntoInnerError<W> {\n     /// };\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> W { self.0 }\n+    pub fn into_inner(self) -> W {\n+        self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W> From<IntoInnerError<W>> for Error {\n-    fn from(iie: IntoInnerError<W>) -> Error { iie.1 }\n+    fn from(iie: IntoInnerError<W>) -> Error {\n+        iie.1\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -856,10 +872,7 @@ impl<W: Write> LineWriter<W> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n-        LineWriter {\n-            inner: BufWriter::with_capacity(capacity, inner),\n-            need_flush: false,\n-        }\n+        LineWriter { inner: BufWriter::with_capacity(capacity, inner), need_flush: false }\n     }\n \n     /// Gets a reference to the underlying writer.\n@@ -879,7 +892,9 @@ impl<W: Write> LineWriter<W> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W { self.inner.get_ref() }\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.get_ref()\n+    }\n \n     /// Gets a mutable reference to the underlying writer.\n     ///\n@@ -902,7 +917,9 @@ impl<W: Write> LineWriter<W> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut W { self.inner.get_mut() }\n+    pub fn get_mut(&mut self) -> &mut W {\n+        self.inner.get_mut()\n+    }\n \n     /// Unwraps this `LineWriter`, returning the underlying writer.\n     ///\n@@ -930,10 +947,7 @@ impl<W: Write> LineWriter<W> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n         self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n-            IntoInnerError(LineWriter {\n-                inner: buf,\n-                need_flush: false,\n-            }, e)\n+            IntoInnerError(LineWriter { inner: buf, need_flush: false }, e)\n         })\n     }\n }\n@@ -953,7 +967,6 @@ impl<W: Write> Write for LineWriter<W> {\n             None => return self.inner.write(buf),\n         };\n \n-\n         // Ok, we're going to write a partial amount of the data given first\n         // followed by flushing the newline. After we've successfully written\n         // some data then we *must* report that we wrote that data, so future\n@@ -962,7 +975,7 @@ impl<W: Write> Write for LineWriter<W> {\n         let n = self.inner.write(&buf[..=i])?;\n         self.need_flush = true;\n         if self.flush().is_err() || n != i + 1 {\n-            return Ok(n)\n+            return Ok(n);\n         }\n \n         // At this point we successfully wrote `i + 1` bytes and flushed it out,\n@@ -984,12 +997,17 @@ impl<W: Write> Write for LineWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n+impl<W: Write> fmt::Debug for LineWriter<W>\n+where\n+    W: fmt::Debug,\n+{\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"LineWriter\")\n             .field(\"writer\", &self.inner.inner)\n-            .field(\"buffer\",\n-                   &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()))\n+            .field(\n+                \"buffer\",\n+                &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()),\n+            )\n             .finish()\n     }\n }\n@@ -1008,11 +1026,7 @@ mod tests {\n \n     impl Read for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-            if self.lengths.is_empty() {\n-                Ok(0)\n-            } else {\n-                Ok(self.lengths.remove(0))\n-            }\n+            if self.lengths.is_empty() { Ok(0) } else { Ok(self.lengths.remove(0)) }\n         }\n     }\n \n@@ -1123,7 +1137,7 @@ mod tests {\n     fn test_buffered_reader_seek_underflow() {\n         // gimmick reader that yields its position modulo 256 for each byte\n         struct PositionReader {\n-            pos: u64\n+            pos: u64,\n         }\n         impl Read for PositionReader {\n             fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -1154,7 +1168,7 @@ mod tests {\n \n         let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n         assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n-        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::max_value()-5));\n+        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::max_value() - 5));\n         assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n         // the following seek will require two underlying seeks\n         let expected = 9223372036854775802;\n@@ -1361,7 +1375,7 @@ mod tests {\n \n     #[test]\n     fn test_short_reads() {\n-        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n+        let inner = ShortReader { lengths: vec![0, 1, 2, 0, 1, 0] };\n         let mut reader = BufReader::new(inner);\n         let mut buf = [0, 0];\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n@@ -1379,7 +1393,9 @@ mod tests {\n         struct FailFlushWriter;\n \n         impl Write for FailFlushWriter {\n-            fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+                Ok(buf.len())\n+            }\n             fn flush(&mut self) -> io::Result<()> {\n                 Err(io::Error::last_os_error())\n             }\n@@ -1405,30 +1421,30 @@ mod tests {\n                 WRITES.fetch_add(1, Ordering::SeqCst);\n                 panic!();\n             }\n-            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+            fn flush(&mut self) -> io::Result<()> {\n+                Ok(())\n+            }\n         }\n \n         thread::spawn(|| {\n             let mut writer = BufWriter::new(PanicWriter);\n             let _ = writer.write(b\"hello world\");\n             let _ = writer.flush();\n-        }).join().unwrap_err();\n+        })\n+        .join()\n+        .unwrap_err();\n \n         assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n     }\n \n     #[bench]\n     fn bench_buffered_reader(b: &mut test::Bencher) {\n-        b.iter(|| {\n-            BufReader::new(io::empty())\n-        });\n+        b.iter(|| BufReader::new(io::empty()));\n     }\n \n     #[bench]\n     fn bench_buffered_writer(b: &mut test::Bencher) {\n-        b.iter(|| {\n-            BufWriter::new(io::sink())\n-        });\n+        b.iter(|| BufWriter::new(io::sink()));\n     }\n \n     struct AcceptOneThenFail {\n@@ -1457,10 +1473,7 @@ mod tests {\n \n     #[test]\n     fn erroneous_flush_retried() {\n-        let a = AcceptOneThenFail {\n-            written: false,\n-            flushed: false,\n-        };\n+        let a = AcceptOneThenFail { written: false, flushed: false };\n \n         let mut l = LineWriter::new(a);\n         assert_eq!(l.write(b\"a\\nb\\na\").unwrap(), 4);"}, {"sha": "c20bd3097b27dea93720d637d91db3a814ac85e1", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,8 +1,8 @@\n+use crate::convert::From;\n use crate::error;\n use crate::fmt;\n use crate::result;\n use crate::sys;\n-use crate::convert::From;\n \n /// A specialized [`Result`](../result/enum.Result.html) type for I/O\n /// operations.\n@@ -73,7 +73,7 @@ enum Repr {\n #[derive(Debug)]\n struct Custom {\n     kind: ErrorKind,\n-    error: Box<dyn error::Error+Send+Sync>,\n+    error: Box<dyn error::Error + Send + Sync>,\n }\n \n /// A list specifying general categories of I/O error.\n@@ -220,9 +220,7 @@ impl From<ErrorKind> for Error {\n     /// [`Error`]: ../../std/io/struct.Error.html\n     #[inline]\n     fn from(kind: ErrorKind) -> Error {\n-        Error {\n-            repr: Repr::Simple(kind)\n-        }\n+        Error { repr: Repr::Simple(kind) }\n     }\n }\n \n@@ -247,18 +245,14 @@ impl Error {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<E>(kind: ErrorKind, error: E) -> Error\n-        where E: Into<Box<dyn error::Error+Send+Sync>>\n+    where\n+        E: Into<Box<dyn error::Error + Send + Sync>>,\n     {\n         Self::_new(kind, error.into())\n     }\n \n-    fn _new(kind: ErrorKind, error: Box<dyn error::Error+Send+Sync>) -> Error {\n-        Error {\n-            repr: Repr::Custom(Box::new(Custom {\n-                kind,\n-                error,\n-            }))\n-        }\n+    fn _new(kind: ErrorKind, error: Box<dyn error::Error + Send + Sync>) -> Error {\n+        Error { repr: Repr::Custom(Box::new(Custom { kind, error })) }\n     }\n \n     /// Returns an error representing the last OS error which occurred.\n@@ -370,7 +364,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n-    pub fn get_ref(&self) -> Option<&(dyn error::Error+Send+Sync+'static)> {\n+    pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n@@ -441,7 +435,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n-    pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error+Send+Sync+'static)> {\n+    pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n@@ -475,11 +469,11 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n-    pub fn into_inner(self) -> Option<Box<dyn error::Error+Send+Sync>> {\n+    pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n-            Repr::Custom(c) => Some(c.error)\n+            Repr::Custom(c) => Some(c.error),\n         }\n     }\n \n@@ -514,11 +508,12 @@ impl Error {\n impl fmt::Debug for Repr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            Repr::Os(code) =>\n-                fmt.debug_struct(\"Os\")\n-                    .field(\"code\", &code)\n-                    .field(\"kind\", &sys::decode_error_kind(code))\n-                    .field(\"message\", &sys::os::error_string(code)).finish(),\n+            Repr::Os(code) => fmt\n+                .debug_struct(\"Os\")\n+                .field(\"code\", &code)\n+                .field(\"kind\", &sys::decode_error_kind(code))\n+                .field(\"message\", &sys::os::error_string(code))\n+                .finish(),\n             Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n             Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n         }\n@@ -567,17 +562,17 @@ impl error::Error for Error {\n }\n \n fn _assert_error_is_sync_send() {\n-    fn _is_sync_send<T: Sync+Send>() {}\n+    fn _is_sync_send<T: Sync + Send>() {}\n     _is_sync_send::<Error>();\n }\n \n #[cfg(test)]\n mod test {\n-    use super::{Error, ErrorKind, Repr, Custom};\n+    use super::{Custom, Error, ErrorKind, Repr};\n     use crate::error;\n     use crate::fmt;\n-    use crate::sys::os::error_string;\n     use crate::sys::decode_error_kind;\n+    use crate::sys::os::error_string;\n \n     #[test]\n     fn test_debug_error() {\n@@ -587,20 +582,18 @@ mod test {\n         let err = Error {\n             repr: Repr::Custom(box Custom {\n                 kind: ErrorKind::InvalidInput,\n-                error: box Error {\n-                    repr: super::Repr::Os(code)\n-                },\n-            })\n+                error: box Error { repr: super::Repr::Os(code) },\n+            }),\n         };\n         let expected = format!(\n             \"Custom {{ \\\n-                kind: InvalidInput, \\\n-                error: Os {{ \\\n-                    code: {:?}, \\\n-                    kind: {:?}, \\\n-                    message: {:?} \\\n-                }} \\\n-            }}\",\n+             kind: InvalidInput, \\\n+             error: Os {{ \\\n+             code: {:?}, \\\n+             kind: {:?}, \\\n+             message: {:?} \\\n+             }} \\\n+             }}\",\n             code, kind, msg\n         );\n         assert_eq!(format!(\"{:?}\", err), expected);"}, {"sha": "b7f82e652990d993b27dd6d5c977856884e09bd5", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,8 @@\n use crate::cmp;\n-use crate::io::{self, SeekFrom, Read, Initializer, Write, Seek, BufRead, Error, ErrorKind,\n-        IoSliceMut, IoSlice};\n use crate::fmt;\n+use crate::io::{\n+    self, BufRead, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n+};\n use crate::mem;\n \n // =============================================================================\n@@ -42,15 +43,19 @@ impl<R: Read + ?Sized> Read for &mut R {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write + ?Sized> Write for &mut W {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        (**self).write(buf)\n+    }\n \n     #[inline]\n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         (**self).write_vectored(bufs)\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (**self).flush()\n+    }\n \n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n@@ -65,15 +70,21 @@ impl<W: Write + ?Sized> Write for &mut W {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Seek + ?Sized> Seek for &mut S {\n     #[inline]\n-    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        (**self).seek(pos)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: BufRead + ?Sized> BufRead for &mut B {\n     #[inline]\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        (**self).fill_buf()\n+    }\n \n     #[inline]\n-    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+    fn consume(&mut self, amt: usize) {\n+        (**self).consume(amt)\n+    }\n \n     #[inline]\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -121,15 +132,19 @@ impl<R: Read + ?Sized> Read for Box<R> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write + ?Sized> Write for Box<W> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        (**self).write(buf)\n+    }\n \n     #[inline]\n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         (**self).write_vectored(bufs)\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (**self).flush()\n+    }\n \n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n@@ -144,15 +159,21 @@ impl<W: Write + ?Sized> Write for Box<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Seek + ?Sized> Seek for Box<S> {\n     #[inline]\n-    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        (**self).seek(pos)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: BufRead + ?Sized> BufRead for Box<B> {\n     #[inline]\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        (**self).fill_buf()\n+    }\n \n     #[inline]\n-    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+    fn consume(&mut self, amt: usize) {\n+        (**self).consume(amt)\n+    }\n \n     #[inline]\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -227,8 +248,7 @@ impl Read for &[u8] {\n     #[inline]\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         if buf.len() > self.len() {\n-            return Err(Error::new(ErrorKind::UnexpectedEof,\n-                                  \"failed to fill whole buffer\"));\n+            return Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"));\n         }\n         let (a, b) = self.split_at(buf.len());\n \n@@ -257,10 +277,14 @@ impl Read for &[u8] {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BufRead for &[u8] {\n     #[inline]\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        Ok(*self)\n+    }\n \n     #[inline]\n-    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }\n+    fn consume(&mut self, amt: usize) {\n+        *self = &self[amt..];\n+    }\n }\n \n /// Write is implemented for `&mut [u8]` by copying into the slice, overwriting\n@@ -302,7 +326,9 @@ impl Write for &mut [u8] {\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n /// Write is implemented for `Vec<u8>` by appending to the vector.\n@@ -332,7 +358,9 @@ impl Write for Vec<u8> {\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "20c1c5cd1b8ad9bfa84d9c851e050eaab73a416c", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 89, "deletions": 79, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -261,49 +261,54 @@\n \n use crate::cmp;\n use crate::fmt;\n-use crate::slice;\n-use crate::str;\n use crate::memchr;\n use crate::ops::{Deref, DerefMut};\n use crate::ptr;\n+use crate::slice;\n+use crate::str;\n use crate::sys;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::buffered::{BufReader, BufWriter, LineWriter};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::IntoInnerError;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::cursor::Cursor;\n+pub use self::buffered::{BufReader, BufWriter, LineWriter};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::error::{Result, Error, ErrorKind};\n+pub use self::cursor::Cursor;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::util::{copy, sink, Sink, empty, Empty, repeat, Repeat};\n+pub use self::error::{Error, ErrorKind, Result};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::stdio::{stdin, stdout, stderr, Stdin, Stdout, Stderr};\n+pub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::stdio::{StdoutLock, StderrLock, StdinLock};\n+pub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n #[unstable(feature = \"print_internals\", issue = \"0\")]\n-pub use self::stdio::{_print, _eprint};\n+pub use self::stdio::{_eprint, _print};\n #[unstable(feature = \"libstd_io_internals\", issue = \"42788\")]\n #[doc(no_inline, hidden)]\n pub use self::stdio::{set_panic, set_print};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::util::{copy, empty, repeat, sink, Empty, Repeat, Sink};\n \n-pub mod prelude;\n mod buffered;\n mod cursor;\n mod error;\n mod impls;\n mod lazy;\n-mod util;\n+pub mod prelude;\n mod stdio;\n+mod util;\n \n const DEFAULT_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n \n-struct Guard<'a> { buf: &'a mut Vec<u8>, len: usize }\n+struct Guard<'a> {\n+    buf: &'a mut Vec<u8>,\n+    len: usize,\n+}\n \n impl Drop for Guard<'_> {\n     fn drop(&mut self) {\n-        unsafe { self.buf.set_len(self.len); }\n+        unsafe {\n+            self.buf.set_len(self.len);\n+        }\n     }\n }\n \n@@ -326,15 +331,15 @@ impl Drop for Guard<'_> {\n //    the function only *appends* bytes to the buffer. We'll get undefined\n //    behavior if existing bytes are overwritten to have non-UTF-8 data.\n fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n-    where F: FnOnce(&mut Vec<u8>) -> Result<usize>\n+where\n+    F: FnOnce(&mut Vec<u8>) -> Result<usize>,\n {\n     unsafe {\n         let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };\n         let ret = f(g.buf);\n         if str::from_utf8(&g.buf[g.len..]).is_err() {\n             ret.and_then(|_| {\n-                Err(Error::new(ErrorKind::InvalidData,\n-                               \"stream did not contain valid UTF-8\"))\n+                Err(Error::new(ErrorKind::InvalidData, \"stream did not contain valid UTF-8\"))\n             })\n         } else {\n             g.len = g.buf.len();\n@@ -405,23 +410,17 @@ where\n \n pub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>\n where\n-    F: FnOnce(&mut [u8]) -> Result<usize>\n+    F: FnOnce(&mut [u8]) -> Result<usize>,\n {\n-    let buf = bufs\n-        .iter_mut()\n-        .find(|b| !b.is_empty())\n-        .map_or(&mut [][..], |b| &mut **b);\n+    let buf = bufs.iter_mut().find(|b| !b.is_empty()).map_or(&mut [][..], |b| &mut **b);\n     read(buf)\n }\n \n pub(crate) fn default_write_vectored<F>(write: F, bufs: &[IoSlice<'_>]) -> Result<usize>\n where\n-    F: FnOnce(&[u8]) -> Result<usize>\n+    F: FnOnce(&[u8]) -> Result<usize>,\n {\n-    let buf = bufs\n-        .iter()\n-        .find(|b| !b.is_empty())\n-        .map_or(&[][..], |b| &**b);\n+    let buf = bufs.iter().find(|b| !b.is_empty()).map_or(&[][..], |b| &**b);\n     write(buf)\n }\n \n@@ -767,14 +766,16 @@ pub trait Read {\n         while !buf.is_empty() {\n             match self.read(buf) {\n                 Ok(0) => break,\n-                Ok(n) => { let tmp = buf; buf = &mut tmp[n..]; }\n+                Ok(n) => {\n+                    let tmp = buf;\n+                    buf = &mut tmp[n..];\n+                }\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                 Err(e) => return Err(e),\n             }\n         }\n         if !buf.is_empty() {\n-            Err(Error::new(ErrorKind::UnexpectedEof,\n-                           \"failed to fill whole buffer\"))\n+            Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -815,7 +816,12 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n+    fn by_ref(&mut self) -> &mut Self\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n \n     /// Transforms this `Read` instance to an [`Iterator`] over its bytes.\n     ///\n@@ -852,7 +858,10 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn bytes(self) -> Bytes<Self> where Self: Sized {\n+    fn bytes(self) -> Bytes<Self>\n+    where\n+        Self: Sized,\n+    {\n         Bytes { inner: self }\n     }\n \n@@ -887,7 +896,10 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized {\n+    fn chain<R: Read>(self, next: R) -> Chain<Self, R>\n+    where\n+        Self: Sized,\n+    {\n         Chain { first: self, second: next, done_first: false }\n     }\n \n@@ -923,7 +935,10 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n+    fn take(self, limit: u64) -> Take<Self>\n+    where\n+        Self: Sized,\n+    {\n         Take { inner: self, limit: limit }\n     }\n }\n@@ -1339,8 +1354,9 @@ pub trait Write {\n     fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n         while !buf.is_empty() {\n             match self.write(buf) {\n-                Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n-                                               \"failed to write whole buffer\")),\n+                Ok(0) => {\n+                    return Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"));\n+                }\n                 Ok(n) => buf = &buf[n..],\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                 Err(e) => return Err(e),\n@@ -1444,7 +1460,12 @@ pub trait Write {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n+    fn by_ref(&mut self) -> &mut Self\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n }\n \n /// The `Seek` trait provides a cursor which can be moved within a stream of\n@@ -1601,15 +1622,14 @@ pub enum SeekFrom {\n     Current(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n }\n \n-fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n-                                   -> Result<usize> {\n+fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> Result<usize> {\n     let mut read = 0;\n     loop {\n         let (done, used) = {\n             let available = match r.fill_buf() {\n                 Ok(n) => n,\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n-                Err(e) => return Err(e)\n+                Err(e) => return Err(e),\n             };\n             match memchr::memchr(delim, available) {\n                 Some(i) => {\n@@ -1900,7 +1920,10 @@ pub trait BufRead: Read {\n     /// assert_eq!(split_iter.next(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n+    fn split(self, byte: u8) -> Split<Self>\n+    where\n+        Self: Sized,\n+    {\n         Split { buf: self, delim: byte }\n     }\n \n@@ -1939,7 +1962,10 @@ pub trait BufRead: Read {\n     ///\n     /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn lines(self) -> Lines<Self> where Self: Sized {\n+    fn lines(self) -> Lines<Self>\n+    where\n+        Self: Sized,\n+    {\n         Lines { buf: self }\n     }\n }\n@@ -2035,10 +2061,7 @@ impl<T, U> Chain<T, U> {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<T: fmt::Debug, U: fmt::Debug> fmt::Debug for Chain<T, U> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Chain\")\n-            .field(\"t\", &self.first)\n-            .field(\"u\", &self.second)\n-            .finish()\n+        f.debug_struct(\"Chain\").field(\"t\", &self.first).field(\"u\", &self.second).finish()\n     }\n }\n \n@@ -2066,11 +2089,7 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n \n     unsafe fn initializer(&self) -> Initializer {\n         let initializer = self.first.initializer();\n-        if initializer.should_initialize() {\n-            initializer\n-        } else {\n-            self.second.initializer()\n-        }\n+        if initializer.should_initialize() { initializer } else { self.second.initializer() }\n     }\n }\n \n@@ -2079,19 +2098,17 @@ impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n     fn fill_buf(&mut self) -> Result<&[u8]> {\n         if !self.done_first {\n             match self.first.fill_buf()? {\n-                buf if buf.is_empty() => { self.done_first = true; }\n+                buf if buf.is_empty() => {\n+                    self.done_first = true;\n+                }\n                 buf => return Ok(buf),\n             }\n         }\n         self.second.fill_buf()\n     }\n \n     fn consume(&mut self, amt: usize) {\n-        if !self.done_first {\n-            self.first.consume(amt)\n-        } else {\n-            self.second.consume(amt)\n-        }\n+        if !self.done_first { self.first.consume(amt) } else { self.second.consume(amt) }\n     }\n }\n \n@@ -2137,7 +2154,9 @@ impl<T> Take<T> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn limit(&self) -> u64 { self.limit }\n+    pub fn limit(&self) -> u64 {\n+        self.limit\n+    }\n \n     /// Sets the number of bytes that can be read before this instance will\n     /// return EOF. This is the same as constructing a new `Take` instance, so\n@@ -2351,7 +2370,7 @@ impl<B: BufRead> Iterator for Split<B> {\n                 }\n                 Some(Ok(buf))\n             }\n-            Err(e) => Some(Err(e))\n+            Err(e) => Some(Err(e)),\n         }\n     }\n }\n@@ -2385,16 +2404,16 @@ impl<B: BufRead> Iterator for Lines<B> {\n                 }\n                 Some(Ok(buf))\n             }\n-            Err(e) => Some(Err(e))\n+            Err(e) => Some(Err(e)),\n         }\n     }\n }\n \n #[cfg(test)]\n mod tests {\n+    use super::{repeat, Cursor, SeekFrom};\n     use crate::cmp;\n     use crate::io::prelude::*;\n-    use super::{Cursor, SeekFrom, repeat};\n     use crate::io::{self, IoSlice, IoSliceMut};\n     use crate::mem;\n     use crate::ops::Deref;\n@@ -2509,29 +2528,25 @@ mod tests {\n         let mut buf = [0; 4];\n \n         let mut c = Cursor::new(&b\"\"[..]);\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n-                   io::ErrorKind::UnexpectedEof);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n \n         let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n         c.read_exact(&mut buf).unwrap();\n         assert_eq!(&buf, b\"1234\");\n         c.read_exact(&mut buf).unwrap();\n         assert_eq!(&buf, b\"5678\");\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n-                   io::ErrorKind::UnexpectedEof);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n     }\n \n     #[test]\n     fn read_exact_slice() {\n         let mut buf = [0; 4];\n \n         let mut c = &b\"\"[..];\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n-                   io::ErrorKind::UnexpectedEof);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n \n         let mut c = &b\"123\"[..];\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n-                   io::ErrorKind::UnexpectedEof);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n         // make sure the optimized (early returning) method is being used\n         assert_eq!(&buf, &[0; 4]);\n \n@@ -2558,7 +2573,7 @@ mod tests {\n             fn fill_buf(&mut self) -> io::Result<&[u8]> {\n                 Err(io::Error::new(io::ErrorKind::Other, \"\"))\n             }\n-            fn consume(&mut self, _amt: usize) { }\n+            fn consume(&mut self, _amt: usize) {}\n         }\n \n         let mut buf = [0; 1];\n@@ -2591,11 +2606,9 @@ mod tests {\n     #[test]\n     fn chain_bufread() {\n         let testdata = b\"ABCDEFGHIJKL\";\n-        let chain1 = (&testdata[..3]).chain(&testdata[3..6])\n-                                     .chain(&testdata[6..9])\n-                                     .chain(&testdata[9..]);\n-        let chain2 = (&testdata[..4]).chain(&testdata[4..8])\n-                                     .chain(&testdata[8..]);\n+        let chain1 =\n+            (&testdata[..3]).chain(&testdata[3..6]).chain(&testdata[6..9]).chain(&testdata[9..]);\n+        let chain2 = (&testdata[..4]).chain(&testdata[4..8]).chain(&testdata[8..]);\n         cmp_bufread(chain1, chain2, &testdata[..]);\n     }\n \n@@ -2651,7 +2664,6 @@ mod tests {\n         assert_eq!(c.stream_position()?, 15);\n         assert_eq!(c.stream_position()?, 15);\n \n-\n         c.seek(SeekFrom::Start(7))?;\n         c.seek(SeekFrom::Current(2))?;\n         assert_eq!(c.stream_position()?, 9);\n@@ -2700,9 +2712,7 @@ mod tests {\n         // that will not allocate when the limit has already been reached. In\n         // this case, vec2 never grows.\n         let mut vec2 = Vec::with_capacity(input.len());\n-        ExampleSliceReader { slice: input }\n-            .take(input.len() as u64)\n-            .read_to_end(&mut vec2)?;\n+        ExampleSliceReader { slice: input }.take(input.len() as u64).read_to_end(&mut vec2)?;\n         assert_eq!(vec2.len(), input.len());\n         assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n "}, {"sha": "3baab2be37795f390cb01eda75cb17d1aefb01e4", "filename": "src/libstd/io/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -11,4 +11,4 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use super::{Read, Write, BufRead, Seek};\n+pub use super::{BufRead, Read, Seek, Write};"}, {"sha": "b09161b97aa5e8d2cd67fc7ef8da53e100146bae", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n #![allow(missing_copy_implementations)]\n \n use crate::fmt;\n-use crate::io::{self, Read, Initializer, Write, ErrorKind, BufRead, IoSlice, IoSliceMut};\n+use crate::io::{self, BufRead, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Write};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -41,15 +41,19 @@ use crate::mem::MaybeUninit;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n-    where R: Read, W: Write\n+where\n+    R: Read,\n+    W: Write,\n {\n     let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n     // FIXME(#53491): This is calling `get_mut` and `get_ref` on an uninitialized\n     // `MaybeUninit`. Revisit this once we decided whether that is valid or not.\n     // This is still technically undefined behavior due to creating a reference\n     // to uninitialized data, but within libstd we can rely on more guarantees\n     // than if this code were in an external lib.\n-    unsafe { reader.initializer().initialize(buf.get_mut()); }\n+    unsafe {\n+        reader.initializer().initialize(buf.get_mut());\n+    }\n \n     let mut written = 0;\n     loop {\n@@ -71,7 +75,9 @@ pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<\n ///\n /// [`empty`]: fn.empty.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Empty { _priv: () }\n+pub struct Empty {\n+    _priv: (),\n+}\n \n /// Constructs a new handle to an empty reader.\n ///\n@@ -91,12 +97,16 @@ pub struct Empty { _priv: () }\n /// assert!(buffer.is_empty());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn empty() -> Empty { Empty { _priv: () } }\n+pub fn empty() -> Empty {\n+    Empty { _priv: () }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Empty {\n     #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> { Ok(0) }\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n+    }\n \n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n@@ -106,7 +116,9 @@ impl Read for Empty {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BufRead for Empty {\n     #[inline]\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(&[]) }\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        Ok(&[])\n+    }\n     #[inline]\n     fn consume(&mut self, _n: usize) {}\n }\n@@ -125,7 +137,9 @@ impl fmt::Debug for Empty {\n ///\n /// [repeat]: fn.repeat.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Repeat { byte: u8 }\n+pub struct Repeat {\n+    byte: u8,\n+}\n \n /// Creates an instance of a reader that infinitely repeats one byte.\n ///\n@@ -142,7 +156,9 @@ pub struct Repeat { byte: u8 }\n /// assert_eq!(buffer, [0b101, 0b101, 0b101]);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn repeat(byte: u8) -> Repeat { Repeat { byte } }\n+pub fn repeat(byte: u8) -> Repeat {\n+    Repeat { byte }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Repeat {\n@@ -183,7 +199,9 @@ impl fmt::Debug for Repeat {\n ///\n /// [sink]: fn.sink.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Sink { _priv: () }\n+pub struct Sink {\n+    _priv: (),\n+}\n \n /// Creates an instance of a writer which will successfully consume all data.\n ///\n@@ -200,12 +218,16 @@ pub struct Sink { _priv: () }\n /// assert_eq!(num_bytes, 5);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn sink() -> Sink { Sink { _priv: () } }\n+pub fn sink() -> Sink {\n+    Sink { _priv: () }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Sink {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        Ok(buf.len())\n+    }\n \n     #[inline]\n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n@@ -214,7 +236,9 @@ impl Write for Sink {\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -227,7 +251,7 @@ impl fmt::Debug for Sink {\n #[cfg(test)]\n mod tests {\n     use crate::io::prelude::*;\n-    use crate::io::{copy, sink, empty, repeat};\n+    use crate::io::{copy, empty, repeat, sink};\n \n     #[test]\n     fn copy_copies() {"}, {"sha": "11850a1b5fc3884200dc12eb5ec131384629d845", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -313,9 +313,8 @@ macro_rules! dbg {\n \n #[cfg(test)]\n macro_rules! assert_approx_eq {\n-    ($a:expr, $b:expr) => ({\n+    ($a:expr, $b:expr) => {{\n         let (a, b) = (&$a, &$b);\n-        assert!((*a - *b).abs() < 1.0e-6,\n-                \"{} is not approximately equal to {}\", *a, *b);\n-    })\n+        assert!((*a - *b).abs() < 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n+    }};\n }"}, {"sha": "d5f4ece726bea86b9b1ae9a18f686742e422b5c6", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,16 +1,16 @@\n+use crate::convert::TryInto;\n use crate::fmt;\n use crate::hash;\n use crate::io;\n+use crate::iter;\n use crate::mem;\n-use crate::net::{ntoh, hton, IpAddr, Ipv4Addr, Ipv6Addr};\n+use crate::net::{hton, ntoh, IpAddr, Ipv4Addr, Ipv6Addr};\n use crate::option;\n+use crate::slice;\n use crate::sys::net::netc as c;\n-use crate::sys_common::{FromInner, AsInner, IntoInner};\n use crate::sys_common::net::LookupHost;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::vec;\n-use crate::iter;\n-use crate::slice;\n-use crate::convert::TryInto;\n \n /// An internet socket address, either IPv4 or IPv6.\n ///\n@@ -74,7 +74,9 @@ pub enum SocketAddr {\n /// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV4 { inner: c::sockaddr_in }\n+pub struct SocketAddrV4 {\n+    inner: c::sockaddr_in,\n+}\n \n /// An IPv6 socket address.\n ///\n@@ -104,7 +106,9 @@ pub struct SocketAddrV4 { inner: c::sockaddr_in }\n /// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV6 { inner: c::sockaddr_in6 }\n+pub struct SocketAddrV6 {\n+    inner: c::sockaddr_in6,\n+}\n \n impl SocketAddr {\n     /// Creates a new socket address from an [IP address] and a port number.\n@@ -274,7 +278,7 @@ impl SocketAddrV4 {\n                 sin_family: c::AF_INET as c::sa_family_t,\n                 sin_port: hton(port),\n                 sin_addr: *ip.as_inner(),\n-                .. unsafe { mem::zeroed() }\n+                ..unsafe { mem::zeroed() }\n             },\n         }\n     }\n@@ -291,9 +295,7 @@ impl SocketAddrV4 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv4Addr {\n-        unsafe {\n-            &*(&self.inner.sin_addr as *const c::in_addr as *const Ipv4Addr)\n-        }\n+        unsafe { &*(&self.inner.sin_addr as *const c::in_addr as *const Ipv4Addr) }\n     }\n \n     /// Changes the IP address associated with this socket address.\n@@ -362,16 +364,15 @@ impl SocketAddrV6 {\n     /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32)\n-               -> SocketAddrV6 {\n+    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n         SocketAddrV6 {\n             inner: c::sockaddr_in6 {\n                 sin6_family: c::AF_INET6 as c::sa_family_t,\n                 sin6_port: hton(port),\n                 sin6_addr: *ip.as_inner(),\n                 sin6_flowinfo: flowinfo,\n                 sin6_scope_id: scope_id,\n-                .. unsafe { mem::zeroed() }\n+                ..unsafe { mem::zeroed() }\n             },\n         }\n     }\n@@ -388,9 +389,7 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv6Addr {\n-        unsafe {\n-            &*(&self.inner.sin6_addr as *const c::in6_addr as *const Ipv6Addr)\n-        }\n+        unsafe { &*(&self.inner.sin6_addr as *const c::in6_addr as *const Ipv6Addr) }\n     }\n \n     /// Changes the IP address associated with this socket address.\n@@ -633,27 +632,31 @@ impl fmt::Debug for SocketAddrV6 {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for SocketAddrV4 {\n-    fn clone(&self) -> SocketAddrV4 { *self }\n+    fn clone(&self) -> SocketAddrV4 {\n+        *self\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for SocketAddrV6 {\n-    fn clone(&self) -> SocketAddrV6 { *self }\n+    fn clone(&self) -> SocketAddrV6 {\n+        *self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for SocketAddrV4 {\n     fn eq(&self, other: &SocketAddrV4) -> bool {\n-        self.inner.sin_port == other.inner.sin_port &&\n-            self.inner.sin_addr.s_addr == other.inner.sin_addr.s_addr\n+        self.inner.sin_port == other.inner.sin_port\n+            && self.inner.sin_addr.s_addr == other.inner.sin_addr.s_addr\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for SocketAddrV6 {\n     fn eq(&self, other: &SocketAddrV6) -> bool {\n-        self.inner.sin6_port == other.inner.sin6_port &&\n-            self.inner.sin6_addr.s6_addr == other.inner.sin6_addr.s6_addr &&\n-            self.inner.sin6_flowinfo == other.inner.sin6_flowinfo &&\n-            self.inner.sin6_scope_id == other.inner.sin6_scope_id\n+        self.inner.sin6_port == other.inner.sin6_port\n+            && self.inner.sin6_addr.s6_addr == other.inner.sin6_addr.s6_addr\n+            && self.inner.sin6_flowinfo == other.inner.sin6_flowinfo\n+            && self.inner.sin6_scope_id == other.inner.sin6_scope_id\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -670,8 +673,13 @@ impl hash::Hash for SocketAddrV4 {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for SocketAddrV6 {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        (self.inner.sin6_port, &self.inner.sin6_addr.s6_addr,\n-         self.inner.sin6_flowinfo, self.inner.sin6_scope_id).hash(s)\n+        (\n+            self.inner.sin6_port,\n+            &self.inner.sin6_addr.s6_addr,\n+            self.inner.sin6_flowinfo,\n+            self.inner.sin6_scope_id,\n+        )\n+            .hash(s)\n     }\n }\n \n@@ -795,7 +803,7 @@ pub trait ToSocketAddrs {\n     /// Returned iterator over socket addresses which this type may correspond\n     /// to.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Iter: Iterator<Item=SocketAddr>;\n+    type Iter: Iterator<Item = SocketAddr>;\n \n     /// Converts this object to an iterator of resolved `SocketAddr`s.\n     ///\n@@ -864,7 +872,12 @@ impl ToSocketAddrs for (Ipv6Addr, u16) {\n \n fn resolve_socket_addr(lh: LookupHost) -> io::Result<vec::IntoIter<SocketAddr>> {\n     let p = lh.port();\n-    let v: Vec<_> = lh.map(|mut a| { a.set_port(p); a }).collect();\n+    let v: Vec<_> = lh\n+        .map(|mut a| {\n+            a.set_port(p);\n+            a\n+        })\n+        .collect();\n     Ok(v.into_iter())\n }\n \n@@ -877,11 +890,11 @@ impl ToSocketAddrs for (&str, u16) {\n         // try to parse the host as a regular IP address first\n         if let Ok(addr) = host.parse::<Ipv4Addr>() {\n             let addr = SocketAddrV4::new(addr, port);\n-            return Ok(vec![SocketAddr::V4(addr)].into_iter())\n+            return Ok(vec![SocketAddr::V4(addr)].into_iter());\n         }\n         if let Ok(addr) = host.parse::<Ipv6Addr>() {\n             let addr = SocketAddrV6::new(addr, port, 0, 0);\n-            return Ok(vec![SocketAddr::V6(addr)].into_iter())\n+            return Ok(vec![SocketAddr::V6(addr)].into_iter());\n         }\n \n         resolve_socket_addr((host, port).try_into()?)\n@@ -929,8 +942,8 @@ impl ToSocketAddrs for String {\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n+    use crate::net::test::{sa4, sa6, tsa};\n     use crate::net::*;\n-    use crate::net::test::{tsa, sa6, sa4};\n \n     #[test]\n     fn to_socket_addr_ipaddr_u16() {\n@@ -991,8 +1004,12 @@ mod tests {\n \n     #[test]\n     fn set_ip() {\n-        fn ip4(low: u8) -> Ipv4Addr { Ipv4Addr::new(77, 88, 21, low) }\n-        fn ip6(low: u16) -> Ipv6Addr { Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low) }\n+        fn ip4(low: u8) -> Ipv4Addr {\n+            Ipv4Addr::new(77, 88, 21, low)\n+        }\n+        fn ip6(low: u16) -> Ipv6Addr {\n+            Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low)\n+        }\n \n         let mut v4 = SocketAddrV4::new(ip4(11), 80);\n         assert_eq!(v4.ip(), &ip4(11));\n@@ -1068,7 +1085,11 @@ mod tests {\n     #[test]\n     fn is_v6() {\n         let v6 = SocketAddr::V6(SocketAddrV6::new(\n-                Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 10, 0));\n+            Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1),\n+            80,\n+            10,\n+            0,\n+        ));\n         assert!(!v6.is_ipv4());\n         assert!(v6.is_ipv6());\n     }"}, {"sha": "8106d1c3315aaec9bd6a3731a54f4818a4375e95", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -16,18 +16,16 @@ struct Parser<'a> {\n \n impl<'a> Parser<'a> {\n     fn new(s: &'a str) -> Parser<'a> {\n-        Parser {\n-            s: s.as_bytes(),\n-            pos: 0,\n-        }\n+        Parser { s: s.as_bytes(), pos: 0 }\n     }\n \n     fn is_eof(&self) -> bool {\n         self.pos == self.s.len()\n     }\n \n     // Commit only if parser returns Some\n-    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where\n+    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T>\n+    where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n         let pos = self.pos;\n@@ -39,17 +37,18 @@ impl<'a> Parser<'a> {\n     }\n \n     // Commit only if parser read till EOF\n-    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where\n+    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T>\n+    where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_atomically(move |p| {\n-            cb(p).filter(|_| p.is_eof())\n-        })\n+        self.read_atomically(move |p| cb(p).filter(|_| p.is_eof()))\n     }\n \n     // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &mut [Box<dyn FnMut(&mut Parser<'_>) -> Option<T> + 'static>])\n-               -> Option<T> {\n+    fn read_or<T>(\n+        &mut self,\n+        parsers: &mut [Box<dyn FnMut(&mut Parser<'_>) -> Option<T> + 'static>],\n+    ) -> Option<T> {\n         for pf in parsers {\n             if let Some(r) = self.read_atomically(|p: &mut Parser<'_>| pf(p)) {\n                 return Some(r);\n@@ -59,11 +58,8 @@ impl<'a> Parser<'a> {\n     }\n \n     // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,\n-                                       pa: PA,\n-                                       pb: PB,\n-                                       pc: PC)\n-                                       -> Option<(A, B, C)> where\n+    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self, pa: PA, pb: PB, pc: PC) -> Option<(A, B, C)>\n+    where\n         PA: FnOnce(&mut Parser<'_>) -> Option<A>,\n         PB: FnOnce(&mut Parser<'_>) -> Option<B>,\n         PC: FnOnce(&mut Parser<'_>) -> Option<C>,\n@@ -74,7 +70,7 @@ impl<'a> Parser<'a> {\n             let c = if b.is_some() { pc(p) } else { None };\n             match (a, b, c) {\n                 (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n-                _ => None\n+                _ => None,\n             }\n         })\n     }\n@@ -92,11 +88,9 @@ impl<'a> Parser<'a> {\n \n     // Return char and advance iff next char is equal to requested\n     fn read_given_char(&mut self, c: char) -> Option<char> {\n-        self.read_atomically(|p| {\n-            match p.read_char() {\n-                Some(next) if next == c => Some(next),\n-                _ => None,\n-            }\n+        self.read_atomically(|p| match p.read_char() {\n+            Some(next) if next == c => Some(next),\n+            _ => None,\n         })\n     }\n \n@@ -116,9 +110,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        self.read_atomically(|p| {\n-            p.read_char().and_then(|c| parse_digit(c, radix))\n-        })\n+        self.read_atomically(|p| p.read_char().and_then(|c| parse_digit(c, radix)))\n     }\n \n     fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n@@ -130,14 +122,14 @@ impl<'a> Parser<'a> {\n                     r = r * (radix as u32) + (d as u32);\n                     digit_count += 1;\n                     if digit_count > max_digits || r >= upto {\n-                        return None\n+                        return None;\n                     }\n                 }\n                 None => {\n                     if digit_count == 0 {\n-                        return None\n+                        return None;\n                     } else {\n-                        return Some(r)\n+                        return Some(r);\n                     }\n                 }\n             };\n@@ -173,12 +165,11 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0; 8];\n             gs[..head.len()].copy_from_slice(head);\n-            gs[(8 - tail.len()) .. 8].copy_from_slice(tail);\n+            gs[(8 - tail.len())..8].copy_from_slice(tail);\n             Ipv6Addr::new(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n \n-        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16; 8], limit: usize)\n-                       -> (usize, bool) {\n+        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n             let mut i = 0;\n             while i < limit {\n                 if i < limit - 1 {\n@@ -206,7 +197,7 @@ impl<'a> Parser<'a> {\n                 });\n                 match group {\n                     Some(g) => groups[i] = g,\n-                    None => return (i, false)\n+                    None => return (i, false),\n                 }\n                 i += 1;\n             }\n@@ -218,13 +209,13 @@ impl<'a> Parser<'a> {\n \n         if head_size == 8 {\n             return Some(Ipv6Addr::new(\n-                head[0], head[1], head[2], head[3],\n-                head[4], head[5], head[6], head[7]))\n+                head[0], head[1], head[2], head[3], head[4], head[5], head[6], head[7],\n+            ));\n         }\n \n         // IPv4 part is not allowed before `::`\n         if head_ipv4 {\n-            return None\n+            return None;\n         }\n \n         // read `::` if previous code parsed less than 8 groups\n@@ -252,9 +243,7 @@ impl<'a> Parser<'a> {\n     fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n         let ip_addr = |p: &mut Parser<'_>| p.read_ipv4_addr();\n         let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| {\n-            p.read_number(10, 5, 0x10000).map(|n| n as u16)\n-        };\n+        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n \n         self.read_seq_3(ip_addr, colon, port).map(|t| {\n             let (ip, _, port): (Ipv4Addr, char, u16) = t;\n@@ -270,9 +259,7 @@ impl<'a> Parser<'a> {\n             p.read_seq_3(open_br, ip_addr, clos_br).map(|t| t.1)\n         };\n         let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| {\n-            p.read_number(10, 5, 0x10000).map(|n| n as u16)\n-        };\n+        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n \n         self.read_seq_3(ip_addr, colon, port).map(|t| {\n             let (ip, _, port): (Ipv6Addr, char, u16) = t;\n@@ -293,7 +280,7 @@ impl FromStr for IpAddr {\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n         match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n             Some(s) => Ok(s),\n-            None => Err(AddrParseError(()))\n+            None => Err(AddrParseError(())),\n         }\n     }\n }\n@@ -304,7 +291,7 @@ impl FromStr for Ipv4Addr {\n     fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n         match Parser::new(s).read_till_eof(|p| p.read_ipv4_addr()) {\n             Some(s) => Ok(s),\n-            None => Err(AddrParseError(()))\n+            None => Err(AddrParseError(())),\n         }\n     }\n }\n@@ -315,7 +302,7 @@ impl FromStr for Ipv6Addr {\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n         match Parser::new(s).read_till_eof(|p| p.read_ipv6_addr()) {\n             Some(s) => Ok(s),\n-            None => Err(AddrParseError(()))\n+            None => Err(AddrParseError(())),\n         }\n     }\n }"}, {"sha": "5c02215997088cfadaea32f2128218c2e4589d7a", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 146, "deletions": 93, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,7 +2,7 @@ use crate::io::prelude::*;\n \n use crate::fmt;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n-use crate::net::{ToSocketAddrs, SocketAddr, Shutdown};\n+use crate::net::{Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n@@ -93,7 +93,9 @@ pub struct TcpListener(net_imp::TcpListener);\n /// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct Incoming<'a> { listener: &'a TcpListener }\n+pub struct Incoming<'a> {\n+    listener: &'a TcpListener,\n+}\n \n impl TcpStream {\n     /// Opens a TCP connection to a remote host.\n@@ -567,7 +569,9 @@ impl TcpStream {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n@@ -580,17 +584,23 @@ impl Read for TcpStream {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         self.0.write_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for &TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n@@ -603,25 +613,35 @@ impl Read for &TcpStream {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for &TcpStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         self.0.write_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n impl AsInner<net_imp::TcpStream> for TcpStream {\n-    fn as_inner(&self) -> &net_imp::TcpStream { &self.0 }\n+    fn as_inner(&self) -> &net_imp::TcpStream {\n+        &self.0\n+    }\n }\n \n impl FromInner<net_imp::TcpStream> for TcpStream {\n-    fn from_inner(inner: net_imp::TcpStream) -> TcpStream { TcpStream(inner) }\n+    fn from_inner(inner: net_imp::TcpStream) -> TcpStream {\n+        TcpStream(inner)\n+    }\n }\n \n impl IntoInner<net_imp::TcpStream> for TcpStream {\n-    fn into_inner(self) -> net_imp::TcpStream { self.0 }\n+    fn into_inner(self) -> net_imp::TcpStream {\n+        self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -814,16 +834,20 @@ impl TcpListener {\n     }\n \n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n-    #[rustc_deprecated(since = \"1.16.0\",\n-                       reason = \"this option can only be set before the socket is bound\")]\n+    #[rustc_deprecated(\n+        since = \"1.16.0\",\n+        reason = \"this option can only be set before the socket is bound\"\n+    )]\n     #[allow(missing_docs)]\n     pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n         self.0.set_only_v6(only_v6)\n     }\n \n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n-    #[rustc_deprecated(since = \"1.16.0\",\n-                       reason = \"this option can only be set before the socket is bound\")]\n+    #[rustc_deprecated(\n+        since = \"1.16.0\",\n+        reason = \"this option can only be set before the socket is bound\"\n+    )]\n     #[allow(missing_docs)]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n@@ -907,7 +931,9 @@ impl<'a> Iterator for Incoming<'a> {\n }\n \n impl AsInner<net_imp::TcpListener> for TcpListener {\n-    fn as_inner(&self) -> &net_imp::TcpListener { &self.0 }\n+    fn as_inner(&self) -> &net_imp::TcpListener {\n+        &self.0\n+    }\n }\n \n impl FromInner<net_imp::TcpListener> for TcpListener {\n@@ -917,7 +943,9 @@ impl FromInner<net_imp::TcpListener> for TcpListener {\n }\n \n impl IntoInner<net_imp::TcpListener> for TcpListener {\n-    fn into_inner(self) -> net_imp::TcpListener { self.0 }\n+    fn into_inner(self) -> net_imp::TcpListener {\n+        self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -930,13 +958,13 @@ impl fmt::Debug for TcpListener {\n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n     use crate::fmt;\n-    use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n     use crate::io::prelude::*;\n-    use crate::net::*;\n+    use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n     use crate::net::test::{next_test_ip4, next_test_ip6};\n+    use crate::net::*;\n     use crate::sync::mpsc::channel;\n-    use crate::time::{Instant, Duration};\n     use crate::thread;\n+    use crate::time::{Duration, Instant};\n \n     fn each_ip(f: &mut dyn FnMut(SocketAddr)) {\n         f(next_test_ip4());\n@@ -949,27 +977,30 @@ mod tests {\n                 Ok(t) => t,\n                 Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n             }\n-        }\n+        };\n     }\n \n     #[test]\n     fn bind_error() {\n         match TcpListener::bind(\"1.1.1.1:9999\") {\n             Ok(..) => panic!(),\n-            Err(e) =>\n-                assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n         }\n     }\n \n     #[test]\n     fn connect_error() {\n         match TcpStream::connect(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n-            Err(e) => assert!(e.kind() == ErrorKind::ConnectionRefused ||\n-                              e.kind() == ErrorKind::InvalidInput ||\n-                              e.kind() == ErrorKind::AddrInUse ||\n-                              e.kind() == ErrorKind::AddrNotAvailable,\n-                              \"bad error: {} {:?}\", e, e.kind()),\n+            Err(e) => assert!(\n+                e.kind() == ErrorKind::ConnectionRefused\n+                    || e.kind() == ErrorKind::InvalidInput\n+                    || e.kind() == ErrorKind::AddrInUse\n+                    || e.kind() == ErrorKind::AddrNotAvailable,\n+                \"bad error: {} {:?}\",\n+                e,\n+                e.kind()\n+            ),\n         }\n     }\n \n@@ -979,8 +1010,7 @@ mod tests {\n         let listener = t!(TcpListener::bind(&socket_addr));\n \n         let _t = thread::spawn(move || {\n-            let mut stream = t!(TcpStream::connect(&(\"localhost\",\n-                                                     socket_addr.port())));\n+            let mut stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n             t!(stream.write(&[144]));\n         });\n \n@@ -995,7 +1025,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let host = match addr {\n                     SocketAddr::V4(..) => \"127.0.0.1\",\n                     SocketAddr::V6(..) => \"::1\",\n@@ -1017,7 +1047,7 @@ mod tests {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n             let (tx, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 t!(stream.write(&[99]));\n                 tx.send(t!(stream.local_addr())).unwrap();\n@@ -1036,7 +1066,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _stream = t!(TcpStream::connect(&addr));\n                 // Close\n             });\n@@ -1056,7 +1086,7 @@ mod tests {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n             let (tx, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(t!(TcpStream::connect(&addr)));\n                 tx.send(()).unwrap();\n             });\n@@ -1067,10 +1097,13 @@ mod tests {\n             match stream.write(&buf) {\n                 Ok(..) => {}\n                 Err(e) => {\n-                    assert!(e.kind() == ErrorKind::ConnectionReset ||\n-                            e.kind() == ErrorKind::BrokenPipe ||\n-                            e.kind() == ErrorKind::ConnectionAborted,\n-                            \"unknown error: {}\", e);\n+                    assert!(\n+                        e.kind() == ErrorKind::ConnectionReset\n+                            || e.kind() == ErrorKind::BrokenPipe\n+                            || e.kind() == ErrorKind::ConnectionAborted,\n+                        \"unknown error: {}\",\n+                        e\n+                    );\n                 }\n             }\n         })\n@@ -1082,7 +1115,7 @@ mod tests {\n             let max = 10;\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 for _ in 0..max {\n                     let mut stream = t!(TcpStream::connect(&addr));\n                     t!(stream.write(&[99]));\n@@ -1104,11 +1137,11 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let acceptor = acceptor;\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n                     // Start another thread to handle the connection\n-                    let _t = thread::spawn(move|| {\n+                    let _t = thread::spawn(move || {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n                         t!(stream.read(&mut buf));\n@@ -1121,9 +1154,11 @@ mod tests {\n         });\n \n         fn connect(i: usize, addr: SocketAddr) {\n-            if i == MAX { return }\n+            if i == MAX {\n+                return;\n+            }\n \n-            let t = thread::spawn(move|| {\n+            let t = thread::spawn(move || {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 // Connect again before writing\n                 connect(i + 1, addr);\n@@ -1139,10 +1174,10 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 for stream in acceptor.incoming().take(MAX) {\n                     // Start another thread to handle the connection\n-                    let _t = thread::spawn(move|| {\n+                    let _t = thread::spawn(move || {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n                         t!(stream.read(&mut buf));\n@@ -1155,9 +1190,11 @@ mod tests {\n         });\n \n         fn connect(i: usize, addr: SocketAddr) {\n-            if i == MAX { return }\n+            if i == MAX {\n+                return;\n+            }\n \n-            let t = thread::spawn(move|| {\n+            let t = thread::spawn(move || {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 connect(i + 1, addr);\n                 t!(stream.write(&[99]));\n@@ -1172,7 +1209,7 @@ mod tests {\n             let listener = t!(TcpListener::bind(&addr));\n             let so_name = t!(listener.local_addr());\n             assert_eq!(addr, so_name);\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 t!(listener.accept());\n             });\n \n@@ -1186,7 +1223,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let (tx, rx) = channel();\n             let srv = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut cl = t!(srv.accept()).0;\n                 cl.write(&[10]).unwrap();\n                 let mut b = [0];\n@@ -1215,9 +1252,11 @@ mod tests {\n             let mut a = [];\n             let mut b = [0];\n             let mut c = [0; 3];\n-            let len = t!(s2.read_vectored(\n-                &mut [IoSliceMut::new(&mut a), IoSliceMut::new(&mut b), IoSliceMut::new(&mut c)],\n-            ));\n+            let len = t!(s2.read_vectored(&mut [\n+                IoSliceMut::new(&mut a),\n+                IoSliceMut::new(&mut b),\n+                IoSliceMut::new(&mut c)\n+            ],));\n             assert!(len > 0);\n             assert_eq!(b, [10]);\n             // some implementations don't support readv, so we may only fill the first buffer\n@@ -1260,10 +1299,14 @@ mod tests {\n                     listener1, listener2\n                 ),\n                 Err(e) => {\n-                    assert!(e.kind() == ErrorKind::ConnectionRefused ||\n-                            e.kind() == ErrorKind::Other ||\n-                            e.kind() == ErrorKind::AddrInUse,\n-                            \"unknown error: {} {:?}\", e, e.kind());\n+                    assert!(\n+                        e.kind() == ErrorKind::ConnectionRefused\n+                            || e.kind() == ErrorKind::Other\n+                            || e.kind() == ErrorKind::AddrInUse,\n+                        \"unknown error: {} {:?}\",\n+                        e,\n+                        e.kind()\n+                    );\n                 }\n             }\n         })\n@@ -1274,7 +1317,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 t!(TcpStream::connect(&addr));\n             });\n \n@@ -1289,7 +1332,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 0];\n                 assert_eq!(s.read(&mut buf).unwrap(), 1);\n@@ -1302,7 +1345,7 @@ mod tests {\n \n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s2 = s2;\n                 rx1.recv().unwrap();\n                 t!(s2.write(&[1]));\n@@ -1322,7 +1365,7 @@ mod tests {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 t!(s.write(&[1]));\n                 rx.recv().unwrap();\n@@ -1334,7 +1377,7 @@ mod tests {\n             let s2 = t!(s1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s2 = s2;\n                 let mut buf = [0, 0];\n                 t!(s2.read(&mut buf));\n@@ -1354,7 +1397,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 1];\n                 t!(s.read(&mut buf));\n@@ -1365,7 +1408,7 @@ mod tests {\n             let s2 = t!(s1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s2 = s2;\n                 t!(s2.write(&[1]));\n                 done.send(()).unwrap();\n@@ -1382,7 +1425,7 @@ mod tests {\n     fn shutdown_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut c = t!(a.accept()).0;\n                 let mut b = [0];\n                 assert_eq!(c.read(&mut b).unwrap(), 0);\n@@ -1405,7 +1448,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n             let (tx, rx) = channel::<()>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _s = t!(a.accept());\n                 let _ = rx.recv();\n             });\n@@ -1444,15 +1487,15 @@ mod tests {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n             let (tx1, rx) = channel::<()>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _s = t!(a.accept());\n                 let _ = rx.recv();\n             });\n \n             let s = t!(TcpStream::connect(&addr));\n             let s2 = t!(s.try_clone());\n             let (tx, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s2 = s2;\n                 assert_eq!(t!(s2.read(&mut [0])), 0);\n                 tx.send(()).unwrap();\n@@ -1475,7 +1518,7 @@ mod tests {\n             let (tx, rx) = channel();\n             let (txdone, rxdone) = channel();\n             let txdone2 = txdone.clone();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut tcp = t!(TcpStream::connect(&addr));\n                 rx.recv().unwrap();\n                 t!(tcp.write(&[0]));\n@@ -1486,7 +1529,7 @@ mod tests {\n             let tcp = t!(accept.accept()).0;\n             let tcp2 = t!(tcp.try_clone());\n             let txdone3 = txdone.clone();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut tcp2 = tcp2;\n                 t!(tcp2.read(&mut [0]));\n                 txdone3.send(()).unwrap();\n@@ -1512,10 +1555,10 @@ mod tests {\n             let a = t!(TcpListener::bind(&addr));\n             let a2 = t!(a.try_clone());\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _ = TcpStream::connect(&addr);\n             });\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _ = TcpStream::connect(&addr);\n             });\n \n@@ -1533,17 +1576,17 @@ mod tests {\n             let (tx, rx) = channel();\n             let tx2 = tx.clone();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 tx.send(t!(a.accept())).unwrap();\n             });\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 tx2.send(t!(a2.accept())).unwrap();\n             });\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _ = TcpStream::connect(&addr);\n             });\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _ = TcpStream::connect(&addr);\n             });\n \n@@ -1563,10 +1606,10 @@ mod tests {\n             addr.to_string()\n         }\n \n-        #[cfg(unix)]\n-        use crate::os::unix::io::AsRawFd;\n         #[cfg(target_env = \"sgx\")]\n         use crate::os::fortanix_sgx::io::AsRawFd;\n+        #[cfg(unix)]\n+        use crate::os::unix::io::AsRawFd;\n         #[cfg(not(windows))]\n         fn render_inner(addr: &dyn AsRawFd) -> impl fmt::Debug {\n             addr.as_raw_fd()\n@@ -1576,22 +1619,26 @@ mod tests {\n             addr.as_raw_socket()\n         }\n \n-        let inner_name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        let inner_name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n         let socket_addr = next_test_ip4();\n \n         let listener = t!(TcpListener::bind(&socket_addr));\n-        let compare = format!(\"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n-                              render_socket_addr(&socket_addr),\n-                              inner_name,\n-                              render_inner(&listener));\n+        let compare = format!(\n+            \"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n+            render_socket_addr(&socket_addr),\n+            inner_name,\n+            render_inner(&listener)\n+        );\n         assert_eq!(format!(\"{:?}\", listener), compare);\n \n         let stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n-        let compare = format!(\"TcpStream {{ addr: {:?}, peer: {:?}, {}: {:?} }}\",\n-                              render_socket_addr(&stream.local_addr().unwrap()),\n-                              render_socket_addr(&stream.peer_addr().unwrap()),\n-                              inner_name,\n-                              render_inner(&stream));\n+        let compare = format!(\n+            \"TcpStream {{ addr: {:?}, peer: {:?}, {}: {:?} }}\",\n+            render_socket_addr(&stream.local_addr().unwrap()),\n+            render_socket_addr(&stream.peer_addr().unwrap()),\n+            inner_name,\n+            render_inner(&stream)\n+        );\n         assert_eq!(format!(\"{:?}\", stream), compare);\n     }\n \n@@ -1638,8 +1685,11 @@ mod tests {\n         let mut buf = [0; 10];\n         let start = Instant::now();\n         let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                \"unexpected_error: {:?}\", kind);\n+        assert!(\n+            kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+            \"unexpected_error: {:?}\",\n+            kind\n+        );\n         assert!(start.elapsed() > Duration::from_millis(400));\n         drop(listener);\n     }\n@@ -1662,8 +1712,11 @@ mod tests {\n \n         let start = Instant::now();\n         let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                \"unexpected_error: {:?}\", kind);\n+        assert!(\n+            kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+            \"unexpected_error: {:?}\",\n+            kind\n+        );\n         assert!(start.elapsed() > Duration::from_millis(400));\n         drop(listener);\n     }\n@@ -1749,9 +1802,9 @@ mod tests {\n             let (txdone, rxdone) = channel();\n \n             let srv = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut cl = t!(srv.accept()).0;\n-                cl.write(&[1,3,3,7]).unwrap();\n+                cl.write(&[1, 3, 3, 7]).unwrap();\n                 t!(rxdone.recv());\n             });\n "}, {"sha": "37937b5ea95410a1f7b94c6e4a3f579fe2c4ebfa", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n #![allow(warnings)] // not used on emscripten\n \n use crate::env;\n-use crate::net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n+use crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n use crate::sync::atomic::{AtomicUsize, Ordering};\n \n static PORT: AtomicUsize = AtomicUsize::new(0);\n@@ -13,8 +13,7 @@ pub fn next_test_ip4() -> SocketAddr {\n \n pub fn next_test_ip6() -> SocketAddr {\n     let port = PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port();\n-    SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1),\n-                                     port, 0, 0))\n+    SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), port, 0, 0))\n }\n \n pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n@@ -41,11 +40,21 @@ fn base_port() -> u16 {\n     } else {\n         env::current_dir().unwrap().into_os_string().into_string().unwrap()\n     };\n-    let dirs = [\"32-opt\", \"32-nopt\",\n-                \"musl-64-opt\", \"cross-opt\",\n-                \"64-opt\", \"64-nopt\", \"64-opt-vg\", \"64-debug-opt\",\n-                \"all-opt\", \"snap3\", \"dist\", \"sgx\"];\n-    dirs.iter().enumerate().find(|&(_, dir)| {\n-        cwd.contains(dir)\n-    }).map(|p| p.0).unwrap_or(0) as u16 * 1000 + 19600\n+    let dirs = [\n+        \"32-opt\",\n+        \"32-nopt\",\n+        \"musl-64-opt\",\n+        \"cross-opt\",\n+        \"64-opt\",\n+        \"64-nopt\",\n+        \"64-opt-vg\",\n+        \"64-debug-opt\",\n+        \"all-opt\",\n+        \"snap3\",\n+        \"dist\",\n+        \"sgx\",\n+    ];\n+    dirs.iter().enumerate().find(|&(_, dir)| cwd.contains(dir)).map(|p| p.0).unwrap_or(0) as u16\n+        * 1000\n+        + 19600\n }"}, {"sha": "0096b827ca456df7bd19801054c3e89fe31ed0a9", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,6 +1,6 @@\n use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n-use crate::net::{ToSocketAddrs, SocketAddr, Ipv4Addr, Ipv6Addr};\n+use crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n@@ -171,12 +171,10 @@ impl UdpSocket {\n     /// socket.send_to(&[0; 10], \"127.0.0.1:4242\").expect(\"couldn't send data\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)\n-                                     -> io::Result<usize> {\n+    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> io::Result<usize> {\n         match addr.to_socket_addrs()?.next() {\n             Some(addr) => self.0.send_to(buf, &addr),\n-            None => Err(Error::new(ErrorKind::InvalidInput,\n-                                   \"no addresses to send data to\")),\n+            None => Err(Error::new(ErrorKind::InvalidInput, \"no addresses to send data to\")),\n         }\n     }\n \n@@ -817,15 +815,21 @@ impl UdpSocket {\n }\n \n impl AsInner<net_imp::UdpSocket> for UdpSocket {\n-    fn as_inner(&self) -> &net_imp::UdpSocket { &self.0 }\n+    fn as_inner(&self) -> &net_imp::UdpSocket {\n+        &self.0\n+    }\n }\n \n impl FromInner<net_imp::UdpSocket> for UdpSocket {\n-    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket { UdpSocket(inner) }\n+    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket {\n+        UdpSocket(inner)\n+    }\n }\n \n impl IntoInner<net_imp::UdpSocket> for UdpSocket {\n-    fn into_inner(self) -> net_imp::UdpSocket { self.0 }\n+    fn into_inner(self) -> net_imp::UdpSocket {\n+        self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -838,12 +842,12 @@ impl fmt::Debug for UdpSocket {\n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n mod tests {\n     use crate::io::ErrorKind;\n-    use crate::net::*;\n     use crate::net::test::{next_test_ip4, next_test_ip6};\n+    use crate::net::*;\n     use crate::sync::mpsc::channel;\n     use crate::sys_common::AsInner;\n-    use crate::time::{Instant, Duration};\n     use crate::thread;\n+    use crate::time::{Duration, Instant};\n \n     fn each_ip(f: &mut dyn FnMut(SocketAddr, SocketAddr)) {\n         f(next_test_ip4(), next_test_ip4());\n@@ -856,16 +860,14 @@ mod tests {\n                 Ok(t) => t,\n                 Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n             }\n-        }\n+        };\n     }\n \n     #[test]\n     fn bind_error() {\n         match UdpSocket::bind(\"1.1.1.1:9999\") {\n             Ok(..) => panic!(),\n-            Err(e) => {\n-                assert_eq!(e.kind(), ErrorKind::AddrNotAvailable)\n-            }\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n         }\n     }\n \n@@ -875,7 +877,7 @@ mod tests {\n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let client = t!(UdpSocket::bind(&client_ip));\n                 rx1.recv().unwrap();\n                 t!(client.send_to(&[99], &server_ip));\n@@ -917,7 +919,7 @@ mod tests {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n             let sock2 = t!(UdpSocket::bind(&addr2));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut buf = [0, 0];\n                 assert_eq!(sock2.recv_from(&mut buf).unwrap(), (1, addr1));\n                 assert_eq!(buf[0], 1);\n@@ -928,7 +930,7 @@ mod tests {\n \n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 rx1.recv().unwrap();\n                 t!(sock3.send_to(&[1], &addr2));\n                 tx2.send(()).unwrap();\n@@ -948,7 +950,7 @@ mod tests {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 t!(sock2.send_to(&[1], &addr1));\n                 rx.recv().unwrap();\n                 t!(sock2.send_to(&[2], &addr1));\n@@ -958,7 +960,7 @@ mod tests {\n             let sock3 = t!(sock1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut buf = [0, 0];\n                 t!(sock3.recv_from(&mut buf));\n                 tx2.send(()).unwrap();\n@@ -981,7 +983,7 @@ mod tests {\n             let (tx, rx) = channel();\n             let (serv_tx, serv_rx) = channel();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut buf = [0, 1];\n                 rx.recv().unwrap();\n                 t!(sock2.recv_from(&mut buf));\n@@ -992,15 +994,19 @@ mod tests {\n \n             let (done, rx) = channel();\n             let tx2 = tx.clone();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 match sock3.send_to(&[1], &addr2) {\n-                    Ok(..) => { let _ = tx2.send(()); }\n+                    Ok(..) => {\n+                        let _ = tx2.send(());\n+                    }\n                     Err(..) => {}\n                 }\n                 done.send(()).unwrap();\n             });\n             match sock1.send_to(&[2], &addr2) {\n-                Ok(..) => { let _ = tx.send(()); }\n+                Ok(..) => {\n+                    let _ = tx.send(());\n+                }\n                 Err(..) => {}\n             }\n             drop(tx);\n@@ -1012,13 +1018,13 @@ mod tests {\n \n     #[test]\n     fn debug() {\n-        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n         let socket_addr = next_test_ip4();\n \n         let udpsock = t!(UdpSocket::bind(&socket_addr));\n         let udpsock_inner = udpsock.0.socket().as_inner();\n-        let compare = format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\",\n-                              socket_addr, name, udpsock_inner);\n+        let compare =\n+            format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\", socket_addr, name, udpsock_inner);\n         assert_eq!(format!(\"{:?}\", udpsock), compare);\n     }\n \n@@ -1063,8 +1069,11 @@ mod tests {\n         loop {\n             let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n             if kind != ErrorKind::Interrupted {\n-                assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                        \"unexpected_error: {:?}\", kind);\n+                assert!(\n+                    kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+                    \"unexpected_error: {:?}\",\n+                    kind\n+                );\n                 break;\n             }\n         }\n@@ -1088,8 +1097,11 @@ mod tests {\n         loop {\n             let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n             if kind != ErrorKind::Interrupted {\n-                assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                        \"unexpected_error: {:?}\", kind);\n+                assert!(\n+                    kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+                    \"unexpected_error: {:?}\",\n+                    kind\n+                );\n                 break;\n             }\n         }"}, {"sha": "de8acf8d9d4721b8ed07347b636bb68f90455e32", "filename": "src/libstd/num.rs", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,57 +6,65 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::Wrapping;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::num::{FpCategory, ParseFloatError, ParseIntError, TryFromIntError};\n \n-#[stable(feature = \"nonzero\", since = \"1.28.0\")]\n-pub use core::num::{NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize};\n #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n-pub use core::num::{NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize};\n-\n-#[unstable(feature = \"int_error_matching\",\n-           reason = \"it can be useful to match errors when making error messages \\\n-                     for integer parsing\",\n-           issue = \"22639\")]\n+pub use core::num::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n+#[stable(feature = \"nonzero\", since = \"1.28.0\")]\n+pub use core::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n+\n+#[unstable(\n+    feature = \"int_error_matching\",\n+    reason = \"it can be useful to match errors when making error messages \\\n+              for integer parsing\",\n+    issue = \"22639\"\n+)]\n pub use core::num::IntErrorKind;\n \n-#[cfg(test)] use crate::fmt;\n-#[cfg(test)] use crate::ops::{Add, Sub, Mul, Div, Rem};\n+#[cfg(test)]\n+use crate::fmt;\n+#[cfg(test)]\n+use crate::ops::{Add, Div, Mul, Rem, Sub};\n \n /// Helper function for testing numeric operations\n #[cfg(test)]\n-pub fn test_num<T>(ten: T, two: T) where\n+pub fn test_num<T>(ten: T, two: T)\n+where\n     T: PartialEq\n-     + Add<Output=T> + Sub<Output=T>\n-     + Mul<Output=T> + Div<Output=T>\n-     + Rem<Output=T> + fmt::Debug\n-     + Copy\n+        + Add<Output = T>\n+        + Sub<Output = T>\n+        + Mul<Output = T>\n+        + Div<Output = T>\n+        + Rem<Output = T>\n+        + fmt::Debug\n+        + Copy,\n {\n-    assert_eq!(ten.add(two),  ten + two);\n-    assert_eq!(ten.sub(two),  ten - two);\n-    assert_eq!(ten.mul(two),  ten * two);\n-    assert_eq!(ten.div(two),  ten / two);\n-    assert_eq!(ten.rem(two),  ten % two);\n+    assert_eq!(ten.add(two), ten + two);\n+    assert_eq!(ten.sub(two), ten - two);\n+    assert_eq!(ten.mul(two), ten * two);\n+    assert_eq!(ten.div(two), ten / two);\n+    assert_eq!(ten.rem(two), ten % two);\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::u8;\n+    use crate::ops::Mul;\n     use crate::u16;\n     use crate::u32;\n     use crate::u64;\n+    use crate::u8;\n     use crate::usize;\n-    use crate::ops::Mul;\n \n     #[test]\n     fn test_saturating_add_uint() {\n         use crate::usize::MAX;\n         assert_eq!(3_usize.saturating_add(5_usize), 8_usize);\n-        assert_eq!(3_usize.saturating_add(MAX-1), MAX);\n+        assert_eq!(3_usize.saturating_add(MAX - 1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n-        assert_eq!((MAX-2).saturating_add(1), MAX-1);\n+        assert_eq!((MAX - 2).saturating_add(1), MAX - 1);\n     }\n \n     #[test]\n@@ -65,31 +73,31 @@ mod tests {\n         assert_eq!(5_usize.saturating_sub(3_usize), 2_usize);\n         assert_eq!(3_usize.saturating_sub(5_usize), 0_usize);\n         assert_eq!(0_usize.saturating_sub(1_usize), 0_usize);\n-        assert_eq!((MAX-1).saturating_sub(MAX), 0);\n+        assert_eq!((MAX - 1).saturating_sub(MAX), 0);\n     }\n \n     #[test]\n     fn test_saturating_add_int() {\n-        use crate::isize::{MIN,MAX};\n+        use crate::isize::{MAX, MIN};\n         assert_eq!(3i32.saturating_add(5), 8);\n-        assert_eq!(3isize.saturating_add(MAX-1), MAX);\n+        assert_eq!(3isize.saturating_add(MAX - 1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n-        assert_eq!((MAX-2).saturating_add(1), MAX-1);\n+        assert_eq!((MAX - 2).saturating_add(1), MAX - 1);\n         assert_eq!(3i32.saturating_add(-5), -2);\n         assert_eq!(MIN.saturating_add(-1), MIN);\n         assert_eq!((-2isize).saturating_add(-MAX), MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n-        use crate::isize::{MIN,MAX};\n+        use crate::isize::{MAX, MIN};\n         assert_eq!(3i32.saturating_sub(5), -2);\n         assert_eq!(MIN.saturating_sub(1), MIN);\n         assert_eq!((-2isize).saturating_sub(MAX), MIN);\n         assert_eq!(3i32.saturating_sub(-5), 8);\n-        assert_eq!(3isize.saturating_sub(-(MAX-1)), MAX);\n+        assert_eq!(3isize.saturating_sub(-(MAX - 1)), MAX);\n         assert_eq!(MAX.saturating_sub(-MAX), MAX);\n-        assert_eq!((MAX-2).saturating_sub(-1), MAX-1);\n+        assert_eq!((MAX - 2).saturating_sub(-1), MAX - 1);\n     }\n \n     #[test]\n@@ -128,7 +136,7 @@ mod tests {\n     }\n \n     macro_rules! test_is_power_of_two {\n-        ($test_name:ident, $T:ident) => (\n+        ($test_name:ident, $T:ident) => {\n             fn $test_name() {\n                 #![test]\n                 assert_eq!((0 as $T).is_power_of_two(), false);\n@@ -139,27 +147,29 @@ mod tests {\n                 assert_eq!((5 as $T).is_power_of_two(), false);\n                 assert_eq!(($T::MAX / 2 + 1).is_power_of_two(), true);\n             }\n-        )\n+        };\n     }\n \n-    test_is_power_of_two!{ test_is_power_of_two_u8, u8 }\n-    test_is_power_of_two!{ test_is_power_of_two_u16, u16 }\n-    test_is_power_of_two!{ test_is_power_of_two_u32, u32 }\n-    test_is_power_of_two!{ test_is_power_of_two_u64, u64 }\n-    test_is_power_of_two!{ test_is_power_of_two_uint, usize }\n+    test_is_power_of_two! { test_is_power_of_two_u8, u8 }\n+    test_is_power_of_two! { test_is_power_of_two_u16, u16 }\n+    test_is_power_of_two! { test_is_power_of_two_u32, u32 }\n+    test_is_power_of_two! { test_is_power_of_two_u64, u64 }\n+    test_is_power_of_two! { test_is_power_of_two_uint, usize }\n \n     macro_rules! test_next_power_of_two {\n-        ($test_name:ident, $T:ident) => (\n+        ($test_name:ident, $T:ident) => {\n             fn $test_name() {\n                 #![test]\n                 assert_eq!((0 as $T).next_power_of_two(), 1);\n                 let mut next_power = 1;\n                 for i in 1 as $T..40 {\n-                     assert_eq!(i.next_power_of_two(), next_power);\n-                     if i == next_power { next_power *= 2 }\n+                    assert_eq!(i.next_power_of_two(), next_power);\n+                    if i == next_power {\n+                        next_power *= 2\n+                    }\n                 }\n             }\n-        )\n+        };\n     }\n \n     test_next_power_of_two! { test_next_power_of_two_u8, u8 }\n@@ -169,23 +179,25 @@ mod tests {\n     test_next_power_of_two! { test_next_power_of_two_uint, usize }\n \n     macro_rules! test_checked_next_power_of_two {\n-        ($test_name:ident, $T:ident) => (\n+        ($test_name:ident, $T:ident) => {\n             fn $test_name() {\n                 #![test]\n                 assert_eq!((0 as $T).checked_next_power_of_two(), Some(1));\n                 let smax = $T::MAX >> 1;\n-                assert_eq!(smax.checked_next_power_of_two(), Some(smax+1));\n+                assert_eq!(smax.checked_next_power_of_two(), Some(smax + 1));\n                 assert_eq!((smax + 1).checked_next_power_of_two(), Some(smax + 1));\n                 assert_eq!((smax + 2).checked_next_power_of_two(), None);\n                 assert_eq!(($T::MAX - 1).checked_next_power_of_two(), None);\n                 assert_eq!($T::MAX.checked_next_power_of_two(), None);\n                 let mut next_power = 1;\n                 for i in 1 as $T..40 {\n-                     assert_eq!(i.checked_next_power_of_two(), Some(next_power));\n-                     if i == next_power { next_power *= 2 }\n+                    assert_eq!(i.checked_next_power_of_two(), Some(next_power));\n+                    if i == next_power {\n+                        next_power *= 2\n+                    }\n                 }\n             }\n-        )\n+        };\n     }\n \n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u8, u8 }\n@@ -196,15 +208,15 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Mul<Output=T> + Copy>(one: T, base: T, exp: usize) -> T {\n+        fn naive_pow<T: Mul<Output = T> + Copy>(one: T, base: T, exp: usize) -> T {\n             (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n             (($num:expr, $exp:expr) => $expected:expr) => {{\n                 let result = $num.pow($exp);\n                 assert_eq!(result, $expected);\n                 assert_eq!(result, naive_pow(1, $num, $exp));\n-            }}\n+            }};\n         }\n         assert_pow!((3u32,     0 ) => 1);\n         assert_pow!((5u32,     1 ) => 5);\n@@ -280,14 +292,15 @@ mod tests {\n     }\n }\n \n-\n #[cfg(test)]\n mod bench {\n     use test::Bencher;\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n         let v = (0..1024).collect::<Vec<u32>>();\n-        b.iter(|| {v.iter().fold(0u32, |old, new| old.pow(*new as u32));});\n+        b.iter(|| {\n+            v.iter().fold(0u32, |old, new| old.pow(*new as u32));\n+        });\n     }\n }"}, {"sha": "9356e607c908e4752c0681521e1e66161b4a5c57", "filename": "src/libstd/os/android/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fandroid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fandroid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -62,10 +64,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "dbb0127f369fd01d9a344596fb780c9f88229f6f", "filename": "src/libstd/os/android/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "2b8ade8a82e65f794b6d80e64aa8ba76bf506eb7", "filename": "src/libstd/os/android/raw.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,11 +1,13 @@\n //! Android-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;\n@@ -15,12 +17,12 @@ pub type pthread_t = c_long;\n \n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use self::arch::{dev_t, mode_t, blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n+pub use self::arch::{blkcnt_t, blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t, stat, time_t};\n \n #[cfg(any(target_arch = \"arm\", target_arch = \"x86\"))]\n mod arch {\n-    use crate::os::raw::{c_uint, c_uchar, c_ulonglong, c_longlong, c_ulong};\n-    use crate::os::unix::raw::{uid_t, gid_t};\n+    use crate::os::raw::{c_longlong, c_uchar, c_uint, c_ulong, c_ulonglong};\n+    use crate::os::unix::raw::{gid_t, uid_t};\n \n     #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n     pub type dev_t = u64;\n@@ -83,14 +85,12 @@ mod arch {\n         #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n         pub st_ino: c_ulonglong,\n     }\n-\n }\n \n-\n #[cfg(target_arch = \"aarch64\")]\n mod arch {\n     use crate::os::raw::{c_uchar, c_ulong};\n-    use crate::os::unix::raw::{uid_t, gid_t};\n+    use crate::os::unix::raw::{gid_t, uid_t};\n \n     #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n     pub type dev_t = u64;\n@@ -157,8 +157,8 @@ mod arch {\n \n #[cfg(target_arch = \"x86_64\")]\n mod arch {\n-    use crate::os::raw::{c_uint, c_long, c_ulong};\n-    use crate::os::unix::raw::{uid_t, gid_t};\n+    use crate::os::raw::{c_long, c_uint, c_ulong};\n+    use crate::os::unix::raw::{gid_t, uid_t};\n \n     #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n     pub type dev_t = u64;"}, {"sha": "8552abb1cb9773482306c760faa1a7bccc351a03", "filename": "src/libstd/os/dragonfly/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fdragonfly%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fdragonfly%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -68,10 +70,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "350b5fca7ea6646b490ab34c0fdf79bb3c30c9f9", "filename": "src/libstd/os/dragonfly/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "2a2d29043727e1aec51b7f9ba153f17cf655738c", "filename": "src/libstd/os/dragonfly/raw.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,24 +1,35 @@\n //! Dragonfly-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type fflags_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type fflags_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = i64;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = usize;"}, {"sha": "f5e30dc8eefc9df5124410c1df57bc6e3f55e500", "filename": "src/libstd/os/emscripten/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Femscripten%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Femscripten%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Femscripten%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -62,10 +64,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat64\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat64 as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "d35307162cc7e3b961eeb3d8810f961ba078485c", "filename": "src/libstd/os/emscripten/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Femscripten%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Femscripten%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Femscripten%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "dda7c82525debc637e2d5ecd82e126fc927fb3ef", "filename": "src/libstd/os/emscripten/raw.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Femscripten%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Femscripten%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Femscripten%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -3,28 +3,38 @@\n //! except using the musl-specific stat64 structure in liblibc.\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::{c_long, c_short, c_uint, c_ulong};\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = c_ulong;\n \n #[doc(inline)]\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = c_long;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = c_long;\n \n #[repr(C)]\n #[derive(Clone)]"}, {"sha": "69923268e570e058d2353dc6787c9df8e89cdde6", "filename": "src/libstd/os/fortanix_sgx/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -21,19 +21,20 @@ pub mod usercalls {\n \n     /// Lowest-level interfaces to usercalls and usercall ABI type definitions.\n     pub mod raw {\n+        pub use crate::sys::abi::usercalls::raw::{\n+            accept_stream, alloc, async_queues, bind_stream, close, connect_stream, exit, flush,\n+            free, insecure_time, launch_thread, read, read_alloc, send, wait, write,\n+        };\n         pub use crate::sys::abi::usercalls::raw::{do_usercall, Usercalls as UsercallNrs};\n-        pub use crate::sys::abi::usercalls::raw::{accept_stream, alloc, async_queues, bind_stream,\n-                                           close, connect_stream, exit, flush, free, insecure_time,\n-                                           launch_thread, read, read_alloc, send, wait, write};\n \n         // fortanix-sgx-abi re-exports\n-        pub use crate::sys::abi::usercalls::raw::{ByteBuffer, FifoDescriptor, Return, Usercall};\n         pub use crate::sys::abi::usercalls::raw::Error;\n-        pub use crate::sys::abi::usercalls::raw::{EV_RETURNQ_NOT_EMPTY, EV_UNPARK,\n-                                           EV_USERCALLQ_NOT_FULL, FD_STDERR, FD_STDIN, FD_STDOUT,\n-                                           RESULT_SUCCESS, USERCALL_USER_DEFINED, WAIT_INDEFINITE,\n-                                           WAIT_NO};\n+        pub use crate::sys::abi::usercalls::raw::{ByteBuffer, FifoDescriptor, Return, Usercall};\n         pub use crate::sys::abi::usercalls::raw::{Fd, Result, Tcs};\n+        pub use crate::sys::abi::usercalls::raw::{\n+            EV_RETURNQ_NOT_EMPTY, EV_UNPARK, EV_USERCALLQ_NOT_FULL, FD_STDERR, FD_STDIN, FD_STDOUT,\n+            RESULT_SUCCESS, USERCALL_USER_DEFINED, WAIT_INDEFINITE, WAIT_NO,\n+        };\n     }\n }\n \n@@ -42,7 +43,7 @@ pub mod mem {\n     pub use crate::sys::abi::mem::*;\n }\n \n-pub use crate::sys::ext::{io, arch, ffi};\n+pub use crate::sys::ext::{arch, ffi, io};\n \n /// Functions for querying thread-related information.\n pub mod thread {"}, {"sha": "6798e0d8f44fa146a337a8b8f7175863b5634e87", "filename": "src/libstd/os/freebsd/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffreebsd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffreebsd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -72,10 +74,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "c072fae557fe0306821844b89cc11da3c078a840", "filename": "src/libstd/os/freebsd/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "aeae08fc6aae0a4e86e60b6286058532f7b5e616", "filename": "src/libstd/os/freebsd/raw.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,24 +1,35 @@\n //! FreeBSD-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type fflags_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type fflags_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = i64;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = usize;"}, {"sha": "cd1b8233eb3ec09289562a68cec13ef8ed42db6d", "filename": "src/libstd/os/fuchsia/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffuchsia%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffuchsia%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffuchsia%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "f94659cd5baabf3731c2f6bb0f19dfc5fdf6ee5d", "filename": "src/libstd/os/fuchsia/raw.rs", "status": "modified", "additions": 75, "deletions": 42, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffuchsia%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Ffuchsia%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffuchsia%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,38 +1,50 @@\n //! Fuchsia-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_ulong;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = c_ulong;\n \n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use self::arch::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+pub use self::arch::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n \n-#[cfg(any(target_arch = \"x86\",\n-          target_arch = \"le32\",\n-          target_arch = \"powerpc\",\n-          target_arch = \"arm\"))]\n+#[cfg(any(\n+    target_arch = \"x86\",\n+    target_arch = \"le32\",\n+    target_arch = \"powerpc\",\n+    target_arch = \"arm\"\n+))]\n mod arch {\n     use crate::os::raw::{c_long, c_short, c_uint};\n \n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n \n     #[repr(C)]\n     #[derive(Clone)]\n@@ -84,20 +96,29 @@ mod arch {\n     use crate::os::raw::{c_long, c_ulong};\n \n     #[cfg(target_env = \"musl\")]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = i64;\n     #[cfg(not(target_env = \"musl\"))]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n     #[cfg(target_env = \"musl\")]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n     #[cfg(not(target_env = \"musl\"))]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n     #[cfg(target_env = \"musl\")]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n     #[cfg(not(target_env = \"musl\"))]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n \n     #[repr(C)]\n     #[derive(Clone)]\n@@ -146,19 +167,25 @@ mod arch {\n \n #[cfg(target_arch = \"mips64\")]\n mod arch {\n-    pub use libc::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+    pub use libc::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n }\n \n #[cfg(target_arch = \"aarch64\")]\n mod arch {\n-    use crate::os::raw::{c_long, c_int};\n+    use crate::os::raw::{c_int, c_long};\n \n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n \n     #[repr(C)]\n     #[derive(Clone)]\n@@ -207,14 +234,20 @@ mod arch {\n \n #[cfg(target_arch = \"x86_64\")]\n mod arch {\n-    use crate::os::raw::{c_long, c_int};\n+    use crate::os::raw::{c_int, c_long};\n \n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n \n     #[repr(C)]\n     #[derive(Clone)]"}, {"sha": "13a4a92ae90e43db53898d32f22962563ebaa645", "filename": "src/libstd/os/haiku/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fhaiku%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fhaiku%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhaiku%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -66,10 +68,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "73f500cadaa3071a7b3b9a460de4c4e1a681af02", "filename": "src/libstd/os/haiku/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fhaiku%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fhaiku%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhaiku%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "0d7e70b6b351d855ff98f4516582d4e12e3d22e7", "filename": "src/libstd/os/haiku/raw.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fhaiku%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fhaiku%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhaiku%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,23 +1,31 @@\n //! Haiku-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-\n #![allow(deprecated)]\n \n-use crate::os::raw::{c_long};\n-use crate::os::unix::raw::{uid_t, gid_t};\n+use crate::os::raw::c_long;\n+use crate::os::unix::raw::{gid_t, uid_t};\n \n // Use the direct definition of usize, instead of uintptr_t like in libc\n-#[stable(feature = \"pthread_t\", since = \"1.8.0\")] pub type pthread_t = usize;\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub type pthread_t = usize;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = i64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = i32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = i32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = i64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = i32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = i64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = i32;\n \n #[repr(C)]\n #[derive(Clone)]"}, {"sha": "08d3e4bcedfe2d07698c6938acb3668179dd6ece", "filename": "src/libstd/os/ios/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fios%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fios%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -72,10 +74,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "fdefa1f6b21c45299a4c7f1482ab9ef4a75c3f7d", "filename": "src/libstd/os/ios/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "97b0a96b0f1c006c7656e1766d0783441bd66366", "filename": "src/libstd/os/ios/raw.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,23 +1,33 @@\n //! iOS-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = i64;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = usize;"}, {"sha": "dd71201b50b91a632a17128f167540dd3e8c8ccd", "filename": "src/libstd/os/linux/fs.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Flinux%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Flinux%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -34,10 +34,7 @@ pub trait MetadataExt {\n     /// }\n     /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(\n-        since = \"1.8.0\",\n-        reason = \"other methods of this trait are now prefered\"\n-    )]\n+    #[rustc_deprecated(since = \"1.8.0\", reason = \"other methods of this trait are now prefered\")]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -328,10 +325,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat64\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat64 as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "d35307162cc7e3b961eeb3d8810f961ba078485c", "filename": "src/libstd/os/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "d9b2236047bdf78184b737556c7f0ece83ff2cc4", "filename": "src/libstd/os/linux/raw.rs", "status": "modified", "additions": 92, "deletions": 55, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,41 +1,53 @@\n //! Linux-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n #![allow(missing_debug_implementations)]\n \n use crate::os::raw::c_ulong;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = c_ulong;\n \n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use self::arch::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+pub use self::arch::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n \n-#[cfg(any(target_arch = \"x86\",\n-          target_arch = \"le32\",\n-          target_arch = \"powerpc\",\n-          target_arch = \"arm\",\n-          target_arch = \"asmjs\",\n-          target_arch = \"wasm32\"))]\n+#[cfg(any(\n+    target_arch = \"x86\",\n+    target_arch = \"le32\",\n+    target_arch = \"powerpc\",\n+    target_arch = \"arm\",\n+    target_arch = \"asmjs\",\n+    target_arch = \"wasm32\"\n+))]\n mod arch {\n     use crate::os::raw::{c_long, c_short, c_uint};\n \n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n \n     #[repr(C)]\n     #[derive(Clone)]\n@@ -87,20 +99,29 @@ mod arch {\n     use crate::os::raw::{c_long, c_ulong};\n \n     #[cfg(target_env = \"musl\")]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = i64;\n     #[cfg(not(target_env = \"musl\"))]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n     #[cfg(target_env = \"musl\")]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n     #[cfg(not(target_env = \"musl\"))]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n     #[cfg(target_env = \"musl\")]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n     #[cfg(not(target_env = \"musl\"))]\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n \n     #[repr(C)]\n     #[derive(Clone)]\n@@ -149,14 +170,20 @@ mod arch {\n \n #[cfg(target_arch = \"hexagon\")]\n mod arch {\n-    use crate::os::raw::{c_long, c_int, c_longlong, culonglong};\n+    use crate::os::raw::{c_int, c_long, c_longlong, culonglong};\n \n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = c_longlong;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = c_long;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = c_ulonglong;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = c_uint;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = c_longlong;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = c_long;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = c_longlong;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = c_long;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = c_ulonglong;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = c_uint;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = c_longlong;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = c_long;\n \n     #[repr(C)]\n     #[derive(Clone)]\n@@ -199,27 +226,31 @@ mod arch {\n         #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n         pub st_ctime_nsec: ::c_long,\n         #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-        pub __pad3: [::c_int;2],\n+        pub __pad3: [::c_int; 2],\n     }\n }\n \n-#[cfg(any(target_arch = \"mips64\",\n-          target_arch = \"s390x\",\n-          target_arch = \"sparc64\"))]\n+#[cfg(any(target_arch = \"mips64\", target_arch = \"s390x\", target_arch = \"sparc64\"))]\n mod arch {\n-    pub use libc::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+    pub use libc::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n }\n \n #[cfg(target_arch = \"aarch64\")]\n mod arch {\n-    use crate::os::raw::{c_long, c_int};\n+    use crate::os::raw::{c_int, c_long};\n \n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n \n     #[repr(C)]\n     #[derive(Clone)]\n@@ -268,14 +299,20 @@ mod arch {\n \n #[cfg(any(target_arch = \"x86_64\", target_arch = \"powerpc64\"))]\n mod arch {\n-    use crate::os::raw::{c_long, c_int};\n+    use crate::os::raw::{c_int, c_long};\n \n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-    #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = i64;\n \n     #[repr(C)]\n     #[derive(Clone)]"}, {"sha": "ad313a1240dfc13c1eaeba8161e78eb8ee26763d", "filename": "src/libstd/os/macos/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fmacos%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fmacos%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -74,10 +76,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "791d703b142cfefca079f4d94bcc55a9a4389d31", "filename": "src/libstd/os/macos/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "708261d86bddba769ff859c1bf83522fcff4cc2b", "filename": "src/libstd/os/macos/raw.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,23 +1,33 @@\n //! macOS-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = i64;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = usize;"}, {"sha": "91e37ed833a4faddaa4eb06c399245bb71ee4a29", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -38,20 +38,35 @@ cfg_if::cfg_if! {\n     }\n }\n \n-#[cfg(target_os = \"android\")]    pub mod android;\n-#[cfg(target_os = \"dragonfly\")]  pub mod dragonfly;\n-#[cfg(target_os = \"freebsd\")]    pub mod freebsd;\n-#[cfg(target_os = \"haiku\")]      pub mod haiku;\n-#[cfg(target_os = \"ios\")]        pub mod ios;\n-#[cfg(target_os = \"macos\")]      pub mod macos;\n-#[cfg(target_os = \"netbsd\")]     pub mod netbsd;\n-#[cfg(target_os = \"openbsd\")]    pub mod openbsd;\n-#[cfg(target_os = \"solaris\")]    pub mod solaris;\n-#[cfg(target_os = \"emscripten\")] pub mod emscripten;\n-#[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n-#[cfg(target_os = \"redox\")]      pub mod redox;\n-#[cfg(target_os = \"wasi\")]       pub mod wasi;\n-#[cfg(target_os = \"vxworks\")]    pub mod vxworks;\n-#[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] pub mod fortanix_sgx;\n+#[cfg(target_os = \"android\")]\n+pub mod android;\n+#[cfg(target_os = \"dragonfly\")]\n+pub mod dragonfly;\n+#[cfg(target_os = \"emscripten\")]\n+pub mod emscripten;\n+#[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))]\n+pub mod fortanix_sgx;\n+#[cfg(target_os = \"freebsd\")]\n+pub mod freebsd;\n+#[cfg(target_os = \"fuchsia\")]\n+pub mod fuchsia;\n+#[cfg(target_os = \"haiku\")]\n+pub mod haiku;\n+#[cfg(target_os = \"ios\")]\n+pub mod ios;\n+#[cfg(target_os = \"macos\")]\n+pub mod macos;\n+#[cfg(target_os = \"netbsd\")]\n+pub mod netbsd;\n+#[cfg(target_os = \"openbsd\")]\n+pub mod openbsd;\n+#[cfg(target_os = \"redox\")]\n+pub mod redox;\n+#[cfg(target_os = \"solaris\")]\n+pub mod solaris;\n+#[cfg(target_os = \"vxworks\")]\n+pub mod vxworks;\n+#[cfg(target_os = \"wasi\")]\n+pub mod wasi;\n \n pub mod raw;"}, {"sha": "90980fdce8028678a13b14e22bac339fb850381a", "filename": "src/libstd/os/netbsd/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fnetbsd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fnetbsd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnetbsd%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -70,10 +72,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "497a51a1df6fdb10b3df0fee8caaa11bf3fa904b", "filename": "src/libstd/os/netbsd/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fnetbsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fnetbsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnetbsd%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "475fcdcc4aaabab7bd8626a89f44cabff3b9d3d4", "filename": "src/libstd/os/netbsd/raw.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fnetbsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fnetbsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnetbsd%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,25 +1,36 @@\n //! NetBSD-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;\n-use crate::os::unix::raw::{uid_t, gid_t};\n+use crate::os::unix::raw::{gid_t, uid_t};\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type fflags_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type fflags_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = i64;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = usize;"}, {"sha": "47da00ae26e72518e485b9a0fd0eac4f1a65c939", "filename": "src/libstd/os/openbsd/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fopenbsd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fopenbsd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -70,10 +72,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "497a51a1df6fdb10b3df0fee8caaa11bf3fa904b", "filename": "src/libstd/os/openbsd/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "8e34e5483b7a0723da078bff431a712a331debfb", "filename": "src/libstd/os/openbsd/raw.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,24 +1,35 @@\n //! OpenBSD-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type fflags_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type fflags_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = i64;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = usize;"}, {"sha": "e09012007f2d4d59fe31e425e3bc40ec9418bdc8", "filename": "src/libstd/os/raw/mod.rs", "status": "modified", "additions": 110, "deletions": 60, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -9,85 +9,135 @@\n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n #[doc(include = \"char.md\")]\n-#[cfg(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n-                                       target_arch = \"arm\",\n-                                       target_arch = \"hexagon\",\n-                                       target_arch = \"powerpc\",\n-                                       target_arch = \"powerpc64\",\n-                                       target_arch = \"s390x\")),\n-          all(target_os = \"android\", any(target_arch = \"aarch64\",\n-                                         target_arch = \"arm\")),\n-          all(target_os = \"l4re\", target_arch = \"x86_64\"),\n-          all(target_os = \"freebsd\", any(target_arch = \"aarch64\",\n-                                         target_arch = \"arm\",\n-                                         target_arch = \"powerpc\",\n-                                         target_arch = \"powerpc64\")),\n-          all(target_os = \"netbsd\", any(target_arch = \"aarch64\",\n-                                        target_arch = \"arm\",\n-                                        target_arch = \"powerpc\")),\n-          all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n-          all(target_os = \"vxworks\", any(target_arch = \"aarch64\",\n-                                         target_arch = \"arm\",\n-                                         target_arch = \"powerpc64\",\n-                                         target_arch = \"powerpc\")),\n-          all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n+#[cfg(any(\n+    all(\n+        target_os = \"linux\",\n+        any(\n+            target_arch = \"aarch64\",\n+            target_arch = \"arm\",\n+            target_arch = \"hexagon\",\n+            target_arch = \"powerpc\",\n+            target_arch = \"powerpc64\",\n+            target_arch = \"s390x\"\n+        )\n+    ),\n+    all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n+    all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+    all(\n+        target_os = \"freebsd\",\n+        any(\n+            target_arch = \"aarch64\",\n+            target_arch = \"arm\",\n+            target_arch = \"powerpc\",\n+            target_arch = \"powerpc64\"\n+        )\n+    ),\n+    all(\n+        target_os = \"netbsd\",\n+        any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n+    ),\n+    all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n+    all(\n+        target_os = \"vxworks\",\n+        any(\n+            target_arch = \"aarch64\",\n+            target_arch = \"arm\",\n+            target_arch = \"powerpc64\",\n+            target_arch = \"powerpc\"\n+        )\n+    ),\n+    all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n+))]\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_char = u8;\n #[doc(include = \"char.md\")]\n-#[cfg(not(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n-                                           target_arch = \"arm\",\n-                                           target_arch = \"hexagon\",\n-                                           target_arch = \"powerpc\",\n-                                           target_arch = \"powerpc64\",\n-                                           target_arch = \"s390x\")),\n-              all(target_os = \"android\", any(target_arch = \"aarch64\",\n-                                             target_arch = \"arm\")),\n-              all(target_os = \"l4re\", target_arch = \"x86_64\"),\n-              all(target_os = \"freebsd\", any(target_arch = \"aarch64\",\n-                                             target_arch = \"arm\",\n-                                             target_arch = \"powerpc\",\n-                                             target_arch = \"powerpc64\")),\n-              all(target_os = \"netbsd\", any(target_arch = \"aarch64\",\n-                                            target_arch = \"arm\",\n-                                            target_arch = \"powerpc\")),\n-              all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n-              all(target_os = \"vxworks\", any(target_arch = \"aarch64\",\n-                                             target_arch = \"arm\",\n-                                             target_arch = \"powerpc64\",\n-                                             target_arch = \"powerpc\")),\n-              all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n+#[cfg(not(any(\n+    all(\n+        target_os = \"linux\",\n+        any(\n+            target_arch = \"aarch64\",\n+            target_arch = \"arm\",\n+            target_arch = \"hexagon\",\n+            target_arch = \"powerpc\",\n+            target_arch = \"powerpc64\",\n+            target_arch = \"s390x\"\n+        )\n+    ),\n+    all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n+    all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+    all(\n+        target_os = \"freebsd\",\n+        any(\n+            target_arch = \"aarch64\",\n+            target_arch = \"arm\",\n+            target_arch = \"powerpc\",\n+            target_arch = \"powerpc64\"\n+        )\n+    ),\n+    all(\n+        target_os = \"netbsd\",\n+        any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n+    ),\n+    all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n+    all(\n+        target_os = \"vxworks\",\n+        any(\n+            target_arch = \"aarch64\",\n+            target_arch = \"arm\",\n+            target_arch = \"powerpc64\",\n+            target_arch = \"powerpc\"\n+        )\n+    ),\n+    all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n+)))]\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_char = i8;\n #[doc(include = \"schar.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_schar = i8;\n #[doc(include = \"uchar.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_uchar = u8;\n #[doc(include = \"short.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_short = i16;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_short = i16;\n #[doc(include = \"ushort.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ushort = u16;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_ushort = u16;\n #[doc(include = \"int.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_int = i32;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_int = i32;\n #[doc(include = \"uint.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uint = u32;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_uint = u32;\n #[doc(include = \"long.md\")]\n #[cfg(any(target_pointer_width = \"32\", windows))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_long = i32;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_long = i32;\n #[doc(include = \"ulong.md\")]\n #[cfg(any(target_pointer_width = \"32\", windows))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulong = u32;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_ulong = u32;\n #[doc(include = \"long.md\")]\n #[cfg(all(target_pointer_width = \"64\", not(windows)))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_long = i64;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_long = i64;\n #[doc(include = \"ulong.md\")]\n #[cfg(all(target_pointer_width = \"64\", not(windows)))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulong = u64;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_ulong = u64;\n #[doc(include = \"longlong.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_longlong = i64;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_longlong = i64;\n #[doc(include = \"ulonglong.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulonglong = u64;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_ulonglong = u64;\n #[doc(include = \"float.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_float = f32;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_float = f32;\n #[doc(include = \"double.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_double = f64;\n+#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+pub type c_double = f64;\n \n #[stable(feature = \"raw_os\", since = \"1.1.0\")]\n #[doc(no_inline)]"}, {"sha": "6c87df534bdc683c929cbddc584a361bb7b95717", "filename": "src/libstd/os/redox/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fredox%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -34,9 +34,11 @@ pub trait MetadataExt {\n     /// }\n     /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -327,10 +329,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "d786759c6111a633795f2577941bf48e67b20d61", "filename": "src/libstd/os/redox/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fredox%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "abe6dfc6b0c51beb7e657faeb61252f7e810c53c", "filename": "src/libstd/os/redox/raw.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fredox%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fredox%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fredox%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,30 +1,42 @@\n //! Redox-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n #![allow(missing_debug_implementations)]\n \n use crate::os::raw::{c_char, c_int, c_long, c_ulong, c_void};\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = c_long;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type gid_t = c_int;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = c_int;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type uid_t = c_int;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = c_long;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type gid_t = c_int;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = c_int;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type uid_t = c_int;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = *mut c_void;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = c_ulong;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = c_ulong;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = c_ulong;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = c_ulong;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = c_long;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = c_long;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = c_ulong;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = c_ulong;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = c_ulong;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = c_ulong;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = c_long;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = c_long;\n \n #[repr(C)]\n #[derive(Clone)]"}, {"sha": "549d3d756362df76b60cf3ac400a410f5b1e7fb2", "filename": "src/libstd/os/solaris/fs.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fsolaris%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fsolaris%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fsolaris%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,11 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat;\n \n@@ -62,10 +64,7 @@ pub trait MetadataExt {\n impl MetadataExt for Metadata {\n     #[allow(deprecated)]\n     fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat\n-                                          as *const raw::stat)\n-        }\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n     }\n     fn st_dev(&self) -> u64 {\n         self.as_inner().as_inner().st_dev as u64"}, {"sha": "e4cfd53291a6ea590d977d226529c7bfc62785e9", "filename": "src/libstd/os/solaris/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fsolaris%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fsolaris%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fsolaris%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "e78f9992bb32469c457af7877443076805fc109c", "filename": "src/libstd/os/solaris/raw.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fsolaris%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fsolaris%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fsolaris%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,25 +1,36 @@\n //! Solaris-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;\n-use crate::os::unix::raw::{uid_t, gid_t};\n+use crate::os::unix::raw::{gid_t, uid_t};\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blkcnt_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type blksize_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type dev_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type fflags_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type ino_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type mode_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type nlink_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type off_t = u64;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type fflags_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = i64;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = u32;\n@@ -61,5 +72,5 @@ pub struct stat {\n     #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n     pub st_blocks: blkcnt_t,\n     #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-    pub __unused: [u8; 16]\n+    pub __unused: [u8; 16],\n }"}, {"sha": "0a7ac641dd3e1c3d0dba3de345f83fac5fe05674", "filename": "src/libstd/os/vxworks/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fvxworks%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,5 +2,5 @@\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n \n-pub mod raw;\n pub mod fs;\n+pub mod raw;"}, {"sha": "29a0af5645ee1f4d052b507a4644dd3e1c0968e5", "filename": "src/libstd/os/vxworks/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fvxworks%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fos%2Fvxworks%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fvxworks%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n //! VxWorks-specific raw type definitions\n #![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n \n-use crate::os::raw::{c_ulong};\n+use crate::os::raw::c_ulong;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = c_ulong;"}, {"sha": "ac8e0daf766bfc4d7df36e7a8545bde1cfd3c778", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -7,21 +7,21 @@ use crate::cell::UnsafeCell;\n use crate::collections;\n use crate::fmt;\n use crate::future::Future;\n-use crate::pin::Pin;\n use crate::ops::{Deref, DerefMut};\n use crate::panicking;\n-use crate::ptr::{Unique, NonNull};\n+use crate::pin::Pin;\n+use crate::ptr::{NonNull, Unique};\n use crate::rc::Rc;\n-use crate::sync::{Arc, Mutex, RwLock};\n use crate::sync::atomic;\n+use crate::sync::{Arc, Mutex, RwLock};\n use crate::task::{Context, Poll};\n use crate::thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-pub use crate::panicking::{take_hook, set_hook};\n+pub use crate::panicking::{set_hook, take_hook};\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-pub use core::panic::{PanicInfo, Location};\n+pub use core::panic::{Location, PanicInfo};\n \n /// A marker trait which represents \"panic safe\" types in Rust.\n ///\n@@ -103,8 +103,8 @@ pub use core::panic::{PanicInfo, Location};\n /// [`AssertUnwindSafe`]: ./struct.AssertUnwindSafe.html\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented(\n-    message=\"the type `{Self}` may not be safely transferred across an unwind boundary\",\n-    label=\"`{Self}` may not be safely transferred across an unwind boundary\",\n+    message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n+    label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n )]\n pub auto trait UnwindSafe {}\n \n@@ -121,10 +121,10 @@ pub auto trait UnwindSafe {}\n /// [`UnwindSafe`]: ./trait.UnwindSafe.html\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented(\n-    message=\"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n-             transferrable across a catch_unwind boundary\",\n-    label=\"`{Self}` may contain interior mutability and a reference may not be safely \\\n-           transferrable across a catch_unwind boundary\",\n+    message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n+               transferrable across a catch_unwind boundary\",\n+    label = \"`{Self}` may contain interior mutability and a reference may not be safely \\\n+             transferrable across a catch_unwind boundary\"\n )]\n pub auto trait RefUnwindSafe {}\n \n@@ -187,10 +187,7 @@ pub auto trait RefUnwindSafe {}\n /// // ...\n /// ```\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-pub struct AssertUnwindSafe<T>(\n-    #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-    pub T\n-);\n+pub struct AssertUnwindSafe<T>(#[stable(feature = \"catch_unwind\", since = \"1.9.0\")] pub T);\n \n // Implementations of the `UnwindSafe` trait:\n //\n@@ -290,7 +287,12 @@ impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n // https://github.com/rust-lang/rust/issues/62301\n #[stable(feature = \"hashbrown\", since = \"1.36.0\")]\n impl<K, V, S> UnwindSafe for collections::HashMap<K, V, S>\n-    where K: UnwindSafe, V: UnwindSafe, S: UnwindSafe {}\n+where\n+    K: UnwindSafe,\n+    V: UnwindSafe,\n+    S: UnwindSafe,\n+{\n+}\n \n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> Deref for AssertUnwindSafe<T> {\n@@ -320,9 +322,7 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"AssertUnwindSafe\")\n-            .field(&self.0)\n-            .finish()\n+        f.debug_tuple(\"AssertUnwindSafe\").field(&self.0).finish()\n     }\n }\n \n@@ -391,9 +391,7 @@ impl<F: Future> Future for AssertUnwindSafe<F> {\n /// ```\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n-    unsafe {\n-        panicking::r#try(f)\n-    }\n+    unsafe { panicking::r#try(f) }\n }\n \n /// Triggers a panic without invoking the panic hook."}, {"sha": "42bca0a9575b3da705f9e17192453f512b7f93d9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 781, "deletions": 847, "changes": 1628, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -84,7 +84,7 @@ use crate::sync::Arc;\n \n use crate::ffi::{OsStr, OsString};\n \n-use crate::sys::path::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n+use crate::sys::path::{is_sep_byte, is_verbatim_sep, parse_prefix, MAIN_SEP_STR};\n \n ////////////////////////////////////////////////////////////////////////////////\n // GENERAL NOTES\n@@ -196,26 +196,13 @@ impl<'a> Prefix<'a> {\n         match *self {\n             Verbatim(x) => 4 + os_str_len(x),\n             VerbatimUNC(x, y) => {\n-                8 + os_str_len(x) +\n-                if os_str_len(y) > 0 {\n-                    1 + os_str_len(y)\n-                } else {\n-                    0\n-                }\n-            },\n+                8 + os_str_len(x) + if os_str_len(y) > 0 { 1 + os_str_len(y) } else { 0 }\n+            }\n             VerbatimDisk(_) => 6,\n-            UNC(x, y) => {\n-                2 + os_str_len(x) +\n-                if os_str_len(y) > 0 {\n-                    1 + os_str_len(y)\n-                } else {\n-                    0\n-                }\n-            },\n+            UNC(x, y) => 2 + os_str_len(x) + if os_str_len(y) > 0 { 1 + os_str_len(y) } else { 0 },\n             DeviceNS(x) => 4 + os_str_len(x),\n             Disk(_) => 2,\n         }\n-\n     }\n \n     /// Determines if the prefix is verbatim, i.e., begins with `\\\\?\\`.\n@@ -291,8 +278,9 @@ pub const MAIN_SEPARATOR: char = crate::sys::path::MAIN_SEP;\n // is not a prefix of `iter`, otherwise return `Some(iter_after_prefix)` giving\n // `iter` after having exhausted `prefix`.\n fn iter_after<'a, 'b, I, J>(mut iter: I, mut prefix: J) -> Option<I>\n-    where I: Iterator<Item = Component<'a>> + Clone,\n-          J: Iterator<Item = Component<'b>>,\n+where\n+    I: Iterator<Item = Component<'a>> + Clone,\n+    J: Iterator<Item = Component<'b>>,\n {\n     loop {\n         let mut iter_next = iter.clone();\n@@ -326,11 +314,7 @@ fn has_redox_scheme(s: &[u8]) -> bool {\n \n /// Says whether the first byte after the prefix is a separator.\n fn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n-    let path = if let Some(p) = prefix {\n-        &s[p.len()..]\n-    } else {\n-        s\n-    };\n+    let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n     !path.is_empty() && is_sep_byte(path[0])\n }\n \n@@ -352,8 +336,7 @@ fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n         if before == Some(b\"\") {\n             (Some(file), None)\n         } else {\n-            (before.map(|s| u8_slice_as_os_str(s)),\n-             after.map(|s| u8_slice_as_os_str(s)))\n+            (before.map(|s| u8_slice_as_os_str(s)), after.map(|s| u8_slice_as_os_str(s)))\n         }\n     }\n }\n@@ -370,9 +353,9 @@ fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n /// directory component, and a body (of normal components)\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n enum State {\n-    Prefix = 0,         // c:\n-    StartDir = 1,       // / or . or nothing\n-    Body = 2,           // foo/bar/baz\n+    Prefix = 0,   // c:\n+    StartDir = 1, // / or . or nothing\n+    Body = 2,     // foo/bar/baz\n     Done = 3,\n }\n \n@@ -509,9 +492,7 @@ pub enum Component<'a> {\n     ///\n     /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Prefix(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>\n-    ),\n+    Prefix(#[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>),\n \n     /// The root directory component, appears after any prefix and before anything else.\n     ///\n@@ -637,15 +618,11 @@ impl fmt::Debug for Components<'_> {\n \n         impl fmt::Debug for DebugHelper<'_> {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.debug_list()\n-                    .entries(self.0.components())\n-                    .finish()\n+                f.debug_list().entries(self.0.components()).finish()\n             }\n         }\n \n-        f.debug_tuple(\"Components\")\n-            .field(&DebugHelper(self.as_path()))\n-            .finish()\n+        f.debug_tuple(\"Components\").field(&DebugHelper(self.as_path())).finish()\n     }\n }\n \n@@ -664,26 +641,14 @@ impl<'a> Components<'a> {\n     /// how much of the prefix is left from the point of view of iteration?\n     #[inline]\n     fn prefix_remaining(&self) -> usize {\n-        if self.front == State::Prefix {\n-            self.prefix_len()\n-        } else {\n-            0\n-        }\n+        if self.front == State::Prefix { self.prefix_len() } else { 0 }\n     }\n \n     // Given the iteration so far, how much of the pre-State::Body path is left?\n     #[inline]\n     fn len_before_body(&self) -> usize {\n-        let root = if self.front <= State::StartDir && self.has_physical_root {\n-            1\n-        } else {\n-            0\n-        };\n-        let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() {\n-            1\n-        } else {\n-            0\n-        };\n+        let root = if self.front <= State::StartDir && self.has_physical_root { 1 } else { 0 };\n+        let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() { 1 } else { 0 };\n         self.prefix_remaining() + root + cur_dir\n     }\n \n@@ -695,11 +660,7 @@ impl<'a> Components<'a> {\n \n     #[inline]\n     fn is_sep_byte(&self, b: u8) -> bool {\n-        if self.prefix_verbatim() {\n-            is_verbatim_sep(b)\n-        } else {\n-            is_sep_byte(b)\n-        }\n+        if self.prefix_verbatim() { is_verbatim_sep(b) } else { is_sep_byte(b) }\n     }\n \n     /// Extracts a slice corresponding to the portion of the path remaining for iteration.\n@@ -758,8 +719,8 @@ impl<'a> Components<'a> {\n         match comp {\n             b\".\" if self.prefix_verbatim() => Some(Component::CurDir),\n             b\".\" => None, // . components are normalized away, except at\n-                          // the beginning of a path, which is treated\n-                          // separately via `include_cur_dir`\n+            // the beginning of a path, which is treated\n+            // separately via `include_cur_dir`\n             b\"..\" => Some(Component::ParentDir),\n             b\"\" => None,\n             _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) })),\n@@ -835,15 +796,11 @@ impl fmt::Debug for Iter<'_> {\n \n         impl fmt::Debug for DebugHelper<'_> {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.debug_list()\n-                    .entries(self.0.iter())\n-                    .finish()\n+                f.debug_list().entries(self.0.iter()).finish()\n             }\n         }\n \n-        f.debug_tuple(\"Iter\")\n-            .field(&DebugHelper(self.as_path()))\n-            .finish()\n+        f.debug_tuple(\"Iter\").field(&DebugHelper(self.as_path())).finish()\n     }\n }\n \n@@ -1174,9 +1131,7 @@ impl PathBuf {\n     /// [`OsString`]: ../ffi/struct.OsString.html\n     #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n     pub fn with_capacity(capacity: usize) -> PathBuf {\n-        PathBuf {\n-            inner: OsString::with_capacity(capacity)\n-        }\n+        PathBuf { inner: OsString::with_capacity(capacity) }\n     }\n \n     /// Coerces to a [`Path`] slice.\n@@ -1239,8 +1194,10 @@ impl PathBuf {\n         // in the special case of `C:` on Windows, do *not* add a separator\n         {\n             let comps = self.components();\n-            if comps.prefix_len() > 0 && comps.prefix_len() == comps.path.len() &&\n-               comps.prefix.unwrap().is_drive() {\n+            if comps.prefix_len() > 0\n+                && comps.prefix_len() == comps.path.len()\n+                && comps.prefix.unwrap().is_drive()\n+            {\n                 need_sep = false\n             }\n         }\n@@ -1527,7 +1484,7 @@ impl From<PathBuf> for OsString {\n     /// Converts a `PathBuf` into a `OsString`\n     ///\n     /// This conversion does not allocate or copy memory.\n-    fn from(path_buf : PathBuf) -> OsString {\n+    fn from(path_buf: PathBuf) -> OsString {\n         path_buf.inner\n     }\n }\n@@ -1992,13 +1949,11 @@ impl Path {\n     pub fn parent(&self) -> Option<&Path> {\n         let mut comps = self.components();\n         let comp = comps.next_back();\n-        comp.and_then(|p| {\n-            match p {\n-                Component::Normal(_) |\n-                Component::CurDir |\n-                Component::ParentDir => Some(comps.as_path()),\n-                _ => None,\n+        comp.and_then(|p| match p {\n+            Component::Normal(_) | Component::CurDir | Component::ParentDir => {\n+                Some(comps.as_path())\n             }\n+            _ => None,\n         })\n     }\n \n@@ -2026,9 +1981,7 @@ impl Path {\n     /// [`parent`]: struct.Path.html#method.parent\n     #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n     pub fn ancestors(&self) -> Ancestors<'_> {\n-        Ancestors {\n-            next: Some(&self),\n-        }\n+        Ancestors { next: Some(&self) }\n     }\n \n     /// Returns the final component of the `Path`, if there is one.\n@@ -2055,11 +2008,9 @@ impl Path {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n-        self.components().next_back().and_then(|p| {\n-            match p {\n-                Component::Normal(p) => Some(p.as_ref()),\n-                _ => None,\n-            }\n+        self.components().next_back().and_then(|p| match p {\n+            Component::Normal(p) => Some(p.as_ref()),\n+            _ => None,\n         })\n     }\n \n@@ -2092,15 +2043,14 @@ impl Path {\n     /// assert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));\n     /// ```\n     #[stable(since = \"1.7.0\", feature = \"path_strip_prefix\")]\n-    pub fn strip_prefix<P>(&self, base: P)\n-                           -> Result<&Path, StripPrefixError>\n-        where P: AsRef<Path>\n+    pub fn strip_prefix<P>(&self, base: P) -> Result<&Path, StripPrefixError>\n+    where\n+        P: AsRef<Path>,\n     {\n         self._strip_prefix(base.as_ref())\n     }\n \n-    fn _strip_prefix(&self, base: &Path)\n-                     -> Result<&Path, StripPrefixError> {\n+    fn _strip_prefix(&self, base: &Path) -> Result<&Path, StripPrefixError> {\n         iter_after(self.components(), base.components())\n             .map(|c| c.as_path())\n             .ok_or(StripPrefixError(()))\n@@ -2329,8 +2279,8 @@ impl Path {\n         Components {\n             path: self.as_u8_slice(),\n             prefix,\n-            has_physical_root: has_physical_root(self.as_u8_slice(), prefix) ||\n-                               has_redox_scheme(self.as_u8_slice()),\n+            has_physical_root: has_physical_root(self.as_u8_slice(), prefix)\n+                || has_redox_scheme(self.as_u8_slice()),\n             front: State::Prefix,\n             back: State::Body,\n         }\n@@ -2727,28 +2677,36 @@ impl AsRef<Path> for PathBuf {\n impl<'a> IntoIterator for &'a PathBuf {\n     type Item = &'a OsStr;\n     type IntoIter = Iter<'a>;\n-    fn into_iter(self) -> Iter<'a> { self.iter() }\n+    fn into_iter(self) -> Iter<'a> {\n+        self.iter()\n+    }\n }\n \n #[stable(feature = \"path_into_iter\", since = \"1.6.0\")]\n impl<'a> IntoIterator for &'a Path {\n     type Item = &'a OsStr;\n     type IntoIter = Iter<'a>;\n-    fn into_iter(self) -> Iter<'a> { self.iter() }\n+    fn into_iter(self) -> Iter<'a> {\n+        self.iter()\n+    }\n }\n \n macro_rules! impl_cmp {\n     ($lhs:ty, $rhs: ty) => {\n         #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n         impl<'a, 'b> PartialEq<$rhs> for $lhs {\n             #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { <Path as PartialEq>::eq(self, other) }\n+            fn eq(&self, other: &$rhs) -> bool {\n+                <Path as PartialEq>::eq(self, other)\n+            }\n         }\n \n         #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n         impl<'a, 'b> PartialEq<$lhs> for $rhs {\n             #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { <Path as PartialEq>::eq(self, other) }\n+            fn eq(&self, other: &$lhs) -> bool {\n+                <Path as PartialEq>::eq(self, other)\n+            }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n@@ -2766,7 +2724,7 @@ macro_rules! impl_cmp {\n                 <Path as PartialOrd>::partial_cmp(self, other)\n             }\n         }\n-    }\n+    };\n }\n \n impl_cmp!(PathBuf, Path);\n@@ -2780,13 +2738,17 @@ macro_rules! impl_cmp_os_str {\n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n         impl<'a, 'b> PartialEq<$rhs> for $lhs {\n             #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { <Path as PartialEq>::eq(self, other.as_ref()) }\n+            fn eq(&self, other: &$rhs) -> bool {\n+                <Path as PartialEq>::eq(self, other.as_ref())\n+            }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n         impl<'a, 'b> PartialEq<$lhs> for $rhs {\n             #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { <Path as PartialEq>::eq(self.as_ref(), other) }\n+            fn eq(&self, other: &$lhs) -> bool {\n+                <Path as PartialEq>::eq(self.as_ref(), other)\n+            }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n@@ -2804,7 +2766,7 @@ macro_rules! impl_cmp_os_str {\n                 <Path as PartialOrd>::partial_cmp(self.as_ref(), other)\n             }\n         }\n-    }\n+    };\n }\n \n impl_cmp_os_str!(PathBuf, OsStr);\n@@ -2831,7 +2793,9 @@ impl fmt::Display for StripPrefixError {\n \n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n impl Error for StripPrefixError {\n-    fn description(&self) -> &str { \"prefix not found\" }\n+    fn description(&self) -> &str {\n+        \"prefix not found\"\n+    }\n }\n \n #[cfg(test)]\n@@ -2948,568 +2912,568 @@ mod tests {\n     #[cfg(unix)]\n     pub fn test_decompositions_unix() {\n         t!(\"\",\n-           iter: [],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"/\",\n-           iter: [\"/\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"/\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"/foo\",\n-           iter: [\"/\", \"foo\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"/foo/\",\n-           iter: [\"/\", \"foo\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/bar\",\n-           iter: [\"foo\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"/foo/bar\",\n-           iter: [\"/\", \"foo\", \"bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\", \"bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"///foo///\",\n-           iter: [\"/\", \"foo\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"///foo///bar\",\n-           iter: [\"/\", \"foo\", \"bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"///foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\", \"bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"///foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"./.\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"/..\",\n-           iter: [\"/\", \"..\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"/\", \"..\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"../\",\n-           iter: [\"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/.\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/..\",\n-           iter: [\"foo\", \"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/./\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/./bar\",\n-           iter: [\"foo\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"foo/../\",\n-           iter: [\"foo\", \"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/../bar\",\n-           iter: [\"foo\", \"..\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo/..\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo/..\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"./a\",\n-           iter: [\".\", \"a\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\".\"),\n-           file_name: Some(\"a\"),\n-           file_stem: Some(\"a\"),\n-           extension: None\n-           );\n+        iter: [\".\", \"a\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\".\"),\n+        file_name: Some(\"a\"),\n+        file_stem: Some(\"a\"),\n+        extension: None\n+        );\n \n         t!(\".\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"./\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"a/b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a//b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a/./b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a/b/c\",\n-           iter: [\"a\", \"b\", \"c\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a/b\"),\n-           file_name: Some(\"c\"),\n-           file_stem: Some(\"c\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\", \"c\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a/b\"),\n+        file_name: Some(\"c\"),\n+        file_stem: Some(\"c\"),\n+        extension: None\n+        );\n \n         t!(\".foo\",\n-           iter: [\".foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\".foo\"),\n-           file_stem: Some(\".foo\"),\n-           extension: None\n-           );\n+        iter: [\".foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\".foo\"),\n+        file_stem: Some(\".foo\"),\n+        extension: None\n+        );\n     }\n \n     #[test]\n     #[cfg(windows)]\n     pub fn test_decompositions_windows() {\n         t!(\"\",\n-           iter: [],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"/\",\n-           iter: [\"\\\\\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\",\n-           iter: [\"\\\\\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"c:\",\n-           iter: [\"c:\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"c:\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"c:\\\\\",\n-           iter: [\"c:\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"c:\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"c:/\",\n-           iter: [\"c:\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"c:\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"/foo\",\n-           iter: [\"\\\\\", \"foo\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"/foo/\",\n-           iter: [\"\\\\\", \"foo\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/bar\",\n-           iter: [\"foo\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"/foo/bar\",\n-           iter: [\"\\\\\", \"foo\", \"bar\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\", \"bar\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"///foo///\",\n-           iter: [\"\\\\\", \"foo\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"///foo///bar\",\n-           iter: [\"\\\\\", \"foo\", \"bar\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"///foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\", \"bar\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"///foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"./.\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"/..\",\n-           iter: [\"\\\\\", \"..\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"..\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"../\",\n-           iter: [\"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/.\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/..\",\n-           iter: [\"foo\", \"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/./\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/./bar\",\n-           iter: [\"foo\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"foo/../\",\n-           iter: [\"foo\", \"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/../bar\",\n-           iter: [\"foo\", \"..\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo/..\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo/..\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"./a\",\n-           iter: [\".\", \"a\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\".\"),\n-           file_name: Some(\"a\"),\n-           file_stem: Some(\"a\"),\n-           extension: None\n-           );\n+        iter: [\".\", \"a\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\".\"),\n+        file_name: Some(\"a\"),\n+        file_stem: Some(\"a\"),\n+        extension: None\n+        );\n \n         t!(\".\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"./\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"a/b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a//b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a/./b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a/b/c\",\n            iter: [\"a\", \"b\", \"c\"],\n@@ -3521,291 +3485,273 @@ mod tests {\n            extension: None);\n \n         t!(\"a\\\\b\\\\c\",\n-           iter: [\"a\", \"b\", \"c\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\\\\b\"),\n-           file_name: Some(\"c\"),\n-           file_stem: Some(\"c\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\", \"c\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\\\\b\"),\n+        file_name: Some(\"c\"),\n+        file_stem: Some(\"c\"),\n+        extension: None\n+        );\n \n         t!(\"\\\\a\",\n-           iter: [\"\\\\\", \"a\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"\\\\\"),\n-           file_name: Some(\"a\"),\n-           file_stem: Some(\"a\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"a\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"\\\\\"),\n+        file_name: Some(\"a\"),\n+        file_stem: Some(\"a\"),\n+        extension: None\n+        );\n \n         t!(\"c:\\\\foo.txt\",\n-           iter: [\"c:\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"c:\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        iter: [\"c:\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"c:\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\server\\\\share\\\\foo.txt\",\n-           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\server\\\\share\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\server\\\\share\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\server\\\\share\",\n-           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\server\\\\share\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\server\",\n-           iter: [\"\\\\\", \"server\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"\\\\\"),\n-           file_name: Some(\"server\"),\n-           file_stem: Some(\"server\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"server\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"\\\\\"),\n+        file_name: Some(\"server\"),\n+        file_stem: Some(\"server\"),\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\bar\\\\foo.txt\",\n-           iter: [\"\\\\\\\\?\\\\bar\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\bar\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        iter: [\"\\\\\\\\?\\\\bar\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\?\\\\bar\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\?\\\\bar\",\n-           iter: [\"\\\\\\\\?\\\\bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\\",\n-           iter: [\"\\\\\\\\?\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\",\n-           iter: [\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        iter: [\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\?\\\\UNC\\\\server\",\n-           iter: [\"\\\\\\\\?\\\\UNC\\\\server\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\UNC\\\\server\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\UNC\\\\\",\n-           iter: [\"\\\\\\\\?\\\\UNC\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\UNC\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\C:\\\\foo.txt\",\n-           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\C:\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\?\\\\C:\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\?\\\\C:\\\\\",\n-           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\C:\",\n-           iter: [\"\\\\\\\\?\\\\C:\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\C:\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\foo/bar\",\n-           iter: [\"\\\\\\\\?\\\\foo/bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\foo/bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\C:/foo\",\n-           iter: [\"\\\\\\\\?\\\\C:/foo\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\C:/foo\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\foo\\\\bar\",\n-           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\.\\\\foo\\\\\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\.\\\\foo\\\\\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\foo\",\n-           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\foo/bar\",\n-           iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\foo\\\\bar/baz\",\n-           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\", \"baz\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\.\\\\foo\\\\bar\"),\n-           file_name: Some(\"baz\"),\n-           file_stem: Some(\"baz\"),\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\", \"baz\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\.\\\\foo\\\\bar\"),\n+        file_name: Some(\"baz\"),\n+        file_stem: Some(\"baz\"),\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\\",\n-           iter: [\"\\\\\\\\.\\\\\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\.\\\\\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\a\\\\b\\\\\",\n-           iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\a\\\\\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\?\\\\a\\\\\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n     }\n \n     #[test]\n     pub fn test_stem_ext() {\n         t!(\"foo\",\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo.\",\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"\")\n-           );\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"\")\n+        );\n \n         t!(\".foo\",\n-           file_stem: Some(\".foo\"),\n-           extension: None\n-           );\n+        file_stem: Some(\".foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo.txt\",\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"foo.bar.txt\",\n-           file_stem: Some(\"foo.bar\"),\n-           extension: Some(\"txt\")\n-           );\n+        file_stem: Some(\"foo.bar\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"foo.bar.\",\n-           file_stem: Some(\"foo.bar\"),\n-           extension: Some(\"\")\n-           );\n+        file_stem: Some(\"foo.bar\"),\n+        extension: Some(\"\")\n+        );\n \n-        t!(\".\",\n-           file_stem: None,\n-           extension: None\n-           );\n+        t!(\".\", file_stem: None, extension: None);\n \n-        t!(\"..\",\n-           file_stem: None,\n-           extension: None\n-           );\n+        t!(\"..\", file_stem: None, extension: None);\n \n-        t!(\"\",\n-           file_stem: None,\n-           extension: None\n-           );\n+        t!(\"\", file_stem: None, extension: None);\n     }\n \n     #[test]\n@@ -3873,26 +3819,20 @@ mod tests {\n             tp!(\"C:a\\\\b\\\\c\", \"C:d\", \"C:d\");\n             tp!(\"C:\", r\"a\\b\\c\", r\"C:a\\b\\c\");\n             tp!(\"C:\", r\"..\\a\", r\"C:..\\a\");\n-            tp!(\"\\\\\\\\server\\\\share\\\\foo\",\n-                \"bar\",\n-                \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n             tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\",\n-                \"bar\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n \n             // Note: modified from old path API\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\foo\");\n \n-            tp!(\"C:\\\\a\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n+            tp!(\"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n             tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n             tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n             // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n@@ -3945,15 +3885,9 @@ mod tests {\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n             tp!(\"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\",\n-                true);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\",\n-                true);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n-                false);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\", true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n             tp!(\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n             tp!(\"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\\\\\", true);\n             tp!(\"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n@@ -4051,8 +3985,8 @@ mod tests {\n \n     #[test]\n     pub fn test_compare() {\n-        use crate::hash::{Hash, Hasher};\n         use crate::collections::hash_map::DefaultHasher;\n+        use crate::hash::{Hash, Hasher};\n \n         fn hash<T: Hash>(t: T) -> u64 {\n             let mut s = DefaultHasher::new();\n@@ -4095,83 +4029,83 @@ mod tests {\n         );\n \n         tc!(\"\", \"\",\n-            eq: true,\n-            starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"\")\n-            );\n+        eq: true,\n+        starts_with: true,\n+        ends_with: true,\n+        relative_from: Some(\"\")\n+        );\n \n         tc!(\"foo\", \"\",\n-            eq: false,\n-            starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"foo\")\n-            );\n+        eq: false,\n+        starts_with: true,\n+        ends_with: true,\n+        relative_from: Some(\"foo\")\n+        );\n \n         tc!(\"\", \"foo\",\n-            eq: false,\n-            starts_with: false,\n-            ends_with: false,\n-            relative_from: None\n-            );\n+        eq: false,\n+        starts_with: false,\n+        ends_with: false,\n+        relative_from: None\n+        );\n \n         tc!(\"foo\", \"foo\",\n-            eq: true,\n-            starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"\")\n-            );\n+        eq: true,\n+        starts_with: true,\n+        ends_with: true,\n+        relative_from: Some(\"\")\n+        );\n \n         tc!(\"foo/\", \"foo\",\n-            eq: true,\n-            starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"\")\n-            );\n+        eq: true,\n+        starts_with: true,\n+        ends_with: true,\n+        relative_from: Some(\"\")\n+        );\n \n         tc!(\"foo/bar\", \"foo\",\n-            eq: false,\n-            starts_with: true,\n-            ends_with: false,\n-            relative_from: Some(\"bar\")\n-            );\n+        eq: false,\n+        starts_with: true,\n+        ends_with: false,\n+        relative_from: Some(\"bar\")\n+        );\n \n         tc!(\"foo/bar/baz\", \"foo/bar\",\n-            eq: false,\n-            starts_with: true,\n-            ends_with: false,\n-            relative_from: Some(\"baz\")\n-            );\n+        eq: false,\n+        starts_with: true,\n+        ends_with: false,\n+        relative_from: Some(\"baz\")\n+        );\n \n         tc!(\"foo/bar\", \"foo/bar/baz\",\n-            eq: false,\n-            starts_with: false,\n-            ends_with: false,\n-            relative_from: None\n-            );\n+        eq: false,\n+        starts_with: false,\n+        ends_with: false,\n+        relative_from: None\n+        );\n \n         tc!(\"./foo/bar/\", \".\",\n+        eq: false,\n+        starts_with: true,\n+        ends_with: false,\n+        relative_from: Some(\"foo/bar\")\n+        );\n+\n+        if cfg!(windows) {\n+            tc!(r\"C:\\src\\rust\\cargo-test\\test\\Cargo.toml\",\n+            r\"c:\\src\\rust\\cargo-test\\test\",\n             eq: false,\n             starts_with: true,\n             ends_with: false,\n-            relative_from: Some(\"foo/bar\")\n+            relative_from: Some(\"Cargo.toml\")\n             );\n \n-        if cfg!(windows) {\n-            tc!(r\"C:\\src\\rust\\cargo-test\\test\\Cargo.toml\",\n-                r\"c:\\src\\rust\\cargo-test\\test\",\n-                eq: false,\n-                starts_with: true,\n-                ends_with: false,\n-                relative_from: Some(\"Cargo.toml\")\n-                );\n-\n             tc!(r\"c:\\foo\", r\"C:\\foo\",\n-                eq: true,\n-                starts_with: true,\n-                ends_with: true,\n-                relative_from: Some(\"\")\n-                );\n+            eq: true,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"\")\n+            );\n         }\n     }\n "}, {"sha": "7c0efe828c27acff030c97a114b8dc5797631dc0", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 12, "deletions": 46, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,8 +2,6 @@\n //!\n //! See the [module-level documentation](../index.html) for more.\n \n-\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Re-exported core operators\n@@ -22,45 +20,27 @@ pub use crate::mem::drop;\n // Re-exported types and traits\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::convert::{AsRef, AsMut, Into, From};\n+pub use crate::convert::{AsMut, AsRef, From, Into};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{Iterator, Extend, IntoIterator};\n+pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n+pub use crate::iter::{Extend, IntoIterator, Iterator};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::option::Option::{self, Some, None};\n+pub use crate::option::Option::{self, None, Some};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::result::Result::{self, Ok, Err};\n+pub use crate::result::Result::{self, Err, Ok};\n \n // Re-exported built-in macros\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use core::prelude::v1::{\n-    asm,\n-    assert,\n-    cfg,\n-    column,\n-    compile_error,\n-    concat,\n-    concat_idents,\n-    env,\n-    file,\n-    format_args,\n-    format_args_nl,\n-    global_asm,\n-    include,\n-    include_bytes,\n-    include_str,\n-    line,\n-    log_syntax,\n-    module_path,\n-    option_env,\n-    stringify,\n-    trace_macros,\n+    asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n+    format_args_nl, global_asm, include, include_bytes, include_str, line, log_syntax, module_path,\n+    option_env, stringify, trace_macros,\n };\n \n // FIXME: Attribute and derive macros are not documented because for them rustdoc generates\n@@ -69,35 +49,21 @@ pub use core::prelude::v1::{\n #[allow(deprecated)]\n #[doc(hidden)]\n pub use core::prelude::v1::{\n-    Clone,\n-    Copy,\n-    Debug,\n-    Default,\n-    Eq,\n-    Hash,\n-    Ord,\n-    PartialEq,\n-    PartialOrd,\n-    RustcDecodable,\n-    RustcEncodable,\n-    bench,\n-    global_allocator,\n-    test,\n-    test_case,\n+    bench, global_allocator, test, test_case, Clone, Copy, Debug, Default, Eq, Hash, Ord,\n+    PartialEq, PartialOrd, RustcDecodable, RustcEncodable,\n };\n \n // The file so far is equivalent to src/libcore/prelude/v1.rs,\n // and below to src/liballoc/prelude.rs.\n // Those files are duplicated rather than using glob imports\n // because we want docs to show these re-exports as pointing to within `std`.\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::boxed::Box;\n+pub use crate::borrow::ToOwned;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::borrow::ToOwned;\n+pub use crate::boxed::Box;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::string::{String, ToString};"}, {"sha": "3eee45d000cd10ea6ac1237833606fcb2ad3e302", "filename": "src/libstd/process.rs", "status": "modified", "additions": 133, "deletions": 86, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -186,7 +186,9 @@ pub struct Child {\n }\n \n impl AsInner<imp::Process> for Child {\n-    fn as_inner(&self) -> &imp::Process { &self.handle }\n+    fn as_inner(&self) -> &imp::Process {\n+        &self.handle\n+    }\n }\n \n impl FromInner<(imp::Process, imp::StdioPipes)> for Child {\n@@ -201,7 +203,9 @@ impl FromInner<(imp::Process, imp::StdioPipes)> for Child {\n }\n \n impl IntoInner<imp::Process> for Child {\n-    fn into_inner(self) -> imp::Process { self.handle }\n+    fn into_inner(self) -> imp::Process {\n+        self.handle\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -228,7 +232,7 @@ impl fmt::Debug for Child {\n /// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n-    inner: AnonPipe\n+    inner: AnonPipe,\n }\n \n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -247,11 +251,15 @@ impl Write for ChildStdin {\n }\n \n impl AsInner<AnonPipe> for ChildStdin {\n-    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+    fn as_inner(&self) -> &AnonPipe {\n+        &self.inner\n+    }\n }\n \n impl IntoInner<AnonPipe> for ChildStdin {\n-    fn into_inner(self) -> AnonPipe { self.inner }\n+    fn into_inner(self) -> AnonPipe {\n+        self.inner\n+    }\n }\n \n impl FromInner<AnonPipe> for ChildStdin {\n@@ -279,7 +287,7 @@ impl fmt::Debug for ChildStdin {\n /// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n-    inner: AnonPipe\n+    inner: AnonPipe,\n }\n \n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -299,11 +307,15 @@ impl Read for ChildStdout {\n }\n \n impl AsInner<AnonPipe> for ChildStdout {\n-    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+    fn as_inner(&self) -> &AnonPipe {\n+        &self.inner\n+    }\n }\n \n impl IntoInner<AnonPipe> for ChildStdout {\n-    fn into_inner(self) -> AnonPipe { self.inner }\n+    fn into_inner(self) -> AnonPipe {\n+        self.inner\n+    }\n }\n \n impl FromInner<AnonPipe> for ChildStdout {\n@@ -331,7 +343,7 @@ impl fmt::Debug for ChildStdout {\n /// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n-    inner: AnonPipe\n+    inner: AnonPipe,\n }\n \n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -351,11 +363,15 @@ impl Read for ChildStderr {\n }\n \n impl AsInner<AnonPipe> for ChildStderr {\n-    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+    fn as_inner(&self) -> &AnonPipe {\n+        &self.inner\n+    }\n }\n \n impl IntoInner<AnonPipe> for ChildStderr {\n-    fn into_inner(self) -> AnonPipe { self.inner }\n+    fn into_inner(self) -> AnonPipe {\n+        self.inner\n+    }\n }\n \n impl FromInner<AnonPipe> for ChildStderr {\n@@ -533,7 +549,9 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn args<I, S>(&mut self, args: I) -> &mut Command\n-        where I: IntoIterator<Item=S>, S: AsRef<OsStr>\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n     {\n         for arg in args {\n             self.arg(arg.as_ref());\n@@ -560,7 +578,9 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n-        where K: AsRef<OsStr>, V: AsRef<OsStr>\n+    where\n+        K: AsRef<OsStr>,\n+        V: AsRef<OsStr>,\n     {\n         self.inner.env_mut().set(key.as_ref(), val.as_ref());\n         self\n@@ -592,7 +612,10 @@ impl Command {\n     /// ```\n     #[stable(feature = \"command_envs\", since = \"1.19.0\")]\n     pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Command\n-        where I: IntoIterator<Item=(K, V)>, K: AsRef<OsStr>, V: AsRef<OsStr>\n+    where\n+        I: IntoIterator<Item = (K, V)>,\n+        K: AsRef<OsStr>,\n+        V: AsRef<OsStr>,\n     {\n         for (ref key, ref val) in vars {\n             self.inner.env_mut().set(key.as_ref(), val.as_ref());\n@@ -794,7 +817,9 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn output(&mut self) -> io::Result<Output> {\n-        self.inner.spawn(imp::Stdio::MakePipe, false).map(Child::from_inner)\n+        self.inner\n+            .spawn(imp::Stdio::MakePipe, false)\n+            .map(Child::from_inner)\n             .and_then(|p| p.wait_with_output())\n     }\n \n@@ -819,8 +844,10 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn status(&mut self) -> io::Result<ExitStatus> {\n-        self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n-                  .and_then(|mut p| p.wait())\n+        self.inner\n+            .spawn(imp::Stdio::Inherit, true)\n+            .map(Child::from_inner)\n+            .and_then(|mut p| p.wait())\n     }\n }\n \n@@ -835,11 +862,15 @@ impl fmt::Debug for Command {\n }\n \n impl AsInner<imp::Command> for Command {\n-    fn as_inner(&self) -> &imp::Command { &self.inner }\n+    fn as_inner(&self) -> &imp::Command {\n+        &self.inner\n+    }\n }\n \n impl AsInnerMut<imp::Command> for Command {\n-    fn as_inner_mut(&mut self) -> &mut imp::Command { &mut self.inner }\n+    fn as_inner_mut(&mut self) -> &mut imp::Command {\n+        &mut self.inner\n+    }\n }\n \n /// The output of a finished process.\n@@ -871,17 +902,16 @@ pub struct Output {\n #[stable(feature = \"process_output_debug\", since = \"1.7.0\")]\n impl fmt::Debug for Output {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-\n         let stdout_utf8 = str::from_utf8(&self.stdout);\n         let stdout_debug: &dyn fmt::Debug = match stdout_utf8 {\n             Ok(ref str) => str,\n-            Err(_) => &self.stdout\n+            Err(_) => &self.stdout,\n         };\n \n         let stderr_utf8 = str::from_utf8(&self.stderr);\n         let stderr_debug: &dyn fmt::Debug = match stderr_utf8 {\n             Ok(ref str) => str,\n-            Err(_) => &self.stderr\n+            Err(_) => &self.stderr,\n         };\n \n         fmt.debug_struct(\"Output\")\n@@ -943,7 +973,9 @@ impl Stdio {\n     /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\");\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn piped() -> Stdio { Stdio(imp::Stdio::MakePipe) }\n+    pub fn piped() -> Stdio {\n+        Stdio(imp::Stdio::MakePipe)\n+    }\n \n     /// The child inherits from the corresponding parent descriptor.\n     ///\n@@ -980,7 +1012,9 @@ impl Stdio {\n     /// io::stdout().write_all(&output.stdout).unwrap();\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn inherit() -> Stdio { Stdio(imp::Stdio::Inherit) }\n+    pub fn inherit() -> Stdio {\n+        Stdio(imp::Stdio::Inherit)\n+    }\n \n     /// This stream will be ignored. This is the equivalent of attaching the\n     /// stream to `/dev/null`\n@@ -1017,7 +1051,9 @@ impl Stdio {\n     /// // Ignores any piped-in input\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn null() -> Stdio { Stdio(imp::Stdio::Null) }\n+    pub fn null() -> Stdio {\n+        Stdio(imp::Stdio::Null)\n+    }\n }\n \n impl FromInner<imp::Stdio> for Stdio {\n@@ -1217,7 +1253,9 @@ impl ExitStatus {\n }\n \n impl AsInner<imp::ExitStatus> for ExitStatus {\n-    fn as_inner(&self) -> &imp::ExitStatus { &self.0 }\n+    fn as_inner(&self) -> &imp::ExitStatus {\n+        &self.0\n+    }\n }\n \n impl FromInner<imp::ExitStatus> for ExitStatus {\n@@ -1449,11 +1487,7 @@ impl Child {\n         }\n \n         let status = self.wait()?;\n-        Ok(Output {\n-            status,\n-            stdout,\n-            stderr,\n-        })\n+        Ok(Output { status, stdout, stderr })\n     }\n }\n \n@@ -1604,8 +1638,9 @@ pub fn id() -> u32 {\n #[cfg_attr(not(test), lang = \"termination\")]\n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n #[rustc_on_unimplemented(\n-  message=\"`main` has invalid return type `{Self}`\",\n-  label=\"`main` can only return types that implement `{Termination}`\")]\n+    message = \"`main` has invalid return type `{Self}`\",\n+    label = \"`main` can only return types that implement `{Termination}`\"\n+)]\n pub trait Termination {\n     /// Is called to get the representation of the value as status code.\n     /// This status code is returned to the operating system.\n@@ -1615,7 +1650,9 @@ pub trait Termination {\n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n impl Termination for () {\n     #[inline]\n-    fn report(self) -> i32 { ExitCode::SUCCESS.report() }\n+    fn report(self) -> i32 {\n+        ExitCode::SUCCESS.report()\n+    }\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n@@ -1630,7 +1667,9 @@ impl<E: fmt::Debug> Termination for Result<(), E> {\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n impl Termination for ! {\n-    fn report(self) -> i32 { self }\n+    fn report(self) -> i32 {\n+        self\n+    }\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n@@ -1654,9 +1693,9 @@ impl Termination for ExitCode {\n mod tests {\n     use crate::io::prelude::*;\n \n+    use super::{Command, Output, Stdio};\n     use crate::io::ErrorKind;\n     use crate::str;\n-    use super::{Command, Output, Stdio};\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n \n@@ -1702,15 +1741,12 @@ mod tests {\n     fn signal_reported_right() {\n         use crate::os::unix::process::ExitStatusExt;\n \n-        let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"read a\")\n-                            .stdin(Stdio::piped())\n-                            .spawn().unwrap();\n+        let mut p =\n+            Command::new(\"/bin/sh\").arg(\"-c\").arg(\"read a\").stdin(Stdio::piped()).spawn().unwrap();\n         p.kill().unwrap();\n         match p.wait().unwrap().signal() {\n-            Some(9) => {},\n-            result => panic!(\"not terminated by signal 9 (instead, {:?})\",\n-                             result),\n+            Some(9) => {}\n+            result => panic!(\"not terminated by signal 9 (instead, {:?})\", result),\n         }\n     }\n \n@@ -1743,20 +1779,20 @@ mod tests {\n     #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n     fn set_current_dir_works() {\n         let mut cmd = Command::new(\"/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"pwd\")\n-           .current_dir(\"/\")\n-           .stdout(Stdio::piped());\n+        cmd.arg(\"-c\").arg(\"pwd\").current_dir(\"/\").stdout(Stdio::piped());\n         assert_eq!(run_output(cmd), \"/\\n\");\n     }\n \n     #[test]\n     #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n     fn stdin_works() {\n         let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"read line; echo $line\")\n-                            .stdin(Stdio::piped())\n-                            .stdout(Stdio::piped())\n-                            .spawn().unwrap();\n+            .arg(\"-c\")\n+            .arg(\"read line; echo $line\")\n+            .stdin(Stdio::piped())\n+            .stdout(Stdio::piped())\n+            .spawn()\n+            .unwrap();\n         p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n         drop(p.stdin.take());\n         let mut out = String::new();\n@@ -1787,19 +1823,18 @@ mod tests {\n     fn test_process_output_fail_to_start() {\n         match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n             Err(e) => assert_eq!(e.kind(), ErrorKind::NotFound),\n-            Ok(..) => panic!()\n+            Ok(..) => panic!(),\n         }\n     }\n \n     #[test]\n     #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n     fn test_process_output_output() {\n-        let Output {status, stdout, stderr}\n-             = if cfg!(target_os = \"windows\") {\n-                 Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).output().unwrap()\n-             } else {\n-                 Command::new(\"echo\").arg(\"hello\").output().unwrap()\n-             };\n+        let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).output().unwrap()\n+        } else {\n+            Command::new(\"echo\").arg(\"hello\").output().unwrap()\n+        };\n         let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n@@ -1810,12 +1845,11 @@ mod tests {\n     #[test]\n     #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n     fn test_process_output_error() {\n-        let Output {status, stdout, stderr}\n-             = if cfg!(target_os = \"windows\") {\n-                 Command::new(\"cmd\").args(&[\"/C\", \"mkdir .\"]).output().unwrap()\n-             } else {\n-                 Command::new(\"mkdir\").arg(\"./\").output().unwrap()\n-             };\n+        let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"mkdir .\"]).output().unwrap()\n+        } else {\n+            Command::new(\"mkdir\").arg(\"./\").output().unwrap()\n+        };\n \n         assert!(status.code() == Some(1));\n         assert_eq!(stdout, Vec::new());\n@@ -1854,19 +1888,19 @@ mod tests {\n             Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped()).spawn().unwrap()\n         };\n \n-        let Output {status, stdout, stderr} = prog.wait_with_output().unwrap();\n+        let Output { status, stdout, stderr } = prog.wait_with_output().unwrap();\n         let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n         assert_eq!(stderr, Vec::new());\n     }\n \n-    #[cfg(all(unix, not(target_os=\"android\")))]\n+    #[cfg(all(unix, not(target_os = \"android\")))]\n     pub fn env_cmd() -> Command {\n         Command::new(\"env\")\n     }\n-    #[cfg(target_os=\"android\")]\n+    #[cfg(target_os = \"android\")]\n     pub fn env_cmd() -> Command {\n         let mut cmd = Command::new(\"/system/bin/sh\");\n         cmd.arg(\"-c\").arg(\"set\");\n@@ -1897,8 +1931,11 @@ mod tests {\n         let result = cmd.output().unwrap();\n         let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+        assert!(\n+            output.contains(\"RUN_TEST_NEW_ENV=123\"),\n+            \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n+            output\n+        );\n     }\n \n     #[test]\n@@ -1907,8 +1944,11 @@ mod tests {\n         let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n         let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+        assert!(\n+            output.contains(\"RUN_TEST_NEW_ENV=123\"),\n+            \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n+            output\n+        );\n     }\n \n     #[test]\n@@ -1927,10 +1967,16 @@ mod tests {\n \n         let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n-        assert!(output.contains(\"RUN_TEST_NEW_ENV1=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV1 inside of:\\n\\n{}\", output);\n-        assert!(output.contains(\"RUN_TEST_NEW_ENV2=456\"),\n-                \"didn't find RUN_TEST_NEW_ENV2 inside of:\\n\\n{}\", output);\n+        assert!(\n+            output.contains(\"RUN_TEST_NEW_ENV1=123\"),\n+            \"didn't find RUN_TEST_NEW_ENV1 inside of:\\n\\n{}\",\n+            output\n+        );\n+        assert!(\n+            output.contains(\"RUN_TEST_NEW_ENV2=456\"),\n+            \"didn't find RUN_TEST_NEW_ENV2 inside of:\\n\\n{}\",\n+            output\n+        );\n     }\n \n     // Regression tests for #30858.\n@@ -2005,8 +2051,11 @@ mod tests {\n \n         extern \"system\" {\n             fn WaitForDebugEvent(lpDebugEvent: *mut DEBUG_EVENT, dwMilliseconds: DWORD) -> BOOL;\n-            fn ContinueDebugEvent(dwProcessId: DWORD, dwThreadId: DWORD,\n-                                  dwContinueStatus: DWORD) -> BOOL;\n+            fn ContinueDebugEvent(\n+                dwProcessId: DWORD,\n+                dwThreadId: DWORD,\n+                dwContinueStatus: DWORD,\n+            ) -> BOOL;\n         }\n \n         const DEBUG_PROCESS: DWORD = 1;\n@@ -2015,15 +2064,12 @@ mod tests {\n \n         let mut child = Command::new(\"cmd\")\n             .creation_flags(DEBUG_PROCESS)\n-            .stdin(Stdio::piped()).spawn().unwrap();\n+            .stdin(Stdio::piped())\n+            .spawn()\n+            .unwrap();\n         child.stdin.take().unwrap().write_all(b\"exit\\r\\n\").unwrap();\n         let mut events = 0;\n-        let mut event = DEBUG_EVENT {\n-            event_code: 0,\n-            process_id: 0,\n-            thread_id: 0,\n-            _junk: [0; 164],\n-        };\n+        let mut event = DEBUG_EVENT { event_code: 0, process_id: 0, thread_id: 0, _junk: [0; 164] };\n         loop {\n             if unsafe { WaitForDebugEvent(&mut event as *mut DEBUG_EVENT, INFINITE) } == 0 {\n                 panic!(\"WaitForDebugEvent failed!\");\n@@ -2034,9 +2080,10 @@ mod tests {\n                 break;\n             }\n \n-            if unsafe { ContinueDebugEvent(event.process_id,\n-                                           event.thread_id,\n-                                           DBG_EXCEPTION_NOT_HANDLED) } == 0 {\n+            if unsafe {\n+                ContinueDebugEvent(event.process_id, event.thread_id, DBG_EXCEPTION_NOT_HANDLED)\n+            } == 0\n+            {\n                 panic!(\"ContinueDebugEvent failed!\");\n             }\n         }"}, {"sha": "1ed984509d27c56a0d55849e63fb4d981d296f9c", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,21 +6,25 @@\n //! and should be considered as private implementation details for the\n //! time being.\n \n-#![unstable(feature = \"rt\",\n-            reason = \"this public module should not exist and is highly likely \\\n-                      to disappear\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"rt\",\n+    reason = \"this public module should not exist and is highly likely \\\n+              to disappear\",\n+    issue = \"0\"\n+)]\n #![doc(hidden)]\n \n-\n // Re-export some of our utilities which are expected by other crates.\n pub use crate::panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n \n // To reduce the generated code of the new `lang_start`, this function is doing\n // the real work.\n #[cfg(not(test))]\n-fn lang_start_internal(main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindSafe),\n-                       argc: isize, argv: *const *const u8) -> isize {\n+fn lang_start_internal(\n+    main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindSafe),\n+    argc: isize,\n+    argv: *const *const u8,\n+) -> isize {\n     use crate::panic;\n     use crate::sys;\n     use crate::sys_common;\n@@ -55,8 +59,10 @@ fn lang_start_internal(main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindS\n \n #[cfg(not(test))]\n #[lang = \"start\"]\n-fn lang_start<T: crate::process::Termination + 'static>\n-    (main: fn() -> T, argc: isize, argv: *const *const u8) -> isize\n-{\n+fn lang_start<T: crate::process::Termination + 'static>(\n+    main: fn() -> T,\n+    argc: isize,\n+    argv: *const *const u8,\n+) -> isize {\n     lang_start_internal(&move || main().report(), argc, argv)\n }"}, {"sha": "eddbdff257a992a21b09eb1a5acdd707340203a7", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n use crate::fmt;\n-use crate::sync::{Mutex, Condvar};\n+use crate::sync::{Condvar, Mutex};\n \n /// A barrier enables multiple threads to synchronize the beginning\n /// of some computation.\n@@ -82,10 +82,7 @@ impl Barrier {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(n: usize) -> Barrier {\n         Barrier {\n-            lock: Mutex::new(BarrierState {\n-                count: 0,\n-                generation_id: 0,\n-            }),\n+            lock: Mutex::new(BarrierState { count: 0, generation_id: 0 }),\n             cvar: Condvar::new(),\n             num_threads: n,\n         }\n@@ -135,8 +132,7 @@ impl Barrier {\n         if lock.count < self.num_threads {\n             // We need a while loop to guard against spurious wakeups.\n             // http://en.wikipedia.org/wiki/Spurious_wakeup\n-            while local_gen == lock.generation_id &&\n-                  lock.count < self.num_threads {\n+            while local_gen == lock.generation_id && lock.count < self.num_threads {\n                 lock = self.cvar.wait(lock).unwrap();\n             }\n             BarrierWaitResult(false)\n@@ -152,9 +148,7 @@ impl Barrier {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for BarrierWaitResult {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BarrierWaitResult\")\n-            .field(\"is_leader\", &self.is_leader())\n-            .finish()\n+        f.debug_struct(\"BarrierWaitResult\").field(\"is_leader\", &self.is_leader()).finish()\n     }\n }\n \n@@ -176,13 +170,15 @@ impl BarrierWaitResult {\n     /// println!(\"{:?}\", barrier_wait_result.is_leader());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_leader(&self) -> bool { self.0 }\n+    pub fn is_leader(&self) -> bool {\n+        self.0\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::sync::{Arc, Barrier};\n     use crate::sync::mpsc::{channel, TryRecvError};\n+    use crate::sync::{Arc, Barrier};\n     use crate::thread;\n \n     #[test]\n@@ -196,7 +192,7 @@ mod tests {\n         for _ in 0..N - 1 {\n             let c = barrier.clone();\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 tx.send(c.wait().is_leader()).unwrap();\n             });\n         }"}, {"sha": "d34de6a4fac3e9bfe87f62449f23c12b37f7c5b8", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n //! Generic support for building blocking abstractions.\n \n-use crate::thread::{self, Thread};\n+use crate::mem;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::Arc;\n-use crate::mem;\n+use crate::thread::{self, Thread};\n use crate::time::Instant;\n \n struct Inner {\n@@ -28,16 +28,9 @@ impl !Send for WaitToken {}\n impl !Sync for WaitToken {}\n \n pub fn tokens() -> (WaitToken, SignalToken) {\n-    let inner = Arc::new(Inner {\n-        thread: thread::current(),\n-        woken: AtomicBool::new(false),\n-    });\n-    let wait_token = WaitToken {\n-        inner: inner.clone(),\n-    };\n-    let signal_token = SignalToken {\n-        inner,\n-    };\n+    let inner = Arc::new(Inner { thread: thread::current(), woken: AtomicBool::new(false) });\n+    let wait_token = WaitToken { inner: inner.clone() };\n+    let signal_token = SignalToken { inner };\n     (wait_token, signal_token)\n }\n "}, {"sha": "b0842144328a8bfa2f21f11d2f2e338fc5bd04cf", "filename": "src/libstd/sync/mpsc/cache_aligned.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -8,16 +8,16 @@ pub(super) struct Aligner;\n pub(super) struct CacheAligned<T>(pub T, pub Aligner);\n \n impl<T> Deref for CacheAligned<T> {\n-     type Target = T;\n-     fn deref(&self) -> &Self::Target {\n-         &self.0\n-     }\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n }\n \n impl<T> DerefMut for CacheAligned<T> {\n-     fn deref_mut(&mut self) -> &mut Self::Target {\n-         &mut self.0\n-     }\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n }\n \n impl<T> CacheAligned<T> {"}, {"sha": "2831bbcb88d2e49e790f3f420b368a808263cb85", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 251, "deletions": 259, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -269,20 +269,20 @@\n // And now that you've seen all the races that I found and attempted to fix,\n // here's the code for you to find some more!\n \n-use crate::sync::Arc;\n+use crate::cell::UnsafeCell;\n use crate::error;\n use crate::fmt;\n use crate::mem;\n-use crate::cell::UnsafeCell;\n+use crate::sync::Arc;\n use crate::time::{Duration, Instant};\n \n mod blocking;\n+mod mpsc_queue;\n mod oneshot;\n mod shared;\n+mod spsc_queue;\n mod stream;\n mod sync;\n-mod mpsc_queue;\n-mod spsc_queue;\n \n mod cache_aligned;\n \n@@ -322,10 +322,10 @@ pub struct Receiver<T> {\n // The receiver port can be sent from place to place, so long as it\n // is not used to receive non-sendable things.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for Receiver<T> { }\n+unsafe impl<T: Send> Send for Receiver<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> !Sync for Receiver<T> { }\n+impl<T> !Sync for Receiver<T> {}\n \n /// An iterator over messages on a [`Receiver`], created by [`iter`].\n ///\n@@ -359,7 +359,7 @@ impl<T> !Sync for Receiver<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, T: 'a> {\n-    rx: &'a Receiver<T>\n+    rx: &'a Receiver<T>,\n }\n \n /// An iterator that attempts to yield all pending values for a [`Receiver`],\n@@ -404,7 +404,7 @@ pub struct Iter<'a, T: 'a> {\n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n #[derive(Debug)]\n pub struct TryIter<'a, T: 'a> {\n-    rx: &'a Receiver<T>\n+    rx: &'a Receiver<T>,\n }\n \n /// An owning iterator over messages on a [`Receiver`],\n@@ -439,7 +439,7 @@ pub struct TryIter<'a, T: 'a> {\n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n-    rx: Receiver<T>\n+    rx: Receiver<T>,\n }\n \n /// The sending-half of Rust's asynchronous [`channel`] type. This half can only be\n@@ -482,10 +482,10 @@ pub struct Sender<T> {\n // The send port can be sent from place to place, so long as it\n // is not used to send non-sendable things.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for Sender<T> { }\n+unsafe impl<T: Send> Send for Sender<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> !Sync for Sender<T> { }\n+impl<T> !Sync for Sender<T> {}\n \n /// The sending-half of Rust's synchronous [`sync_channel`] type.\n ///\n@@ -772,9 +772,7 @@ pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n \n impl<T> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n-        Sender {\n-            inner: UnsafeCell::new(inner),\n-        }\n+        Sender { inner: UnsafeCell::new(inner) }\n     }\n \n     /// Attempts to send a value on this channel, returning it back if it could\n@@ -856,8 +854,7 @@ impl<T> Clone for Sender<T> {\n                     let guard = a.postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n                     let sleeper = match p.upgrade(rx) {\n-                        oneshot::UpSuccess |\n-                        oneshot::UpDisconnected => None,\n+                        oneshot::UpSuccess | oneshot::UpDisconnected => None,\n                         oneshot::UpWoke(task) => Some(task),\n                     };\n                     a.inherit_blocker(sleeper, guard);\n@@ -870,8 +867,7 @@ impl<T> Clone for Sender<T> {\n                     let guard = a.postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n                     let sleeper = match p.upgrade(rx) {\n-                        stream::UpSuccess |\n-                        stream::UpDisconnected => None,\n+                        stream::UpSuccess | stream::UpDisconnected => None,\n                         stream::UpWoke(task) => Some(task),\n                     };\n                     a.inherit_blocker(sleeper, guard);\n@@ -1078,48 +1074,31 @@ impl<T> Receiver<T> {\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.try_recv() {\n-                        Ok(t) => return Ok(t),\n-                        Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n-                        Err(oneshot::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n-                        Err(oneshot::Upgraded(rx)) => rx,\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.try_recv() {\n-                        Ok(t) => return Ok(t),\n-                        Err(stream::Empty) => return Err(TryRecvError::Empty),\n-                        Err(stream::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n-                        Err(stream::Upgraded(rx)) => rx,\n-                    }\n-                }\n-                Flavor::Shared(ref p) => {\n-                    match p.try_recv() {\n-                        Ok(t) => return Ok(t),\n-                        Err(shared::Empty) => return Err(TryRecvError::Empty),\n-                        Err(shared::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n-                    }\n-                }\n-                Flavor::Sync(ref p) => {\n-                    match p.try_recv() {\n-                        Ok(t) => return Ok(t),\n-                        Err(sync::Empty) => return Err(TryRecvError::Empty),\n-                        Err(sync::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n-                    }\n-                }\n+                Flavor::Oneshot(ref p) => match p.try_recv() {\n+                    Ok(t) => return Ok(t),\n+                    Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n+                    Err(oneshot::Disconnected) => return Err(TryRecvError::Disconnected),\n+                    Err(oneshot::Upgraded(rx)) => rx,\n+                },\n+                Flavor::Stream(ref p) => match p.try_recv() {\n+                    Ok(t) => return Ok(t),\n+                    Err(stream::Empty) => return Err(TryRecvError::Empty),\n+                    Err(stream::Disconnected) => return Err(TryRecvError::Disconnected),\n+                    Err(stream::Upgraded(rx)) => rx,\n+                },\n+                Flavor::Shared(ref p) => match p.try_recv() {\n+                    Ok(t) => return Ok(t),\n+                    Err(shared::Empty) => return Err(TryRecvError::Empty),\n+                    Err(shared::Disconnected) => return Err(TryRecvError::Disconnected),\n+                },\n+                Flavor::Sync(ref p) => match p.try_recv() {\n+                    Ok(t) => return Ok(t),\n+                    Err(sync::Empty) => return Err(TryRecvError::Empty),\n+                    Err(sync::Disconnected) => return Err(TryRecvError::Disconnected),\n+                },\n             };\n             unsafe {\n-                mem::swap(self.inner_mut(),\n-                          new_port.inner_mut());\n+                mem::swap(self.inner_mut(), new_port.inner_mut());\n             }\n         }\n     }\n@@ -1185,29 +1164,23 @@ impl<T> Receiver<T> {\n     pub fn recv(&self) -> Result<T, RecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.recv(None) {\n-                        Ok(t) => return Ok(t),\n-                        Err(oneshot::Disconnected) => return Err(RecvError),\n-                        Err(oneshot::Upgraded(rx)) => rx,\n-                        Err(oneshot::Empty) => unreachable!(),\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.recv(None) {\n-                        Ok(t) => return Ok(t),\n-                        Err(stream::Disconnected) => return Err(RecvError),\n-                        Err(stream::Upgraded(rx)) => rx,\n-                        Err(stream::Empty) => unreachable!(),\n-                    }\n-                }\n-                Flavor::Shared(ref p) => {\n-                    match p.recv(None) {\n-                        Ok(t) => return Ok(t),\n-                        Err(shared::Disconnected) => return Err(RecvError),\n-                        Err(shared::Empty) => unreachable!(),\n-                    }\n-                }\n+                Flavor::Oneshot(ref p) => match p.recv(None) {\n+                    Ok(t) => return Ok(t),\n+                    Err(oneshot::Disconnected) => return Err(RecvError),\n+                    Err(oneshot::Upgraded(rx)) => rx,\n+                    Err(oneshot::Empty) => unreachable!(),\n+                },\n+                Flavor::Stream(ref p) => match p.recv(None) {\n+                    Ok(t) => return Ok(t),\n+                    Err(stream::Disconnected) => return Err(RecvError),\n+                    Err(stream::Upgraded(rx)) => rx,\n+                    Err(stream::Empty) => unreachable!(),\n+                },\n+                Flavor::Shared(ref p) => match p.recv(None) {\n+                    Ok(t) => return Ok(t),\n+                    Err(shared::Disconnected) => return Err(RecvError),\n+                    Err(shared::Empty) => unreachable!(),\n+                },\n                 Flavor::Sync(ref p) => return p.recv(None).map_err(|_| RecvError),\n             };\n             unsafe {\n@@ -1383,36 +1356,28 @@ impl<T> Receiver<T> {\n \n         loop {\n             let port_or_empty = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.recv(Some(deadline)) {\n-                        Ok(t) => return Ok(t),\n-                        Err(oneshot::Disconnected) => return Err(Disconnected),\n-                        Err(oneshot::Upgraded(rx)) => Some(rx),\n-                        Err(oneshot::Empty) => None,\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.recv(Some(deadline)) {\n-                        Ok(t) => return Ok(t),\n-                        Err(stream::Disconnected) => return Err(Disconnected),\n-                        Err(stream::Upgraded(rx)) => Some(rx),\n-                        Err(stream::Empty) => None,\n-                    }\n-                }\n-                Flavor::Shared(ref p) => {\n-                    match p.recv(Some(deadline)) {\n-                        Ok(t) => return Ok(t),\n-                        Err(shared::Disconnected) => return Err(Disconnected),\n-                        Err(shared::Empty) => None,\n-                    }\n-                }\n-                Flavor::Sync(ref p) => {\n-                    match p.recv(Some(deadline)) {\n-                        Ok(t) => return Ok(t),\n-                        Err(sync::Disconnected) => return Err(Disconnected),\n-                        Err(sync::Empty) => None,\n-                    }\n-                }\n+                Flavor::Oneshot(ref p) => match p.recv(Some(deadline)) {\n+                    Ok(t) => return Ok(t),\n+                    Err(oneshot::Disconnected) => return Err(Disconnected),\n+                    Err(oneshot::Upgraded(rx)) => Some(rx),\n+                    Err(oneshot::Empty) => None,\n+                },\n+                Flavor::Stream(ref p) => match p.recv(Some(deadline)) {\n+                    Ok(t) => return Ok(t),\n+                    Err(stream::Disconnected) => return Err(Disconnected),\n+                    Err(stream::Upgraded(rx)) => Some(rx),\n+                    Err(stream::Empty) => None,\n+                },\n+                Flavor::Shared(ref p) => match p.recv(Some(deadline)) {\n+                    Ok(t) => return Ok(t),\n+                    Err(shared::Disconnected) => return Err(Disconnected),\n+                    Err(shared::Empty) => None,\n+                },\n+                Flavor::Sync(ref p) => match p.recv(Some(deadline)) {\n+                    Ok(t) => return Ok(t),\n+                    Err(sync::Disconnected) => return Err(Disconnected),\n+                    Err(sync::Empty) => None,\n+                },\n             };\n \n             if let Some(new_port) = port_or_empty {\n@@ -1502,39 +1467,46 @@ impl<T> Receiver<T> {\n     pub fn try_iter(&self) -> TryIter<'_, T> {\n         TryIter { rx: self }\n     }\n-\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = T;\n \n-    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n+    fn next(&mut self) -> Option<T> {\n+        self.rx.recv().ok()\n+    }\n }\n \n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n impl<'a, T> Iterator for TryIter<'a, T> {\n     type Item = T;\n \n-    fn next(&mut self) -> Option<T> { self.rx.try_recv().ok() }\n+    fn next(&mut self) -> Option<T> {\n+        self.rx.try_recv().ok()\n+    }\n }\n \n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n impl<'a, T> IntoIterator for &'a Receiver<T> {\n     type Item = T;\n     type IntoIter = Iter<'a, T>;\n \n-    fn into_iter(self) -> Iter<'a, T> { self.iter() }\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n }\n \n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n-    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n+    fn next(&mut self) -> Option<T> {\n+        self.rx.recv().ok()\n+    }\n }\n \n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n-impl <T> IntoIterator for Receiver<T> {\n+impl<T> IntoIterator for Receiver<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -1597,27 +1569,18 @@ impl<T> fmt::Debug for TrySendError<T> {\n impl<T> fmt::Display for TrySendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            TrySendError::Full(..) => {\n-                \"sending on a full channel\".fmt(f)\n-            }\n-            TrySendError::Disconnected(..) => {\n-                \"sending on a closed channel\".fmt(f)\n-            }\n+            TrySendError::Full(..) => \"sending on a full channel\".fmt(f),\n+            TrySendError::Disconnected(..) => \"sending on a closed channel\".fmt(f),\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> error::Error for TrySendError<T> {\n-\n     fn description(&self) -> &str {\n         match *self {\n-            TrySendError::Full(..) => {\n-                \"sending on a full channel\"\n-            }\n-            TrySendError::Disconnected(..) => {\n-                \"sending on a closed channel\"\n-            }\n+            TrySendError::Full(..) => \"sending on a full channel\",\n+            TrySendError::Disconnected(..) => \"sending on a closed channel\",\n         }\n     }\n }\n@@ -1640,7 +1603,6 @@ impl fmt::Display for RecvError {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl error::Error for RecvError {\n-\n     fn description(&self) -> &str {\n         \"receiving on a closed channel\"\n     }\n@@ -1650,27 +1612,18 @@ impl error::Error for RecvError {\n impl fmt::Display for TryRecvError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            TryRecvError::Empty => {\n-                \"receiving on an empty channel\".fmt(f)\n-            }\n-            TryRecvError::Disconnected => {\n-                \"receiving on a closed channel\".fmt(f)\n-            }\n+            TryRecvError::Empty => \"receiving on an empty channel\".fmt(f),\n+            TryRecvError::Disconnected => \"receiving on a closed channel\".fmt(f),\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl error::Error for TryRecvError {\n-\n     fn description(&self) -> &str {\n         match *self {\n-            TryRecvError::Empty => {\n-                \"receiving on an empty channel\"\n-            }\n-            TryRecvError::Disconnected => {\n-                \"receiving on a closed channel\"\n-            }\n+            TryRecvError::Empty => \"receiving on an empty channel\",\n+            TryRecvError::Disconnected => \"receiving on a closed channel\",\n         }\n     }\n }\n@@ -1688,12 +1641,8 @@ impl From<RecvError> for TryRecvError {\n impl fmt::Display for RecvTimeoutError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            RecvTimeoutError::Timeout => {\n-                \"timed out waiting on channel\".fmt(f)\n-            }\n-            RecvTimeoutError::Disconnected => {\n-                \"channel is empty and sending half is closed\".fmt(f)\n-            }\n+            RecvTimeoutError::Timeout => \"timed out waiting on channel\".fmt(f),\n+            RecvTimeoutError::Disconnected => \"channel is empty and sending half is closed\".fmt(f),\n         }\n     }\n }\n@@ -1702,12 +1651,8 @@ impl fmt::Display for RecvTimeoutError {\n impl error::Error for RecvTimeoutError {\n     fn description(&self) -> &str {\n         match *self {\n-            RecvTimeoutError::Timeout => {\n-                \"timed out waiting on channel\"\n-            }\n-            RecvTimeoutError::Disconnected => {\n-                \"channel is empty and sending half is closed\"\n-            }\n+            RecvTimeoutError::Timeout => \"timed out waiting on channel\",\n+            RecvTimeoutError::Disconnected => \"channel is empty and sending half is closed\",\n         }\n     }\n }\n@@ -1769,7 +1714,7 @@ mod tests {\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = channel::<i32>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             tx.send(1).unwrap();\n         });\n         assert_eq!(rx.recv().unwrap(), 1);\n@@ -1801,7 +1746,7 @@ mod tests {\n     #[test]\n     fn port_gone_concurrent() {\n         let (tx, rx) = channel::<i32>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() {}\n@@ -1811,7 +1756,7 @@ mod tests {\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<i32>();\n         let tx2 = tx.clone();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n@@ -1836,7 +1781,7 @@ mod tests {\n     #[test]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<i32>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n         });\n@@ -1846,8 +1791,10 @@ mod tests {\n     #[test]\n     fn stress() {\n         let (tx, rx) = channel::<i32>();\n-        let t = thread::spawn(move|| {\n-            for _ in 0..10000 { tx.send(1).unwrap(); }\n+        let t = thread::spawn(move || {\n+            for _ in 0..10000 {\n+                tx.send(1).unwrap();\n+            }\n         });\n         for _ in 0..10000 {\n             assert_eq!(rx.recv().unwrap(), 1);\n@@ -1861,7 +1808,7 @@ mod tests {\n         const NTHREADS: u32 = 8;\n         let (tx, rx) = channel::<i32>();\n \n-        let t = thread::spawn(move|| {\n+        let t = thread::spawn(move || {\n             for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1873,8 +1820,10 @@ mod tests {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n-                for _ in 0..AMT { tx.send(1).unwrap(); }\n+            thread::spawn(move || {\n+                for _ in 0..AMT {\n+                    tx.send(1).unwrap();\n+                }\n             });\n         }\n         drop(tx);\n@@ -1885,14 +1834,14 @@ mod tests {\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<i32>();\n-        let t1 = thread::spawn(move|| {\n+        let t1 = thread::spawn(move || {\n             tx1.send(()).unwrap();\n             for _ in 0..40 {\n                 assert_eq!(rx2.recv().unwrap(), 1);\n             }\n         });\n         rx1.recv().unwrap();\n-        let t2 = thread::spawn(move|| {\n+        let t2 = thread::spawn(move || {\n             for _ in 0..40 {\n                 tx2.send(1).unwrap();\n             }\n@@ -1904,7 +1853,7 @@ mod tests {\n     #[test]\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<i32>();\n-        let t = thread::spawn(move|| {\n+        let t = thread::spawn(move || {\n             for _ in 0..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1919,11 +1868,11 @@ mod tests {\n     fn no_runtime() {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<i32>();\n-        let t1 = thread::spawn(move|| {\n+        let t1 = thread::spawn(move || {\n             assert_eq!(rx1.recv().unwrap(), 1);\n             tx2.send(2).unwrap();\n         });\n-        let t2 = thread::spawn(move|| {\n+        let t2 = thread::spawn(move || {\n             tx1.send(1).unwrap();\n             assert_eq!(rx2.recv().unwrap(), 2);\n         });\n@@ -1956,11 +1905,12 @@ mod tests {\n     #[test]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = thread::spawn(move|| {\n+        let res = thread::spawn(move || {\n             let (tx, rx) = channel::<i32>();\n             drop(tx);\n             rx.recv().unwrap();\n-        }).join();\n+        })\n+        .join();\n         // What is our res?\n         assert!(res.is_err());\n     }\n@@ -2025,7 +1975,7 @@ mod tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<i32>>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             assert!(*rx.recv().unwrap() == 10);\n         });\n \n@@ -2035,20 +1985,21 @@ mod tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<i32>>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             drop(tx);\n         });\n-        let res = thread::spawn(move|| {\n+        let res = thread::spawn(move || {\n             assert!(*rx.recv().unwrap() == 10);\n-        }).join();\n+        })\n+        .join();\n         assert!(res.is_err());\n     }\n \n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -2059,27 +2010,29 @@ mod tests {\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(rx);\n             });\n-            let _ = thread::spawn(move|| {\n+            let _ = thread::spawn(move || {\n                 tx.send(1).unwrap();\n-            }).join();\n+            })\n+            .join();\n         }\n     }\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n-            thread::spawn(move|| {\n-                let res = thread::spawn(move|| {\n+            thread::spawn(move || {\n+                let res = thread::spawn(move || {\n                     rx.recv().unwrap();\n-                }).join();\n+                })\n+                .join();\n                 assert!(res.is_err());\n             });\n-            let _t = thread::spawn(move|| {\n-                thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n+                thread::spawn(move || {\n                     drop(tx);\n                 });\n             });\n@@ -2090,7 +2043,7 @@ mod tests {\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<Box<isize>>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 tx.send(box 10).unwrap();\n             });\n             assert!(*rx.recv().unwrap() == 10);\n@@ -2106,18 +2059,22 @@ mod tests {\n             recv(rx, 0);\n \n             fn send(tx: Sender<Box<i32>>, i: i32) {\n-                if i == 10 { return }\n+                if i == 10 {\n+                    return;\n+                }\n \n-                thread::spawn(move|| {\n+                thread::spawn(move || {\n                     tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 });\n             }\n \n             fn recv(rx: Receiver<Box<i32>>, i: i32) {\n-                if i == 10 { return }\n+                if i == 10 {\n+                    return;\n+                }\n \n-                thread::spawn(move|| {\n+                thread::spawn(move || {\n                     assert!(*rx.recv().unwrap() == i);\n                     recv(rx, i + 1);\n                 });\n@@ -2214,9 +2171,8 @@ mod tests {\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn very_long_recv_timeout_wont_panic() {\n         let (tx, rx) = channel::<()>();\n-        let join_handle = thread::spawn(move || {\n-            rx.recv_timeout(Duration::from_secs(u64::max_value()))\n-        });\n+        let join_handle =\n+            thread::spawn(move || rx.recv_timeout(Duration::from_secs(u64::max_value())));\n         thread::sleep(Duration::from_secs(1));\n         assert!(tx.send(()).is_ok());\n         assert_eq!(join_handle.join().unwrap(), Ok(()));\n@@ -2226,8 +2182,12 @@ mod tests {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n-        for _ in 0..10000 { tx.send(()).unwrap(); }\n-        for _ in 0..10000 { rx.recv().unwrap(); }\n+        for _ in 0..10000 {\n+            tx.send(()).unwrap();\n+        }\n+        for _ in 0..10000 {\n+            rx.recv().unwrap();\n+        }\n     }\n \n     #[test]\n@@ -2237,12 +2197,14 @@ mod tests {\n         let total = 5;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 tx.send(()).unwrap();\n             });\n         }\n \n-        for _ in 0..total { rx.recv().unwrap(); }\n+        for _ in 0..total {\n+            rx.recv().unwrap();\n+        }\n \n         assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n         tx.send(()).unwrap();\n@@ -2255,7 +2217,7 @@ mod tests {\n         let total = stress_factor() + 100;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 tx.send(()).unwrap();\n             });\n         }\n@@ -2270,7 +2232,7 @@ mod tests {\n         let (tx, rx) = channel::<i32>();\n         let (total_tx, total_rx) = channel::<i32>();\n \n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -2290,7 +2252,7 @@ mod tests {\n         let (tx, rx) = channel::<i32>();\n         let (count_tx, count_rx) = channel();\n \n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -2316,7 +2278,7 @@ mod tests {\n         let (response_tx, response_rx) = channel();\n \n         // Request `x`s until we have `6`.\n-        let t = thread::spawn(move|| {\n+        let t = thread::spawn(move || {\n             let mut count = 0;\n             loop {\n                 for x in response_rx.try_iter() {\n@@ -2341,11 +2303,11 @@ mod tests {\n     #[test]\n     fn test_recv_into_iter_owned() {\n         let mut iter = {\n-          let (tx, rx) = channel::<i32>();\n-          tx.send(1).unwrap();\n-          tx.send(2).unwrap();\n+            let (tx, rx) = channel::<i32>();\n+            tx.send(1).unwrap();\n+            tx.send(2).unwrap();\n \n-          rx.into_iter()\n+            rx.into_iter()\n         };\n         assert_eq!(iter.next().unwrap(), 1);\n         assert_eq!(iter.next().unwrap(), 2);\n@@ -2369,7 +2331,7 @@ mod tests {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx2.recv().unwrap();\n             tx1.send(1).unwrap();\n             tx3.send(()).unwrap();\n@@ -2394,13 +2356,15 @@ mod tests {\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap(); // wait on a oneshot\n-            drop(rx);  // destroy a shared\n+            drop(rx); // destroy a shared\n             tx2.send(()).unwrap();\n         });\n         // make sure the other thread has gone to sleep\n-        for _ in 0..5000 { thread::yield_now(); }\n+        for _ in 0..5000 {\n+            thread::yield_now();\n+        }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -2468,7 +2432,7 @@ mod sync_tests {\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             tx.send(1).unwrap();\n         });\n         assert_eq!(rx.recv().unwrap(), 1);\n@@ -2493,7 +2457,7 @@ mod sync_tests {\n     #[test]\n     fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() {}\n@@ -2503,7 +2467,7 @@ mod sync_tests {\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n@@ -2528,7 +2492,7 @@ mod sync_tests {\n     #[test]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n         });\n@@ -2538,8 +2502,10 @@ mod sync_tests {\n     #[test]\n     fn stress() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        thread::spawn(move|| {\n-            for _ in 0..10000 { tx.send(1).unwrap(); }\n+        thread::spawn(move || {\n+            for _ in 0..10000 {\n+                tx.send(1).unwrap();\n+            }\n         });\n         for _ in 0..10000 {\n             assert_eq!(rx.recv().unwrap(), 1);\n@@ -2551,8 +2517,10 @@ mod sync_tests {\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n \n-        thread::spawn(move|| {\n-            for _ in 0..10000 { tx.send(1).unwrap(); }\n+        thread::spawn(move || {\n+            for _ in 0..10000 {\n+                tx.send(1).unwrap();\n+            }\n         });\n \n         let mut recv_count = 0;\n@@ -2561,7 +2529,7 @@ mod sync_tests {\n                 Ok(v) => {\n                     assert_eq!(v, 1);\n                     recv_count += 1;\n-                },\n+                }\n                 Err(RecvTimeoutError::Timeout) => continue,\n                 Err(RecvTimeoutError::Disconnected) => break,\n             }\n@@ -2578,14 +2546,14 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut recv_count = 0;\n             loop {\n                 match rx.recv_timeout(Duration::from_millis(10)) {\n                     Ok(v) => {\n                         assert_eq!(v, 1);\n                         recv_count += 1;\n-                    },\n+                    }\n                     Err(RecvTimeoutError::Timeout) => continue,\n                     Err(RecvTimeoutError::Disconnected) => break,\n                 }\n@@ -2599,8 +2567,10 @@ mod sync_tests {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n-                for _ in 0..AMT { tx.send(1).unwrap(); }\n+            thread::spawn(move || {\n+                for _ in 0..AMT {\n+                    tx.send(1).unwrap();\n+                }\n             });\n         }\n \n@@ -2616,7 +2586,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -2629,8 +2599,10 @@ mod sync_tests {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n-                for _ in 0..AMT { tx.send(1).unwrap(); }\n+            thread::spawn(move || {\n+                for _ in 0..AMT {\n+                    tx.send(1).unwrap();\n+                }\n             });\n         }\n         drop(tx);\n@@ -2662,11 +2634,12 @@ mod sync_tests {\n     #[test]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = thread::spawn(move|| {\n+        let res = thread::spawn(move || {\n             let (tx, rx) = sync_channel::<i32>(0);\n             drop(tx);\n             rx.recv().unwrap();\n-        }).join();\n+        })\n+        .join();\n         // What is our res?\n         assert!(res.is_err());\n     }\n@@ -2746,7 +2719,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             assert!(*rx.recv().unwrap() == 10);\n         });\n \n@@ -2756,20 +2729,21 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             drop(tx);\n         });\n-        let res = thread::spawn(move|| {\n+        let res = thread::spawn(move || {\n             assert!(*rx.recv().unwrap() == 10);\n-        }).join();\n+        })\n+        .join();\n         assert!(res.is_err());\n     }\n \n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -2780,27 +2754,29 @@ mod sync_tests {\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(rx);\n             });\n             let _ = thread::spawn(move || {\n                 tx.send(1).unwrap();\n-            }).join();\n+            })\n+            .join();\n         }\n     }\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n-            let _t = thread::spawn(move|| {\n-                let res = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n+                let res = thread::spawn(move || {\n                     rx.recv().unwrap();\n-                }).join();\n+                })\n+                .join();\n                 assert!(res.is_err());\n             });\n-            let _t = thread::spawn(move|| {\n-                thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n+                thread::spawn(move || {\n                     drop(tx);\n                 });\n             });\n@@ -2811,7 +2787,7 @@ mod sync_tests {\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<i32>>(0);\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 tx.send(box 10).unwrap();\n             });\n             assert!(*rx.recv().unwrap() == 10);\n@@ -2827,18 +2803,22 @@ mod sync_tests {\n             recv(rx, 0);\n \n             fn send(tx: SyncSender<Box<i32>>, i: i32) {\n-                if i == 10 { return }\n+                if i == 10 {\n+                    return;\n+                }\n \n-                thread::spawn(move|| {\n+                thread::spawn(move || {\n                     tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 });\n             }\n \n             fn recv(rx: Receiver<Box<i32>>, i: i32) {\n-                if i == 10 { return }\n+                if i == 10 {\n+                    return;\n+                }\n \n-                thread::spawn(move|| {\n+                thread::spawn(move || {\n                     assert!(*rx.recv().unwrap() == i);\n                     recv(rx, i + 1);\n                 });\n@@ -2850,8 +2830,12 @@ mod sync_tests {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = sync_channel(10000);\n-        for _ in 0..10000 { tx.send(()).unwrap(); }\n-        for _ in 0..10000 { rx.recv().unwrap(); }\n+        for _ in 0..10000 {\n+            tx.send(()).unwrap();\n+        }\n+        for _ in 0..10000 {\n+            rx.recv().unwrap();\n+        }\n     }\n \n     #[test]\n@@ -2860,7 +2844,7 @@ mod sync_tests {\n         let total = stress_factor() + 100;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 tx.send(()).unwrap();\n             });\n         }\n@@ -2875,7 +2859,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (total_tx, total_rx) = sync_channel::<i32>(0);\n \n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -2895,7 +2879,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -2920,7 +2904,7 @@ mod sync_tests {\n         let (tx1, rx1) = sync_channel::<i32>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx2.recv().unwrap();\n             tx1.send(1).unwrap();\n             tx3.send(()).unwrap();\n@@ -2945,13 +2929,15 @@ mod sync_tests {\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap(); // wait on a oneshot\n-            drop(rx);  // destroy a shared\n+            drop(rx); // destroy a shared\n             tx2.send(()).unwrap();\n         });\n         // make sure the other thread has gone to sleep\n-        for _ in 0..5000 { thread::yield_now(); }\n+        for _ in 0..5000 {\n+            thread::yield_now();\n+        }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -2965,22 +2951,28 @@ mod sync_tests {\n     #[test]\n     fn send1() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n+        let _t = thread::spawn(move || {\n+            rx.recv().unwrap();\n+        });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n     fn send2() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| { drop(rx); });\n+        let _t = thread::spawn(move || {\n+            drop(rx);\n+        });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send3() {\n         let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.send(1), Ok(()));\n-        let _t =thread::spawn(move|| { drop(rx); });\n+        let _t = thread::spawn(move || {\n+            drop(rx);\n+        });\n         assert!(tx.send(1).is_err());\n     }\n \n@@ -2990,11 +2982,11 @@ mod sync_tests {\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             assert!(tx.send(1).is_err());\n             done.send(()).unwrap();\n         });\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             assert!(tx2.send(2).is_err());\n             done2.send(()).unwrap();\n         });\n@@ -3030,7 +3022,7 @@ mod sync_tests {\n             let (tx1, rx1) = sync_channel::<()>(3);\n             let (tx2, rx2) = sync_channel::<()>(3);\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 rx1.recv().unwrap();\n                 tx2.try_send(()).unwrap();\n             });"}, {"sha": "6e7a7be4430edae471def217e6c63b5ae451ce9b", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -13,8 +13,8 @@\n \n pub use self::PopResult::*;\n \n-use core::ptr;\n use core::cell::UnsafeCell;\n+use core::ptr;\n \n use crate::boxed::Box;\n use crate::sync::atomic::{AtomicPtr, Ordering};\n@@ -45,15 +45,12 @@ pub struct Queue<T> {\n     tail: UnsafeCell<*mut Node<T>>,\n }\n \n-unsafe impl<T: Send> Send for Queue<T> { }\n-unsafe impl<T: Send> Sync for Queue<T> { }\n+unsafe impl<T: Send> Send for Queue<T> {}\n+unsafe impl<T: Send> Sync for Queue<T> {}\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        Box::into_raw(box Node {\n-            next: AtomicPtr::new(ptr::null_mut()),\n-            value: v,\n-        })\n+        Box::into_raw(box Node { next: AtomicPtr::new(ptr::null_mut()), value: v })\n     }\n }\n \n@@ -62,10 +59,7 @@ impl<T> Queue<T> {\n     /// one consumer.\n     pub fn new() -> Queue<T> {\n         let stub = unsafe { Node::new(None) };\n-        Queue {\n-            head: AtomicPtr::new(stub),\n-            tail: UnsafeCell::new(stub),\n-        }\n+        Queue { head: AtomicPtr::new(stub), tail: UnsafeCell::new(stub) }\n     }\n \n     /// Pushes a new value onto this queue.\n@@ -101,7 +95,7 @@ impl<T> Queue<T> {\n                 return Data(ret);\n             }\n \n-            if self.head.load(Ordering::Acquire) == tail {Empty} else {Inconsistent}\n+            if self.head.load(Ordering::Acquire) == tail { Empty } else { Inconsistent }\n         }\n     }\n }\n@@ -121,7 +115,7 @@ impl<T> Drop for Queue<T> {\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n-    use super::{Queue, Data, Empty, Inconsistent};\n+    use super::{Data, Empty, Inconsistent, Queue};\n     use crate::sync::mpsc::channel;\n     use crate::sync::Arc;\n     use crate::thread;\n@@ -140,15 +134,15 @@ mod tests {\n         let q = Queue::new();\n         match q.pop() {\n             Empty => {}\n-            Inconsistent | Data(..) => panic!()\n+            Inconsistent | Data(..) => panic!(),\n         }\n         let (tx, rx) = channel();\n         let q = Arc::new(q);\n \n         for _ in 0..nthreads {\n             let tx = tx.clone();\n             let q = q.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 for i in 0..nmsgs {\n                     q.push(i);\n                 }\n@@ -159,8 +153,8 @@ mod tests {\n         let mut i = 0;\n         while i < nthreads * nmsgs {\n             match q.pop() {\n-                Empty | Inconsistent => {},\n-                Data(_) => { i += 1 }\n+                Empty | Inconsistent => {}\n+                Data(_) => i += 1,\n             }\n         }\n         drop(tx);"}, {"sha": "bbe77e7d0fb5c41f201782a8f72f760361df66c7", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -21,22 +21,21 @@\n /// consuming the port). This upgrade is then also stored in the shared packet.\n /// The one caveat to consider is that when a port sees a disconnected channel\n /// it must check for data because there is no \"data plus upgrade\" state.\n-\n pub use self::Failure::*;\n-pub use self::UpgradeResult::*;\n use self::MyUpgrade::*;\n+pub use self::UpgradeResult::*;\n \n-use crate::sync::mpsc::Receiver;\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::cell::UnsafeCell;\n use crate::ptr;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::mpsc::blocking::{self, SignalToken};\n+use crate::sync::mpsc::Receiver;\n use crate::time::Instant;\n \n // Various states you can find a port in.\n-const EMPTY: usize = 0;          // initial state: no data, no blocked receiver\n-const DATA: usize = 1;           // data ready for receiver to take\n-const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n+const EMPTY: usize = 0; // initial state: no data, no blocked receiver\n+const DATA: usize = 1; // data ready for receiver to take\n+const DISCONNECTED: usize = 2; // channel is disconnected OR upgraded\n // Any other value represents a pointer to a SignalToken value. The\n // protocol ensures that when the state moves *to* a pointer,\n // ownership of the token is given to the packet, and when the state\n@@ -178,21 +177,17 @@ impl<T> Packet<T> {\n                 // and an upgrade flags the channel as disconnected, so when we see\n                 // this we first need to check if there's data available and *then*\n                 // we go through and process the upgrade.\n-                DISCONNECTED => {\n-                    match (&mut *self.data.get()).take() {\n-                        Some(data) => Ok(data),\n-                        None => {\n-                            match ptr::replace(self.upgrade.get(), SendUsed) {\n-                                SendUsed | NothingSent => Err(Disconnected),\n-                                GoUp(upgrade) => Err(Upgraded(upgrade))\n-                            }\n-                        }\n-                    }\n-                }\n+                DISCONNECTED => match (&mut *self.data.get()).take() {\n+                    Some(data) => Ok(data),\n+                    None => match ptr::replace(self.upgrade.get(), SendUsed) {\n+                        SendUsed | NothingSent => Err(Disconnected),\n+                        GoUp(upgrade) => Err(Upgraded(upgrade)),\n+                    },\n+                },\n \n                 // We are the sole receiver; there cannot be a blocking\n                 // receiver already.\n-                _ => unreachable!()\n+                _ => unreachable!(),\n             }\n         }\n     }\n@@ -217,10 +212,13 @@ impl<T> Packet<T> {\n \n                 // If the other end is already disconnected, then we failed the\n                 // upgrade. Be sure to trash the port we were given.\n-                DISCONNECTED => { ptr::replace(self.upgrade.get(), prev); UpDisconnected }\n+                DISCONNECTED => {\n+                    ptr::replace(self.upgrade.get(), prev);\n+                    UpDisconnected\n+                }\n \n                 // If someone's waiting, we gotta wake them up\n-                ptr => UpWoke(SignalToken::cast_from_usize(ptr))\n+                ptr => UpWoke(SignalToken::cast_from_usize(ptr)),\n             }\n         }\n     }\n@@ -232,7 +230,7 @@ impl<T> Packet<T> {\n             // If someone's waiting, we gotta wake them up\n             ptr => unsafe {\n                 SignalToken::cast_from_usize(ptr).signal();\n-            }\n+            },\n         }\n     }\n \n@@ -246,10 +244,12 @@ impl<T> Packet<T> {\n             // There's data on the channel, so make sure we destroy it promptly.\n             // This is why not using an arc is a little difficult (need the box\n             // to stay valid while we take the data).\n-            DATA => unsafe { (&mut *self.data.get()).take().unwrap(); },\n+            DATA => unsafe {\n+                (&mut *self.data.get()).take().unwrap();\n+            },\n \n             // We're the only ones that can block on this port\n-            _ => unreachable!()\n+            _ => unreachable!(),\n         }\n     }\n \n@@ -265,13 +265,11 @@ impl<T> Packet<T> {\n         let state = match self.state.load(Ordering::SeqCst) {\n             // Each of these states means that no further activity will happen\n             // with regard to abortion selection\n-            s @ EMPTY |\n-            s @ DATA |\n-            s @ DISCONNECTED => s,\n+            s @ EMPTY | s @ DATA | s @ DISCONNECTED => s,\n \n             // If we've got a blocked thread, then use an atomic to gain ownership\n             // of it (may fail)\n-            ptr => self.state.compare_and_swap(ptr, EMPTY, Ordering::SeqCst)\n+            ptr => self.state.compare_and_swap(ptr, EMPTY, Ordering::SeqCst),\n         };\n \n         // Now that we've got ownership of our state, figure out what to do\n@@ -302,7 +300,7 @@ impl<T> Packet<T> {\n             ptr => unsafe {\n                 drop(SignalToken::cast_from_usize(ptr));\n                 Ok(false)\n-            }\n+            },\n         }\n     }\n }"}, {"sha": "2b0393573fdc4a44d7e278f0ef717463dca60c10", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -7,7 +7,6 @@\n /// High level implementation details can be found in the comment of the parent\n /// module. You'll also note that the implementation of the shared and stream\n /// channels are quite similar, and this is no coincidence!\n-\n pub use self::Failure::*;\n use self::StartResult::*;\n \n@@ -17,7 +16,7 @@ use core::isize;\n \n use crate::cell::UnsafeCell;\n use crate::ptr;\n-use crate::sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n+use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::mpsc_queue as mpsc;\n use crate::sync::{Mutex, MutexGuard};\n@@ -34,9 +33,9 @@ const MAX_STEALS: isize = 1 << 20;\n \n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n-    cnt: AtomicIsize, // How many items are on this channel\n+    cnt: AtomicIsize,          // How many items are on this channel\n     steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n-    to_wake: AtomicUsize, // SignalToken for wake up\n+    to_wake: AtomicUsize,      // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n     channels: AtomicUsize,\n@@ -92,9 +91,7 @@ impl<T> Packet<T> {\n     // threads in select().\n     //\n     // This can only be called at channel-creation time\n-    pub fn inherit_blocker(&self,\n-                           token: Option<SignalToken>,\n-                           guard: MutexGuard<'_, ()>) {\n+    pub fn inherit_blocker(&self, token: Option<SignalToken>, guard: MutexGuard<'_, ()>) {\n         token.map(|token| {\n             assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n@@ -119,7 +116,9 @@ impl<T> Packet<T> {\n             // To offset this bad increment, we initially set the steal count to\n             // -1. You'll find some special code in abort_selection() as well to\n             // ensure that this -1 steal count doesn't escape too far.\n-            unsafe { *self.steals.get() = -1; }\n+            unsafe {\n+                *self.steals.get() = -1;\n+            }\n         });\n \n         // When the shared packet is constructed, we grabbed this lock. The\n@@ -132,7 +131,9 @@ impl<T> Packet<T> {\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n         // See Port::drop for what's going on\n-        if self.port_dropped.load(Ordering::SeqCst) { return Err(t) }\n+        if self.port_dropped.load(Ordering::SeqCst) {\n+            return Err(t);\n+        }\n \n         // Note that the multiple sender case is a little trickier\n         // semantically than the single sender case. The logic for\n@@ -160,7 +161,7 @@ impl<T> Packet<T> {\n         // received\". Once we get beyond this check, we have permanently\n         // entered the realm of \"this may be received\"\n         if self.cnt.load(Ordering::SeqCst) < DISCONNECTED + FUDGE {\n-            return Err(t)\n+            return Err(t);\n         }\n \n         self.queue.push(t);\n@@ -197,7 +198,7 @@ impl<T> Packet<T> {\n                         // maybe we're done, if we're not the last ones\n                         // here, then we need to go try again.\n                         if self.sender_drain.fetch_sub(1, Ordering::SeqCst) == 1 {\n-                            break\n+                            break;\n                         }\n                     }\n \n@@ -236,7 +237,10 @@ impl<T> Packet<T> {\n         }\n \n         match self.try_recv() {\n-            data @ Ok(..) => unsafe { *self.steals.get() -= 1; data },\n+            data @ Ok(..) => unsafe {\n+                *self.steals.get() -= 1;\n+                data\n+            },\n             data => data,\n         }\n     }\n@@ -252,12 +256,16 @@ impl<T> Packet<T> {\n             let steals = ptr::replace(self.steals.get(), 0);\n \n             match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-                DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n+                DISCONNECTED => {\n+                    self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n+                }\n                 // If we factor in our steals and notice that the channel has no\n                 // data, we successfully sleep\n                 n => {\n                     assert!(n >= 0);\n-                    if n - steals <= 0 { return Installed }\n+                    if n - steals <= 0 {\n+                        return Installed;\n+                    }\n                 }\n             }\n \n@@ -290,7 +298,10 @@ impl<T> Packet<T> {\n                 loop {\n                     thread::yield_now();\n                     match self.queue.pop() {\n-                        mpsc::Data(t) => { data = t; break }\n+                        mpsc::Data(t) => {\n+                            data = t;\n+                            break;\n+                        }\n                         mpsc::Empty => panic!(\"inconsistent => empty\"),\n                         mpsc::Inconsistent => {}\n                     }\n@@ -361,9 +372,13 @@ impl<T> Packet<T> {\n         }\n \n         match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n-            -1 => { self.take_to_wake().signal(); }\n+            -1 => {\n+                self.take_to_wake().signal();\n+            }\n             DISCONNECTED => {}\n-            n => { assert!(n >= 0); }\n+            n => {\n+                assert!(n >= 0);\n+            }\n         }\n     }\n \n@@ -380,7 +395,9 @@ impl<T> Packet<T> {\n             // control of this thread.\n             loop {\n                 match self.queue.pop() {\n-                    mpsc::Data(..) => { steals += 1; }\n+                    mpsc::Data(..) => {\n+                        steals += 1;\n+                    }\n                     mpsc::Empty | mpsc::Inconsistent => break,\n                 }\n             }\n@@ -406,7 +423,7 @@ impl<T> Packet<T> {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 DISCONNECTED\n             }\n-            n => n\n+            n => n,\n         }\n     }\n \n@@ -432,7 +449,7 @@ impl<T> Packet<T> {\n         // positive.\n         let steals = {\n             let cnt = self.cnt.load(Ordering::SeqCst);\n-            if cnt < 0 && cnt != DISCONNECTED {-cnt} else {0}\n+            if cnt < 0 && cnt != DISCONNECTED { -cnt } else { 0 }\n         };\n         let prev = self.bump(steals + 1);\n "}, {"sha": "c51aa7619db77c3935dcb67aaeca3f0fa9463302", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,8 +6,8 @@\n \n // http://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n \n-use core::ptr;\n use core::cell::UnsafeCell;\n+use core::ptr;\n \n use crate::boxed::Box;\n use crate::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n@@ -19,16 +19,16 @@ struct Node<T> {\n     // FIXME: this could be an uninitialized T if we're careful enough, and\n     //      that would reduce memory usage (and be a bit faster).\n     //      is it worth it?\n-    value: Option<T>,           // nullable for re-use of nodes\n-    cached: bool,               // This node goes into the node cache\n-    next: AtomicPtr<Node<T>>,   // next node in the queue\n+    value: Option<T>,         // nullable for re-use of nodes\n+    cached: bool,             // This node goes into the node cache\n+    next: AtomicPtr<Node<T>>, // next node in the queue\n }\n \n /// The single-producer single-consumer queue. This structure is not cloneable,\n /// but it can be safely shared in an Arc if it is guaranteed that there\n /// is only one popper and one pusher touching the queue at any one point in\n /// time.\n-pub struct Queue<T, ProducerAddition=(), ConsumerAddition=()> {\n+pub struct Queue<T, ProducerAddition = (), ConsumerAddition = ()> {\n     // consumer fields\n     consumer: CacheAligned<Consumer<T, ConsumerAddition>>,\n \n@@ -38,9 +38,9 @@ pub struct Queue<T, ProducerAddition=(), ConsumerAddition=()> {\n \n struct Consumer<T, Addition> {\n     tail: UnsafeCell<*mut Node<T>>, // where to pop from\n-    tail_prev: AtomicPtr<Node<T>>, // where to pop from\n-    cache_bound: usize, // maximum cache size\n-    cached_nodes: AtomicUsize, // number of nodes marked as cachable\n+    tail_prev: AtomicPtr<Node<T>>,  // where to pop from\n+    cache_bound: usize,             // maximum cache size\n+    cached_nodes: AtomicUsize,      // number of nodes marked as cachable\n     addition: Addition,\n }\n \n@@ -51,9 +51,9 @@ struct Producer<T, Addition> {\n     addition: Addition,\n }\n \n-unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Send for Queue<T, P, C> { }\n+unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Send for Queue<T, P, C> {}\n \n-unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Sync for Queue<T, P, C> { }\n+unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Sync for Queue<T, P, C> {}\n \n impl<T> Node<T> {\n     fn new() -> *mut Node<T> {\n@@ -66,7 +66,6 @@ impl<T> Node<T> {\n }\n \n impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerAddition> {\n-\n     /// Creates a new queue. With given additional elements in the producer and\n     /// consumer portions of the queue.\n     ///\n@@ -107,13 +106,13 @@ impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerA\n                 tail_prev: AtomicPtr::new(n1),\n                 cache_bound: bound,\n                 cached_nodes: AtomicUsize::new(0),\n-                addition: consumer_addition\n+                addition: consumer_addition,\n             }),\n             producer: CacheAligned::new(Producer {\n                 head: UnsafeCell::new(n2),\n                 first: UnsafeCell::new(n1),\n                 tail_copy: UnsafeCell::new(n1),\n-                addition: producer_addition\n+                addition: producer_addition,\n             }),\n         }\n     }\n@@ -142,8 +141,7 @@ impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerA\n         }\n         // If the above fails, then update our copy of the tail and try\n         // again.\n-        *self.producer.0.tail_copy.get() =\n-            self.consumer.tail_prev.load(Ordering::Acquire);\n+        *self.producer.0.tail_copy.get() = self.consumer.tail_prev.load(Ordering::Acquire);\n         if *self.producer.first.get() != *self.producer.tail_copy.get() {\n             let ret = *self.producer.first.get();\n             *self.producer.0.first.get() = (*ret).next.load(Ordering::Relaxed);\n@@ -164,7 +162,9 @@ impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerA\n             // the current tail node is a candidate for going into the cache.\n             let tail = *self.consumer.tail.get();\n             let next = (*tail).next.load(Ordering::Acquire);\n-            if next.is_null() { return None }\n+            if next.is_null() {\n+                return None;\n+            }\n             assert!((*next).value.is_some());\n             let ret = (*next).value.take();\n \n@@ -182,7 +182,8 @@ impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerA\n                     self.consumer.tail_prev.store(tail, Ordering::Release);\n                 } else {\n                     (*self.consumer.tail_prev.load(Ordering::Relaxed))\n-                        .next.store(next, Ordering::Relaxed);\n+                        .next\n+                        .store(next, Ordering::Relaxed);\n                     // We have successfully erased all references to 'tail', so\n                     // now we can safely drop it.\n                     let _: Box<Node<T>> = Box::from_raw(tail);\n@@ -234,9 +235,9 @@ impl<T, ProducerAddition, ConsumerAddition> Drop for Queue<T, ProducerAddition,\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use super::Queue;\n+    use crate::sync::mpsc::channel;\n     use crate::sync::Arc;\n     use crate::thread;\n-    use crate::sync::mpsc::channel;\n \n     #[test]\n     fn smoke() {\n@@ -265,15 +266,15 @@ mod tests {\n             match queue.peek() {\n                 Some(vec) => {\n                     assert_eq!(&*vec, &[1]);\n-                },\n-                None => unreachable!()\n+                }\n+                None => unreachable!(),\n             }\n \n             match queue.pop() {\n                 Some(vec) => {\n                     assert_eq!(&*vec, &[1]);\n-                },\n-                None => unreachable!()\n+                }\n+                None => unreachable!(),\n             }\n         }\n     }\n@@ -316,7 +317,7 @@ mod tests {\n \n             let (tx, rx) = channel();\n             let q2 = q.clone();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 for _ in 0..100000 {\n                     loop {\n                         match q2.pop() {"}, {"sha": "2e3270e81fcd033f4494d95c160bc525fc3ab537", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 62, "deletions": 50, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,10 +6,9 @@\n ///\n /// High level implementation details can be found in the comment of the parent\n /// module.\n-\n pub use self::Failure::*;\n-pub use self::UpgradeResult::*;\n use self::Message::*;\n+pub use self::UpgradeResult::*;\n \n use core::cmp;\n use core::isize;\n@@ -19,10 +18,10 @@ use crate::ptr;\n use crate::thread;\n use crate::time::Instant;\n \n-use crate::sync::atomic::{AtomicIsize, AtomicUsize, Ordering, AtomicBool};\n-use crate::sync::mpsc::Receiver;\n+use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::spsc_queue as spsc;\n+use crate::sync::mpsc::Receiver;\n \n const DISCONNECTED: isize = isize::MIN;\n #[cfg(test)]\n@@ -36,17 +35,16 @@ pub struct Packet<T> {\n }\n \n struct ProducerAddition {\n-    cnt: AtomicIsize, // How many items are on this channel\n+    cnt: AtomicIsize,     // How many items are on this channel\n     to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n }\n \n struct ConsumerAddition {\n-    steals: UnsafeCell<isize>,  // How many times has a port received without blocking?\n+    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n }\n \n-\n pub enum Failure<T> {\n     Empty,\n     Disconnected,\n@@ -69,30 +67,34 @@ enum Message<T> {\n impl<T> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n-            queue: unsafe { spsc::Queue::with_additions(\n-                128,\n-                ProducerAddition {\n-                    cnt: AtomicIsize::new(0),\n-                    to_wake: AtomicUsize::new(0),\n-\n-                    port_dropped: AtomicBool::new(false),\n-                },\n-                ConsumerAddition {\n-                    steals: UnsafeCell::new(0),\n-                }\n-            )},\n+            queue: unsafe {\n+                spsc::Queue::with_additions(\n+                    128,\n+                    ProducerAddition {\n+                        cnt: AtomicIsize::new(0),\n+                        to_wake: AtomicUsize::new(0),\n+\n+                        port_dropped: AtomicBool::new(false),\n+                    },\n+                    ConsumerAddition { steals: UnsafeCell::new(0) },\n+                )\n+            },\n         }\n     }\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n         // If the other port has deterministically gone away, then definitely\n         // must return the data back up the stack. Otherwise, the data is\n         // considered as being sent.\n-        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) { return Err(t) }\n+        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n+            return Err(t);\n+        }\n \n         match self.do_send(Data(t)) {\n-            UpSuccess | UpDisconnected => {},\n-            UpWoke(token) => { token.signal(); }\n+            UpSuccess | UpDisconnected => {}\n+            UpWoke(token) => {\n+                token.signal();\n+            }\n         }\n         Ok(())\n     }\n@@ -101,7 +103,7 @@ impl<T> Packet<T> {\n         // If the port has gone away, then there's no need to proceed any\n         // further.\n         if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n-            return UpDisconnected\n+            return UpDisconnected;\n         }\n \n         self.do_send(GoUp(up))\n@@ -136,7 +138,10 @@ impl<T> Packet<T> {\n \n             // Otherwise we just sent some data on a non-waiting queue, so just\n             // make sure the world is sane and carry on!\n-            n => { assert!(n >= 0); UpSuccess }\n+            n => {\n+                assert!(n >= 0);\n+                UpSuccess\n+            }\n         }\n     }\n \n@@ -166,7 +171,9 @@ impl<T> Packet<T> {\n             // data, we successfully sleep\n             n => {\n                 assert!(n >= 0);\n-                if n - steals <= 0 { return Ok(()) }\n+                if n - steals <= 0 {\n+                    return Ok(());\n+                }\n             }\n         }\n \n@@ -199,8 +206,7 @@ impl<T> Packet<T> {\n             // Messages which actually popped from the queue shouldn't count as\n             // a steal, so offset the decrement here (we already have our\n             // \"steal\" factored into the channel count above).\n-            data @ Ok(..) |\n-            data @ Err(Upgraded(..)) => unsafe {\n+            data @ Ok(..) | data @ Err(Upgraded(..)) => unsafe {\n                 *self.queue.consumer_addition().steals.get() -= 1;\n                 data\n             },\n@@ -226,8 +232,10 @@ impl<T> Packet<T> {\n                 if *self.queue.consumer_addition().steals.get() > MAX_STEALS {\n                     match self.queue.producer_addition().cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n-                            self.queue.producer_addition().cnt.store(\n-                                DISCONNECTED, Ordering::SeqCst);\n+                            self.queue\n+                                .producer_addition()\n+                                .cnt\n+                                .store(DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n                             let m = cmp::min(n, *self.queue.consumer_addition().steals.get());\n@@ -259,13 +267,11 @@ impl<T> Packet<T> {\n                     // We can ignore steals because the other end is\n                     // disconnected and we'll never need to really factor in our\n                     // steals again.\n-                    _ => {\n-                        match self.queue.pop() {\n-                            Some(Data(t)) => Ok(t),\n-                            Some(GoUp(up)) => Err(Upgraded(up)),\n-                            None => Err(Disconnected),\n-                        }\n-                    }\n+                    _ => match self.queue.pop() {\n+                        Some(Data(t)) => Ok(t),\n+                        Some(GoUp(up)) => Err(Upgraded(up)),\n+                        None => Err(Disconnected),\n+                    },\n                 }\n             }\n         }\n@@ -275,9 +281,13 @@ impl<T> Packet<T> {\n         // Dropping a channel is pretty simple, we just flag it as disconnected\n         // and then wakeup a blocker if there is one.\n         match self.queue.producer_addition().cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n-            -1 => { self.take_to_wake().signal(); }\n+            -1 => {\n+                self.take_to_wake().signal();\n+            }\n             DISCONNECTED => {}\n-            n => { assert!(n >= 0); }\n+            n => {\n+                assert!(n >= 0);\n+            }\n         }\n     }\n \n@@ -314,10 +324,15 @@ impl<T> Packet<T> {\n         let mut steals = unsafe { *self.queue.consumer_addition().steals.get() };\n         while {\n             let cnt = self.queue.producer_addition().cnt.compare_and_swap(\n-                            steals, DISCONNECTED, Ordering::SeqCst);\n+                steals,\n+                DISCONNECTED,\n+                Ordering::SeqCst,\n+            );\n             cnt != DISCONNECTED && cnt != steals\n         } {\n-            while let Some(_) = self.queue.pop() { steals += 1; }\n+            while let Some(_) = self.queue.pop() {\n+                steals += 1;\n+            }\n         }\n \n         // At this point in time, we have gated all future senders from sending,\n@@ -338,13 +353,12 @@ impl<T> Packet<T> {\n                 self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 DISCONNECTED\n             }\n-            n => n\n+            n => n,\n         }\n     }\n \n     // Removes a previous thread from being blocked in this port\n-    pub fn abort_selection(&self,\n-                           was_upgrade: bool) -> Result<bool, Receiver<T>> {\n+    pub fn abort_selection(&self, was_upgrade: bool) -> Result<bool, Receiver<T>> {\n         // If we're aborting selection after upgrading from a oneshot, then\n         // we're guarantee that no one is waiting. The only way that we could\n         // have seen the upgrade is if data was actually sent on the channel\n@@ -361,7 +375,7 @@ impl<T> Packet<T> {\n         if was_upgrade {\n             assert_eq!(unsafe { *self.queue.consumer_addition().steals.get() }, 0);\n             assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n-            return Ok(true)\n+            return Ok(true);\n         }\n \n         // We want to make sure that the count on the channel goes non-negative,\n@@ -416,12 +430,10 @@ impl<T> Packet<T> {\n         // upgraded port.\n         if has_data {\n             match self.queue.peek() {\n-                Some(&mut GoUp(..)) => {\n-                    match self.queue.pop() {\n-                        Some(GoUp(port)) => Err(port),\n-                        _ => unreachable!(),\n-                    }\n-                }\n+                Some(&mut GoUp(..)) => match self.queue.pop() {\n+                    Some(GoUp(port)) => Err(port),\n+                    _ => unreachable!(),\n+                },\n                 _ => Ok(true),\n             }\n         } else {"}, {"sha": "79e868171546b4b35ce4b96ed036bb9452469c51", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 66, "deletions": 55, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,3 +1,4 @@\n+use self::Blocker::*;\n /// Synchronous channels/ports\n ///\n /// This channel implementation differs significantly from the asynchronous\n@@ -22,17 +23,15 @@\n /// implementation shares almost all code for the buffered and unbuffered cases\n /// of a synchronous channel. There are a few branches for the unbuffered case,\n /// but they're mostly just relevant to blocking senders.\n-\n pub use self::Failure::*;\n-use self::Blocker::*;\n \n use core::intrinsics::abort;\n use core::isize;\n use core::mem;\n use core::ptr;\n \n-use crate::sync::atomic::{Ordering, AtomicUsize};\n-use crate::sync::mpsc::blocking::{self, WaitToken, SignalToken};\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::mpsc::blocking::{self, SignalToken, WaitToken};\n use crate::sync::{Mutex, MutexGuard};\n use crate::time::Instant;\n \n@@ -46,9 +45,9 @@ pub struct Packet<T> {\n     lock: Mutex<State<T>>,\n }\n \n-unsafe impl<T: Send> Send for Packet<T> { }\n+unsafe impl<T: Send> Send for Packet<T> {}\n \n-unsafe impl<T: Send> Sync for Packet<T> { }\n+unsafe impl<T: Send> Sync for Packet<T> {}\n \n struct State<T> {\n     disconnected: bool, // Is the channel disconnected yet?\n@@ -72,7 +71,7 @@ unsafe impl<T: Send> Send for State<T> {}\n enum Blocker {\n     BlockedSender(SignalToken),\n     BlockedReceiver(SignalToken),\n-    NoneBlocked\n+    NoneBlocked,\n }\n \n /// Simple queue for threading threads together. Nodes are stack-allocated, so\n@@ -104,35 +103,35 @@ pub enum Failure {\n \n /// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n /// in the meantime. This re-locks the mutex upon returning.\n-fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n-                   mut guard: MutexGuard<'b, State<T>>,\n-                   f: fn(SignalToken) -> Blocker)\n-                   -> MutexGuard<'a, State<T>>\n-{\n+fn wait<'a, 'b, T>(\n+    lock: &'a Mutex<State<T>>,\n+    mut guard: MutexGuard<'b, State<T>>,\n+    f: fn(SignalToken) -> Blocker,\n+) -> MutexGuard<'a, State<T>> {\n     let (wait_token, signal_token) = blocking::tokens();\n     match mem::replace(&mut guard.blocker, f(signal_token)) {\n         NoneBlocked => {}\n         _ => unreachable!(),\n     }\n-    drop(guard);         // unlock\n-    wait_token.wait();   // block\n+    drop(guard); // unlock\n+    wait_token.wait(); // block\n     lock.lock().unwrap() // relock\n }\n \n /// Same as wait, but waiting at most until `deadline`.\n-fn wait_timeout_receiver<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n-                                    deadline: Instant,\n-                                    mut guard: MutexGuard<'b, State<T>>,\n-                                    success: &mut bool)\n-                                    -> MutexGuard<'a, State<T>>\n-{\n+fn wait_timeout_receiver<'a, 'b, T>(\n+    lock: &'a Mutex<State<T>>,\n+    deadline: Instant,\n+    mut guard: MutexGuard<'b, State<T>>,\n+    success: &mut bool,\n+) -> MutexGuard<'a, State<T>> {\n     let (wait_token, signal_token) = blocking::tokens();\n     match mem::replace(&mut guard.blocker, BlockedReceiver(signal_token)) {\n         NoneBlocked => {}\n         _ => unreachable!(),\n     }\n-    drop(guard);         // unlock\n-    *success = wait_token.wait_max_until(deadline);   // block\n+    drop(guard); // unlock\n+    *success = wait_token.wait_max_until(deadline); // block\n     let mut new_guard = lock.lock().unwrap(); // relock\n     if !*success {\n         abort_selection(&mut new_guard);\n@@ -147,7 +146,10 @@ fn abort_selection<T>(guard: &mut MutexGuard<'_, State<T>>) -> bool {\n             guard.blocker = BlockedSender(token);\n             true\n         }\n-        BlockedReceiver(token) => { drop(token); false }\n+        BlockedReceiver(token) => {\n+            drop(token);\n+            false\n+        }\n     }\n }\n \n@@ -168,12 +170,9 @@ impl<T> Packet<T> {\n                 blocker: NoneBlocked,\n                 cap: capacity,\n                 canceled: None,\n-                queue: Queue {\n-                    head: ptr::null_mut(),\n-                    tail: ptr::null_mut(),\n-                },\n+                queue: Queue { head: ptr::null_mut(), tail: ptr::null_mut() },\n                 buf: Buffer {\n-                    buf: (0..capacity + if capacity == 0 {1} else {0}).map(|_| None).collect(),\n+                    buf: (0..capacity + if capacity == 0 { 1 } else { 0 }).map(|_| None).collect(),\n                     start: 0,\n                     size: 0,\n                 },\n@@ -200,7 +199,9 @@ impl<T> Packet<T> {\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n         let mut guard = self.acquire_send_slot();\n-        if guard.disconnected { return Err(t) }\n+        if guard.disconnected {\n+            return Err(t);\n+        }\n         guard.buf.enqueue(t);\n \n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n@@ -213,14 +214,17 @@ impl<T> Packet<T> {\n                 assert!(guard.canceled.is_none());\n                 guard.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n                 let mut guard = wait(&self.lock, guard, BlockedSender);\n-                if canceled {Err(guard.buf.dequeue())} else {Ok(())}\n+                if canceled { Err(guard.buf.dequeue()) } else { Ok(()) }\n             }\n \n             // success, we buffered some data\n             NoneBlocked => Ok(()),\n \n             // success, someone's about to receive our buffered data.\n-            BlockedReceiver(token) => { wakeup(token, guard); Ok(()) }\n+            BlockedReceiver(token) => {\n+                wakeup(token, guard);\n+                Ok(())\n+            }\n \n             BlockedSender(..) => panic!(\"lolwut\"),\n         }\n@@ -271,10 +275,8 @@ impl<T> Packet<T> {\n         // while loop because we're the only receiver.\n         if !guard.disconnected && guard.buf.size() == 0 {\n             if let Some(deadline) = deadline {\n-                guard = wait_timeout_receiver(&self.lock,\n-                                              deadline,\n-                                              guard,\n-                                              &mut woke_up_after_waiting);\n+                guard =\n+                    wait_timeout_receiver(&self.lock, deadline, guard, &mut woke_up_after_waiting);\n             } else {\n                 guard = wait(&self.lock, guard, BlockedReceiver);\n                 woke_up_after_waiting = true;\n@@ -290,7 +292,9 @@ impl<T> Packet<T> {\n         // Pick up the data, wake up our neighbors, and carry on\n         assert!(guard.buf.size() > 0 || (deadline.is_some() && !woke_up_after_waiting));\n \n-        if guard.buf.size() == 0 { return Err(Empty); }\n+        if guard.buf.size() == 0 {\n+            return Err(Empty);\n+        }\n \n         let ret = guard.buf.dequeue();\n         self.wakeup_senders(woke_up_after_waiting, guard);\n@@ -301,8 +305,12 @@ impl<T> Packet<T> {\n         let mut guard = self.lock.lock().unwrap();\n \n         // Easy cases first\n-        if guard.disconnected && guard.buf.size() == 0 { return Err(Disconnected) }\n-        if guard.buf.size() == 0 { return Err(Empty) }\n+        if guard.disconnected && guard.buf.size() == 0 {\n+            return Err(Disconnected);\n+        }\n+        if guard.buf.size() == 0 {\n+            return Err(Empty);\n+        }\n \n         // Be sure to wake up neighbors\n         let ret = Ok(guard.buf.dequeue());\n@@ -357,12 +365,14 @@ impl<T> Packet<T> {\n         // Only flag the channel as disconnected if we're the last channel\n         match self.channels.fetch_sub(1, Ordering::SeqCst) {\n             1 => {}\n-            _ => return\n+            _ => return,\n         }\n \n         // Not much to do other than wake up a receiver if one's there\n         let mut guard = self.lock.lock().unwrap();\n-        if guard.disconnected { return }\n+        if guard.disconnected {\n+            return;\n+        }\n         guard.disconnected = true;\n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => {}\n@@ -374,23 +384,19 @@ impl<T> Packet<T> {\n     pub fn drop_port(&self) {\n         let mut guard = self.lock.lock().unwrap();\n \n-        if guard.disconnected { return }\n+        if guard.disconnected {\n+            return;\n+        }\n         guard.disconnected = true;\n \n         // If the capacity is 0, then the sender may want its data back after\n         // we're disconnected. Otherwise it's now our responsibility to destroy\n         // the buffered data. As with many other portions of this code, this\n         // needs to be careful to destroy the data *outside* of the lock to\n         // prevent deadlock.\n-        let _data = if guard.cap != 0 {\n-            mem::take(&mut guard.buf.buf)\n-        } else {\n-            Vec::new()\n-        };\n-        let mut queue = mem::replace(&mut guard.queue, Queue {\n-            head: ptr::null_mut(),\n-            tail: ptr::null_mut(),\n-        });\n+        let _data = if guard.cap != 0 { mem::take(&mut guard.buf.buf) } else { Vec::new() };\n+        let mut queue =\n+            mem::replace(&mut guard.queue, Queue { head: ptr::null_mut(), tail: ptr::null_mut() });\n \n         let waiter = match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => None,\n@@ -402,7 +408,9 @@ impl<T> Packet<T> {\n         };\n         mem::drop(guard);\n \n-        while let Some(token) = queue.dequeue() { token.signal(); }\n+        while let Some(token) = queue.dequeue() {\n+            token.signal();\n+        }\n         waiter.map(|t| t.signal());\n     }\n }\n@@ -416,7 +424,6 @@ impl<T> Drop for Packet<T> {\n     }\n }\n \n-\n ////////////////////////////////////////////////////////////////////////////////\n // Buffer, a simple ring buffer backed by Vec<T>\n ////////////////////////////////////////////////////////////////////////////////\n@@ -437,8 +444,12 @@ impl<T> Buffer<T> {\n         result.take().unwrap()\n     }\n \n-    fn size(&self) -> usize { self.size }\n-    fn capacity(&self) -> usize { self.buf.len() }\n+    fn size(&self) -> usize {\n+        self.size\n+    }\n+    fn capacity(&self) -> usize {\n+        self.buf.len()\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -466,7 +477,7 @@ impl Queue {\n \n     fn dequeue(&mut self) -> Option<SignalToken> {\n         if self.head.is_null() {\n-            return None\n+            return None;\n         }\n         let node = self.head;\n         self.head = unsafe { (*node).next };"}, {"sha": "326faaa852afeceb554bd8459c5e85cfe0512c49", "filename": "src/libstd/sys/cloudabi/os.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,9 +18,7 @@ pub fn errno() -> i32 {\n pub fn error_string(errno: i32) -> String {\n     // cloudlibc's strerror() is guaranteed to be thread-safe. There is\n     // thus no need to use strerror_r().\n-    str::from_utf8(unsafe { CStr::from_ptr(libc::strerror(errno)) }.to_bytes())\n-        .unwrap()\n-        .to_owned()\n+    str::from_utf8(unsafe { CStr::from_ptr(libc::strerror(errno)) }.to_bytes()).unwrap().to_owned()\n }\n \n pub fn exit(code: i32) -> ! {"}, {"sha": "e6160d1457d269176ba95e96409b6eda799d4bb7", "filename": "src/libstd/sys/cloudabi/shims/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::io::{self, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sys::time::SystemTime;\n use crate::sys::{unsupported, Void};"}, {"sha": "b1b5f142f45c2cf95775324d52d1086a8aeda425", "filename": "src/libstd/sys/cloudabi/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -4,19 +4,16 @@ pub mod args;\n pub mod env;\n pub mod fs;\n pub mod net;\n+pub mod os;\n #[path = \"../../unix/path.rs\"]\n pub mod path;\n pub mod pipe;\n pub mod process;\n-pub mod os;\n \n // This enum is used as the storage for a bunch of types which can't actually exist.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub enum Void {}\n \n pub fn unsupported<T>() -> io::Result<T> {\n-    Err(io::Error::new(\n-        io::ErrorKind::Other,\n-        \"This function is not available on CloudABI.\",\n-    ))\n+    Err(io::Error::new(io::ErrorKind::Other, \"This function is not available on CloudABI.\"))\n }"}, {"sha": "67c436fa7955d5c623fbecd69e23df0d35e28a20", "filename": "src/libstd/sys/cloudabi/shims/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n+use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n-use crate::time::Duration;\n use crate::sys::{unsupported, Void};\n-use crate::convert::TryFrom;\n+use crate::time::Duration;\n \n #[allow(unused_extern_crates)]\n pub extern crate libc as netc;"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/cloudabi/shims/process.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -32,9 +32,7 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default(),\n-        }\n+        Command { env: Default::default() }\n     }\n \n     pub fn arg(&mut self, _arg: &OsStr) {}"}, {"sha": "3afcae7ae751603ab0e84fe834f197846b238725", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -58,8 +58,8 @@ impl Thread {\n     }\n \n     pub fn sleep(dur: Duration) {\n-        let timeout = checked_dur2intervals(&dur)\n-            .expect(\"overflow converting duration to nanoseconds\");\n+        let timeout =\n+            checked_dur2intervals(&dur).expect(\"overflow converting duration to nanoseconds\");\n         unsafe {\n             let subscription = abi::subscription {\n                 type_: abi::eventtype::CLOCK,\n@@ -85,11 +85,7 @@ impl Thread {\n         unsafe {\n             let ret = libc::pthread_join(self.id, ptr::null_mut());\n             mem::forget(self);\n-            assert!(\n-                ret == 0,\n-                \"failed to join thread: {}\",\n-                io::Error::from_raw_os_error(ret)\n-            );\n+            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n         }\n     }\n }"}, {"sha": "c209231cf8c0186352f5020194283d293feb46df", "filename": "src/libstd/sys/cloudabi/time.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -10,9 +10,7 @@ pub struct Instant {\n }\n \n pub fn checked_dur2intervals(dur: &Duration) -> Option<abi::timestamp> {\n-    dur.as_secs()\n-        .checked_mul(NSEC_PER_SEC)?\n-        .checked_add(dur.subsec_nanos() as abi::timestamp)\n+    dur.as_secs().checked_mul(NSEC_PER_SEC)?.checked_add(dur.subsec_nanos() as abi::timestamp)\n }\n \n impl Instant {\n@@ -39,15 +37,11 @@ impl Instant {\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant {\n-            t: self.t.checked_add(checked_dur2intervals(other)?)?,\n-        })\n+        Some(Instant { t: self.t.checked_add(checked_dur2intervals(other)?)? })\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant {\n-            t: self.t.checked_sub(checked_dur2intervals(other)?)?,\n-        })\n+        Some(Instant { t: self.t.checked_sub(checked_dur2intervals(other)?)? })\n     }\n }\n \n@@ -69,29 +63,19 @@ impl SystemTime {\n     pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n         if self.t >= other.t {\n             let diff = self.t - other.t;\n-            Ok(Duration::new(\n-                diff / NSEC_PER_SEC,\n-                (diff % NSEC_PER_SEC) as u32,\n-            ))\n+            Ok(Duration::new(diff / NSEC_PER_SEC, (diff % NSEC_PER_SEC) as u32))\n         } else {\n             let diff = other.t - self.t;\n-            Err(Duration::new(\n-                diff / NSEC_PER_SEC,\n-                (diff % NSEC_PER_SEC) as u32,\n-            ))\n+            Err(Duration::new(diff / NSEC_PER_SEC, (diff % NSEC_PER_SEC) as u32))\n         }\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime {\n-            t: self.t.checked_add(checked_dur2intervals(other)?)?,\n-        })\n+        Some(SystemTime { t: self.t.checked_add(checked_dur2intervals(other)?)? })\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime {\n-            t: self.t.checked_sub(checked_dur2intervals(other)?)?,\n-        })\n+        Some(SystemTime { t: self.t.checked_sub(checked_dur2intervals(other)?)? })\n     }\n }\n "}, {"sha": "d153914e77e10235294109f575e627882e34c926", "filename": "src/libstd/sys/hermit/alloc.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -13,11 +13,7 @@ unsafe impl GlobalAlloc for System {\n         let addr = abi::malloc(layout.size(), layout.align());\n \n         if !addr.is_null() {\n-            ptr::write_bytes(\n-                addr,\n-                0x00,\n-                layout.size()\n-            );\n+            ptr::write_bytes(addr, 0x00, layout.size());\n         }\n \n         addr"}, {"sha": "72c1b8511cac8cc25a8d196c8336572626742913", "filename": "src/libstd/sys/hermit/args.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -3,10 +3,14 @@ use crate::marker::PhantomData;\n use crate::vec;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    imp::init(argc, argv)\n+}\n \n /// One-time global cleanup.\n-pub unsafe fn cleanup() { imp::cleanup() }\n+pub unsafe fn cleanup() {\n+    imp::cleanup()\n+}\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n@@ -26,24 +30,32 @@ impl Args {\n \n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<OsString> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.iter.next_back()\n+    }\n }\n \n mod imp {\n-    use crate::sys_common::os_str_bytes::*;\n-    use crate::ptr;\n+    use super::Args;\n     use crate::ffi::{CStr, OsString};\n     use crate::marker::PhantomData;\n-    use super::Args;\n+    use crate::ptr;\n+    use crate::sys_common::os_str_bytes::*;\n \n     use crate::sys_common::mutex::Mutex;\n \n@@ -64,19 +76,18 @@ mod imp {\n     }\n \n     pub fn args() -> Args {\n-        Args {\n-            iter: clone().into_iter(),\n-            _dont_send_or_sync_me: PhantomData\n-        }\n+        Args { iter: clone().into_iter(), _dont_send_or_sync_me: PhantomData }\n     }\n \n     fn clone() -> Vec<OsString> {\n         unsafe {\n             let _guard = LOCK.lock();\n-            (0..ARGC).map(|i| {\n-                let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n-                OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-            }).collect()\n+            (0..ARGC)\n+                .map(|i| {\n+                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n+                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n+                })\n+                .collect()\n         }\n     }\n }"}, {"sha": "304cf906b2aeadba92007440bb5628e3c9ed8184", "filename": "src/libstd/sys/hermit/cmath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n // These symbols are all defined in `compiler-builtins`\n-extern {\n+extern \"C\" {\n     pub fn acos(n: f64) -> f64;\n     pub fn acosf(n: f32) -> f32;\n     pub fn asin(n: f64) -> f64;"}, {"sha": "5b7f16ce562b9b30862071a313618b6f13079df1", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -18,12 +18,12 @@ impl Condvar {\n     }\n \n     pub unsafe fn notify_one(&self) {\n-         let _ = abi::notify(self.id(), 1);\n+        let _ = abi::notify(self.id(), 1);\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n-         let _ = abi::notify(self.id(), -1 /* =all */);\n+        let _ = abi::notify(self.id(), -1 /* =all */);\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {"}, {"sha": "f2f61fdfb8cc64b00a7067ea151e430d28fbc6cf", "filename": "src/libstd/sys/hermit/fd.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,6 +1,6 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n-use crate::io::{self, Read, ErrorKind};\n+use crate::io::{self, ErrorKind, Read};\n use crate::mem;\n use crate::sys::cvt;\n use crate::sys::hermit::abi;\n@@ -16,7 +16,9 @@ impl FileDesc {\n         FileDesc { fd }\n     }\n \n-    pub fn raw(&self) -> i32 { self.fd }\n+    pub fn raw(&self) -> i32 {\n+        self.fd\n+    }\n \n     /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> i32 {\n@@ -67,7 +69,9 @@ impl<'a> Read for &'a FileDesc {\n }\n \n impl AsInner<i32> for FileDesc {\n-    fn as_inner(&self) -> &i32 { &self.fd }\n+    fn as_inner(&self) -> &i32 {\n+        &self.fd\n+    }\n }\n \n impl Drop for FileDesc {"}, {"sha": "37ac5984eeeaf4b0da7c88e71fdc1823e8c96d34", "filename": "src/libstd/sys/hermit/fs.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,14 +1,14 @@\n-use crate::ffi::{OsString, CString, CStr};\n+use crate::ffi::{CStr, CString, OsString};\n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind};\n use crate::hash::{Hash, Hasher};\n-use crate::io::{SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, Error, ErrorKind};\n+use crate::io::{IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n-use crate::sys::time::SystemTime;\n-use crate::sys::{unsupported, Void};\n+use crate::sys::cvt;\n use crate::sys::hermit::abi;\n use crate::sys::hermit::fd::FileDesc;\n-use crate::sys::cvt;\n+use crate::sys::time::SystemTime;\n+use crate::sys::{unsupported, Void};\n use crate::sys_common::os_str_bytes::OsStrExt;\n \n pub use crate::sys_common::fs::copy;\n@@ -45,15 +45,15 @@ pub struct OpenOptions {\n     create: bool,\n     create_new: bool,\n     // system-specific\n-    mode: i32\n+    mode: i32,\n }\n \n pub struct FilePermissions(Void);\n \n pub struct FileType(Void);\n \n #[derive(Debug)]\n-pub struct DirBuilder { }\n+pub struct DirBuilder {}\n \n impl FileAttr {\n     pub fn size(&self) -> u64 {\n@@ -109,8 +109,7 @@ impl PartialEq for FilePermissions {\n     }\n }\n \n-impl Eq for FilePermissions {\n-}\n+impl Eq for FilePermissions {}\n \n impl fmt::Debug for FilePermissions {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -146,8 +145,7 @@ impl PartialEq for FileType {\n     }\n }\n \n-impl Eq for FileType {\n-}\n+impl Eq for FileType {}\n \n impl Hash for FileType {\n     fn hash<H: Hasher>(&self, _h: &mut H) {\n@@ -204,50 +202,64 @@ impl OpenOptions {\n             create: false,\n             create_new: false,\n             // system-specific\n-            mode: 0x777\n+            mode: 0x777,\n         }\n     }\n \n-    pub fn read(&mut self, read: bool) { self.read = read; }\n-    pub fn write(&mut self, write: bool) { self.write = write; }\n-    pub fn append(&mut self, append: bool) { self.append = append; }\n-    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n-    pub fn create(&mut self, create: bool) { self.create = create; }\n-    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+    pub fn read(&mut self, read: bool) {\n+        self.read = read;\n+    }\n+    pub fn write(&mut self, write: bool) {\n+        self.write = write;\n+    }\n+    pub fn append(&mut self, append: bool) {\n+        self.append = append;\n+    }\n+    pub fn truncate(&mut self, truncate: bool) {\n+        self.truncate = truncate;\n+    }\n+    pub fn create(&mut self, create: bool) {\n+        self.create = create;\n+    }\n+    pub fn create_new(&mut self, create_new: bool) {\n+        self.create_new = create_new;\n+    }\n \n     fn get_access_mode(&self) -> io::Result<i32> {\n         match (self.read, self.write, self.append) {\n-            (true,  false, false) => Ok(O_RDONLY),\n-            (false, true,  false) => Ok(O_WRONLY),\n-            (true,  true,  false) => Ok(O_RDWR),\n-            (false, _,     true)  => Ok(O_WRONLY | O_APPEND),\n-            (true,  _,     true)  => Ok(O_RDWR | O_APPEND),\n+            (true, false, false) => Ok(O_RDONLY),\n+            (false, true, false) => Ok(O_WRONLY),\n+            (true, true, false) => Ok(O_RDWR),\n+            (false, _, true) => Ok(O_WRONLY | O_APPEND),\n+            (true, _, true) => Ok(O_RDWR | O_APPEND),\n             (false, false, false) => {\n                 Err(io::Error::new(ErrorKind::InvalidInput, \"invalid access mode\"))\n-            },\n+            }\n         }\n     }\n \n     fn get_creation_mode(&self) -> io::Result<i32> {\n         match (self.write, self.append) {\n             (true, false) => {}\n-            (false, false) =>\n+            (false, false) => {\n                 if self.truncate || self.create || self.create_new {\n                     return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n-                },\n-            (_, true) =>\n+                }\n+            }\n+            (_, true) => {\n                 if self.truncate && !self.create_new {\n                     return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n-                },\n+                }\n+            }\n         }\n \n         Ok(match (self.create, self.truncate, self.create_new) {\n-                (false, false, false) => 0,\n-                (true,  false, false) => O_CREAT,\n-                (false, true,  false) => O_TRUNC,\n-                (true,  true,  false) => O_CREAT | O_TRUNC,\n-                (_,      _,    true)  => O_CREAT | O_EXCL,\n-           })\n+            (false, false, false) => 0,\n+            (true, false, false) => O_CREAT,\n+            (false, true, false) => O_TRUNC,\n+            (true, true, false) => O_CREAT | O_TRUNC,\n+            (_, _, true) => O_CREAT | O_EXCL,\n+        })\n     }\n }\n \n@@ -327,7 +339,7 @@ impl File {\n \n impl DirBuilder {\n     pub fn new() -> DirBuilder {\n-        DirBuilder { }\n+        DirBuilder {}\n     }\n \n     pub fn mkdir(&self, _p: &Path) -> io::Result<()> {"}, {"sha": "1e4a53abdc7bd9ed1cbc3ed27ed20e8f02218784", "filename": "src/libstd/sys/hermit/mod.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -13,34 +13,34 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-use crate::os::raw::c_char;\n use crate::intrinsics;\n+use crate::os::raw::c_char;\n \n pub mod alloc;\n pub mod args;\n-pub mod condvar;\n-pub mod stdio;\n-pub mod memchr;\n-pub mod io;\n-pub mod mutex;\n-pub mod rwlock;\n-pub mod os;\n pub mod cmath;\n-pub mod thread;\n+pub mod condvar;\n pub mod env;\n-pub mod fs;\n+pub mod fast_thread_local;\n pub mod fd;\n+pub mod fs;\n+pub mod io;\n+pub mod memchr;\n+pub mod mutex;\n pub mod net;\n+pub mod os;\n pub mod path;\n pub mod pipe;\n pub mod process;\n+pub mod rwlock;\n pub mod stack_overflow;\n-pub mod time;\n+pub mod stdio;\n+pub mod thread;\n pub mod thread_local;\n-pub mod fast_thread_local;\n+pub mod time;\n \n-pub use crate::sys_common::os_str_bytes as os_str;\n use crate::io::ErrorKind;\n+pub use crate::sys_common::os_str_bytes as os_str;\n \n #[allow(unused_extern_crates)]\n pub extern crate hermit_abi as abi;\n@@ -50,8 +50,7 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new(crate::io::ErrorKind::Other,\n-           \"operation not supported on HermitCore yet\")\n+    crate::io::Error::new(crate::io::ErrorKind::Other, \"operation not supported on HermitCore yet\")\n }\n \n // This enum is used as the storage for a bunch of types which can't actually\n@@ -71,9 +70,7 @@ pub unsafe fn strlen(start: *const c_char) -> usize {\n \n #[no_mangle]\n pub extern \"C\" fn floor(x: f64) -> f64 {\n-    unsafe {\n-        intrinsics::floorf64(x)\n-    }\n+    unsafe { intrinsics::floorf64(x) }\n }\n \n pub unsafe fn abort_internal() -> ! {\n@@ -103,8 +100,11 @@ pub fn init() {\n \n #[cfg(not(test))]\n #[no_mangle]\n-pub unsafe extern \"C\" fn runtime_entry(argc: i32, argv: *const *const c_char,\n-                                       env: *const *const c_char) -> ! {\n+pub unsafe extern \"C\" fn runtime_entry(\n+    argc: i32,\n+    argv: *const *const c_char,\n+    env: *const *const c_char,\n+) -> ! {\n     extern \"C\" {\n         fn main(argc: isize, argv: *const *const c_char) -> i32;\n     }\n@@ -139,9 +139,5 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n }\n \n pub fn cvt(result: i32) -> crate::io::Result<usize> {\n-    if result < 0 {\n-        Err(crate::io::Error::from_raw_os_error(-result))\n-    } else {\n-        Ok(result as usize)\n-    }\n+    if result < 0 { Err(crate::io::Error::from_raw_os_error(-result)) } else { Ok(result as usize) }\n }"}, {"sha": "b5c75f738d228e170f0d07d21a7a7e0e24d353c1", "filename": "src/libstd/sys/hermit/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n-use crate::ptr;\n use crate::ffi::c_void;\n+use crate::ptr;\n use crate::sys::hermit::abi;\n \n pub struct Mutex {\n-    inner: *const c_void\n+    inner: *const c_void,\n }\n \n unsafe impl Send for Mutex {}\n@@ -42,7 +42,7 @@ impl Mutex {\n }\n \n pub struct ReentrantMutex {\n-    inner: *const c_void\n+    inner: *const c_void,\n }\n \n impl ReentrantMutex {"}, {"sha": "82917e71be1f815d5be96d84b76adb4160955e70", "filename": "src/libstd/sys/hermit/net.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n-use crate::fmt;\n use crate::convert::TryFrom;\n+use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::str;\n use crate::sys::{unsupported, Void};\n use crate::time::Duration;\n@@ -234,23 +234,19 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n@@ -357,8 +353,7 @@ pub mod netc {\n     }\n \n     #[derive(Copy, Clone)]\n-    pub struct sockaddr {\n-    }\n+    pub struct sockaddr {}\n \n     pub type socklen_t = usize;\n }"}, {"sha": "ad63b0e0c13180fa105df280606b2d381ebeef3e", "filename": "src/libstd/sys/hermit/os.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,18 +1,18 @@\n+use crate::collections::HashMap;\n use crate::error::Error as StdError;\n-use crate::ffi::{CStr, OsString, OsStr};\n+use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n use crate::memchr;\n use crate::path::{self, PathBuf};\n use crate::ptr;\n use crate::str;\n-use crate::sys::{unsupported, Void};\n-use crate::collections::HashMap;\n-use crate::vec;\n use crate::sync::Mutex;\n-use crate::sys_common::os_str_bytes::*;\n use crate::sys::hermit::abi;\n+use crate::sys::{unsupported, Void};\n+use crate::sys_common::os_str_bytes::*;\n+use crate::vec;\n \n pub fn errno() -> i32 {\n     0\n@@ -47,7 +47,9 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     Err(JoinPathsError)\n }\n@@ -77,7 +79,7 @@ pub fn init_environment(env: *const *const i8) {\n         let mut guard = ENV.as_ref().unwrap().lock().unwrap();\n         let mut environ = env;\n         while environ != ptr::null() && *environ != ptr::null() {\n-            if let Some((key,value)) = parse(CStr::from_ptr(*environ).to_bytes()) {\n+            if let Some((key, value)) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                 guard.insert(key, value);\n             }\n             environ = environ.offset(1);\n@@ -93,10 +95,12 @@ pub fn init_environment(env: *const *const i8) {\n             return None;\n         }\n         let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n-        pos.map(|p| (\n-            OsStringExt::from_vec(input[..p].to_vec()),\n-            OsStringExt::from_vec(input[p+1..].to_vec()),\n-        ))\n+        pos.map(|p| {\n+            (\n+                OsStringExt::from_vec(input[..p].to_vec()),\n+                OsStringExt::from_vec(input[p + 1..].to_vec()),\n+            )\n+        })\n     }\n }\n \n@@ -107,33 +111,34 @@ pub struct Env {\n \n impl Iterator for Env {\n     type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n-   unsafe {\n+    unsafe {\n         let guard = ENV.as_ref().unwrap().lock().unwrap();\n         let mut result = Vec::new();\n \n         for (key, value) in guard.iter() {\n             result.push((key.clone(), value.clone()));\n         }\n \n-        return Env {\n-            iter: result.into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        }\n+        return Env { iter: result.into_iter(), _dont_send_or_sync_me: PhantomData };\n     }\n }\n \n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     unsafe {\n         match ENV.as_ref().unwrap().lock().unwrap().get_mut(k) {\n-            Some(value) => { Ok(Some(value.clone())) },\n-            None => { Ok(None) },\n+            Some(value) => Ok(Some(value.clone())),\n+            None => Ok(None),\n         }\n     }\n }\n@@ -168,7 +173,5 @@ pub fn exit(code: i32) -> ! {\n }\n \n pub fn getpid() -> u32 {\n-    unsafe {\n-        abi::getpid()\n-    }\n+    unsafe { abi::getpid() }\n }"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/hermit/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "fb14dc591018116ea405550f4697f60378b2d7e8", "filename": "src/libstd/sys/hermit/pipe.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -25,9 +25,6 @@ impl AnonPipe {\n     }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             _v1: &mut Vec<u8>,\n-             _p2: AnonPipe,\n-             _v2: &mut Vec<u8>) -> io::Result<()> {\n+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n     match p1.0 {}\n }"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/hermit/process.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -32,32 +32,28 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default()\n-        }\n+        Command { env: Default::default() }\n     }\n \n-    pub fn arg(&mut self, _arg: &OsStr) {\n-    }\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n \n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n-    pub fn cwd(&mut self, _dir: &OsStr) {\n-    }\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n \n-    pub fn stdin(&mut self, _stdin: Stdio) {\n-    }\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n \n-    pub fn stdout(&mut self, _stdout: Stdio) {\n-    }\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n \n-    pub fn stderr(&mut self, _stderr: Stdio) {\n-    }\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n \n-    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n-        -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         unsupported()\n     }\n }\n@@ -106,8 +102,7 @@ impl PartialEq for ExitStatus {\n     }\n }\n \n-impl Eq for ExitStatus {\n-}\n+impl Eq for ExitStatus {}\n \n impl fmt::Debug for ExitStatus {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "c19799af3c7ee3c2d1ada043f32158aa7a062b7a", "filename": "src/libstd/sys/hermit/rwlock.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,17 +1,15 @@\n use super::mutex::Mutex;\n \n pub struct RWLock {\n-    mutex: Mutex\n+    mutex: Mutex,\n }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock {\n-            mutex: Mutex::new()\n-        }\n+        RWLock { mutex: Mutex::new() }\n     }\n \n     #[inline]"}, {"sha": "65a1b17acce9a701eea14e5fed00c3bc1569aeed", "filename": "src/libstd/sys/hermit/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -7,9 +7,7 @@ impl Handler {\n }\n \n #[inline]\n-pub unsafe fn init() {\n-}\n+pub unsafe fn init() {}\n \n #[inline]\n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}"}, {"sha": "2eb011ccb3974d311597fe83228b441d6d6ca919", "filename": "src/libstd/sys/hermit/stdio.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -20,7 +20,6 @@ impl Stdin {\n         //    .read(data)\n         Ok(0)\n     }\n-\n }\n \n impl Stdout {\n@@ -31,9 +30,7 @@ impl Stdout {\n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n         let len;\n \n-        unsafe {\n-            len = abi::write(1, data.as_ptr() as *const u8, data.len())\n-        }\n+        unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n             Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n@@ -45,9 +42,7 @@ impl Stdout {\n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n         let len;\n \n-        unsafe {\n-            len = abi::write(1, data.as_ptr() as *const u8, data.len())\n-        }\n+        unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n             Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n@@ -69,9 +64,7 @@ impl Stderr {\n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n         let len;\n \n-        unsafe {\n-            len = abi::write(2, data.as_ptr() as *const u8, data.len())\n-        }\n+        unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n             Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))\n@@ -83,9 +76,7 @@ impl Stderr {\n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n         let len;\n \n-        unsafe {\n-            len = abi::write(2, data.as_ptr() as *const u8, data.len())\n-        }\n+        unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n             Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))"}, {"sha": "c3c29c93826dedfe8ccb6f3b4c8ee5dcad9fdaec", "filename": "src/libstd/sys/hermit/thread.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,11 +1,11 @@\n #![allow(dead_code)]\n \n use crate::ffi::CStr;\n+use crate::fmt;\n use crate::io;\n+use crate::mem;\n use crate::sys::hermit::abi;\n use crate::time::Duration;\n-use crate::mem;\n-use crate::fmt;\n use core::u32;\n \n use crate::sys_common::thread::*;\n@@ -35,7 +35,7 @@ impl fmt::Display for Priority {\n pub const NORMAL_PRIO: Priority = Priority::from(2);\n \n pub struct Thread {\n-    tid: Tid\n+    tid: Tid,\n }\n \n unsafe impl Send for Thread {}\n@@ -44,14 +44,20 @@ unsafe impl Sync for Thread {}\n pub const DEFAULT_MIN_STACK_SIZE: usize = 262144;\n \n impl Thread {\n-    pub unsafe fn new_with_coreid(_stack: usize, p: Box<dyn FnOnce()>, core_id: isize)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new_with_coreid(\n+        _stack: usize,\n+        p: Box<dyn FnOnce()>,\n+        core_id: isize,\n+    ) -> io::Result<Thread> {\n         let p = box p;\n         let mut tid: Tid = u32::MAX;\n-        let ret = abi::spawn(&mut tid as *mut Tid, thread_start,\n-                            &*p as *const _ as *const u8 as usize,\n-                            Priority::into(NORMAL_PRIO), core_id);\n+        let ret = abi::spawn(\n+            &mut tid as *mut Tid,\n+            thread_start,\n+            &*p as *const _ as *const u8 as usize,\n+            Priority::into(NORMAL_PRIO),\n+            core_id,\n+        );\n \n         return if ret == 0 {\n             mem::forget(p); // ownership passed to pthread_create\n@@ -60,16 +66,14 @@ impl Thread {\n             Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n         };\n \n-        extern fn thread_start(main: usize) {\n+        extern \"C\" fn thread_start(main: usize) {\n             unsafe {\n                 start_thread(main as *mut u8);\n             }\n         }\n     }\n \n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         Thread::new_with_coreid(stack, p, -1 /* = no specific core */)\n     }\n \n@@ -99,7 +103,9 @@ impl Thread {\n     }\n \n     #[inline]\n-    pub fn id(&self) -> Tid { self.tid }\n+    pub fn id(&self) -> Tid {\n+        self.tid\n+    }\n \n     #[inline]\n     pub fn into_id(self) -> Tid {\n@@ -111,6 +117,10 @@ impl Thread {\n \n pub mod guard {\n     pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }"}, {"sha": "ba967c7676c3fd6118a9999d18735c3d5ad928ac", "filename": "src/libstd/sys/hermit/thread_local.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -7,7 +7,7 @@ use crate::sys_common::mutex::Mutex;\n \n pub type Key = usize;\n \n-type Dtor = unsafe extern fn(*mut u8);\n+type Dtor = unsafe extern \"C\" fn(*mut u8);\n \n static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n \n@@ -41,11 +41,7 @@ pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n \n #[inline]\n pub unsafe fn get(key: Key) -> *mut u8 {\n-    if let Some(&entry) = locals().get(&key) {\n-        entry\n-    } else {\n-        ptr::null_mut()\n-    }\n+    if let Some(&entry) = locals().get(&key) { entry } else { ptr::null_mut() }\n }\n \n #[inline]"}, {"sha": "c02de17c1fc3ab61688c528bfd55595bffc675cb", "filename": "src/libstd/sys/hermit/time.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,34 +1,35 @@\n #![allow(dead_code)]\n \n-use crate::time::Duration;\n use crate::cmp::Ordering;\n use crate::convert::TryInto;\n-use core::hash::{Hash, Hasher};\n use crate::sys::hermit::abi;\n-use crate::sys::hermit::abi::{CLOCK_REALTIME, CLOCK_MONOTONIC, NSEC_PER_SEC};\n use crate::sys::hermit::abi::timespec;\n+use crate::sys::hermit::abi::{CLOCK_MONOTONIC, CLOCK_REALTIME, NSEC_PER_SEC};\n+use crate::time::Duration;\n+use core::hash::{Hash, Hasher};\n \n #[derive(Copy, Clone, Debug)]\n struct Timespec {\n-    t: timespec\n+    t: timespec,\n }\n \n impl Timespec {\n     const fn zero() -> Timespec {\n-        Timespec {\n-            t: timespec { tv_sec: 0, tv_nsec: 0 },\n-        }\n+        Timespec { t: timespec { tv_sec: 0, tv_nsec: 0 } }\n     }\n \n     fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n         if self >= other {\n             Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n-                              (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+                Duration::new(\n+                    (self.t.tv_sec - other.t.tv_sec) as u64,\n+                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n+                )\n             } else {\n-                Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n-                              other.t.tv_nsec as u32)\n+                Duration::new(\n+                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n+                )\n             })\n         } else {\n             match other.sub_timespec(self) {\n@@ -52,12 +53,7 @@ impl Timespec {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n         }\n-        Some(Timespec {\n-            t: timespec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as _,\n-            },\n-        })\n+        Some(Timespec { t: timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n     }\n \n     fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n@@ -73,12 +69,7 @@ impl Timespec {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n         }\n-        Some(Timespec {\n-            t: timespec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as _,\n-            },\n-        })\n+        Some(Timespec { t: timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n     }\n }\n \n@@ -105,7 +96,7 @@ impl Ord for Timespec {\n }\n \n impl Hash for Timespec {\n-    fn hash<H : Hasher>(&self, state: &mut H) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         self.t.tv_sec.hash(state);\n         self.t.tv_nsec.hash(state);\n     }\n@@ -150,9 +141,7 @@ pub struct SystemTime {\n     t: Timespec,\n }\n \n-pub const UNIX_EPOCH: SystemTime = SystemTime {\n-    t: Timespec::zero(),\n-};\n+pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n \n impl SystemTime {\n     pub fn now() -> SystemTime {"}, {"sha": "87e7a5da2b7a9b179eaa0222305f89914fbd4efb", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,11 +1,11 @@\n #![cfg_attr(test, allow(unused))] // RT initialization logic is not compiled for test\n \n-use core::sync::atomic::{AtomicUsize, Ordering};\n use crate::io::Write;\n+use core::sync::atomic::{AtomicUsize, Ordering};\n \n // runtime features\n-mod reloc;\n pub(super) mod panic;\n+mod reloc;\n \n // library features\n pub mod mem;\n@@ -38,14 +38,16 @@ unsafe extern \"C\" fn tcs_init(secondary: bool) {\n         UNINIT => {\n             reloc::relocate_elf_rela();\n             RELOC_STATE.store(DONE, Ordering::Release);\n-        },\n+        }\n         // We need to wait until the initialization is done.\n-        BUSY => while RELOC_STATE.load(Ordering::Acquire) == BUSY  {\n-            core::arch::x86_64::_mm_pause()\n-        },\n+        BUSY => {\n+            while RELOC_STATE.load(Ordering::Acquire) == BUSY {\n+                core::arch::x86_64::_mm_pause()\n+            }\n+        }\n         // Initialization is done.\n-        DONE => {},\n-        _ => unreachable!()\n+        DONE => {}\n+        _ => unreachable!(),\n     }\n }\n "}, {"sha": "229b3b3291f63fa1a8624a304248c2875d2095e3", "filename": "src/libstd/sys/sgx/abi/panic.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -16,21 +16,13 @@ fn empty_user_slice() -> &'static mut UserRef<[u8]> {\n \n impl SgxPanicOutput {\n     pub(crate) fn new() -> Option<Self> {\n-        if unsafe { DEBUG == 0 } {\n-            None\n-        } else {\n-            Some(SgxPanicOutput(None))\n-        }\n+        if unsafe { DEBUG == 0 } { None } else { Some(SgxPanicOutput(None)) }\n     }\n \n     fn init(&mut self) -> &mut &'static mut UserRef<[u8]> {\n         self.0.get_or_insert_with(|| unsafe {\n             let ptr = take_debug_panic_buf_ptr();\n-            if ptr.is_null() {\n-                empty_user_slice()\n-            } else {\n-                UserRef::from_raw_parts_mut(ptr, 1024)\n-            }\n+            if ptr.is_null() { empty_user_slice() } else { UserRef::from_raw_parts_mut(ptr, 1024) }\n         })\n     }\n }"}, {"sha": "02dff0ad29fc3ddd821ed279787d61273155cc9a", "filename": "src/libstd/sys/sgx/abi/reloc.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n-use crate::slice::from_raw_parts;\n use super::mem;\n+use crate::slice::from_raw_parts;\n \n const R_X86_64_RELATIVE: u32 = 8;\n \n@@ -11,18 +11,20 @@ struct Rela<T> {\n }\n \n pub fn relocate_elf_rela() {\n-    extern {\n+    extern \"C\" {\n         static RELA: u64;\n         static RELACOUNT: usize;\n     }\n \n-    if unsafe { RELACOUNT } == 0 { return }  // unsafe ok: link-time constant\n+    if unsafe { RELACOUNT } == 0 {\n+        return;\n+    } // unsafe ok: link-time constant\n \n     let relas = unsafe {\n-        from_raw_parts::<Rela<u64>>(mem::rel_ptr(RELA), RELACOUNT)  // unsafe ok: link-time constant\n+        from_raw_parts::<Rela<u64>>(mem::rel_ptr(RELA), RELACOUNT) // unsafe ok: link-time constant\n     };\n     for rela in relas {\n-        if rela.info != (/*0 << 32 |*/ R_X86_64_RELATIVE as u64) {\n+        if rela.info != (/*0 << 32 |*/R_X86_64_RELATIVE as u64) {\n             rtabort!(\"Invalid relocation\");\n         }\n         unsafe { *mem::rel_ptr_mut::<*const ()>(rela.offset) = mem::rel_ptr(rela.addend) };"}, {"sha": "ef55b821a2b6524e39d4d381ebba2311ad96164b", "filename": "src/libstd/sys/sgx/abi/thread.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,6 +6,8 @@ use fortanix_sgx_abi::Tcs;\n /// is a one-to-one correspondence of the ID to the address of the TCS.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn current() -> Tcs {\n-    extern \"C\" { fn get_tcs_addr() -> Tcs; }\n+    extern \"C\" {\n+        fn get_tcs_addr() -> Tcs;\n+    }\n     unsafe { get_tcs_addr() }\n }"}, {"sha": "81a766e367d6eb270eec84ff38b9b382eed04fe6", "filename": "src/libstd/sys/sgx/abi/tls.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,11 +1,11 @@\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-use crate::ptr;\n-use crate::mem;\n+use self::sync_bitset::*;\n use crate::cell::Cell;\n+use crate::mem;\n use crate::num::NonZeroUsize;\n-use self::sync_bitset::*;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n \n-#[cfg(target_pointer_width=\"64\")]\n+#[cfg(target_pointer_width = \"64\")]\n const USIZE_BITS: usize = 64;\n const TLS_KEYS: usize = 128; // Same as POSIX minimum\n const TLS_KEYS_BITSET_SIZE: usize = (TLS_KEYS + (USIZE_BITS - 1)) / USIZE_BITS;\n@@ -50,18 +50,18 @@ impl Key {\n \n #[repr(C)]\n pub struct Tls {\n-    data: [Cell<*mut u8>; TLS_KEYS]\n+    data: [Cell<*mut u8>; TLS_KEYS],\n }\n \n pub struct ActiveTls<'a> {\n-    tls: &'a Tls\n+    tls: &'a Tls,\n }\n \n impl<'a> Drop for ActiveTls<'a> {\n     fn drop(&mut self) {\n         let value_with_destructor = |key: usize| {\n             let ptr = TLS_DESTRUCTOR[key].load(Ordering::Relaxed);\n-            unsafe { mem::transmute::<_,Option<unsafe extern fn(*mut u8)>>(ptr) }\n+            unsafe { mem::transmute::<_, Option<unsafe extern \"C\" fn(*mut u8)>>(ptr) }\n                 .map(|dtor| (&self.tls.data[key], dtor))\n         };\n \n@@ -99,7 +99,7 @@ impl Tls {\n         &*(get_tls_ptr() as *const Tls)\n     }\n \n-    pub fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    pub fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n         let index = if let Some(index) = TLS_KEY_IN_USE.set() {\n             index\n         } else {\n@@ -127,10 +127,10 @@ impl Tls {\n }\n \n mod sync_bitset {\n-    use crate::sync::atomic::{AtomicUsize, Ordering};\n+    use super::{TLS_KEYS_BITSET_SIZE, USIZE_BITS};\n     use crate::iter::{Enumerate, Peekable};\n     use crate::slice::Iter;\n-    use super::{TLS_KEYS_BITSET_SIZE, USIZE_BITS};\n+    use crate::sync::atomic::{AtomicUsize, Ordering};\n \n     /// A bitset that can be used synchronously.\n     pub(super) struct SyncBitset([AtomicUsize; TLS_KEYS_BITSET_SIZE]);\n@@ -146,10 +146,7 @@ mod sync_bitset {\n \n         /// Not atomic.\n         pub fn iter(&self) -> SyncBitsetIter<'_> {\n-            SyncBitsetIter {\n-                iter: self.0.iter().enumerate().peekable(),\n-                elem_idx: 0,\n-            }\n+            SyncBitsetIter { iter: self.0.iter().enumerate().peekable(), elem_idx: 0 }\n         }\n \n         pub fn clear(&self, index: usize) {\n@@ -171,7 +168,7 @@ mod sync_bitset {\n                         current,\n                         current | (1 << trailing_ones),\n                         Ordering::AcqRel,\n-                        Ordering::Relaxed\n+                        Ordering::Relaxed,\n                     ) {\n                         Ok(_) => return Some(idx * USIZE_BITS + trailing_ones),\n                         Err(previous) => current = previous,"}, {"sha": "b54c115a2b6b670a7e4ea53cffe06962b6131c03", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,14 +1,14 @@\n #![allow(unused)]\n \n-use crate::ptr::{self, NonNull};\n-use crate::mem;\n use crate::cell::UnsafeCell;\n+use crate::mem;\n+use crate::ops::{CoerceUnsized, Deref, DerefMut, Index, IndexMut};\n+use crate::ptr::{self, NonNull};\n use crate::slice;\n-use crate::ops::{Deref, DerefMut, Index, IndexMut, CoerceUnsized};\n use crate::slice::SliceIndex;\n \n-use fortanix_sgx_abi::*;\n use super::super::mem::is_user_range;\n+use fortanix_sgx_abi::*;\n \n /// A type that can be safely read from or written to userspace.\n ///\n@@ -109,9 +109,7 @@ pub unsafe trait UserSafe {\n     /// * the pointer is null.\n     /// * the pointed-to range is not in user memory.\n     unsafe fn check_ptr(ptr: *const Self) {\n-        let is_aligned = |p| -> bool {\n-            0 == (p as usize) & (Self::align_of() - 1)\n-        };\n+        let is_aligned = |p| -> bool { 0 == (p as usize) & (Self::align_of() - 1) };\n \n         assert!(is_aligned(ptr as *const u8));\n         assert!(is_user_range(ptr as _, mem::size_of_val(&*ptr)));\n@@ -183,7 +181,10 @@ impl<T: ?Sized> NewUserRef<NonNull<T>> for NonNull<UserRef<T>> {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> User<T> where T: UserSafe {\n+impl<T: ?Sized> User<T>\n+where\n+    T: UserSafe,\n+{\n     // This function returns memory that is practically uninitialized, but is\n     // not considered \"unspecified\" or \"undefined\" for purposes of an\n     // optimizing compiler. This is achieved by returning a pointer from\n@@ -211,7 +212,7 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n             ptr::copy(\n                 val as *const T as *const u8,\n                 ret.0.as_ptr() as *mut u8,\n-                mem::size_of_val(val)\n+                mem::size_of_val(val),\n             );\n             ret\n         }\n@@ -244,15 +245,21 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T> User<T> where T: UserSafe {\n+impl<T> User<T>\n+where\n+    T: UserSafe,\n+{\n     /// Allocate space for `T` in user memory.\n     pub fn uninitialized() -> Self {\n         Self::new_uninit_bytes(mem::size_of::<T>())\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T> User<[T]> where [T]: UserSafe {\n+impl<T> User<[T]>\n+where\n+    [T]: UserSafe,\n+{\n     /// Allocate space for a `[T]` of `n` elements in user memory.\n     pub fn uninitialized(n: usize) -> Self {\n         Self::new_uninit_bytes(n * mem::size_of::<T>())\n@@ -278,7 +285,10 @@ impl<T> User<[T]> where [T]: UserSafe {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> UserRef<T> where T: UserSafe {\n+impl<T: ?Sized> UserRef<T>\n+where\n+    T: UserSafe,\n+{\n     /// Creates a `&UserRef<[T]>` from a raw pointer.\n     ///\n     /// # Safety\n@@ -309,7 +319,7 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_mut_ptr<'a>(ptr: *mut T) -> &'a mut Self {\n         T::check_ptr(ptr);\n-        &mut*(ptr as *mut Self)\n+        &mut *(ptr as *mut Self)\n     }\n \n     /// Copies `val` into user memory.\n@@ -319,11 +329,11 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n     /// the source. This can happen for dynamically-sized types such as slices.\n     pub fn copy_from_enclave(&mut self, val: &T) {\n         unsafe {\n-            assert_eq!(mem::size_of_val(val), mem::size_of_val( &*self.0.get() ));\n+            assert_eq!(mem::size_of_val(val), mem::size_of_val(&*self.0.get()));\n             ptr::copy(\n                 val as *const T as *const u8,\n                 self.0.get() as *mut T as *mut u8,\n-                mem::size_of_val(val)\n+                mem::size_of_val(val),\n             );\n         }\n     }\n@@ -335,11 +345,11 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n     /// the source. This can happen for dynamically-sized types such as slices.\n     pub fn copy_to_enclave(&self, dest: &mut T) {\n         unsafe {\n-            assert_eq!(mem::size_of_val(dest), mem::size_of_val( &*self.0.get() ));\n+            assert_eq!(mem::size_of_val(dest), mem::size_of_val(&*self.0.get()));\n             ptr::copy(\n                 self.0.get() as *const T as *const u8,\n                 dest as *mut T as *mut u8,\n-                mem::size_of_val(dest)\n+                mem::size_of_val(dest),\n             );\n         }\n     }\n@@ -356,15 +366,21 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T> UserRef<T> where T: UserSafe {\n+impl<T> UserRef<T>\n+where\n+    T: UserSafe,\n+{\n     /// Copies the value from user memory into enclave memory.\n     pub fn to_enclave(&self) -> T {\n         unsafe { ptr::read(self.0.get()) }\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T> UserRef<[T]> where [T]: UserSafe {\n+impl<T> UserRef<[T]>\n+where\n+    [T]: UserSafe,\n+{\n     /// Creates a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n     ///\n     /// # Safety\n@@ -396,7 +412,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n     /// * The pointed-to range does not fit in the address space\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n-        &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n+        &mut *(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n     }\n \n     /// Obtain a raw pointer to the first element of this user slice.\n@@ -439,20 +455,18 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n \n     /// Returns an iterator over the slice.\n     pub fn iter(&self) -> Iter<'_, T>\n-        where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n+    where\n+        T: UserSafe, // FIXME: should be implied by [T]: UserSafe?\n     {\n-        unsafe {\n-            Iter((&*self.as_raw_ptr()).iter())\n-        }\n+        unsafe { Iter((&*self.as_raw_ptr()).iter()) }\n     }\n \n     /// Returns an iterator that allows modifying each value.\n     pub fn iter_mut(&mut self) -> IterMut<'_, T>\n-        where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n+    where\n+        T: UserSafe, // FIXME: should be implied by [T]: UserSafe?\n     {\n-        unsafe {\n-            IterMut((&mut*self.as_raw_mut_ptr()).iter_mut())\n-        }\n+        unsafe { IterMut((&mut *self.as_raw_mut_ptr()).iter_mut()) }\n     }\n }\n \n@@ -468,9 +482,7 @@ impl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        unsafe {\n-            self.0.next().map(|e| UserRef::from_ptr(e))\n-        }\n+        unsafe { self.0.next().map(|e| UserRef::from_ptr(e)) }\n     }\n }\n \n@@ -486,14 +498,15 @@ impl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        unsafe {\n-            self.0.next().map(|e| UserRef::from_mut_ptr(e))\n-        }\n+        unsafe { self.0.next().map(|e| UserRef::from_mut_ptr(e)) }\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> Deref for User<T> where T: UserSafe {\n+impl<T: ?Sized> Deref for User<T>\n+where\n+    T: UserSafe,\n+{\n     type Target = UserRef<T>;\n \n     fn deref(&self) -> &Self::Target {\n@@ -502,18 +515,24 @@ impl<T: ?Sized> Deref for User<T> where T: UserSafe {\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> DerefMut for User<T> where T: UserSafe {\n+impl<T: ?Sized> DerefMut for User<T>\n+where\n+    T: UserSafe,\n+{\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        unsafe { &mut*self.0.as_ptr() }\n+        unsafe { &mut *self.0.as_ptr() }\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T: ?Sized> Drop for User<T> where T: UserSafe {\n+impl<T: ?Sized> Drop for User<T>\n+where\n+    T: UserSafe,\n+{\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = (*self.0.as_ptr()).0.get();\n-            super::free(ptr as _, mem::size_of_val(&mut*ptr), T::align_of());\n+            super::free(ptr as _, mem::size_of_val(&mut *ptr), T::align_of());\n         }\n     }\n }\n@@ -550,7 +569,7 @@ where\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n         unsafe {\n-            if let Some(slice) = index.get_mut(&mut*self.as_raw_mut_ptr()) {\n+            if let Some(slice) = index.get_mut(&mut *self.as_raw_mut_ptr()) {\n                 UserRef::from_mut_ptr(slice)\n             } else {\n                 rtabort!(\"index out of range for user slice\");"}, {"sha": "ae803ee47a6cb1717bd7439a6cc80322b28557ad", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n use crate::cmp;\n-use crate::io::{Error as IoError, Result as IoResult, IoSlice, IoSliceMut};\n+use crate::io::{Error as IoError, IoSlice, IoSliceMut, Result as IoResult};\n use crate::time::Duration;\n \n pub(crate) mod alloc;\n@@ -26,7 +26,7 @@ pub fn read(fd: Fd, bufs: &mut [IoSliceMut<'_>]) -> IoResult<usize> {\n                 userbuf[index..end].copy_to_enclave(&mut buf[..buflen]);\n                 index += buf.len();\n             } else {\n-                break\n+                break;\n             }\n         }\n         Ok(userbuf.len())\n@@ -60,7 +60,7 @@ pub fn write(fd: Fd, bufs: &[IoSlice<'_>]) -> IoResult<usize> {\n                 userbuf[index..end].copy_from_enclave(&buf[..buflen]);\n                 index += buf.len();\n             } else {\n-                break\n+                break;\n             }\n         }\n         raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n@@ -90,11 +90,8 @@ pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n     unsafe {\n         let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n         let mut local = alloc::User::<ByteBuffer>::uninitialized();\n-        let fd = raw::bind_stream(\n-            addr_user.as_ptr(),\n-            addr_user.len(),\n-            local.as_raw_mut_ptr()\n-        ).from_sgx_result()?;\n+        let fd = raw::bind_stream(addr_user.as_ptr(), addr_user.len(), local.as_raw_mut_ptr())\n+            .from_sgx_result()?;\n         let local = string_from_bytebuffer(&local, \"bind_stream\", \"local_addr\");\n         Ok((fd, local))\n     }\n@@ -106,13 +103,10 @@ pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n     unsafe {\n         let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n         let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n-                                                               // without forcing coercion?\n+        // without forcing coercion?\n         let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n-        let fd = raw::accept_stream(\n-            fd,\n-            local.as_raw_mut_ptr(),\n-            peer.as_raw_mut_ptr()\n-        ).from_sgx_result()?;\n+        let fd = raw::accept_stream(fd, local.as_raw_mut_ptr(), peer.as_raw_mut_ptr())\n+            .from_sgx_result()?;\n         let local = string_from_bytebuffer(&local, \"accept_stream\", \"local_addr\");\n         let peer = string_from_bytebuffer(&peer, \"accept_stream\", \"peer_addr\");\n         Ok((fd, local, peer))\n@@ -126,14 +120,15 @@ pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n         let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n         let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n         let mut buf_it = alloc::UserRef::iter_mut(&mut *bufs); // FIXME: can this be done\n-                                                               // without forcing coercion?\n+        // without forcing coercion?\n         let (local, peer) = (buf_it.next().unwrap(), buf_it.next().unwrap());\n         let fd = raw::connect_stream(\n             addr_user.as_ptr(),\n             addr_user.len(),\n             local.as_raw_mut_ptr(),\n-            peer.as_raw_mut_ptr()\n-        ).from_sgx_result()?;\n+            peer.as_raw_mut_ptr(),\n+        )\n+        .from_sgx_result()?;\n         let local = string_from_bytebuffer(&local, \"connect_stream\", \"local_addr\");\n         let peer = string_from_bytebuffer(&peer, \"connect_stream\", \"peer_addr\");\n         Ok((fd, local, peer))\n@@ -183,25 +178,25 @@ pub use self::raw::free;\n \n fn check_os_error(err: Result) -> i32 {\n     // FIXME: not sure how to make sure all variants of Error are covered\n-    if err == Error::NotFound as _ ||\n-       err == Error::PermissionDenied as _ ||\n-       err == Error::ConnectionRefused as _ ||\n-       err == Error::ConnectionReset as _ ||\n-       err == Error::ConnectionAborted as _ ||\n-       err == Error::NotConnected as _ ||\n-       err == Error::AddrInUse as _ ||\n-       err == Error::AddrNotAvailable as _ ||\n-       err == Error::BrokenPipe as _ ||\n-       err == Error::AlreadyExists as _ ||\n-       err == Error::WouldBlock as _ ||\n-       err == Error::InvalidInput as _ ||\n-       err == Error::InvalidData as _ ||\n-       err == Error::TimedOut as _ ||\n-       err == Error::WriteZero as _ ||\n-       err == Error::Interrupted as _ ||\n-       err == Error::Other as _ ||\n-       err == Error::UnexpectedEof as _ ||\n-       ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&err)\n+    if err == Error::NotFound as _\n+        || err == Error::PermissionDenied as _\n+        || err == Error::ConnectionRefused as _\n+        || err == Error::ConnectionReset as _\n+        || err == Error::ConnectionAborted as _\n+        || err == Error::NotConnected as _\n+        || err == Error::AddrInUse as _\n+        || err == Error::AddrNotAvailable as _\n+        || err == Error::BrokenPipe as _\n+        || err == Error::AlreadyExists as _\n+        || err == Error::WouldBlock as _\n+        || err == Error::InvalidInput as _\n+        || err == Error::InvalidData as _\n+        || err == Error::TimedOut as _\n+        || err == Error::WriteZero as _\n+        || err == Error::Interrupted as _\n+        || err == Error::Other as _\n+        || err == Error::UnexpectedEof as _\n+        || ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&err)\n     {\n         err\n     } else {"}, {"sha": "e0ebf860618c8f14705e23628dc563517776f79e", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -3,8 +3,8 @@\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub use fortanix_sgx_abi::*;\n \n-use crate::ptr::NonNull;\n use crate::num::NonZeroU64;\n+use crate::ptr::NonNull;\n \n #[repr(C)]\n struct UsercallReturn(u64, u64);\n@@ -25,9 +25,14 @@ extern \"C\" {\n /// Panics if `nr` is `0`.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n #[inline]\n-pub unsafe fn do_usercall(nr: NonZeroU64, p1: u64, p2: u64, p3: u64, p4: u64, abort: bool)\n-    -> (u64, u64)\n-{\n+pub unsafe fn do_usercall(\n+    nr: NonZeroU64,\n+    p1: u64,\n+    p2: u64,\n+    p3: u64,\n+    p4: u64,\n+    abort: bool,\n+) -> (u64, u64) {\n     let UsercallReturn(a, b) = usercall(nr, p1, p2, abort as _, p3, p4);\n     (a, b)\n }\n@@ -109,11 +114,7 @@ define_ra!(<T> *mut T);\n \n impl RegisterArgument for bool {\n     fn from_register(a: Register) -> bool {\n-        if a != 0 {\n-            true\n-        } else {\n-            false\n-        }\n+        if a != 0 { true } else { false }\n     }\n     fn into_register(self) -> Register {\n         self as _\n@@ -152,16 +153,17 @@ impl<T: RegisterArgument> ReturnValue for T {\n \n impl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n     fn from_registers(_call: &'static str, regs: (Register, Register)) -> Self {\n-        (\n-            T::from_register(regs.0),\n-            U::from_register(regs.1)\n-        )\n+        (T::from_register(regs.0), U::from_register(regs.1))\n     }\n }\n \n macro_rules! return_type_is_abort {\n-    (!) => { true };\n-    ($r:ty) => { false };\n+    (!) => {\n+        true\n+    };\n+    ($r:ty) => {\n+        false\n+    };\n }\n \n // In this macro: using `$r:tt` because `$r:ty` doesn't match ! in `return_type_is_abort`"}, {"sha": "b47a48e752cb7859570aa9212583a9ad4a9077e1", "filename": "src/libstd/sys/sgx/args.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n use super::abi::usercalls::{alloc, raw::ByteBuffer};\n use crate::ffi::OsString;\n+use crate::slice;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::os_str::Buf;\n use crate::sys_common::FromInner;\n-use crate::slice;\n \n #[cfg_attr(test, linkage = \"available_externally\")]\n #[export_name = \"_ZN16__rust_internals3std3sys3sgx4args4ARGSE\"]\n@@ -14,8 +14,9 @@ type ArgsStore = Vec<OsString>;\n pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     if argc != 0 {\n         let args = alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _);\n-        let args = args.iter()\n-            .map( |a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }) )\n+        let args = args\n+            .iter()\n+            .map(|a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }))\n             .collect::<ArgsStore>();\n         ARGS.store(Box::into_raw(Box::new(args)) as _, Ordering::Relaxed);\n     }\n@@ -30,11 +31,7 @@ pub unsafe fn cleanup() {\n \n pub fn args() -> Args {\n     let args = unsafe { (ARGS.load(Ordering::Relaxed) as *const ArgsStore).as_ref() };\n-    if let Some(args) = args {\n-        Args(args.iter())\n-    } else {\n-        Args([].iter())\n-    }\n+    if let Some(args) = args { Args(args.iter()) } else { Args([].iter()) }\n }\n \n pub struct Args(slice::Iter<'static, OsString>);"}, {"sha": "b89238f1da8f7af7f3eada50e050eff26797e857", "filename": "src/libstd/sys/sgx/cmath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n #![cfg(not(test))]\n \n // These symbols are all defined in `compiler-builtins`\n-extern {\n+extern \"C\" {\n     pub fn acos(n: f64) -> f64;\n     pub fn acosf(n: f32) -> f32;\n     pub fn asin(n: f64) -> f64;"}, {"sha": "8aa84a550d2edfab8c98aefa4eb9b092ed1b2626", "filename": "src/libstd/sys/sgx/ext/io.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -4,8 +4,8 @@\n //! description of [`TryIntoRawFd`](trait.TryIntoRawFd.html) for more details.\n #![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n \n-pub use crate::sys::abi::usercalls::raw::Fd as RawFd;\n use crate::net;\n+pub use crate::sys::abi::usercalls::raw::Fd as RawFd;\n use crate::sys::{self, AsInner, FromInner, IntoInner, TryIntoInner};\n \n /// A trait to extract the raw SGX file descriptor from an underlying\n@@ -60,11 +60,15 @@ pub trait TryIntoRawFd: Sized {\n }\n \n impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().as_inner().as_inner().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().as_inner().as_inner().as_inner()\n+    }\n }\n \n impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().as_inner().as_inner().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().as_inner().as_inner().as_inner()\n+    }\n }\n \n impl FromRawFd for net::TcpStream {"}, {"sha": "258ad3cd2180ce6a1a3f63e66783be324a4e8dd2", "filename": "src/libstd/sys/sgx/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n #![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n \n pub mod arch;\n-pub mod io;\n pub mod ffi;\n+pub mod io;"}, {"sha": "7da2424a6426195437b0ef48c1a3b5dfbf5f875b", "filename": "src/libstd/sys/sgx/fd.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n use fortanix_sgx_abi::Fd;\n \n+use super::abi::usercalls;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::sys::{AsInner, FromInner, IntoInner};\n-use super::abi::usercalls;\n \n #[derive(Debug)]\n pub struct FileDesc {\n@@ -15,7 +15,9 @@ impl FileDesc {\n         FileDesc { fd: fd }\n     }\n \n-    pub fn raw(&self) -> Fd { self.fd }\n+    pub fn raw(&self) -> Fd {\n+        self.fd\n+    }\n \n     /// Extracts the actual filedescriptor without closing it.\n     pub fn into_raw(self) -> Fd {\n@@ -46,7 +48,9 @@ impl FileDesc {\n }\n \n impl AsInner<Fd> for FileDesc {\n-    fn as_inner(&self) -> &Fd { &self.fd }\n+    fn as_inner(&self) -> &Fd {\n+        &self.fd\n+    }\n }\n \n impl IntoInner<Fd> for FileDesc {"}, {"sha": "e6160d1457d269176ba95e96409b6eda799d4bb7", "filename": "src/libstd/sys/sgx/fs.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::io::{self, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sys::time::SystemTime;\n use crate::sys::{unsupported, Void};\n@@ -15,14 +15,14 @@ pub struct ReadDir(Void);\n pub struct DirEntry(Void);\n \n #[derive(Clone, Debug)]\n-pub struct OpenOptions { }\n+pub struct OpenOptions {}\n \n pub struct FilePermissions(Void);\n \n pub struct FileType(Void);\n \n #[derive(Debug)]\n-pub struct DirBuilder { }\n+pub struct DirBuilder {}\n \n impl FileAttr {\n     pub fn size(&self) -> u64 {\n@@ -78,8 +78,7 @@ impl PartialEq for FilePermissions {\n     }\n }\n \n-impl Eq for FilePermissions {\n-}\n+impl Eq for FilePermissions {}\n \n impl fmt::Debug for FilePermissions {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -115,8 +114,7 @@ impl PartialEq for FileType {\n     }\n }\n \n-impl Eq for FileType {\n-}\n+impl Eq for FileType {}\n \n impl Hash for FileType {\n     fn hash<H: Hasher>(&self, _h: &mut H) {\n@@ -164,15 +162,15 @@ impl DirEntry {\n \n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n-        OpenOptions { }\n+        OpenOptions {}\n     }\n \n-    pub fn read(&mut self, _read: bool) { }\n-    pub fn write(&mut self, _write: bool) { }\n-    pub fn append(&mut self, _append: bool) { }\n-    pub fn truncate(&mut self, _truncate: bool) { }\n-    pub fn create(&mut self, _create: bool) { }\n-    pub fn create_new(&mut self, _create_new: bool) { }\n+    pub fn read(&mut self, _read: bool) {}\n+    pub fn write(&mut self, _write: bool) {}\n+    pub fn append(&mut self, _append: bool) {}\n+    pub fn truncate(&mut self, _truncate: bool) {}\n+    pub fn create(&mut self, _create: bool) {}\n+    pub fn create_new(&mut self, _create_new: bool) {}\n }\n \n impl File {\n@@ -235,7 +233,7 @@ impl File {\n \n impl DirBuilder {\n     pub fn new() -> DirBuilder {\n-        DirBuilder { }\n+        DirBuilder {}\n     }\n \n     pub fn mkdir(&self, _p: &Path) -> io::Result<()> {"}, {"sha": "f36687b4d3d5855609fc742f4104f858435a625d", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,12 +1,12 @@\n-use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n-use crate::time::Duration;\n-use crate::sys::{unsupported, Void, sgx_ineffective, AsInner, FromInner, IntoInner, TryIntoInner};\n-use crate::sys::fd::FileDesc;\n use crate::convert::TryFrom;\n use crate::error;\n+use crate::fmt;\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sync::Arc;\n+use crate::sys::fd::FileDesc;\n+use crate::sys::{sgx_ineffective, unsupported, AsInner, FromInner, IntoInner, TryIntoInner, Void};\n+use crate::time::Duration;\n \n use super::abi::usercalls;\n \n@@ -25,13 +25,15 @@ impl Socket {\n }\n \n impl AsInner<FileDesc> for Socket {\n-    fn as_inner(&self) -> &FileDesc { &self.inner }\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.inner\n+    }\n }\n \n impl TryIntoInner<FileDesc> for Socket {\n     fn try_into_inner(self) -> Result<FileDesc, Socket> {\n         let Socket { inner, local_addr } = self;\n-        Arc::try_unwrap(inner).map_err(|inner| Socket { inner, local_addr } )\n+        Arc::try_unwrap(inner).map_err(|inner| Socket { inner, local_addr })\n     }\n }\n \n@@ -59,8 +61,7 @@ impl fmt::Debug for TcpStream {\n             res.field(\"peer\", peer);\n         }\n \n-        res.field(\"fd\", &self.inner.inner.as_inner())\n-            .finish()\n+        res.field(\"fd\", &self.inner.inner.as_inner()).finish()\n     }\n }\n \n@@ -69,10 +70,12 @@ fn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n         Ok(saddr) => Ok(saddr.to_string()),\n         // need to downcast twice because io::Error::into_inner doesn't return the original\n         // value if the conversion fails\n-        Err(e) => if e.get_ref().and_then(|e| e.downcast_ref::<NonIpSockAddr>()).is_some() {\n-            Ok(e.into_inner().unwrap().downcast::<NonIpSockAddr>().unwrap().host)\n-        } else {\n-            Err(e)\n+        Err(e) => {\n+            if e.get_ref().and_then(|e| e.downcast_ref::<NonIpSockAddr>()).is_some() {\n+                Ok(e.into_inner().unwrap().downcast::<NonIpSockAddr>().unwrap().host)\n+            } else {\n+                Err(e)\n+            }\n         }\n     }\n }\n@@ -94,29 +97,35 @@ impl TcpStream {\n \n     pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {\n         if dur == Duration::default() {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"cannot set a 0 duration timeout\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"cannot set a 0 duration timeout\",\n+            ));\n         }\n         Self::connect(Ok(addr)) // FIXME: ignoring timeout\n     }\n \n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                          \"cannot set a 0 duration timeout\"));\n+                return Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"cannot set a 0 duration timeout\",\n+                ));\n             }\n-            _ => sgx_ineffective(())\n+            _ => sgx_ineffective(()),\n         }\n     }\n \n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                          \"cannot set a 0 duration timeout\"));\n+                return Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"cannot set a 0 duration timeout\",\n+                ));\n             }\n-            _ => sgx_ineffective(())\n+            _ => sgx_ineffective(()),\n         }\n     }\n \n@@ -190,7 +199,9 @@ impl TcpStream {\n }\n \n impl AsInner<Socket> for TcpStream {\n-    fn as_inner(&self) -> &Socket { &self.inner }\n+    fn as_inner(&self) -> &Socket {\n+        &self.inner\n+    }\n }\n \n // `Inner` includes `peer_addr` so that a `TcpStream` maybe correctly\n@@ -220,8 +231,7 @@ impl fmt::Debug for TcpListener {\n             res.field(\"addr\", addr);\n         }\n \n-        res.field(\"fd\", &self.inner.inner.as_inner())\n-            .finish()\n+        res.field(\"fd\", &self.inner.inner.as_inner()).finish()\n     }\n }\n \n@@ -273,7 +283,9 @@ impl TcpListener {\n }\n \n impl AsInner<Socket> for TcpListener {\n-    fn as_inner(&self) -> &Socket { &self.inner }\n+    fn as_inner(&self) -> &Socket {\n+        &self.inner\n+    }\n }\n \n impl IntoInner<Socket> for TcpListener {\n@@ -367,23 +379,19 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n@@ -428,7 +436,7 @@ impl fmt::Debug for UdpSocket {\n \n #[derive(Debug)]\n pub struct NonIpSockAddr {\n-    host: String\n+    host: String,\n }\n \n impl error::Error for NonIpSockAddr {\n@@ -511,8 +519,7 @@ pub mod netc {\n     }\n \n     #[derive(Copy, Clone)]\n-    pub struct sockaddr {\n-    }\n+    pub struct sockaddr {}\n \n     pub type socklen_t = usize;\n }"}, {"sha": "2c5b31342199affa5300d6dc7fb35f069e798672", "filename": "src/libstd/sys/sgx/os.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,17 +1,17 @@\n use fortanix_sgx_abi::{Error, RESULT_SUCCESS};\n \n+use crate::collections::HashMap;\n use crate::error::Error as StdError;\n-use crate::ffi::{OsString, OsStr};\n+use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::path::{self, PathBuf};\n use crate::str;\n-use crate::sys::{unsupported, Void, sgx_ineffective, decode_error_kind};\n-use crate::collections::HashMap;\n-use crate::vec;\n-use crate::sync::Mutex;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::Mutex;\n use crate::sync::Once;\n+use crate::sys::{decode_error_kind, sgx_ineffective, unsupported, Void};\n+use crate::vec;\n \n pub fn errno() -> i32 {\n     RESULT_SUCCESS\n@@ -52,7 +52,9 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     Err(JoinPathsError)\n }\n@@ -89,26 +91,21 @@ fn create_env_store() -> &'static EnvStore {\n     ENV_INIT.call_once(|| {\n         ENV.store(Box::into_raw(Box::new(EnvStore::default())) as _, Ordering::Relaxed)\n     });\n-    unsafe {\n-        &*(ENV.load(Ordering::Relaxed) as *const EnvStore)\n-    }\n+    unsafe { &*(ENV.load(Ordering::Relaxed) as *const EnvStore) }\n }\n \n pub type Env = vec::IntoIter<(OsString, OsString)>;\n \n pub fn env() -> Env {\n     let clone_to_vec = |map: &HashMap<OsString, OsString>| -> Vec<_> {\n-        map.iter().map(|(k, v)| (k.clone(), v.clone()) ).collect()\n+        map.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n     };\n \n-    get_env_store()\n-        .map(|env| clone_to_vec(&env.lock().unwrap()) )\n-        .unwrap_or_default()\n-        .into_iter()\n+    get_env_store().map(|env| clone_to_vec(&env.lock().unwrap())).unwrap_or_default().into_iter()\n }\n \n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    Ok(get_env_store().and_then(|s| s.lock().unwrap().get(k).cloned() ))\n+    Ok(get_env_store().and_then(|s| s.lock().unwrap().get(k).cloned()))\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {"}, {"sha": "06c9df3ff5427afd68fe1fb4f9d56fab7dc98d37", "filename": "src/libstd/sys/sgx/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/sgx/process.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -32,32 +32,28 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default()\n-        }\n+        Command { env: Default::default() }\n     }\n \n-    pub fn arg(&mut self, _arg: &OsStr) {\n-    }\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n \n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n-    pub fn cwd(&mut self, _dir: &OsStr) {\n-    }\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n \n-    pub fn stdin(&mut self, _stdin: Stdio) {\n-    }\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n \n-    pub fn stdout(&mut self, _stdout: Stdio) {\n-    }\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n \n-    pub fn stderr(&mut self, _stderr: Stdio) {\n-    }\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n \n-    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n-        -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         unsupported()\n     }\n }\n@@ -106,8 +102,7 @@ impl PartialEq for ExitStatus {\n     }\n }\n \n-impl Eq for ExitStatus {\n-}\n+impl Eq for ExitStatus {}\n \n impl fmt::Debug for ExitStatus {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "a2d13d11849e790a2addf31f5b62a00ebaebb967", "filename": "src/libstd/sys/sgx/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -7,8 +7,6 @@ impl Handler {\n }\n \n #[cfg_attr(test, allow(dead_code))]\n-pub unsafe fn init() {\n-}\n+pub unsafe fn init() {}\n \n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}"}, {"sha": "716c174bd53b65a165231e2c1959603384b2a4d2", "filename": "src/libstd/sys/sgx/stdio.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,11 +1,11 @@\n use fortanix_sgx_abi as abi;\n \n use crate::io;\n-use crate::sys::fd::FileDesc;\n #[cfg(not(test))]\n use crate::slice;\n #[cfg(not(test))]\n use crate::str;\n+use crate::sys::fd::FileDesc;\n \n pub struct Stdin(());\n pub struct Stdout(());\n@@ -19,7 +19,9 @@ fn with_std_fd<F: FnOnce(&FileDesc) -> R, R>(fd: abi::Fd, f: F) -> R {\n }\n \n impl Stdin {\n-    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin(()))\n+    }\n }\n \n impl io::Read for Stdin {\n@@ -29,7 +31,9 @@ impl io::Read for Stdin {\n }\n \n impl Stdout {\n-    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout(()))\n+    }\n }\n \n impl io::Write for Stdout {\n@@ -43,7 +47,9 @@ impl io::Write for Stdout {\n }\n \n impl Stderr {\n-    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr(()))\n+    }\n }\n \n impl io::Write for Stderr {"}, {"sha": "9b515eb82de350bd5bc468d4cf626d8f0ca10c6b", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -10,8 +10,8 @@ pub struct Thread(task_queue::JoinHandle);\n pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n \n mod task_queue {\n-    use crate::sync::{Mutex, MutexGuard, Once};\n     use crate::sync::mpsc;\n+    use crate::sync::{Mutex, MutexGuard, Once};\n \n     pub type JoinHandle = mpsc::Receiver<()>;\n \n@@ -41,17 +41,15 @@ mod task_queue {\n \n     pub(super) fn lock() -> MutexGuard<'static, Vec<Task>> {\n         unsafe {\n-            TASK_QUEUE_INIT.call_once(|| TASK_QUEUE = Some(Default::default()) );\n+            TASK_QUEUE_INIT.call_once(|| TASK_QUEUE = Some(Default::default()));\n             TASK_QUEUE.as_ref().unwrap().lock().unwrap()\n         }\n     }\n }\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(_stack: usize, p: Box<dyn FnOnce()>)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new(_stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         let mut queue_lock = task_queue::lock();\n         usercalls::launch_thread()?;\n         let (task, handle) = task_queue::Task::new(p);\n@@ -86,6 +84,10 @@ impl Thread {\n \n pub mod guard {\n     pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }"}, {"sha": "b21784475f0d2d020aa4f0eb14cff31d0b1f558c", "filename": "src/libstd/sys/sgx/thread_local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n-use super::abi::tls::{Tls, Key as AbiKey};\n+use super::abi::tls::{Key as AbiKey, Tls};\n \n pub type Key = usize;\n \n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     Tls::create(dtor).as_usize()\n }\n "}, {"sha": "e2f6e6dba695d3f80c4dfd8b86c6596c0299b3ff", "filename": "src/libstd/sys/sgx/time.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n-use crate::time::Duration;\n use super::abi::usercalls;\n+use crate::time::Duration;\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -40,8 +40,7 @@ impl SystemTime {\n         SystemTime(usercalls::insecure_time())\n     }\n \n-    pub fn sub_time(&self, other: &SystemTime)\n-                    -> Result<Duration, Duration> {\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n         self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n     }\n "}, {"sha": "77417e41331273182742069d918b7ce138cab182", "filename": "src/libstd/sys/unix/alloc.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Falloc.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,6 +1,6 @@\n-use crate::ptr;\n-use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ptr;\n+use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n unsafe impl GlobalAlloc for System {\n@@ -16,7 +16,7 @@ unsafe impl GlobalAlloc for System {\n             #[cfg(target_os = \"macos\")]\n             {\n                 if layout.align() > (1 << 31) {\n-                    return ptr::null_mut()\n+                    return ptr::null_mut();\n                 }\n             }\n             aligned_malloc(&layout)\n@@ -52,9 +52,7 @@ unsafe impl GlobalAlloc for System {\n     }\n }\n \n-#[cfg(any(target_os = \"android\",\n-          target_os = \"redox\",\n-          target_os = \"solaris\"))]\n+#[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n #[inline]\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     // On android we currently target API level 9 which unfortunately\n@@ -77,19 +75,13 @@ unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     libc::memalign(layout.align(), layout.size()) as *mut u8\n }\n \n-#[cfg(not(any(target_os = \"android\",\n-              target_os = \"redox\",\n-              target_os = \"solaris\")))]\n+#[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n #[inline]\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     let mut out = ptr::null_mut();\n     // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n     // Since these are all powers of 2, we can just use max.\n     let align = layout.align().max(crate::mem::size_of::<usize>());\n     let ret = libc::posix_memalign(&mut out, align, layout.size());\n-    if ret != 0 {\n-        ptr::null_mut()\n-    } else {\n-        out as *mut u8\n-    }\n+    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n }"}, {"sha": "c5e9d66e85ef9dd0e59c0898db6fccba1d19499d", "filename": "src/libstd/sys/unix/android.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -21,8 +21,8 @@\n use libc::{c_int, c_void, sighandler_t, size_t, ssize_t};\n use libc::{ftruncate, pread, pwrite};\n \n-use crate::io;\n use super::{cvt, cvt_r};\n+use crate::io;\n \n // The `log2` and `log2f` functions apparently appeared in android-18, or at\n // least you can see they're not present in the android-17 header [1] and they\n@@ -96,8 +96,7 @@ pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n             Some(f) => cvt_r(|| f(fd, size as i64)).map(|_| ()),\n             None => {\n                 if size > i32::max_value() as u64 {\n-                    Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                       \"cannot truncate >2GB\"))\n+                    Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot truncate >2GB\"))\n                 } else {\n                     cvt_r(|| ftruncate(fd, size as i32)).map(|_| ())\n                 }\n@@ -108,53 +107,61 @@ pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n \n #[cfg(target_pointer_width = \"64\")]\n pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n-    unsafe {\n-        cvt_r(|| ftruncate(fd, size as i64)).map(|_| ())\n-    }\n+    unsafe { cvt_r(|| ftruncate(fd, size as i64)).map(|_| ()) }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n+pub unsafe fn cvt_pread64(\n+    fd: c_int,\n+    buf: *mut c_void,\n+    count: size_t,\n+    offset: i64,\n+) -> io::Result<ssize_t> {\n     use crate::convert::TryInto;\n     weak!(fn pread64(c_int, *mut c_void, size_t, i64) -> ssize_t);\n     pread64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n         if let Ok(o) = offset.try_into() {\n             cvt(pread(fd, buf, count, o))\n         } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                               \"cannot pread >2GB\"))\n+            Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot pread >2GB\"))\n         }\n     })\n }\n \n #[cfg(target_pointer_width = \"32\")]\n-pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n+pub unsafe fn cvt_pwrite64(\n+    fd: c_int,\n+    buf: *const c_void,\n+    count: size_t,\n+    offset: i64,\n+) -> io::Result<ssize_t> {\n     use crate::convert::TryInto;\n     weak!(fn pwrite64(c_int, *const c_void, size_t, i64) -> ssize_t);\n     pwrite64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n         if let Ok(o) = offset.try_into() {\n             cvt(pwrite(fd, buf, count, o))\n         } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                               \"cannot pwrite >2GB\"))\n+            Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot pwrite >2GB\"))\n         }\n     })\n }\n \n #[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n+pub unsafe fn cvt_pread64(\n+    fd: c_int,\n+    buf: *mut c_void,\n+    count: size_t,\n+    offset: i64,\n+) -> io::Result<ssize_t> {\n     cvt(pread(fd, buf, count, offset))\n }\n \n #[cfg(target_pointer_width = \"64\")]\n-pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n-    -> io::Result<ssize_t>\n-{\n+pub unsafe fn cvt_pwrite64(\n+    fd: c_int,\n+    buf: *const c_void,\n+    count: size_t,\n+    offset: i64,\n+) -> io::Result<ssize_t> {\n     cvt(pwrite(fd, buf, count, offset))\n }"}, {"sha": "2916ebe4440593d2e1c9b4144f5b83da0ae8a28c", "filename": "src/libstd/sys/unix/cmath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcmath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n #![cfg(not(test))]\n \n-use libc::{c_float, c_double};\n+use libc::{c_double, c_float};\n \n #[link_name = \"m\"]\n-extern {\n+extern \"C\" {\n     pub fn acos(n: c_double) -> c_double;\n     pub fn acosf(n: c_float) -> c_float;\n     pub fn asin(n: c_double) -> c_double;"}, {"sha": "732cd677a18594f495f651c13f6b5ec7688ab476", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 77, "deletions": 31, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,12 +2,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::fs::{self, Permissions, OpenOptions};\n+use crate::fs::{self, OpenOptions, Permissions};\n use crate::io;\n use crate::path::Path;\n use crate::sys;\n-use crate::sys_common::{FromInner, AsInner, AsInnerMut};\n use crate::sys::platform::fs::MetadataExt as UnixMetadataExt;\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n \n /// Unix-specific extensions to [`File`].\n ///\n@@ -112,8 +112,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new(io::ErrorKind::UnexpectedEof,\n-                               \"failed to fill whole buffer\"))\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -195,8 +194,12 @@ pub trait FileExt {\n     fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n-                Ok(0) => return Err(io::Error::new(io::ErrorKind::WriteZero,\n-                                                   \"failed to write whole buffer\")),\n+                Ok(0) => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::WriteZero,\n+                        \"failed to write whole buffer\",\n+                    ));\n+                }\n                 Ok(n) => {\n                     buf = &buf[n..];\n                     offset += n as u64\n@@ -356,11 +359,13 @@ pub trait OpenOptionsExt {\n #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n impl OpenOptionsExt for OpenOptions {\n     fn mode(&mut self, mode: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().mode(mode); self\n+        self.as_inner_mut().mode(mode);\n+        self\n     }\n \n     fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n-        self.as_inner_mut().custom_flags(flags); self\n+        self.as_inner_mut().custom_flags(flags);\n+        self\n     }\n }\n \n@@ -657,22 +662,54 @@ pub trait MetadataExt {\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n impl MetadataExt for fs::Metadata {\n-    fn dev(&self) -> u64 { self.st_dev() }\n-    fn ino(&self) -> u64 { self.st_ino() }\n-    fn mode(&self) -> u32 { self.st_mode() }\n-    fn nlink(&self) -> u64 { self.st_nlink() }\n-    fn uid(&self) -> u32 { self.st_uid() }\n-    fn gid(&self) -> u32 { self.st_gid() }\n-    fn rdev(&self) -> u64 { self.st_rdev() }\n-    fn size(&self) -> u64 { self.st_size() }\n-    fn atime(&self) -> i64 { self.st_atime() }\n-    fn atime_nsec(&self) -> i64 { self.st_atime_nsec() }\n-    fn mtime(&self) -> i64 { self.st_mtime() }\n-    fn mtime_nsec(&self) -> i64 { self.st_mtime_nsec() }\n-    fn ctime(&self) -> i64 { self.st_ctime() }\n-    fn ctime_nsec(&self) -> i64 { self.st_ctime_nsec() }\n-    fn blksize(&self) -> u64 { self.st_blksize() }\n-    fn blocks(&self) -> u64 { self.st_blocks() }\n+    fn dev(&self) -> u64 {\n+        self.st_dev()\n+    }\n+    fn ino(&self) -> u64 {\n+        self.st_ino()\n+    }\n+    fn mode(&self) -> u32 {\n+        self.st_mode()\n+    }\n+    fn nlink(&self) -> u64 {\n+        self.st_nlink()\n+    }\n+    fn uid(&self) -> u32 {\n+        self.st_uid()\n+    }\n+    fn gid(&self) -> u32 {\n+        self.st_gid()\n+    }\n+    fn rdev(&self) -> u64 {\n+        self.st_rdev()\n+    }\n+    fn size(&self) -> u64 {\n+        self.st_size()\n+    }\n+    fn atime(&self) -> i64 {\n+        self.st_atime()\n+    }\n+    fn atime_nsec(&self) -> i64 {\n+        self.st_atime_nsec()\n+    }\n+    fn mtime(&self) -> i64 {\n+        self.st_mtime()\n+    }\n+    fn mtime_nsec(&self) -> i64 {\n+        self.st_mtime_nsec()\n+    }\n+    fn ctime(&self) -> i64 {\n+        self.st_ctime()\n+    }\n+    fn ctime_nsec(&self) -> i64 {\n+        self.st_ctime_nsec()\n+    }\n+    fn blksize(&self) -> u64 {\n+        self.st_blksize()\n+    }\n+    fn blocks(&self) -> u64 {\n+        self.st_blocks()\n+    }\n }\n \n /// Unix-specific extensions for [`FileType`].\n@@ -759,10 +796,18 @@ pub trait FileTypeExt {\n \n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n impl FileTypeExt for fs::FileType {\n-    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }\n-    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }\n-    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }\n-    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }\n+    fn is_block_device(&self) -> bool {\n+        self.as_inner().is(libc::S_IFBLK)\n+    }\n+    fn is_char_device(&self) -> bool {\n+        self.as_inner().is(libc::S_IFCHR)\n+    }\n+    fn is_fifo(&self) -> bool {\n+        self.as_inner().is(libc::S_IFIFO)\n+    }\n+    fn is_socket(&self) -> bool {\n+        self.as_inner().is(libc::S_IFSOCK)\n+    }\n }\n \n /// Unix-specific extension methods for [`fs::DirEntry`].\n@@ -794,7 +839,9 @@ pub trait DirEntryExt {\n \n #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n impl DirEntryExt for fs::DirEntry {\n-    fn ino(&self) -> u64 { self.as_inner().ino() }\n+    fn ino(&self) -> u64 {\n+        self.as_inner().ino()\n+    }\n }\n \n /// Creates a new symbolic link on the filesystem.\n@@ -821,8 +868,7 @@ impl DirEntryExt for fs::DirEntry {\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n-{\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     sys::fs::symlink(src.as_ref(), dst.as_ref())\n }\n "}, {"sha": "5077e2e28d18b7ccb4ec96f3851119fd4abf8c69", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -3,9 +3,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fs;\n+use crate::io;\n use crate::os::raw;\n use crate::sys;\n-use crate::io;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// Raw file descriptors.\n@@ -83,30 +83,42 @@ impl IntoRawFd for fs::File {\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdin {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdout {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stderr {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StdinLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StdoutLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StderrLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO\n+    }\n }"}, {"sha": "fa8670b4aecac0caa0c06b0da07f2989385b4322", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -4,10 +4,10 @@\n \n use crate::ffi::OsStr;\n use crate::io;\n-use crate::os::unix::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n use crate::process;\n use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n /// Unix-specific extensions to the [`process::Command`] builder.\n ///\n@@ -56,7 +56,8 @@ pub trait CommandExt {\n     /// locations may not appear where intended.\n     #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n     unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n \n     /// Schedules a closure to be run just before the `exec` function is\n     /// invoked.\n@@ -68,7 +69,8 @@ pub trait CommandExt {\n     #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n     #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n     fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n     {\n         unsafe { self.pre_exec(f) }\n     }\n@@ -111,7 +113,8 @@ pub trait CommandExt {\n     /// default executable path.\n     #[unstable(feature = \"process_set_argv0\", issue = \"66510\")]\n     fn arg0<S>(&mut self, arg: S) -> &mut process::Command\n-        where S: AsRef<OsStr>;\n+    where\n+        S: AsRef<OsStr>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -127,7 +130,8 @@ impl CommandExt for process::Command {\n     }\n \n     unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n     {\n         self.as_inner_mut().pre_exec(Box::new(f));\n         self\n@@ -138,7 +142,8 @@ impl CommandExt for process::Command {\n     }\n \n     fn arg0<S>(&mut self, arg: S) -> &mut process::Command\n-        where S: AsRef<OsStr>\n+    where\n+        S: AsRef<OsStr>,\n     {\n         self.as_inner_mut().set_arg_0(arg.as_ref());\n         self"}, {"sha": "d81368a18b4522018bfdfcaff7c5d4c504eea4bc", "filename": "src/libstd/sys/unix/ext/raw.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,23 +1,28 @@\n //! Unix-specific primitives available on all unix platforms\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type uid_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type gid_t = u32;\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type pid_t = i32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type uid_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type gid_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type pid_t = i32;\n \n #[doc(inline)]\n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub use crate::sys::platform::raw::pthread_t;\n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use crate::sys::platform::raw::{dev_t, ino_t, mode_t, nlink_t, off_t, blksize_t};\n+pub use crate::sys::platform::raw::{blkcnt_t, time_t};\n #[doc(inline)]\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use crate::sys::platform::raw::{blkcnt_t, time_t};\n+pub use crate::sys::platform::raw::{blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t};"}, {"sha": "dfb9307daea9fafd363acda4e8e15b0a9ca183e2", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -10,25 +10,34 @@\n // fallback implementation to use as well.\n //\n // Due to rust-lang/rust#18804, make sure this is not generic!\n-#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"redox\",\n-          target_os = \"emscripten\"))]\n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+#[cfg(any(\n+    target_os = \"linux\",\n+    target_os = \"fuchsia\",\n+    target_os = \"redox\",\n+    target_os = \"emscripten\"\n+))]\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::mem;\n     use crate::sys_common::thread_local::register_dtor_fallback;\n \n-    extern {\n+    extern \"C\" {\n         #[linkage = \"extern_weak\"]\n         static __dso_handle: *mut u8;\n         #[linkage = \"extern_weak\"]\n         static __cxa_thread_atexit_impl: *const libc::c_void;\n     }\n     if !__cxa_thread_atexit_impl.is_null() {\n-        type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n-                                  arg: *mut u8,\n-                                  dso_handle: *mut u8) -> libc::c_int;\n-        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n-            (dtor, t, &__dso_handle as *const _ as *mut _);\n-        return\n+        type F = unsafe extern \"C\" fn(\n+            dtor: unsafe extern \"C\" fn(*mut u8),\n+            arg: *mut u8,\n+            dso_handle: *mut u8,\n+        ) -> libc::c_int;\n+        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)(\n+            dtor,\n+            t,\n+            &__dso_handle as *const _ as *mut _,\n+        );\n+        return;\n     }\n     register_dtor_fallback(t, dtor);\n }\n@@ -44,7 +53,7 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n // thread. thread_local dtors are pushed to the DTOR list without calling\n // _tlv_atexit.\n #[cfg(target_os = \"macos\")]\n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::cell::Cell;\n     use crate::ptr;\n \n@@ -55,7 +64,7 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         REGISTERED.set(true);\n     }\n \n-    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+    type List = Vec<(*mut u8, unsafe extern \"C\" fn(*mut u8))>;\n \n     #[thread_local]\n     static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n@@ -64,15 +73,14 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         DTORS.set(Box::into_raw(v));\n     }\n \n-    extern {\n-        fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n-                       arg: *mut u8);\n+    extern \"C\" {\n+        fn _tlv_atexit(dtor: unsafe extern \"C\" fn(*mut u8), arg: *mut u8);\n     }\n \n     let list: &mut List = &mut *DTORS.get();\n     list.push((t, dtor));\n \n-    unsafe extern fn run_dtors(_: *mut u8) {\n+    unsafe extern \"C\" fn run_dtors(_: *mut u8) {\n         let mut ptr = DTORS.replace(ptr::null_mut());\n         while !ptr.is_null() {\n             let list = Box::from_raw(ptr);"}, {"sha": "53b50763fbf2ec2f4999f481829b101348a4c910", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 73, "deletions": 58, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n use crate::cmp;\n-use crate::io::{self, Read, Initializer, IoSlice, IoSliceMut};\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::cvt;\n@@ -35,7 +35,9 @@ impl FileDesc {\n         FileDesc { fd }\n     }\n \n-    pub fn raw(&self) -> c_int { self.fd }\n+    pub fn raw(&self) -> c_int {\n+        self.fd\n+    }\n \n     /// Extracts the actual file descriptor without closing it.\n     pub fn into_raw(self) -> c_int {\n@@ -46,18 +48,18 @@ impl FileDesc {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::read(self.fd,\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       cmp::min(buf.len(), max_len()))\n+            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::readv(self.fd,\n-                        bufs.as_ptr() as *const libc::iovec,\n-                        cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+            libc::readv(\n+                self.fd,\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -72,39 +74,44 @@ impl FileDesc {\n         use super::android::cvt_pread64;\n \n         #[cfg(not(target_os = \"android\"))]\n-        unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n-            #[cfg(target_os = \"linux\")]\n-            use libc::pread64;\n+        unsafe fn cvt_pread64(\n+            fd: c_int,\n+            buf: *mut c_void,\n+            count: usize,\n+            offset: i64,\n+        ) -> io::Result<isize> {\n             #[cfg(not(target_os = \"linux\"))]\n             use libc::pread as pread64;\n+            #[cfg(target_os = \"linux\")]\n+            use libc::pread64;\n             cvt(pread64(fd, buf, count, offset))\n         }\n \n         unsafe {\n-            cvt_pread64(self.fd,\n-                        buf.as_mut_ptr() as *mut c_void,\n-                        cmp::min(buf.len(), max_len()),\n-                        offset as i64)\n-                .map(|n| n as usize)\n+            cvt_pread64(\n+                self.fd,\n+                buf.as_mut_ptr() as *mut c_void,\n+                cmp::min(buf.len(), max_len()),\n+                offset as i64,\n+            )\n+            .map(|n| n as usize)\n         }\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::write(self.fd,\n-                        buf.as_ptr() as *const c_void,\n-                        cmp::min(buf.len(), max_len()))\n+            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::writev(self.fd,\n-                         bufs.as_ptr() as *const libc::iovec,\n-                         cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+            libc::writev(\n+                self.fd,\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -114,54 +121,61 @@ impl FileDesc {\n         use super::android::cvt_pwrite64;\n \n         #[cfg(not(target_os = \"android\"))]\n-        unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n-            #[cfg(target_os = \"linux\")]\n-            use libc::pwrite64;\n+        unsafe fn cvt_pwrite64(\n+            fd: c_int,\n+            buf: *const c_void,\n+            count: usize,\n+            offset: i64,\n+        ) -> io::Result<isize> {\n             #[cfg(not(target_os = \"linux\"))]\n             use libc::pwrite as pwrite64;\n+            #[cfg(target_os = \"linux\")]\n+            use libc::pwrite64;\n             cvt(pwrite64(fd, buf, count, offset))\n         }\n \n         unsafe {\n-            cvt_pwrite64(self.fd,\n-                         buf.as_ptr() as *const c_void,\n-                         cmp::min(buf.len(), max_len()),\n-                         offset as i64)\n-                .map(|n| n as usize)\n+            cvt_pwrite64(\n+                self.fd,\n+                buf.as_ptr() as *const c_void,\n+                cmp::min(buf.len(), max_len()),\n+                offset as i64,\n+            )\n+            .map(|n| n as usize)\n         }\n     }\n \n     #[cfg(target_os = \"linux\")]\n     pub fn get_cloexec(&self) -> io::Result<bool> {\n-        unsafe {\n-            Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0)\n-        }\n+        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n     }\n \n-    #[cfg(not(any(target_env = \"newlib\",\n-                  target_os = \"solaris\",\n-                  target_os = \"emscripten\",\n-                  target_os = \"fuchsia\",\n-                  target_os = \"l4re\",\n-                  target_os = \"linux\",\n-                  target_os = \"haiku\",\n-                  target_os = \"redox\")))]\n+    #[cfg(not(any(\n+        target_env = \"newlib\",\n+        target_os = \"solaris\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"l4re\",\n+        target_os = \"linux\",\n+        target_os = \"haiku\",\n+        target_os = \"redox\"\n+    )))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             cvt(libc::ioctl(self.fd, libc::FIOCLEX))?;\n             Ok(())\n         }\n     }\n-    #[cfg(any(target_env = \"newlib\",\n-              target_os = \"solaris\",\n-              target_os = \"emscripten\",\n-              target_os = \"fuchsia\",\n-              target_os = \"l4re\",\n-              target_os = \"linux\",\n-              target_os = \"haiku\",\n-              target_os = \"redox\"))]\n+    #[cfg(any(\n+        target_env = \"newlib\",\n+        target_os = \"solaris\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"l4re\",\n+        target_os = \"linux\",\n+        target_os = \"haiku\",\n+        target_os = \"redox\"\n+    ))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n             let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n@@ -216,16 +230,15 @@ impl FileDesc {\n         // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n         #[cfg(any(target_os = \"android\", target_os = \"haiku\"))]\n         use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n-        #[cfg(not(any(target_os = \"android\", target_os=\"haiku\")))]\n+        #[cfg(not(any(target_os = \"android\", target_os = \"haiku\")))]\n         use libc::F_DUPFD_CLOEXEC;\n \n         let make_filedesc = |fd| {\n             let fd = FileDesc::new(fd);\n             fd.set_cloexec()?;\n             Ok(fd)\n         };\n-        static TRY_CLOEXEC: AtomicBool =\n-            AtomicBool::new(!cfg!(target_os = \"android\"));\n+        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(!cfg!(target_os = \"android\"));\n         let fd = self.raw();\n         if TRY_CLOEXEC.load(Ordering::Relaxed) {\n             match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n@@ -237,7 +250,7 @@ impl FileDesc {\n                         make_filedesc(fd)?\n                     } else {\n                         FileDesc::new(fd)\n-                    })\n+                    });\n                 }\n                 Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n                     TRY_CLOEXEC.store(false, Ordering::Relaxed);\n@@ -261,7 +274,9 @@ impl<'a> Read for &'a FileDesc {\n }\n \n impl AsInner<c_int> for FileDesc {\n-    fn as_inner(&self) -> &c_int { &self.fd }\n+    fn as_inner(&self) -> &c_int {\n+        &self.fd\n+    }\n }\n \n impl Drop for FileDesc {"}, {"sha": "b4a64e93c842b606d31fc978bf4698cda8b39d6b", "filename": "src/libstd/sys/unix/io.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n use crate::marker::PhantomData;\n use crate::slice;\n \n-use libc::{iovec, c_void};\n+use libc::{c_void, iovec};\n \n #[repr(transparent)]\n pub struct IoSlice<'a> {\n@@ -13,10 +13,7 @@ impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice {\n-            vec: iovec {\n-                iov_base: buf.as_ptr() as *mut u8 as *mut c_void,\n-                iov_len: buf.len()\n-            },\n+            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n             _p: PhantomData,\n         }\n     }\n@@ -35,9 +32,7 @@ impl<'a> IoSlice<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }\n \n@@ -51,10 +46,7 @@ impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut {\n-            vec: iovec {\n-                iov_base: buf.as_mut_ptr() as *mut c_void,\n-                iov_len: buf.len()\n-            },\n+            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n             _p: PhantomData,\n         }\n     }\n@@ -73,15 +65,11 @@ impl<'a> IoSliceMut<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n \n     #[inline]\n     pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }"}, {"sha": "c6e4f5693ed5af4ac48eaec26ed367b46debd76c", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,16 +1,18 @@\n macro_rules! unimpl {\n-    () => (return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));)\n+    () => {\n+        return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));\n+    };\n }\n \n pub mod net {\n     #![allow(warnings)]\n+    use crate::convert::TryFrom;\n     use crate::fmt;\n     use crate::io::{self, IoSlice, IoSliceMut};\n-    use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n-    use crate::sys_common::{AsInner, FromInner, IntoInner};\n+    use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n     use crate::sys::fd::FileDesc;\n+    use crate::sys_common::{AsInner, FromInner, IntoInner};\n     use crate::time::Duration;\n-    use crate::convert::TryFrom;\n \n     #[allow(unused_extern_crates)]\n     pub extern crate libc as netc;\n@@ -33,8 +35,11 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn accept(&self, _: *mut libc::sockaddr, _: *mut libc::socklen_t)\n-                  -> io::Result<Socket> {\n+        pub fn accept(\n+            &self,\n+            _: *mut libc::sockaddr,\n+            _: *mut libc::socklen_t,\n+        ) -> io::Result<Socket> {\n             unimpl!();\n         }\n \n@@ -100,15 +105,21 @@ pub mod net {\n     }\n \n     impl AsInner<libc::c_int> for Socket {\n-        fn as_inner(&self) -> &libc::c_int { self.0.as_inner() }\n+        fn as_inner(&self) -> &libc::c_int {\n+            self.0.as_inner()\n+        }\n     }\n \n     impl FromInner<libc::c_int> for Socket {\n-        fn from_inner(fd: libc::c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+        fn from_inner(fd: libc::c_int) -> Socket {\n+            Socket(FileDesc::new(fd))\n+        }\n     }\n \n     impl IntoInner<libc::c_int> for Socket {\n-        fn into_inner(self) -> libc::c_int { self.0.into_raw() }\n+        fn into_inner(self) -> libc::c_int {\n+            self.0.into_raw()\n+        }\n     }\n \n     pub struct TcpStream {\n@@ -124,9 +135,13 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn socket(&self) -> &Socket { &self.inner }\n+        pub fn socket(&self) -> &Socket {\n+            &self.inner\n+        }\n \n-        pub fn into_socket(self) -> Socket { self.inner }\n+        pub fn into_socket(self) -> Socket {\n+            self.inner\n+        }\n \n         pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n             unimpl!();\n@@ -226,9 +241,13 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn socket(&self) -> &Socket { &self.inner }\n+        pub fn socket(&self) -> &Socket {\n+            &self.inner\n+        }\n \n-        pub fn into_socket(self) -> Socket { self.inner }\n+        pub fn into_socket(self) -> Socket {\n+            self.inner\n+        }\n \n         pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n             unimpl!();\n@@ -288,9 +307,13 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn socket(&self) -> &Socket { &self.inner }\n+        pub fn socket(&self) -> &Socket {\n+            &self.inner\n+        }\n \n-        pub fn into_socket(self) -> Socket { self.inner }\n+        pub fn into_socket(self) -> Socket {\n+            self.inner\n+        }\n \n         pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n             unimpl!();\n@@ -364,24 +387,20 @@ pub mod net {\n             unimpl!();\n         }\n \n-        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                             -> io::Result<()> {\n-                                 unimpl!();\n+        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n+            unimpl!();\n         }\n \n-        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                             -> io::Result<()> {\n-                                 unimpl!();\n+        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n+            unimpl!();\n         }\n \n-        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                              -> io::Result<()> {\n-                                  unimpl!();\n+        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n+            unimpl!();\n         }\n \n-        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                              -> io::Result<()> {\n-                                  unimpl!();\n+        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n+            unimpl!();\n         }\n \n         pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n@@ -450,7 +469,6 @@ pub mod net {\n     unsafe impl Sync for LookupHost {}\n     unsafe impl Send for LookupHost {}\n \n-\n     impl TryFrom<&str> for LookupHost {\n         type Error = io::Error;\n "}, {"sha": "a9273ea676cb3949012c4c4cc987ae5dbc0ea7f4", "filename": "src/libstd/sys/unix/memchr.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,32 +6,27 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n         libc::memchr(\n             haystack.as_ptr() as *const libc::c_void,\n             needle as libc::c_int,\n-            haystack.len())\n+            haystack.len(),\n+        )\n     };\n-    if p.is_null() {\n-        None\n-    } else {\n-        Some(p as usize - (haystack.as_ptr() as usize))\n-    }\n+    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n }\n \n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-\n     #[cfg(target_os = \"linux\")]\n     fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n         // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n-        if haystack.is_empty() {return None}\n+        if haystack.is_empty() {\n+            return None;\n+        }\n         let p = unsafe {\n             libc::memrchr(\n                 haystack.as_ptr() as *const libc::c_void,\n                 needle as libc::c_int,\n-                haystack.len())\n+                haystack.len(),\n+            )\n         };\n-        if p.is_null() {\n-            None\n-        } else {\n-            Some(p as usize - (haystack.as_ptr() as usize))\n-        }\n+        if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n     }\n \n     #[cfg(not(target_os = \"linux\"))]"}, {"sha": "946b2b9d8decfa1ccc04c57738b7c5756242112e", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 53, "deletions": 59, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,13 +1,13 @@\n+use crate::cmp;\n use crate::ffi::CStr;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n-use crate::net::{SocketAddr, Shutdown};\n+use crate::net::{Shutdown, SocketAddr};\n use crate::str;\n use crate::sys::fd::FileDesc;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::{Duration, Instant};\n-use crate::cmp;\n \n use libc::{c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n \n@@ -42,23 +42,23 @@ pub fn init() {}\n \n pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 {\n-        return Ok(())\n+        return Ok(());\n     }\n \n     // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n     on_resolver_failure();\n \n     if err == EAI_SYSTEM {\n-        return Err(io::Error::last_os_error())\n+        return Err(io::Error::last_os_error());\n     }\n \n     let detail = unsafe {\n-        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap()\n-            .to_owned()\n+        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n     };\n-    Err(io::Error::new(io::ErrorKind::Other,\n-                       &format!(\"failed to lookup address information: {}\",\n-                                detail)[..]))\n+    Err(io::Error::new(\n+        io::ErrorKind::Other,\n+        &format!(\"failed to lookup address information: {}\", detail)[..],\n+    ))\n }\n \n impl Socket {\n@@ -106,7 +106,7 @@ impl Socket {\n                     Ok(_) => {\n                         return Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))));\n                     }\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {},\n+                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n                     Err(e) => return Err(e),\n                 }\n             }\n@@ -135,15 +135,13 @@ impl Socket {\n             Err(e) => return Err(e),\n         }\n \n-        let mut pollfd = libc::pollfd {\n-            fd: self.0.raw(),\n-            events: libc::POLLOUT,\n-            revents: 0,\n-        };\n+        let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"cannot set a 0 duration timeout\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"cannot set a 0 duration timeout\",\n+            ));\n         }\n \n         let start = Instant::now();\n@@ -155,7 +153,8 @@ impl Socket {\n             }\n \n             let timeout = timeout - elapsed;\n-            let mut timeout = timeout.as_secs()\n+            let mut timeout = timeout\n+                .as_secs()\n                 .saturating_mul(1_000)\n                 .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n             if timeout == 0 {\n@@ -176,10 +175,9 @@ impl Socket {\n                     // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n                     // for POLLHUP rather than read readiness\n                     if pollfd.revents & libc::POLLHUP != 0 {\n-                        let e = self.take_error()?\n-                            .unwrap_or_else(|| {\n-                                io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n-                            });\n+                        let e = self.take_error()?.unwrap_or_else(|| {\n+                            io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n+                        });\n                         return Err(e);\n                     }\n \n@@ -189,8 +187,7 @@ impl Socket {\n         }\n     }\n \n-    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n-                  -> io::Result<Socket> {\n+    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n         // Unfortunately the only known way right now to accept a socket and\n         // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n         // Linux. This was added in 2.6.28, however, and because we support\n@@ -204,19 +201,15 @@ impl Socket {\n                     flags: c_int\n                 ) -> c_int\n             }\n-            let res = cvt_r(|| unsafe {\n-                accept4(self.0.raw(), storage, len, SOCK_CLOEXEC)\n-            });\n+            let res = cvt_r(|| unsafe { accept4(self.0.raw(), storage, len, SOCK_CLOEXEC) });\n             match res {\n                 Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n                 Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}\n                 Err(e) => return Err(e),\n             }\n         }\n \n-        let fd = cvt_r(|| unsafe {\n-            libc::accept(self.0.raw(), storage, len)\n-        })?;\n+        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n         let fd = FileDesc::new(fd);\n         fd.set_cloexec()?;\n         Ok(Socket(fd))\n@@ -228,10 +221,7 @@ impl Socket {\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::recv(self.0.raw(),\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       buf.len(),\n-                       flags)\n+            libc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n         })?;\n         Ok(ret as usize)\n     }\n@@ -248,18 +238,23 @@ impl Socket {\n         self.0.read_vectored(bufs)\n     }\n \n-    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n-                            -> io::Result<(usize, SocketAddr)> {\n+    fn recv_from_with_flags(\n+        &self,\n+        buf: &mut [u8],\n+        flags: c_int,\n+    ) -> io::Result<(usize, SocketAddr)> {\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n \n         let n = cvt(unsafe {\n-            libc::recvfrom(self.0.raw(),\n-                        buf.as_mut_ptr() as *mut c_void,\n-                        buf.len(),\n-                        flags,\n-                        &mut storage as *mut _ as *mut _,\n-                        &mut addrlen)\n+            libc::recvfrom(\n+                self.0.raw(),\n+                buf.as_mut_ptr() as *mut c_void,\n+                buf.len(),\n+                flags,\n+                &mut storage as *mut _ as *mut _,\n+                &mut addrlen,\n+            )\n         })?;\n         Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n     }\n@@ -284,8 +279,10 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                              \"cannot set a 0 duration timeout\"));\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::InvalidInput,\n+                        \"cannot set a 0 duration timeout\",\n+                    ));\n                 }\n \n                 let secs = if dur.as_secs() > libc::time_t::max_value() as u64 {\n@@ -302,12 +299,7 @@ impl Socket {\n                 }\n                 timeout\n             }\n-            None => {\n-                libc::timeval {\n-                    tv_sec: 0,\n-                    tv_usec: 0,\n-                }\n-            }\n+            None => libc::timeval { tv_sec: 0, tv_usec: 0 },\n         };\n         setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n     }\n@@ -349,24 +341,26 @@ impl Socket {\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n-        if raw == 0 {\n-            Ok(None)\n-        } else {\n-            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n-        }\n+        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n     }\n }\n \n impl AsInner<c_int> for Socket {\n-    fn as_inner(&self) -> &c_int { self.0.as_inner() }\n+    fn as_inner(&self) -> &c_int {\n+        self.0.as_inner()\n+    }\n }\n \n impl FromInner<c_int> for Socket {\n-    fn from_inner(fd: c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+    fn from_inner(fd: c_int) -> Socket {\n+        Socket(FileDesc::new(fd))\n+    }\n }\n \n impl IntoInner<c_int> for Socket {\n-    fn into_inner(self) -> c_int { self.0.into_raw() }\n+    fn into_inner(self) -> c_int {\n+        self.0.into_raw()\n+    }\n }\n \n // In versions of glibc prior to 2.26, there's a bug where the DNS resolver"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/unix/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "77fefef8a1802d9425e47764ea3b1c7797a34fe0", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -22,24 +22,23 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n     // 2.6.27, however, and because we support 2.6.18 we must detect this\n     // support dynamically.\n-    if cfg!(any(target_os = \"dragonfly\",\n-                target_os = \"freebsd\",\n-                target_os = \"linux\",\n-                target_os = \"netbsd\",\n-                target_os = \"openbsd\",\n-                target_os = \"redox\")) &&\n-       !INVALID.load(Ordering::SeqCst)\n+    if cfg!(any(\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"redox\"\n+    )) && !INVALID.load(Ordering::SeqCst)\n     {\n-\n         // Note that despite calling a glibc function here we may still\n         // get ENOSYS. Glibc has `pipe2` since 2.9 and doesn't try to\n         // emulate on older kernels, so if you happen to be running on\n         // an older kernel you may see `pipe2` as a symbol but still not\n         // see the syscall.\n         match cvt(unsafe { pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) }) {\n             Ok(_) => {\n-                return Ok((AnonPipe(FileDesc::new(fds[0])),\n-                            AnonPipe(FileDesc::new(fds[1]))));\n+                return Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))));\n             }\n             Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {\n                 INVALID.store(true, Ordering::SeqCst);\n@@ -73,15 +72,15 @@ impl AnonPipe {\n         self.0.write_vectored(bufs)\n     }\n \n-    pub fn fd(&self) -> &FileDesc { &self.0 }\n-    pub fn into_fd(self) -> FileDesc { self.0 }\n+    pub fn fd(&self) -> &FileDesc {\n+        &self.0\n+    }\n+    pub fn into_fd(self) -> FileDesc {\n+        self.0\n+    }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             v1: &mut Vec<u8>,\n-             p2: AnonPipe,\n-             v2: &mut Vec<u8>) -> io::Result<()> {\n-\n+pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n     // Set both pipes into nonblocking mode as we're gonna be reading from both\n     // in the `select` loop below, and we wouldn't want one to block the other!\n     let p1 = p1.into_fd();\n@@ -117,8 +116,9 @@ pub fn read2(p1: AnonPipe,\n         match fd.read_to_end(dst) {\n             Ok(_) => Ok(true),\n             Err(e) => {\n-                if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n-                   e.raw_os_error() == Some(libc::EAGAIN) {\n+                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n+                    || e.raw_os_error() == Some(libc::EAGAIN)\n+                {\n                     Ok(false)\n                 } else {\n                     Err(e)"}, {"sha": "c9109b0c9d4d7b17a5fb1eae1d4baa5539065912", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 22, "deletions": 42, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,19 +1,19 @@\n use crate::os::unix::prelude::*;\n \n-use crate::ffi::{OsString, OsStr, CString, CStr};\n+use crate::collections::BTreeMap;\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::ptr;\n use crate::sys::fd::FileDesc;\n use crate::sys::fs::File;\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys_common::process::CommandEnv;\n-use crate::collections::BTreeMap;\n \n #[cfg(not(target_os = \"fuchsia\"))]\n use crate::sys::fs::OpenOptions;\n \n-use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n+use libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n \n cfg_if::cfg_if! {\n     if #[cfg(target_os = \"fuchsia\")] {\n@@ -204,10 +204,7 @@ impl Command {\n         &mut self.closures\n     }\n \n-    pub unsafe fn pre_exec(\n-        &mut self,\n-        f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n-    ) {\n+    pub unsafe fn pre_exec(&mut self, f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n         self.closures.push(f);\n     }\n \n@@ -236,26 +233,21 @@ impl Command {\n         self.env.have_changed_path()\n     }\n \n-    pub fn setup_io(&self, default: Stdio, needs_stdin: bool)\n-                -> io::Result<(StdioPipes, ChildPipes)> {\n+    pub fn setup_io(\n+        &self,\n+        default: Stdio,\n+        needs_stdin: bool,\n+    ) -> io::Result<(StdioPipes, ChildPipes)> {\n         let null = Stdio::Null;\n-        let default_stdin = if needs_stdin {&default} else {&null};\n+        let default_stdin = if needs_stdin { &default } else { &null };\n         let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n         let stdout = self.stdout.as_ref().unwrap_or(&default);\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n         let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n         let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n         let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n-        let ours = StdioPipes {\n-            stdin: our_stdin,\n-            stdout: our_stdout,\n-            stderr: our_stderr,\n-        };\n-        let theirs = ChildPipes {\n-            stdin: their_stdin,\n-            stdout: their_stdout,\n-            stderr: their_stderr,\n-        };\n+        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n+        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n         Ok((ours, theirs))\n     }\n }\n@@ -270,21 +262,21 @@ fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n // Helper type to manage ownership of the strings within a C-style array.\n pub struct CStringArray {\n     items: Vec<CString>,\n-    ptrs: Vec<*const c_char>\n+    ptrs: Vec<*const c_char>,\n }\n \n impl CStringArray {\n     pub fn with_capacity(capacity: usize) -> Self {\n         let mut result = CStringArray {\n             items: Vec::with_capacity(capacity),\n-            ptrs: Vec::with_capacity(capacity+1)\n+            ptrs: Vec::with_capacity(capacity + 1),\n         };\n         result.ptrs.push(ptr::null());\n         result\n     }\n     pub fn push(&mut self, item: CString) {\n         let l = self.ptrs.len();\n-        self.ptrs[l-1] = item.as_ptr();\n+        self.ptrs[l - 1] = item.as_ptr();\n         self.ptrs.push(ptr::null());\n         self.items.push(item);\n     }\n@@ -315,12 +307,9 @@ fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStr\n }\n \n impl Stdio {\n-    pub fn to_child_stdio(&self, readable: bool)\n-                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n         match *self {\n-            Stdio::Inherit => {\n-                Ok((ChildStdio::Inherit, None))\n-            },\n+            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n \n             // Make sure that the source descriptors are not an stdio\n             // descriptor, otherwise the order which we set the child's\n@@ -339,11 +328,7 @@ impl Stdio {\n \n             Stdio::MakePipe => {\n                 let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if readable {\n-                    (writer, reader)\n-                } else {\n-                    (reader, writer)\n-                };\n+                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                 Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n             }\n \n@@ -352,17 +337,13 @@ impl Stdio {\n                 let mut opts = OpenOptions::new();\n                 opts.read(readable);\n                 opts.write(!readable);\n-                let path = unsafe {\n-                    CStr::from_ptr(DEV_NULL.as_ptr() as *const _)\n-                };\n+                let path = unsafe { CStr::from_ptr(DEV_NULL.as_ptr() as *const _) };\n                 let fd = File::open_c(&path, &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n \n             #[cfg(target_os = \"fuchsia\")]\n-            Stdio::Null => {\n-                Ok((ChildStdio::Null, None))\n-            }\n+            Stdio::Null => Ok((ChildStdio::Null, None)),\n         }\n     }\n }\n@@ -430,7 +411,7 @@ mod tests {\n                 Ok(t) => t,\n                 Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n             }\n-        }\n+        };\n     }\n \n     // See #14232 for more information, but it appears that signal delivery to a\n@@ -461,8 +442,7 @@ mod tests {\n             let stdin_write = pipes.stdin.take().unwrap();\n             let stdout_read = pipes.stdout.take().unwrap();\n \n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(),\n-                                         ptr::null_mut())));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(), ptr::null_mut())));\n \n             t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n             // We need to wait until SIGINT is definitely delivered. The"}, {"sha": "f0bd1cdfed52f0a2c250aeffb44284d31dda32cc", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,11 +1,11 @@\n use crate::convert::TryInto;\n-use crate::io;\n use crate::fmt;\n+use crate::io;\n use crate::mem;\n use crate::ptr;\n \n-use crate::sys::process::zircon::{Handle, zx_handle_t};\n use crate::sys::process::process_common::*;\n+use crate::sys::process::zircon::{zx_handle_t, Handle};\n \n use libc::{c_int, size_t};\n \n@@ -14,13 +14,18 @@ use libc::{c_int, size_t};\n ////////////////////////////////////////////////////////////////////////////////\n \n impl Command {\n-    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n-                 -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        default: Stdio,\n+        needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"nul byte found in provided data\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"nul byte found in provided data\",\n+            ));\n         }\n \n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n@@ -32,21 +37,23 @@ impl Command {\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         if self.saw_nul() {\n-            return io::Error::new(io::ErrorKind::InvalidInput,\n-                                  \"nul byte found in provided data\")\n+            return io::Error::new(io::ErrorKind::InvalidInput, \"nul byte found in provided data\");\n         }\n \n         match self.setup_io(default, true) {\n             Ok((_, _)) => {\n                 // FIXME: This is tough because we don't support the exec syscalls\n                 unimplemented!();\n-            },\n+            }\n             Err(e) => e,\n         }\n     }\n \n-    unsafe fn do_exec(&mut self, stdio: ChildPipes, maybe_envp: Option<&CStringArray>)\n-                      -> io::Result<zx_handle_t> {\n+    unsafe fn do_exec(\n+        &mut self,\n+        stdio: ChildPipes,\n+        maybe_envp: Option<&CStringArray>,\n+    ) -> io::Result<zx_handle_t> {\n         use crate::sys::process::zircon::*;\n \n         let envp = match maybe_envp {\n@@ -108,10 +115,15 @@ impl Command {\n         let mut process_handle: zx_handle_t = 0;\n         zx_cvt(fdio_spawn_etc(\n             ZX_HANDLE_INVALID,\n-            FDIO_SPAWN_CLONE_JOB | FDIO_SPAWN_CLONE_LDSVC | FDIO_SPAWN_CLONE_NAMESPACE\n-            | FDIO_SPAWN_CLONE_ENVIRON,  // this is ignored when envp is non-null\n-            self.get_program().as_ptr(), self.get_argv().as_ptr(), envp,\n-            actions.len() as size_t, actions.as_ptr(),\n+            FDIO_SPAWN_CLONE_JOB\n+                | FDIO_SPAWN_CLONE_LDSVC\n+                | FDIO_SPAWN_CLONE_NAMESPACE\n+                | FDIO_SPAWN_CLONE_ENVIRON, // this is ignored when envp is non-null\n+            self.get_program().as_ptr(),\n+            self.get_argv().as_ptr(),\n+            envp,\n+            actions.len() as size_t,\n+            actions.as_ptr(),\n             &mut process_handle,\n             ptr::null_mut(),\n         ))?;\n@@ -137,7 +149,9 @@ impl Process {\n     pub fn kill(&mut self) -> io::Result<()> {\n         use crate::sys::process::zircon::*;\n \n-        unsafe { zx_cvt(zx_task_kill(self.handle.raw()))?; }\n+        unsafe {\n+            zx_cvt(zx_task_kill(self.handle.raw()))?;\n+        }\n \n         Ok(())\n     }\n@@ -151,16 +165,26 @@ impl Process {\n         let mut avail: size_t = 0;\n \n         unsafe {\n-            zx_cvt(zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED,\n-                                      ZX_TIME_INFINITE, ptr::null_mut()))?;\n-            zx_cvt(zx_object_get_info(self.handle.raw(), ZX_INFO_PROCESS,\n-                                      &mut proc_info as *mut _ as *mut libc::c_void,\n-                                      mem::size_of::<zx_info_process_t>(), &mut actual,\n-                                      &mut avail))?;\n+            zx_cvt(zx_object_wait_one(\n+                self.handle.raw(),\n+                ZX_TASK_TERMINATED,\n+                ZX_TIME_INFINITE,\n+                ptr::null_mut(),\n+            ))?;\n+            zx_cvt(zx_object_get_info(\n+                self.handle.raw(),\n+                ZX_INFO_PROCESS,\n+                &mut proc_info as *mut _ as *mut libc::c_void,\n+                mem::size_of::<zx_info_process_t>(),\n+                &mut actual,\n+                &mut avail,\n+            ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidData,\n-                                      \"Failed to get exit status of process\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidData,\n+                \"Failed to get exit status of process\",\n+            ));\n         }\n         Ok(ExitStatus(proc_info.return_code))\n     }\n@@ -174,23 +198,31 @@ impl Process {\n         let mut avail: size_t = 0;\n \n         unsafe {\n-            let status = zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED,\n-                                            0, ptr::null_mut());\n+            let status =\n+                zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED, 0, ptr::null_mut());\n             match status {\n-                0 => { }, // Success\n+                0 => {} // Success\n                 x if x == ERR_TIMED_OUT => {\n                     return Ok(None);\n-                },\n-                _ => { panic!(\"Failed to wait on process handle: {}\", status); },\n+                }\n+                _ => {\n+                    panic!(\"Failed to wait on process handle: {}\", status);\n+                }\n             }\n-            zx_cvt(zx_object_get_info(self.handle.raw(), ZX_INFO_PROCESS,\n-                                      &mut proc_info as *mut _ as *mut libc::c_void,\n-                                      mem::size_of::<zx_info_process_t>(), &mut actual,\n-                                      &mut avail))?;\n+            zx_cvt(zx_object_get_info(\n+                self.handle.raw(),\n+                ZX_INFO_PROCESS,\n+                &mut proc_info as *mut _ as *mut libc::c_void,\n+                mem::size_of::<zx_info_process_t>(),\n+                &mut actual,\n+                &mut avail,\n+            ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidData,\n-                                      \"Failed to get exit status of process\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidData,\n+                \"Failed to get exit status of process\",\n+            ));\n         }\n         Ok(Some(ExitStatus(proc_info.return_code)))\n     }"}, {"sha": "750b8f0762ae51ba72e2c97a92256801ca00b046", "filename": "src/libstd/sys/unix/process/zircon.rs", "status": "modified", "additions": 111, "deletions": 62, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,8 +1,8 @@\n #![allow(non_camel_case_types, unused)]\n \n use crate::convert::TryInto;\n-use crate::io;\n use crate::i64;\n+use crate::io;\n use crate::mem::MaybeUninit;\n use crate::os::raw::c_char;\n \n@@ -16,27 +16,26 @@ pub type zx_status_t = i32;\n pub const ZX_HANDLE_INVALID: zx_handle_t = 0;\n \n pub type zx_time_t = i64;\n-pub const ZX_TIME_INFINITE : zx_time_t = i64::MAX;\n+pub const ZX_TIME_INFINITE: zx_time_t = i64::MAX;\n \n pub type zx_signals_t = u32;\n \n-pub const ZX_OBJECT_SIGNAL_3         : zx_signals_t = 1 << 3;\n+pub const ZX_OBJECT_SIGNAL_3: zx_signals_t = 1 << 3;\n \n-pub const ZX_TASK_TERMINATED        : zx_signals_t = ZX_OBJECT_SIGNAL_3;\n+pub const ZX_TASK_TERMINATED: zx_signals_t = ZX_OBJECT_SIGNAL_3;\n \n-pub const ZX_RIGHT_SAME_RIGHTS  : zx_rights_t = 1 << 31;\n+pub const ZX_RIGHT_SAME_RIGHTS: zx_rights_t = 1 << 31;\n \n pub type zx_object_info_topic_t = u32;\n \n-pub const ZX_INFO_PROCESS         : zx_object_info_topic_t = 3;\n+pub const ZX_INFO_PROCESS: zx_object_info_topic_t = 3;\n \n-pub fn zx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<zx_status_t>+Copy {\n+pub fn zx_cvt<T>(t: T) -> io::Result<T>\n+where\n+    T: TryInto<zx_status_t> + Copy,\n+{\n     if let Ok(status) = TryInto::try_into(t) {\n-        if status < 0 {\n-            Err(io::Error::from_raw_os_error(status))\n-        } else {\n-            Ok(t)\n-        }\n+        if status < 0 { Err(io::Error::from_raw_os_error(status)) } else { Ok(t) }\n     } else {\n         Err(io::Error::last_os_error())\n     }\n@@ -49,9 +48,7 @@ pub struct Handle {\n \n impl Handle {\n     pub fn new(raw: zx_handle_t) -> Handle {\n-        Handle {\n-            raw,\n-        }\n+        Handle { raw }\n     }\n \n     pub fn raw(&self) -> zx_handle_t {\n@@ -61,7 +58,9 @@ impl Handle {\n \n impl Drop for Handle {\n     fn drop(&mut self) {\n-        unsafe { zx_cvt(zx_handle_close(self.raw)).expect(\"Failed to close zx_handle_t\"); }\n+        unsafe {\n+            zx_cvt(zx_handle_close(self.raw)).expect(\"Failed to close zx_handle_t\");\n+        }\n     }\n }\n \n@@ -75,22 +74,34 @@ pub struct zx_info_process_t {\n     pub debugger_attached: bool,\n }\n \n-extern {\n+extern \"C\" {\n     pub fn zx_job_default() -> zx_handle_t;\n \n     pub fn zx_task_kill(handle: zx_handle_t) -> zx_status_t;\n \n     pub fn zx_handle_close(handle: zx_handle_t) -> zx_status_t;\n \n-    pub fn zx_handle_duplicate(handle: zx_handle_t, rights: zx_rights_t,\n-                               out: *const zx_handle_t) -> zx_handle_t;\n-\n-    pub fn zx_object_wait_one(handle: zx_handle_t, signals: zx_signals_t, timeout: zx_time_t,\n-                              pending: *mut zx_signals_t) -> zx_status_t;\n-\n-    pub fn zx_object_get_info(handle: zx_handle_t, topic: u32, buffer: *mut c_void,\n-                              buffer_size: size_t, actual_size: *mut size_t,\n-                              avail: *mut size_t) -> zx_status_t;\n+    pub fn zx_handle_duplicate(\n+        handle: zx_handle_t,\n+        rights: zx_rights_t,\n+        out: *const zx_handle_t,\n+    ) -> zx_handle_t;\n+\n+    pub fn zx_object_wait_one(\n+        handle: zx_handle_t,\n+        signals: zx_signals_t,\n+        timeout: zx_time_t,\n+        pending: *mut zx_signals_t,\n+    ) -> zx_status_t;\n+\n+    pub fn zx_object_get_info(\n+        handle: zx_handle_t,\n+        topic: u32,\n+        buffer: *mut c_void,\n+        buffer_size: size_t,\n+        actual_size: *mut size_t,\n+        avail: *mut size_t,\n+    ) -> zx_status_t;\n }\n \n #[derive(Default)]\n@@ -103,11 +114,18 @@ pub struct fdio_spawn_action_t {\n     pub reserved1: u64,\n }\n \n-extern {\n-    pub fn fdio_spawn_etc(job: zx_handle_t, flags: u32, path: *const c_char,\n-                          argv: *const *const c_char, envp: *const *const c_char,\n-                          action_count: size_t, actions: *const fdio_spawn_action_t,\n-                          process: *mut zx_handle_t, err_msg: *mut c_char) -> zx_status_t;\n+extern \"C\" {\n+    pub fn fdio_spawn_etc(\n+        job: zx_handle_t,\n+        flags: u32,\n+        path: *const c_char,\n+        argv: *const *const c_char,\n+        envp: *const *const c_char,\n+        action_count: size_t,\n+        actions: *const fdio_spawn_action_t,\n+        process: *mut zx_handle_t,\n+        err_msg: *mut c_char,\n+    ) -> zx_status_t;\n \n     pub fn fdio_fd_clone(fd: c_int, out_handle: *mut zx_handle_t) -> zx_status_t;\n     pub fn fdio_fd_create(handle: zx_handle_t, fd: *mut c_int) -> zx_status_t;\n@@ -129,60 +147,74 @@ pub const FDIO_SPAWN_ACTION_TRANSFER_FD: u32 = 0x0002;\n \n // Errors\n \n-#[allow(unused)] pub const ERR_INTERNAL: zx_status_t = -1;\n+#[allow(unused)]\n+pub const ERR_INTERNAL: zx_status_t = -1;\n \n // ERR_NOT_SUPPORTED: The operation is not implemented, supported,\n // or enabled.\n-#[allow(unused)] pub const ERR_NOT_SUPPORTED: zx_status_t = -2;\n+#[allow(unused)]\n+pub const ERR_NOT_SUPPORTED: zx_status_t = -2;\n \n // ERR_NO_RESOURCES: The system was not able to allocate some resource\n // needed for the operation.\n-#[allow(unused)] pub const ERR_NO_RESOURCES: zx_status_t = -3;\n+#[allow(unused)]\n+pub const ERR_NO_RESOURCES: zx_status_t = -3;\n \n // ERR_NO_MEMORY: The system was not able to allocate memory needed\n // for the operation.\n-#[allow(unused)] pub const ERR_NO_MEMORY: zx_status_t = -4;\n+#[allow(unused)]\n+pub const ERR_NO_MEMORY: zx_status_t = -4;\n \n // ERR_CALL_FAILED: The second phase of zx_channel_call(; did not complete\n // successfully.\n-#[allow(unused)] pub const ERR_CALL_FAILED: zx_status_t = -5;\n+#[allow(unused)]\n+pub const ERR_CALL_FAILED: zx_status_t = -5;\n \n // ERR_INTERRUPTED_RETRY: The system call was interrupted, but should be\n // retried.  This should not be seen outside of the VDSO.\n-#[allow(unused)] pub const ERR_INTERRUPTED_RETRY: zx_status_t = -6;\n+#[allow(unused)]\n+pub const ERR_INTERRUPTED_RETRY: zx_status_t = -6;\n \n // ======= Parameter errors =======\n // ERR_INVALID_ARGS: an argument is invalid, ex. null pointer\n-#[allow(unused)] pub const ERR_INVALID_ARGS: zx_status_t = -10;\n+#[allow(unused)]\n+pub const ERR_INVALID_ARGS: zx_status_t = -10;\n \n // ERR_BAD_HANDLE: A specified handle value does not refer to a handle.\n-#[allow(unused)] pub const ERR_BAD_HANDLE: zx_status_t = -11;\n+#[allow(unused)]\n+pub const ERR_BAD_HANDLE: zx_status_t = -11;\n \n // ERR_WRONG_TYPE: The subject of the operation is the wrong type to\n // perform the operation.\n // Example: Attempting a message_read on a thread handle.\n-#[allow(unused)] pub const ERR_WRONG_TYPE: zx_status_t = -12;\n+#[allow(unused)]\n+pub const ERR_WRONG_TYPE: zx_status_t = -12;\n \n // ERR_BAD_SYSCALL: The specified syscall number is invalid.\n-#[allow(unused)] pub const ERR_BAD_SYSCALL: zx_status_t = -13;\n+#[allow(unused)]\n+pub const ERR_BAD_SYSCALL: zx_status_t = -13;\n \n // ERR_OUT_OF_RANGE: An argument is outside the valid range for this\n // operation.\n-#[allow(unused)] pub const ERR_OUT_OF_RANGE: zx_status_t = -14;\n+#[allow(unused)]\n+pub const ERR_OUT_OF_RANGE: zx_status_t = -14;\n \n // ERR_BUFFER_TOO_SMALL: A caller provided buffer is too small for\n // this operation.\n-#[allow(unused)] pub const ERR_BUFFER_TOO_SMALL: zx_status_t = -15;\n+#[allow(unused)]\n+pub const ERR_BUFFER_TOO_SMALL: zx_status_t = -15;\n \n // ======= Precondition or state errors =======\n // ERR_BAD_STATE: operation failed because the current state of the\n // object does not allow it, or a precondition of the operation is\n // not satisfied\n-#[allow(unused)] pub const ERR_BAD_STATE: zx_status_t = -20;\n+#[allow(unused)]\n+pub const ERR_BAD_STATE: zx_status_t = -20;\n \n // ERR_TIMED_OUT: The time limit for the operation elapsed before\n // the operation completed.\n-#[allow(unused)] pub const ERR_TIMED_OUT: zx_status_t = -21;\n+#[allow(unused)]\n+pub const ERR_TIMED_OUT: zx_status_t = -21;\n \n // ERR_SHOULD_WAIT: The operation cannot be performed currently but\n // potentially could succeed if the caller waits for a prerequisite\n@@ -192,67 +224,84 @@ pub const FDIO_SPAWN_ACTION_TRANSFER_FD: u32 = 0x0002;\n // messages waiting but has an open remote will return ERR_SHOULD_WAIT.\n // Attempting to read from a message pipe that has no messages waiting\n // and has a closed remote end will return ERR_REMOTE_CLOSED.\n-#[allow(unused)] pub const ERR_SHOULD_WAIT: zx_status_t = -22;\n+#[allow(unused)]\n+pub const ERR_SHOULD_WAIT: zx_status_t = -22;\n \n // ERR_CANCELED: The in-progress operation (e.g., a wait) has been\n // // canceled.\n-#[allow(unused)] pub const ERR_CANCELED: zx_status_t = -23;\n+#[allow(unused)]\n+pub const ERR_CANCELED: zx_status_t = -23;\n \n // ERR_PEER_CLOSED: The operation failed because the remote end\n // of the subject of the operation was closed.\n-#[allow(unused)] pub const ERR_PEER_CLOSED: zx_status_t = -24;\n+#[allow(unused)]\n+pub const ERR_PEER_CLOSED: zx_status_t = -24;\n \n // ERR_NOT_FOUND: The requested entity is not found.\n-#[allow(unused)] pub const ERR_NOT_FOUND: zx_status_t = -25;\n+#[allow(unused)]\n+pub const ERR_NOT_FOUND: zx_status_t = -25;\n \n // ERR_ALREADY_EXISTS: An object with the specified identifier\n // already exists.\n // Example: Attempting to create a file when a file already exists\n // with that name.\n-#[allow(unused)] pub const ERR_ALREADY_EXISTS: zx_status_t = -26;\n+#[allow(unused)]\n+pub const ERR_ALREADY_EXISTS: zx_status_t = -26;\n \n // ERR_ALREADY_BOUND: The operation failed because the named entity\n // is already owned or controlled by another entity. The operation\n // could succeed later if the current owner releases the entity.\n-#[allow(unused)] pub const ERR_ALREADY_BOUND: zx_status_t = -27;\n+#[allow(unused)]\n+pub const ERR_ALREADY_BOUND: zx_status_t = -27;\n \n // ERR_UNAVAILABLE: The subject of the operation is currently unable\n // to perform the operation.\n // Note: This is used when there's no direct way for the caller to\n // observe when the subject will be able to perform the operation\n // and should thus retry.\n-#[allow(unused)] pub const ERR_UNAVAILABLE: zx_status_t = -28;\n+#[allow(unused)]\n+pub const ERR_UNAVAILABLE: zx_status_t = -28;\n \n // ======= Permission check errors =======\n // ERR_ACCESS_DENIED: The caller did not have permission to perform\n // the specified operation.\n-#[allow(unused)] pub const ERR_ACCESS_DENIED: zx_status_t = -30;\n+#[allow(unused)]\n+pub const ERR_ACCESS_DENIED: zx_status_t = -30;\n \n // ======= Input-output errors =======\n // ERR_IO: Otherwise unspecified error occurred during I/O.\n-#[allow(unused)] pub const ERR_IO: zx_status_t = -40;\n+#[allow(unused)]\n+pub const ERR_IO: zx_status_t = -40;\n \n // ERR_REFUSED: The entity the I/O operation is being performed on\n // rejected the operation.\n // Example: an I2C device NAK'ing a transaction or a disk controller\n // rejecting an invalid command.\n-#[allow(unused)] pub const ERR_IO_REFUSED: zx_status_t = -41;\n+#[allow(unused)]\n+pub const ERR_IO_REFUSED: zx_status_t = -41;\n \n // ERR_IO_DATA_INTEGRITY: The data in the operation failed an integrity\n // check and is possibly corrupted.\n // Example: CRC or Parity error.\n-#[allow(unused)] pub const ERR_IO_DATA_INTEGRITY: zx_status_t = -42;\n+#[allow(unused)]\n+pub const ERR_IO_DATA_INTEGRITY: zx_status_t = -42;\n \n // ERR_IO_DATA_LOSS: The data in the operation is currently unavailable\n // and may be permanently lost.\n // Example: A disk block is irrecoverably damaged.\n-#[allow(unused)] pub const ERR_IO_DATA_LOSS: zx_status_t = -43;\n+#[allow(unused)]\n+pub const ERR_IO_DATA_LOSS: zx_status_t = -43;\n \n // Filesystem specific errors\n-#[allow(unused)] pub const ERR_BAD_PATH: zx_status_t = -50;\n-#[allow(unused)] pub const ERR_NOT_DIR: zx_status_t = -51;\n-#[allow(unused)] pub const ERR_NOT_FILE: zx_status_t = -52;\n+#[allow(unused)]\n+pub const ERR_BAD_PATH: zx_status_t = -50;\n+#[allow(unused)]\n+pub const ERR_NOT_DIR: zx_status_t = -51;\n+#[allow(unused)]\n+pub const ERR_NOT_FILE: zx_status_t = -52;\n // ERR_FILE_BIG: A file exceeds a filesystem-specific size limit.\n-#[allow(unused)] pub const ERR_FILE_BIG: zx_status_t = -53;\n+#[allow(unused)]\n+pub const ERR_FILE_BIG: zx_status_t = -53;\n // ERR_NO_SPACE: Filesystem or device space is exhausted.\n-#[allow(unused)] pub const ERR_NO_SPACE: zx_status_t = -54;\n+#[allow(unused)]\n+pub const ERR_NO_SPACE: zx_status_t = -54;"}, {"sha": "9ce5f3d014cc1fd8ec577601765c256af01dee91", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -4,20 +4,21 @@ use crate::slice;\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut v = (0, 0);\n     unsafe {\n-        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8,\n-                                             mem::size_of_val(&v));\n+        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8, mem::size_of_val(&v));\n         imp::fill_bytes(view);\n     }\n     v\n }\n \n-#[cfg(all(unix,\n-          not(target_os = \"ios\"),\n-          not(target_os = \"openbsd\"),\n-          not(target_os = \"freebsd\"),\n-          not(target_os = \"netbsd\"),\n-          not(target_os = \"fuchsia\"),\n-          not(target_os = \"redox\")))]\n+#[cfg(all(\n+    unix,\n+    not(target_os = \"ios\"),\n+    not(target_os = \"openbsd\"),\n+    not(target_os = \"freebsd\"),\n+    not(target_os = \"netbsd\"),\n+    not(target_os = \"fuchsia\"),\n+    not(target_os = \"redox\")\n+))]\n mod imp {\n     use crate::fs::File;\n     use crate::io::Read;\n@@ -30,7 +31,9 @@ mod imp {\n     }\n \n     #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool { false }\n+    fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool {\n+        false\n+    }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n@@ -96,9 +99,7 @@ mod imp {\n     pub fn fill_bytes(v: &mut [u8]) {\n         // getentropy(2) permits a maximum buffer size of 256 bytes\n         for s in v.chunks_mut(256) {\n-            let ret = unsafe {\n-                libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len())\n-            };\n+            let ret = unsafe { libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len()) };\n             if ret == -1 {\n                 panic!(\"unexpected getentropy error: {}\", errno());\n             }\n@@ -124,21 +125,14 @@ mod imp {\n     #[allow(non_upper_case_globals)]\n     const kSecRandomDefault: *const SecRandom = ptr::null();\n \n-    extern {\n-        fn SecRandomCopyBytes(rnd: *const SecRandom,\n-                              count: size_t,\n-                              bytes: *mut u8) -> c_int;\n+    extern \"C\" {\n+        fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n     }\n \n     pub fn fill_bytes(v: &mut [u8]) {\n-        let ret = unsafe {\n-            SecRandomCopyBytes(kSecRandomDefault,\n-                               v.len(),\n-                               v.as_mut_ptr())\n-        };\n+        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n         if ret == -1 {\n-            panic!(\"couldn't generate random bytes: {}\",\n-                   io::Error::last_os_error());\n+            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n         }\n     }\n }\n@@ -153,13 +147,22 @@ mod imp {\n         for s in v.chunks_mut(256) {\n             let mut s_len = s.len();\n             let ret = unsafe {\n-                libc::sysctl(mib.as_ptr(), mib.len() as libc::c_uint,\n-                             s.as_mut_ptr() as *mut _, &mut s_len,\n-                             ptr::null(), 0)\n+                libc::sysctl(\n+                    mib.as_ptr(),\n+                    mib.len() as libc::c_uint,\n+                    s.as_mut_ptr() as *mut _,\n+                    &mut s_len,\n+                    ptr::null(),\n+                    0,\n+                )\n             };\n             if ret == -1 || s_len != s.len() {\n-                panic!(\"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n-                       ret, s.len(), s_len);\n+                panic!(\n+                    \"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n+                    ret,\n+                    s.len(),\n+                    s_len\n+                );\n             }\n         }\n     }\n@@ -168,7 +171,7 @@ mod imp {\n #[cfg(target_os = \"fuchsia\")]\n mod imp {\n     #[link(name = \"zircon\")]\n-    extern {\n+    extern \"C\" {\n         fn zx_cprng_draw(buffer: *mut u8, len: usize);\n     }\n "}, {"sha": "528fe321efbce32cb0e83500ff55dd8872caaa02", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,12 +1,12 @@\n #![cfg_attr(test, allow(dead_code))]\n \n-use self::imp::{make_handler, drop_handler};\n+use self::imp::{drop_handler, make_handler};\n \n pub use self::imp::cleanup;\n pub use self::imp::init;\n \n pub struct Handler {\n-    _data: *mut libc::c_void\n+    _data: *mut libc::c_void,\n }\n \n impl Handler {\n@@ -23,28 +23,28 @@ impl Drop for Handler {\n     }\n }\n \n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"macos\",\n-          target_os = \"dragonfly\",\n-          target_os = \"freebsd\",\n-          target_os = \"solaris\",\n-          all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-          target_os = \"openbsd\"))]\n+#[cfg(any(\n+    target_os = \"linux\",\n+    target_os = \"macos\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"solaris\",\n+    all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+    target_os = \"openbsd\"\n+))]\n mod imp {\n     use super::Handler;\n     use crate::mem;\n     use crate::ptr;\n \n-    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n-    use libc::{sigaction, SIGBUS, SIG_DFL,\n-               SA_SIGINFO, SA_ONSTACK, sighandler_t};\n-    use libc::{mmap, munmap};\n-    use libc::{SIGSEGV, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON};\n     use libc::MAP_FAILED;\n+    use libc::{mmap, munmap};\n+    use libc::{sigaction, sighandler_t, SA_ONSTACK, SA_SIGINFO, SIGBUS, SIG_DFL};\n+    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n+    use libc::{MAP_ANON, MAP_PRIVATE, PROT_READ, PROT_WRITE, SIGSEGV};\n \n     use crate::sys_common::thread_info;\n \n-\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n         #[repr(C)]\n@@ -82,9 +82,11 @@ mod imp {\n     // out many large systems and all implementations allow returning from a\n     // signal handler to work. For a more detailed explanation see the\n     // comments on #26458.\n-    unsafe extern fn signal_handler(signum: libc::c_int,\n-                                    info: *mut libc::siginfo_t,\n-                                    _data: *mut libc::c_void) {\n+    unsafe extern \"C\" fn signal_handler(\n+        signum: libc::c_int,\n+        info: *mut libc::siginfo_t,\n+        _data: *mut libc::c_void,\n+    ) {\n         use crate::sys_common::util::report_overflow;\n \n         let guard = thread_info::stack_guard().unwrap_or(0..0);\n@@ -124,24 +126,22 @@ mod imp {\n     }\n \n     unsafe fn get_stackp() -> *mut libc::c_void {\n-        let stackp = mmap(ptr::null_mut(),\n-                          SIGSTKSZ,\n-                          PROT_READ | PROT_WRITE,\n-                          MAP_PRIVATE | MAP_ANON,\n-                          -1,\n-                          0);\n+        let stackp =\n+            mmap(ptr::null_mut(), SIGSTKSZ, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n         if stackp == MAP_FAILED {\n             panic!(\"failed to allocate an alternative stack\");\n         }\n         stackp\n     }\n \n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"freebsd\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\",\n-              target_os = \"solaris\"))]\n+    #[cfg(any(\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"freebsd\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"solaris\"\n+    ))]\n     unsafe fn get_stack() -> libc::stack_t {\n         libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }\n     }\n@@ -166,7 +166,7 @@ mod imp {\n \n     pub unsafe fn drop_handler(handler: &mut Handler) {\n         if !handler._data.is_null() {\n-            let stack =  libc::stack_t {\n+            let stack = libc::stack_t {\n                 ss_sp: ptr::null_mut(),\n                 ss_flags: SS_DISABLE,\n                 // Workaround for bug in macOS implementation of sigaltstack\n@@ -181,26 +181,25 @@ mod imp {\n     }\n }\n \n-#[cfg(not(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"dragonfly\",\n-              target_os = \"freebsd\",\n-              target_os = \"solaris\",\n-              all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-              target_os = \"openbsd\")))]\n+#[cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"macos\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"solaris\",\n+    all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+    target_os = \"openbsd\"\n+)))]\n mod imp {\n     use crate::ptr;\n \n-    pub unsafe fn init() {\n-    }\n+    pub unsafe fn init() {}\n \n-    pub unsafe fn cleanup() {\n-    }\n+    pub unsafe fn cleanup() {}\n \n     pub unsafe fn make_handler() -> super::Handler {\n         super::Handler { _data: ptr::null_mut() }\n     }\n \n-    pub unsafe fn drop_handler(_handler: &mut super::Handler) {\n-    }\n+    pub unsafe fn drop_handler(_handler: &mut super::Handler) {}\n }"}, {"sha": "b9c56963885c0d6bd38f2360e4680bdb7442bff4", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,13 +1,15 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::sys::fd::FileDesc;\n use crate::mem::ManuallyDrop;\n+use crate::sys::fd::FileDesc;\n \n pub struct Stdin(());\n pub struct Stdout(());\n pub struct Stderr(());\n \n impl Stdin {\n-    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin(()))\n+    }\n }\n \n impl io::Read for Stdin {\n@@ -21,7 +23,9 @@ impl io::Read for Stdin {\n }\n \n impl Stdout {\n-    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout(()))\n+    }\n }\n \n impl io::Write for Stdout {\n@@ -39,7 +43,9 @@ impl io::Write for Stdout {\n }\n \n impl Stderr {\n-    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr(()))\n+    }\n }\n \n impl io::Write for Stderr {"}, {"sha": "a5b34eeec289ee130b7e32f18a7f3b0e17e761f1", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 96, "deletions": 76, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -25,30 +25,32 @@ unsafe impl Sync for Thread {}\n // The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n // so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n #[cfg(not(target_os = \"emscripten\"))]\n-unsafe fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                    stack_size: libc::size_t) -> libc::c_int {\n+unsafe fn pthread_attr_setstacksize(\n+    attr: *mut libc::pthread_attr_t,\n+    stack_size: libc::size_t,\n+) -> libc::c_int {\n     libc::pthread_attr_setstacksize(attr, stack_size)\n }\n \n #[cfg(target_os = \"emscripten\")]\n-unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,\n-                                    _stack_size: libc::size_t) -> libc::c_int {\n+unsafe fn pthread_attr_setstacksize(\n+    _attr: *mut libc::pthread_attr_t,\n+    _stack_size: libc::size_t,\n+) -> libc::c_int {\n     panic!()\n }\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n-                          -> io::Result<Thread> {\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         let p = box p;\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n \n-        match pthread_attr_setstacksize(&mut attr,\n-                                        stack_size) {\n+        match pthread_attr_setstacksize(&mut attr, stack_size) {\n             0 => {}\n             n => {\n                 assert_eq!(n, libc::EINVAL);\n@@ -57,15 +59,13 @@ impl Thread {\n                 // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                 // Round up to the nearest page and try again.\n                 let page_size = os::page_size();\n-                let stack_size = (stack_size + page_size - 1) &\n-                                 (-(page_size as isize - 1) as usize - 1);\n-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr,\n-                                                           stack_size), 0);\n+                let stack_size =\n+                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n+                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start,\n-                                       &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n@@ -75,8 +75,10 @@ impl Thread {\n             Ok(Thread { id: native })\n         };\n \n-        extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n-            unsafe { start_thread(main as *mut u8); }\n+        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n             ptr::null_mut()\n         }\n     }\n@@ -86,8 +88,7 @@ impl Thread {\n         debug_assert_eq!(ret, 0);\n     }\n \n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"android\"))]\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     pub fn set_name(name: &CStr) {\n         const PR_SET_NAME: libc::c_int = 15;\n         // pthread wrapper only appeared in glibc 2.12, so we use syscall\n@@ -97,9 +98,7 @@ impl Thread {\n         }\n     }\n \n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"openbsd\"))]\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"openbsd\"))]\n     pub fn set_name(name: &CStr) {\n         unsafe {\n             libc::pthread_set_name_np(libc::pthread_self(), name.as_ptr());\n@@ -118,8 +117,11 @@ impl Thread {\n         use crate::ffi::CString;\n         let cname = CString::new(&b\"%s\"[..]).unwrap();\n         unsafe {\n-            libc::pthread_setname_np(libc::pthread_self(), cname.as_ptr(),\n-                                     name.as_ptr() as *mut libc::c_void);\n+            libc::pthread_setname_np(\n+                libc::pthread_self(),\n+                cname.as_ptr(),\n+                name.as_ptr() as *mut libc::c_void,\n+            );\n         }\n     }\n \n@@ -132,15 +134,19 @@ impl Thread {\n         }\n \n         if let Some(f) = pthread_setname_np.get() {\n-            unsafe { f(libc::pthread_self(), name.as_ptr()); }\n+            unsafe {\n+                f(libc::pthread_self(), name.as_ptr());\n+            }\n         }\n     }\n \n-    #[cfg(any(target_env = \"newlib\",\n-              target_os = \"haiku\",\n-              target_os = \"l4re\",\n-              target_os = \"emscripten\",\n-              target_os = \"redox\"))]\n+    #[cfg(any(\n+        target_env = \"newlib\",\n+        target_os = \"haiku\",\n+        target_os = \"l4re\",\n+        target_os = \"emscripten\",\n+        target_os = \"redox\"\n+    ))]\n     pub fn set_name(_name: &CStr) {\n         // Newlib, Illumos, Haiku, and Emscripten have no way to set a thread name.\n     }\n@@ -177,12 +183,13 @@ impl Thread {\n         unsafe {\n             let ret = libc::pthread_join(self.id, ptr::null_mut());\n             mem::forget(self);\n-            assert!(ret == 0,\n-                    \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n+            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n         }\n     }\n \n-    pub fn id(&self) -> libc::pthread_t { self.id }\n+    pub fn id(&self) -> libc::pthread_t {\n+        self.id\n+    }\n \n     pub fn into_id(self) -> libc::pthread_t {\n         let id = self.id;\n@@ -198,31 +205,38 @@ impl Drop for Thread {\n     }\n }\n \n-#[cfg(all(not(all(target_os = \"linux\", not(target_env = \"musl\"))),\n-          not(target_os = \"freebsd\"),\n-          not(target_os = \"macos\"),\n-          not(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\"))),\n-          not(target_os = \"openbsd\"),\n-          not(target_os = \"solaris\")))]\n+#[cfg(all(\n+    not(all(target_os = \"linux\", not(target_env = \"musl\"))),\n+    not(target_os = \"freebsd\"),\n+    not(target_os = \"macos\"),\n+    not(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\"))),\n+    not(target_os = \"openbsd\"),\n+    not(target_os = \"solaris\")\n+))]\n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n     use crate::ops::Range;\n     pub type Guard = Range<usize>;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }\n \n-\n-#[cfg(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n-          target_os = \"freebsd\",\n-          target_os = \"macos\",\n-          all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-          target_os = \"openbsd\",\n-          target_os = \"solaris\"))]\n+#[cfg(any(\n+    all(target_os = \"linux\", not(target_env = \"musl\")),\n+    target_os = \"freebsd\",\n+    target_os = \"macos\",\n+    all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+    target_os = \"openbsd\",\n+    target_os = \"solaris\"\n+))]\n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n     use libc::{mmap, mprotect};\n-    use libc::{PROT_NONE, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON, MAP_FAILED, MAP_FIXED};\n+    use libc::{MAP_ANON, MAP_FAILED, MAP_FIXED, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE};\n \n     use crate::ops::Range;\n     use crate::sys::os;\n@@ -241,16 +255,15 @@ pub mod guard {\n \n     #[cfg(target_os = \"macos\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n-        let stackaddr = libc::pthread_get_stackaddr_np(libc::pthread_self()) as usize -\n-             libc::pthread_get_stacksize_np(libc::pthread_self());\n+        let stackaddr = libc::pthread_get_stackaddr_np(libc::pthread_self()) as usize\n+            - libc::pthread_get_stacksize_np(libc::pthread_self());\n         Some(stackaddr as *mut libc::c_void)\n     }\n \n     #[cfg(target_os = \"openbsd\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut current_stack: libc::stack_t = crate::mem::zeroed();\n-        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(),\n-                                             &mut current_stack), 0);\n+        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(), &mut current_stack), 0);\n \n         let stackaddr = if libc::pthread_main_np() == 1 {\n             // main thread\n@@ -262,21 +275,25 @@ pub mod guard {\n         Some(stackaddr as *mut libc::c_void)\n     }\n \n-    #[cfg(any(target_os = \"android\", target_os = \"freebsd\",\n-              target_os = \"linux\", target_os = \"netbsd\", target_os = \"l4re\"))]\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"l4re\"\n+    ))]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n         #[cfg(target_os = \"freebsd\")]\n-            let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n+        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n         #[cfg(not(target_os = \"freebsd\"))]\n-            let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n+        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n         if e == 0 {\n             let mut stackaddr = crate::ptr::null_mut();\n             let mut stacksize = 0;\n-            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr,\n-                                                   &mut stacksize), 0);\n+            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize), 0);\n             ret = Some(stackaddr);\n         }\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n@@ -329,8 +346,14 @@ pub mod guard {\n             // than the initial mmap() used, so we mmap() here with\n             // read/write permissions and only then mprotect() it to\n             // no permissions at all. See issue #50313.\n-            let result = mmap(stackaddr, PAGE_SIZE, PROT_READ | PROT_WRITE,\n-                              MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);\n+            let result = mmap(\n+                stackaddr,\n+                PAGE_SIZE,\n+                PROT_READ | PROT_WRITE,\n+                MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n+                -1,\n+                0,\n+            );\n             if result != stackaddr || result == MAP_FAILED {\n                 panic!(\"failed to allocate a guard page\");\n             }\n@@ -341,34 +364,33 @@ pub mod guard {\n             }\n \n             let guardaddr = stackaddr as usize;\n-            let offset = if cfg!(target_os = \"freebsd\") {\n-                2\n-            } else {\n-                1\n-            };\n+            let offset = if cfg!(target_os = \"freebsd\") { 2 } else { 1 };\n \n             Some(guardaddr..guardaddr + offset * PAGE_SIZE)\n         }\n     }\n \n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"openbsd\",\n-              target_os = \"solaris\"))]\n+    #[cfg(any(target_os = \"macos\", target_os = \"openbsd\", target_os = \"solaris\"))]\n     pub unsafe fn current() -> Option<Guard> {\n         let stackaddr = get_stack_start()? as usize;\n         Some(stackaddr - PAGE_SIZE..stackaddr)\n     }\n \n-    #[cfg(any(target_os = \"android\", target_os = \"freebsd\",\n-              target_os = \"linux\", target_os = \"netbsd\", target_os = \"l4re\"))]\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"l4re\"\n+    ))]\n     pub unsafe fn current() -> Option<Guard> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = crate::mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n         #[cfg(target_os = \"freebsd\")]\n-            let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n+        let e = libc::pthread_attr_get_np(libc::pthread_self(), &mut attr);\n         #[cfg(not(target_os = \"freebsd\"))]\n-            let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n+        let e = libc::pthread_getattr_np(libc::pthread_self(), &mut attr);\n         if e == 0 {\n             let mut guardsize = 0;\n             assert_eq!(libc::pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n@@ -377,8 +399,7 @@ pub mod guard {\n             }\n             let mut stackaddr = crate::ptr::null_mut();\n             let mut size = 0;\n-            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr,\n-                                                   &mut size), 0);\n+            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n \n             let stackaddr = stackaddr as usize;\n             ret = if cfg!(target_os = \"freebsd\") {\n@@ -422,8 +443,7 @@ fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n \n // No point in looking up __pthread_get_minstack() on non-glibc\n // platforms.\n-#[cfg(all(not(target_os = \"linux\"),\n-          not(target_os = \"netbsd\")))]\n+#[cfg(all(not(target_os = \"linux\"), not(target_os = \"netbsd\")))]\n fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n     libc::PTHREAD_STACK_MIN\n }"}, {"sha": "2c5b94b1e61e5710717363d92396c6b5e1027305", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -5,7 +5,7 @@ use crate::mem;\n pub type Key = libc::pthread_key_t;\n \n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n     assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n     key"}, {"sha": "08cbe59617465731a22fdc228c84b9d5ce7e9733", "filename": "src/libstd/sys/unix/weak.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fweak.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -36,11 +36,7 @@ pub struct Weak<F> {\n \n impl<F> Weak<F> {\n     pub const fn new(name: &'static str) -> Weak<F> {\n-        Weak {\n-            name,\n-            addr: AtomicUsize::new(1),\n-            _marker: marker::PhantomData,\n-        }\n+        Weak { name, addr: AtomicUsize::new(1), _marker: marker::PhantomData }\n     }\n \n     pub fn get(&self) -> Option<F> {"}, {"sha": "97a191d7232e08837fcbac10e3862232784aa53c", "filename": "src/libstd/sys/vxworks/alloc.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,6 +1,6 @@\n-use crate::ptr;\n-use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ptr;\n+use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n unsafe impl GlobalAlloc for System {\n@@ -45,9 +45,5 @@ unsafe impl GlobalAlloc for System {\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     let mut out = ptr::null_mut();\n     let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n-    if ret != 0 {\n-        ptr::null_mut()\n-    } else {\n-        out as *mut u8\n-    }\n+    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n }"}, {"sha": "efd615f404db6b316e89c57b3fe5bbe47ef7abd2", "filename": "src/libstd/sys/vxworks/args.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -4,10 +4,14 @@ use crate::marker::PhantomData;\n use crate::vec;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    imp::init(argc, argv)\n+}\n \n /// One-time global cleanup.\n-pub unsafe fn cleanup() { imp::cleanup() }\n+pub unsafe fn cleanup() {\n+    imp::cleanup()\n+}\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n@@ -27,24 +31,32 @@ impl Args {\n \n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<OsString> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.iter.next_back()\n+    }\n }\n \n mod imp {\n-    use crate::ptr;\n+    use super::Args;\n     use crate::ffi::{CStr, OsString};\n     use crate::marker::PhantomData;\n+    use crate::ptr;\n     use libc;\n-    use super::Args;\n \n     use crate::sys_common::mutex::Mutex;\n \n@@ -65,21 +77,20 @@ mod imp {\n     }\n \n     pub fn args() -> Args {\n-        Args {\n-            iter: clone().into_iter(),\n-            _dont_send_or_sync_me: PhantomData\n-        }\n+        Args { iter: clone().into_iter(), _dont_send_or_sync_me: PhantomData }\n     }\n \n     fn clone() -> Vec<OsString> {\n         unsafe {\n             let _guard = LOCK.lock();\n-            let ret = (0..ARGC).map(|i| {\n-                let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n-                use crate::sys::vxworks::ext::ffi::OsStringExt;\n-                OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-            }).collect();\n-            return ret\n+            let ret = (0..ARGC)\n+                .map(|i| {\n+                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n+                    use crate::sys::vxworks::ext::ffi::OsStringExt;\n+                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n+                })\n+                .collect();\n+            return ret;\n         }\n     }\n }"}, {"sha": "2916ebe4440593d2e1c9b4144f5b83da0ae8a28c", "filename": "src/libstd/sys/vxworks/cmath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n #![cfg(not(test))]\n \n-use libc::{c_float, c_double};\n+use libc::{c_double, c_float};\n \n #[link_name = \"m\"]\n-extern {\n+extern \"C\" {\n     pub fn acos(n: c_double) -> c_double;\n     pub fn acosf(n: c_float) -> c_float;\n     pub fn asin(n: c_double) -> c_double;"}, {"sha": "f2a1d6815290d220879ac2f9023f842828bfbf5a", "filename": "src/libstd/sys/vxworks/condvar.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,15 +2,15 @@ use crate::cell::UnsafeCell;\n use crate::sys::mutex::{self, Mutex};\n use crate::time::Duration;\n \n-pub struct Condvar { inner: UnsafeCell<libc::pthread_cond_t> }\n+pub struct Condvar {\n+    inner: UnsafeCell<libc::pthread_cond_t>,\n+}\n \n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n-const TIMESPEC_MAX: libc::timespec = libc::timespec {\n-    tv_sec: <libc::time_t>::max_value(),\n-    tv_nsec: 1_000_000_000 - 1,\n-};\n+const TIMESPEC_MAX: libc::timespec =\n+    libc::timespec { tv_sec: <libc::time_t>::max_value(), tv_nsec: 1_000_000_000 - 1 };\n \n fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n     if value > <libc::time_t>::max_value() as u64 {\n@@ -77,17 +77,14 @@ impl Condvar {\n             .and_then(|s| s.checked_add(now.tv_sec));\n         let nsec = nsec % 1_000_000_000;\n \n-        let timeout = sec.map(|s| {\n-            libc::timespec { tv_sec: s, tv_nsec: nsec as _}\n-        }).unwrap_or(TIMESPEC_MAX);\n+        let timeout =\n+            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n \n-        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n-                                            &timeout);\n+        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n         assert!(r == libc::ETIMEDOUT || r == 0);\n         r == 0\n     }\n \n-\n     #[inline]\n     pub unsafe fn destroy(&self) {\n         let r = libc::pthread_cond_destroy(self.inner.get());"}, {"sha": "9864a855df738ef0afc3353cfc40959f463449c3", "filename": "src/libstd/sys/vxworks/ext/fs.rs", "status": "modified", "additions": 67, "deletions": 27, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,11 +2,11 @@\n \n use crate::fs::{self, Permissions};\n use crate::io;\n-use libc;\n use crate::path::Path;\n use crate::sys;\n-use crate::sys_common::{FromInner, AsInner, AsInnerMut};\n use crate::sys::platform::fs::MetadataExt as UnixMetadataExt;\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n+use libc;\n \n /// Unix-specific extensions to [`File`].\n ///\n@@ -112,8 +112,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new(io::ErrorKind::UnexpectedEof,\n-                               \"failed to fill whole buffer\"))\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -196,8 +195,12 @@ pub trait FileExt {\n     fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n-                Ok(0) => return Err(io::Error::new(io::ErrorKind::WriteZero,\n-                                                   \"failed to write whole buffer\")),\n+                Ok(0) => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::WriteZero,\n+                        \"failed to write whole buffer\",\n+                    ));\n+                }\n                 Ok(n) => {\n                     buf = &buf[n..];\n                     offset += n as u64\n@@ -604,20 +607,48 @@ pub trait MetadataExt {\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n impl MetadataExt for fs::Metadata {\n-    fn dev(&self) -> u64 { self.st_dev() }\n-    fn ino(&self) -> u64 { self.st_ino() }\n-    fn mode(&self) -> u32 { self.st_mode() }\n-    fn nlink(&self) -> u64 { self.st_nlink() }\n-    fn uid(&self) -> u32 { self.st_uid() }\n-    fn gid(&self) -> u32 { self.st_gid() }\n-    fn rdev(&self) -> u64 { self.st_rdev() }\n-    fn size(&self) -> u64 { self.st_size() }\n-    fn atime(&self) -> i64 { self.st_atime() }\n-    fn mtime(&self) -> i64 { self.st_mtime() }\n-    fn ctime(&self) -> i64 { self.st_ctime() }\n-    fn blksize(&self) -> u64 { self.st_blksize() }\n-    fn blocks(&self) -> u64 { self.st_blocks() }\n-    fn attrib(&self) -> u8 {self.st_attrib() }\n+    fn dev(&self) -> u64 {\n+        self.st_dev()\n+    }\n+    fn ino(&self) -> u64 {\n+        self.st_ino()\n+    }\n+    fn mode(&self) -> u32 {\n+        self.st_mode()\n+    }\n+    fn nlink(&self) -> u64 {\n+        self.st_nlink()\n+    }\n+    fn uid(&self) -> u32 {\n+        self.st_uid()\n+    }\n+    fn gid(&self) -> u32 {\n+        self.st_gid()\n+    }\n+    fn rdev(&self) -> u64 {\n+        self.st_rdev()\n+    }\n+    fn size(&self) -> u64 {\n+        self.st_size()\n+    }\n+    fn atime(&self) -> i64 {\n+        self.st_atime()\n+    }\n+    fn mtime(&self) -> i64 {\n+        self.st_mtime()\n+    }\n+    fn ctime(&self) -> i64 {\n+        self.st_ctime()\n+    }\n+    fn blksize(&self) -> u64 {\n+        self.st_blksize()\n+    }\n+    fn blocks(&self) -> u64 {\n+        self.st_blocks()\n+    }\n+    fn attrib(&self) -> u8 {\n+        self.st_attrib()\n+    }\n }\n \n /// Unix-specific extensions for [`FileType`].\n@@ -704,10 +735,18 @@ pub trait FileTypeExt {\n \n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n impl FileTypeExt for fs::FileType {\n-    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }\n-    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }\n-    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }\n-    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }\n+    fn is_block_device(&self) -> bool {\n+        self.as_inner().is(libc::S_IFBLK)\n+    }\n+    fn is_char_device(&self) -> bool {\n+        self.as_inner().is(libc::S_IFCHR)\n+    }\n+    fn is_fifo(&self) -> bool {\n+        self.as_inner().is(libc::S_IFIFO)\n+    }\n+    fn is_socket(&self) -> bool {\n+        self.as_inner().is(libc::S_IFSOCK)\n+    }\n }\n \n /// Unix-specific extension methods for [`fs::DirEntry`].\n@@ -739,7 +778,9 @@ pub trait DirEntryExt {\n \n #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n impl DirEntryExt for fs::DirEntry {\n-    fn ino(&self) -> u64 { self.as_inner().ino() }\n+    fn ino(&self) -> u64 {\n+        self.as_inner().ino()\n+    }\n }\n \n /// Creates a new symbolic link on the filesystem.\n@@ -766,8 +807,7 @@ impl DirEntryExt for fs::DirEntry {\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n-{\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     sys::fs::symlink(src.as_ref(), dst.as_ref())\n }\n "}, {"sha": "25c6e26d96e91d1a74f6edc1594abdde3a15ff31", "filename": "src/libstd/sys/vxworks/ext/io.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -3,11 +3,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fs;\n+use crate::io;\n+use crate::net;\n use crate::os::raw;\n use crate::sys;\n-use crate::io;\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-use crate::net;\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -84,47 +84,65 @@ impl IntoRawFd for fs::File {\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdin {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdout {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stderr {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StdinLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StdoutLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO\n+    }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawFd for io::StderrLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n }\n \n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]"}, {"sha": "251a198f821d6a2d56080f040bf50792769d50bd", "filename": "src/libstd/sys/vxworks/ext/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,18 +1,21 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-pub mod io;\n pub mod ffi;\n pub mod fs;\n-pub mod raw;\n+pub mod io;\n pub mod process;\n+pub mod raw;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt, FileTypeExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::fs::{FileTypeExt, MetadataExt, OpenOptionsExt, PermissionsExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n }"}, {"sha": "e535c4aa122f0fe6d034e6b833eee0cfcf6da834", "filename": "src/libstd/sys/vxworks/ext/process.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -3,10 +3,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::io;\n-use crate::sys::vxworks::ext::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n use crate::process;\n use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+use crate::sys::vxworks::ext::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n /// Unix-specific extensions to the [`process::Command`] builder.\n ///\n@@ -55,7 +55,8 @@ pub trait CommandExt {\n     /// locations may not appear where intended.\n     #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n     unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n \n     /// Schedules a closure to be run just before the `exec` function is\n     /// invoked.\n@@ -67,7 +68,8 @@ pub trait CommandExt {\n     #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n     #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n     fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n     {\n         unsafe { self.pre_exec(f) }\n     }\n@@ -118,7 +120,8 @@ impl CommandExt for process::Command {\n     }\n \n     unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    where\n+        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n     {\n         self.as_inner_mut().pre_exec(Box::new(f));\n         self"}, {"sha": "387ebd0520a71023465dfc8e4322323da44ae526", "filename": "src/libstd/sys/vxworks/fast_thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n #![cfg(target_thread_local)]\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::sys_common::thread_local::register_dtor_fallback;\n     register_dtor_fallback(t, dtor);\n }"}, {"sha": "9b649aa7ef45f99cf553c9191d733ff8f231c1c1", "filename": "src/libstd/sys/vxworks/fd.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n use crate::cmp;\n-use crate::io::{self, Read, Initializer, IoSlice, IoSliceMut};\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::sys::cvt;\n use crate::sys_common::AsInner;\n@@ -25,7 +25,9 @@ impl FileDesc {\n         FileDesc { fd: fd }\n     }\n \n-    pub fn raw(&self) -> c_int { self.fd }\n+    pub fn raw(&self) -> c_int {\n+        self.fd\n+    }\n \n     /// Extracts the actual filedescriptor without closing it.\n     pub fn into_raw(self) -> c_int {\n@@ -36,18 +38,18 @@ impl FileDesc {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::read(self.fd,\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       cmp::min(buf.len(), max_len()))\n+            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::readv(self.fd,\n-                        bufs.as_ptr() as *const libc::iovec,\n-                        cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+            libc::readv(\n+                self.fd,\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -58,61 +60,69 @@ impl FileDesc {\n     }\n \n     pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        unsafe fn cvt_pread(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n+        unsafe fn cvt_pread(\n+            fd: c_int,\n+            buf: *mut c_void,\n+            count: usize,\n+            offset: i64,\n+        ) -> io::Result<isize> {\n             use libc::pread;\n             cvt(pread(fd, buf, count, offset))\n         }\n \n         unsafe {\n-            cvt_pread(self.fd,\n+            cvt_pread(\n+                self.fd,\n                 buf.as_mut_ptr() as *mut c_void,\n                 cmp::min(buf.len(), max_len()),\n-                offset as i64)\n+                offset as i64,\n+            )\n             .map(|n| n as usize)\n         }\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::write(self.fd,\n-            buf.as_ptr() as *const c_void,\n-            cmp::min(buf.len(), max_len()))\n+            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::writev(self.fd,\n-                         bufs.as_ptr() as *const libc::iovec,\n-                         cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+            libc::writev(\n+                self.fd,\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        unsafe fn cvt_pwrite(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n-            -> io::Result<isize>\n-        {\n+        unsafe fn cvt_pwrite(\n+            fd: c_int,\n+            buf: *const c_void,\n+            count: usize,\n+            offset: i64,\n+        ) -> io::Result<isize> {\n             use libc::pwrite;\n             cvt(pwrite(fd, buf, count, offset))\n         }\n \n         unsafe {\n-            cvt_pwrite(self.fd,\n+            cvt_pwrite(\n+                self.fd,\n                 buf.as_ptr() as *const c_void,\n                 cmp::min(buf.len(), max_len()),\n-                offset as i64)\n-                .map(|n| n as usize)\n+                offset as i64,\n+            )\n+            .map(|n| n as usize)\n         }\n     }\n \n     pub fn get_cloexec(&self) -> io::Result<bool> {\n-        unsafe {\n-            Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0)\n-        }\n+        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n     }\n \n     pub fn set_cloexec(&self) -> io::Result<()> {\n@@ -139,23 +149,16 @@ impl FileDesc {\n     pub fn set_nonblocking_pipe(&self, nonblocking: bool) -> io::Result<()> {\n         unsafe {\n             let mut flags = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n-            flags = if nonblocking {\n-                flags | libc::O_NONBLOCK\n-            } else {\n-                flags & !libc::O_NONBLOCK\n-            };\n+            flags = if nonblocking { flags | libc::O_NONBLOCK } else { flags & !libc::O_NONBLOCK };\n             cvt(libc::fcntl(self.fd, libc::F_SETFL, flags))?;\n             Ok(())\n         }\n     }\n \n-\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n         let fd = self.raw();\n         match cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD_CLOEXEC, 0) }) {\n-            Ok(newfd) => {\n-                Ok(FileDesc::new(newfd))\n-            }\n+            Ok(newfd) => Ok(FileDesc::new(newfd)),\n             Err(e) => return Err(e),\n         }\n     }\n@@ -173,7 +176,9 @@ impl<'a> Read for &'a FileDesc {\n }\n \n impl AsInner<c_int> for FileDesc {\n-    fn as_inner(&self) -> &c_int { &self.fd }\n+    fn as_inner(&self) -> &c_int {\n+        &self.fd\n+    }\n }\n \n impl Drop for FileDesc {"}, {"sha": "6c2dfb79d6f11d874b67ac22c24867a04c03383f", "filename": "src/libstd/sys/vxworks/fs.rs", "status": "modified", "additions": 121, "deletions": 95, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,19 +1,19 @@\n // copies from linuxx\n-use crate::ffi::{CString, CStr, OsString, OsStr};\n-use crate::sys::vxworks::ext::ffi::OsStrExt;\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sync::Arc;\n use crate::sys::fd::FileDesc;\n use crate::sys::time::SystemTime;\n+use crate::sys::vxworks::ext::ffi::OsStrExt;\n+use crate::sys::vxworks::ext::ffi::OsStringExt;\n use crate::sys::{cvt, cvt_r};\n use crate::sys_common::{AsInner, FromInner};\n-use libc::{self, c_int, mode_t, stat64, off_t};\n-use libc::{ftruncate, lseek, dirent, readdir_r as readdir64_r, open};\n-use crate::sys::vxworks::ext::ffi::OsStringExt;\n+use libc::{self, c_int, mode_t, off_t, stat64};\n+use libc::{dirent, ftruncate, lseek, open, readdir_r as readdir64_r};\n pub struct File(FileDesc);\n \n #[derive(Clone)]\n@@ -58,16 +58,24 @@ pub struct OpenOptions {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FilePermissions { mode: mode_t }\n+pub struct FilePermissions {\n+    mode: mode_t,\n+}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct FileType { mode: mode_t }\n+pub struct FileType {\n+    mode: mode_t,\n+}\n \n #[derive(Debug)]\n-pub struct DirBuilder { mode: mode_t }\n+pub struct DirBuilder {\n+    mode: mode_t,\n+}\n \n impl FileAttr {\n-    pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n+    pub fn size(&self) -> u64 {\n+        self.stat.st_size as u64\n+    }\n     pub fn perm(&self) -> FilePermissions {\n         FilePermissions { mode: (self.stat.st_mode as mode_t) }\n     }\n@@ -85,20 +93,23 @@ impl FileAttr {\n \n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n-        tv_sec: self.stat.st_atime as libc::time_t,\n-        tv_nsec: 0, // hack - a proper fix would be better\n+            tv_sec: self.stat.st_atime as libc::time_t,\n+            tv_nsec: 0, // hack - a proper fix would be better\n         }))\n     }\n \n     pub fn created(&self) -> io::Result<SystemTime> {\n-        Err(io::Error::new(io::ErrorKind::Other,\n-                           \"creation time is not available on this platform currently\"))\n+        Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"creation time is not available on this platform currently\",\n+        ))\n     }\n-\n }\n \n impl AsInner<stat64> for FileAttr {\n-    fn as_inner(&self) -> &stat64 { &self.stat }\n+    fn as_inner(&self) -> &stat64 {\n+        &self.stat\n+    }\n }\n \n impl FilePermissions {\n@@ -116,15 +127,25 @@ impl FilePermissions {\n             self.mode |= 0o222;\n         }\n     }\n-    pub fn mode(&self) -> u32 { self.mode as u32 }\n+    pub fn mode(&self) -> u32 {\n+        self.mode as u32\n+    }\n }\n \n impl FileType {\n-    pub fn is_dir(&self) -> bool { self.is(libc::S_IFDIR) }\n-    pub fn is_file(&self) -> bool { self.is(libc::S_IFREG) }\n-    pub fn is_symlink(&self) -> bool { self.is(libc::S_IFLNK) }\n+    pub fn is_dir(&self) -> bool {\n+        self.is(libc::S_IFDIR)\n+    }\n+    pub fn is_file(&self) -> bool {\n+        self.is(libc::S_IFREG)\n+    }\n+    pub fn is_symlink(&self) -> bool {\n+        self.is(libc::S_IFLNK)\n+    }\n \n-    pub fn is(&self, mode: mode_t) -> bool { self.mode & libc::S_IFMT == mode }\n+    pub fn is(&self, mode: mode_t) -> bool {\n+        self.mode & libc::S_IFMT == mode\n+    }\n }\n \n impl FromInner<u32> for FilePermissions {\n@@ -149,10 +170,7 @@ impl Iterator for ReadDir {\n         }\n \n         unsafe {\n-            let mut ret = DirEntry {\n-                entry: mem::zeroed(),\n-                dir: self.clone(),\n-            };\n+            let mut ret = DirEntry { entry: mem::zeroed(), dir: self.clone() };\n             let mut entry_ptr = ptr::null_mut();\n             loop {\n                 if readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n@@ -163,13 +181,13 @@ impl Iterator for ReadDir {\n                         // (instead of looping forever)\n                         self.end_of_stream = true;\n                     }\n-                    return Some(Err(Error::last_os_error()))\n+                    return Some(Err(Error::last_os_error()));\n                 }\n                 if entry_ptr.is_null() {\n-                    return None\n+                    return None;\n                 }\n                 if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n-                    return Some(Ok(ret))\n+                    return Some(Ok(ret));\n                 }\n             }\n         }\n@@ -185,22 +203,20 @@ impl Drop for Dir {\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-            use crate::sys::vxworks::ext::ffi::OsStrExt;\n-            self.dir.inner.root.join(OsStr::from_bytes(self.name_bytes()))\n+        use crate::sys::vxworks::ext::ffi::OsStrExt;\n+        self.dir.inner.root.join(OsStr::from_bytes(self.name_bytes()))\n     }\n \n     pub fn file_name(&self) -> OsString {\n         OsStr::from_bytes(self.name_bytes()).to_os_string()\n     }\n \n-\n     pub fn metadata(&self) -> io::Result<FileAttr> {\n         lstat(&self.path())\n     }\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n-\n     }\n \n     pub fn ino(&self) -> u64 {\n@@ -231,45 +247,61 @@ impl OpenOptions {\n         }\n     }\n \n-    pub fn read(&mut self, read: bool) { self.read = read; }\n-    pub fn write(&mut self, write: bool) { self.write = write; }\n-    pub fn append(&mut self, append: bool) { self.append = append; }\n-    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n-    pub fn create(&mut self, create: bool) { self.create = create; }\n-    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n-    pub fn mode(&mut self, mode: u32) { self.mode = mode as mode_t; }\n+    pub fn read(&mut self, read: bool) {\n+        self.read = read;\n+    }\n+    pub fn write(&mut self, write: bool) {\n+        self.write = write;\n+    }\n+    pub fn append(&mut self, append: bool) {\n+        self.append = append;\n+    }\n+    pub fn truncate(&mut self, truncate: bool) {\n+        self.truncate = truncate;\n+    }\n+    pub fn create(&mut self, create: bool) {\n+        self.create = create;\n+    }\n+    pub fn create_new(&mut self, create_new: bool) {\n+        self.create_new = create_new;\n+    }\n+    pub fn mode(&mut self, mode: u32) {\n+        self.mode = mode as mode_t;\n+    }\n \n     fn get_access_mode(&self) -> io::Result<c_int> {\n         match (self.read, self.write, self.append) {\n-            (true,  false, false) => Ok(libc::O_RDONLY),\n-            (false, true,  false) => Ok(libc::O_WRONLY),\n-            (true,  true,  false) => Ok(libc::O_RDWR),\n-            (false, _,     true)  => Ok(libc::O_WRONLY | libc::O_APPEND),\n-            (true,  _,     true)  => Ok(libc::O_RDWR | libc::O_APPEND),\n+            (true, false, false) => Ok(libc::O_RDONLY),\n+            (false, true, false) => Ok(libc::O_WRONLY),\n+            (true, true, false) => Ok(libc::O_RDWR),\n+            (false, _, true) => Ok(libc::O_WRONLY | libc::O_APPEND),\n+            (true, _, true) => Ok(libc::O_RDWR | libc::O_APPEND),\n             (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n         }\n     }\n \n     fn get_creation_mode(&self) -> io::Result<c_int> {\n         match (self.write, self.append) {\n             (true, false) => {}\n-            (false, false) =>\n+            (false, false) => {\n                 if self.truncate || self.create || self.create_new {\n                     return Err(Error::from_raw_os_error(libc::EINVAL));\n-                },\n-            (_, true) =>\n+                }\n+            }\n+            (_, true) => {\n                 if self.truncate && !self.create_new {\n                     return Err(Error::from_raw_os_error(libc::EINVAL));\n-                },\n+                }\n+            }\n         }\n \n         Ok(match (self.create, self.truncate, self.create_new) {\n-                (false, false, false) => 0,\n-                (true,  false, false) => libc::O_CREAT,\n-                (false, true,  false) => libc::O_TRUNC,\n-                (true,  true,  false) => libc::O_CREAT | libc::O_TRUNC,\n-                (_,      _,    true)  => libc::O_CREAT | libc::O_EXCL,\n-           })\n+            (false, false, false) => 0,\n+            (true, false, false) => libc::O_CREAT,\n+            (false, true, false) => libc::O_TRUNC,\n+            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,\n+            (_, _, true) => libc::O_CREAT | libc::O_EXCL,\n+        })\n     }\n }\n \n@@ -280,21 +312,17 @@ impl File {\n     }\n \n     pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = libc::O_CLOEXEC |\n-                opts.get_access_mode()? |\n-                opts.get_creation_mode()? |\n-                (opts.custom_flags as c_int & !libc::O_ACCMODE);\n-        let fd = cvt_r(|| unsafe {\n-            open(path.as_ptr(), flags, opts.mode as c_int)\n-        })?;\n+        let flags = libc::O_CLOEXEC\n+            | opts.get_access_mode()?\n+            | opts.get_creation_mode()?\n+            | (opts.custom_flags as c_int & !libc::O_ACCMODE);\n+        let fd = cvt_r(|| unsafe { open(path.as_ptr(), flags, opts.mode as c_int) })?;\n         Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         let mut stat: stat64 = unsafe { mem::zeroed() };\n-        cvt(unsafe {\n-            ::libc::fstat(self.0.raw(), &mut stat)\n-        })?;\n+        cvt(unsafe { ::libc::fstat(self.0.raw(), &mut stat) })?;\n         Ok(FileAttr { stat: stat })\n     }\n \n@@ -306,13 +334,13 @@ impl File {\n     pub fn datasync(&self) -> io::Result<()> {\n         cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n         return Ok(());\n-        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) } //not supported\n+        unsafe fn os_datasync(fd: c_int) -> c_int {\n+            libc::fsync(fd)\n+        } //not supported\n     }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        return cvt_r(|| unsafe {\n-            ftruncate(self.0.raw(), size as off_t)\n-        }).map(|_| ());\n+        return cvt_r(|| unsafe { ftruncate(self.0.raw(), size as off_t) }).map(|_| ());\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -339,7 +367,9 @@ impl File {\n         self.0.write_at(buf, offset)\n     }\n \n-    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, pos) = match pos {\n@@ -357,9 +387,13 @@ impl File {\n         self.0.duplicate().map(File)\n     }\n \n-    pub fn fd(&self) -> &FileDesc { &self.0 }\n+    pub fn fd(&self) -> &FileDesc {\n+        &self.0\n+    }\n \n-    pub fn into_fd(self) -> FileDesc { self.0 }\n+    pub fn into_fd(self) -> FileDesc {\n+        self.0\n+    }\n \n     pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n         cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n@@ -401,7 +435,7 @@ impl FromInner<c_int> for File {\n impl fmt::Debug for File {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fn get_path(fd: c_int) -> Option<PathBuf> {\n-            let mut buf = vec![0;libc::PATH_MAX as usize];\n+            let mut buf = vec![0; libc::PATH_MAX as usize];\n             let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n             if n == -1 {\n                 return None;\n@@ -419,7 +453,7 @@ impl fmt::Debug for File {\n                 libc::O_RDONLY => Some((true, false)),\n                 libc::O_RDWR => Some((true, true)),\n                 libc::O_WRONLY => Some((false, true)),\n-                _ => None\n+                _ => None,\n             }\n         }\n \n@@ -445,10 +479,7 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n             Err(Error::last_os_error())\n         } else {\n             let inner = InnerReadDir { dirp: Dir(ptr), root };\n-            Ok(ReadDir{\n-                inner: Arc::new(inner),\n-                end_of_stream: false,\n-            })\n+            Ok(ReadDir { inner: Arc::new(inner), end_of_stream: false })\n         }\n     }\n }\n@@ -480,11 +511,7 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n \n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n     let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() {\n-        unlink(path)\n-    } else {\n-        remove_dir_all_recursive(path)\n-    }\n+    if filetype.is_symlink() { unlink(path) } else { remove_dir_all_recursive(path) }\n }\n \n fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n@@ -506,11 +533,12 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let mut buf = Vec::with_capacity(256);\n \n     loop {\n-        let buf_read = cvt(unsafe {\n-            libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity())\n-        })? as usize;\n+        let buf_read =\n+            cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;\n \n-        unsafe { buf.set_len(buf_read); }\n+        unsafe {\n+            buf.set_len(buf_read);\n+        }\n \n         if buf_read != buf.capacity() {\n             buf.shrink_to_fit();\n@@ -542,18 +570,14 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe {\n-        libc::stat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n-    })?;\n+    cvt(unsafe { libc::stat(p.as_ptr(), &mut stat as *mut _ as *mut _) })?;\n     Ok(FileAttr { stat })\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     let p = cstr(p)?;\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe {\n-        ::libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n-    })?;\n+    cvt(unsafe { ::libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _) })?;\n     Ok(FileAttr { stat })\n }\n \n@@ -564,7 +588,7 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     unsafe {\n         let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n         if r.is_null() {\n-            return Err(io::Error::last_os_error())\n+            return Err(io::Error::last_os_error());\n         }\n         buf = CStr::from_ptr(r).to_bytes().to_vec();\n         libc::free(r as *mut _);\n@@ -575,8 +599,10 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::fs::File;\n     if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n+        return Err(Error::new(\n+            ErrorKind::InvalidInput,\n+            \"the source path is not an existing regular file\",\n+        ));\n     }\n \n     let mut reader = File::open(from)?;"}, {"sha": "f1a2c8446ff8b40c7d096702746b8f78be31f128", "filename": "src/libstd/sys/vxworks/io.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n use crate::marker::PhantomData;\n use crate::slice;\n \n-use libc::{iovec, c_void};\n+use libc::{c_void, iovec};\n \n #[repr(transparent)]\n pub struct IoSlice<'a> {\n@@ -13,10 +13,7 @@ impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice {\n-            vec: iovec {\n-                iov_base: buf.as_ptr() as *mut u8 as *mut c_void,\n-                iov_len: buf.len()\n-            },\n+            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n             _p: PhantomData,\n         }\n     }\n@@ -35,9 +32,7 @@ impl<'a> IoSlice<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }\n \n@@ -50,10 +45,7 @@ impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut {\n-            vec: iovec {\n-                iov_base: buf.as_mut_ptr() as *mut c_void,\n-                iov_len: buf.len()\n-            },\n+            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n             _p: PhantomData,\n         }\n     }\n@@ -72,15 +64,11 @@ impl<'a> IoSliceMut<'a> {\n \n     #[inline]\n     pub fn as_slice(&self) -> &[u8] {\n-        unsafe {\n-            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n \n     #[inline]\n     pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        unsafe {\n-            slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len)\n-        }\n+        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }"}, {"sha": "928100c92ffadf57c3f018c628509bb073ccb786", "filename": "src/libstd/sys/vxworks/memchr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,13 +6,10 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n         libc::memchr(\n             haystack.as_ptr() as *const libc::c_void,\n             needle as libc::c_int,\n-            haystack.len())\n+            haystack.len(),\n+        )\n     };\n-    if p.is_null() {\n-        None\n-    } else {\n-        Some(p as usize - (haystack.as_ptr() as usize))\n-    }\n+    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n }\n \n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {"}, {"sha": "f102e4d6adf59250581e5b864dc95107cddb5414", "filename": "src/libstd/sys/vxworks/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -3,8 +3,8 @@\n \n use crate::io::ErrorKind;\n \n-pub use crate::os::vxworks as platform;\n pub use self::rand::hashmap_random_keys;\n+pub use crate::os::vxworks as platform;\n pub use libc::strlen;\n \n pub mod alloc;\n@@ -16,8 +16,8 @@ pub mod ext;\n pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n-pub mod memchr;\n pub mod io;\n+pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod os;\n@@ -27,10 +27,10 @@ pub mod process;\n pub mod rand;\n pub mod rwlock;\n pub mod stack_overflow;\n+pub mod stdio;\n pub mod thread;\n pub mod thread_local;\n pub mod time;\n-pub mod stdio;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n@@ -47,7 +47,7 @@ pub fn init() {\n         reset_sigpipe();\n     }\n \n-    unsafe fn reset_sigpipe() { }\n+    unsafe fn reset_sigpipe() {}\n }\n \n pub use libc::signal;\n@@ -71,8 +71,7 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n         // These two constants can have the same value on some systems,\n         // but different values on others, so we can't use a match\n         // clause\n-        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-            ErrorKind::WouldBlock,\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK => ErrorKind::WouldBlock,\n \n         _ => ErrorKind::Other,\n     }\n@@ -94,16 +93,13 @@ macro_rules! impl_is_minus_one {\n impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n pub fn cvt<T: IsMinusOne>(t: T) -> crate::io::Result<T> {\n-    if t.is_minus_one() {\n-        Err(crate::io::Error::last_os_error())\n-    } else {\n-        Ok(t)\n-    }\n+    if t.is_minus_one() { Err(crate::io::Error::last_os_error()) } else { Ok(t) }\n }\n \n pub fn cvt_r<T, F>(mut f: F) -> crate::io::Result<T>\n-    where T: IsMinusOne,\n-          F: FnMut() -> T\n+where\n+    T: IsMinusOne,\n+    F: FnMut() -> T,\n {\n     loop {\n         match cvt(f()) {"}, {"sha": "b38375a2e03c5cd4a2d016d82cfa4cdd12fee1a9", "filename": "src/libstd/sys/vxworks/mutex.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,9 @@\n use crate::cell::UnsafeCell;\n use crate::mem::MaybeUninit;\n \n-pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n+pub struct Mutex {\n+    inner: UnsafeCell<libc::pthread_mutex_t>,\n+}\n \n #[inline]\n pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n@@ -82,7 +84,9 @@ impl Mutex {\n     }\n }\n \n-pub struct ReentrantMutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n+pub struct ReentrantMutex {\n+    inner: UnsafeCell<libc::pthread_mutex_t>,\n+}\n \n unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n@@ -96,8 +100,8 @@ impl ReentrantMutex {\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n         let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_settype(attr.as_mut_ptr(),\n-                                                    libc::PTHREAD_MUTEX_RECURSIVE);\n+        let result =\n+            libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE);\n         debug_assert_eq!(result, 0);\n         let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n         debug_assert_eq!(result, 0);"}, {"sha": "85f5fcff2c259e3dd9c60d58e4761f53dc453b25", "filename": "src/libstd/sys/vxworks/net.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,15 +1,15 @@\n+use crate::cmp;\n use crate::ffi::CStr;\n use crate::io;\n use crate::io::{IoSlice, IoSliceMut};\n-use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n use crate::mem;\n-use crate::net::{SocketAddr, Shutdown};\n+use crate::net::{Shutdown, SocketAddr};\n use crate::str;\n use crate::sys::fd::FileDesc;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::{Duration, Instant};\n-use crate::cmp;\n+use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n \n pub use crate::sys::{cvt, cvt_r};\n \n@@ -18,7 +18,6 @@ pub extern crate libc as netc;\n \n pub type wrlen_t = size_t;\n \n-\n const SOCK_CLOEXEC: c_int = 0;\n const SO_NOSIGPIPE: c_int = 0;\n \n@@ -28,23 +27,23 @@ pub fn init() {}\n \n pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 {\n-        return Ok(())\n+        return Ok(());\n     }\n \n     // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n     on_resolver_failure();\n \n     if err == EAI_SYSTEM {\n-        return Err(io::Error::last_os_error())\n+        return Err(io::Error::last_os_error());\n     }\n \n     let detail = unsafe {\n-        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap()\n-            .to_owned()\n+        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n     };\n-    Err(io::Error::new(io::ErrorKind::Other,\n-                       &format!(\"failed to lookup address information: {}\",\n-                                detail)[..]))\n+    Err(io::Error::new(\n+        io::ErrorKind::Other,\n+        &format!(\"failed to lookup address information: {}\", detail)[..],\n+    ))\n }\n \n impl Socket {\n@@ -67,7 +66,7 @@ impl Socket {\n     }\n \n     pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n-            unimplemented!();\n+        unimplemented!();\n     }\n \n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n@@ -85,15 +84,13 @@ impl Socket {\n             Err(e) => return Err(e),\n         }\n \n-        let mut pollfd = libc::pollfd {\n-            fd: self.0.raw(),\n-            events: libc::POLLOUT,\n-            revents: 0,\n-        };\n+        let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"cannot set a 0 duration timeout\"));\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"cannot set a 0 duration timeout\",\n+            ));\n         }\n \n         let start = Instant::now();\n@@ -105,7 +102,8 @@ impl Socket {\n             }\n \n             let timeout = timeout - elapsed;\n-            let mut timeout = timeout.as_secs()\n+            let mut timeout = timeout\n+                .as_secs()\n                 .saturating_mul(1_000)\n                 .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n             if timeout == 0 {\n@@ -126,10 +124,9 @@ impl Socket {\n                     // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n                     // for POLLHUP rather than read readiness\n                     if pollfd.revents & libc::POLLHUP != 0 {\n-                        let e = self.take_error()?\n-                            .unwrap_or_else(|| {\n-                                io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n-                            });\n+                        let e = self.take_error()?.unwrap_or_else(|| {\n+                            io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n+                        });\n                         return Err(e);\n                     }\n \n@@ -139,11 +136,8 @@ impl Socket {\n         }\n     }\n \n-    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n-                  -> io::Result<Socket> {\n-        let fd = cvt_r(|| unsafe {\n-            libc::accept(self.0.raw(), storage, len)\n-        })?;\n+    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n+        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n         let fd = FileDesc::new(fd);\n         fd.set_cloexec()?;\n         Ok(Socket(fd))\n@@ -155,10 +149,7 @@ impl Socket {\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::recv(self.0.raw(),\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       buf.len(),\n-                       flags)\n+            libc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n         })?;\n         Ok(ret as usize)\n     }\n@@ -175,18 +166,23 @@ impl Socket {\n         self.0.read_vectored(bufs)\n     }\n \n-    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n-                            -> io::Result<(usize, SocketAddr)> {\n+    fn recv_from_with_flags(\n+        &self,\n+        buf: &mut [u8],\n+        flags: c_int,\n+    ) -> io::Result<(usize, SocketAddr)> {\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n \n         let n = cvt(unsafe {\n-            libc::recvfrom(self.0.raw(),\n-                        buf.as_mut_ptr() as *mut c_void,\n-                        buf.len(),\n-                        flags,\n-                        &mut storage as *mut _ as *mut _,\n-                        &mut addrlen)\n+            libc::recvfrom(\n+                self.0.raw(),\n+                buf.as_mut_ptr() as *mut c_void,\n+                buf.len(),\n+                flags,\n+                &mut storage as *mut _ as *mut _,\n+                &mut addrlen,\n+            )\n         })?;\n         Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n     }\n@@ -211,8 +207,10 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                              \"cannot set a 0 duration timeout\"));\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::InvalidInput,\n+                        \"cannot set a 0 duration timeout\",\n+                    ));\n                 }\n \n                 let secs = if dur.as_secs() > libc::time_t::max_value() as u64 {\n@@ -229,12 +227,7 @@ impl Socket {\n                 }\n                 timeout\n             }\n-            None => {\n-                libc::timeval {\n-                    tv_sec: 0,\n-                    tv_usec: 0,\n-                }\n-            }\n+            None => libc::timeval { tv_sec: 0, tv_usec: 0 },\n         };\n         setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n     }\n@@ -276,24 +269,26 @@ impl Socket {\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n-        if raw == 0 {\n-            Ok(None)\n-        } else {\n-            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n-        }\n+        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n     }\n }\n \n impl AsInner<c_int> for Socket {\n-    fn as_inner(&self) -> &c_int { self.0.as_inner() }\n+    fn as_inner(&self) -> &c_int {\n+        self.0.as_inner()\n+    }\n }\n \n impl FromInner<c_int> for Socket {\n-    fn from_inner(fd: c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+    fn from_inner(fd: c_int) -> Socket {\n+        Socket(FileDesc::new(fd))\n+    }\n }\n \n impl IntoInner<c_int> for Socket {\n-    fn into_inner(self) -> c_int { self.0.into_raw() }\n+    fn into_inner(self) -> c_int {\n+        self.0.into_raw()\n+    }\n }\n \n // In versions of glibc prior to 2.26, there's a bug where the DNS resolver\n@@ -314,7 +309,7 @@ impl IntoInner<c_int> for Socket {\n // believe it's thread-safe).\n #[cfg(target_env = \"gnu\")]\n fn on_resolver_failure() {\n-/*\n+    /*\n     use crate::sys;\n \n     // If the version fails to parse, we treat it the same as \"not glibc\"."}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/vxworks/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "b72a6554551579b8dc0516ea00047205fbf9d0e2", "filename": "src/libstd/sys/vxworks/pipe.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n-use libc::{self /*, c_int apparently not used? */};\n use crate::mem;\n-use crate::sync::atomic::{AtomicBool};\n+use crate::sync::atomic::AtomicBool;\n use crate::sys::fd::FileDesc;\n use crate::sys::{cvt, cvt_r};\n+use libc::{self /*, c_int apparently not used? */};\n \n pub struct AnonPipe(FileDesc);\n \n@@ -25,29 +25,29 @@ impl AnonPipe {\n         self.0.read(buf)\n     }\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-                self.0.read_vectored(bufs)\n-        }\n+        self.0.read_vectored(bufs)\n+    }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n \n-        pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-                self.0.write_vectored(bufs)\n-        }\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n \n-    pub fn fd(&self) -> &FileDesc { &self.0 }\n-    pub fn into_fd(self) -> FileDesc { self.0 }\n+    pub fn fd(&self) -> &FileDesc {\n+        &self.0\n+    }\n+    pub fn into_fd(self) -> FileDesc {\n+        self.0\n+    }\n     pub fn diverge(&self) -> ! {\n         panic!()\n-     }\n+    }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             v1: &mut Vec<u8>,\n-             p2: AnonPipe,\n-             v2: &mut Vec<u8>) -> io::Result<()> {\n-\n+pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n     // Set both pipes into nonblocking mode as we're gonna be reading from both\n     // in the `select` loop below, and we wouldn't want one to block the other!\n     let p1 = p1.into_fd();\n@@ -83,8 +83,9 @@ pub fn read2(p1: AnonPipe,\n         match fd.read_to_end(dst) {\n             Ok(_) => Ok(true),\n             Err(e) => {\n-                if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n-                   e.raw_os_error() == Some(libc::EAGAIN) {\n+                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n+                    || e.raw_os_error() == Some(libc::EAGAIN)\n+                {\n                     Ok(false)\n                 } else {\n                     Err(e)"}, {"sha": "c59782ff44b0bc27c00e3c9b850e26d37785c142", "filename": "src/libstd/sys/vxworks/process/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,4 +1,4 @@\n-pub use self::process_common::{Command, ExitStatus, ExitCode, Stdio, StdioPipes};\n+pub use self::process_common::{Command, ExitCode, ExitStatus, Stdio, StdioPipes};\n pub use self::process_inner::Process;\n pub use crate::ffi::OsString as EnvKey;\n "}, {"sha": "a8139a27537a973611a6abe0eeea927118872b1d", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,16 +1,16 @@\n use crate::os::unix::prelude::*;\n \n-use crate::ffi::{OsString, OsStr, CString, CStr};\n+use crate::collections::BTreeMap;\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::ptr;\n use crate::sys::fd::FileDesc;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys_common::process::CommandEnv;\n-use crate::collections::BTreeMap;\n \n-use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n+use libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -150,10 +150,7 @@ impl Command {\n         &mut self.closures\n     }\n \n-    pub unsafe fn pre_exec(\n-        &mut self,\n-        _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n-    ) {\n+    pub unsafe fn pre_exec(&mut self, _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n         // Fork() is not supported in vxWorks so no way to run the closure in the new procecss.\n         unimplemented!();\n     }\n@@ -183,26 +180,21 @@ impl Command {\n         self.env.have_changed_path()\n     }\n \n-    pub fn setup_io(&self, default: Stdio, needs_stdin: bool)\n-                -> io::Result<(StdioPipes, ChildPipes)> {\n+    pub fn setup_io(\n+        &self,\n+        default: Stdio,\n+        needs_stdin: bool,\n+    ) -> io::Result<(StdioPipes, ChildPipes)> {\n         let null = Stdio::Null;\n-        let default_stdin = if needs_stdin {&default} else {&null};\n+        let default_stdin = if needs_stdin { &default } else { &null };\n         let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n         let stdout = self.stdout.as_ref().unwrap_or(&default);\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n         let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n         let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n         let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n-        let ours = StdioPipes {\n-            stdin: our_stdin,\n-            stdout: our_stdout,\n-            stderr: our_stderr,\n-        };\n-        let theirs = ChildPipes {\n-            stdin: their_stdin,\n-            stdout: their_stdout,\n-            stderr: their_stderr,\n-        };\n+        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n+        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n         Ok((ours, theirs))\n     }\n }\n@@ -217,21 +209,21 @@ fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n // Helper type to manage ownership of the strings within a C-style array.\n pub struct CStringArray {\n     items: Vec<CString>,\n-    ptrs: Vec<*const c_char>\n+    ptrs: Vec<*const c_char>,\n }\n \n impl CStringArray {\n     pub fn with_capacity(capacity: usize) -> Self {\n         let mut result = CStringArray {\n             items: Vec::with_capacity(capacity),\n-            ptrs: Vec::with_capacity(capacity+1)\n+            ptrs: Vec::with_capacity(capacity + 1),\n         };\n         result.ptrs.push(ptr::null());\n         result\n     }\n     pub fn push(&mut self, item: CString) {\n         let l = self.ptrs.len();\n-        self.ptrs[l-1] = item.as_ptr();\n+        self.ptrs[l - 1] = item.as_ptr();\n         self.ptrs.push(ptr::null());\n         self.items.push(item);\n     }\n@@ -262,12 +254,9 @@ fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStr\n }\n \n impl Stdio {\n-    pub fn to_child_stdio(&self, readable: bool)\n-                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n         match *self {\n-            Stdio::Inherit => {\n-                Ok((ChildStdio::Inherit, None))\n-            },\n+            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n \n             // Make sure that the source descriptors are not an stdio\n             // descriptor, otherwise the order which we set the child's\n@@ -286,21 +275,15 @@ impl Stdio {\n \n             Stdio::MakePipe => {\n                 let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if readable {\n-                    (writer, reader)\n-                } else {\n-                    (reader, writer)\n-                };\n+                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                 Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n             }\n \n             Stdio::Null => {\n                 let mut opts = OpenOptions::new();\n                 opts.read(readable);\n                 opts.write(!readable);\n-                let path = unsafe {\n-                    CStr::from_ptr(\"/null\\0\".as_ptr() as *const _)\n-                };\n+                let path = unsafe { CStr::from_ptr(\"/null\\0\".as_ptr() as *const _) };\n                 let fd = File::open_c(&path, &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n@@ -350,7 +333,8 @@ impl ExitStatus {\n     }\n \n     fn exited(&self) -> bool {\n-        /*unsafe*/ { libc::WIFEXITED(self.0) }\n+        /*unsafe*/\n+        { libc::WIFEXITED(self.0) }\n     }\n \n     pub fn success(&self) -> bool {"}, {"sha": "87ebd2c9593fc936a10fd699ecb3346aad22ea9d", "filename": "src/libstd/sys/vxworks/rand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -4,17 +4,16 @@ use crate::slice;\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut v = (0, 0);\n     unsafe {\n-        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8,\n-                                             mem::size_of_val(&v));\n+        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8, mem::size_of_val(&v));\n         imp::fill_bytes(view);\n     }\n-    return v\n+    return v;\n }\n \n mod imp {\n-    use libc;\n     use crate::io;\n     use core::sync::atomic::{AtomicBool, Ordering::Relaxed};\n+    use libc;\n \n     pub fn fill_bytes(v: &mut [u8]) {\n         static RNG_INIT: AtomicBool = AtomicBool::new(false);"}, {"sha": "fd2e1a6e7bcfb99311ac2d4a9d50ce1c3e8e279a", "filename": "src/libstd/sys/vxworks/rwlock.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,6 +1,6 @@\n-use libc;\n use crate::cell::UnsafeCell;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n+use libc;\n \n pub struct RWLock {\n     inner: UnsafeCell<libc::pthread_rwlock_t>,\n@@ -29,7 +29,7 @@ impl RWLock {\n             if r == 0 {\n                 self.raw_unlock();\n             }\n-        panic!(\"rwlock read lock would result in deadlock\");\n+            panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n             self.num_readers.fetch_add(1, Ordering::Relaxed);\n@@ -57,12 +57,14 @@ impl RWLock {\n         let r = libc::pthread_rwlock_wrlock(self.inner.get());\n         // See comments above for why we check for EDEADLK and write_locked. We\n         // also need to check that num_readers is 0.\n-        if r == libc::EDEADLK || *self.write_locked.get() ||\n-            self.num_readers.load(Ordering::Relaxed) != 0 {\n+        if r == libc::EDEADLK\n+            || *self.write_locked.get()\n+            || self.num_readers.load(Ordering::Relaxed) != 0\n+        {\n             if r == 0 {\n                 self.raw_unlock();\n             }\n-        panic!(\"rwlock write lock would result in deadlock\");\n+            panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n         }\n@@ -80,8 +82,8 @@ impl RWLock {\n                 *self.write_locked.get() = true;\n                 true\n             }\n-            } else {\n-                false\n+        } else {\n+            false\n         }\n     }\n \n@@ -98,7 +100,7 @@ impl RWLock {\n         self.raw_unlock();\n     }\n \n-     #[inline]\n+    #[inline]\n     pub unsafe fn write_unlock(&self) {\n         debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n         debug_assert!(*self.write_locked.get());"}, {"sha": "7b58c83193bf3579d484798a21d6c125a378d6d9", "filename": "src/libstd/sys/vxworks/stack_overflow.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,12 +1,12 @@\n #![cfg_attr(test, allow(dead_code))]\n \n-use self::imp::{make_handler, drop_handler};\n+use self::imp::{drop_handler, make_handler};\n \n pub use self::imp::cleanup;\n pub use self::imp::init;\n \n pub struct Handler {\n-    _data: *mut libc::c_void\n+    _data: *mut libc::c_void,\n }\n \n impl Handler {\n@@ -26,16 +26,13 @@ impl Drop for Handler {\n mod imp {\n     use crate::ptr;\n \n-    pub unsafe fn init() {\n-    }\n+    pub unsafe fn init() {}\n \n-    pub unsafe fn cleanup() {\n-    }\n+    pub unsafe fn cleanup() {}\n \n     pub unsafe fn make_handler() -> super::Handler {\n         super::Handler { _data: ptr::null_mut() }\n     }\n \n-    pub unsafe fn drop_handler(_handler: &mut super::Handler) {\n-    }\n+    pub unsafe fn drop_handler(_handler: &mut super::Handler) {}\n }"}, {"sha": "622444ccafd3cd0d97d4426b8e515951b82d1c77", "filename": "src/libstd/sys/vxworks/stdio.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,7 +6,9 @@ pub struct Stdout(());\n pub struct Stderr(());\n \n impl Stdin {\n-    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin(()))\n+    }\n }\n \n impl io::Read for Stdin {\n@@ -19,7 +21,9 @@ impl io::Read for Stdin {\n }\n \n impl Stdout {\n-    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout(()))\n+    }\n }\n \n impl io::Write for Stdout {\n@@ -36,7 +40,9 @@ impl io::Write for Stdout {\n }\n \n impl Stderr {\n-    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr(()))\n+    }\n }\n \n impl io::Write for Stderr {"}, {"sha": "e0d104b5f3ec938a6fd3c6e934c52cb09478df98", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -21,24 +21,24 @@ unsafe impl Sync for Thread {}\n \n // The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n // so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n-unsafe fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                    stack_size: libc::size_t) -> libc::c_int {\n+unsafe fn pthread_attr_setstacksize(\n+    attr: *mut libc::pthread_attr_t,\n+    stack_size: libc::size_t,\n+) -> libc::c_int {\n     libc::pthread_attr_setstacksize(attr, stack_size)\n }\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n-                          -> io::Result<Thread> {\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         let p = box p;\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n \n-        match pthread_attr_setstacksize(&mut attr,\n-                                        stack_size) {\n+        match pthread_attr_setstacksize(&mut attr, stack_size) {\n             0 => {}\n             n => {\n                 assert_eq!(n, libc::EINVAL);\n@@ -47,15 +47,13 @@ impl Thread {\n                 // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                 // Round up to the nearest page and try again.\n                 let page_size = os::page_size();\n-                let stack_size = (stack_size + page_size - 1) &\n-                                 (-(page_size as isize - 1) as usize - 1);\n-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr,\n-                                                           stack_size), 0);\n+                let stack_size =\n+                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n+                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start,\n-                                       &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n@@ -65,8 +63,10 @@ impl Thread {\n             Ok(Thread { id: native })\n         };\n \n-        extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n-            unsafe { start_thread(main as *mut u8); }\n+        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n             ptr::null_mut()\n         }\n     }\n@@ -108,12 +108,13 @@ impl Thread {\n         unsafe {\n             let ret = libc::pthread_join(self.id, ptr::null_mut());\n             mem::forget(self);\n-            assert!(ret == 0,\n-                    \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n+            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n         }\n     }\n \n-    pub fn id(&self) -> libc::pthread_t { self.id }\n+    pub fn id(&self) -> libc::pthread_t {\n+        self.id\n+    }\n \n     pub fn into_id(self) -> libc::pthread_t {\n         let id = self.id;\n@@ -133,8 +134,12 @@ impl Drop for Thread {\n pub mod guard {\n     use crate::ops::Range;\n     pub type Guard = Range<usize>;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n     pub unsafe fn deinit() {}\n }\n "}, {"sha": "2c5b94b1e61e5710717363d92396c6b5e1027305", "filename": "src/libstd/sys/vxworks/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -5,7 +5,7 @@ use crate::mem;\n pub type Key = libc::pthread_key_t;\n \n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n     assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n     key"}, {"sha": "8ebbf89213f321bfbdf27111ec4e3d86a57a0ef5", "filename": "src/libstd/sys/vxworks/time.rs", "status": "modified", "additions": 28, "deletions": 53, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n use crate::cmp::Ordering;\n-use libc;\n use crate::time::Duration;\n use ::core::hash::{Hash, Hasher};\n+use libc;\n \n pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n use crate::convert::TryInto;\n@@ -15,20 +15,21 @@ struct Timespec {\n \n impl Timespec {\n     const fn zero() -> Timespec {\n-        Timespec {\n-            t: libc::timespec { tv_sec: 0, tv_nsec: 0 },\n-        }\n+        Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } }\n     }\n     fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n         if self >= other {\n             Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n-                                (self.t.tv_nsec - other.t.tv_nsec) as u32)\n-                } else {\n-                    Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                        self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n-                        other.t.tv_nsec as u32)\n-                })\n+                Duration::new(\n+                    (self.t.tv_sec - other.t.tv_sec) as u64,\n+                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n+                )\n+            } else {\n+                Duration::new(\n+                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n+                )\n+            })\n         } else {\n             match other.sub_timespec(self) {\n                 Ok(d) => Err(d),\n@@ -51,12 +52,7 @@ impl Timespec {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n         }\n-        Some(Timespec {\n-            t: libc::timespec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as _,\n-            },\n-        })\n+        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n     }\n \n     fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n@@ -72,12 +68,7 @@ impl Timespec {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n         }\n-        Some(Timespec {\n-            t: libc::timespec {\n-                tv_sec: secs,\n-                tv_nsec: nsec as _,\n-            },\n-        })\n+        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n     }\n }\n \n@@ -104,16 +95,16 @@ impl Ord for Timespec {\n }\n \n impl Hash for Timespec {\n-    fn hash<H : Hasher>(&self, state: &mut H) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         self.t.tv_sec.hash(state);\n         self.t.tv_nsec.hash(state);\n     }\n }\n mod inner {\n     use crate::fmt;\n-    use libc;\n     use crate::sys::cvt;\n     use crate::time::Duration;\n+    use libc;\n \n     use super::Timespec;\n \n@@ -127,24 +118,16 @@ mod inner {\n         t: Timespec,\n     }\n \n-    pub const UNIX_EPOCH: SystemTime = SystemTime {\n-        t: Timespec {\n-            t: libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 0,\n-            },\n-        },\n-    };\n+    pub const UNIX_EPOCH: SystemTime =\n+        SystemTime { t: Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } } };\n \n     impl Instant {\n         pub fn now() -> Instant {\n             Instant { t: now(libc::CLOCK_MONOTONIC) }\n         }\n \n         pub const fn zero() -> Instant {\n-            Instant {\n-                t: Timespec::zero(),\n-            }\n+            Instant { t: Timespec::zero() }\n         }\n \n         pub fn actually_monotonic() -> bool {\n@@ -167,9 +150,9 @@ mod inner {\n     impl fmt::Debug for Instant {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"Instant\")\n-             .field(\"tv_sec\", &self.t.t.tv_sec)\n-             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-             .finish()\n+                .field(\"tv_sec\", &self.t.t.tv_sec)\n+                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+                .finish()\n         }\n     }\n \n@@ -178,8 +161,7 @@ mod inner {\n             SystemTime { t: now(libc::CLOCK_REALTIME) }\n         }\n \n-        pub fn sub_time(&self, other: &SystemTime)\n-                        -> Result<Duration, Duration> {\n+        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n             self.t.sub_timespec(&other.t)\n         }\n \n@@ -201,24 +183,17 @@ mod inner {\n     impl fmt::Debug for SystemTime {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"SystemTime\")\n-             .field(\"tv_sec\", &self.t.t.tv_sec)\n-             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-             .finish()\n+                .field(\"tv_sec\", &self.t.t.tv_sec)\n+                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+                .finish()\n         }\n     }\n \n     pub type clock_t = libc::c_int;\n \n     fn now(clock: clock_t) -> Timespec {\n-        let mut t = Timespec {\n-            t: libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 0,\n-            }\n-        };\n-        cvt(unsafe {\n-            libc::clock_gettime(clock, &mut t.t)\n-        }).unwrap();\n+        let mut t = Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } };\n+        cvt(unsafe { libc::clock_gettime(clock, &mut t.t) }).unwrap();\n         t\n     }\n }"}, {"sha": "4c6fddefd3f84c938e2a1ff2a6ffad202022e421", "filename": "src/libstd/sys/vxworks/weak.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -29,11 +29,7 @@ pub struct Weak<F> {\n \n impl<F> Weak<F> {\n     pub const fn new(name: &'static str) -> Weak<F> {\n-        Weak {\n-            name,\n-            addr: AtomicUsize::new(1),\n-            _marker: marker::PhantomData,\n-        }\n+        Weak { name, addr: AtomicUsize::new(1), _marker: marker::PhantomData }\n     }\n \n     pub fn get(&self) -> Option<F> {\n@@ -56,5 +52,5 @@ unsafe fn fetch(name: &str) -> usize {\n         Err(..) => return 0,\n     };\n     assert!(false, \"FIXME: fetch\");\n-   libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n+    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n }"}, {"sha": "e9760d050e105fbe04e9d5ff315152c711607fd3", "filename": "src/libstd/sys/wasi/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Falloc.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,6 +1,6 @@\n use crate::alloc::{GlobalAlloc, Layout, System};\n use crate::ptr;\n-use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n use libc;\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]"}, {"sha": "5f8b1cbfa0b5314a37a4355318a52996a84ad344", "filename": "src/libstd/sys/wasi/ext/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -7,12 +7,16 @@ pub mod io;\n /// Includes all extension traits, and some important type definitions.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use crate::sys::ext::ffi::{OsStringExt, OsStrExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use crate::sys::ext::fs::{FileExt, DirEntryExt, MetadataExt, OpenOptionsExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use crate::sys::ext::fs::FileTypeExt;\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use crate::sys::ext::io::{AsRawFd, IntoRawFd, FromRawFd};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::fs::{DirEntryExt, FileExt, MetadataExt, OpenOptionsExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::io::{AsRawFd, FromRawFd, IntoRawFd};\n }"}, {"sha": "8a69028ff1dcf42e2bb01b399fb0ec5da36cb3ff", "filename": "src/libstd/sys/wasi/net.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fnet.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,11 +1,11 @@\n+use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n-use crate::time::Duration;\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n+use crate::sys::fd::WasiFd;\n use crate::sys::{unsupported, Void};\n-use crate::convert::TryFrom;\n-use crate::sys::fd::{WasiFd};\n use crate::sys_common::FromInner;\n+use crate::time::Duration;\n \n pub struct TcpStream {\n     fd: WasiFd,\n@@ -107,24 +107,18 @@ impl TcpStream {\n \n impl FromInner<u32> for TcpStream {\n     fn from_inner(fd: u32) -> TcpStream {\n-        unsafe {\n-            TcpStream {\n-                fd: WasiFd::from_raw(fd),\n-            }\n-        }\n+        unsafe { TcpStream { fd: WasiFd::from_raw(fd) } }\n     }\n }\n \n impl fmt::Debug for TcpStream {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TcpStream\")\n-            .field(\"fd\", &self.fd.as_raw())\n-            .finish()\n+        f.debug_struct(\"TcpStream\").field(\"fd\", &self.fd.as_raw()).finish()\n     }\n }\n \n pub struct TcpListener {\n-    fd: WasiFd\n+    fd: WasiFd,\n }\n \n impl TcpListener {\n@@ -179,19 +173,13 @@ impl TcpListener {\n \n impl FromInner<u32> for TcpListener {\n     fn from_inner(fd: u32) -> TcpListener {\n-        unsafe {\n-            TcpListener {\n-                fd: WasiFd::from_raw(fd),\n-            }\n-        }\n+        unsafe { TcpListener { fd: WasiFd::from_raw(fd) } }\n     }\n }\n \n impl fmt::Debug for TcpListener {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TcpListener\")\n-            .field(\"fd\", &self.fd.as_raw())\n-            .finish()\n+        f.debug_struct(\"TcpListener\").field(\"fd\", &self.fd.as_raw()).finish()\n     }\n }\n \n@@ -276,23 +264,19 @@ impl UdpSocket {\n         unsupported()\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         unsupported()\n     }\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         unsupported()\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         unsupported()\n     }\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         unsupported()\n     }\n \n@@ -339,19 +323,13 @@ impl UdpSocket {\n \n impl FromInner<u32> for UdpSocket {\n     fn from_inner(fd: u32) -> UdpSocket {\n-        unsafe {\n-            UdpSocket {\n-                fd: WasiFd::from_raw(fd),\n-            }\n-        }\n+        unsafe { UdpSocket { fd: WasiFd::from_raw(fd) } }\n     }\n }\n \n impl fmt::Debug for UdpSocket {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"UdpSocket\")\n-            .field(\"fd\", &self.fd.as_raw())\n-            .finish()\n+        f.debug_struct(\"UdpSocket\").field(\"fd\", &self.fd.as_raw()).finish()\n     }\n }\n \n@@ -419,8 +397,7 @@ pub mod netc {\n     }\n \n     #[derive(Copy, Clone)]\n-    pub struct sockaddr {\n-    }\n+    pub struct sockaddr {}\n \n     pub type socklen_t = usize;\n }"}, {"sha": "338fbe89765149636c1d6f302d742bcfea083e7c", "filename": "src/libstd/sys/wasi/os.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,6 +1,6 @@\n use crate::any::Any;\n use crate::error::Error as StdError;\n-use crate::ffi::{OsString, OsStr, CString, CStr};\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n@@ -19,7 +19,7 @@ pub unsafe fn env_lock() -> impl Any {\n }\n \n pub fn errno() -> i32 {\n-    extern {\n+    extern \"C\" {\n         #[thread_local]\n         static errno: libc::c_int;\n     }\n@@ -64,7 +64,9 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     Err(JoinPathsError)\n }\n@@ -91,11 +93,14 @@ pub struct Env {\n \n impl Iterator for Env {\n     type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n-\n pub fn env() -> Env {\n     unsafe {\n         let _guard = env_lock();\n@@ -107,10 +112,7 @@ pub fn env() -> Env {\n             }\n             environ = environ.offset(1);\n         }\n-        return Env {\n-            iter: result.into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        }\n+        return Env { iter: result.into_iter(), _dont_send_or_sync_me: PhantomData };\n     }\n \n     // See src/libstd/sys/unix/os.rs, same as that\n@@ -119,10 +121,12 @@ pub fn env() -> Env {\n             return None;\n         }\n         let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n-        pos.map(|p| (\n-            OsStringExt::from_vec(input[..p].to_vec()),\n-            OsStringExt::from_vec(input[p+1..].to_vec()),\n-        ))\n+        pos.map(|p| {\n+            (\n+                OsStringExt::from_vec(input[..p].to_vec()),\n+                OsStringExt::from_vec(input[p + 1..].to_vec()),\n+            )\n+        })\n     }\n }\n \n@@ -168,9 +172,7 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(code: i32) -> ! {\n-    unsafe {\n-        libc::exit(code)\n-    }\n+    unsafe { libc::exit(code) }\n }\n \n pub fn getpid() -> u32 {\n@@ -193,9 +195,5 @@ macro_rules! impl_is_minus_one {\n impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n-    if t.is_minus_one() {\n-        Err(io::Error::last_os_error())\n-    } else {\n-        Ok(t)\n-    }\n+    if t.is_minus_one() { Err(io::Error::last_os_error()) } else { Ok(t) }\n }"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/wasi/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fpath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "fb14dc591018116ea405550f4697f60378b2d7e8", "filename": "src/libstd/sys/wasi/pipe.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fpipe.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -25,9 +25,6 @@ impl AnonPipe {\n     }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             _v1: &mut Vec<u8>,\n-             _p2: AnonPipe,\n-             _v2: &mut Vec<u8>) -> io::Result<()> {\n+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n     match p1.0 {}\n }"}, {"sha": "7156c9ab92f2b6af3da9699a3618f76275280af1", "filename": "src/libstd/sys/wasi/process.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -13,7 +13,7 @@ pub use crate::ffi::OsString as EnvKey;\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Command {\n-    env: CommandEnv\n+    env: CommandEnv,\n }\n \n // passed back to std::process with the pipes connected to the child, if any\n@@ -32,32 +32,28 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default()\n-        }\n+        Command { env: Default::default() }\n     }\n \n-    pub fn arg(&mut self, _arg: &OsStr) {\n-    }\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n \n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n-    pub fn cwd(&mut self, _dir: &OsStr) {\n-    }\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n \n-    pub fn stdin(&mut self, _stdin: Stdio) {\n-    }\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n \n-    pub fn stdout(&mut self, _stdout: Stdio) {\n-    }\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n \n-    pub fn stderr(&mut self, _stderr: Stdio) {\n-    }\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n \n-    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n-        -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         unsupported()\n     }\n }\n@@ -106,8 +102,7 @@ impl PartialEq for ExitStatus {\n     }\n }\n \n-impl Eq for ExitStatus {\n-}\n+impl Eq for ExitStatus {}\n \n impl fmt::Debug for ExitStatus {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "3b6557ae3257f73b1497af9e1ddbd858c39664aa", "filename": "src/libstd/sys/wasm/args.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,14 +6,10 @@ pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n     // On wasm these should always be null, so there's nothing for us to do here\n }\n \n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}\n \n pub fn args() -> Args {\n-    Args {\n-        iter: Vec::new().into_iter(),\n-        _dont_send_or_sync_me: PhantomData,\n-    }\n+    Args { iter: Vec::new().into_iter(), _dont_send_or_sync_me: PhantomData }\n }\n \n pub struct Args {"}, {"sha": "304cf906b2aeadba92007440bb5628e3c9ed8184", "filename": "src/libstd/sys/wasm/cmath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n // These symbols are all defined in `compiler-builtins`\n-extern {\n+extern \"C\" {\n     pub fn acos(n: f64) -> f64;\n     pub fn acosf(n: f32) -> f32;\n     pub fn asin(n: f64) -> f64;"}, {"sha": "e6160d1457d269176ba95e96409b6eda799d4bb7", "filename": "src/libstd/sys/wasm/fs.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::io::{self, SeekFrom, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sys::time::SystemTime;\n use crate::sys::{unsupported, Void};\n@@ -15,14 +15,14 @@ pub struct ReadDir(Void);\n pub struct DirEntry(Void);\n \n #[derive(Clone, Debug)]\n-pub struct OpenOptions { }\n+pub struct OpenOptions {}\n \n pub struct FilePermissions(Void);\n \n pub struct FileType(Void);\n \n #[derive(Debug)]\n-pub struct DirBuilder { }\n+pub struct DirBuilder {}\n \n impl FileAttr {\n     pub fn size(&self) -> u64 {\n@@ -78,8 +78,7 @@ impl PartialEq for FilePermissions {\n     }\n }\n \n-impl Eq for FilePermissions {\n-}\n+impl Eq for FilePermissions {}\n \n impl fmt::Debug for FilePermissions {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -115,8 +114,7 @@ impl PartialEq for FileType {\n     }\n }\n \n-impl Eq for FileType {\n-}\n+impl Eq for FileType {}\n \n impl Hash for FileType {\n     fn hash<H: Hasher>(&self, _h: &mut H) {\n@@ -164,15 +162,15 @@ impl DirEntry {\n \n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n-        OpenOptions { }\n+        OpenOptions {}\n     }\n \n-    pub fn read(&mut self, _read: bool) { }\n-    pub fn write(&mut self, _write: bool) { }\n-    pub fn append(&mut self, _append: bool) { }\n-    pub fn truncate(&mut self, _truncate: bool) { }\n-    pub fn create(&mut self, _create: bool) { }\n-    pub fn create_new(&mut self, _create_new: bool) { }\n+    pub fn read(&mut self, _read: bool) {}\n+    pub fn write(&mut self, _write: bool) {}\n+    pub fn append(&mut self, _append: bool) {}\n+    pub fn truncate(&mut self, _truncate: bool) {}\n+    pub fn create(&mut self, _create: bool) {}\n+    pub fn create_new(&mut self, _create_new: bool) {}\n }\n \n impl File {\n@@ -235,7 +233,7 @@ impl File {\n \n impl DirBuilder {\n     pub fn new() -> DirBuilder {\n-        DirBuilder { }\n+        DirBuilder {}\n     }\n \n     pub fn mkdir(&self, _p: &Path) -> io::Result<()> {"}, {"sha": "b7c3108f172f608c743b79e5c64390791b3d471d", "filename": "src/libstd/sys/wasm/net.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n+use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n-use crate::time::Duration;\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::sys::{unsupported, Void};\n-use crate::convert::TryFrom;\n+use crate::time::Duration;\n \n pub struct TcpStream(Void);\n \n@@ -228,23 +228,19 @@ impl UdpSocket {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n         match self.0 {}\n     }\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n         match self.0 {}\n     }\n \n@@ -351,8 +347,7 @@ pub mod netc {\n     }\n \n     #[derive(Copy, Clone)]\n-    pub struct sockaddr {\n-    }\n+    pub struct sockaddr {}\n \n     pub type socklen_t = usize;\n }"}, {"sha": "193c3892743c480b53a59acefdab8b6f638fd8d4", "filename": "src/libstd/sys/wasm/os.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n use crate::error::Error as StdError;\n-use crate::ffi::{OsString, OsStr};\n+use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::path::{self, PathBuf};\n@@ -39,7 +39,9 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n     Err(JoinPathsError)\n }"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "src/libstd/sys/wasm/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,5 +1,5 @@\n-use crate::path::Prefix;\n use crate::ffi::OsStr;\n+use crate::path::Prefix;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {"}, {"sha": "fb14dc591018116ea405550f4697f60378b2d7e8", "filename": "src/libstd/sys/wasm/pipe.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -25,9 +25,6 @@ impl AnonPipe {\n     }\n }\n \n-pub fn read2(p1: AnonPipe,\n-             _v1: &mut Vec<u8>,\n-             _p2: AnonPipe,\n-             _v2: &mut Vec<u8>) -> io::Result<()> {\n+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n     match p1.0 {}\n }"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "src/libstd/sys/wasm/process.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -32,32 +32,28 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {\n-            env: Default::default()\n-        }\n+        Command { env: Default::default() }\n     }\n \n-    pub fn arg(&mut self, _arg: &OsStr) {\n-    }\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n \n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n-    pub fn cwd(&mut self, _dir: &OsStr) {\n-    }\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n \n-    pub fn stdin(&mut self, _stdin: Stdio) {\n-    }\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n \n-    pub fn stdout(&mut self, _stdout: Stdio) {\n-    }\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n \n-    pub fn stderr(&mut self, _stderr: Stdio) {\n-    }\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n \n-    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n-        -> io::Result<(Process, StdioPipes)> {\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n         unsupported()\n     }\n }\n@@ -106,8 +102,7 @@ impl PartialEq for ExitStatus {\n     }\n }\n \n-impl Eq for ExitStatus {\n-}\n+impl Eq for ExitStatus {}\n \n impl fmt::Debug for ExitStatus {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "cbf62b6e5b7e36eb108b76a699316304ae221026", "filename": "src/libstd/sys/wasm/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -6,8 +6,6 @@ impl Handler {\n     }\n }\n \n-pub unsafe fn init() {\n-}\n+pub unsafe fn init() {}\n \n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}"}, {"sha": "0e0e78a827670bfb265b13165be10a37ad94a82e", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -9,9 +9,7 @@ pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         unsupported()\n     }\n \n@@ -55,8 +53,12 @@ impl Thread {\n \n pub mod guard {\n     pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }\n \n // This is only used by atomics primitives when the `atomics` feature is\n@@ -84,9 +86,7 @@ pub fn my_id() -> u32 {\n         if MY_ID == 0 {\n             let mut cur = NEXT_ID.load(SeqCst);\n             MY_ID = loop {\n-                let next = cur.checked_add(1).unwrap_or_else(|| {\n-                    crate::arch::wasm32::unreachable()\n-                });\n+                let next = cur.checked_add(1).unwrap_or_else(|| crate::arch::wasm32::unreachable());\n                 match NEXT_ID.compare_exchange(cur, next, SeqCst, SeqCst) {\n                     Ok(_) => break next,\n                     Err(i) => cur = i,"}, {"sha": "f8be9863ed56f69713e88c98fdfd8b4a6037f2e6", "filename": "src/libstd/sys/wasm/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,7 +1,7 @@\n pub type Key = usize;\n \n #[inline]\n-pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+pub unsafe fn create(_dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     panic!(\"should not be used on the wasm target\");\n }\n "}, {"sha": "d9edc7fdc44518205c86ee6d929619ffc3de7f0c", "filename": "src/libstd/sys/wasm/time.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -39,8 +39,7 @@ impl SystemTime {\n         panic!(\"time not implemented on wasm32-unknown-unknown\")\n     }\n \n-    pub fn sub_time(&self, other: &SystemTime)\n-                    -> Result<Duration, Duration> {\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n         self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n     }\n "}, {"sha": "99b4d6c72a0e3e036e78a9d83e61594df833ebe8", "filename": "src/libstd/sys/windows/alloc.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,6 +1,6 @@\n use crate::alloc::{GlobalAlloc, Layout, System};\n use crate::sys::c;\n-use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n #[repr(C)]\n struct Header(*mut u8);\n@@ -18,16 +18,12 @@ unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n #[inline]\n unsafe fn allocate_with_flags(layout: Layout, flags: c::DWORD) -> *mut u8 {\n     if layout.align() <= MIN_ALIGN {\n-        return c::HeapAlloc(c::GetProcessHeap(), flags, layout.size()) as *mut u8\n+        return c::HeapAlloc(c::GetProcessHeap(), flags, layout.size()) as *mut u8;\n     }\n \n     let size = layout.size() + layout.align();\n     let ptr = c::HeapAlloc(c::GetProcessHeap(), flags, size);\n-    if ptr.is_null() {\n-        ptr as *mut u8\n-    } else {\n-        align_ptr(ptr as *mut u8, layout.align())\n-    }\n+    if ptr.is_null() { ptr as *mut u8 } else { align_ptr(ptr as *mut u8, layout.align()) }\n }\n \n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n@@ -46,13 +42,11 @@ unsafe impl GlobalAlloc for System {\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         if layout.align() <= MIN_ALIGN {\n             let err = c::HeapFree(c::GetProcessHeap(), 0, ptr as c::LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                          c::GetLastError());\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n         } else {\n             let header = get_header(ptr);\n             let err = c::HeapFree(c::GetProcessHeap(), 0, header.0 as c::LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                          c::GetLastError());\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n         }\n     }\n "}, {"sha": "5fbea2a2910174c32c8ab9aacb71a00abb8b4712", "filename": "src/libstd/sys/windows/args.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,26 +1,26 @@\n #![allow(dead_code)] // runtime init functions not used during testing\n \n-use crate::os::windows::prelude::*;\n-use crate::sys::windows::os::current_exe;\n-use crate::sys::c;\n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::vec;\n-use crate::slice;\n+use crate::os::windows::prelude::*;\n use crate::path::PathBuf;\n+use crate::slice;\n+use crate::sys::c;\n+use crate::sys::windows::os::current_exe;\n+use crate::vec;\n \n use core::iter;\n \n-pub unsafe fn init(_argc: isize, _argv: *const *const u8) { }\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n \n-pub unsafe fn cleanup() { }\n+pub unsafe fn cleanup() {}\n \n pub fn args() -> Args {\n     unsafe {\n         let lp_cmd_line = c::GetCommandLineW();\n-        let parsed_args_list = parse_lp_cmd_line(\n-            lp_cmd_line as *const u16,\n-            || current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new()));\n+        let parsed_args_list = parse_lp_cmd_line(lp_cmd_line as *const u16, || {\n+            current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new())\n+        });\n \n         Args { parsed_args_list: parsed_args_list.into_iter() }\n     }\n@@ -40,8 +40,10 @@ pub fn args() -> Args {\n /// Windows 10 Pro v1803, using an exhaustive test suite available at\n /// <https://gist.github.com/notriddle/dde431930c392e428055b2dc22e638f5> or\n /// <https://paste.gg/p/anonymous/47d6ed5f5bd549168b1c69c799825223>.\n-unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_name: F)\n-                                                 -> Vec<OsString> {\n+unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(\n+    lp_cmd_line: *const u16,\n+    exe_name: F,\n+) -> Vec<OsString> {\n     const BACKSLASH: u16 = '\\\\' as u16;\n     const QUOTE: u16 = '\"' as u16;\n     const TAB: u16 = '\\t' as u16;\n@@ -84,7 +86,7 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n         0..=SPACE => {\n             ret_val.push(OsString::new());\n             &cmd_line[1..]\n-        },\n+        }\n         // The executable name ends at the next whitespace,\n         // no matter what.\n         _ => {\n@@ -112,7 +114,7 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n             BACKSLASH => {\n                 backslash_count += 1;\n                 was_in_quotes = false;\n-            },\n+            }\n             QUOTE if backslash_count % 2 == 0 => {\n                 cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n                 backslash_count = 0;\n@@ -171,30 +173,36 @@ impl<'a> fmt::Debug for ArgsInnerDebug<'a> {\n \n impl Args {\n     pub fn inner_debug(&self) -> ArgsInnerDebug<'_> {\n-        ArgsInnerDebug {\n-            args: self\n-        }\n+        ArgsInnerDebug { args: self }\n     }\n }\n \n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.parsed_args_list.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.parsed_args_list.size_hint() }\n+    fn next(&mut self) -> Option<OsString> {\n+        self.parsed_args_list.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.parsed_args_list.size_hint()\n+    }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.parsed_args_list.next_back() }\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.parsed_args_list.next_back()\n+    }\n }\n \n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.parsed_args_list.len() }\n+    fn len(&self) -> usize {\n+        self.parsed_args_list.len()\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::sys::windows::args::*;\n     use crate::ffi::OsString;\n+    use crate::sys::windows::args::*;\n \n     fn chk(string: &str, parts: &[&str]) {\n         let mut wide: Vec<u16> = OsString::from(string).encode_wide().collect();\n@@ -245,14 +253,14 @@ mod tests {\n         chk(r#\"EXE \"\" \"\"\"\"#, &[\"EXE\", \"\", \"\\\"\"]);\n         chk(\n             r#\"EXE \"this is \"\"\"all\"\"\" in the same argument\"\"#,\n-            &[\"EXE\", \"this is \\\"all\\\" in the same argument\"]\n+            &[\"EXE\", \"this is \\\"all\\\" in the same argument\"],\n         );\n         chk(r#\"EXE \"a\"\"\"#, &[\"EXE\", \"a\\\"\"]);\n         chk(r#\"EXE \"a\"\" a\"#, &[\"EXE\", \"a\\\"\", \"a\"]);\n         // quotes cannot be escaped in command names\n         chk(r#\"\"EXE\" check\"#, &[\"EXE\", \"check\"]);\n         chk(r#\"\"EXE check\"\"#, &[\"EXE check\"]);\n         chk(r#\"\"EXE \"\"\"for\"\"\" check\"#, &[\"EXE \", r#\"for\"\"#, \"check\"]);\n-        chk(r#\"\"EXE \\\"for\\\" check\"#, &[r#\"EXE \\\"#, r#\"for\"\"#,  \"check\"]);\n+        chk(r#\"\"EXE \\\"for\\\" check\"#, &[r#\"EXE \\\"#, r#\"for\"\"#, \"check\"]);\n     }\n }"}, {"sha": "7c5bfa1bd06410ff6fe339689864639aec9691af", "filename": "src/libstd/sys/windows/cmath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,9 +1,9 @@\n #![cfg(not(test))]\n \n-use libc::{c_float, c_double};\n+use libc::{c_double, c_float};\n \n #[link_name = \"m\"]\n-extern {\n+extern \"C\" {\n     pub fn acos(n: c_double) -> c_double;\n     pub fn asin(n: c_double) -> c_double;\n     pub fn atan(n: c_double) -> c_double;\n@@ -32,7 +32,7 @@ pub use self::shims::*;\n mod shims {\n     use libc::c_float;\n \n-    extern {\n+    extern \"C\" {\n         pub fn acosf(n: c_float) -> c_float;\n         pub fn asinf(n: c_float) -> c_float;\n         pub fn atan2f(a: c_float, b: c_float) -> c_float;"}, {"sha": "d6d433f9d086b0992d758d940ee7c653a862daa0", "filename": "src/libstd/sys/windows/compat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -28,8 +28,7 @@ pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n     }\n }\n \n-pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n-                  fallback: usize) -> usize {\n+pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str, fallback: usize) -> usize {\n     let value = lookup(module, symbol).unwrap_or(fallback);\n     ptr.store(value, Ordering::SeqCst);\n     value"}, {"sha": "6e78119383f43fe12899be0b2537457d022058c3", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -59,10 +59,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::ffi::{OsString, OsStr};\n+use crate::ffi::{OsStr, OsString};\n use crate::sys::os_str::Buf;\n use crate::sys_common::wtf8::Wtf8Buf;\n-use crate::sys_common::{FromInner, AsInner};\n+use crate::sys_common::{AsInner, FromInner};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::sys_common::wtf8::EncodeWide;"}, {"sha": "7eaff226a7654640f0d34b6d26611a95b2701b2f", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,11 +2,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::fs::{self, OpenOptions, Metadata};\n+use crate::fs::{self, Metadata, OpenOptions};\n use crate::io;\n use crate::path::Path;\n use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner};\n+use crate::sys_common::{AsInner, AsInnerMut};\n \n /// Windows-specific extensions to [`File`].\n ///\n@@ -265,23 +265,28 @@ pub trait OpenOptionsExt {\n #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n impl OpenOptionsExt for OpenOptions {\n     fn access_mode(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().access_mode(access); self\n+        self.as_inner_mut().access_mode(access);\n+        self\n     }\n \n     fn share_mode(&mut self, share: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().share_mode(share); self\n+        self.as_inner_mut().share_mode(share);\n+        self\n     }\n \n     fn custom_flags(&mut self, flags: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().custom_flags(flags); self\n+        self.as_inner_mut().custom_flags(flags);\n+        self\n     }\n \n     fn attributes(&mut self, attributes: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().attributes(attributes); self\n+        self.as_inner_mut().attributes(attributes);\n+        self\n     }\n \n     fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().security_qos_flags(flags); self\n+        self.as_inner_mut().security_qos_flags(flags);\n+        self\n     }\n }\n \n@@ -468,14 +473,30 @@ pub trait MetadataExt {\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n impl MetadataExt for Metadata {\n-    fn file_attributes(&self) -> u32 { self.as_inner().attrs() }\n-    fn creation_time(&self) -> u64 { self.as_inner().created_u64() }\n-    fn last_access_time(&self) -> u64 { self.as_inner().accessed_u64() }\n-    fn last_write_time(&self) -> u64 { self.as_inner().modified_u64() }\n-    fn file_size(&self) -> u64 { self.as_inner().size() }\n-    fn volume_serial_number(&self) -> Option<u32> { self.as_inner().volume_serial_number() }\n-    fn number_of_links(&self) -> Option<u32> { self.as_inner().number_of_links() }\n-    fn file_index(&self) -> Option<u64> { self.as_inner().file_index() }\n+    fn file_attributes(&self) -> u32 {\n+        self.as_inner().attrs()\n+    }\n+    fn creation_time(&self) -> u64 {\n+        self.as_inner().created_u64()\n+    }\n+    fn last_access_time(&self) -> u64 {\n+        self.as_inner().accessed_u64()\n+    }\n+    fn last_write_time(&self) -> u64 {\n+        self.as_inner().modified_u64()\n+    }\n+    fn file_size(&self) -> u64 {\n+        self.as_inner().size()\n+    }\n+    fn volume_serial_number(&self) -> Option<u32> {\n+        self.as_inner().volume_serial_number()\n+    }\n+    fn number_of_links(&self) -> Option<u32> {\n+        self.as_inner().number_of_links()\n+    }\n+    fn file_index(&self) -> Option<u64> {\n+        self.as_inner().file_index()\n+    }\n }\n \n /// Windows-specific extensions to [`FileType`].\n@@ -495,8 +516,12 @@ pub trait FileTypeExt {\n \n #[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n impl FileTypeExt for fs::FileType {\n-    fn is_symlink_dir(&self) -> bool { self.as_inner().is_symlink_dir() }\n-    fn is_symlink_file(&self) -> bool { self.as_inner().is_symlink_file() }\n+    fn is_symlink_dir(&self) -> bool {\n+        self.as_inner().is_symlink_dir()\n+    }\n+    fn is_symlink_file(&self) -> bool {\n+        self.as_inner().is_symlink_file()\n+    }\n }\n \n /// Creates a new file symbolic link on the filesystem.\n@@ -515,8 +540,7 @@ impl FileTypeExt for fs::FileType {\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n-                                                    -> io::Result<()> {\n+pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), false)\n }\n \n@@ -536,7 +560,6 @@ pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n-                                                   -> io::Result<()> {\n+pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), true)\n }"}, {"sha": "4573ee589321dd488b8d5695b91d9ef9b586331f", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -1,12 +1,12 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fs;\n-use crate::os::windows::raw;\n+use crate::io;\n use crate::net;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::os::windows::raw;\n use crate::sys;\n use crate::sys::c;\n-use crate::io;\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n \n /// Raw HANDLEs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "613d3dc189a437f9bdb79f38253b8123171ca57d", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -13,23 +13,28 @@\n pub mod ffi;\n pub mod fs;\n pub mod io;\n-pub mod raw;\n pub mod process;\n+pub mod raw;\n pub mod thread;\n \n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod prelude {\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{RawSocket, RawHandle, AsRawSocket, AsRawHandle};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{FromRawSocket, FromRawHandle, IntoRawSocket, IntoRawHandle};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{OpenOptionsExt, MetadataExt};\n-    #[doc(no_inline)] #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n+    #[doc(no_inline)]\n+    #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     pub use super::fs::FileExt;\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::fs::{MetadataExt, OpenOptionsExt};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{AsRawHandle, AsRawSocket, RawHandle, RawSocket};\n+    #[doc(no_inline)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{FromRawHandle, FromRawSocket, IntoRawHandle, IntoRawSocket};\n }"}, {"sha": "ed35c5ff19446e93ebe9317ff7823ab72eaf7227", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,10 +2,10 @@\n \n #![stable(feature = \"process_extensions\", since = \"1.2.0\")]\n \n-use crate::os::windows::io::{FromRawHandle, RawHandle, AsRawHandle, IntoRawHandle};\n+use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n use crate::process;\n use crate::sys;\n-use crate::sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl FromRawHandle for process::Stdio {"}, {"sha": "7f2a2877828cfe4f3d657a7b69ebab73060ffe45", "filename": "src/libstd/sys/windows/ext/raw.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -4,8 +4,11 @@\n \n use crate::os::raw::c_void;\n \n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type HANDLE = *mut c_void;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type HANDLE = *mut c_void;\n #[cfg(target_pointer_width = \"32\")]\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type SOCKET = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type SOCKET = u32;\n #[cfg(target_pointer_width = \"64\")]\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type SOCKET = u64;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type SOCKET = u64;"}, {"sha": "41c29f5b950ef537ca78039eb3609112b16f5461", "filename": "src/libstd/sys/windows/ext/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3", "patch": "@@ -2,9 +2,9 @@\n \n #![stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n \n-use crate::os::windows::io::{RawHandle, AsRawHandle, IntoRawHandle};\n-use crate::thread;\n+use crate::os::windows::io::{AsRawHandle, IntoRawHandle, RawHandle};\n use crate::sys_common::{AsInner, IntoInner};\n+use crate::thread;\n \n #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n impl<T> AsRawHandle for thread::JoinHandle<T> {\n@@ -14,7 +14,7 @@ impl<T> AsRawHandle for thread::JoinHandle<T> {\n }\n \n #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n-impl<T> IntoRawHandle for thread::JoinHandle<T>  {\n+impl<T> IntoRawHandle for thread::JoinHandle<T> {\n     fn into_raw_handle(self) -> RawHandle {\n         self.into_inner().into_handle().into_raw() as *mut _\n     }"}, {"sha": "e9c84c4e7c9cb654414f120920e06a7d299c70be", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "ebaa0783d603d6138a44e684ffbf02d6eae903da", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 57, "deletions": 47, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "9d8018fd5e864acb9c2c46a1d599e96d353e412c", "filename": "src/libstd/sys/windows/io.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "8631e50cf3888833110278ca2baccbc94be70c85", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 76, "deletions": 68, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "e451e0cfb5bc4f1ccb13cab922a92ec9ed0add98", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "524f21f889bc2c492fe69c92e35b8b56f26a79c7", "filename": "src/libstd/sys/windows/path.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "992e634dea510f6e852d40fbddd6003c4a35c34e", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 44, "deletions": 55, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "87ea416bf675af590f119be2438c3d291c6ecb7e", "filename": "src/libstd/sys/windows/rand.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "187ad4e66c3efcaedf613623ac714e2eccd5fdd4", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "f322c2b1d96c96779b9d5153d49ba741b645d77e", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "0f2178f73532feda05eaf93c47c7a0511fbe7cc7", "filename": "src/libstd/sys/windows/stdio_uwp.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "c828243a59b1190a6ec6fc2b1b4a667611640943", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "e0bb102b3afe5b8e746ea51d420466e41b8112bb", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "713b9949f64610c0c41499bba33912a86ee6a9d0", "filename": "src/libstd/sys_common/alloc.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Falloc.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "dccc3bc4a19a85f61112a759a45faabc9e83037e", "filename": "src/libstd/sys_common/bytestring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fbytestring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fbytestring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbytestring.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "e30e8018a31fe9b4f677f157a82b2d10ac59a39e", "filename": "src/libstd/sys_common/fs.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Ffs.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "7c1d98a5abd599bb6b0460c6942ebaebd94175d4", "filename": "src/libstd/sys_common/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fio.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "9d40d9f0afd5cade8f38e78ca3859c6298d6ef0b", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 143, "deletions": 113, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "a2608ad4000d420c90fc70124dfeb4f71f0d246b", "filename": "src/libstd/sys_common/os_str_bytes.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "0157b952996acc97f363bfd65f04bb8e8c2b169f", "filename": "src/libstd/sys_common/poison.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fpoison.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "55b421794c4130d6b942271e0452b95dbff3cd03", "filename": "src/libstd/sys_common/process.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fprocess.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "f09d16c33e6d6401470b61814af5e2ea39ff27b8", "filename": "src/libstd/sys_common/thread_info.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_info.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "00f7db4c037619a8724b86aa37d951a727ba7cf1", "filename": "src/libstd/sys_common/util.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Futil.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "1d96cdfe46042c5617d8826e94f078eff06010b4", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 122, "deletions": 121, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "c94fc41178dfe0bdc6d51096e0d41eba876861af", "filename": "src/libstd/tests/env.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Ftests%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Ftests%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftests%2Fenv.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "9c530e7b3248c88e5270c8742f23c18ba6bd7799", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 49, "deletions": 54, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "eae4f3cb5479fc3ab5e602dc82fd15904e405696", "filename": "src/test/ui/fmt/format-string-error.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "8b018480fb082cec80ee4f39d733a0a6da03da53", "filename": "src/test/ui/fmt/format-string-error.stderr", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-string-error.stderr?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "1a070843cc4468af85d2b13ce64a1e3c715089b3", "filename": "src/test/ui/ifmt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Ftest%2Fui%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Ftest%2Fui%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fifmt.rs?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}, {"sha": "d3f8407f8e262688a4b91327fd21c8ec73411a2e", "filename": "src/test/ui/issues/issue-27033.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr?ref=d8bdb3fdcbd88eb16e1a6669236122c41ed2aed3"}]}