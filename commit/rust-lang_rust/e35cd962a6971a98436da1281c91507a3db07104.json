{"sha": "e35cd962a6971a98436da1281c91507a3db07104", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNWNkOTYyYTY5NzFhOTg0MzZkYTEyODFjOTE1MDdhM2RiMDcxMDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-01T06:31:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-01T06:31:11Z"}, "message": "Drop struct fields if the user destructor fails\n\nThis commit changes drop glue generated for structs to use the invoke LLVM\ninstruction instead of call. What this means is that if the user destructor\ntriggers an unwinding, then the fields of the struct will still ge dropped.\n\nThis is not an attempt to support failing while failing, as that's mostly a\nproblem of runtime support. This is more of an issue of soundness in making sure\nthat destructors are appropriately run. The test included fails before this\ncommit, and only has one call to fail!(), yet it doesn't destroy its struct\nfields.", "tree": {"sha": "c7c4ac5d998a04831fd6faa349081be21a6a7847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7c4ac5d998a04831fd6faa349081be21a6a7847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e35cd962a6971a98436da1281c91507a3db07104", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e35cd962a6971a98436da1281c91507a3db07104", "html_url": "https://github.com/rust-lang/rust/commit/e35cd962a6971a98436da1281c91507a3db07104", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e35cd962a6971a98436da1281c91507a3db07104/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d04a58cf2d224f6e0ae69334f90a9013ae2ba35a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d04a58cf2d224f6e0ae69334f90a9013ae2ba35a", "html_url": "https://github.com/rust-lang/rust/commit/d04a58cf2d224f6e0ae69334f90a9013ae2ba35a"}], "stats": {"total": 99, "additions": 59, "deletions": 40}, "files": [{"sha": "02b44907f336adbe09cb89d8193682ee35b80bd2", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e35cd962a6971a98436da1281c91507a3db07104/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35cd962a6971a98436da1281c91507a3db07104/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e35cd962a6971a98436da1281c91507a3db07104", "patch": "@@ -395,39 +395,11 @@ pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n-        let mut bcx = cx;\n-\n-        // Find and call the actual destructor\n-        let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n-                                     class_did, substs.tps.clone());\n-\n-        // The second argument is the \"self\" argument for drop\n-        let params = unsafe {\n-            let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n-            ty.element_type().func_params()\n-        };\n-\n-        // Class dtors have no explicit args, so the params should\n-        // just consist of the environment (self)\n-        assert_eq!(params.len(), 1);\n-\n-        let self_arg = PointerCast(bcx, v0, params[0]);\n-        let args = ~[self_arg];\n-\n-        Call(bcx, dtor_addr, args, []);\n-\n-        // Drop the fields\n-        let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n-        for (i, fld) in field_tys.iter().enumerate() {\n-            let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n-            bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n-        }\n-\n-        bcx\n+        trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     }\n }\n \n-pub fn trans_struct_drop(mut bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n+pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n                          class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n@@ -445,19 +417,24 @@ pub fn trans_struct_drop(mut bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n     // just consist of the environment (self)\n     assert_eq!(params.len(), 1);\n \n-    let self_arg = PointerCast(bcx, v0, params[0]);\n-    let args = ~[self_arg];\n+    // Be sure to put all of the fields into a scope so we can use an invoke\n+    // instruction to call the user destructor but still call the field\n+    // destructors if the user destructor fails.\n+    do with_scope(bcx, None, \"field drops\") |bcx| {\n+        let self_arg = PointerCast(bcx, v0, params[0]);\n+        let args = ~[self_arg];\n \n-    Call(bcx, dtor_addr, args, []);\n+        // Add all the fields as a value which needs to be cleaned at the end of\n+        // this scope.\n+        let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n+        for (i, fld) in field_tys.iter().enumerate() {\n+            let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n+            add_clean(bcx, llfld_a, fld.mt.ty);\n+        }\n \n-    // Drop the fields\n-    let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n-    for (i, fld) in field_tys.iter().enumerate() {\n-        let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n-        bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n+        let (_, bcx) = invoke(bcx, dtor_addr, args, []);\n+        bcx\n     }\n-\n-    bcx\n }\n \n pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {"}, {"sha": "7c6bb1fa379b4d1b5c51ddb265fb7e1064ad6c5e", "filename": "src/test/run-pass/fail-in-dtor-drops-fields.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e35cd962a6971a98436da1281c91507a3db07104/src%2Ftest%2Frun-pass%2Ffail-in-dtor-drops-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35cd962a6971a98436da1281c91507a3db07104/src%2Ftest%2Frun-pass%2Ffail-in-dtor-drops-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffail-in-dtor-drops-fields.rs?ref=e35cd962a6971a98436da1281c91507a3db07104", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::task;\n+\n+static mut dropped: bool = false;\n+\n+struct A {\n+    b: B,\n+}\n+\n+struct B {\n+    foo: int,\n+}\n+\n+impl Drop for A {\n+    fn drop(&mut self) {\n+        fail!()\n+    }\n+}\n+\n+impl Drop for B {\n+    fn drop(&mut self) {\n+        unsafe { dropped = true; }\n+    }\n+}\n+\n+pub fn main() {\n+    let ret = do task::try {\n+        let _a = A { b: B { foo: 3 } };\n+    };\n+    assert!(ret.is_err());\n+    unsafe { assert!(dropped); }\n+}\n+"}]}