{"sha": "16a71cce514f29cb8c532248cf749e26972afb01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YTcxY2NlNTE0ZjI5Y2I4YzUzMjI0OGNmNzQ5ZTI2OTcyYWZiMDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-17T15:49:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "rework how we handle the type of loops\n\nFirst, we keep a `CoerceMany` now to find the LUB of all the break\nexpressions. Second, this `CoerceMany` is actually an\n`Option<CoerceMany>`, and we store `None` for loops where \"break with an\nexpression\" is disallowed. This avoids silly duplicate errors about a\ntype mismatch, since the loops pass already reports an error that the\nbreak cannot have an expression. Finally, since we now detect an invalid\nbreak target during HIR lowering, refactor `find_loop` to be infallible.\n\nAdjust tests as needed:\n\n- some spans from breaks are slightly different\n- break up a single loop into multiple since `CoerceMany` silences\n  redundant and derived errors\n- add a ui test that we only give on error for loop-break-value", "tree": {"sha": "4c7deb57f9bd62a1f52332a9673a6d00fcadcdfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c7deb57f9bd62a1f52332a9673a6d00fcadcdfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16a71cce514f29cb8c532248cf749e26972afb01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16a71cce514f29cb8c532248cf749e26972afb01", "html_url": "https://github.com/rust-lang/rust/commit/16a71cce514f29cb8c532248cf749e26972afb01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16a71cce514f29cb8c532248cf749e26972afb01/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ae620bbebadbe4362a28b37bcecd41cfed66cea", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae620bbebadbe4362a28b37bcecd41cfed66cea", "html_url": "https://github.com/rust-lang/rust/commit/1ae620bbebadbe4362a28b37bcecd41cfed66cea"}], "stats": {"total": 271, "additions": 161, "deletions": 110}, "files": [{"sha": "59f3ac739e0a2cafb8c9809ea06f2359e8061b11", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 111, "deletions": 96, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/16a71cce514f29cb8c532248cf749e26972afb01/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a71cce514f29cb8c532248cf749e26972afb01/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=16a71cce514f29cb8c532248cf749e26972afb01", "patch": "@@ -415,15 +415,16 @@ impl Diverges {\n }\n \n #[derive(Clone)]\n-pub struct BreakableCtxt<'gcx, 'tcx> {\n-    unified: Ty<'tcx>,\n-    coerce_to: Ty<'tcx>,\n-    break_exprs: Vec<&'gcx hir::Expr>,\n+pub struct BreakableCtxt<'gcx: 'tcx, 'tcx> {\n     may_break: bool,\n+\n+    // this is `null` for loops where break with a value is illegal,\n+    // such as `while`, `for`, and `while let`\n+    coerce: Option<CoerceMany<'gcx, 'tcx>>,\n }\n \n #[derive(Clone)]\n-pub struct EnclosingBreakables<'gcx, 'tcx> {\n+pub struct EnclosingBreakables<'gcx: 'tcx, 'tcx> {\n     stack: Vec<BreakableCtxt<'gcx, 'tcx>>,\n     by_id: NodeMap<usize>,\n }\n@@ -3547,60 +3548,66 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               tcx.mk_nil()\n           }\n           hir::ExprBreak(destination, ref expr_opt) => {\n-            if let Some(target_id) = destination.target_id.opt_id() {\n-                let coerce_to = {\n-                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                    enclosing_breakables.find_breakable(target_id).coerce_to\n-                };\n-\n-                let e_ty;\n-                let cause;\n-                if let Some(ref e) = *expr_opt {\n-                    // Recurse without `enclosing_loops` borrowed.\n-                    e_ty = self.check_expr_with_hint(e, coerce_to);\n-                    cause = self.misc(e.span);\n-                    // Notably, the recursive call may alter coerce_to - must not keep using it!\n-                } else {\n-                    // `break` without argument acts like `break ()`.\n-                    e_ty = tcx.mk_nil();\n-                    cause = self.misc(expr.span);\n-                }\n-\n-                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                let ctxt = enclosing_breakables.find_breakable(target_id);\n+              if let Some(target_id) = destination.target_id.opt_id() {\n+                  let (e_ty, cause);\n+                  if let Some(ref e) = *expr_opt {\n+                      // If this is a break with a value, we need to type-check\n+                      // the expression. Get an expected type from the loop context.\n+                      let opt_coerce_to = {\n+                          let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                          enclosing_breakables.find_breakable(target_id)\n+                                              .coerce\n+                                              .as_ref()\n+                                              .map(|coerce| coerce.expected_ty())\n+                      };\n+\n+                      // If the loop context is not a `loop { }`, then break with\n+                      // a value is illegal, and `opt_coerce_to` will be `None`.\n+                      // Just set expectation to error in that case.\n+                      let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+\n+                      // Recurse without `enclosing_breakables` borrowed.\n+                      e_ty = self.check_expr_with_hint(e, coerce_to);\n+                      cause = self.misc(e.span);\n+                  } else {\n+                      // Otherwise, this is a break *without* a value. That's\n+                      // always legal, and is equivalent to `break ()`.\n+                      e_ty = tcx.mk_nil();\n+                      cause = self.misc(expr.span);\n+                  }\n \n-                let result = if let Some(ref e) = *expr_opt {\n-                    // Special-case the first element, as it has no \"previous expressions\".\n-                    let result = if !ctxt.may_break {\n-                        self.try_coerce(e, e_ty, ctxt.coerce_to)\n-                    } else {\n-                        self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n-                                                   ctxt.unified, e, e_ty)\n-                    };\n+                  // Now that we have type-checked `expr_opt`, borrow\n+                  // the `enclosing_loops` field and let's coerce the\n+                  // type of `expr_opt` into what is expected.\n+                  let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                  let ctxt = enclosing_breakables.find_breakable(target_id);\n+                  if let Some(ref mut coerce) = ctxt.coerce {\n+                      if let Some(ref e) = *expr_opt {\n+                          coerce.coerce(self, &cause, e, e_ty);\n+                      } else {\n+                          assert!(e_ty.is_nil());\n+                          coerce.coerce_forced_unit(self, &cause);\n+                      }\n+                  } else {\n+                      // If `ctxt.coerce` is `None`, we can just ignore\n+                      // the type of the expresison.  This is because\n+                      // either this was a break *without* a value, in\n+                      // which case it is always a legal type (`()`), or\n+                      // else an error would have been flagged by the\n+                      // `loops` pass for using break with an expression\n+                      // where you are not supposed to.\n+                      assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n+                  }\n \n-                    ctxt.break_exprs.push(e);\n-                    result\n-                } else {\n-                    self.eq_types(true, &cause, e_ty, ctxt.unified)\n-                        .map(|InferOk { obligations, .. }| {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n-                            e_ty\n-                        })\n-                };\n-                match result {\n-                    Ok(ty) => ctxt.unified = ty,\n-                    Err(err) => {\n-                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err).emit();\n-                    }\n-                }\n+                  ctxt.may_break = true;\n+              } else {\n+                  // Otherwise, we failed to find the enclosing loop; this can only happen if the\n+                  // `break` was not inside a loop at all, which is caught by the loop-checking pass.\n+                  assert!(self.tcx.sess.err_count() > 0);\n+              }\n \n-                ctxt.may_break = true;\n-            }\n-            // Otherwise, we failed to find the enclosing breakable; this can only happen if the\n-            // `break` target was not found, which is caught in HIR lowering and reported by the\n-            // loop-checking pass.\n-            tcx.types.never\n+              // the type of a `break` is always `!`, since it diverges\n+              tcx.types.never\n           }\n           hir::ExprAgain(_) => { tcx.types.never }\n           hir::ExprRet(ref expr_opt) => {\n@@ -3645,51 +3652,59 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                    expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            let unified = self.tcx.mk_nil();\n-            let coerce_to = unified;\n-            let ctxt = BreakableCtxt {\n-                unified: unified,\n-                coerce_to: coerce_to,\n-                break_exprs: vec![],\n-                may_break: true,\n-            };\n-            self.with_breakable_ctxt(expr.id, ctxt, || {\n-                self.check_expr_has_type(&cond, tcx.types.bool);\n-                let cond_diverging = self.diverges.get();\n-                self.check_block_no_value(&body);\n+              let ctxt = BreakableCtxt {\n+                  // cannot use break with a value from a while loop\n+                  coerce: None,\n+                  may_break: true,\n+              };\n \n-                // We may never reach the body so it diverging means nothing.\n-                self.diverges.set(cond_diverging);\n-            });\n+              self.with_breakable_ctxt(expr.id, ctxt, || {\n+                  self.check_expr_has_type(&cond, tcx.types.bool);\n+                  let cond_diverging = self.diverges.get();\n+                  self.check_block_no_value(&body);\n \n-            if self.has_errors.get() {\n-                tcx.types.err\n-            } else {\n-                tcx.mk_nil()\n-            }\n+                  // We may never reach the body so it diverging means nothing.\n+                  self.diverges.set(cond_diverging);\n+              });\n+\n+              self.tcx.mk_nil()\n           }\n-          hir::ExprLoop(ref body, _, _) => {\n-            let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(body.span));\n-            let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n-            let ctxt = BreakableCtxt {\n-                unified: unified,\n-                coerce_to: coerce_to,\n-                break_exprs: vec![],\n-                may_break: false,\n-            };\n+          hir::ExprLoop(ref body, _, source) => {\n+              let coerce = match source {\n+                  // you can only use break with a value from a normal `loop { }`\n+                  hir::LoopSource::Loop => {\n+                      let coerce_to = expected.only_has_type_or_fresh_var(self, body.span);\n+                      Some(CoerceMany::new(coerce_to))\n+                  }\n \n-            let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n-                self.check_block_no_value(&body);\n-            });\n-            if ctxt.may_break {\n-                // No way to know whether it's diverging because\n-                // of a `break` or an outer `break` or `return.\n-                self.diverges.set(Diverges::Maybe);\n+                  hir::LoopSource::WhileLet |\n+                  hir::LoopSource::ForLoop => {\n+                      None\n+                  }\n+              };\n \n-                ctxt.unified\n-            } else {\n-                tcx.types.never\n-            }\n+              let ctxt = BreakableCtxt {\n+                  coerce: coerce,\n+                  may_break: false, // will get updated if/when we find a `break`\n+              };\n+\n+              let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                  self.check_block_no_value(&body);\n+              });\n+\n+              if ctxt.may_break {\n+                  // No way to know whether it's diverging because\n+                  // of a `break` or an outer `break` or `return.\n+                  self.diverges.set(Diverges::Maybe);\n+              }\n+\n+              // If we permit break with a value, then result type is\n+              // the LUB of the breaks (possibly ! if none); else, it\n+              // is nil. This makes sense because infinite loops\n+              // (which would have type !) are only possible iff we\n+              // permit break with a value [1].\n+              assert!(ctxt.coerce.is_some() || ctxt.may_break); // [1]\n+              ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n             self.check_match(expr, &discrim, arms, expected, match_src)"}, {"sha": "23afa4b629636ac94e3e856b736d840466b9cba8", "filename": "src/test/compile-fail/issue-27042.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16a71cce514f29cb8c532248cf749e26972afb01/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a71cce514f29cb8c532248cf749e26972afb01/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs?ref=16a71cce514f29cb8c532248cf749e26972afb01", "patch": "@@ -12,14 +12,14 @@\n \n fn main() {\n     let _: i32 =\n-        'a: //~ ERROR mismatched types\n-        loop { break };\n+        'a: // in this case, the citation is just the `break`:\n+        loop { break }; //~ ERROR mismatched types\n     let _: i32 =\n         'b: //~ ERROR mismatched types\n-        while true { break };\n+        while true { break }; // but here we cite the whole loop\n     let _: i32 =\n         'c: //~ ERROR mismatched types\n-        for _ in None { break };\n+        for _ in None { break }; // but here we cite the whole loop\n     let _: i32 =\n         'd: //~ ERROR mismatched types\n         while let Some(_) = None { break };"}, {"sha": "a414321899203d17b0f16642a9e8fc0e67170d18", "filename": "src/test/compile-fail/loop-break-value.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16a71cce514f29cb8c532248cf749e26972afb01/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a71cce514f29cb8c532248cf749e26972afb01/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs?ref=16a71cce514f29cb8c532248cf749e26972afb01", "patch": "@@ -40,37 +40,40 @@ fn main() {\n         loop {\n             break 'while_loop 123;\n             //~^ ERROR `break` with value from a `while` loop\n-            //~| ERROR mismatched types\n             break 456;\n             break 789;\n         };\n     }\n \n-    'while_let_loop: while let Some(_) = Some(()) {\n+    while let Some(_) = Some(()) {\n         if break () { //~ ERROR `break` with value from a `while let` loop\n-            break;\n-            break None;\n-            //~^ ERROR `break` with value from a `while let` loop\n-            //~| ERROR mismatched types\n         }\n+    }\n+\n+    while let Some(_) = Some(()) {\n+        break None;\n+        //~^ ERROR `break` with value from a `while let` loop\n+    }\n+\n+    'while_let_loop: while let Some(_) = Some(()) {\n         loop {\n             break 'while_let_loop \"nope\";\n             //~^ ERROR `break` with value from a `while let` loop\n-            //~| ERROR mismatched types\n             break 33;\n         };\n     }\n \n-    'for_loop: for _ in &[1,2,3] {\n+    for _ in &[1,2,3] {\n         break (); //~ ERROR `break` with value from a `for` loop\n         break [()];\n         //~^ ERROR `break` with value from a `for` loop\n-        //~| ERROR mismatched types\n+    }\n+\n+    'for_loop: for _ in &[1,2,3] {\n         loop {\n             break Some(3);\n             break 'for_loop Some(17);\n             //~^ ERROR `break` with value from a `for` loop\n-            //~| ERROR mismatched types\n         };\n     }\n "}, {"sha": "790f796fae07f787a64fba8266b46ede5ed7bb65", "filename": "src/test/ui/loop-break-value-no-repeat.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/16a71cce514f29cb8c532248cf749e26972afb01/src%2Ftest%2Fui%2Floop-break-value-no-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a71cce514f29cb8c532248cf749e26972afb01/src%2Ftest%2Fui%2Floop-break-value-no-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floop-break-value-no-repeat.rs?ref=16a71cce514f29cb8c532248cf749e26972afb01", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(loop_break_value)]\n+#![allow(unused_variables)]\n+\n+use std::ptr;\n+\n+// Test that we only report **one** error here and that is that\n+// `break` with an expression is illegal in this context. In\n+// particular, we don't report any mismatched types error, which is\n+// besides the point.\n+\n+fn main() {\n+    for _ in &[1,2,3] {\n+        break 22\n+    }\n+}"}, {"sha": "0d99abd3907d81b40a67e8959a1d9edf747db9f5", "filename": "src/test/ui/loop-break-value-no-repeat.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16a71cce514f29cb8c532248cf749e26972afb01/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16a71cce514f29cb8c532248cf749e26972afb01/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr?ref=16a71cce514f29cb8c532248cf749e26972afb01", "patch": "@@ -0,0 +1,8 @@\n+error[E0571]: `break` with value from a `for` loop\n+  --> $DIR/loop-break-value-no-repeat.rs:23:9\n+   |\n+23 |         break 22\n+   |         ^^^^^^^^ can only break with a value inside `loop`\n+\n+error: aborting due to previous error\n+"}]}