{"sha": "4dff9cbf58bb7a274a693eb7d19006402945fc7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkZmY5Y2JmNThiYjdhMjc0YTY5M2ViN2QxOTAwNjQwMjk0NWZjN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-20T20:21:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-20T20:21:18Z"}, "message": "auto merge of #14304 : brson/rust/moredocs, r=kballard\n\nIncludes module docs for `cell`.", "tree": {"sha": "c8eefbda7bfb2a21f240a3ba4ab9e3ffc7e57898", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8eefbda7bfb2a21f240a3ba4ab9e3ffc7e57898"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dff9cbf58bb7a274a693eb7d19006402945fc7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dff9cbf58bb7a274a693eb7d19006402945fc7e", "html_url": "https://github.com/rust-lang/rust/commit/4dff9cbf58bb7a274a693eb7d19006402945fc7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dff9cbf58bb7a274a693eb7d19006402945fc7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9bd6b4e3900da77f06ebad04ae6bada1e26e042", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9bd6b4e3900da77f06ebad04ae6bada1e26e042", "html_url": "https://github.com/rust-lang/rust/commit/f9bd6b4e3900da77f06ebad04ae6bada1e26e042"}, {"sha": "c9ab33a8fde708c8a4cf70b03f5d69370220665c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9ab33a8fde708c8a4cf70b03f5d69370220665c", "html_url": "https://github.com/rust-lang/rust/commit/c9ab33a8fde708c8a4cf70b03f5d69370220665c"}], "stats": {"total": 202, "additions": 182, "deletions": 20}, "files": [{"sha": "093b3f57047ca0f1118a1798511ad1daec8a0d88", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 151, "deletions": 1, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4dff9cbf58bb7a274a693eb7d19006402945fc7e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dff9cbf58bb7a274a693eb7d19006402945fc7e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=4dff9cbf58bb7a274a693eb7d19006402945fc7e", "patch": "@@ -8,7 +8,157 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Types that provide interior mutability.\n+//! Sharable mutable containers.\n+//!\n+//! Values of the `Cell` and `RefCell` types may be mutated through\n+//! shared references (i.e. the common `&T` type), whereas most Rust\n+//! types can only be mutated through unique (`&mut T`) references. We\n+//! say that `Cell` and `RefCell` provide *interior mutability*, in\n+//! contrast with typical Rust types that exhibit *inherited\n+//! mutability*.\n+//!\n+//! Cell types come in two flavors: `Cell` and `RefCell`. `Cell`\n+//! provides `get` and `set` methods that change the\n+//! interior value with a single method call. `Cell` though is only\n+//! compatible with types that implement `Copy`. For other types,\n+//! one must use the `RefCell` type, acquiring a write lock before\n+//! mutating.\n+//!\n+//! `RefCell` uses Rust's lifetimes to implement *dynamic borrowing*,\n+//! a process whereby one can claim temporary, exclusive, mutable\n+//! access to the inner value. Borrows for `RefCell`s are tracked *at\n+//! runtime*, unlike Rust's native reference types which are entirely\n+//! tracked statically, at compile time. Because `RefCell` borrows are\n+//! dynamic it is possible to attempt to borrow a value that is\n+//! already mutably borrowed; when this happens it results in task\n+//! failure.\n+//!\n+//! # When to choose interior mutability\n+//!\n+//! The more common inherited mutability, where one must have unique\n+//! access to mutate a value, is one of the key language elements that\n+//! enables Rust to reason strongly about pointer aliasing, statically\n+//! preventing crash bugs. Because of that, inherited mutability is\n+//! preferred, and interior mutability is something of a last\n+//! resort. Since cell types enable mutation where it would otherwise\n+//! be disallowed though, there are occassions when interior\n+//! mutability might be appropriate, or even *must* be used, e.g.\n+//!\n+//! * Introducing inherited mutability roots to shared types.\n+//! * Implementation details of logically-immutable methods.\n+//! * Mutating implementations of `clone`.\n+//!\n+//! ## Introducing inherited mutability roots to shared types\n+//!\n+//! Shared smart pointer types, including `Rc` and `Arc`, provide\n+//! containers that can be cloned and shared between multiple parties.\n+//! Because the contained values may be multiply-aliased, they can\n+//! only be borrowed as shared references, not mutable references.\n+//! Without cells it would be impossible to mutate data inside of\n+//! shared boxes at all!\n+//!\n+//! It's very common then to put a `RefCell` inside shared pointer\n+//! types to reintroduce mutability:\n+//!\n+//! ```\n+//! extern crate collections;\n+//!\n+//! use collections::HashMap;\n+//! use std::cell::RefCell;\n+//! use std::rc::Rc;\n+//!\n+//! fn main() {\n+//!     let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n+//!     shared_map.borrow_mut().insert(\"africa\", 92388);\n+//!     shared_map.borrow_mut().insert(\"kyoto\", 11837);\n+//!     shared_map.borrow_mut().insert(\"piccadilly\", 11826);\n+//!     shared_map.borrow_mut().insert(\"marbles\", 38);\n+//! }\n+//! ```\n+//!\n+//! ## Implementation details of logically-immutable methods\n+//!\n+//! Occasionally it may be desirable not to expose in an API that\n+//! there is mutation happening \"under the hood\". This may be because\n+//! logically the operation is immutable, but e.g. caching forces the\n+//! implementation to perform mutation; or because you must employ\n+//! mutation to implement a trait method that was originally defined\n+//! to take `&self`.\n+//!\n+//! ```\n+//! extern crate collections;\n+//!\n+//! use collections::HashMap;\n+//! use std::cell::RefCell;\n+//!\n+//! struct Graph {\n+//!     edges: HashMap<uint, uint>,\n+//!     span_tree_cache: RefCell<Option<Vec<(uint, uint)>>>\n+//! }\n+//!\n+//! impl Graph {\n+//!     fn minimum_spanning_tree(&self) -> Vec<(uint, uint)> {\n+//!         // Create a new scope to contain the lifetime of the\n+//!         // dynamic borrow\n+//!         {\n+//!             // Take a reference to the inside of cache cell\n+//!             let mut cache = self.span_tree_cache.borrow_mut();\n+//!             if cache.is_some() {\n+//!                 return cache.get_ref().clone();\n+//!             }\n+//!\n+//!             let span_tree = self.calc_span_tree();\n+//!             *cache = Some(span_tree);\n+//!         }\n+//!\n+//!         // Recursive call to return the just-cached value.\n+//!         // Note that if we had not let the previous borrow\n+//!         // of the cache fall out of scope then the subsequent\n+//!         // recursive borrow would cause a dynamic task failure.\n+//!         // This is the major hazard of using `RefCell`.\n+//!         self.minimum_spanning_tree()\n+//!     }\n+//! #   fn calc_span_tree(&self) -> Vec<(uint, uint)> { vec![] }\n+//! }\n+//! # fn main() { }\n+//! ```\n+//!\n+//! ## Mutating implementations of `clone`\n+//!\n+//! This is simply a special - but common - case of the previous:\n+//! hiding mutability for operations that appear to be immutable.\n+//! The `clone` method is expected to not change the source value, and\n+//! is declared to take `&self`, not `&mut self`. Therefore any\n+//! mutation that happens in the `clone` method must use cell\n+//! types. For example, `Rc` maintains its reference counts within a\n+//! `Cell`.\n+//!\n+//! ```\n+//! use std::cell::Cell;\n+//!\n+//! struct Rc<T> {\n+//!     ptr: *mut RcBox<T>\n+//! }\n+//!\n+//! struct RcBox<T> {\n+//!     value: T,\n+//!     refcount: Cell<uint>\n+//! }\n+//!\n+//! impl<T> Clone for Rc<T> {\n+//!     fn clone(&self) -> Rc<T> {\n+//!         unsafe {\n+//!             (*self.ptr).refcount.set((*self.ptr).refcount.get() + 1);\n+//!             Rc { ptr: self.ptr }\n+//!         }\n+//!     }\n+//! }\n+//! ```\n+//!\n+// FIXME: Explain difference between Cell and RefCell\n+// FIXME: Downsides to interior mutability\n+// FIXME: Can't be shared between threads. Dynamic borrows\n+// FIXME: Relationship to Atomic types and RWLock\n \n use clone::Clone;\n use cmp::Eq;"}, {"sha": "ffb9b676e7d4752c2811ae88d81443375cd758ad", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4dff9cbf58bb7a274a693eb7d19006402945fc7e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dff9cbf58bb7a274a693eb7d19006402945fc7e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=4dff9cbf58bb7a274a693eb7d19006402945fc7e", "patch": "@@ -8,12 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The Rust core library\n+//! The Rust Core Library\n //!\n-//! This library is meant to represent the core functionality of rust that is\n-//! maximally portable to other platforms. To that extent, this library has no\n-//! knowledge of things like allocation, threads, I/O, etc. This library is\n-//! built on the assumption of a few existing symbols:\n+//! The Rust Core Library is the dependency-free foundation of [The\n+//! Rust Standard Library](../std/index.html). It is the portable glue\n+//! between the language and its libraries, defining the intrinsic and\n+//! primitive building blocks of all Rust code. It links to no\n+//! upstream libraries, no system libraries, and no libc.\n+//!\n+//! The core library is *minimal*: it isn't even aware of heap allocation,\n+//! nor does it provide concurrency or I/O. These things require\n+//! platform integration, and this library is platform-agnostic.\n+//!\n+//! *It is not recommended to use the core library*. The stable\n+//! functionality of libcore is reexported from the\n+//! [standard library](../std/index.html). The composition of this library is\n+//! subject to change over time; only the interface exposed through libstd is\n+//! intended to be stable.\n+//!\n+//! # How to use the core library\n+//!\n+// FIXME: Fill me in with more detail when the interface settles\n+//! This library is built on the assumption of a few existing symbols:\n //!\n //! * `memcpy`, `memcmp`, `memset` - These are core memory routines which are\n //!   often generated by LLVM. Additionally, this library can make explicit\n@@ -23,16 +39,11 @@\n //!   distribution.\n //!\n //! * `rust_begin_unwind` - This function takes three arguments, a\n-//!   `&fmt::Arguments`, a `&str`, and a `uint. These three arguments dictate\n+//!   `&fmt::Arguments`, a `&str`, and a `uint`. These three arguments dictate\n //!   the failure message, the file at which failure was invoked, and the line.\n //!   It is up to consumers of this core library to define this failure\n //!   function; it is only required to never return.\n //!\n-//! Currently, it is *not* recommended to use the core library. The stable\n-//! functionality of libcore is exported directly into the\n-//! [standard library](../std/index.html). The composition of this library is\n-//! subject to change over time, only the interface exposed through libstd is\n-//! intended to be stable.\n \n #![crate_id = \"core#0.11.0-pre\"]\n #![license = \"MIT/ASL2\"]"}, {"sha": "1eab5c04469fc62c920471356017f40e38189e9b", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dff9cbf58bb7a274a693eb7d19006402945fc7e/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dff9cbf58bb7a274a693eb7d19006402945fc7e/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=4dff9cbf58bb7a274a693eb7d19006402945fc7e", "patch": "@@ -10,7 +10,7 @@\n \n /*!\n  *\n- * Traits representing built-in operators, useful for overloading\n+ * Overloadable operators\n  *\n  * Implementing these traits allows you to get an effect similar to\n  * overloading operators."}, {"sha": "a9ec9c1ddc5ac0ed5f5e819e909b5e24b6c6d52e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4dff9cbf58bb7a274a693eb7d19006402945fc7e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dff9cbf58bb7a274a693eb7d19006402945fc7e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4dff9cbf58bb7a274a693eb7d19006402945fc7e", "patch": "@@ -16,9 +16,8 @@\n //!\n //! ## Intrinsic types and operations\n //!\n-//! The [`ptr`](../core/ptr/index.html), [`mem`](../core/mem/index.html),\n-//! and [`cast`](../core/cast/index.html) modules deal with unsafe pointers,\n-//! memory manipulation, and coercion.\n+//! The [`ptr`](../core/ptr/index.html) and [`mem`](../core/mem/index.html)\n+//! modules deal with unsafe pointers and memory manipulation.\n //! [`kinds`](../core/kinds/index.html) defines the special built-in traits,\n //! and [`raw`](../core/raw/index.html) the runtime representation of Rust types.\n //! These are some of the lowest-level building blocks of Rust\n@@ -135,24 +134,26 @@ extern crate libc;\n #[cfg(test)] pub use realstd::cmp;\n #[cfg(test)] pub use realstd::ty;\n \n-#[cfg(not(test))] pub use core::cmp;\n-#[cfg(not(test))] pub use core::kinds;\n-#[cfg(not(test))] pub use core::ops;\n-#[cfg(not(test))] pub use core::ty;\n+\n+// NB: These reexports are in the order they should be listed in rustdoc\n \n pub use core::any;\n pub use core::bool;\n pub use core::cell;\n pub use core::char;\n pub use core::clone;\n+#[cfg(not(test))] pub use core::cmp;\n pub use core::container;\n pub use core::default;\n pub use core::intrinsics;\n pub use core::iter;\n+#[cfg(not(test))] pub use core::kinds;\n pub use core::mem;\n+#[cfg(not(test))] pub use core::ops;\n pub use core::ptr;\n pub use core::raw;\n pub use core::tuple;\n+#[cfg(not(test))] pub use core::ty;\n pub use core::result;\n \n pub use alloc::owned;"}]}