{"sha": "49f73e14a9e1db294f1e08511cb279a65c2f88b1", "node_id": "C_kwDOAAsO6NoAKDQ5ZjczZTE0YTllMWRiMjk0ZjFlMDg1MTFjYjI3OWE2NWMyZjg4YjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-08T16:12:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-08T16:12:00Z"}, "message": "Auto merge of #8356 - J-ZhengLi:master-issue8288, r=dswij\n\nSimplify if let statements\n\nfixes: #8288\n\n---\n\nchangelog: Allowing [`qustion_mark`] lint to check `if let` expressions that immediatly return unwrapped value", "tree": {"sha": "4d08a498e7f1c2dfd95454becea8abd9edaa93ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d08a498e7f1c2dfd95454becea8abd9edaa93ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49f73e14a9e1db294f1e08511cb279a65c2f88b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49f73e14a9e1db294f1e08511cb279a65c2f88b1", "html_url": "https://github.com/rust-lang/rust/commit/49f73e14a9e1db294f1e08511cb279a65c2f88b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49f73e14a9e1db294f1e08511cb279a65c2f88b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54feac18d1ad9cc5af1f71dfb34baa32f99630ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/54feac18d1ad9cc5af1f71dfb34baa32f99630ae", "html_url": "https://github.com/rust-lang/rust/commit/54feac18d1ad9cc5af1f71dfb34baa32f99630ae"}, {"sha": "d0b8f7508c584f74ed668b1bf665657894c63a4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0b8f7508c584f74ed668b1bf665657894c63a4a", "html_url": "https://github.com/rust-lang/rust/commit/d0b8f7508c584f74ed668b1bf665657894c63a4a"}], "stats": {"total": 482, "additions": 312, "deletions": 170}, "files": [{"sha": "f0155ed6051f6b7c11408130d1b52d14e167076b", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 174, "deletions": 116, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/49f73e14a9e1db294f1e08511cb279a65c2f88b1/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f73e14a9e1db294f1e08511cb279a65c2f88b1/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=49f73e14a9e1db294f1e08511cb279a65c2f88b1", "patch": "@@ -1,16 +1,19 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, is_lang_ctor, path_to_local, path_to_local_id, peel_blocks, peel_blocks_with_stmt};\n+use clippy_utils::{\n+    eq_expr_value, get_parent_node, is_else_clause, is_lang_ctor, path_to_local, path_to_local_id, peel_blocks,\n+    peel_blocks_with_stmt,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome, ResultOk};\n-use rustc_hir::{BindingAnnotation, Expr, ExprKind, PatKind};\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::{BindingAnnotation, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n+use rustc_span::{sym, symbol::Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -39,135 +42,190 @@ declare_clippy_lint! {\n \n declare_lint_pass!(QuestionMark => [QUESTION_MARK]);\n \n-impl QuestionMark {\n-    /// Checks if the given expression on the given context matches the following structure:\n+enum IfBlockType<'hir> {\n+    /// An `if x.is_xxx() { a } else { b } ` expression.\n     ///\n-    /// ```ignore\n-    /// if option.is_none() {\n-    ///    return None;\n-    /// }\n-    /// ```\n-    ///\n-    /// ```ignore\n-    /// if result.is_err() {\n-    ///     return result;\n-    /// }\n-    /// ```\n+    /// Contains: caller (x), caller_type, call_sym (is_xxx), if_then (a), if_else (b)\n+    IfIs(\n+        &'hir Expr<'hir>,\n+        Ty<'hir>,\n+        Symbol,\n+        &'hir Expr<'hir>,\n+        Option<&'hir Expr<'hir>>,\n+    ),\n+    /// An `if let Xxx(a) = b { c } else { d }` expression.\n     ///\n-    /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n-            if let ExprKind::MethodCall(segment, args, _) = &cond.kind;\n-            if let Some(subject) = args.get(0);\n-            if (Self::option_check_and_early_return(cx, subject, then) && segment.ident.name == sym!(is_none)) ||\n-                (Self::result_check_and_early_return(cx, subject, then) && segment.ident.name == sym!(is_err));\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n-                let mut replacement: Option<String> = None;\n-                if let Some(else_inner) = r#else {\n-                    if eq_expr_value(cx, subject, peel_blocks(else_inner)) {\n-                        replacement = Some(format!(\"Some({}?)\", receiver_str));\n-                    }\n-                } else if Self::moves_by_default(cx, subject)\n-                    && !matches!(subject.kind, ExprKind::Call(..) | ExprKind::MethodCall(..))\n-                {\n-                    replacement = Some(format!(\"{}.as_ref()?;\", receiver_str));\n-                } else {\n-                    replacement = Some(format!(\"{}?;\", receiver_str));\n-                }\n+    /// Contains: let_pat_qpath (Xxx), let_pat_type, let_pat_sym (a), let_expr (b), if_then (c),\n+    /// if_else (d)\n+    IfLet(\n+        &'hir QPath<'hir>,\n+        Ty<'hir>,\n+        Symbol,\n+        &'hir Expr<'hir>,\n+        &'hir Expr<'hir>,\n+        Option<&'hir Expr<'hir>>,\n+    ),\n+}\n \n-                if let Some(replacement_str) = replacement {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        QUESTION_MARK,\n-                        expr.span,\n-                        \"this block may be rewritten with the `?` operator\",\n-                        \"replace it with\",\n-                        replacement_str,\n-                        applicability,\n-                    );\n+/// Checks if the given expression on the given context matches the following structure:\n+///\n+/// ```ignore\n+/// if option.is_none() {\n+///    return None;\n+/// }\n+/// ```\n+///\n+/// ```ignore\n+/// if result.is_err() {\n+///     return result;\n+/// }\n+/// ```\n+///\n+/// If it matches, it will suggest to use the question mark operator instead\n+fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n+    if_chain! {\n+        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n+        if !is_else_clause(cx.tcx, expr);\n+        if let ExprKind::MethodCall(segment, args, _) = &cond.kind;\n+        if let Some(caller) = args.get(0);\n+        let caller_ty = cx.typeck_results().expr_ty(caller);\n+        let if_block = IfBlockType::IfIs(caller, caller_ty, segment.ident.name, then, r#else);\n+        if is_early_return(sym::Option, cx, &if_block) || is_early_return(sym::Result, cx, &if_block);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let receiver_str = snippet_with_applicability(cx, caller.span, \"..\", &mut applicability);\n+            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx.at(caller.span), cx.param_env) &&\n+                !matches!(caller.kind, ExprKind::Call(..) | ExprKind::MethodCall(..));\n+            let sugg = if let Some(else_inner) = r#else {\n+                if eq_expr_value(cx, caller, peel_blocks(else_inner)) {\n+                    format!(\"Some({}?)\", receiver_str)\n+                } else {\n+                    return;\n                 }\n-            }\n+            } else {\n+                format!(\"{}{}?;\", receiver_str, if by_ref { \".as_ref()\" } else { \"\" })\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                QUESTION_MARK,\n+                expr.span,\n+                \"this block may be rewritten with the `?` operator\",\n+                \"replace it with\",\n+                sugg,\n+                applicability,\n+            );\n         }\n     }\n+}\n \n-    fn check_if_let_some_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n-                = higher::IfLet::hir(cx, expr);\n-            if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n-            if (Self::option_check_and_early_return(cx, let_expr, if_else) && is_lang_ctor(cx, path1, OptionSome)) ||\n-                (Self::result_check_and_early_return(cx, let_expr, if_else) && is_lang_ctor(cx, path1, ResultOk));\n-\n-            if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n+fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n+    if_chain! {\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else }) = higher::IfLet::hir(cx, expr);\n+        if !is_else_clause(cx.tcx, expr);\n+        if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n+        if let PatKind::Binding(annot, bind_id, ident, _) = fields[0].kind;\n+        let caller_ty = cx.typeck_results().expr_ty(let_expr);\n+        let if_block = IfBlockType::IfLet(path1, caller_ty, ident.name, let_expr, if_then, if_else);\n+        if (is_early_return(sym::Option, cx, &if_block) && path_to_local_id(peel_blocks(if_then), bind_id))\n+            || is_early_return(sym::Result, cx, &if_block);\n+        if if_else.map(|e| eq_expr_value(cx, let_expr, peel_blocks(e))).filter(|e| *e).is_none();\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-            if path_to_local_id(peel_blocks(if_then), bind_id);\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n-                let replacement = format!(\"{}{}?\", receiver_str, if by_ref { \".as_ref()\" } else { \"\" },);\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    QUESTION_MARK,\n-                    expr.span,\n-                    \"this if-let-else may be rewritten with the `?` operator\",\n-                    \"replace it with\",\n-                    replacement,\n-                    applicability,\n-                );\n-            }\n+            let requires_semi = matches!(get_parent_node(cx.tcx, expr.hir_id), Some(Node::Stmt(_)));\n+            let sugg = format!(\n+                \"{}{}?{}\",\n+                receiver_str,\n+                if by_ref { \".as_ref()\" } else { \"\" },\n+                if requires_semi { \";\" } else { \"\" }\n+            );\n+            span_lint_and_sugg(\n+                cx,\n+                QUESTION_MARK,\n+                expr.span,\n+                \"this block may be rewritten with the `?` operator\",\n+                \"replace it with\",\n+                sugg,\n+                applicability,\n+            );\n         }\n     }\n+}\n \n-    fn result_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n-        Self::is_result(cx, expr) && Self::expression_returns_unmodified_err(nested_expr, expr)\n-    }\n-\n-    fn option_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n-        Self::is_option(cx, expr) && Self::expression_returns_none(cx, nested_expr)\n-    }\n-\n-    fn moves_by_default(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.typeck_results().expr_ty(expression);\n-\n-        !expr_ty.is_copy_modulo_regions(cx.tcx.at(expression.span), cx.param_env)\n-    }\n-\n-    fn is_option(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.typeck_results().expr_ty(expression);\n-\n-        is_type_diagnostic_item(cx, expr_ty, sym::Option)\n-    }\n-\n-    fn is_result(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.typeck_results().expr_ty(expression);\n-\n-        is_type_diagnostic_item(cx, expr_ty, sym::Result)\n-    }\n-\n-    fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        match peel_blocks_with_stmt(expression).kind {\n-            ExprKind::Ret(Some(expr)) => Self::expression_returns_none(cx, expr),\n-            ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n-            _ => false,\n-        }\n+fn is_early_return(smbl: Symbol, cx: &LateContext<'_>, if_block: &IfBlockType<'_>) -> bool {\n+    match *if_block {\n+        IfBlockType::IfIs(caller, caller_ty, call_sym, if_then, _) => {\n+            // If the block could be identified as `if x.is_none()/is_err()`,\n+            // we then only need to check the if_then return to see if it is none/err.\n+            is_type_diagnostic_item(cx, caller_ty, smbl)\n+                && expr_return_none_or_err(smbl, cx, if_then, caller, None)\n+                && match smbl {\n+                    sym::Option => call_sym == sym!(is_none),\n+                    sym::Result => call_sym == sym!(is_err),\n+                    _ => false,\n+                }\n+        },\n+        IfBlockType::IfLet(qpath, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n+            is_type_diagnostic_item(cx, let_expr_ty, smbl)\n+                && match smbl {\n+                    sym::Option => {\n+                        // We only need to check `if let Some(x) = option` not `if let None = option`,\n+                        // because the later one will be suggested as `if option.is_none()` thus causing conflict.\n+                        is_lang_ctor(cx, qpath, OptionSome)\n+                            && if_else.is_some()\n+                            && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, None)\n+                    },\n+                    sym::Result => {\n+                        (is_lang_ctor(cx, qpath, ResultOk)\n+                            && if_else.is_some()\n+                            && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, Some(let_pat_sym)))\n+                            || is_lang_ctor(cx, qpath, ResultErr)\n+                                && expr_return_none_or_err(smbl, cx, if_then, let_expr, Some(let_pat_sym))\n+                    },\n+                    _ => false,\n+                }\n+        },\n     }\n+}\n \n-    fn expression_returns_unmodified_err(expr: &Expr<'_>, cond_expr: &Expr<'_>) -> bool {\n-        match peel_blocks_with_stmt(expr).kind {\n-            ExprKind::Ret(Some(ret_expr)) => Self::expression_returns_unmodified_err(ret_expr, cond_expr),\n-            ExprKind::Path(_) => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n+fn expr_return_none_or_err(\n+    smbl: Symbol,\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cond_expr: &Expr<'_>,\n+    err_sym: Option<Symbol>,\n+) -> bool {\n+    match peel_blocks_with_stmt(expr).kind {\n+        ExprKind::Ret(Some(ret_expr)) => expr_return_none_or_err(smbl, cx, ret_expr, cond_expr, err_sym),\n+        ExprKind::Path(ref qpath) => match smbl {\n+            sym::Option => is_lang_ctor(cx, qpath, OptionNone),\n+            sym::Result => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n-        }\n+        },\n+        ExprKind::Call(call_expr, args_expr) => {\n+            if_chain! {\n+                if smbl == sym::Result;\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = &call_expr.kind;\n+                if let Some(segment) = path.segments.first();\n+                if let Some(err_sym) = err_sym;\n+                if let Some(arg) = args_expr.first();\n+                if let ExprKind::Path(QPath::Resolved(_, arg_path)) = &arg.kind;\n+                if let Some(PathSegment { ident, .. }) = arg_path.segments.first();\n+                then {\n+                    return segment.ident.name == sym::Err && err_sym == ident.name;\n+                }\n+            }\n+            false\n+        },\n+        _ => false,\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for QuestionMark {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        Self::check_is_none_or_err_and_early_return(cx, expr);\n-        Self::check_if_let_some_or_err_and_early_return(cx, expr);\n+        check_is_none_or_err_and_early_return(cx, expr);\n+        check_if_let_some_or_err_and_early_return(cx, expr);\n     }\n }"}, {"sha": "0c9178fb85efe39a0a3e7938e658b162fcb2efc1", "filename": "tests/ui/needless_match.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fneedless_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fneedless_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.fixed?ref=49f73e14a9e1db294f1e08511cb279a65c2f88b1", "patch": "@@ -99,6 +99,7 @@ fn if_let_result() {\n     let _: Result<i32, i32> = x;\n     let _: Result<i32, i32> = x;\n     // Input type mismatch, don't trigger\n+    #[allow(clippy::question_mark)]\n     let _: Result<i32, i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n }\n "}, {"sha": "f66f01d7ccaf4ef2f96be1e2e2247cebf83884f2", "filename": "tests/ui/needless_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.rs?ref=49f73e14a9e1db294f1e08511cb279a65c2f88b1", "patch": "@@ -122,6 +122,7 @@ fn if_let_result() {\n     let _: Result<i32, i32> = if let Err(e) = x { Err(e) } else { x };\n     let _: Result<i32, i32> = if let Ok(val) = x { Ok(val) } else { x };\n     // Input type mismatch, don't trigger\n+    #[allow(clippy::question_mark)]\n     let _: Result<i32, i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n }\n "}, {"sha": "5bc79800a1a748bcbbb696e6fa824c791af3e647", "filename": "tests/ui/needless_match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fneedless_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fneedless_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.stderr?ref=49f73e14a9e1db294f1e08511cb279a65c2f88b1", "patch": "@@ -84,7 +84,7 @@ LL |     let _: Result<i32, i32> = if let Ok(val) = x { Ok(val) } else { x };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:129:21\n+  --> $DIR/needless_match.rs:130:21\n    |\n LL |       let _: Simple = if let Simple::A = x {\n    |  _____________________^\n@@ -97,7 +97,7 @@ LL | |     };\n    | |_____^ help: replace it with: `x`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:168:26\n+  --> $DIR/needless_match.rs:169:26\n    |\n LL |           let _: Complex = match ce {\n    |  __________________________^"}, {"sha": "c4c9c82143336647e2dafb04292544c81797c6d5", "filename": "tests/ui/question_mark.fixed", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fquestion_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fquestion_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.fixed?ref=49f73e14a9e1db294f1e08511cb279a65c2f88b1", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![allow(unreachable_code)]\n+#![allow(dead_code)]\n #![allow(clippy::unnecessary_wraps)]\n \n fn some_func(a: Option<u32>) -> Option<u32> {\n@@ -154,26 +155,56 @@ fn f() -> NotOption {\n     NotOption::First\n }\n \n-fn main() {\n-    some_func(Some(42));\n-    some_func(None);\n-    some_other_func(Some(42));\n+fn do_something() {}\n \n-    let copy_struct = CopyStruct { opt: Some(54) };\n-    copy_struct.func();\n+fn err_immediate_return() -> Result<i32, i32> {\n+    func_returning_result()?;\n+    Ok(1)\n+}\n \n-    let move_struct = MoveStruct {\n-        opt: Some(vec![42, 1337]),\n-    };\n-    move_struct.ref_func();\n-    move_struct.clone().mov_func_reuse();\n-    move_struct.mov_func_no_use();\n+fn err_immediate_return_and_do_something() -> Result<i32, i32> {\n+    func_returning_result()?;\n+    do_something();\n+    Ok(1)\n+}\n \n-    let so = SeemsOption::Some(45);\n-    returns_something_similar_to_option(so);\n+// No warning\n+fn no_immediate_return() -> Result<i32, i32> {\n+    if let Err(err) = func_returning_result() {\n+        do_something();\n+        return Err(err);\n+    }\n+    Ok(1)\n+}\n \n-    func();\n+// No warning\n+fn mixed_result_and_option() -> Option<i32> {\n+    if let Err(err) = func_returning_result() {\n+        return Some(err);\n+    }\n+    None\n+}\n+\n+// No warning\n+fn else_if_check() -> Result<i32, i32> {\n+    if true {\n+        Ok(1)\n+    } else if let Err(e) = func_returning_result() {\n+        Err(e)\n+    } else {\n+        Err(-1)\n+    }\n+}\n \n-    let _ = result_func(Ok(42));\n-    let _ = f();\n+// No warning\n+#[allow(clippy::manual_map)]\n+#[rustfmt::skip]\n+fn option_map() -> Option<bool> {\n+    if let Some(a) = Some(false) {\n+        Some(!a)\n+    } else {\n+        None\n+    }\n }\n+\n+fn main() {}"}, {"sha": "cdbc7b1606f80782c7d107e213311e4b79cb6769", "filename": "tests/ui/question_mark.rs", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.rs?ref=49f73e14a9e1db294f1e08511cb279a65c2f88b1", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![allow(unreachable_code)]\n+#![allow(dead_code)]\n #![allow(clippy::unnecessary_wraps)]\n \n fn some_func(a: Option<u32>) -> Option<u32> {\n@@ -186,26 +187,60 @@ fn f() -> NotOption {\n     NotOption::First\n }\n \n-fn main() {\n-    some_func(Some(42));\n-    some_func(None);\n-    some_other_func(Some(42));\n+fn do_something() {}\n \n-    let copy_struct = CopyStruct { opt: Some(54) };\n-    copy_struct.func();\n+fn err_immediate_return() -> Result<i32, i32> {\n+    if let Err(err) = func_returning_result() {\n+        return Err(err);\n+    }\n+    Ok(1)\n+}\n \n-    let move_struct = MoveStruct {\n-        opt: Some(vec![42, 1337]),\n-    };\n-    move_struct.ref_func();\n-    move_struct.clone().mov_func_reuse();\n-    move_struct.mov_func_no_use();\n+fn err_immediate_return_and_do_something() -> Result<i32, i32> {\n+    if let Err(err) = func_returning_result() {\n+        return Err(err);\n+    }\n+    do_something();\n+    Ok(1)\n+}\n \n-    let so = SeemsOption::Some(45);\n-    returns_something_similar_to_option(so);\n+// No warning\n+fn no_immediate_return() -> Result<i32, i32> {\n+    if let Err(err) = func_returning_result() {\n+        do_something();\n+        return Err(err);\n+    }\n+    Ok(1)\n+}\n \n-    func();\n+// No warning\n+fn mixed_result_and_option() -> Option<i32> {\n+    if let Err(err) = func_returning_result() {\n+        return Some(err);\n+    }\n+    None\n+}\n \n-    let _ = result_func(Ok(42));\n-    let _ = f();\n+// No warning\n+fn else_if_check() -> Result<i32, i32> {\n+    if true {\n+        Ok(1)\n+    } else if let Err(e) = func_returning_result() {\n+        Err(e)\n+    } else {\n+        Err(-1)\n+    }\n }\n+\n+// No warning\n+#[allow(clippy::manual_map)]\n+#[rustfmt::skip]\n+fn option_map() -> Option<bool> {\n+    if let Some(a) = Some(false) {\n+        Some(!a)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1b6cd524b2f2339484878443a9e09f2acc00917a", "filename": "tests/ui/question_mark.stderr", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fquestion_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49f73e14a9e1db294f1e08511cb279a65c2f88b1/tests%2Fui%2Fquestion_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.stderr?ref=49f73e14a9e1db294f1e08511cb279a65c2f88b1", "patch": "@@ -1,5 +1,5 @@\n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:6:5\n+  --> $DIR/question_mark.rs:7:5\n    |\n LL | /     if a.is_none() {\n LL | |         return None;\n@@ -9,23 +9,23 @@ LL | |     }\n    = note: `-D clippy::question-mark` implied by `-D warnings`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:51:9\n+  --> $DIR/question_mark.rs:52:9\n    |\n LL | /         if (self.opt).is_none() {\n LL | |             return None;\n LL | |         }\n    | |_________^ help: replace it with: `(self.opt)?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:55:9\n+  --> $DIR/question_mark.rs:56:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None\n LL | |         }\n    | |_________^ help: replace it with: `self.opt?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:59:17\n+  --> $DIR/question_mark.rs:60:17\n    |\n LL |           let _ = if self.opt.is_none() {\n    |  _________________^\n@@ -35,8 +35,8 @@ LL | |             self.opt\n LL | |         };\n    | |_________^ help: replace it with: `Some(self.opt?)`\n \n-error: this if-let-else may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:65:17\n+error: this block may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:66:17\n    |\n LL |           let _ = if let Some(x) = self.opt {\n    |  _________________^\n@@ -47,31 +47,31 @@ LL | |         };\n    | |_________^ help: replace it with: `self.opt?`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:82:9\n+  --> $DIR/question_mark.rs:83:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n    | |_________^ help: replace it with: `self.opt.as_ref()?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:90:9\n+  --> $DIR/question_mark.rs:91:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n    | |_________^ help: replace it with: `self.opt.as_ref()?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:98:9\n+  --> $DIR/question_mark.rs:99:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n    | |_________^ help: replace it with: `self.opt.as_ref()?;`\n \n-error: this if-let-else may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:105:26\n+error: this block may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:106:26\n    |\n LL |           let v: &Vec<_> = if let Some(ref v) = self.opt {\n    |  __________________________^\n@@ -81,8 +81,8 @@ LL | |             return None;\n LL | |         };\n    | |_________^ help: replace it with: `self.opt.as_ref()?`\n \n-error: this if-let-else may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:115:17\n+error: this block may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:116:17\n    |\n LL |           let v = if let Some(v) = self.opt {\n    |  _________________^\n@@ -93,26 +93,42 @@ LL | |         };\n    | |_________^ help: replace it with: `self.opt?`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:130:5\n+  --> $DIR/question_mark.rs:131:5\n    |\n LL | /     if f().is_none() {\n LL | |         return None;\n LL | |     }\n    | |_____^ help: replace it with: `f()?;`\n \n-error: this if-let-else may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:142:13\n+error: this block may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:143:13\n    |\n LL |     let _ = if let Ok(x) = x { x } else { return x };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x?`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:144:5\n+  --> $DIR/question_mark.rs:145:5\n    |\n LL | /     if x.is_err() {\n LL | |         return x;\n LL | |     }\n    | |_____^ help: replace it with: `x?;`\n \n-error: aborting due to 13 previous errors\n+error: this block may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:193:5\n+   |\n+LL | /     if let Err(err) = func_returning_result() {\n+LL | |         return Err(err);\n+LL | |     }\n+   | |_____^ help: replace it with: `func_returning_result()?;`\n+\n+error: this block may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:200:5\n+   |\n+LL | /     if let Err(err) = func_returning_result() {\n+LL | |         return Err(err);\n+LL | |     }\n+   | |_____^ help: replace it with: `func_returning_result()?;`\n+\n+error: aborting due to 15 previous errors\n "}]}