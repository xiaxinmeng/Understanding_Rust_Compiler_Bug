{"sha": "7c6c7e8785fa553baf43ea82382a97ec01466b9b", "node_id": "C_kwDOAAsO6NoAKDdjNmM3ZTg3ODVmYTU1M2JhZjQzZWE4MjM4MmE5N2VjMDE0NjZiOWI", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-07-28T09:07:49Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-07-28T09:08:47Z"}, "message": "Introduce an ArchiveBuilderBuilder\n\nThis avoids monomorphizing all linker code for each codegen backend and\nwill allow passing in extra information to the archive builder from the\ncodegen backend.", "tree": {"sha": "5db0200867b436e0a450e3ba31fdbd6eb36a24c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5db0200867b436e0a450e3ba31fdbd6eb36a24c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c6c7e8785fa553baf43ea82382a97ec01466b9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6c7e8785fa553baf43ea82382a97ec01466b9b", "html_url": "https://github.com/rust-lang/rust/commit/7c6c7e8785fa553baf43ea82382a97ec01466b9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c6c7e8785fa553baf43ea82382a97ec01466b9b/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90da3c6f2b4db9bde02138830de1ea14982b1512", "url": "https://api.github.com/repos/rust-lang/rust/commits/90da3c6f2b4db9bde02138830de1ea14982b1512", "html_url": "https://github.com/rust-lang/rust/commit/90da3c6f2b4db9bde02138830de1ea14982b1512"}], "stats": {"total": 354, "additions": 210, "deletions": 144}, "files": [{"sha": "b4c790961707900f839ad4977a89d5e725cf9f69", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=7c6c7e8785fa553baf43ea82382a97ec01466b9b", "patch": "@@ -5,7 +5,7 @@ use std::fs::File;\n use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n use object::read::archive::ArchiveFile;\n@@ -17,6 +17,32 @@ enum ArchiveEntry {\n     File(PathBuf),\n }\n \n+pub(crate) struct ArArchiveBuilderBuilder;\n+\n+impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n+        Box::new(ArArchiveBuilder {\n+            sess,\n+            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n+            // FIXME fix builtin ranlib on macOS\n+            no_builtin_ranlib: sess.target.is_like_osx,\n+\n+            src_archives: vec![],\n+            entries: vec![],\n+        })\n+    }\n+\n+    fn create_dll_import_lib(\n+        &self,\n+        _sess: &Session,\n+        _lib_name: &str,\n+        _dll_imports: &[rustc_session::cstore::DllImport],\n+        _tmpdir: &Path,\n+    ) -> PathBuf {\n+        bug!(\"creating dll imports is not supported\");\n+    }\n+}\n+\n pub(crate) struct ArArchiveBuilder<'a> {\n     sess: &'a Session,\n     use_gnu_style_archive: bool,\n@@ -29,29 +55,18 @@ pub(crate) struct ArArchiveBuilder<'a> {\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn new(sess: &'a Session) -> Self {\n-        ArArchiveBuilder {\n-            sess,\n-            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n-            // FIXME fix builtin ranlib on macOS\n-            no_builtin_ranlib: sess.target.is_like_osx,\n-\n-            src_archives: vec![],\n-            entries: vec![],\n-        }\n-    }\n-\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n             ArchiveEntry::File(file.to_owned()),\n         ));\n     }\n \n-    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive_path: &Path,\n+        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> std::io::Result<()> {\n         let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n         let archive = ArchiveFile::parse(&read_cache).unwrap();\n         let archive_index = self.src_archives.len();\n@@ -72,7 +87,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn build(mut self, output: &Path) -> bool {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n         enum BuilderKind {\n             Bsd(ar::Builder<File>),\n             Gnu(ar::GnuBuilder<File>),\n@@ -218,13 +233,4 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n         any_members\n     }\n-\n-    fn create_dll_import_lib(\n-        _sess: &Session,\n-        _lib_name: &str,\n-        _dll_imports: &[rustc_session::cstore::DllImport],\n-        _tmpdir: &Path,\n-    ) -> PathBuf {\n-        bug!(\"creating dll imports is not supported\");\n-    }\n }"}, {"sha": "bb0793b1deb2e8e75262648ebc89ab6b1d1e76e5", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=7c6c7e8785fa553baf43ea82382a97ec01466b9b", "patch": "@@ -226,7 +226,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorGuaranteed> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        link_binary::<crate::archive::ArArchiveBuilder<'_>>(sess, &codegen_results, outputs)\n+        link_binary(sess, &crate::archive::ArArchiveBuilderBuilder, &codegen_results, outputs)\n     }\n }\n "}, {"sha": "f863abdcc97ec12739924bc026ac9d8e1849b928", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=7c6c7e8785fa553baf43ea82382a97ec01466b9b", "patch": "@@ -1,7 +1,7 @@\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n use rustc_session::cstore::DllImport;\n@@ -21,41 +21,56 @@ enum ArchiveEntry {\n     File(PathBuf),\n }\n \n-pub struct ArArchiveBuilder<'a> {\n-    config: ArchiveConfig<'a>,\n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(String, ArchiveEntry)>,\n-}\n+pub struct ArArchiveBuilderBuilder;\n \n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn new(sess: &'a Session) -> Self {\n+impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n         let config = ArchiveConfig {\n             sess,\n             use_native_ar: false,\n             // FIXME test for linux and System V derivatives instead\n             use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n         };\n \n-        ArArchiveBuilder {\n+        Box::new(ArArchiveBuilder {\n             config,\n             src_archives: vec![],\n             entries: vec![],\n-        }\n+        })\n     }\n \n+    fn create_dll_import_lib(\n+        &self,\n+        _sess: &Session,\n+        _lib_name: &str,\n+        _dll_imports: &[DllImport],\n+        _tmpdir: &Path,\n+    ) -> PathBuf {\n+        unimplemented!();\n+    }\n+}\n+\n+pub struct ArArchiveBuilder<'a> {\n+    config: ArchiveConfig<'a>,\n+    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n+    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n+    // the end of an archive for linkers to not get confused.\n+    entries: Vec<(String, ArchiveEntry)>,\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string(),\n             ArchiveEntry::File(file.to_owned()),\n         ));\n     }\n \n-    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive_path: &Path,\n+        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> std::io::Result<()> {\n         let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n         let archive_index = self.src_archives.len();\n \n@@ -75,7 +90,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn build(mut self, output: &Path) -> bool {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n         use std::process::Command;\n \n         fn add_file_using_ar(archive: &Path, file: &Path) {\n@@ -171,13 +186,4 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n         any_members\n     }\n-\n-    fn create_dll_import_lib(\n-        _sess: &Session,\n-        _lib_name: &str,\n-        _dll_imports: &[DllImport],\n-        _tmpdir: &Path,\n-    ) -> PathBuf {\n-        unimplemented!();\n-    }\n }"}, {"sha": "8a206c0368fcb0ec2c7e5ad9bdecac3b99e87c16", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=7c6c7e8785fa553baf43ea82382a97ec01466b9b", "patch": "@@ -133,8 +133,9 @@ impl CodegenBackend for GccCodegenBackend {\n     fn link(&self, sess: &Session, codegen_results: CodegenResults, outputs: &OutputFilenames) -> Result<(), ErrorGuaranteed> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n+        link_binary(\n             sess,\n+            &crate::archive::ArArchiveBuilderBuilder,\n             &codegen_results,\n             outputs,\n         )"}, {"sha": "27039cda253825f5fca016bd63e5c9c398d63988", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=7c6c7e8785fa553baf43ea82382a97ec01466b9b", "patch": "@@ -10,7 +10,7 @@ use std::str;\n \n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::cstore::{DllCallingConvention, DllImport};\n use rustc_session::Session;\n \n@@ -53,16 +53,11 @@ fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n }\n \n impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n-    /// Creates a new static archive, ready for modifying the archive specified\n-    /// by `config`.\n-    fn new(sess: &'a Session) -> LlvmArchiveBuilder<'a> {\n-        LlvmArchiveBuilder { sess, additions: Vec::new() }\n-    }\n-\n-    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive: &Path,\n+        skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> io::Result<()> {\n         let archive_ro = match ArchiveRO::open(archive) {\n             Ok(ar) => ar,\n             Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n@@ -87,14 +82,23 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n \n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n-    fn build(mut self, output: &Path) -> bool {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n         match self.build_with_llvm(output) {\n             Ok(any_members) => any_members,\n             Err(e) => self.sess.fatal(&format!(\"failed to build archive: {}\", e)),\n         }\n     }\n+}\n+\n+pub struct LlvmArchiveBuilderBuilder;\n+\n+impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n+        Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n+    }\n \n     fn create_dll_import_lib(\n+        &self,\n         sess: &Session,\n         lib_name: &str,\n         dll_imports: &[DllImport],"}, {"sha": "eeb1ed61f288f9245a9b497794c25d294da72d9e", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=7c6c7e8785fa553baf43ea82382a97ec01466b9b", "patch": "@@ -370,12 +370,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n         codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorGuaranteed> {\n-        use crate::back::archive::LlvmArchiveBuilder;\n+        use crate::back::archive::LlvmArchiveBuilderBuilder;\n         use rustc_codegen_ssa::back::link::link_binary;\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        link_binary::<LlvmArchiveBuilder<'_>>(sess, &codegen_results, outputs)\n+        link_binary(sess, &LlvmArchiveBuilderBuilder, &codegen_results, outputs)\n     }\n }\n "}, {"sha": "0d2aa483d3d4a03c45d6a3d3b53b69b4ff691a5f", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=7c6c7e8785fa553baf43ea82382a97ec01466b9b", "patch": "@@ -39,26 +39,31 @@ pub(super) fn find_library(\n     ));\n }\n \n-pub trait ArchiveBuilder<'a> {\n-    fn new(sess: &'a Session) -> Self;\n-\n-    fn add_file(&mut self, path: &Path);\n-\n-    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static;\n-\n-    fn build(self, output: &Path) -> bool;\n+pub trait ArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n \n     /// Creates a DLL Import Library <https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-creation#creating-an-import-library>.\n     /// and returns the path on disk to that import library.\n     /// This functions doesn't take `self` so that it can be called from\n     /// `linker_with_args`, which is specialized on `ArchiveBuilder` but\n     /// doesn't take or create an instance of that type.\n     fn create_dll_import_lib(\n+        &self,\n         sess: &Session,\n         lib_name: &str,\n         dll_imports: &[DllImport],\n         tmpdir: &Path,\n     ) -> PathBuf;\n }\n+\n+pub trait ArchiveBuilder<'a> {\n+    fn add_file(&mut self, path: &Path);\n+\n+    fn add_archive(\n+        &mut self,\n+        archive: &Path,\n+        skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> io::Result<()>;\n+\n+    fn build(self: Box<Self>, output: &Path) -> bool;\n+}"}, {"sha": "7e6a5f0366a79cc76e3d3a4cf333fcad44780558", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 109, "deletions": 65, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6c7e8785fa553baf43ea82382a97ec01466b9b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=7c6c7e8785fa553baf43ea82382a97ec01466b9b", "patch": "@@ -24,7 +24,7 @@ use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n-use super::archive::{find_library, ArchiveBuilder};\n+use super::archive::{find_library, ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::metadata::{create_rmeta_file, MetadataPosition};\n@@ -56,8 +56,9 @@ pub fn ensure_removed(diag_handler: &Handler, path: &Path) {\n \n /// Performs the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n-pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n+pub fn link_binary<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     outputs: &OutputFilenames,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -102,15 +103,28 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                 CrateType::Rlib => {\n                     let _timer = sess.timer(\"link_rlib\");\n                     info!(\"preparing rlib to {:?}\", out_filename);\n-                    link_rlib::<B>(sess, codegen_results, RlibFlavor::Normal, &path)?\n-                        .build(&out_filename);\n+                    link_rlib(\n+                        sess,\n+                        archive_builder_builder,\n+                        codegen_results,\n+                        RlibFlavor::Normal,\n+                        &path,\n+                    )?\n+                    .build(&out_filename);\n                 }\n                 CrateType::Staticlib => {\n-                    link_staticlib::<B>(sess, codegen_results, &out_filename, &path)?;\n+                    link_staticlib(\n+                        sess,\n+                        archive_builder_builder,\n+                        codegen_results,\n+                        &out_filename,\n+                        &path,\n+                    )?;\n                 }\n                 _ => {\n-                    link_natively::<B>(\n+                    link_natively(\n                         sess,\n+                        archive_builder_builder,\n                         crate_type,\n                         &out_filename,\n                         codegen_results,\n@@ -240,15 +254,16 @@ pub fn each_linked_rlib(\n /// the object file of the crate, but it also contains all of the object files from native\n /// libraries. This is done by unzipping native libraries and inserting all of the contents into\n /// this archive.\n-fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n+fn link_rlib<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     flavor: RlibFlavor,\n     tmpdir: &MaybeTempDir,\n-) -> Result<B, ErrorGuaranteed> {\n+) -> Result<Box<dyn ArchiveBuilder<'a> + 'a>, ErrorGuaranteed> {\n     let lib_search_paths = archive_search_paths(sess);\n \n-    let mut ab = <B as ArchiveBuilder>::new(sess);\n+    let mut ab = archive_builder_builder.new_archive_builder(sess);\n \n     let trailing_metadata = match flavor {\n         RlibFlavor::Normal => {\n@@ -333,7 +348,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n         if let Some(name) = lib.name {\n             let location =\n                 find_library(name.as_str(), lib.verbatim.unwrap_or(false), &lib_search_paths, sess);\n-            ab.add_archive(&location, |_| false).unwrap_or_else(|e| {\n+            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|e| {\n                 sess.fatal(&format!(\n                     \"failed to add native library {}: {}\",\n                     location.to_string_lossy(),\n@@ -346,10 +361,14 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     for (raw_dylib_name, raw_dylib_imports) in\n         collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n     {\n-        let output_path =\n-            B::create_dll_import_lib(sess, &raw_dylib_name, &raw_dylib_imports, tmpdir.as_ref());\n+        let output_path = archive_builder_builder.create_dll_import_lib(\n+            sess,\n+            &raw_dylib_name,\n+            &raw_dylib_imports,\n+            tmpdir.as_ref(),\n+        );\n \n-        ab.add_archive(&output_path, |_| false).unwrap_or_else(|e| {\n+        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|e| {\n             sess.fatal(&format!(\"failed to add native library {}: {}\", output_path.display(), e));\n         });\n     }\n@@ -442,14 +461,21 @@ fn collate_raw_dylibs(\n ///\n /// There's no need to include metadata in a static archive, so ensure to not link in the metadata\n /// object file (and also don't prepare the archive with a metadata file).\n-fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n+fn link_staticlib<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     out_filename: &Path,\n     tempdir: &MaybeTempDir,\n ) -> Result<(), ErrorGuaranteed> {\n     info!(\"preparing staticlib to {:?}\", out_filename);\n-    let mut ab = link_rlib::<B>(sess, codegen_results, RlibFlavor::StaticlibBase, tempdir)?;\n+    let mut ab = link_rlib(\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        RlibFlavor::StaticlibBase,\n+        tempdir,\n+    )?;\n     let mut all_native_libs = vec![];\n \n     let res = each_linked_rlib(&codegen_results.crate_info, &mut |cnum, path| {\n@@ -483,26 +509,29 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n         // might be also an extra name suffix\n         let obj_start = name.as_str().to_owned();\n \n-        ab.add_archive(path, move |fname: &str| {\n-            // Ignore metadata files, no matter the name.\n-            if fname == METADATA_FILENAME {\n-                return true;\n-            }\n+        ab.add_archive(\n+            path,\n+            Box::new(move |fname: &str| {\n+                // Ignore metadata files, no matter the name.\n+                if fname == METADATA_FILENAME {\n+                    return true;\n+                }\n \n-            // Don't include Rust objects if LTO is enabled\n-            if lto && looks_like_rust_object_file(fname) {\n-                return true;\n-            }\n+                // Don't include Rust objects if LTO is enabled\n+                if lto && looks_like_rust_object_file(fname) {\n+                    return true;\n+                }\n \n-            // Otherwise if this is *not* a rust object and we're skipping\n-            // objects then skip this file\n-            if skip_object_files && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n-                return true;\n-            }\n+                // Otherwise if this is *not* a rust object and we're skipping\n+                // objects then skip this file\n+                if skip_object_files && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n+                    return true;\n+                }\n \n-            // ok, don't skip this\n-            false\n-        })\n+                // ok, don't skip this\n+                false\n+            }),\n+        )\n         .unwrap();\n \n         all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n@@ -641,19 +670,21 @@ fn link_dwarf_object<'a>(\n ///\n /// This will invoke the system linker/cc to create the resulting file. This links to all upstream\n /// files as well.\n-fn link_natively<'a, B: ArchiveBuilder<'a>>(\n+fn link_natively<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     crate_type: CrateType,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n ) -> Result<(), ErrorGuaranteed> {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let (linker_path, flavor) = linker_and_flavor(sess);\n-    let mut cmd = linker_with_args::<B>(\n+    let mut cmd = linker_with_args(\n         &linker_path,\n         flavor,\n         sess,\n+        archive_builder_builder,\n         crate_type,\n         tmpdir,\n         out_filename,\n@@ -1839,10 +1870,11 @@ fn add_rpath_args(\n /// to the linking process as a whole.\n /// Order-independent options may still override each other in order-dependent fashion,\n /// e.g `--foo=yes --foo=no` may be equivalent to `--foo=no`.\n-fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n+fn linker_with_args<'a>(\n     path: &Path,\n     flavor: LinkerFlavor,\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     crate_type: CrateType,\n     tmpdir: &Path,\n     out_filename: &Path,\n@@ -1943,7 +1975,14 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // Upstream rust libraries and their non-bundled static libraries\n-    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n+    add_upstream_rust_crates(\n+        cmd,\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        crate_type,\n+        tmpdir,\n+    );\n \n     // Upstream dynamic native libraries linked with `#[link]` attributes at and `-l`\n     // command line options.\n@@ -1958,7 +1997,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     for (raw_dylib_name, raw_dylib_imports) in\n         collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n     {\n-        cmd.add_object(&B::create_dll_import_lib(\n+        cmd.add_object(&archive_builder_builder.create_dll_import_lib(\n             sess,\n             &raw_dylib_name,\n             &raw_dylib_imports,\n@@ -2248,9 +2287,10 @@ fn add_local_native_libraries(\n ///\n /// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n /// linked when producing the final output (instead of the intermediate rlib version).\n-fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n+fn add_upstream_rust_crates<'a>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     crate_type: CrateType,\n     tmpdir: &Path,\n@@ -2339,7 +2379,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+                add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n@@ -2349,7 +2389,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             }\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+                add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n \n                 // Link static native libs with \"-bundle\" modifier only if the crate they originate from\n                 // is being linked statically to the current crate.  If it's linked dynamically\n@@ -2408,7 +2448,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n-        add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+        add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -2434,9 +2474,10 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     // Note, however, that if we're not doing LTO we can just pass the rlib\n     // blindly to the linker (fast) because it's fine if it's not actually\n     // included as we're at the end of the dependency chain.\n-    fn add_static_crate<'a, B: ArchiveBuilder<'a>>(\n+    fn add_static_crate<'a>(\n         cmd: &mut dyn Linker,\n         sess: &'a Session,\n+        archive_builder_builder: &dyn ArchiveBuilderBuilder,\n         codegen_results: &CodegenResults,\n         tmpdir: &Path,\n         cnum: CrateNum,\n@@ -2476,35 +2517,38 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             let is_builtins = sess.target.no_builtins\n                 || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n-            let mut archive = <B as ArchiveBuilder>::new(sess);\n-            if let Err(e) = archive.add_archive(cratepath, move |f| {\n-                if f == METADATA_FILENAME {\n-                    return true;\n-                }\n+            let mut archive = archive_builder_builder.new_archive_builder(sess);\n+            if let Err(e) = archive.add_archive(\n+                cratepath,\n+                Box::new(move |f| {\n+                    if f == METADATA_FILENAME {\n+                        return true;\n+                    }\n \n-                let canonical = f.replace('-', \"_\");\n+                    let canonical = f.replace('-', \"_\");\n \n-                let is_rust_object =\n-                    canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n+                    let is_rust_object =\n+                        canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n \n-                // If we've been requested to skip all native object files\n-                // (those not generated by the rust compiler) then we can skip\n-                // this file. See above for why we may want to do this.\n-                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+                    // If we've been requested to skip all native object files\n+                    // (those not generated by the rust compiler) then we can skip\n+                    // this file. See above for why we may want to do this.\n+                    let skip_because_cfg_say_so = skip_native && !is_rust_object;\n \n-                // If we're performing LTO and this is a rust-generated object\n-                // file, then we don't need the object file as it's part of the\n-                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                // though, so we let that object file slide.\n-                let skip_because_lto =\n-                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n+                    // If we're performing LTO and this is a rust-generated object\n+                    // file, then we don't need the object file as it's part of the\n+                    // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                    // though, so we let that object file slide.\n+                    let skip_because_lto =\n+                        upstream_rust_objects_already_included && is_rust_object && is_builtins;\n \n-                if skip_because_cfg_say_so || skip_because_lto {\n-                    return true;\n-                }\n+                    if skip_because_cfg_say_so || skip_because_lto {\n+                        return true;\n+                    }\n \n-                false\n-            }) {\n+                    false\n+                }),\n+            ) {\n                 sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n             }\n             if archive.build(&dst) {"}]}