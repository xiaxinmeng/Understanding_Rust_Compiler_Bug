{"sha": "a6294b762859b3bb86b2a94c6857ae39beea9aeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2Mjk0Yjc2Mjg1OWIzYmI4NmIyYTk0YzY4NTdhZTM5YmVlYTlhZWI=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2019-01-16T01:38:02Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2019-01-16T01:38:02Z"}, "message": "update/remove some old readmes", "tree": {"sha": "7fee81ebf3a9fcfef959789ef2c552f54134bef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fee81ebf3a9fcfef959789ef2c552f54134bef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6294b762859b3bb86b2a94c6857ae39beea9aeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6294b762859b3bb86b2a94c6857ae39beea9aeb", "html_url": "https://github.com/rust-lang/rust/commit/a6294b762859b3bb86b2a94c6857ae39beea9aeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6294b762859b3bb86b2a94c6857ae39beea9aeb/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14ea6e50c1534a23cb51375552c14568db9ee130", "url": "https://api.github.com/repos/rust-lang/rust/commits/14ea6e50c1534a23cb51375552c14568db9ee130", "html_url": "https://github.com/rust-lang/rust/commit/14ea6e50c1534a23cb51375552c14568db9ee130"}], "stats": {"total": 246, "additions": 85, "deletions": 161}, "files": [{"sha": "56320636a67431a88e7616cfb7c9189936977ec3", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6294b762859b3bb86b2a94c6857ae39beea9aeb/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6294b762859b3bb86b2a94c6857ae39beea9aeb/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=a6294b762859b3bb86b2a94c6857ae39beea9aeb", "patch": "@@ -2,8 +2,12 @@\n \n > WARNING: This README is obsolete and will be removed soon! For\n > more info on how the current borrowck works, see the [rustc guide].\n+>\n+> As of edition 2018, region inference is done using Non-lexical lifetimes,\n+> which is described in the guide and [this RFC].\n \n [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n+[this RFC]: https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md\n \n ## Terminology\n "}, {"sha": "ea7fffe9dc1c6fdc25b673ff7b248cc1bcea9203", "filename": "src/librustc/infer/region_constraints/README.md", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a6294b762859b3bb86b2a94c6857ae39beea9aeb/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6294b762859b3bb86b2a94c6857ae39beea9aeb/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=a6294b762859b3bb86b2a94c6857ae39beea9aeb", "patch": "@@ -1,77 +1,3 @@\n-# Region constraint collection\n-\n-> WARNING: This README is obsolete and will be removed soon! For\n-> more info on how the current borrowck works, see the [rustc guide].\n+For info on how the current borrowck works, see the [rustc guide].\n \n [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n-\n-## Terminology\n-\n-Note that we use the terms region and lifetime interchangeably.\n-\n-## Introduction\n-\n-As described in the rustc guide [chapter on type inference][ti], and unlike\n-normal type inference, which is similar in spirit to H-M and thus\n-works progressively, the region type inference works by accumulating\n-constraints over the course of a function.  Finally, at the end of\n-processing a function, we process and solve the constraints all at\n-once.\n-\n-[ti]: https://rust-lang.github.io/rustc-guide/type-inference.html\n-\n-The constraints are always of one of three possible forms:\n-\n-- `ConstrainVarSubVar(Ri, Rj)` states that region variable Ri must be\n-  a subregion of Rj\n-- `ConstrainRegSubVar(R, Ri)` states that the concrete region R (which\n-  must not be a variable) must be a subregion of the variable Ri\n-- `ConstrainVarSubReg(Ri, R)` states the variable Ri should be less\n-  than the concrete region R. This is kind of deprecated and ought to\n-  be replaced with a verify (they essentially play the same role).\n-\n-In addition to constraints, we also gather up a set of \"verifys\"\n-(what, you don't think Verify is a noun? Get used to it my\n-friend!). These represent relations that must hold but which don't\n-influence inference proper. These take the form of:\n-\n-- `VerifyRegSubReg(Ri, Rj)` indicates that Ri <= Rj must hold,\n-  where Rj is not an inference variable (and Ri may or may not contain\n-  one). This doesn't influence inference because we will already have\n-  inferred Ri to be as small as possible, so then we just test whether\n-  that result was less than Rj or not.\n-- `VerifyGenericBound(R, Vb)` is a more complex expression which tests\n-  that the region R must satisfy the bound `Vb`. The bounds themselves\n-  may have structure like \"must outlive one of the following regions\"\n-  or \"must outlive ALL of the following regions. These bounds arise\n-  from constraints like `T: 'a` -- if we know that `T: 'b` and `T: 'c`\n-  (say, from where clauses), then we can conclude that `T: 'a` if `'b:\n-  'a` *or* `'c: 'a`.\n-\n-## Building up the constraints\n-\n-Variables and constraints are created using the following methods:\n-\n-- `new_region_var()` creates a new, unconstrained region variable;\n-- `make_subregion(Ri, Rj)` states that Ri is a subregion of Rj\n-- `lub_regions(Ri, Rj) -> Rk` returns a region Rk which is\n-  the smallest region that is greater than both Ri and Rj\n-- `glb_regions(Ri, Rj) -> Rk` returns a region Rk which is\n-  the greatest region that is smaller than both Ri and Rj\n-\n-The actual region resolution algorithm is not entirely\n-obvious, though it is also not overly complex.\n-\n-## Snapshotting\n-\n-It is also permitted to try (and rollback) changes to the graph.  This\n-is done by invoking `start_snapshot()`, which returns a value.  Then\n-later you can call `rollback_to()` which undoes the work.\n-Alternatively, you can call `commit()` which ends all snapshots.\n-Snapshots can be recursive---so you can start a snapshot when another\n-is in progress, but only the root snapshot can \"commit\".\n-\n-## Skolemization\n-\n-For a discussion on skolemization and higher-ranked subtyping, please\n-see the module `middle::infer::higher_ranked::doc`."}, {"sha": "982a2bacce1648459cffea4dc3cde3e83d0fb5b2", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/14ea6e50c1534a23cb51375552c14568db9ee130/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/14ea6e50c1534a23cb51375552c14568db9ee130/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=14ea6e50c1534a23cb51375552c14568db9ee130", "patch": "@@ -1,81 +0,0 @@\n-The `ObligationForest` is a utility data structure used in trait\n-matching to track the set of outstanding obligations (those not yet\n-resolved to success or error). It also tracks the \"backtrace\" of each\n-pending obligation (why we are trying to figure this out in the first\n-place).\n-\n-### External view\n-\n-`ObligationForest` supports two main public operations (there are a\n-few others not discussed here):\n-\n-1. Add a new root obligations (`push_tree`).\n-2. Process the pending obligations (`process_obligations`).\n-\n-When a new obligation `N` is added, it becomes the root of an\n-obligation tree. This tree can also carry some per-tree state `T`,\n-which is given at the same time. This tree is a singleton to start, so\n-`N` is both the root and the only leaf. Each time the\n-`process_obligations` method is called, it will invoke its callback\n-with every pending obligation (so that will include `N`, the first\n-time). The callback also receives a (mutable) reference to the\n-per-tree state `T`. The callback should process the obligation `O`\n-that it is given and return one of three results:\n-\n-- `Ok(None)` -> ambiguous result. Obligation was neither a success\n-  nor a failure. It is assumed that further attempts to process the\n-  obligation will yield the same result unless something in the\n-  surrounding environment changes.\n-- `Ok(Some(C))` - the obligation was *shallowly successful*. The\n-  vector `C` is a list of subobligations. The meaning of this is that\n-  `O` was successful on the assumption that all the obligations in `C`\n-  are also successful. Therefore, `O` is only considered a \"true\"\n-  success if `C` is empty. Otherwise, `O` is put into a suspended\n-  state and the obligations in `C` become the new pending\n-  obligations. They will be processed the next time you call\n-  `process_obligations`.\n-- `Err(E)` -> obligation failed with error `E`. We will collect this\n-  error and return it from `process_obligations`, along with the\n-  \"backtrace\" of obligations (that is, the list of obligations up to\n-  and including the root of the failed obligation). No further\n-  obligations from that same tree will be processed, since the tree is\n-  now considered to be in error.\n-\n-When the call to `process_obligations` completes, you get back an `Outcome`,\n-which includes three bits of information:\n-\n-- `completed`: a list of obligations where processing was fully\n-  completed without error (meaning that all transitive subobligations\n-  have also been completed). So, for example, if the callback from\n-  `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n-  then `O` will be considered completed right away if `C` is the\n-  empty vector. Otherwise it will only be considered completed once\n-  all the obligations in `C` have been found completed.\n-- `errors`: a list of errors that occurred and associated backtraces\n-  at the time of error, which can be used to give context to the user.\n-- `stalled`: if true, then none of the existing obligations were\n-  *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n-  This implies that all obligations were either errors or returned an\n-  ambiguous result, which means that any further calls to\n-  `process_obligations` would simply yield back further ambiguous\n-  results. This is used by the `FulfillmentContext` to decide when it\n-  has reached a steady state.\n-\n-#### Snapshots\n-\n-The `ObligationForest` supports a limited form of snapshots; see\n-`start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n-particular, you can use a snapshot to roll back new root\n-obligations. However, it is an error to attempt to\n-`process_obligations` during a snapshot.\n-\n-### Implementation details\n-\n-For the most part, comments specific to the implementation are in the\n-code.  This file only contains a very high-level overview. Basically,\n-the forest is stored in a vector. Each element of the vector is a node\n-in some tree. Each node in the vector has the index of an (optional)\n-parent and (for convenience) its root (which may be itself). It also\n-has a current state, described by `NodeState`. After each\n-processing step, we compress the vector to remove completed and error\n-nodes, which aren't needed anymore."}, {"sha": "9dd7d204f0373d5ccea71f87c629a3d33b5f6176", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a6294b762859b3bb86b2a94c6857ae39beea9aeb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6294b762859b3bb86b2a94c6857ae39beea9aeb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=a6294b762859b3bb86b2a94c6857ae39beea9aeb", "patch": "@@ -1,9 +1,84 @@\n //! The `ObligationForest` is a utility data structure used in trait\n-//! matching to track the set of outstanding obligations (those not\n-//! yet resolved to success or error). It also tracks the \"backtrace\"\n-//! of each pending obligation (why we are trying to figure this out\n-//! in the first place). See README.md for a general overview of how\n-//! to use this class.\n+//! matching to track the set of outstanding obligations (those not yet\n+//! resolved to success or error). It also tracks the \"backtrace\" of each\n+//! pending obligation (why we are trying to figure this out in the first\n+//! place).\n+//!\n+//! ### External view\n+//!\n+//! `ObligationForest` supports two main public operations (there are a\n+//! few others not discussed here):\n+//!\n+//! 1. Add a new root obligations (`push_tree`).\n+//! 2. Process the pending obligations (`process_obligations`).\n+//!\n+//! When a new obligation `N` is added, it becomes the root of an\n+//! obligation tree. This tree can also carry some per-tree state `T`,\n+//! which is given at the same time. This tree is a singleton to start, so\n+//! `N` is both the root and the only leaf. Each time the\n+//! `process_obligations` method is called, it will invoke its callback\n+//! with every pending obligation (so that will include `N`, the first\n+//! time). The callback also receives a (mutable) reference to the\n+//! per-tree state `T`. The callback should process the obligation `O`\n+//! that it is given and return one of three results:\n+//!\n+//! - `Ok(None)` -> ambiguous result. Obligation was neither a success\n+//!   nor a failure. It is assumed that further attempts to process the\n+//!   obligation will yield the same result unless something in the\n+//!   surrounding environment changes.\n+//! - `Ok(Some(C))` - the obligation was *shallowly successful*. The\n+//!   vector `C` is a list of subobligations. The meaning of this is that\n+//!   `O` was successful on the assumption that all the obligations in `C`\n+//!   are also successful. Therefore, `O` is only considered a \"true\"\n+//!   success if `C` is empty. Otherwise, `O` is put into a suspended\n+//!   state and the obligations in `C` become the new pending\n+//!   obligations. They will be processed the next time you call\n+//!   `process_obligations`.\n+//! - `Err(E)` -> obligation failed with error `E`. We will collect this\n+//!   error and return it from `process_obligations`, along with the\n+//!   \"backtrace\" of obligations (that is, the list of obligations up to\n+//!   and including the root of the failed obligation). No further\n+//!   obligations from that same tree will be processed, since the tree is\n+//!   now considered to be in error.\n+//!\n+//! When the call to `process_obligations` completes, you get back an `Outcome`,\n+//! which includes three bits of information:\n+//!\n+//! - `completed`: a list of obligations where processing was fully\n+//!   completed without error (meaning that all transitive subobligations\n+//!   have also been completed). So, for example, if the callback from\n+//!   `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n+//!   then `O` will be considered completed right away if `C` is the\n+//!   empty vector. Otherwise it will only be considered completed once\n+//!   all the obligations in `C` have been found completed.\n+//! - `errors`: a list of errors that occurred and associated backtraces\n+//!   at the time of error, which can be used to give context to the user.\n+//! - `stalled`: if true, then none of the existing obligations were\n+//!   *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n+//!   This implies that all obligations were either errors or returned an\n+//!   ambiguous result, which means that any further calls to\n+//!   `process_obligations` would simply yield back further ambiguous\n+//!   results. This is used by the `FulfillmentContext` to decide when it\n+//!   has reached a steady state.\n+//!\n+//! #### Snapshots\n+//!\n+//! The `ObligationForest` supports a limited form of snapshots; see\n+//! `start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n+//! particular, you can use a snapshot to roll back new root\n+//! obligations. However, it is an error to attempt to\n+//! `process_obligations` during a snapshot.\n+//!\n+//! ### Implementation details\n+//!\n+//! For the most part, comments specific to the implementation are in the\n+//! code.  This file only contains a very high-level overview. Basically,\n+//! the forest is stored in a vector. Each element of the vector is a node\n+//! in some tree. Each node in the vector has the index of an (optional)\n+//! parent and (for convenience) its root (which may be itself). It also\n+//! has a current state, described by `NodeState`. After each\n+//! processing step, we compress the vector to remove completed and error\n+//! nodes, which aren't needed anymore.\n \n use fx::{FxHashMap, FxHashSet};\n "}]}