{"sha": "43062c43d2a63cf4e261c6eddc417575c4f3062f", "node_id": "C_kwDOAAsO6NoAKDQzMDYyYzQzZDJhNjNjZjRlMjYxYzZlZGRjNDE3NTc1YzRmMzA2MmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-09T18:53:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-09T18:53:58Z"}, "message": "Auto merge of #112216 - est31:offset_of_deep_tuple, r=petrochenkov\n\nSupport float-like tuple indices in offset_of!()\n\nSupports invocations like `offset_of!((((), ()), ()), 0.0)`. This `0.0` gets tokenized as float literal, so it has to be broken up again.\n\nThe code that did the breaking up was returning a finished `Expr`, while we need a `Ident`, so this PR splits up the `parse_expr_tuple_field_access_float` function into:\n\n* a function that breaks up the float literal (similar to `TokenKind::break_two_token_op`, but we do access the parser during this splitting operation, so we keep it as an inherent function on the parser)\n* and a function that constructs an `Expr` from it\n\nThe former we can then re-use in `offset_of` parsing. The edge cases especially involving whitespaces are tricky so this adds a bunch of new tests as well.\n\nfixes #112204", "tree": {"sha": "e0d6040c2b9fb53c8070ba3b4e9bdaef6abd7731", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0d6040c2b9fb53c8070ba3b4e9bdaef6abd7731"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43062c43d2a63cf4e261c6eddc417575c4f3062f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43062c43d2a63cf4e261c6eddc417575c4f3062f", "html_url": "https://github.com/rust-lang/rust/commit/43062c43d2a63cf4e261c6eddc417575c4f3062f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43062c43d2a63cf4e261c6eddc417575c4f3062f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "397641f3bd4f4211d0a1e9ada8d477bf495735b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/397641f3bd4f4211d0a1e9ada8d477bf495735b2", "html_url": "https://github.com/rust-lang/rust/commit/397641f3bd4f4211d0a1e9ada8d477bf495735b2"}, {"sha": "9fb266b525938f71089f23b49d756d77f550521b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb266b525938f71089f23b49d756d77f550521b", "html_url": "https://github.com/rust-lang/rust/commit/9fb266b525938f71089f23b49d756d77f550521b"}], "stats": {"total": 432, "additions": 390, "deletions": 42}, "files": [{"sha": "cea2a71c9882164a62fff2372ccbeb2e7f11f446", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 92, "deletions": 24, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/43062c43d2a63cf4e261c6eddc417575c4f3062f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43062c43d2a63cf4e261c6eddc417575c4f3062f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=43062c43d2a63cf4e261c6eddc417575c4f3062f", "patch": "@@ -91,6 +91,18 @@ impl From<P<Expr>> for LhsExpr {\n     }\n }\n \n+#[derive(Debug)]\n+enum DestructuredFloat {\n+    /// 1e2\n+    Single(Symbol, Span),\n+    /// 1.\n+    TrailingDot(Symbol, Span, Span),\n+    /// 1.2 | 1.2e3\n+    MiddleDot(Symbol, Span, Span, Symbol, Span),\n+    /// Invalid\n+    Error,\n+}\n+\n impl<'a> Parser<'a> {\n     /// Parses an expression.\n     #[inline]\n@@ -1013,13 +1025,8 @@ impl<'a> Parser<'a> {\n     // support pushing \"future tokens\" (would be also helpful to `break_and_eat`), or\n     // we should break everything including floats into more basic proc-macro style\n     // tokens in the lexer (probably preferable).\n-    fn parse_expr_tuple_field_access_float(\n-        &mut self,\n-        lo: Span,\n-        base: P<Expr>,\n-        float: Symbol,\n-        suffix: Option<Symbol>,\n-    ) -> P<Expr> {\n+    // See also `TokenKind::break_two_token_op` which does similar splitting of `>>` into `>`.\n+    fn break_up_float(&mut self, float: Symbol) -> DestructuredFloat {\n         #[derive(Debug)]\n         enum FloatComponent {\n             IdentLike(String),\n@@ -1056,7 +1063,7 @@ impl<'a> Parser<'a> {\n         match &*components {\n             // 1e2\n             [IdentLike(i)] => {\n-                self.parse_expr_tuple_field_access(lo, base, Symbol::intern(&i), suffix, None)\n+                DestructuredFloat::Single(Symbol::intern(&i), span)\n             }\n             // 1.\n             [IdentLike(i), Punct('.')] => {\n@@ -1068,11 +1075,8 @@ impl<'a> Parser<'a> {\n                 } else {\n                     (span, span)\n                 };\n-                assert!(suffix.is_none());\n                 let symbol = Symbol::intern(&i);\n-                self.token = Token::new(token::Ident(symbol, false), ident_span);\n-                let next_token = (Token::new(token::Dot, dot_span), self.token_spacing);\n-                self.parse_expr_tuple_field_access(lo, base, symbol, None, Some(next_token))\n+                DestructuredFloat::TrailingDot(symbol, ident_span, dot_span)\n             }\n             // 1.2 | 1.2e3\n             [IdentLike(i1), Punct('.'), IdentLike(i2)] => {\n@@ -1088,16 +1092,8 @@ impl<'a> Parser<'a> {\n                     (span, span, span)\n                 };\n                 let symbol1 = Symbol::intern(&i1);\n-                self.token = Token::new(token::Ident(symbol1, false), ident1_span);\n-                // This needs to be `Spacing::Alone` to prevent regressions.\n-                // See issue #76399 and PR #76285 for more details\n-                let next_token1 = (Token::new(token::Dot, dot_span), Spacing::Alone);\n-                let base1 =\n-                    self.parse_expr_tuple_field_access(lo, base, symbol1, None, Some(next_token1));\n                 let symbol2 = Symbol::intern(&i2);\n-                let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n-                self.bump_with((next_token2, self.token_spacing)); // `.`\n-                self.parse_expr_tuple_field_access(lo, base1, symbol2, suffix, None)\n+                DestructuredFloat::MiddleDot(symbol1, ident1_span, dot_span, symbol2, ident2_span)\n             }\n             // 1e+ | 1e- (recovered)\n             [IdentLike(_), Punct('+' | '-')] |\n@@ -1109,12 +1105,83 @@ impl<'a> Parser<'a> {\n             [IdentLike(_), Punct('.'), IdentLike(_), Punct('+' | '-'), IdentLike(_)] => {\n                 // See the FIXME about `TokenCursor` above.\n                 self.error_unexpected_after_dot();\n-                base\n+                DestructuredFloat::Error\n             }\n             _ => panic!(\"unexpected components in a float token: {:?}\", components),\n         }\n     }\n \n+    fn parse_expr_tuple_field_access_float(\n+        &mut self,\n+        lo: Span,\n+        base: P<Expr>,\n+        float: Symbol,\n+        suffix: Option<Symbol>,\n+    ) -> P<Expr> {\n+        match self.break_up_float(float) {\n+            // 1e2\n+            DestructuredFloat::Single(sym, _sp) => {\n+                self.parse_expr_tuple_field_access(lo, base, sym, suffix, None)\n+            }\n+            // 1.\n+            DestructuredFloat::TrailingDot(sym, ident_span, dot_span) => {\n+                assert!(suffix.is_none());\n+                self.token = Token::new(token::Ident(sym, false), ident_span);\n+                let next_token = (Token::new(token::Dot, dot_span), self.token_spacing);\n+                self.parse_expr_tuple_field_access(lo, base, sym, None, Some(next_token))\n+            }\n+            // 1.2 | 1.2e3\n+            DestructuredFloat::MiddleDot(symbol1, ident1_span, dot_span, symbol2, ident2_span) => {\n+                self.token = Token::new(token::Ident(symbol1, false), ident1_span);\n+                // This needs to be `Spacing::Alone` to prevent regressions.\n+                // See issue #76399 and PR #76285 for more details\n+                let next_token1 = (Token::new(token::Dot, dot_span), Spacing::Alone);\n+                let base1 =\n+                    self.parse_expr_tuple_field_access(lo, base, symbol1, None, Some(next_token1));\n+                let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n+                self.bump_with((next_token2, self.token_spacing)); // `.`\n+                self.parse_expr_tuple_field_access(lo, base1, symbol2, suffix, None)\n+            }\n+            DestructuredFloat::Error => base,\n+        }\n+    }\n+\n+    fn parse_field_name_maybe_tuple(&mut self) -> PResult<'a, ThinVec<Ident>> {\n+        let token::Literal(token::Lit { kind: token::Float, symbol, suffix }) = self.token.kind\n+        else {\n+            return Ok(thin_vec![self.parse_field_name()?]);\n+        };\n+        Ok(match self.break_up_float(symbol) {\n+            // 1e2\n+            DestructuredFloat::Single(sym, sp) => {\n+                self.bump();\n+                thin_vec![Ident::new(sym, sp)]\n+            }\n+            // 1.\n+            DestructuredFloat::TrailingDot(sym, sym_span, dot_span) => {\n+                assert!(suffix.is_none());\n+                // Analogous to `Self::break_and_eat`\n+                self.token_cursor.break_last_token = true;\n+                // This might work, in cases like `1. 2`, and might not,\n+                // in cases like `offset_of!(Ty, 1.)`. It depends on what comes\n+                // after the float-like token, and therefore we have to make\n+                // the other parts of the parser think that there is a dot literal.\n+                self.token = Token::new(token::Ident(sym, false), sym_span);\n+                self.bump_with((Token::new(token::Dot, dot_span), self.token_spacing));\n+                thin_vec![Ident::new(sym, sym_span)]\n+            }\n+            // 1.2 | 1.2e3\n+            DestructuredFloat::MiddleDot(symbol1, ident1_span, _dot_span, symbol2, ident2_span) => {\n+                self.bump();\n+                thin_vec![Ident::new(symbol1, ident1_span), Ident::new(symbol2, ident2_span)]\n+            }\n+            DestructuredFloat::Error => {\n+                self.bump();\n+                thin_vec![Ident::new(symbol, self.prev_token.span)]\n+            }\n+        })\n+    }\n+\n     fn parse_expr_tuple_field_access(\n         &mut self,\n         lo: Span,\n@@ -1821,10 +1888,11 @@ impl<'a> Parser<'a> {\n         let (fields, _trailing, _recovered) = self.parse_seq_to_before_end(\n             &TokenKind::CloseDelim(Delimiter::Parenthesis),\n             seq_sep,\n-            Parser::parse_field_name,\n+            Parser::parse_field_name_maybe_tuple,\n         )?;\n+        let fields = fields.into_iter().flatten().collect::<Vec<_>>();\n         let span = lo.to(self.token.span);\n-        Ok(self.mk_expr(span, ExprKind::OffsetOf(container, fields.to_vec().into())))\n+        Ok(self.mk_expr(span, ExprKind::OffsetOf(container, fields.into())))\n     }\n \n     /// Returns a string literal if the next token is a string literal."}, {"sha": "00fbb6bf8f4077d6886b7a2be609b4768b6b663c", "filename": "tests/ui/offset-of/offset-of-tuple-nested.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43062c43d2a63cf4e261c6eddc417575c4f3062f/tests%2Fui%2Foffset-of%2Foffset-of-tuple-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43062c43d2a63cf4e261c6eddc417575c4f3062f/tests%2Fui%2Foffset-of%2Foffset-of-tuple-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-tuple-nested.rs?ref=43062c43d2a63cf4e261c6eddc417575c4f3062f", "patch": "@@ -0,0 +1,32 @@\n+// run-pass\n+// Test for issue #112204 -- make sure this goes through the entire compilation pipeline,\n+// similar to why `offset-of-unsized.rs` is also build-pass\n+\n+#![feature(offset_of)]\n+#![feature(builtin_syntax)]\n+\n+use std::mem::offset_of;\n+\n+type ComplexTup = ((u8, (u8, (u8, u16), u8)), (u8, u32, u16));\n+\n+fn main() {\n+    println!(\"{}\", offset_of!(((u8, u8), u8), 0));\n+    println!(\"{}\", offset_of!(((u8, u8), u8), 1));\n+    println!(\"{}\", offset_of!(((u8, (u8, u8)), (u8, u8, u8)), 0.1.0));\n+\n+    // Complex case: do all combinations of spacings because the spacing determines what gets\n+    // sent to the lexer.\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1.1.1));\n+    println!(\"{}\", builtin # offset_of(ComplexTup, 0. 1.1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0 . 1.1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0 .1.1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1 .1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1 . 1.1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1. 1.1));\n+    println!(\"{}\", builtin # offset_of(ComplexTup, 0.1.1. 1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1.1 . 1));\n+    println!(\"{}\", offset_of!(ComplexTup, 0.1.1 .1));\n+\n+    println!(\"{}\", offset_of!(((u8, u16), (u32, u16, u8)), 0.0));\n+    println!(\"{}\", offset_of!(((u8, u16), (u32, u16, u8)), 1.2));\n+}"}, {"sha": "e31b037ee3e01f8002201ee0e04c761dde979b70", "filename": "tests/ui/offset-of/offset-of-tuple.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/43062c43d2a63cf4e261c6eddc417575c4f3062f/tests%2Fui%2Foffset-of%2Foffset-of-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43062c43d2a63cf4e261c6eddc417575c4f3062f/tests%2Fui%2Foffset-of%2Foffset-of-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-tuple.rs?ref=43062c43d2a63cf4e261c6eddc417575c4f3062f", "patch": "@@ -1,10 +1,54 @@\n #![feature(offset_of)]\n #![feature(builtin_syntax)]\n \n+use std::mem::offset_of;\n+\n fn main() {\n-    core::mem::offset_of!((u8, u8), _0); //~ ERROR no field `_0`\n-    core::mem::offset_of!((u8, u8), +1); //~ ERROR no rules expected\n-    core::mem::offset_of!((u8, u8), -1); //~ ERROR no rules expected\n+    offset_of!((u8, u8), _0); //~ ERROR no field `_0`\n+    offset_of!((u8, u8), 01); //~ ERROR no field `01`\n+    offset_of!((u8, u8), 1e2); //~ ERROR no field `1e2`\n+    offset_of!((u8, u8), 1_u8); //~ ERROR no field `1_`\n+    //~| ERROR suffixes on a tuple index\n+    offset_of!((u8, u8), +1); //~ ERROR no rules expected\n+    offset_of!((u8, u8), -1); //~ ERROR no rules expected\n+    offset_of!((u8, u8), 1.); //~ ERROR expected identifier, found `)`\n+    offset_of!((u8, u8), 1 .); //~ ERROR unexpected end of macro\n+    builtin # offset_of((u8, u8), 1e2); //~ ERROR no field `1e2`\n     builtin # offset_of((u8, u8), _0); //~ ERROR no field `_0`\n-    builtin # offset_of((u8, u8), +1); //~ ERROR expected identifier\n+    builtin # offset_of((u8, u8), 01); //~ ERROR no field `01`\n+    builtin # offset_of((u8, u8), 1_u8); //~ ERROR no field `1_`\n+    //~| ERROR suffixes on a tuple index\n+    // We need to put these into curly braces, otherwise only one of the\n+    // errors will be emitted and the others suppressed.\n+    { builtin # offset_of((u8, u8), +1) }; //~ ERROR expected identifier, found `+`\n+    { builtin # offset_of((u8, u8), 1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of((u8, u8), 1 .) }; //~ ERROR expected identifier, found `)`\n+}\n+\n+type ComplexTup = ((u8, (u8, u8)), u8);\n+\n+fn nested() {\n+    offset_of!(((u8, u16), (u32, u16, u8)), 0.2); //~ ERROR no field `2`\n+    offset_of!(((u8, u16), (u32, u16, u8)), 1.2);\n+    offset_of!(((u8, u16), (u32, u16, u8)), 1.2.0); //~ ERROR no field `0`\n+\n+    // All combinations of spaces (this sends different tokens to the parser)\n+    offset_of!(ComplexTup, 0.0.1.); //~ ERROR expected identifier\n+    offset_of!(ComplexTup, 0 .0.1.); //~ ERROR unexpected end of macro\n+    offset_of!(ComplexTup, 0 . 0.1.); //~ ERROR unexpected end of macro\n+    offset_of!(ComplexTup, 0. 0.1.); //~ ERROR no rules expected\n+    offset_of!(ComplexTup, 0.0 .1.); //~ ERROR expected identifier, found `)`\n+    offset_of!(ComplexTup, 0.0 . 1.); //~ ERROR expected identifier, found `)`\n+    offset_of!(ComplexTup, 0.0. 1.); //~ ERROR expected identifier, found `)`\n+\n+    // Test for builtin too to ensure that the builtin syntax can also handle these cases\n+    // We need to put these into curly braces, otherwise only one of the\n+    // errors will be emitted and the others suppressed.\n+    { builtin # offset_of(ComplexTup, 0.0.1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0 .0.1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0 . 0.1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0. 0.1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0.0 .1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0.0 . 1.) }; //~ ERROR expected identifier, found `)`\n+    { builtin # offset_of(ComplexTup, 0.0. 1.) }; //~ ERROR expected identifier, found `)`\n }"}, {"sha": "954515f80a65ed3a2e090d116065aa6bd1c6950a", "filename": "tests/ui/offset-of/offset-of-tuple.stderr", "status": "modified", "additions": 218, "deletions": 14, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/43062c43d2a63cf4e261c6eddc417575c4f3062f/tests%2Fui%2Foffset-of%2Foffset-of-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/43062c43d2a63cf4e261c6eddc417575c4f3062f/tests%2Fui%2Foffset-of%2Foffset-of-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-tuple.stderr?ref=43062c43d2a63cf4e261c6eddc417575c4f3062f", "patch": "@@ -1,37 +1,241 @@\n+error: suffixes on a tuple index are invalid\n+  --> $DIR/offset-of-tuple.rs:19:35\n+   |\n+LL |     builtin # offset_of((u8, u8), 1_u8);\n+   |                                   ^^^^ invalid suffix `u8`\n+\n error: expected identifier, found `+`\n-  --> $DIR/offset-of-tuple.rs:9:35\n+  --> $DIR/offset-of-tuple.rs:23:37\n+   |\n+LL |     { builtin # offset_of((u8, u8), +1) };\n+   |                                     ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:24:39\n+   |\n+LL |     { builtin # offset_of((u8, u8), 1.) };\n+   |                                       ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:25:40\n+   |\n+LL |     { builtin # offset_of((u8, u8), 1 .) };\n+   |                                        ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:47:45\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0.0.1.) };\n+   |                                             ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:48:46\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0 .0.1.) };\n+   |                                              ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:49:47\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0 . 0.1.) };\n+   |                                               ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:50:46\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0. 0.1.) };\n+   |                                              ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:51:46\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0.0 .1.) };\n+   |                                              ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:52:47\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0.0 . 1.) };\n+   |                                               ^ expected identifier\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:53:46\n+   |\n+LL |     { builtin # offset_of(ComplexTup, 0.0. 1.) };\n+   |                                              ^ expected identifier\n+\n+error: suffixes on a tuple index are invalid\n+  --> $DIR/offset-of-tuple.rs:10:26\n    |\n-LL |     builtin # offset_of((u8, u8), +1);\n-   |                                   ^ expected identifier\n+LL |     offset_of!((u8, u8), 1_u8);\n+   |                          ^^^^ invalid suffix `u8`\n \n error: no rules expected the token `1`\n-  --> $DIR/offset-of-tuple.rs:6:38\n+  --> $DIR/offset-of-tuple.rs:12:27\n    |\n-LL |     core::mem::offset_of!((u8, u8), +1);\n-   |                                      ^ no rules expected this token in macro call\n+LL |     offset_of!((u8, u8), +1);\n+   |                           ^ no rules expected this token in macro call\n    |\n    = note: while trying to match sequence start\n \n error: no rules expected the token `1`\n-  --> $DIR/offset-of-tuple.rs:7:38\n+  --> $DIR/offset-of-tuple.rs:13:27\n    |\n-LL |     core::mem::offset_of!((u8, u8), -1);\n-   |                                      ^ no rules expected this token in macro call\n+LL |     offset_of!((u8, u8), -1);\n+   |                           ^ no rules expected this token in macro call\n    |\n    = note: while trying to match sequence start\n \n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:14:5\n+   |\n+LL |     offset_of!((u8, u8), 1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-tuple.rs:15:29\n+   |\n+LL |     offset_of!((u8, u8), 1 .);\n+   |                             ^ missing tokens in macro arguments\n+   |\n+note: while trying to match meta-variable `$fields:tt`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:36:5\n+   |\n+LL |     offset_of!(ComplexTup, 0.0.1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-tuple.rs:37:35\n+   |\n+LL |     offset_of!(ComplexTup, 0 .0.1.);\n+   |                                   ^ missing tokens in macro arguments\n+   |\n+note: while trying to match meta-variable `$fields:tt`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-tuple.rs:38:36\n+   |\n+LL |     offset_of!(ComplexTup, 0 . 0.1.);\n+   |                                    ^ missing tokens in macro arguments\n+   |\n+note: while trying to match meta-variable `$fields:tt`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+\n+error: no rules expected the token `0.1`\n+  --> $DIR/offset-of-tuple.rs:39:31\n+   |\n+LL |     offset_of!(ComplexTup, 0. 0.1.);\n+   |                               ^^^ no rules expected this token in macro call\n+   |\n+   = note: while trying to match sequence start\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:40:5\n+   |\n+LL |     offset_of!(ComplexTup, 0.0 .1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:41:5\n+   |\n+LL |     offset_of!(ComplexTup, 0.0 . 1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-tuple.rs:42:5\n+   |\n+LL |     offset_of!(ComplexTup, 0.0. 1.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     expected identifier\n+   |     in this macro invocation\n+   |\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error[E0609]: no field `_0` on type `(u8, u8)`\n-  --> $DIR/offset-of-tuple.rs:5:37\n+  --> $DIR/offset-of-tuple.rs:7:26\n    |\n-LL |     core::mem::offset_of!((u8, u8), _0);\n-   |                                     ^^\n+LL |     offset_of!((u8, u8), _0);\n+   |                          ^^\n+\n+error[E0609]: no field `01` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:8:26\n+   |\n+LL |     offset_of!((u8, u8), 01);\n+   |                          ^^\n+\n+error[E0609]: no field `1e2` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:9:26\n+   |\n+LL |     offset_of!((u8, u8), 1e2);\n+   |                          ^^^\n+\n+error[E0609]: no field `1_` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:10:26\n+   |\n+LL |     offset_of!((u8, u8), 1_u8);\n+   |                          ^^^^\n+\n+error[E0609]: no field `1e2` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:16:35\n+   |\n+LL |     builtin # offset_of((u8, u8), 1e2);\n+   |                                   ^^^\n \n error[E0609]: no field `_0` on type `(u8, u8)`\n-  --> $DIR/offset-of-tuple.rs:8:35\n+  --> $DIR/offset-of-tuple.rs:17:35\n    |\n LL |     builtin # offset_of((u8, u8), _0);\n    |                                   ^^\n \n-error: aborting due to 5 previous errors\n+error[E0609]: no field `01` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:18:35\n+   |\n+LL |     builtin # offset_of((u8, u8), 01);\n+   |                                   ^^\n+\n+error[E0609]: no field `1_` on type `(u8, u8)`\n+  --> $DIR/offset-of-tuple.rs:19:35\n+   |\n+LL |     builtin # offset_of((u8, u8), 1_u8);\n+   |                                   ^^^^\n+\n+error[E0609]: no field `2` on type `(u8, u16)`\n+  --> $DIR/offset-of-tuple.rs:31:47\n+   |\n+LL |     offset_of!(((u8, u16), (u32, u16, u8)), 0.2);\n+   |                                               ^\n+\n+error[E0609]: no field `0` on type `u8`\n+  --> $DIR/offset-of-tuple.rs:33:49\n+   |\n+LL |     offset_of!(((u8, u16), (u32, u16, u8)), 1.2.0);\n+   |                                                 ^\n+\n+error: aborting due to 33 previous errors\n \n For more information about this error, try `rustc --explain E0609`."}]}