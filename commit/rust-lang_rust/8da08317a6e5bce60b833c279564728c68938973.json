{"sha": "8da08317a6e5bce60b833c279564728c68938973", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYTA4MzE3YTZlNWJjZTYwYjgzM2MyNzk1NjQ3MjhjNjg5Mzg5NzM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-31T23:02:32Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-31T23:02:32Z"}, "message": "Move benchmark tests to unstable section\n\nFixes #23881", "tree": {"sha": "d82c1378fb5584f9e2afc6ceb05d5c8f4c4fb090", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d82c1378fb5584f9e2afc6ceb05d5c8f4c4fb090"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da08317a6e5bce60b833c279564728c68938973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da08317a6e5bce60b833c279564728c68938973", "html_url": "https://github.com/rust-lang/rust/commit/8da08317a6e5bce60b833c279564728c68938973", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da08317a6e5bce60b833c279564728c68938973/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80bf31dd514055177b22c3dc66836d39eb5b1648", "url": "https://api.github.com/repos/rust-lang/rust/commits/80bf31dd514055177b22c3dc66836d39eb5b1648", "html_url": "https://github.com/rust-lang/rust/commit/80bf31dd514055177b22c3dc66836d39eb5b1648"}], "stats": {"total": 299, "additions": 153, "deletions": 146}, "files": [{"sha": "136e155b1afe3e6f9f6d00f29b8b9718c12e585a", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8da08317a6e5bce60b833c279564728c68938973/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/8da08317a6e5bce60b833c279564728c68938973/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=8da08317a6e5bce60b833c279564728c68938973", "patch": "@@ -42,5 +42,6 @@\n     * [Intrinsics](intrinsics.md)\n     * [Lang items](lang-items.md)\n     * [Link args](link-args.md)\n+    * [Benchmark Tests](benchmark-tests.md)\n * [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "887965375932b3fe4953179a96d4dd54ec23c32e", "filename": "src/doc/trpl/benchmark-tests.md", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/8da08317a6e5bce60b833c279564728c68938973/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/8da08317a6e5bce60b833c279564728c68938973/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md?ref=8da08317a6e5bce60b833c279564728c68938973", "patch": "@@ -0,0 +1,152 @@\n+% Benchmark tests\n+\n+Rust supports benchmark tests, which can test the performance of your\n+code. Let's make our `src/lib.rs` look like this (comments elided):\n+\n+```{rust,ignore}\n+#![feature(test)]\n+\n+extern crate test;\n+\n+pub fn add_two(a: i32) -> i32 {\n+    a + 2\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test::Bencher;\n+\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(4, add_two(2));\n+    }\n+\n+    #[bench]\n+    fn bench_add_two(b: &mut Bencher) {\n+        b.iter(|| add_two(2));\n+    }\n+}\n+```\n+\n+Note the `test` feature gate, which enables this unstable feature.\n+\n+We've imported the `test` crate, which contains our benchmarking support.\n+We have a new function as well, with the `bench` attribute. Unlike regular\n+tests, which take no arguments, benchmark tests take a `&mut Bencher`. This\n+`Bencher` provides an `iter` method, which takes a closure. This closure\n+contains the code we'd like to benchmark.\n+\n+We can run benchmark tests with `cargo bench`:\n+\n+```bash\n+$ cargo bench\n+   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n+     Running target/release/adder-91b3e234d4ed382a\n+\n+running 2 tests\n+test tests::it_works ... ignored\n+test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)\n+\n+test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured\n+```\n+\n+Our non-benchmark test was ignored. You may have noticed that `cargo bench`\n+takes a bit longer than `cargo test`. This is because Rust runs our benchmark\n+a number of times, and then takes the average. Because we're doing so little\n+work in this example, we have a `1 ns/iter (+/- 0)`, but this would show\n+the variance if there was one.\n+\n+Advice on writing benchmarks:\n+\n+\n+* Move setup code outside the `iter` loop; only put the part you want to measure inside\n+* Make the code do \"the same thing\" on each iteration; do not accumulate or change state\n+* Make the outer function idempotent too; the benchmark runner is likely to run\n+  it many times\n+*  Make the inner `iter` loop short and fast so benchmark runs are fast and the\n+   calibrator can adjust the run-length at fine resolution\n+* Make the code in the `iter` loop do something simple, to assist in pinpointing\n+  performance improvements (or regressions)\n+\n+## Gotcha: optimizations\n+\n+There's another tricky part to writing benchmarks: benchmarks compiled with\n+optimizations activated can be dramatically changed by the optimizer so that\n+the benchmark is no longer benchmarking what one expects. For example, the\n+compiler might recognize that some calculation has no external effects and\n+remove it entirely.\n+\n+```{rust,ignore}\n+#![feature(test)]\n+\n+extern crate test;\n+use test::Bencher;\n+\n+#[bench]\n+fn bench_xor_1000_ints(b: &mut Bencher) {\n+    b.iter(|| {\n+        (0..1000).fold(0, |old, new| old ^ new);\n+    });\n+}\n+```\n+\n+gives the following results\n+\n+```text\n+running 1 test\n+test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n+```\n+\n+The benchmarking runner offers two ways to avoid this. Either, the closure that\n+the `iter` method receives can return an arbitrary value which forces the\n+optimizer to consider the result used and ensures it cannot remove the\n+computation entirely. This could be done for the example above by adjusting the\n+`b.iter` call to\n+\n+```rust\n+# struct X;\n+# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n+b.iter(|| {\n+    // note lack of `;` (could also use an explicit `return`).\n+    (0..1000).fold(0, |old, new| old ^ new)\n+});\n+```\n+\n+Or, the other option is to call the generic `test::black_box` function, which\n+is an opaque \"black box\" to the optimizer and so forces it to consider any\n+argument as used.\n+\n+```rust\n+#![feature(test)]\n+\n+extern crate test;\n+\n+# fn main() {\n+# struct X;\n+# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n+b.iter(|| {\n+    let n = test::black_box(1000);\n+\n+    (0..n).fold(0, |a, b| a ^ b)\n+})\n+# }\n+```\n+\n+Neither of these read or modify the value, and are very cheap for small values.\n+Larger values can be passed indirectly to reduce overhead (e.g.\n+`black_box(&huge_struct)`).\n+\n+Performing either of the above changes gives the following benchmarking results\n+\n+```text\n+running 1 test\n+test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n+```\n+\n+However, the optimizer can still modify a testcase in an undesirable manner\n+even when using either of the above."}, {"sha": "fddb4c19031726f51f9dfe0930c40dbb4ff538fb", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/8da08317a6e5bce60b833c279564728c68938973/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/8da08317a6e5bce60b833c279564728c68938973/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=8da08317a6e5bce60b833c279564728c68938973", "patch": "@@ -430,149 +430,3 @@ documentation tests: the `_0` is generated for the module test, and `add_two_0`\n for the function test. These will auto increment with names like `add_two_1` as\n you add more examples.\n \n-# Benchmark tests\n-\n-Rust also supports benchmark tests, which can test the performance of your\n-code. Let's make our `src/lib.rs` look like this (comments elided):\n-\n-```{rust,ignore}\n-extern crate test;\n-\n-pub fn add_two(a: i32) -> i32 {\n-    a + 2\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test::Bencher;\n-\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(4, add_two(2));\n-    }\n-\n-    #[bench]\n-    fn bench_add_two(b: &mut Bencher) {\n-        b.iter(|| add_two(2));\n-    }\n-}\n-```\n-\n-We've imported the `test` crate, which contains our benchmarking support.\n-We have a new function as well, with the `bench` attribute. Unlike regular\n-tests, which take no arguments, benchmark tests take a `&mut Bencher`. This\n-`Bencher` provides an `iter` method, which takes a closure. This closure\n-contains the code we'd like to benchmark.\n-\n-We can run benchmark tests with `cargo bench`:\n-\n-```bash\n-$ cargo bench\n-   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n-     Running target/release/adder-91b3e234d4ed382a\n-\n-running 2 tests\n-test tests::it_works ... ignored\n-test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)\n-\n-test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured\n-```\n-\n-Our non-benchmark test was ignored. You may have noticed that `cargo bench`\n-takes a bit longer than `cargo test`. This is because Rust runs our benchmark\n-a number of times, and then takes the average. Because we're doing so little\n-work in this example, we have a `1 ns/iter (+/- 0)`, but this would show\n-the variance if there was one.\n-\n-Advice on writing benchmarks:\n-\n-\n-* Move setup code outside the `iter` loop; only put the part you want to measure inside\n-* Make the code do \"the same thing\" on each iteration; do not accumulate or change state\n-* Make the outer function idempotent too; the benchmark runner is likely to run\n-  it many times\n-*  Make the inner `iter` loop short and fast so benchmark runs are fast and the\n-   calibrator can adjust the run-length at fine resolution\n-* Make the code in the `iter` loop do something simple, to assist in pinpointing\n-  performance improvements (or regressions)\n-\n-## Gotcha: optimizations\n-\n-There's another tricky part to writing benchmarks: benchmarks compiled with\n-optimizations activated can be dramatically changed by the optimizer so that\n-the benchmark is no longer benchmarking what one expects. For example, the\n-compiler might recognize that some calculation has no external effects and\n-remove it entirely.\n-\n-```{rust,ignore}\n-extern crate test;\n-use test::Bencher;\n-\n-#[bench]\n-fn bench_xor_1000_ints(b: &mut Bencher) {\n-    b.iter(|| {\n-        (0..1000).fold(0, |old, new| old ^ new);\n-    });\n-}\n-```\n-\n-gives the following results\n-\n-```text\n-running 1 test\n-test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n-```\n-\n-The benchmarking runner offers two ways to avoid this. Either, the closure that\n-the `iter` method receives can return an arbitrary value which forces the\n-optimizer to consider the result used and ensures it cannot remove the\n-computation entirely. This could be done for the example above by adjusting the\n-`b.iter` call to\n-\n-```rust\n-# struct X;\n-# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n-b.iter(|| {\n-    // note lack of `;` (could also use an explicit `return`).\n-    (0..1000).fold(0, |old, new| old ^ new)\n-});\n-```\n-\n-Or, the other option is to call the generic `test::black_box` function, which\n-is an opaque \"black box\" to the optimizer and so forces it to consider any\n-argument as used.\n-\n-```rust\n-# #![feature(test)]\n-\n-extern crate test;\n-\n-# fn main() {\n-# struct X;\n-# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n-b.iter(|| {\n-    let n = test::black_box(1000);\n-\n-    (0..n).fold(0, |a, b| a ^ b)\n-})\n-# }\n-```\n-\n-Neither of these read or modify the value, and are very cheap for small values.\n-Larger values can be passed indirectly to reduce overhead (e.g.\n-`black_box(&huge_struct)`).\n-\n-Performing either of the above changes gives the following benchmarking results\n-\n-```text\n-running 1 test\n-test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n-```\n-\n-However, the optimizer can still modify a testcase in an undesirable manner\n-even when using either of the above."}]}