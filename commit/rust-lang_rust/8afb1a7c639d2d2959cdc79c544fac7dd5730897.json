{"sha": "8afb1a7c639d2d2959cdc79c544fac7dd5730897", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZmIxYTdjNjM5ZDJkMjk1OWNkYzc5YzU0NGZhYzdkZDU3MzA4OTc=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-15T00:08:22Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-15T00:08:45Z"}, "message": "refactor: Move the LLVM type and constant constructors into a new module.", "tree": {"sha": "f4a349131134cf40bbf394612e668685617531e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4a349131134cf40bbf394612e668685617531e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8afb1a7c639d2d2959cdc79c544fac7dd5730897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8afb1a7c639d2d2959cdc79c544fac7dd5730897", "html_url": "https://github.com/rust-lang/rust/commit/8afb1a7c639d2d2959cdc79c544fac7dd5730897", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8afb1a7c639d2d2959cdc79c544fac7dd5730897/comments", "author": null, "committer": null, "parents": [{"sha": "e2fcd29bbd7dc58b4af5f498cb1f323822ffc254", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2fcd29bbd7dc58b4af5f498cb1f323822ffc254", "html_url": "https://github.com/rust-lang/rust/commit/e2fcd29bbd7dc58b4af5f498cb1f323822ffc254"}], "stats": {"total": 957, "additions": 511, "deletions": 446}, "files": [{"sha": "6d95b25b95b6b922b05f2dfcc8cb75c07602c4de", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=8afb1a7c639d2d2959cdc79c544fac7dd5730897", "patch": "@@ -1,22 +1,22 @@\n \n import middle::trans;\n import trans::decl_cdecl_fn;\n-import trans::T_f32;\n-import trans::T_f64;\n-import trans::T_fn;\n-import trans::T_bool;\n-import trans::T_i8;\n-import trans::T_i32;\n-import trans::T_int;\n-import trans::T_nil;\n-import trans::T_opaque_chan_ptr;\n-import trans::T_opaque_ivec;\n-import trans::T_opaque_port_ptr;\n-import trans::T_opaque_vec_ptr;\n-import trans::T_ptr;\n-import trans::T_size_t;\n-import trans::T_str;\n-import trans::T_void;\n+import middle::trans_common::T_f32;\n+import middle::trans_common::T_f64;\n+import middle::trans_common::T_fn;\n+import middle::trans_common::T_bool;\n+import middle::trans_common::T_i8;\n+import middle::trans_common::T_i32;\n+import middle::trans_common::T_int;\n+import middle::trans_common::T_nil;\n+import middle::trans_common::T_opaque_chan_ptr;\n+import middle::trans_common::T_opaque_ivec;\n+import middle::trans_common::T_opaque_port_ptr;\n+import middle::trans_common::T_opaque_vec_ptr;\n+import middle::trans_common::T_ptr;\n+import middle::trans_common::T_size_t;\n+import middle::trans_common::T_str;\n+import middle::trans_common::T_void;\n import lib::llvm::type_names;\n import lib::llvm::llvm::ModuleRef;\n import lib::llvm::llvm::ValueRef;"}, {"sha": "fa10792454644e4b75e5ba3d4804f0e5587632a5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 425, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8afb1a7c639d2d2959cdc79c544fac7dd5730897", "patch": "@@ -65,6 +65,8 @@ import util::ppaux::ty_to_short_str;\n import syntax::print::pprust::expr_to_str;\n import syntax::print::pprust::path_to_str;\n \n+import trans_common::*;\n+\n obj namegen(mutable int i) {\n     fn next(str prefix) -> str { i += 1; ret prefix + int::str(i); }\n }\n@@ -399,330 +401,6 @@ fn struct_elt(TypeRef llstructty, uint n) -> TypeRef {\n }\n \n \n-// LLVM type constructors.\n-fn T_void() -> TypeRef {\n-    // Note: For the time being llvm is kinda busted here, it has the notion\n-    // of a 'void' type that can only occur as part of the signature of a\n-    // function, but no general unit type of 0-sized value. This is, afaict,\n-    // vestigial from its C heritage, and we'll be attempting to submit a\n-    // patch upstream to fix it. In the mean time we only model function\n-    // outputs (Rust functions and C functions) using T_void, and model the\n-    // Rust general purpose nil type you can construct as 1-bit (always\n-    // zero). This makes the result incorrect for now -- things like a tuple\n-    // of 10 nil values will have 10-bit size -- but it doesn't seem like we\n-    // have any other options until it's fixed upstream.\n-\n-    ret llvm::LLVMVoidType();\n-}\n-\n-fn T_nil() -> TypeRef {\n-    // NB: See above in T_void().\n-\n-    ret llvm::LLVMInt1Type();\n-}\n-\n-fn T_i1() -> TypeRef { ret llvm::LLVMInt1Type(); }\n-\n-fn T_i8() -> TypeRef { ret llvm::LLVMInt8Type(); }\n-\n-fn T_i16() -> TypeRef { ret llvm::LLVMInt16Type(); }\n-\n-fn T_i32() -> TypeRef { ret llvm::LLVMInt32Type(); }\n-\n-fn T_i64() -> TypeRef { ret llvm::LLVMInt64Type(); }\n-\n-fn T_f32() -> TypeRef { ret llvm::LLVMFloatType(); }\n-\n-fn T_f64() -> TypeRef { ret llvm::LLVMDoubleType(); }\n-\n-fn T_bool() -> TypeRef { ret T_i1(); }\n-\n-fn T_int() -> TypeRef {\n-    // FIXME: switch on target type.\n-\n-    ret T_i32();\n-}\n-\n-fn T_float() -> TypeRef {\n-    // FIXME: switch on target type.\n-\n-    ret T_f64();\n-}\n-\n-fn T_char() -> TypeRef { ret T_i32(); }\n-\n-fn T_size_t() -> TypeRef {\n-    // FIXME: switch on target type.\n-\n-    ret T_i32();\n-}\n-\n-fn T_fn(&TypeRef[] inputs, TypeRef output) -> TypeRef {\n-    ret llvm::LLVMFunctionType(output, std::ivec::to_ptr(inputs),\n-                               std::ivec::len[TypeRef](inputs), False);\n-}\n-\n-fn T_fn_pair(&crate_ctxt cx, TypeRef tfn) -> TypeRef {\n-    ret T_struct(~[T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n-}\n-\n-fn T_ptr(TypeRef t) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n-\n-fn T_struct(&TypeRef[] elts) -> TypeRef {\n-    ret llvm::LLVMStructType(std::ivec::to_ptr(elts), std::ivec::len(elts),\n-                             False);\n-}\n-\n-fn T_named_struct(&str name) -> TypeRef {\n-    auto c = llvm::LLVMGetGlobalContext();\n-    ret llvm::LLVMStructCreateNamed(c, str::buf(name));\n-}\n-\n-fn set_struct_body(TypeRef t, &TypeRef[] elts) {\n-    llvm::LLVMStructSetBody(t, std::ivec::to_ptr(elts), std::ivec::len(elts),\n-                            False);\n-}\n-\n-fn T_empty_struct() -> TypeRef { ret T_struct(~[]); }\n-\n-fn T_rust_object() -> TypeRef {\n-    auto t = T_named_struct(\"rust_object\");\n-    auto e = T_ptr(T_empty_struct());\n-    set_struct_body(t, ~[e,e]);\n-    ret t;\n-}\n-\n-fn T_task() -> TypeRef {\n-    auto t = T_named_struct(\"task\");\n-\n-    auto elems = ~[T_int(), // Refcount\n-                   T_int(), // Delegate pointer\n-                   T_int(), // Stack segment pointer\n-                   T_int(), // Runtime SP\n-                   T_int(), // Rust SP\n-                   T_int(), // GC chain\n-\n-                   T_int(), // Domain pointer\n-                            // Crate cache pointer\n-                   T_int()];\n-    set_struct_body(t, elems);\n-    ret t;\n-}\n-\n-fn T_tydesc_field(&crate_ctxt cx, int field) -> TypeRef {\n-    // Bit of a kludge: pick the fn typeref out of the tydesc..\n-\n-    let TypeRef[] tydesc_elts =\n-        std::ivec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n-    llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n-                                    std::ivec::to_ptr[TypeRef](tydesc_elts));\n-    auto t = llvm::LLVMGetElementType(tydesc_elts.(field));\n-    ret t;\n-}\n-\n-fn T_glue_fn(&crate_ctxt cx) -> TypeRef {\n-    auto s = \"glue_fn\";\n-    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n-    auto t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n-    cx.tn.associate(s, t);\n-    ret t;\n-}\n-\n-fn T_dtor(&@crate_ctxt ccx, &span sp) -> TypeRef {\n-    ret type_of_fn_full(ccx, sp, ast::proto_fn, true,\n-                        ~[], ty::mk_nil(ccx.tcx), 0u);\n-}\n-\n-fn T_cmp_glue_fn(&crate_ctxt cx) -> TypeRef {\n-    auto s = \"cmp_glue_fn\";\n-    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n-    auto t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n-    cx.tn.associate(s, t);\n-    ret t;\n-}\n-\n-fn T_tydesc(TypeRef taskptr_type) -> TypeRef {\n-    auto tydesc = T_named_struct(\"tydesc\");\n-    auto tydescpp = T_ptr(T_ptr(tydesc));\n-    auto pvoid = T_ptr(T_i8());\n-    auto glue_fn_ty =\n-        T_ptr(T_fn(~[T_ptr(T_nil()), taskptr_type, T_ptr(T_nil()), tydescpp,\n-                     pvoid], T_void()));\n-    auto cmp_glue_fn_ty =\n-        T_ptr(T_fn(~[T_ptr(T_i1()), taskptr_type, T_ptr(T_nil()), tydescpp,\n-                     pvoid, pvoid, T_i8()], T_void()));\n-\n-    auto elems = ~[tydescpp,   // first_param\n-                   T_int(),    // size\n-                   T_int(),    // align\n-                   glue_fn_ty, // copy_glue\n-                   glue_fn_ty, // drop_glue\n-                   glue_fn_ty, // free_glue\n-                   glue_fn_ty, // sever_glue\n-                   glue_fn_ty, // mark_glue\n-                   glue_fn_ty, // obj_drop_glue\n-                   glue_fn_ty, // is_stateful\n-                   cmp_glue_fn_ty];\n-    set_struct_body(tydesc, elems);\n-    ret tydesc;\n-}\n-\n-fn T_array(TypeRef t, uint n) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n-\n-fn T_vec(TypeRef t) -> TypeRef {\n-    ret T_struct(~[T_int(), // Refcount\n-                   T_int(), // Alloc\n-                   T_int(), // Fill\n-\n-                   T_int(), // Pad\n-                           // Body elements\n-                            T_array(t, 0u)]);\n-}\n-\n-fn T_opaque_vec_ptr() -> TypeRef { ret T_ptr(T_vec(T_int())); }\n-\n-\n-// Interior vector.\n-//\n-// TODO: Support user-defined vector sizes.\n-fn T_ivec(TypeRef t) -> TypeRef {\n-    ret T_struct(~[T_int(), // Length (\"fill\"; if zero, heapified)\n-                   T_int(), // Alloc\n-                   T_array(t, abi::ivec_default_length)]); // Body elements\n-\n-}\n-\n-\n-// Note that the size of this one is in bytes.\n-fn T_opaque_ivec() -> TypeRef {\n-    ret T_struct(~[T_int(), // Length (\"fill\"; if zero, heapified)\n-                   T_int(), // Alloc\n-                   T_array(T_i8(), 0u)]); // Body elements\n-\n-}\n-\n-fn T_ivec_heap_part(TypeRef t) -> TypeRef {\n-    ret T_struct(~[T_int(), // Real length\n-                   T_array(t, 0u)]); // Body elements\n-\n-}\n-\n-\n-// Interior vector on the heap, also known as the \"stub\". Cast to this when\n-// the allocated length (second element of T_ivec above) is zero.\n-fn T_ivec_heap(TypeRef t) -> TypeRef {\n-    ret T_struct(~[T_int(), // Length (zero)\n-                   T_int(), // Alloc\n-                   T_ptr(T_ivec_heap_part(t))]); // Pointer\n-\n-}\n-\n-fn T_opaque_ivec_heap_part() -> TypeRef {\n-    ret T_struct(~[T_int(), // Real length\n-                   T_array(T_i8(), 0u)]); // Body elements\n-\n-}\n-\n-fn T_opaque_ivec_heap() -> TypeRef {\n-    ret T_struct(~[T_int(), // Length (zero)\n-                   T_int(), // Alloc\n-                   T_ptr(T_opaque_ivec_heap_part())]); // Pointer\n-\n-}\n-\n-fn T_str() -> TypeRef { ret T_vec(T_i8()); }\n-\n-fn T_box(TypeRef t) -> TypeRef { ret T_struct(~[T_int(), t]); }\n-\n-fn T_port(TypeRef t) -> TypeRef {\n-    ret T_struct(~[T_int()]); // Refcount\n-\n-}\n-\n-fn T_chan(TypeRef t) -> TypeRef {\n-    ret T_struct(~[T_int()]); // Refcount\n-\n-}\n-\n-fn T_taskptr(&crate_ctxt cx) -> TypeRef { ret T_ptr(cx.task_type); }\n-\n-\n-// This type must never be used directly; it must always be cast away.\n-fn T_typaram(&type_names tn) -> TypeRef {\n-    auto s = \"typaram\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-    auto t = T_i8();\n-    tn.associate(s, t);\n-    ret t;\n-}\n-\n-fn T_typaram_ptr(&type_names tn) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n-\n-fn T_closure_ptr(&crate_ctxt cx, TypeRef lltarget_ty, TypeRef llbindings_ty,\n-                 uint n_ty_params) -> TypeRef {\n-    // NB: keep this in sync with code in trans_bind; we're making\n-    // an LLVM typeref structure that has the same \"shape\" as the ty::t\n-    // it constructs.\n-\n-    ret T_ptr(T_box(T_struct(~[T_ptr(cx.tydesc_type), lltarget_ty,\n-                               llbindings_ty,\n-                               T_captured_tydescs(cx, n_ty_params)])));\n-}\n-\n-fn T_opaque_closure_ptr(&crate_ctxt cx) -> TypeRef {\n-    auto s = \"*closure\";\n-    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n-    auto t =\n-        T_closure_ptr(cx,\n-                      T_struct(~[T_ptr(T_nil()), T_ptr(T_nil())]),\n-                      T_nil(),\n-                      0u);\n-    cx.tn.associate(s, t);\n-    ret t;\n-}\n-\n-fn T_tag(&type_names tn, uint size) -> TypeRef {\n-    auto s = \"tag_\" + uint::to_str(size, 10u);\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-    auto t = T_struct(~[T_int(), T_array(T_i8(), size)]);\n-    tn.associate(s, t);\n-    ret t;\n-}\n-\n-fn T_opaque_tag(&type_names tn) -> TypeRef {\n-    auto s = \"opaque_tag\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-    auto t = T_struct(~[T_int(), T_i8()]);\n-    tn.associate(s, t);\n-    ret t;\n-}\n-\n-fn T_opaque_tag_ptr(&type_names tn) -> TypeRef {\n-    ret T_ptr(T_opaque_tag(tn));\n-}\n-\n-fn T_captured_tydescs(&crate_ctxt cx, uint n) -> TypeRef {\n-    ret T_struct(std::ivec::init_elt[TypeRef](T_ptr(cx.tydesc_type), n));\n-}\n-\n-fn T_obj_ptr(&crate_ctxt cx, uint n_captured_tydescs) -> TypeRef {\n-    // This function is not publicly exposed because it returns an incomplete\n-    // type. The dynamically-sized fields follow the captured tydescs.\n-\n-    fn T_obj(&crate_ctxt cx, uint n_captured_tydescs) -> TypeRef {\n-        ret T_struct(~[T_ptr(cx.tydesc_type),\n-                       T_captured_tydescs(cx, n_captured_tydescs)]);\n-    }\n-    ret T_ptr(T_box(T_obj(cx, n_captured_tydescs)));\n-}\n-\n-fn T_opaque_obj_ptr(&crate_ctxt cx) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n-\n-fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n-\n-fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n-\n-\n // This function now fails if called on a type with dynamic size (as its\n // return value was always meaningless in that case anyhow). Beware!\n //\n@@ -1009,106 +687,6 @@ fn sanitize(&str s) -> str {\n }\n \n \n-// LLVM constant constructors.\n-fn C_null(TypeRef t) -> ValueRef { ret llvm::LLVMConstNull(t); }\n-\n-fn C_integral(TypeRef t, uint u, Bool sign_extend) -> ValueRef {\n-    // FIXME: We can't use LLVM::ULongLong with our existing minimal native\n-    // API, which only knows word-sized args.\n-    //\n-    // ret llvm::LLVMConstInt(T_int(), t as LLVM::ULongLong, False);\n-    //\n-\n-    ret llvm::LLVMRustConstSmallInt(t, u, sign_extend);\n-}\n-\n-fn C_float(&str s) -> ValueRef {\n-    ret llvm::LLVMConstRealOfString(T_float(), str::buf(s));\n-}\n-\n-fn C_floating(&str s, TypeRef t) -> ValueRef {\n-    ret llvm::LLVMConstRealOfString(t, str::buf(s));\n-}\n-\n-fn C_nil() -> ValueRef {\n-    // NB: See comment above in T_void().\n-\n-    ret C_integral(T_i1(), 0u, False);\n-}\n-\n-fn C_bool(bool b) -> ValueRef {\n-    if (b) {\n-        ret C_integral(T_bool(), 1u, False);\n-    } else { ret C_integral(T_bool(), 0u, False); }\n-}\n-\n-fn C_int(int i) -> ValueRef { ret C_integral(T_int(), i as uint, True); }\n-\n-fn C_uint(uint i) -> ValueRef { ret C_integral(T_int(), i, False); }\n-\n-fn C_u8(uint i) -> ValueRef { ret C_integral(T_i8(), i, False); }\n-\n-\n-// This is a 'c-like' raw string, which differs from\n-// our boxed-and-length-annotated strings.\n-fn C_cstr(&@crate_ctxt cx, &str s) -> ValueRef {\n-    auto sc = llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n-    auto g =\n-        llvm::LLVMAddGlobal(cx.llmod, val_ty(sc),\n-                            str::buf(cx.names.next(\"str\")));\n-    llvm::LLVMSetInitializer(g, sc);\n-    llvm::LLVMSetGlobalConstant(g, True);\n-    llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    ret g;\n-}\n-\n-\n-// A rust boxed-and-length-annotated string.\n-fn C_str(&@crate_ctxt cx, &str s) -> ValueRef {\n-    auto len = str::byte_len(s);\n-    auto box =\n-        C_struct(~[C_int(abi::const_refcount as int),\n-                   C_int(len + 1u as int), // 'alloc'\n-                   C_int(len + 1u as int), // 'fill'\n-                   C_int(0), // 'pad'\n-                   llvm::LLVMConstString(str::buf(s), len, False)]);\n-    auto g =\n-        llvm::LLVMAddGlobal(cx.llmod, val_ty(box),\n-                            str::buf(cx.names.next(\"str\")));\n-    llvm::LLVMSetInitializer(g, box);\n-    llvm::LLVMSetGlobalConstant(g, True);\n-    llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    ret llvm::LLVMConstPointerCast(g, T_ptr(T_str()));\n-}\n-\n-// Returns a Plain Old LLVM String:\n-fn C_postr(&str s) -> ValueRef {\n-    ret llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n-}\n-\n-fn C_zero_byte_arr(uint size) -> ValueRef {\n-    auto i = 0u;\n-    let ValueRef[] elts = ~[];\n-    while (i < size) { elts += ~[C_u8(0u)]; i += 1u; }\n-    ret llvm::LLVMConstArray(T_i8(), std::ivec::to_ptr(elts),\n-                             std::ivec::len(elts));\n-}\n-\n-fn C_struct(&ValueRef[] elts) -> ValueRef {\n-    ret llvm::LLVMConstStruct(std::ivec::to_ptr(elts), std::ivec::len(elts),\n-                              False);\n-}\n-\n-fn C_named_struct(TypeRef T, &ValueRef[] elts) -> ValueRef {\n-    ret llvm::LLVMConstNamedStruct(T, std::ivec::to_ptr(elts),\n-                                   std::ivec::len(elts));\n-}\n-\n-fn C_array(TypeRef ty, &ValueRef[] elts) -> ValueRef {\n-    ret llvm::LLVMConstArray(ty, std::ivec::to_ptr(elts),\n-                             std::ivec::len(elts));\n-}\n-\n fn decl_fn(ModuleRef llmod, &str name, uint cc, TypeRef llty) -> ValueRef {\n     let ValueRef llfn = llvm::LLVMAddFunction(llmod, str::buf(name), llty);\n     llvm::LLVMSetFunctionCallConv(llfn, cc);\n@@ -9250,7 +8828,7 @@ fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n fn write_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) {\n     if (!cx.sess.get_opts().library) { ret; }\n     auto llmeta = C_postr(metadata::encoder::encode_metadata(cx, crate));\n-    auto llconst = trans::C_struct(~[llmeta]);\n+    auto llconst = trans_common::C_struct(~[llmeta]);\n     auto llglobal =\n         llvm::LLVMAddGlobal(cx.llmod, trans::val_ty(llconst),\n                             str::buf(\"rust_metadata\"));"}, {"sha": "bc9a7fe235c25fbcb538b05b331eab62bdbe76a0", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=8afb1a7c639d2d2959cdc79c544fac7dd5730897", "patch": "@@ -16,16 +16,15 @@ import trans::block_ctxt;\n import trans::new_sub_block_ctxt;\n import trans::new_scope_block_ctxt;\n import trans::load_if_immediate;\n-import trans::C_int;\n-import trans::C_uint;\n-import trans::C_nil;\n import trans::val_ty;\n import ty::pat_ty;\n import syntax::ast;\n import syntax::ast::def_id;\n import syntax::codemap::span;\n import util::common::lit_eq;\n \n+import trans_common::*;\n+\n // An option identifying a branch (either a literal or a tag variant)\n tag opt {\n     lit(@ast::lit);\n@@ -201,7 +200,7 @@ fn extract_variant_args(@block_ctxt bcx, ast::node_id pat_id,\n                           (ccx.tcx, vdefs._0, vdefs._1).args);\n     if (size > 0u && ivec::len(variants) != 1u) {\n         auto tagptr = bcx.build.PointerCast\n-            (val, trans::T_opaque_tag_ptr(ccx.tn));\n+            (val, trans_common::T_opaque_tag_ptr(ccx.tn));\n         blobptr = bcx.build.GEP(tagptr, ~[C_int(0), C_int(1)]);\n     }\n     auto i = 0u;\n@@ -315,7 +314,7 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n                     kind = single;\n                 } else {\n                     auto tagptr = bcx.build.PointerCast\n-                        (val, trans::T_opaque_tag_ptr(ccx.tn));\n+                        (val, trans_common::T_opaque_tag_ptr(ccx.tn));\n                     auto discrimptr = bcx.build.GEP\n                         (tagptr, ~[C_int(0), C_int(0)]);\n                     test_val = bcx.build.Load(discrimptr);"}, {"sha": "65c1bfb956e604948f11d2bc6241d3138ba610b0", "filename": "src/comp/middle/trans_common.rs", "status": "added", "additions": 487, "deletions": 0, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=8afb1a7c639d2d2959cdc79c544fac7dd5730897", "patch": "@@ -0,0 +1,487 @@\n+/**\n+   Code that is useful in various trans modules.\n+\n+*/\n+\n+import std::int;\n+import std::str;\n+import std::uint;\n+import std::str::rustrt::sbuf;\n+import std::map;\n+import std::map::hashmap;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+import std::fs;\n+import syntax::ast;\n+import syntax::walk;\n+import driver::session;\n+import middle::ty;\n+import back::link;\n+import back::x86;\n+import back::abi;\n+import back::upcall;\n+import syntax::visit;\n+import visit::vt;\n+import util::common;\n+import util::common::*;\n+import std::map::new_int_hash;\n+import std::map::new_str_hash;\n+import syntax::codemap::span;\n+import lib::llvm::llvm;\n+import lib::llvm::builder;\n+import lib::llvm::target_data;\n+import lib::llvm::type_names;\n+import lib::llvm::mk_target_data;\n+import lib::llvm::mk_type_names;\n+import lib::llvm::llvm::ModuleRef;\n+import lib::llvm::llvm::ValueRef;\n+import lib::llvm::llvm::TypeRef;\n+import lib::llvm::llvm::TypeHandleRef;\n+import lib::llvm::llvm::BuilderRef;\n+import lib::llvm::llvm::BasicBlockRef;\n+import lib::llvm::False;\n+import lib::llvm::True;\n+import lib::llvm::Bool;\n+import link::mangle_internal_name_by_type_only;\n+import link::mangle_internal_name_by_seq;\n+import link::mangle_internal_name_by_path;\n+import link::mangle_internal_name_by_path_and_seq;\n+import link::mangle_exported_name;\n+import metadata::creader;\n+import metadata::csearch;\n+import metadata::cstore;\n+import util::ppaux::ty_to_str;\n+import util::ppaux::ty_to_short_str;\n+import syntax::print::pprust::expr_to_str;\n+import syntax::print::pprust::path_to_str;\n+\n+// FIXME: These should probably be pulled in here too.\n+import trans::crate_ctxt;\n+import trans::type_of_fn_full;\n+import trans::val_ty;\n+\n+// LLVM type constructors.\n+fn T_void() -> TypeRef {\n+    // Note: For the time being llvm is kinda busted here, it has the notion\n+    // of a 'void' type that can only occur as part of the signature of a\n+    // function, but no general unit type of 0-sized value. This is, afaict,\n+    // vestigial from its C heritage, and we'll be attempting to submit a\n+    // patch upstream to fix it. In the mean time we only model function\n+    // outputs (Rust functions and C functions) using T_void, and model the\n+    // Rust general purpose nil type you can construct as 1-bit (always\n+    // zero). This makes the result incorrect for now -- things like a tuple\n+    // of 10 nil values will have 10-bit size -- but it doesn't seem like we\n+    // have any other options until it's fixed upstream.\n+\n+    ret llvm::LLVMVoidType();\n+}\n+\n+fn T_nil() -> TypeRef {\n+    // NB: See above in T_void().\n+\n+    ret llvm::LLVMInt1Type();\n+}\n+\n+fn T_i1() -> TypeRef { ret llvm::LLVMInt1Type(); }\n+\n+fn T_i8() -> TypeRef { ret llvm::LLVMInt8Type(); }\n+\n+fn T_i16() -> TypeRef { ret llvm::LLVMInt16Type(); }\n+\n+fn T_i32() -> TypeRef { ret llvm::LLVMInt32Type(); }\n+\n+fn T_i64() -> TypeRef { ret llvm::LLVMInt64Type(); }\n+\n+fn T_f32() -> TypeRef { ret llvm::LLVMFloatType(); }\n+\n+fn T_f64() -> TypeRef { ret llvm::LLVMDoubleType(); }\n+\n+fn T_bool() -> TypeRef { ret T_i1(); }\n+\n+fn T_int() -> TypeRef {\n+    // FIXME: switch on target type.\n+\n+    ret T_i32();\n+}\n+\n+fn T_float() -> TypeRef {\n+    // FIXME: switch on target type.\n+\n+    ret T_f64();\n+}\n+\n+fn T_char() -> TypeRef { ret T_i32(); }\n+\n+fn T_size_t() -> TypeRef {\n+    // FIXME: switch on target type.\n+\n+    ret T_i32();\n+}\n+\n+fn T_fn(&TypeRef[] inputs, TypeRef output) -> TypeRef {\n+    ret llvm::LLVMFunctionType(output, std::ivec::to_ptr(inputs),\n+                               std::ivec::len[TypeRef](inputs), False);\n+}\n+\n+fn T_fn_pair(&crate_ctxt cx, TypeRef tfn) -> TypeRef {\n+    ret T_struct(~[T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n+}\n+\n+fn T_ptr(TypeRef t) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n+\n+fn T_struct(&TypeRef[] elts) -> TypeRef {\n+    ret llvm::LLVMStructType(std::ivec::to_ptr(elts), std::ivec::len(elts),\n+                             False);\n+}\n+\n+fn T_named_struct(&str name) -> TypeRef {\n+    auto c = llvm::LLVMGetGlobalContext();\n+    ret llvm::LLVMStructCreateNamed(c, str::buf(name));\n+}\n+\n+fn set_struct_body(TypeRef t, &TypeRef[] elts) {\n+    llvm::LLVMStructSetBody(t, std::ivec::to_ptr(elts), std::ivec::len(elts),\n+                            False);\n+}\n+\n+fn T_empty_struct() -> TypeRef { ret T_struct(~[]); }\n+\n+fn T_rust_object() -> TypeRef {\n+    auto t = T_named_struct(\"rust_object\");\n+    auto e = T_ptr(T_empty_struct());\n+    set_struct_body(t, ~[e,e]);\n+    ret t;\n+}\n+\n+fn T_task() -> TypeRef {\n+    auto t = T_named_struct(\"task\");\n+\n+    auto elems = ~[T_int(), // Refcount\n+                   T_int(), // Delegate pointer\n+                   T_int(), // Stack segment pointer\n+                   T_int(), // Runtime SP\n+                   T_int(), // Rust SP\n+                   T_int(), // GC chain\n+\n+                   T_int(), // Domain pointer\n+                            // Crate cache pointer\n+                   T_int()];\n+    set_struct_body(t, elems);\n+    ret t;\n+}\n+\n+fn T_tydesc_field(&crate_ctxt cx, int field) -> TypeRef {\n+    // Bit of a kludge: pick the fn typeref out of the tydesc..\n+\n+    let TypeRef[] tydesc_elts =\n+        std::ivec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n+    llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n+                                    std::ivec::to_ptr[TypeRef](tydesc_elts));\n+    auto t = llvm::LLVMGetElementType(tydesc_elts.(field));\n+    ret t;\n+}\n+\n+fn T_glue_fn(&crate_ctxt cx) -> TypeRef {\n+    auto s = \"glue_fn\";\n+    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n+    auto t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n+    cx.tn.associate(s, t);\n+    ret t;\n+}\n+\n+fn T_dtor(&@crate_ctxt ccx, &span sp) -> TypeRef {\n+    ret type_of_fn_full(ccx, sp, ast::proto_fn, true,\n+                        ~[], ty::mk_nil(ccx.tcx), 0u);\n+}\n+\n+fn T_cmp_glue_fn(&crate_ctxt cx) -> TypeRef {\n+    auto s = \"cmp_glue_fn\";\n+    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n+    auto t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n+    cx.tn.associate(s, t);\n+    ret t;\n+}\n+\n+fn T_tydesc(TypeRef taskptr_type) -> TypeRef {\n+    auto tydesc = T_named_struct(\"tydesc\");\n+    auto tydescpp = T_ptr(T_ptr(tydesc));\n+    auto pvoid = T_ptr(T_i8());\n+    auto glue_fn_ty =\n+        T_ptr(T_fn(~[T_ptr(T_nil()), taskptr_type, T_ptr(T_nil()), tydescpp,\n+                     pvoid], T_void()));\n+    auto cmp_glue_fn_ty =\n+        T_ptr(T_fn(~[T_ptr(T_i1()), taskptr_type, T_ptr(T_nil()), tydescpp,\n+                     pvoid, pvoid, T_i8()], T_void()));\n+\n+    auto elems = ~[tydescpp,   // first_param\n+                   T_int(),    // size\n+                   T_int(),    // align\n+                   glue_fn_ty, // copy_glue\n+                   glue_fn_ty, // drop_glue\n+                   glue_fn_ty, // free_glue\n+                   glue_fn_ty, // sever_glue\n+                   glue_fn_ty, // mark_glue\n+                   glue_fn_ty, // obj_drop_glue\n+                   glue_fn_ty, // is_stateful\n+                   cmp_glue_fn_ty];\n+    set_struct_body(tydesc, elems);\n+    ret tydesc;\n+}\n+\n+fn T_array(TypeRef t, uint n) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n+\n+fn T_vec(TypeRef t) -> TypeRef {\n+    ret T_struct(~[T_int(), // Refcount\n+                   T_int(), // Alloc\n+                   T_int(), // Fill\n+\n+                   T_int(), // Pad\n+                           // Body elements\n+                            T_array(t, 0u)]);\n+}\n+\n+fn T_opaque_vec_ptr() -> TypeRef { ret T_ptr(T_vec(T_int())); }\n+\n+\n+// Interior vector.\n+//\n+// TODO: Support user-defined vector sizes.\n+fn T_ivec(TypeRef t) -> TypeRef {\n+    ret T_struct(~[T_int(), // Length (\"fill\"; if zero, heapified)\n+                   T_int(), // Alloc\n+                   T_array(t, abi::ivec_default_length)]); // Body elements\n+\n+}\n+\n+\n+// Note that the size of this one is in bytes.\n+fn T_opaque_ivec() -> TypeRef {\n+    ret T_struct(~[T_int(), // Length (\"fill\"; if zero, heapified)\n+                   T_int(), // Alloc\n+                   T_array(T_i8(), 0u)]); // Body elements\n+\n+}\n+\n+fn T_ivec_heap_part(TypeRef t) -> TypeRef {\n+    ret T_struct(~[T_int(), // Real length\n+                   T_array(t, 0u)]); // Body elements\n+\n+}\n+\n+\n+// Interior vector on the heap, also known as the \"stub\". Cast to this when\n+// the allocated length (second element of T_ivec above) is zero.\n+fn T_ivec_heap(TypeRef t) -> TypeRef {\n+    ret T_struct(~[T_int(), // Length (zero)\n+                   T_int(), // Alloc\n+                   T_ptr(T_ivec_heap_part(t))]); // Pointer\n+\n+}\n+\n+fn T_opaque_ivec_heap_part() -> TypeRef {\n+    ret T_struct(~[T_int(), // Real length\n+                   T_array(T_i8(), 0u)]); // Body elements\n+\n+}\n+\n+fn T_opaque_ivec_heap() -> TypeRef {\n+    ret T_struct(~[T_int(), // Length (zero)\n+                   T_int(), // Alloc\n+                   T_ptr(T_opaque_ivec_heap_part())]); // Pointer\n+\n+}\n+\n+fn T_str() -> TypeRef { ret T_vec(T_i8()); }\n+\n+fn T_box(TypeRef t) -> TypeRef { ret T_struct(~[T_int(), t]); }\n+\n+fn T_port(TypeRef t) -> TypeRef {\n+    ret T_struct(~[T_int()]); // Refcount\n+\n+}\n+\n+fn T_chan(TypeRef t) -> TypeRef {\n+    ret T_struct(~[T_int()]); // Refcount\n+\n+}\n+\n+fn T_taskptr(&crate_ctxt cx) -> TypeRef { ret T_ptr(cx.task_type); }\n+\n+\n+// This type must never be used directly; it must always be cast away.\n+fn T_typaram(&type_names tn) -> TypeRef {\n+    auto s = \"typaram\";\n+    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n+    auto t = T_i8();\n+    tn.associate(s, t);\n+    ret t;\n+}\n+\n+fn T_typaram_ptr(&type_names tn) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n+\n+fn T_closure_ptr(&crate_ctxt cx, TypeRef lltarget_ty, TypeRef llbindings_ty,\n+                 uint n_ty_params) -> TypeRef {\n+    // NB: keep this in sync with code in trans_bind; we're making\n+    // an LLVM typeref structure that has the same \"shape\" as the ty::t\n+    // it constructs.\n+\n+    ret T_ptr(T_box(T_struct(~[T_ptr(cx.tydesc_type), lltarget_ty,\n+                               llbindings_ty,\n+                               T_captured_tydescs(cx, n_ty_params)])));\n+}\n+\n+fn T_opaque_closure_ptr(&crate_ctxt cx) -> TypeRef {\n+    auto s = \"*closure\";\n+    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n+    auto t =\n+        T_closure_ptr(cx,\n+                      T_struct(~[T_ptr(T_nil()), T_ptr(T_nil())]),\n+                      T_nil(),\n+                      0u);\n+    cx.tn.associate(s, t);\n+    ret t;\n+}\n+\n+fn T_tag(&type_names tn, uint size) -> TypeRef {\n+    auto s = \"tag_\" + uint::to_str(size, 10u);\n+    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n+    auto t = T_struct(~[T_int(), T_array(T_i8(), size)]);\n+    tn.associate(s, t);\n+    ret t;\n+}\n+\n+fn T_opaque_tag(&type_names tn) -> TypeRef {\n+    auto s = \"opaque_tag\";\n+    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n+    auto t = T_struct(~[T_int(), T_i8()]);\n+    tn.associate(s, t);\n+    ret t;\n+}\n+\n+fn T_opaque_tag_ptr(&type_names tn) -> TypeRef {\n+    ret T_ptr(T_opaque_tag(tn));\n+}\n+\n+fn T_captured_tydescs(&crate_ctxt cx, uint n) -> TypeRef {\n+    ret T_struct(std::ivec::init_elt[TypeRef](T_ptr(cx.tydesc_type), n));\n+}\n+\n+fn T_obj_ptr(&crate_ctxt cx, uint n_captured_tydescs) -> TypeRef {\n+    // This function is not publicly exposed because it returns an incomplete\n+    // type. The dynamically-sized fields follow the captured tydescs.\n+\n+    fn T_obj(&crate_ctxt cx, uint n_captured_tydescs) -> TypeRef {\n+        ret T_struct(~[T_ptr(cx.tydesc_type),\n+                       T_captured_tydescs(cx, n_captured_tydescs)]);\n+    }\n+    ret T_ptr(T_box(T_obj(cx, n_captured_tydescs)));\n+}\n+\n+fn T_opaque_obj_ptr(&crate_ctxt cx) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n+\n+fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n+\n+fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n+\n+\n+// LLVM constant constructors.\n+fn C_null(TypeRef t) -> ValueRef { ret llvm::LLVMConstNull(t); }\n+\n+fn C_integral(TypeRef t, uint u, Bool sign_extend) -> ValueRef {\n+    // FIXME: We can't use LLVM::ULongLong with our existing minimal native\n+    // API, which only knows word-sized args.\n+    //\n+    // ret llvm::LLVMConstInt(T_int(), t as LLVM::ULongLong, False);\n+    //\n+\n+    ret llvm::LLVMRustConstSmallInt(t, u, sign_extend);\n+}\n+\n+fn C_float(&str s) -> ValueRef {\n+    ret llvm::LLVMConstRealOfString(T_float(), str::buf(s));\n+}\n+\n+fn C_floating(&str s, TypeRef t) -> ValueRef {\n+    ret llvm::LLVMConstRealOfString(t, str::buf(s));\n+}\n+\n+fn C_nil() -> ValueRef {\n+    // NB: See comment above in T_void().\n+\n+    ret C_integral(T_i1(), 0u, False);\n+}\n+\n+fn C_bool(bool b) -> ValueRef {\n+    if (b) {\n+        ret C_integral(T_bool(), 1u, False);\n+    } else { ret C_integral(T_bool(), 0u, False); }\n+}\n+\n+fn C_int(int i) -> ValueRef { ret C_integral(T_int(), i as uint, True); }\n+\n+fn C_uint(uint i) -> ValueRef { ret C_integral(T_int(), i, False); }\n+\n+fn C_u8(uint i) -> ValueRef { ret C_integral(T_i8(), i, False); }\n+\n+\n+// This is a 'c-like' raw string, which differs from\n+// our boxed-and-length-annotated strings.\n+fn C_cstr(&@crate_ctxt cx, &str s) -> ValueRef {\n+    auto sc = llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n+    auto g =\n+        llvm::LLVMAddGlobal(cx.llmod, val_ty(sc),\n+                            str::buf(cx.names.next(\"str\")));\n+    llvm::LLVMSetInitializer(g, sc);\n+    llvm::LLVMSetGlobalConstant(g, True);\n+    llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n+    ret g;\n+}\n+\n+\n+// A rust boxed-and-length-annotated string.\n+fn C_str(&@crate_ctxt cx, &str s) -> ValueRef {\n+    auto len = str::byte_len(s);\n+    auto box =\n+        C_struct(~[C_int(abi::const_refcount as int),\n+                   C_int(len + 1u as int), // 'alloc'\n+                   C_int(len + 1u as int), // 'fill'\n+                   C_int(0), // 'pad'\n+                   llvm::LLVMConstString(str::buf(s), len, False)]);\n+    auto g =\n+        llvm::LLVMAddGlobal(cx.llmod, val_ty(box),\n+                            str::buf(cx.names.next(\"str\")));\n+    llvm::LLVMSetInitializer(g, box);\n+    llvm::LLVMSetGlobalConstant(g, True);\n+    llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n+    ret llvm::LLVMConstPointerCast(g, T_ptr(T_str()));\n+}\n+\n+// Returns a Plain Old LLVM String:\n+fn C_postr(&str s) -> ValueRef {\n+    ret llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n+}\n+\n+fn C_zero_byte_arr(uint size) -> ValueRef {\n+    auto i = 0u;\n+    let ValueRef[] elts = ~[];\n+    while (i < size) { elts += ~[C_u8(0u)]; i += 1u; }\n+    ret llvm::LLVMConstArray(T_i8(), std::ivec::to_ptr(elts),\n+                             std::ivec::len(elts));\n+}\n+\n+fn C_struct(&ValueRef[] elts) -> ValueRef {\n+    ret llvm::LLVMConstStruct(std::ivec::to_ptr(elts), std::ivec::len(elts),\n+                              False);\n+}\n+\n+fn C_named_struct(TypeRef T, &ValueRef[] elts) -> ValueRef {\n+    ret llvm::LLVMConstNamedStruct(T, std::ivec::to_ptr(elts),\n+                                   std::ivec::len(elts));\n+}\n+\n+fn C_array(TypeRef ty, &ValueRef[] elts) -> ValueRef {\n+    ret llvm::LLVMConstArray(ty, std::ivec::to_ptr(elts),\n+                             std::ivec::len(elts));\n+}\n+"}, {"sha": "817ed6e071bc2bacd5e55cd7568f4ef3c9ef27d4", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8afb1a7c639d2d2959cdc79c544fac7dd5730897/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=8afb1a7c639d2d2959cdc79c544fac7dd5730897", "patch": "@@ -15,6 +15,7 @@ use std (name = \"std\",\n          url = \"http://rust-lang.org/src/std\");\n \n mod middle {\n+    mod trans_common;\n     mod trans;\n     mod trans_alt;\n     mod ty;"}]}