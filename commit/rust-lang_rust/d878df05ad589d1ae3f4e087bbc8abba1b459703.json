{"sha": "d878df05ad589d1ae3f4e087bbc8abba1b459703", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NzhkZjA1YWQ1ODlkMWFlM2Y0ZTA4N2JiYzhhYmJhMWI0NTk3MDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-29T18:41:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-29T18:41:37Z"}, "message": "auto merge of #13183 : erickt/rust/remove-list, r=alexcrichton\n\n`collections::list::List` was decided in a [team meeting](https://github.com/mozilla/rust/wiki/Meeting-weekly-2014-03-25) that it was unnecessary, so this PR removes it. Additionally, it removes an old and redundant purity test and fixes some warnings.", "tree": {"sha": "4fc8b2f734f94938d60fe6bfe2d2a0a4c11d7bbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fc8b2f734f94938d60fe6bfe2d2a0a4c11d7bbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d878df05ad589d1ae3f4e087bbc8abba1b459703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d878df05ad589d1ae3f4e087bbc8abba1b459703", "html_url": "https://github.com/rust-lang/rust/commit/d878df05ad589d1ae3f4e087bbc8abba1b459703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d878df05ad589d1ae3f4e087bbc8abba1b459703/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eb3a02c92e129e87561ebcf927543679bf7c74d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb3a02c92e129e87561ebcf927543679bf7c74d", "html_url": "https://github.com/rust-lang/rust/commit/3eb3a02c92e129e87561ebcf927543679bf7c74d"}, {"sha": "63b233c25d45f4dc792fa864ddf710ce9ddd0224", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b233c25d45f4dc792fa864ddf710ce9ddd0224", "html_url": "https://github.com/rust-lang/rust/commit/63b233c25d45f4dc792fa864ddf710ce9ddd0224"}], "stats": {"total": 327, "additions": 31, "deletions": 296}, "files": [{"sha": "061f3e6d268fffff18a8b87dc7eb05ce35f3ea16", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -27,8 +27,6 @@\n \n extern crate collections;\n \n-use collections::list::{List, Cons, Nil};\n-\n use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n use std::cell::{Cell, RefCell};\n@@ -87,7 +85,7 @@ pub struct Arena {\n     // access the head.\n     priv head: Chunk,\n     priv copy_head: Chunk,\n-    priv chunks: RefCell<@List<Chunk>>,\n+    priv chunks: RefCell<Vec<Chunk>>,\n }\n \n impl Arena {\n@@ -99,7 +97,7 @@ impl Arena {\n         Arena {\n             head: chunk(initial_size, false),\n             copy_head: chunk(initial_size, true),\n-            chunks: RefCell::new(@Nil),\n+            chunks: RefCell::new(Vec::new()),\n         }\n     }\n }\n@@ -117,7 +115,7 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            for chunk in self.chunks.get().iter() {\n+            for chunk in self.chunks.borrow().iter() {\n                 if !chunk.is_copy.get() {\n                     destroy_chunk(chunk);\n                 }\n@@ -179,7 +177,7 @@ impl Arena {\n     fn alloc_copy_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.set(@Cons(self.copy_head.clone(), self.chunks.get()));\n+        self.chunks.borrow_mut().push(self.copy_head.clone());\n         self.copy_head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), true);\n \n@@ -219,7 +217,7 @@ impl Arena {\n                          -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.set(@Cons(self.head.clone(), self.chunks.get()));\n+        self.chunks.borrow_mut().push(self.head.clone());\n         self.head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), false);\n "}, {"sha": "a424dbebe149dfa761bc8a534a359e5542d2a7cd", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -33,7 +33,6 @@ pub use deque::Deque;\n pub use dlist::DList;\n pub use enum_set::EnumSet;\n pub use hashmap::{HashMap, HashSet};\n-pub use list::List;\n pub use lru_cache::LruCache;\n pub use priority_queue::PriorityQueue;\n pub use ringbuf::RingBuf;\n@@ -47,7 +46,6 @@ pub mod deque;\n pub mod dlist;\n pub mod enum_set;\n pub mod hashmap;\n-pub mod list;\n pub mod lru_cache;\n pub mod priority_queue;\n pub mod ringbuf;"}, {"sha": "18da9671419eeff111c0abd7ae060778cf9c4d1b", "filename": "src/libcollections/list.rs", "status": "removed", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/3eb3a02c92e129e87561ebcf927543679bf7c74d/src%2Flibcollections%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb3a02c92e129e87561ebcf927543679bf7c74d/src%2Flibcollections%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flist.rs?ref=3eb3a02c92e129e87561ebcf927543679bf7c74d", "patch": "@@ -1,237 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A standard, garbage-collected linked list.\n-\n-use std::container::Container;\n-\n-#[deriving(Clone, Eq)]\n-#[allow(missing_doc)]\n-pub enum List<T> {\n-    Cons(T, @List<T>),\n-    Nil,\n-}\n-\n-pub struct Items<'a, T> {\n-    priv head: &'a List<T>,\n-    priv next: Option<&'a @List<T>>\n-}\n-\n-impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        match self.next {\n-            None => match *self.head {\n-                Nil => None,\n-                Cons(ref value, ref tail) => {\n-                    self.next = Some(tail);\n-                    Some(value)\n-                }\n-            },\n-            Some(next) => match **next {\n-                Nil => None,\n-                Cons(ref value, ref tail) => {\n-                    self.next = Some(tail);\n-                    Some(value)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> List<T> {\n-    /// Returns a forward iterator\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        Items {\n-            head: self,\n-            next: None\n-        }\n-    }\n-\n-    /// Returns the first element of a list\n-    pub fn head<'a>(&'a self) -> Option<&'a T> {\n-        match *self {\n-          Nil => None,\n-          Cons(ref head, _) => Some(head)\n-        }\n-    }\n-\n-    /// Returns all but the first element of a list\n-    pub fn tail(&self) -> Option<@List<T>> {\n-        match *self {\n-            Nil => None,\n-            Cons(_, tail) => Some(tail)\n-        }\n-    }\n-}\n-\n-impl<T> Container for List<T> {\n-    /// Returns the length of a list\n-    fn len(&self) -> uint { self.iter().len() }\n-\n-    /// Returns true if the list is empty\n-    fn is_empty(&self) -> bool { match *self { Nil => true, _ => false } }\n-}\n-\n-impl<T:Eq> List<T> {\n-    /// Returns true if a list contains an element with the given value\n-    pub fn contains(&self, element: T) -> bool {\n-        self.iter().any(|list_element| *list_element == element)\n-    }\n-}\n-\n-impl<T:'static + Clone> List<T> {\n-    /// Create a list from a vector\n-    pub fn from_vec(v: &[T]) -> List<T> {\n-        match v.len() {\n-            0 => Nil,\n-            _ => v.rev_iter().fold(Nil, |tail, value: &T| Cons(value.clone(), @tail))\n-        }\n-    }\n-\n-    /// Appends one list to another, returning a new list\n-    pub fn append(&self, other: List<T>) -> List<T> {\n-        match other {\n-            Nil => return self.clone(),\n-            _ => match *self {\n-                Nil => return other,\n-                Cons(ref value, tail) => Cons(value.clone(), @tail.append(other))\n-            }\n-        }\n-    }\n-\n-    /// Push one element into the front of a list, returning a new list\n-    pub fn unshift(&self, element: T) -> List<T> {\n-        Cons(element, @(self.clone()))\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use list::{List, Nil};\n-    use list;\n-\n-    #[test]\n-    fn test_iter() {\n-        let list = List::from_vec([0, 1, 2]);\n-        let mut iter = list.iter();\n-        assert_eq!(&0, iter.next().unwrap());\n-        assert_eq!(&1, iter.next().unwrap());\n-        assert_eq!(&2, iter.next().unwrap());\n-        assert_eq!(None, iter.next());\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        let empty : list::List<int> = List::from_vec([]);\n-        let full1 = List::from_vec([1]);\n-        let full2 = List::from_vec(['r', 'u']);\n-\n-        assert!(empty.is_empty());\n-        assert!(!full1.is_empty());\n-        assert!(!full2.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.head().unwrap(), &0);\n-\n-        let mut tail = list.tail().unwrap();\n-        assert_eq!(tail.head().unwrap(), &1);\n-\n-        tail = tail.tail().unwrap();\n-        assert_eq!(tail.head().unwrap(), &2);\n-    }\n-\n-    #[test]\n-    fn test_from_vec_empty() {\n-        let empty : list::List<int> = List::from_vec([]);\n-        assert!(empty == Nil::<int>);\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        fn add_(a: uint, b: &uint) -> uint { a + *b }\n-        fn subtract_(a: uint, b: &uint) -> uint { a - *b }\n-\n-        let empty = Nil::<uint>;\n-        assert_eq!(empty.iter().fold(0u, add_), 0u);\n-        assert_eq!(empty.iter().fold(10u, subtract_), 10u);\n-\n-        let list = List::from_vec([0u, 1u, 2u, 3u, 4u]);\n-        assert_eq!(list.iter().fold(0u, add_), 10u);\n-        assert_eq!(list.iter().fold(10u, subtract_), 0u);\n-    }\n-\n-    #[test]\n-    fn test_find_success() {\n-        fn match_(i: & &int) -> bool { **i == 2 }\n-\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.iter().find(match_).unwrap(), &2);\n-    }\n-\n-    #[test]\n-    fn test_find_fail() {\n-        fn match_(_i: & &int) -> bool { false }\n-\n-        let empty = Nil::<int>;\n-        assert_eq!(empty.iter().find(match_), None);\n-\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.iter().find(match_), None);\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        fn match_(i: &int) -> bool { *i == 2 }\n-\n-        let empty = Nil::<int>;\n-        assert_eq!(empty.iter().any(match_), false);\n-\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.iter().any(match_), true);\n-    }\n-\n-    #[test]\n-    fn test_contains() {\n-        let empty = Nil::<int>;\n-        assert!((!empty.contains(5)));\n-\n-        let list = List::from_vec([5, 8, 6]);\n-        assert!((list.contains(5)));\n-        assert!((!list.contains(7)));\n-        assert!((list.contains(8)));\n-    }\n-\n-    #[test]\n-    fn test_len() {\n-        let empty = Nil::<int>;\n-        assert_eq!(empty.len(), 0u);\n-\n-        let list = List::from_vec([0, 1, 2]);\n-        assert_eq!(list.len(), 3u);\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        assert!(List::from_vec([1, 2, 3, 4]) ==\n-                List::from_vec([1, 2]).append(List::from_vec([3, 4])));\n-    }\n-\n-    #[test]\n-    fn test_unshift() {\n-        let list = List::from_vec([1]);\n-        let new_list = list.unshift(0);\n-        assert_eq!(list.len(), 1u);\n-        assert_eq!(new_list.len(), 2u);\n-        assert!(new_list == List::from_vec([0, 1]));\n-    }\n-}"}, {"sha": "cd2284ff6d388dc5f52176f006dc7324a9589f26", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -1473,7 +1473,7 @@ mod test {\n             let mut handle = pool.spawn_sched();\n             handle.send(PinnedTask(pool.task(TaskOpts::new(), proc() {\n                 unsafe {\n-                    let mut guard = LOCK.lock();\n+                    let guard = LOCK.lock();\n \n                     start_tx.send(());\n                     guard.wait();   // block the scheduler thread\n@@ -1509,7 +1509,7 @@ mod test {\n                 child_tx.send(20);\n                 pingpong(&parent_rx, &child_tx);\n                 unsafe {\n-                    let mut guard = LOCK.lock();\n+                    let guard = LOCK.lock();\n                     guard.signal();   // wakeup waiting scheduler\n                     guard.wait();     // wait for them to grab the lock\n                 }"}, {"sha": "47772ca4682c994f1aa7ce98caf45f5ffbdaa787", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -72,7 +72,6 @@ use util::nodemap::{DefIdMap, FnvHashMap};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n-use collections::List;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n@@ -327,7 +326,7 @@ pub fn require_same_types(tcx: &ty::ctxt,\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::Region\n-pub type isr_alist = @List<(ty::BoundRegion, ty::Region)>;\n+pub type isr_alist = @Vec<(ty::BoundRegion, ty::Region)>;\n \n trait get_region<'a, T:'static> {\n     fn get(&'a self, br: ty::BoundRegion) -> ty::Region;"}, {"sha": "f4a7e3c5769aa27adf805ad1cc50cf4817fad526", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -2335,7 +2335,7 @@ mod tests {\n \n     #[test]\n     fn test_counter_from_iter() {\n-        let mut it = count(0, 5).take(10);\n+        let it = count(0, 5).take(10);\n         let xs: ~[int] = FromIterator::from_iterator(it);\n         assert_eq!(xs, ~[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }"}, {"sha": "5ef3e67c208bc138e442dc39e2507d78f0f1b9c1", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -3218,7 +3218,7 @@ mod tests {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n         let mut cpy = data.clone();\n         let other = \"abc\";\n-        let mut it = other.chars();\n+        let it = other.chars();\n         cpy.extend(it);\n         assert_eq!(cpy, data + other);\n     }"}, {"sha": "34023ceb452b62dd86abeebbcdebc0da0e524367", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -621,7 +621,7 @@ mod test {\n     #[test]\n     fn destroy_immediately() {\n         unsafe {\n-            let mut m = StaticNativeMutex::new();\n+            let m = StaticNativeMutex::new();\n             m.destroy();\n         }\n     }"}, {"sha": "fc7e6a03bcfbd03aae345358858b448b04e7feaf", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -13,12 +13,16 @@\n extern crate collections;\n extern crate time;\n \n-use collections::list::{List, Cons, Nil};\n use time::precise_time_s;\n use std::os;\n use std::task;\n use std::vec;\n \n+#[deriving(Clone)]\n+enum List<T> {\n+    Nil, Cons(T, @List<T>)\n+}\n+\n enum UniqueList {\n     ULNil, ULCons(~UniqueList)\n }"}, {"sha": "7e120658aaefd149e019fd4470c57d5bc3f073e5", "filename": "src/test/run-pass/log-knows-the-names-of-variants-in-std.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d878df05ad589d1ae3f4e087bbc8abba1b459703/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs?ref=d878df05ad589d1ae3f4e087bbc8abba1b459703", "patch": "@@ -10,9 +10,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate collections;\n-use collections::list::List;\n-\n #[deriving(Clone)]\n enum foo {\n   a(uint),\n@@ -24,9 +21,21 @@ fn check_log<T>(exp: ~str, v: T) {\n }\n \n pub fn main() {\n-    let x = List::from_vec([a(22u), b(~\"hi\")]);\n-    let exp = ~\"Cons(a(22u), @Cons(b(~\\\"hi\\\"), @Nil))\";\n+    let mut x = Some(a(22u));\n+    let exp = ~\"Some(a(22u))\";\n+    let act = format!(\"{:?}\", x);\n+    assert_eq!(act, exp);\n+    check_log(exp, x);\n+\n+    x = Some(b(~\"hi\"));\n+    let exp = ~\"Some(b(~\\\"hi\\\"))\";\n+    let act = format!(\"{:?}\", x);\n+    assert_eq!(act, exp);\n+    check_log(exp, x);\n+\n+    x = None;\n+    let exp = ~\"None\";\n     let act = format!(\"{:?}\", x);\n-    assert!(act == exp);\n+    assert_eq!(act, exp);\n     check_log(exp, x);\n }"}, {"sha": "66bb2e702bea3bbb71e5596541129eae425fd09f", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3eb3a02c92e129e87561ebcf927543679bf7c74d/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb3a02c92e129e87561ebcf927543679bf7c74d/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=3eb3a02c92e129e87561ebcf927543679bf7c74d", "patch": "@@ -1,36 +0,0 @@\n-// ignore-fast\n-\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-extern crate collections;\n-\n-use collections::list::{List, Cons, Nil};\n-\n-fn pure_length_go<T>(ls: @List<T>, acc: uint) -> uint {\n-    match *ls { Nil => { acc } Cons(_, tl) => { pure_length_go(tl, acc + 1u) } }\n-}\n-\n-fn pure_length<T>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n-\n-fn nonempty_list<T>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n-\n-fn safe_head<T:Clone>(ls: @List<T>) -> T {\n-    assert!(!ls.is_empty());\n-    return ls.head().unwrap().clone();\n-}\n-\n-pub fn main() {\n-    let mylist = @Cons(@1u, @Nil);\n-    assert!((nonempty_list(mylist)));\n-    assert_eq!(*safe_head(mylist), 1u);\n-}"}]}