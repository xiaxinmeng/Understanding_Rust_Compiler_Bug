{"sha": "33a3206dc5e7f267617a625d8b31ccc3250cdc1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYTMyMDZkYzVlN2YyNjc2MTdhNjI1ZDhiMzFjY2MzMjUwY2RjMWU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-23T06:23:11Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-27T04:05:05Z"}, "message": "Use `Symbol` equality in `may_begin_with` and `parse_nt`.", "tree": {"sha": "4d09e30ea55c8a6d0338591876e4c2d8d1c684f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d09e30ea55c8a6d0338591876e4c2d8d1c684f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33a3206dc5e7f267617a625d8b31ccc3250cdc1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33a3206dc5e7f267617a625d8b31ccc3250cdc1e", "html_url": "https://github.com/rust-lang/rust/commit/33a3206dc5e7f267617a625d8b31ccc3250cdc1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33a3206dc5e7f267617a625d8b31ccc3250cdc1e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15789a97737c1cada44aa253fbbcee80ecd40895", "url": "https://api.github.com/repos/rust-lang/rust/commits/15789a97737c1cada44aa253fbbcee80ecd40895", "html_url": "https://github.com/rust-lang/rust/commit/15789a97737c1cada44aa253fbbcee80ecd40895"}], "stats": {"total": 61, "additions": 34, "deletions": 27}, "files": [{"sha": "7b7cf80760f5c3f920feda9ba0eeb6f45f60e71d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/33a3206dc5e7f267617a625d8b31ccc3250cdc1e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a3206dc5e7f267617a625d8b31ccc3250cdc1e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=33a3206dc5e7f267617a625d8b31ccc3250cdc1e", "patch": "@@ -80,7 +80,7 @@ use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::{Parser, PathStyle};\n use crate::parse::token::{self, DocComment, Nonterminal, Token};\n use crate::print::pprust;\n-use crate::symbol::kw;\n+use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream};\n \n use errors::FatalError;\n@@ -598,7 +598,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 TokenTree::MetaVarDecl(_, _, id) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    if may_begin_with(&*id.as_str(), token) {\n+                    if may_begin_with(id.name, token) {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -791,7 +791,7 @@ pub fn parse(\n                 let match_cur = item.match_cur;\n                 item.push_match(\n                     match_cur,\n-                    MatchedNonterminal(Lrc::new(parse_nt(&mut parser, span, &ident.as_str()))),\n+                    MatchedNonterminal(Lrc::new(parse_nt(&mut parser, span, ident.name))),\n                 );\n                 item.idx += 1;\n                 item.match_cur += 1;\n@@ -819,7 +819,7 @@ fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n ///\n /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n /// token. Be conservative (return true) if not sure.\n-fn may_begin_with(name: &str, token: &Token) -> bool {\n+fn may_begin_with(name: Symbol, token: &Token) -> bool {\n     /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n     fn may_be_ident(nt: &token::Nonterminal) -> bool {\n         match *nt {\n@@ -829,16 +829,16 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n     }\n \n     match name {\n-        \"expr\" => token.can_begin_expr(),\n-        \"ty\" => token.can_begin_type(),\n-        \"ident\" => get_macro_ident(token).is_some(),\n-        \"literal\" => token.can_begin_literal_or_bool(),\n-        \"vis\" => match *token {\n+        sym::expr => token.can_begin_expr(),\n+        sym::ty => token.can_begin_type(),\n+        sym::ident => get_macro_ident(token).is_some(),\n+        sym::literal => token.can_begin_literal_or_bool(),\n+        sym::vis => match *token {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n             Token::Comma | Token::Ident(..) | Token::Interpolated(_) => true,\n             _ => token.can_begin_type(),\n         },\n-        \"block\" => match *token {\n+        sym::block => match *token {\n             Token::OpenDelim(token::Brace) => true,\n             Token::Interpolated(ref nt) => match **nt {\n                 token::NtItem(_)\n@@ -852,15 +852,15 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n             },\n             _ => false,\n         },\n-        \"path\" | \"meta\" => match *token {\n+        sym::path | sym::meta => match *token {\n             Token::ModSep | Token::Ident(..) => true,\n             Token::Interpolated(ref nt) => match **nt {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n                 _ => may_be_ident(&nt),\n             },\n             _ => false,\n         },\n-        \"pat\" => match *token {\n+        sym::pat => match *token {\n             Token::Ident(..) |               // box, ref, mut, and other identifiers (can stricten)\n             Token::OpenDelim(token::Paren) |    // tuple pattern\n             Token::OpenDelim(token::Bracket) |  // slice pattern\n@@ -876,7 +876,7 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n             Token::Interpolated(ref nt) => may_be_ident(nt),\n             _ => false,\n         },\n-        \"lifetime\" => match *token {\n+        sym::lifetime => match *token {\n             Token::Lifetime(_) => true,\n             Token::Interpolated(ref nt) => match **nt {\n                 token::NtLifetime(_) | token::NtTT(_) => true,\n@@ -903,34 +903,34 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n /// # Returns\n ///\n /// The parsed non-terminal.\n-fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n-    if name == \"tt\" {\n+fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> Nonterminal {\n+    if name == sym::tt {\n         return token::NtTT(p.parse_token_tree());\n     }\n     // check at the beginning and the parser checks after each bump\n     p.process_potential_macro_variable();\n     match name {\n-        \"item\" => match panictry!(p.parse_item()) {\n+        sym::item => match panictry!(p.parse_item()) {\n             Some(i) => token::NtItem(i),\n             None => {\n                 p.fatal(\"expected an item keyword\").emit();\n                 FatalError.raise();\n             }\n         },\n-        \"block\" => token::NtBlock(panictry!(p.parse_block())),\n-        \"stmt\" => match panictry!(p.parse_stmt()) {\n+        sym::block => token::NtBlock(panictry!(p.parse_block())),\n+        sym::stmt => match panictry!(p.parse_stmt()) {\n             Some(s) => token::NtStmt(s),\n             None => {\n                 p.fatal(\"expected a statement\").emit();\n                 FatalError.raise();\n             }\n         },\n-        \"pat\" => token::NtPat(panictry!(p.parse_pat(None))),\n-        \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n-        \"literal\" => token::NtLiteral(panictry!(p.parse_literal_maybe_minus())),\n-        \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n+        sym::pat => token::NtPat(panictry!(p.parse_pat(None))),\n+        sym::expr => token::NtExpr(panictry!(p.parse_expr())),\n+        sym::literal => token::NtLiteral(panictry!(p.parse_literal_maybe_minus())),\n+        sym::ty => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n-        \"ident\" => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n+        sym::ident => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n             let span = p.span;\n             p.bump();\n             token::NtIdent(Ident::new(ident.name, span), is_raw)\n@@ -939,10 +939,10 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             p.fatal(&format!(\"expected ident, found {}\", &token_str)).emit();\n             FatalError.raise()\n         }\n-        \"path\" => token::NtPath(panictry!(p.parse_path(PathStyle::Type))),\n-        \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n-        \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n-        \"lifetime\" => if p.check_lifetime() {\n+        sym::path => token::NtPath(panictry!(p.parse_path(PathStyle::Type))),\n+        sym::meta => token::NtMeta(panictry!(p.parse_meta_item())),\n+        sym::vis => token::NtVis(panictry!(p.parse_visibility(true))),\n+        sym::lifetime => if p.check_lifetime() {\n             token::NtLifetime(p.expect_lifetime().ident)\n         } else {\n             let token_str = pprust::token_to_string(&p.token);"}, {"sha": "60f87783b3e119d974e009fdc02b55665f70282b", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/33a3206dc5e7f267617a625d8b31ccc3250cdc1e/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a3206dc5e7f267617a625d8b31ccc3250cdc1e/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=33a3206dc5e7f267617a625d8b31ccc3250cdc1e", "patch": "@@ -252,6 +252,7 @@ symbols! {\n         existential_type,\n         expected,\n         export_name,\n+        expr,\n         extern_absolute_paths,\n         external_doc,\n         extern_crate_item_prelude,\n@@ -329,6 +330,7 @@ symbols! {\n         issue,\n         issue_5723_bootstrap,\n         issue_tracker_base_url,\n+        item,\n         item_like_imports,\n         iter,\n         Iterator,\n@@ -339,6 +341,7 @@ symbols! {\n         lang,\n         lang_items,\n         lib,\n+        lifetime,\n         link,\n         linkage,\n         link_args,\n@@ -347,6 +350,7 @@ symbols! {\n         link_name,\n         link_section,\n         lint_reasons,\n+        literal,\n         local_inner_macros,\n         log_syntax,\n         loop_break_value,\n@@ -435,6 +439,7 @@ symbols! {\n         partial_cmp,\n         PartialOrd,\n         passes,\n+        pat,\n         path,\n         pattern_parentheses,\n         Pending,\n@@ -578,6 +583,7 @@ symbols! {\n         static_recursion,\n         std,\n         str,\n+        stmt,\n         stmt_expr_attributes,\n         stop_after_dataflow,\n         struct_field_attributes,\n@@ -610,6 +616,7 @@ symbols! {\n         Try,\n         try_blocks,\n         try_trait,\n+        tt,\n         tuple_indexing,\n         ty,\n         type_alias_enum_variants,"}]}