{"sha": "eda6e068524d2bc38127ad6f9a1f2b8c4bed08a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYTZlMDY4NTI0ZDJiYzM4MTI3YWQ2ZjlhMWYyYjhjNGJlZDA4YTg=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-18T02:47:33Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-18T04:55:09Z"}, "message": "Rollup merge of #55127 - ljedrz:simplify_hybridbitset, r=matthewjasper\n\nRemove HybridBitSet::dummy\n\nThis simplifies some of the `HybridBitSet` code.\n\ncc @nnethercote", "tree": {"sha": "7a473bae6985a4519b3c8431f36fb499d86efea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a473bae6985a4519b3c8431f36fb499d86efea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eda6e068524d2bc38127ad6f9a1f2b8c4bed08a8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvIEi0ACgkQ/vbIBR0O\nATwX7hAAqjgwApTpKA6hxRadJ6mdc+orXp93wCYWgNatWl4IM4h76qfypPtFoly+\nc4Pj8m5XLAtLTtF0gQkpziR6KWDVw8+47FPGQAtglR0LE0s8odNWjb1eIBQTXE+r\ndB5IY6dGTBtzd+WQvcIpeMcSpajNzoteBDOPnCjdmA1zESSURGoppTwORIkQxbki\n2xumX9T63fvXDSbYD134QNGkSWX4P1c/UGcZcVaZRnj75hb0Ce0aDayZyhICFbFX\nhBB/pW8+6pEvY2apbvpaGc7lezYdZZ39MI6Nj5eGQCfYglX0h9+ray227peoen/Z\nKNVuTzjIVVUd7CrFtn3G6mUo8gMEi/GT7ztIYquhxVefaN3GsetL7XtVoojqkval\n3vA6bDfhT2K8DrEnt3YFSb5vdszd7+7mOQgc4FBOgZzYLmEw0t49yuyA/fg6Q10z\nyDHtbnSE2xHMQujmsIeWy1Y/tW5eNgHiJZh+JUtCpMjWIh3W/zIKFlLMsEBx/4yv\nCVGsQ8x8ey3Q23mQ9LYVE5yNn4r5KioBkHwrf51KrRnCpZytZT4mRDBdf3aGTrNy\n0hJt1NxY+xNLu1eM5HQo2Mlpb3mRxfH6f9eHiOWMccMGgDtED/7dZwLART9a4tnP\n0wHKYvm+VxMUNPpNq0D1Yz9myAmtKknvzeFQ1toob/jUBU1dr6U=\n=WCAo\n-----END PGP SIGNATURE-----", "payload": "tree 7a473bae6985a4519b3c8431f36fb499d86efea1\nparent f8fa3da77b374d7b233c86c6b81a063321fcdfdc\nparent 1dd92c4a7000822612e553a121f09bb3e9a55793\nauthor kennytm <kennytm@gmail.com> 1539830853 +0800\ncommitter kennytm <kennytm@gmail.com> 1539838509 +0800\n\nRollup merge of #55127 - ljedrz:simplify_hybridbitset, r=matthewjasper\n\nRemove HybridBitSet::dummy\n\nThis simplifies some of the `HybridBitSet` code.\n\ncc @nnethercote\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eda6e068524d2bc38127ad6f9a1f2b8c4bed08a8", "html_url": "https://github.com/rust-lang/rust/commit/eda6e068524d2bc38127ad6f9a1f2b8c4bed08a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eda6e068524d2bc38127ad6f9a1f2b8c4bed08a8/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "html_url": "https://github.com/rust-lang/rust/commit/f8fa3da77b374d7b233c86c6b81a063321fcdfdc"}, {"sha": "1dd92c4a7000822612e553a121f09bb3e9a55793", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd92c4a7000822612e553a121f09bb3e9a55793", "html_url": "https://github.com/rust-lang/rust/commit/1dd92c4a7000822612e553a121f09bb3e9a55793"}], "stats": {"total": 50, "additions": 14, "deletions": 36}, "files": [{"sha": "28aad49b09b998678ca52d7574718636c6c10ded", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/eda6e068524d2bc38127ad6f9a1f2b8c4bed08a8/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda6e068524d2bc38127ad6f9a1f2b8c4bed08a8/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=eda6e068524d2bc38127ad6f9a1f2b8c4bed08a8", "patch": "@@ -423,15 +423,6 @@ pub enum HybridBitSet<T: Idx> {\n }\n \n impl<T: Idx> HybridBitSet<T> {\n-    // FIXME: This function is used in conjunction with `mem::replace()` in\n-    // several pieces of awful code below. I can't work out how else to appease\n-    // the borrow checker.\n-    fn dummy() -> Self {\n-        // The cheapest HybridBitSet to construct, which is only used to get\n-        // around the borrow checker.\n-        HybridBitSet::Sparse(SparseBitSet::new_empty(0))\n-    }\n-\n     pub fn new_empty(domain_size: usize) -> Self {\n         HybridBitSet::Sparse(SparseBitSet::new_empty(domain_size))\n     }\n@@ -487,20 +478,14 @@ impl<T: Idx> HybridBitSet<T> {\n                 // that doesn't matter because `elem` is already present.\n                 false\n             }\n-            HybridBitSet::Sparse(_) => {\n+            HybridBitSet::Sparse(sparse) => {\n                 // The set is sparse and full. Convert to a dense set.\n-                match mem::replace(self, HybridBitSet::dummy()) {\n-                    HybridBitSet::Sparse(sparse) => {\n-                        let mut dense = sparse.to_dense();\n-                        let changed = dense.insert(elem);\n-                        assert!(changed);\n-                        *self = HybridBitSet::Dense(dense);\n-                        changed\n-                    }\n-                    _ => unreachable!()\n-                }\n+                let mut dense = sparse.to_dense();\n+                let changed = dense.insert(elem);\n+                assert!(changed);\n+                *self = HybridBitSet::Dense(dense);\n+                changed\n             }\n-\n             HybridBitSet::Dense(dense) => dense.insert(elem),\n         }\n     }\n@@ -525,33 +510,26 @@ impl<T: Idx> HybridBitSet<T> {\n \n     pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(_) => {\n+            HybridBitSet::Sparse(self_sparse) => {\n                 match other {\n                     HybridBitSet::Sparse(other_sparse) => {\n                         // Both sets are sparse. Add the elements in\n-                        // `other_sparse` to `self_hybrid` one at a time. This\n-                        // may or may not cause `self_hybrid` to be densified.\n+                        // `other_sparse` to `self` one at a time. This\n+                        // may or may not cause `self` to be densified.\n                         assert_eq!(self.domain_size(), other.domain_size());\n-                        let mut self_hybrid = mem::replace(self, HybridBitSet::dummy());\n                         let mut changed = false;\n                         for elem in other_sparse.iter() {\n-                            changed |= self_hybrid.insert(*elem);\n+                            changed |= self.insert(*elem);\n                         }\n-                        *self = self_hybrid;\n                         changed\n                     }\n                     HybridBitSet::Dense(other_dense) => {\n                         // `self` is sparse and `other` is dense. Densify\n                         // `self` and then do the bitwise union.\n-                        match mem::replace(self, HybridBitSet::dummy()) {\n-                            HybridBitSet::Sparse(self_sparse) => {\n-                                let mut new_dense = self_sparse.to_dense();\n-                                let changed = new_dense.union(other_dense);\n-                                *self = HybridBitSet::Dense(new_dense);\n-                                changed\n-                            }\n-                            _ => unreachable!()\n-                        }\n+                        let mut new_dense = self_sparse.to_dense();\n+                        let changed = new_dense.union(other_dense);\n+                        *self = HybridBitSet::Dense(new_dense);\n+                        changed\n                     }\n                 }\n             }"}]}