{"sha": "04ecab909a38a8c19405ea577e826facfe4d7da8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZWNhYjkwOWEzOGE4YzE5NDA1ZWE1NzdlODI2ZmFjZmU0ZDdkYTg=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-23T08:59:24Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:37:28Z"}, "message": "Re-add discriminant range annotations", "tree": {"sha": "70ba74cc8d4752ff2e1351f0561636a760012689", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70ba74cc8d4752ff2e1351f0561636a760012689"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04ecab909a38a8c19405ea577e826facfe4d7da8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04ecab909a38a8c19405ea577e826facfe4d7da8", "html_url": "https://github.com/rust-lang/rust/commit/04ecab909a38a8c19405ea577e826facfe4d7da8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04ecab909a38a8c19405ea577e826facfe4d7da8/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a1706610b2cf458fe6e5ed12e227e3ca9dcaa6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a1706610b2cf458fe6e5ed12e227e3ca9dcaa6d", "html_url": "https://github.com/rust-lang/rust/commit/8a1706610b2cf458fe6e5ed12e227e3ca9dcaa6d"}], "stats": {"total": 57, "additions": 40, "deletions": 17}, "files": [{"sha": "b4d2be8382751ff17cbcf73843d047f0909741c9", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/04ecab909a38a8c19405ea577e826facfe4d7da8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04ecab909a38a8c19405ea577e826facfe4d7da8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=04ecab909a38a8c19405ea577e826facfe4d7da8", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n use core::vec;\n-use lib::llvm::{ValueRef, TypeRef};\n+use lib::llvm::{ValueRef, TypeRef, True, False};\n use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -23,7 +24,7 @@ use util::ppaux::ty_to_str;\n \n // XXX: should this be done with boxed traits instead of ML-style?\n pub enum Repr {\n-    CEnum,\n+    CEnum(int, int), /* discriminant range */\n     Univariant(Struct, Destructor),\n     General(~[Struct])\n }\n@@ -65,13 +66,13 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> Repr {\n             })), if dt { DtorPresent } else { DtorAbsent })\n         }\n         ty::ty_enum(def_id, ref substs) => {\n-            struct Case { discr: i64, tys: ~[ty::t] };\n+            struct Case { discr: int, tys: ~[ty::t] };\n \n             let cases = do ty::enum_variants(cx.tcx, def_id).map |vi| {\n                 let arg_tys = do vi.args.map |&raw_ty| {\n                     ty::subst(cx.tcx, substs, raw_ty)\n                 };\n-                Case { discr: vi.disr_val /*bad*/as i64, tys: arg_tys }\n+                Case { discr: vi.disr_val, tys: arg_tys }\n             };\n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n@@ -80,9 +81,10 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> Repr {\n                 // struct, tuple, newtype, etc.\n                 Univariant(mk_struct(cx, cases[0].tys), NoDtor)\n             } else if cases.all(|c| c.tys.len() == 0) {\n-                CEnum\n+                let discrs = cases.map(|c| c.discr);\n+                CEnum(discrs.min(), discrs.max())\n             } else {\n-                if !cases.alli(|i,c| c.discr == (i as i64)) {\n+                if !cases.alli(|i,c| c.discr == (i as int)) {\n                     cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n                                       discriminants\",\n                                      ty::item_path_str(cx.tcx, def_id)))\n@@ -114,7 +116,7 @@ pub fn fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     -> ~[TypeRef] {\n     match *r {\n-        CEnum => ~[T_enum_discrim(cx)],\n+        CEnum(*) => ~[T_enum_discrim(cx)],\n         Univariant(ref st, dt) => {\n             let f = if sizing {\n                 st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n@@ -134,25 +136,44 @@ fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     }\n }\n \n+fn load_discr(bcx: block, scrutinee: ValueRef, min: int, max: int)\n+    -> ValueRef {\n+    let ptr = GEPi(bcx, scrutinee, [0, 0]);\n+    // XXX: write tests for the edge cases here\n+    if max + 1 == min {\n+        // i.e., if the range is everything.  The lo==hi case would be\n+        // rejected by the LLVM verifier (it would mean either an\n+        // empty set, which is impossible, or the entire range of the\n+        // type, which is pointless).\n+        Load(bcx, ptr)\n+    } else {\n+        // llvm::ConstantRange can deal with ranges that wrap around,\n+        // so an overflow on (max + 1) is fine.\n+        LoadRangeAssert(bcx, ptr, min as c_ulonglong,\n+                        (max + 1) as c_ulonglong,\n+                        /* signed: */ True)\n+    }\n+}\n+\n pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef) ->\n     (_match::branch_kind, Option<ValueRef>) {\n-    // XXX: LoadRangeAssert\n     match *r {\n-        CEnum => {\n-            (_match::switch, Some(Load(bcx, GEPi(bcx, scrutinee, [0, 0]))))\n+        CEnum(min, max) => {\n+            (_match::switch, Some(load_discr(bcx, scrutinee, min, max)))\n         }\n         Univariant(*) => {\n             (_match::single, None)\n         }\n-        General(*) => {\n-            (_match::switch, Some(Load(bcx, GEPi(bcx, scrutinee, [0, 0]))))\n+        General(ref cases) => {\n+            (_match::switch, Some(load_discr(bcx, scrutinee, 0,\n+                                             (cases.len() - 1) as int)))\n         }\n     }\n }\n \n pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n     match *r {\n-        CEnum => {\n+        CEnum(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n         }\n         Univariant(*) => {\n@@ -166,7 +187,8 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n \n pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n-        CEnum => {\n+        CEnum(min, max) => {\n+            assert min <= discr && discr <= max;\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(_, DtorPresent) => {\n@@ -184,7 +206,7 @@ pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n \n pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n-        CEnum => 0,\n+        CEnum(*) => 0,\n         Univariant(ref st, _dt) => { assert discr == 0; st.fields.len() }\n         General(ref cases) => cases[discr as uint].fields.len()\n     }\n@@ -196,7 +218,7 @@ pub fn trans_GEP(bcx: block, r: &Repr, val: ValueRef, discr: int, ix: uint)\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it'll need to return a possibly-new bcx as well.\n     match *r {\n-        CEnum => {\n+        CEnum(*) => {\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n         Univariant(ref st, dt) => {\n@@ -232,8 +254,9 @@ fn struct_GEP(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n-        CEnum => {\n+        CEnum(min, max) => {\n             assert vals.len() == 0;\n+            assert min <= discr && discr <= max;\n             C_int(ccx, discr)\n         }\n         Univariant(ref st, _dt) => {"}]}