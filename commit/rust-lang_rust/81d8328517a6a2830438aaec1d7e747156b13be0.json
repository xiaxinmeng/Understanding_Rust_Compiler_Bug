{"sha": "81d8328517a6a2830438aaec1d7e747156b13be0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZDgzMjg1MTdhNmEyODMwNDM4YWFlYzFkN2U3NDcxNTZiMTNiZTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-01-22T19:03:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-01T02:18:48Z"}, "message": "Introduce marker types for indicating variance and for opting out\nof builtin bounds.\n\nFixes #10834.\nFixes #11385.\ncc #5922.", "tree": {"sha": "5f3337bdc79406fd7da088d146ad1f64a56ff83b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f3337bdc79406fd7da088d146ad1f64a56ff83b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81d8328517a6a2830438aaec1d7e747156b13be0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81d8328517a6a2830438aaec1d7e747156b13be0", "html_url": "https://github.com/rust-lang/rust/commit/81d8328517a6a2830438aaec1d7e747156b13be0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81d8328517a6a2830438aaec1d7e747156b13be0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83f0f6ef6cb44d9fbba24372f223561a75a50c18", "url": "https://api.github.com/repos/rust-lang/rust/commits/83f0f6ef6cb44d9fbba24372f223561a75a50c18", "html_url": "https://github.com/rust-lang/rust/commit/83f0f6ef6cb44d9fbba24372f223561a75a50c18"}], "stats": {"total": 883, "additions": 729, "deletions": 154}, "files": [{"sha": "44ec3f4a5a1d79df93c94a81511fdb7022d96fe7", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -33,6 +33,7 @@ use std::cast;\n use std::cell::{Cell, RefCell};\n use std::num;\n use std::ptr;\n+use std::kinds::marker;\n use std::mem;\n use std::rt::global_heap;\n use std::uint;\n@@ -71,14 +72,14 @@ struct Chunk {\n // different chunks than objects without destructors. This reduces\n // overhead when initializing plain-old-data and means we don't need\n // to waste time running the destructors of POD.\n-#[no_freeze]\n pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to\n     // access the head.\n     priv head: Chunk,\n     priv pod_head: Chunk,\n     priv chunks: RefCell<@List<Chunk>>,\n+    priv no_freeze: marker::NoFreeze,\n }\n \n impl Arena {\n@@ -91,6 +92,7 @@ impl Arena {\n             head: chunk(initial_size, false),\n             pod_head: chunk(initial_size, true),\n             chunks: RefCell::new(@Nil),\n+            no_freeze: marker::NoFreeze,\n         }\n     }\n }"}, {"sha": "43366d2aa6d84dcf401efb5e62bef48a1add779d", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -45,6 +45,7 @@ use sync;\n use sync::{Mutex, RWLock};\n \n use std::cast;\n+use std::kinds::marker;\n use std::sync::arc::UnsafeArc;\n use std::task;\n \n@@ -150,17 +151,19 @@ impl<T:Freeze + Send> Clone for Arc<T> {\n struct MutexArcInner<T> { lock: Mutex, failed: bool, data: T }\n \n /// An Arc with mutable data protected by a blocking mutex.\n-#[no_freeze]\n-pub struct MutexArc<T> { priv x: UnsafeArc<MutexArcInner<T>> }\n-\n+pub struct MutexArc<T> {\n+    priv x: UnsafeArc<MutexArcInner<T>>,\n+    priv marker: marker::NoFreeze,\n+}\n \n impl<T:Send> Clone for MutexArc<T> {\n     /// Duplicate a mutex-protected Arc. See arc::clone for more details.\n     #[inline]\n     fn clone(&self) -> MutexArc<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n         // count would be exactly the same as the shared state's.\n-        MutexArc { x: self.x.clone() }\n+        MutexArc { x: self.x.clone(),\n+                   marker: marker::NoFreeze, }\n     }\n }\n \n@@ -179,7 +182,8 @@ impl<T:Send> MutexArc<T> {\n             lock: Mutex::new_with_condvars(num_condvars),\n             failed: false, data: user_data\n         };\n-        MutexArc { x: UnsafeArc::new(data) }\n+        MutexArc { x: UnsafeArc::new(data),\n+                   marker: marker::NoFreeze, }\n     }\n \n     /**\n@@ -318,16 +322,17 @@ struct RWArcInner<T> { lock: RWLock, failed: bool, data: T }\n  *\n  * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n  */\n-#[no_freeze]\n pub struct RWArc<T> {\n     priv x: UnsafeArc<RWArcInner<T>>,\n+    priv marker: marker::NoFreeze,\n }\n \n impl<T:Freeze + Send> Clone for RWArc<T> {\n     /// Duplicate a rwlock-protected Arc. See arc::clone for more details.\n     #[inline]\n     fn clone(&self) -> RWArc<T> {\n-        RWArc { x: self.x.clone() }\n+        RWArc { x: self.x.clone(),\n+                marker: marker::NoFreeze, }\n     }\n \n }\n@@ -347,7 +352,8 @@ impl<T:Freeze + Send> RWArc<T> {\n             lock: RWLock::new_with_condvars(num_condvars),\n             failed: false, data: user_data\n         };\n-        RWArc { x: UnsafeArc::new(data), }\n+        RWArc { x: UnsafeArc::new(data),\n+                marker: marker::NoFreeze, }\n     }\n \n     /**"}, {"sha": "aed35c6075e19b991da77e84ecb9bbe57d2adf43", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -273,4 +273,17 @@ lets_do_this! {\n     37, ManagedHeapLangItem,             \"managed_heap\",            managed_heap;\n     38, ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     39, GcLangItem,                      \"gc\",                      gc;\n+\n+    40, CovariantTypeItem,               \"covariant_type\",          covariant_type;\n+    41, ContravariantTypeItem,           \"contravariant_type\",      contravariant_type;\n+    42, InvariantTypeItem,               \"invariant_type\",          invariant_type;\n+\n+    43, CovariantLifetimeItem,           \"covariant_lifetime\",      covariant_lifetime;\n+    44, ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n+    45, InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;\n+\n+    46, NoFreezeItem,                    \"no_freeze_bound\",         no_freeze_bound;\n+    47, NoSendItem,                      \"no_send_bound\",           no_send_bound;\n+    48, NoPodItem,                       \"no_pod_bound\",            no_pod_bound;\n+    49, ManagedItem,                     \"managed_bound\",           managed_bound;\n }"}, {"sha": "825509d539ed2fb6a811be20467bd31b2f93c3b0", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -957,8 +957,8 @@ static other_attrs: &'static [&'static str] = &[\n     \"thread_local\", // for statics\n     \"allow\", \"deny\", \"forbid\", \"warn\", // lint options\n     \"deprecated\", \"experimental\", \"unstable\", \"stable\", \"locked\", \"frozen\", //item stability\n-    \"crate_map\", \"cfg\", \"doc\", \"export_name\", \"link_section\", \"no_freeze\",\n-    \"no_mangle\", \"no_send\", \"static_assert\", \"unsafe_no_drop_flag\", \"packed\",\n+    \"crate_map\", \"cfg\", \"doc\", \"export_name\", \"link_section\",\n+    \"no_mangle\", \"static_assert\", \"unsafe_no_drop_flag\", \"packed\",\n     \"simd\", \"repr\", \"deriving\", \"unsafe_destructor\", \"link\", \"phase\",\n     \"macro_export\", \"must_use\",\n "}, {"sha": "38b34cd13bc6ea5dfe3b19f7066adaeed108250d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -328,7 +328,7 @@ pub fn at_box_body(bcx: &Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n // malloc_raw_dyn: allocates a box to contain a given type, but with a\n // potentially dynamic size.\n pub fn malloc_raw_dyn<'a>(\n-                      bcx: &'a Block,\n+                      bcx: &'a Block<'a>,\n                       t: ty::t,\n                       heap: heap,\n                       size: ValueRef)\n@@ -425,7 +425,7 @@ pub fn malloc_general_dyn<'a>(\n     }\n }\n \n-pub fn malloc_general<'a>(bcx: &'a Block, t: ty::t, heap: heap)\n+pub fn malloc_general<'a>(bcx: &'a Block<'a>, t: ty::t, heap: heap)\n                       -> MallocResult<'a> {\n     let ty = type_of(bcx.ccx(), t);\n     assert!(heap != heap_exchange);\n@@ -1230,18 +1230,19 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n //\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n-pub fn new_fn_ctxt_detailed(ccx: @CrateContext,\n-                            path: ast_map::Path,\n-                            llfndecl: ValueRef,\n-                            id: ast::NodeId,\n-                            has_env: bool,\n-                            output_type: ty::t,\n-                            param_substs: Option<@param_substs>,\n-                            sp: Option<Span>)\n-                            -> FunctionContext {\n+pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n+                       path: ast_map::Path,\n+                       llfndecl: ValueRef,\n+                       id: ast::NodeId,\n+                       has_env: bool,\n+                       output_type: ty::t,\n+                       param_substs: Option<@param_substs>,\n+                       sp: Option<Span>,\n+                       block_arena: &'a TypedArena<Block<'a>>)\n+                       -> FunctionContext<'a> {\n     for p in param_substs.iter() { p.validate(); }\n \n-    debug!(\"new_fn_ctxt_detailed(path={},\n+    debug!(\"new_fn_ctxt(path={},\n            id={:?}, \\\n            param_substs={})\",\n            path_str(ccx.sess, path),\n@@ -1258,25 +1259,25 @@ pub fn new_fn_ctxt_detailed(ccx: @CrateContext,\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n \n     let mut fcx = FunctionContext {\n-        llfn: llfndecl,\n-        llenv: None,\n-        llretptr: Cell::new(None),\n-        entry_bcx: RefCell::new(None),\n-        alloca_insert_pt: Cell::new(None),\n-        llreturn: Cell::new(None),\n-        personality: Cell::new(None),\n-        caller_expects_out_pointer: uses_outptr,\n-        llargs: RefCell::new(HashMap::new()),\n-        lllocals: RefCell::new(HashMap::new()),\n-        llupvars: RefCell::new(HashMap::new()),\n-        id: id,\n-        param_substs: param_substs,\n-        span: sp,\n-        path: path,\n-        block_arena: TypedArena::new(),\n-        ccx: ccx,\n-        debug_context: debug_context,\n-        scopes: RefCell::new(~[])\n+          llfn: llfndecl,\n+          llenv: None,\n+          llretptr: Cell::new(None),\n+          entry_bcx: RefCell::new(None),\n+          alloca_insert_pt: Cell::new(None),\n+          llreturn: Cell::new(None),\n+          personality: Cell::new(None),\n+          caller_expects_out_pointer: uses_outptr,\n+          llargs: RefCell::new(HashMap::new()),\n+          lllocals: RefCell::new(HashMap::new()),\n+          llupvars: RefCell::new(HashMap::new()),\n+          id: id,\n+          param_substs: param_substs,\n+          span: sp,\n+          path: path,\n+          block_arena: block_arena,\n+          ccx: ccx,\n+          debug_context: debug_context,\n+          scopes: RefCell::new(~[])\n     };\n \n     if has_env {\n@@ -1328,18 +1329,6 @@ pub fn init_function<'a>(\n     }\n }\n \n-pub fn new_fn_ctxt(ccx: @CrateContext,\n-                   path: ast_map::Path,\n-                   llfndecl: ValueRef,\n-                   has_env: bool,\n-                   output_type: ty::t,\n-                   sp: Option<Span>)\n-                   -> FunctionContext {\n-    // FIXME(#11385): Do not call `init_function` here; it will typecheck\n-    // but segfault.\n-    new_fn_ctxt_detailed(ccx, path, llfndecl, -1, has_env, output_type, None, sp)\n-}\n-\n // NB: must keep 4 fns in sync:\n //\n //  - type_of_fn\n@@ -1411,7 +1400,8 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: &FunctionContext, last_bcx: &Block) {\n+pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n+                     last_bcx: &'a Block<'a>) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn.get() {\n@@ -1469,7 +1459,7 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n                          id: ast::NodeId,\n                          _attributes: &[ast::Attribute],\n                          output_type: ty::t,\n-                         maybe_load_env: |&'a Block<'a>| -> &'a Block<'a>) {\n+                         maybe_load_env: <'b> |&'b Block<'b>| -> &'b Block<'b>) {\n     ccx.stats.n_closures.set(ccx.stats.n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1483,8 +1473,16 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n         _ => false\n     };\n \n-    let fcx = new_fn_ctxt_detailed(ccx, path, llfndecl, id, has_env, output_type,\n-                                   param_substs, Some(body.span));\n+    let arena = TypedArena::new();\n+    let fcx = new_fn_ctxt(ccx,\n+                          path,\n+                          llfndecl,\n+                          id,\n+                          has_env,\n+                          output_type,\n+                          param_substs,\n+                          Some(body.span),\n+                          &arena);\n     init_function(&fcx, false, output_type, param_substs);\n \n     // cleanup scope for the incoming arguments\n@@ -1626,8 +1624,16 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n                  ty_to_str(ccx.tcx, ctor_ty)))\n     };\n \n-    let fcx = new_fn_ctxt_detailed(ccx, ~[], llfndecl, ctor_id, false,\n-                                   result_ty, param_substs, None);\n+    let arena = TypedArena::new();\n+    let fcx = new_fn_ctxt(ccx,\n+                          ~[],\n+                          llfndecl,\n+                          ctor_id,\n+                          false,\n+                          result_ty,\n+                          param_substs,\n+                          None,\n+                          &arena);\n     init_function(&fcx, false, result_ty, param_substs);\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);"}, {"sha": "c6d56db6877bb8042e83df7ec9c33192e351e01b", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -214,7 +214,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.ccx.tcx.sess.bug(\"No loop scope found\");\n     }\n \n-    fn normal_exit_block(&self,\n+    fn normal_exit_block(&'a self,\n                          cleanup_scope: ast::NodeId,\n                          exit: uint) -> BasicBlockRef {\n         /*!\n@@ -226,7 +226,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.trans_cleanups_to_exit_scope(LoopExit(cleanup_scope, exit))\n     }\n \n-    fn return_exit_block(&self) -> BasicBlockRef {\n+    fn return_exit_block(&'a self) -> BasicBlockRef {\n         /*!\n          * Returns a block to branch to which will perform all pending\n          * cleanups and then return from this function\n@@ -371,7 +371,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         scopes.get().iter().rev().any(|s| s.needs_invoke())\n     }\n \n-    fn get_landing_pad(&self) -> BasicBlockRef {\n+    fn get_landing_pad(&'a self) -> BasicBlockRef {\n         /*!\n          * Returns a basic block to branch to in the event of a failure.\n          * This block will run the failure cleanups and eventually\n@@ -481,7 +481,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         f(scopes.get().last().unwrap())\n     }\n \n-    fn trans_cleanups_to_exit_scope(&self,\n+    fn trans_cleanups_to_exit_scope(&'a self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef {\n         /*!\n@@ -641,7 +641,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         prev_llbb\n     }\n \n-    fn get_or_create_landing_pad(&self) -> BasicBlockRef {\n+    fn get_or_create_landing_pad(&'a self) -> BasicBlockRef {\n         /*!\n          * Creates a landing pad for the top scope, if one does not\n          * exist.  The landing pad will perform all cleanups necessary\n@@ -903,10 +903,10 @@ pub trait CleanupMethods<'a> {\n                                           custom_scope: CustomScopeIndex)\n                                           -> &'a Block<'a>;\n     fn top_loop_scope(&self) -> ast::NodeId;\n-    fn normal_exit_block(&self,\n+    fn normal_exit_block(&'a self,\n                          cleanup_scope: ast::NodeId,\n                          exit: uint) -> BasicBlockRef;\n-    fn return_exit_block(&self) -> BasicBlockRef;\n+    fn return_exit_block(&'a self) -> BasicBlockRef;\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n@@ -929,7 +929,7 @@ pub trait CleanupMethods<'a> {\n                                     custom_scope: CustomScopeIndex,\n                                     cleanup: ~Cleanup);\n     fn needs_invoke(&self) -> bool;\n-    fn get_landing_pad(&self) -> BasicBlockRef;\n+    fn get_landing_pad(&'a self) -> BasicBlockRef;\n }\n \n trait CleanupHelperMethods<'a> {\n@@ -940,10 +940,10 @@ trait CleanupHelperMethods<'a> {\n     fn trans_scope_cleanups(&self,\n                             bcx: &'a Block<'a>,\n                             scope: &CleanupScope<'a>) -> &'a Block<'a>;\n-    fn trans_cleanups_to_exit_scope(&self,\n+    fn trans_cleanups_to_exit_scope(&'a self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef;\n-    fn get_or_create_landing_pad(&self) -> BasicBlockRef;\n+    fn get_or_create_landing_pad(&'a self) -> BasicBlockRef;\n     fn scopes_len(&self) -> uint;\n     fn push_scope(&self, scope: CleanupScope<'a>);\n     fn pop_scope(&self) -> CleanupScope<'a>;"}, {"sha": "d1979c3fee71d23033ca7309b14e62b87ee35bfb", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -25,6 +25,7 @@ use middle::ty;\n use util::ppaux::Repr;\n use util::ppaux::ty_to_str;\n \n+use arena::TypedArena;\n use std::vec;\n use syntax::ast;\n use syntax::ast_map::PathName;\n@@ -404,9 +405,9 @@ pub fn trans_expr_fn<'a>(\n     };\n     let ClosureResult {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, sigil);\n     trans_closure(ccx, sub_path, decl, body, llfn,\n-                    bcx.fcx.param_substs, user_id,\n-                    [], ty::ty_fn_ret(fty),\n-                    |bcx| load_environment(bcx, cdata_ty, cap_vars, sigil));\n+                  bcx.fcx.param_substs, user_id,\n+                  [], ty::ty_fn_ret(fty),\n+                  |bcx| load_environment(bcx, cdata_ty, cap_vars, sigil));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n \n     bcx\n@@ -470,7 +471,9 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n \n     let _icx = push_ctxt(\"closure::get_wrapper_for_bare_fn\");\n \n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, true, f.sig.output, None);\n+    let arena = TypedArena::new();\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, -1, true, f.sig.output, None, None,\n+                          &arena);\n     init_function(&fcx, true, f.sig.output, None);\n     let bcx = fcx.entry_bcx.get().unwrap();\n "}, {"sha": "d35f9a28a835b2d2a2074fa71029c9ab9ad2ac61", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -281,7 +281,7 @@ pub struct FunctionContext<'a> {\n     path: Path,\n \n     // The arena that blocks are allocated from.\n-    block_arena: TypedArena<Block<'a>>,\n+    block_arena: &'a TypedArena<Block<'a>>,\n \n     // This function's enclosing crate context.\n     ccx: @CrateContext,"}, {"sha": "705501c82235fd17c2ebf6fd3eaa4b6a28b819e0", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -36,6 +36,7 @@ use util::ppaux::ty_to_short_str;\n \n use middle::trans::type_::Type;\n \n+use arena::TypedArena;\n use std::c_str::ToCStr;\n use std::cell::Cell;\n use std::libc::c_uint;\n@@ -504,16 +505,21 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n     return llfn;\n }\n \n-pub type glue_helper<'a> =\n-    'a |&'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>;\n-\n-fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n-                     helper: glue_helper, name: &str) -> ValueRef {\n+fn make_generic_glue(ccx: @CrateContext,\n+                     t: ty::t,\n+                     llfn: ValueRef,\n+                     helper: <'a> |&'a Block<'a>, ValueRef, ty::t|\n+                                  -> &'a Block<'a>,\n+                     name: &str)\n+                     -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");\n     let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, false, ty::mk_nil(), None);\n+    let arena = TypedArena::new();\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, -1, false, ty::mk_nil(), None, None,\n+                          &arena);\n+\n     init_function(&fcx, false, ty::mk_nil(), None);\n \n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n@@ -529,7 +535,6 @@ fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n     let bcx = fcx.entry_bcx.get().unwrap();\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, fcx.arg_pos(0) as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n-\n     finish_fn(&fcx, bcx);\n \n     llfn"}, {"sha": "da3b9202d9215634e6ca062073ef785a005a2bac", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -10,6 +10,7 @@\n \n #[allow(non_uppercase_pattern_statics)];\n \n+use arena::TypedArena;\n use back::abi;\n use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n use lib::llvm::{ValueRef, Pointer, Array, Struct};\n@@ -194,8 +195,16 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n \n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n \n-    let fcx = new_fn_ctxt_detailed(ccx, path, decl, item.id, false, output_type,\n-                                   Some(substs), Some(item.span));\n+    let arena = TypedArena::new();\n+    let fcx = new_fn_ctxt(ccx,\n+                          path,\n+                          decl,\n+                          item.id,\n+                          false,\n+                          output_type,\n+                          Some(substs),\n+                          Some(item.span),\n+                          &arena);\n     init_function(&fcx, true, output_type, Some(substs));\n \n     set_always_inline(fcx.llfn);"}, {"sha": "0e245de60193c28d7032c462b4a6ff586e307ebd", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -24,6 +24,7 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use arena::TypedArena;\n use std::libc::c_uint;\n use std::option::{Some,None};\n use std::vec;\n@@ -292,10 +293,17 @@ impl<'a> Reflector<'a> {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfdecl = decl_internal_rust_fn(ccx, false,\n-                                                    [opaqueptrty],\n-                                                    ty::mk_u64(), sym);\n-                let fcx = new_fn_ctxt(ccx, ~[], llfdecl, false, ty::mk_u64(), None);\n+                let llfdecl = decl_internal_rust_fn(ccx, false, [opaqueptrty], ty::mk_u64(), sym);\n+                let arena = TypedArena::new();\n+                let fcx = new_fn_ctxt(ccx,\n+                                      ~[],\n+                                      llfdecl,\n+                                      -1, // id\n+                                      false,\n+                                      ty::mk_u64(),\n+                                      None,\n+                                      None,\n+                                      &arena);\n                 init_function(&fcx, false, ty::mk_u64(), None);\n \n                 let arg = unsafe {"}, {"sha": "f26d94327941d7312026589875040a21dde80948", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -1772,7 +1772,9 @@ def_type_content_sets!(\n         // Things that prevent values from being considered sized\n         Nonsized                            = 0b0000__00000000__0001,\n \n-        // Things that make values considered not POD (same as `Moves`)\n+        // Things that make values considered not POD (would be same\n+        // as `Moves`, but for the fact that managed data `@` is\n+        // not considered POD)\n         Nonpod                              = 0b0000__00001111__0000,\n \n         // Bits to set when a managed value is encountered\n@@ -2051,7 +2053,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 if ty::has_dtor(cx, did) {\n                     res = res | TC::OwnsDtor;\n                 }\n-                apply_attributes(cx, did, res)\n+                apply_lang_items(cx, did, res)\n             }\n \n             ty_tup(ref tys) => {\n@@ -2066,7 +2068,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n                     });\n-                apply_attributes(cx, did, res)\n+                apply_lang_items(cx, did, res)\n             }\n \n             ty_param(p) => {\n@@ -2121,13 +2123,21 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         mc | tc_ty(cx, mt.ty, cache)\n     }\n \n-    fn apply_attributes(cx: ctxt,\n+    fn apply_lang_items(cx: ctxt,\n                         did: ast::DefId,\n                         tc: TypeContents)\n                         -> TypeContents {\n-        tc |\n-            TC::ReachesMutable.when(has_attr(cx, did, \"no_freeze\")) |\n-            TC::ReachesNonsendAnnot.when(has_attr(cx, did, \"no_send\"))\n+        if Some(did) == cx.lang_items.no_freeze_bound() {\n+            tc | TC::ReachesMutable\n+        } else if Some(did) == cx.lang_items.no_send_bound() {\n+            tc | TC::ReachesNonsendAnnot\n+        } else if Some(did) == cx.lang_items.managed_bound() {\n+            tc | TC::Managed\n+        } else if Some(did) == cx.lang_items.no_pod_bound() {\n+            tc | TC::OwnsAffine\n+        } else {\n+            tc\n+        }\n     }\n \n     fn borrowed_contents(region: ty::Region,"}, {"sha": "83be5fd2a305a2b067907c271447bffb38f5a8fd", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -397,6 +397,15 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n struct ConstraintContext<'a> {\n     terms_cx: TermsContext<'a>,\n \n+    // These are the def-id of the std::kinds::marker::InvariantType,\n+    // std::kinds::marker::InvariantLifetime, and so on. The arrays\n+    // are indexed by the `ParamKind` (type, lifetime, self). Note\n+    // that there are no marker types for self, so the entries for\n+    // self are always None.\n+    invariant_lang_items: [Option<ast::DefId>, ..3],\n+    covariant_lang_items: [Option<ast::DefId>, ..3],\n+    contravariant_lang_items: [Option<ast::DefId>, ..3],\n+\n     // These are pointers to common `ConstantTerm` instances\n     covariant: VarianceTermPtr<'a>,\n     contravariant: VarianceTermPtr<'a>,\n@@ -416,12 +425,36 @@ struct Constraint<'a> {\n fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n                                   crate: &ast::Crate)\n                                   -> ConstraintContext<'a> {\n+    let mut invariant_lang_items = [None, ..3];\n+    let mut covariant_lang_items = [None, ..3];\n+    let mut contravariant_lang_items = [None, ..3];\n+\n+    covariant_lang_items[TypeParam as uint] =\n+        terms_cx.tcx.lang_items.covariant_type();\n+    covariant_lang_items[RegionParam as uint] =\n+        terms_cx.tcx.lang_items.covariant_lifetime();\n+\n+    contravariant_lang_items[TypeParam as uint] =\n+        terms_cx.tcx.lang_items.contravariant_type();\n+    contravariant_lang_items[RegionParam as uint] =\n+        terms_cx.tcx.lang_items.contravariant_lifetime();\n+\n+    invariant_lang_items[TypeParam as uint] =\n+        terms_cx.tcx.lang_items.invariant_type();\n+    invariant_lang_items[RegionParam as uint] =\n+        terms_cx.tcx.lang_items.invariant_lifetime();\n+\n     let covariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Covariant));\n     let contravariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Contravariant));\n     let invariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Invariant));\n     let bivariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Bivariant));\n     let mut constraint_cx = ConstraintContext {\n         terms_cx: terms_cx,\n+\n+        invariant_lang_items: invariant_lang_items,\n+        covariant_lang_items: covariant_lang_items,\n+        contravariant_lang_items: contravariant_lang_items,\n+\n         covariant: covariant,\n         contravariant: contravariant,\n         invariant: invariant,\n@@ -520,7 +553,14 @@ impl<'a> ConstraintContext<'a> {\n          */\n \n         assert_eq!(param_def_id.crate, item_def_id.crate);\n-        if param_def_id.crate == ast::LOCAL_CRATE {\n+\n+        if self.invariant_lang_items[kind as uint] == Some(item_def_id) {\n+            self.invariant\n+        } else if self.covariant_lang_items[kind as uint] == Some(item_def_id) {\n+            self.covariant\n+        } else if self.contravariant_lang_items[kind as uint] == Some(item_def_id) {\n+            self.contravariant\n+        } else if param_def_id.crate == ast::LOCAL_CRATE {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance."}, {"sha": "ded80d07003206c2945c8e3505128317d5bdacc4", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -66,6 +66,7 @@ use cast;\n use container::Container;\n use iter::{Iterator, range};\n use libc;\n+use kinds::marker;\n use ops::Drop;\n use option::{Option, Some, None};\n use ptr::RawPtr;\n@@ -174,7 +175,7 @@ impl CString {\n     pub fn iter<'a>(&'a self) -> CChars<'a> {\n         CChars {\n             ptr: self.buf,\n-            lifetime: unsafe { cast::transmute(self.buf) },\n+            marker: marker::ContravariantLifetime,\n         }\n     }\n }\n@@ -332,7 +333,7 @@ fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n /// Use with the `std::iter` module.\n pub struct CChars<'a> {\n     priv ptr: *libc::c_char,\n-    priv lifetime: &'a libc::c_char, // FIXME: #5922\n+    priv marker: marker::ContravariantLifetime<'a>,\n }\n \n impl<'a> Iterator<libc::c_char> for CChars<'a> {"}, {"sha": "eb7d62b7bd3f136722f4e5af7b7de885bd3e0613", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -13,19 +13,22 @@\n use prelude::*;\n use cast;\n use util::NonCopyable;\n+use kinds::{marker,Pod};\n \n /// A mutable memory location that admits only `Pod` data.\n-#[no_freeze]\n-#[deriving(Clone)]\n pub struct Cell<T> {\n     priv value: T,\n+    priv marker1: marker::InvariantType<T>,\n+    priv marker2: marker::NoFreeze,\n }\n \n-impl<T: ::kinds::Pod> Cell<T> {\n+impl<T:Pod> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: value,\n+            marker1: marker::InvariantType::<T>,\n+            marker2: marker::NoFreeze,\n         }\n     }\n \n@@ -44,12 +47,19 @@ impl<T: ::kinds::Pod> Cell<T> {\n     }\n }\n \n+impl<T:Pod> Clone for Cell<T> {\n+    fn clone(&self) -> Cell<T> {\n+        Cell::new(self.get())\n+    }\n+}\n+\n /// A mutable memory location with dynamically checked borrow rules\n-#[no_freeze]\n pub struct RefCell<T> {\n     priv value: T,\n     priv borrow: BorrowFlag,\n-    priv nc: NonCopyable\n+    priv nc: NonCopyable,\n+    priv marker1: marker::InvariantType<T>,\n+    priv marker2: marker::NoFreeze,\n }\n \n // Values [1, MAX-1] represent the number of `Ref` active\n@@ -62,6 +72,8 @@ impl<T> RefCell<T> {\n     /// Create a new `RefCell` containing `value`\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n+            marker1: marker::InvariantType::<T>,\n+            marker2: marker::NoFreeze,\n             value: value,\n             borrow: UNUSED,\n             nc: NonCopyable"}, {"sha": "7b1a6055542d03963fc0ffdb527e3916c135cb26", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -230,6 +230,7 @@ use clone::Clone;\n use container::Container;\n use int;\n use iter::Iterator;\n+use kinds::marker;\n use kinds::Send;\n use ops::Drop;\n use option::{Option, Some, None};\n@@ -297,9 +298,11 @@ impl<T: Send> Consumer<T>{\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n-#[no_freeze] // can't share ports in an arc\n pub struct Port<T> {\n     priv queue: Consumer<T>,\n+\n+    // can't share in an arc\n+    priv marker: marker::NoFreeze,\n }\n \n /// An iterator over messages received on a port, this iterator will block\n@@ -311,17 +314,22 @@ pub struct Messages<'a, T> {\n \n /// The sending-half of Rust's channel type. This half can only be owned by one\n /// task\n-#[no_freeze] // can't share chans in an arc\n pub struct Chan<T> {\n     priv queue: spsc::Producer<T, Packet>,\n+\n+    // can't share in an arc\n+    priv marker: marker::NoFreeze,\n }\n \n /// The sending-half of Rust's channel type. This half can be shared among many\n /// tasks by creating copies of itself through the `clone` method.\n-#[no_freeze] // technically this implementation is shareable, but it shouldn't\n-             // be required to be shareable in an arc\n pub struct SharedChan<T> {\n     priv queue: mpsc::Producer<T, Packet>,\n+\n+    // can't share in an arc -- technically this implementation is\n+    // shareable, but it shouldn't be required to be shareable in an\n+    // arc\n+    priv marker: marker::NoFreeze,\n }\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n@@ -545,7 +553,8 @@ impl<T: Send> Chan<T> {\n         // maximum buffer size\n         let (c, p) = spsc::queue(128, Packet::new());\n         let c = SPSC(c);\n-        (Port { queue: c }, Chan { queue: p })\n+        (Port { queue: c, marker: marker::NoFreeze },\n+         Chan { queue: p, marker: marker::NoFreeze })\n     }\n \n     /// Sends a value along this channel to be received by the corresponding\n@@ -640,7 +649,8 @@ impl<T: Send> SharedChan<T> {\n     pub fn new() -> (Port<T>, SharedChan<T>) {\n         let (c, p) = mpsc::queue(Packet::new());\n         let c = MPSC(c);\n-        (Port { queue: c }, SharedChan { queue: p })\n+        (Port { queue: c, marker: marker::NoFreeze },\n+         SharedChan { queue: p, marker: marker::NoFreeze })\n     }\n \n     /// Equivalent method to `send` on the `Chan` type (using the same\n@@ -706,7 +716,7 @@ impl<T: Send> SharedChan<T> {\n impl<T: Send> Clone for SharedChan<T> {\n     fn clone(&self) -> SharedChan<T> {\n         unsafe { (*self.queue.packet()).channels.fetch_add(1, SeqCst); }\n-        SharedChan { queue: self.queue.clone() }\n+        SharedChan { queue: self.queue.clone(), marker: marker::NoFreeze }\n     }\n }\n "}, {"sha": "a369ecba86b3a6b45333e92ecf98c882d395f23d", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -47,6 +47,7 @@\n use cast;\n use comm;\n use iter::Iterator;\n+use kinds::marker;\n use kinds::Send;\n use ops::Drop;\n use option::{Some, None, Option};\n@@ -77,12 +78,12 @@ macro_rules! select {\n \n /// The \"port set\" of the select interface. This structure is used to manage a\n /// set of ports which are being selected over.\n-#[no_freeze]\n-#[no_send]\n pub struct Select {\n     priv head: *mut Packet,\n     priv tail: *mut Packet,\n     priv next_id: uint,\n+    priv marker1: marker::NoSend,\n+    priv marker2: marker::NoFreeze,\n }\n \n /// A handle to a port which is currently a member of a `Select` set of ports.\n@@ -108,6 +109,8 @@ impl Select {\n             head: 0 as *mut Packet,\n             tail: 0 as *mut Packet,\n             next_id: 1,\n+            marker1: marker::NoSend,\n+            marker2: marker::NoFreeze,\n         }\n     }\n "}, {"sha": "8ec07290a31646b4c445bd1ae1867831ebf9f4eb", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -18,32 +18,34 @@ collector is task-local so `Gc<T>` is not sendable.\n \n #[allow(experimental)];\n \n+use kinds::marker;\n use kinds::Send;\n use clone::{Clone, DeepClone};\n use managed;\n \n /// Immutable garbage-collected pointer type\n #[lang=\"gc\"]\n #[cfg(not(test))]\n-#[no_send]\n #[experimental = \"Gc is currently based on reference-counting and will not collect cycles until \\\n                   task annihilation. For now, cycles need to be broken manually by using `Rc<T>` \\\n                   with a non-owning `Weak<T>` pointer. A tracing garbage collector is planned.\"]\n pub struct Gc<T> {\n-    priv ptr: @T\n+    priv ptr: @T,\n+    priv marker: marker::NoSend,\n }\n \n #[cfg(test)]\n #[no_send]\n pub struct Gc<T> {\n-    priv ptr: @T\n+    priv ptr: @T,\n+    priv marker: marker::NoSend,\n }\n \n impl<T: 'static> Gc<T> {\n     /// Construct a new garbage-collected box\n     #[inline]\n     pub fn new(value: T) -> Gc<T> {\n-        Gc { ptr: @value }\n+        Gc { ptr: @value, marker: marker::NoSend }\n     }\n \n     /// Borrow the value contained in the garbage-collected box\n@@ -63,7 +65,7 @@ impl<T> Clone for Gc<T> {\n     /// Clone the pointer only\n     #[inline]\n     fn clone(&self) -> Gc<T> {\n-        Gc{ ptr: self.ptr }\n+        Gc{ ptr: self.ptr, marker: marker::NoSend }\n     }\n }\n "}, {"sha": "51e9e9b386474e04e99288241257b85bc517cc5d", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -46,3 +46,190 @@ pub trait Pod {\n     // Empty.\n }\n \n+/// Marker types are special types that are used with unsafe code to\n+/// inform the compiler of special constraints. Marker types should\n+/// only be needed when you are creating an abstraction that is\n+/// implemented using unsafe code. In that case, you may want to embed\n+/// some of the marker types below into your type.\n+pub mod marker {\n+\n+    /// A marker type whose type parameter `T` is considered to be\n+    /// covariant with respect to the type itself. This is (typically)\n+    /// used to indicate that an instance of the type `T` is being stored\n+    /// into memory and read from, even though that may not be apparent.\n+    ///\n+    /// For more information about variance, refer to this Wikipedia\n+    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+    ///\n+    /// *Note:* It is very unusual to have to add a covariant constraint.\n+    /// If you are not sure, you probably want to use `InvariantType`.\n+    ///\n+    /// # Example\n+    ///\n+    /// Given a struct `S` that includes a type parameter `T`\n+    /// but does not actually *reference* that type parameter:\n+    ///\n+    /// ```\n+    /// struct S<T> { x: *() }\n+    /// fn get<T>(s: &S<T>) -> T {\n+    ///    unsafe {\n+    ///        let x: *T = cast::transmute(s.x);\n+    ///        *x\n+    ///    }\n+    /// }\n+    /// ```\n+    ///\n+    /// The type system would currently infer that the value of\n+    /// the type parameter `T` is irrelevant, and hence a `S<int>` is\n+    /// a subtype of `S<~[int]>` (or, for that matter, `S<U>` for\n+    /// for any `U`). But this is incorrect because `get()` converts the\n+    /// `*()` into a `*T` and reads from it. Therefore, we should include the\n+    /// a marker field `CovariantType<T>` to inform the type checker that\n+    /// `S<T>` is a subtype of `S<U>` if `T` is a a subtype of `U`\n+    /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n+    /// for some lifetime `'a`, but not the other way around).\n+    #[lang=\"covariant_type\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct CovariantType<T>;\n+\n+    /// A marker type whose type parameter `T` is considered to be\n+    /// contravariant with respect to the type itself. This is (typically)\n+    /// used to indicate that an instance of the type `T` will be consumed\n+    /// (but not read from), even though that may not be apparent.\n+    ///\n+    /// For more information about variance, refer to this Wikipedia\n+    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+    ///\n+    /// *Note:* It is very unusual to have to add a contravariant constraint.\n+    /// If you are not sure, you probably want to use `InvariantType`.\n+    ///\n+    /// # Example\n+    ///\n+    /// Given a struct `S` that includes a type parameter `T`\n+    /// but does not actually *reference* that type parameter:\n+    ///\n+    /// ```\n+    /// struct S<T> { x: *() }\n+    /// fn get<T>(s: &S<T>, v: T) {\n+    ///    unsafe {\n+    ///        let x: fn(T) = cast::transmute(s.x);\n+    ///        x(v)\n+    ///    }\n+    /// }\n+    /// ```\n+    ///\n+    /// The type system would currently infer that the value of\n+    /// the type parameter `T` is irrelevant, and hence a `S<int>` is\n+    /// a subtype of `S<~[int]>` (or, for that matter, `S<U>` for\n+    /// for any `U`). But this is incorrect because `get()` converts the\n+    /// `*()` into a `fn(T)` and then passes a value of type `T` to it.\n+    ///\n+    /// Supplying a `ContravariantType` marker would correct the\n+    /// problem, because it would mark `S` so that `S<T>` is only a\n+    /// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n+    /// function requires arguments of type `T`, it must also accept\n+    /// arguments of type `U`, hence such a conversion is safe.\n+    #[lang=\"contravariant_type\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct ContravariantType<T>;\n+\n+    /// A marker type whose type parameter `T` is considered to be\n+    /// invariant with respect to the type itself. This is (typically)\n+    /// used to indicate that instances of the type `T` may be read or\n+    /// written, even though that may not be apparent.\n+    ///\n+    /// For more information about variance, refer to this Wikipedia\n+    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+    ///\n+    /// # Example\n+    ///\n+    /// The Cell type is an example which uses unsafe code to achieve\n+    /// \"interior\" mutability:\n+    ///\n+    /// ```\n+    /// struct Cell<T> { priv value: T }\n+    /// ```\n+    ///\n+    /// The type system would infer that `value` is only read here and\n+    /// never written, but in fact `Cell` uses unsafe code to achieve\n+    /// interior mutability.\n+    #[lang=\"invariant_type\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct InvariantType<T>;\n+\n+    /// As `CovariantType`, but for lifetime parameters. Using\n+    /// `CovariantLifetime<'a>` indicates that it is ok to substitute\n+    /// a *longer* lifetime for `'a` than the one you originally\n+    /// started with (e.g., you could convert any lifetime `'foo` to\n+    /// `'static`). You almost certainly want `ContravariantLifetime`\n+    /// instead, or possibly `InvariantLifetime`. The only case where\n+    /// it would be appropriate is that you have a (type-casted, and\n+    /// hence hidden from the type system) function pointer with a\n+    /// signature like `fn(&'a T)` (and no other uses of `'a`). In\n+    /// this case, it is ok to substitute a larger lifetime for `'a`\n+    /// (e.g., `fn(&'static T)`), because the function is only\n+    /// becoming more selective in terms of what it accepts as\n+    /// argument.\n+    ///\n+    /// For more information about variance, refer to this Wikipedia\n+    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+    #[lang=\"covariant_lifetime\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct CovariantLifetime<'a>;\n+\n+    /// As `ContravariantType`, but for lifetime parameters. Using\n+    /// `ContravariantLifetime<'a>` indicates that it is ok to\n+    /// substitute a *shorter* lifetime for `'a` than the one you\n+    /// originally started with (e.g., you could convert `'static` to\n+    /// any lifetime `'foo`). This is appropriate for cases where you\n+    /// have an unsafe pointer that is actually a pointer into some\n+    /// memory with lifetime `'a`, and thus you want to limit the\n+    /// lifetime of your data structure to `'a`. An example of where\n+    /// this is used is the iterator for vectors.\n+    ///\n+    /// For more information about variance, refer to this Wikipedia\n+    /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+    #[lang=\"contravariant_lifetime\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct ContravariantLifetime<'a>;\n+\n+    /// As `InvariantType`, but for lifetime parameters. Using\n+    /// `InvariantLifetime<'a>` indicates that it is not ok to\n+    /// substitute any other lifetime for `'a` besides its original\n+    /// value. This is appropriate for cases where you have an unsafe\n+    /// pointer that is actually a pointer into memory with lifetime `'a`,\n+    /// and this pointer is itself stored in an inherently mutable\n+    /// location (such as a `Cell`).\n+    #[lang=\"invariant_lifetime\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct InvariantLifetime<'a>;\n+\n+    /// A type which is considered \"not freezable\", meaning that\n+    /// its contents could change even if stored in an immutable\n+    /// context or it is the referent of an `&T` pointer. This is\n+    /// typically embedded in other types, such as `Cell`.\n+    #[lang=\"no_freeze_bound\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct NoFreeze;\n+\n+    /// A type which is considered \"not sendable\", meaning that it cannot\n+    /// be safely sent between tasks, even if it is owned. This is\n+    /// typically embedded in other types, such as `Gc`, to ensure that\n+    /// their instances remain thread-local.\n+    #[lang=\"no_send_bound\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct NoSend;\n+\n+    /// A type which is considered \"not POD\", meaning that it is not\n+    /// implicitly copyable. This is typically embedded in other types to\n+    /// ensure that they are never copied, even if they lack a destructor.\n+    #[lang=\"no_pod_bound\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct NoPod;\n+\n+    /// A type which is considered managed by the GC. This is typically\n+    /// embedded in other types.\n+    #[lang=\"managed_bound\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct Managed;\n+}"}, {"sha": "4496268430034a319b7f217a03d89c7e6798f2ce", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -69,6 +69,7 @@ use cast;\n use cmp::Ord;\n use container::Container;\n use iter::{Iterator, range};\n+use kinds::marker;\n use local_data;\n use prelude::*;\n use str;\n@@ -543,7 +544,6 @@ impl reseeding::Reseeder<StdRng> for TaskRngReseeder {\n static TASK_RNG_RESEED_THRESHOLD: uint = 32_768;\n type TaskRngInner = reseeding::ReseedingRng<StdRng, TaskRngReseeder>;\n /// The task-local RNG.\n-#[no_send]\n pub struct TaskRng {\n     // This points into TLS (specifically, it points to the endpoint\n     // of a ~ stored in TLS, to make it robust against TLS moving\n@@ -554,7 +554,8 @@ pub struct TaskRng {\n     // The use of unsafe code here is OK if the invariants above are\n     // satisfied; and it allows us to avoid (unnecessarily) using a\n     // GC'd or RC'd pointer.\n-    priv rng: *mut TaskRngInner\n+    priv rng: *mut TaskRngInner,\n+    priv marker: marker::NoSend,\n }\n \n // used to make space in TLS for a random number generator\n@@ -581,9 +582,9 @@ pub fn task_rng() -> TaskRng {\n \n             local_data::set(TASK_RNG_KEY, rng);\n \n-            TaskRng { rng: ptr }\n+            TaskRng { rng: ptr, marker: marker::NoSend }\n         }\n-        Some(rng) => TaskRng { rng: &mut **rng }\n+        Some(rng) => TaskRng { rng: &mut **rng, marker: marker::NoSend }\n     })\n }\n "}, {"sha": "7d0ddb2e4fb0951f86a6b4d6238937e3af88378b", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -27,6 +27,7 @@ use cast::transmute;\n use ops::Drop;\n use cmp::{Eq, Ord};\n use clone::{Clone, DeepClone};\n+use kinds::marker;\n use rt::global_heap::exchange_free;\n use ptr::read_ptr;\n use option::{Option, Some, None};\n@@ -39,16 +40,19 @@ struct RcBox<T> {\n \n /// Immutable reference counted pointer type\n #[unsafe_no_drop_flag]\n-#[no_send]\n pub struct Rc<T> {\n-    priv ptr: *mut RcBox<T>\n+    priv ptr: *mut RcBox<T>,\n+    priv marker: marker::NoSend\n }\n \n impl<T> Rc<T> {\n     /// Construct a new reference-counted box\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n-            Rc { ptr: transmute(~RcBox { value: value, strong: 1, weak: 0 }) }\n+            Rc {\n+                ptr: transmute(~RcBox { value: value, strong: 1, weak: 0 }),\n+                marker: marker::NoSend,\n+            }\n         }\n     }\n }\n@@ -64,7 +68,7 @@ impl<T> Rc<T> {\n     pub fn downgrade(&self) -> Weak<T> {\n         unsafe {\n             (*self.ptr).weak += 1;\n-            Weak { ptr: self.ptr }\n+            Weak { ptr: self.ptr, marker: marker::NoSend }\n         }\n     }\n }\n@@ -91,7 +95,7 @@ impl<T> Clone for Rc<T> {\n     fn clone(&self) -> Rc<T> {\n         unsafe {\n             (*self.ptr).strong += 1;\n-            Rc { ptr: self.ptr }\n+            Rc { ptr: self.ptr, marker: marker::NoSend }\n         }\n     }\n }\n@@ -127,9 +131,9 @@ impl<T: Ord> Ord for Rc<T> {\n \n /// Weak reference to a reference-counted box\n #[unsafe_no_drop_flag]\n-#[no_send]\n pub struct Weak<T> {\n-    priv ptr: *mut RcBox<T>\n+    priv ptr: *mut RcBox<T>,\n+    priv marker: marker::NoSend\n }\n \n impl<T> Weak<T> {\n@@ -140,7 +144,7 @@ impl<T> Weak<T> {\n                 None\n             } else {\n                 (*self.ptr).strong += 1;\n-                Some(Rc { ptr: self.ptr })\n+                Some(Rc { ptr: self.ptr, marker: marker::NoSend })\n             }\n         }\n     }\n@@ -165,7 +169,7 @@ impl<T> Clone for Weak<T> {\n     fn clone(&self) -> Weak<T> {\n         unsafe {\n             (*self.ptr).weak += 1;\n-            Weak { ptr: self.ptr }\n+            Weak { ptr: self.ptr, marker: marker::NoSend }\n         }\n     }\n }"}, {"sha": "bdb6077f984bf4ca764bcef6acf6c9b3951d4de1", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -117,6 +117,7 @@ use ptr::RawPtr;\n use rt::global_heap::{malloc_raw, realloc_raw, exchange_free};\n use mem;\n use mem::size_of;\n+use kinds::marker;\n use uint;\n use unstable::finally::Finally;\n use unstable::intrinsics;\n@@ -1055,12 +1056,12 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n                 Items{ptr: p,\n-                            end: (p as uint + self.len()) as *T,\n-                            lifetime: None}\n+                      end: (p as uint + self.len()) as *T,\n+                      marker: marker::ContravariantLifetime::<'a>}\n             } else {\n                 Items{ptr: p,\n-                            end: p.offset(self.len() as int),\n-                            lifetime: None}\n+                      end: p.offset(self.len() as int),\n+                      marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n     }\n@@ -2281,12 +2282,12 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n                 MutItems{ptr: p,\n-                               end: (p as uint + self.len()) as *mut T,\n-                               lifetime: None}\n+                         end: (p as uint + self.len()) as *mut T,\n+                         marker: marker::ContravariantLifetime::<'a>}\n             } else {\n                 MutItems{ptr: p,\n-                               end: p.offset(self.len() as int),\n-                               lifetime: None}\n+                         end: p.offset(self.len() as int),\n+                         marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n     }\n@@ -2638,7 +2639,7 @@ macro_rules! iterator {\n         pub struct $name<'a, T> {\n             priv ptr: $ptr,\n             priv end: $ptr,\n-            priv lifetime: Option<$elem> // FIXME: #5922\n+            priv marker: marker::ContravariantLifetime<'a>,\n         }\n \n         impl<'a, T> Iterator<$elem> for $name<'a, T> {"}, {"sha": "85f4f4fefd43e1ffa6472640317032018dab47e3", "filename": "src/test/compile-fail/marker-no-freeze.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fmarker-no-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fmarker-no-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmarker-no-freeze.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::kinds::marker;\n+\n+fn foo<P:Freeze>(p: P) { }\n+\n+fn main()\n+{\n+    foo(marker::NoFreeze); //~ ERROR does not fulfill `Freeze`\n+}"}, {"sha": "90b277a74323848262f8131ce821a554d8d00634", "filename": "src/test/compile-fail/marker-no-pod.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fmarker-no-pod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fmarker-no-pod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmarker-no-pod.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::kinds::marker;\n+\n+fn foo<P:Pod>(p: P) { }\n+\n+fn main()\n+{\n+    foo(marker::NoPod); //~ ERROR does not fulfill `Pod`\n+}"}, {"sha": "101959035eb9b6c59e74c5ac48f07f0e069746cb", "filename": "src/test/compile-fail/marker-no-send.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fmarker-no-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fmarker-no-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmarker-no-send.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::kinds::marker;\n+\n+fn foo<P:Send>(p: P) { }\n+\n+fn main()\n+{\n+    foo(marker::NoSend); //~ ERROR does not fulfill `Send`\n+}"}, {"sha": "0e14de61ff74cc64fe4764ea327b9a31c371edcc", "filename": "src/test/compile-fail/mutable-enum-indirect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -1,12 +1,13 @@\n // Tests that an `&` pointer to something inherently mutable is itself\n // to be considered mutable.\n \n-#[no_freeze]\n-enum Foo { A }\n+use std::kinds::marker;\n+\n+enum Foo { A(marker::NoFreeze) }\n \n fn bar<T: Freeze>(_: T) {}\n \n fn main() {\n-    let x = A;\n+    let x = A(marker::NoFreeze);\n     bar(&x); //~ ERROR type parameter with an incompatible type\n }"}, {"sha": "9b7189d02bb4db35c2eb6c65974da0555b9c2592", "filename": "src/test/compile-fail/no_freeze-enum.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fno_freeze-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fno_freeze-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_freeze-enum.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[no_freeze]\n-enum Foo { A }\n+use std::kinds::marker;\n+\n+enum Foo { A(marker::NoFreeze) }\n \n fn bar<T: Freeze>(_: T) {}\n \n fn main() {\n-    let x = A;\n+    let x = A(marker::NoFreeze);\n     bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Freeze`\n }"}, {"sha": "9ac7966e7041b48c8dd9eb458721e63c071a1c45", "filename": "src/test/compile-fail/no_freeze-struct.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fno_freeze-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fno_freeze-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_freeze-struct.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[no_freeze]\n-struct Foo { a: int }\n+use std::kinds::marker;\n+\n+struct Foo { a: int, m: marker::NoFreeze }\n \n fn bar<T: Freeze>(_: T) {}\n \n fn main() {\n-    let x = Foo { a: 5 };\n+    let x = Foo { a: 5, m: marker::NoFreeze };\n     bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Freeze`\n }"}, {"sha": "7a5ad743d217afd6f52de0ed92f684ec0d3ccc71", "filename": "src/test/compile-fail/no_send-enum.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-enum.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[no_send]\n-enum Foo { A }\n+use std::kinds::marker;\n+\n+enum Foo {\n+    A(marker::NoSend)\n+}\n \n fn bar<T: Send>(_: T) {}\n \n fn main() {\n-    let x = A;\n+    let x = A(marker::NoSend);\n     bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Send`\n }"}, {"sha": "7617602cbfbb8c7acee18dba65f27ece3d17b368", "filename": "src/test/compile-fail/no_send-struct.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-struct.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[no_send]\n-struct Foo { a: int }\n+use std::kinds::marker;\n+\n+struct Foo {\n+    a: int,\n+    ns: marker::NoSend\n+}\n \n fn bar<T: Send>(_: T) {}\n \n fn main() {\n-    let x = Foo { a: 5 };\n+    let x = Foo { a: 5, ns: marker::NoSend };\n     bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Send`\n }"}, {"sha": "d3e9c1f6ea848478afa3bbe7a0ac1f1fc7a75e57", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-decl.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is contravariant with respect to its region\n+// parameter yields an error when used in a covariant way.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+use std::kinds::marker;\n+\n+// This is contravariant with respect to 'a, meaning that\n+// Contravariant<'foo> <: Contravariant<'static> because\n+// 'foo <= 'static\n+struct Contravariant<'a> {\n+    marker: marker::ContravariantLifetime<'a>\n+}\n+\n+fn use_<'short,'long>(c: Contravariant<'short>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+\n+    // Test whether Contravariant<'short> <: Contravariant<'long>.  Since\n+    // 'short <= 'long, this would be true if the Contravariant type were\n+    // covariant with respect to its parameter 'a.\n+\n+    let _: Contravariant<'long> = c; //~ ERROR mismatched types\n+    //~^ ERROR  cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "2d3ca17301220ed81aa7af9249e3abaeeb536517", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-decl.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is covariant with respect to its region\n+// parameter yields an error when used in a contravariant way.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+use std::kinds::marker;\n+\n+struct Covariant<'a> {\n+    marker: marker::CovariantLifetime<'a>\n+}\n+\n+fn use_<'short,'long>(c: Covariant<'long>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+\n+    // Test whether Covariant<'long> <: Covariant<'short>.  Since\n+    // 'short <= 'long, this would be true if the Covariant type were\n+    // contravariant with respect to its parameter 'a.\n+\n+    let _: Covariant<'short> = c; //~ ERROR mismatched types\n+    //~^ ERROR  cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "ad5ad143b15bcbeed8dbc2979313515f5fd251d6", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-decl.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-decl.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::kinds::marker;\n+\n+struct invariant<'a> {\n+    marker: marker::InvariantLifetime<'a>\n+}\n+\n+fn to_same_lifetime<'r>(bi: invariant<'r>) {\n+    let bj: invariant<'r> = bi;\n+}\n+\n+fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n+    bi //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}"}, {"sha": "0efca74f3ced685bc5f74aab092c246ff5422199", "filename": "src/test/compile-fail/variance-cell-is-invariant.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fvariance-cell-is-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Fcompile-fail%2Fvariance-cell-is-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-cell-is-invariant.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that Cell is considered invariant with respect to its\n+// type.\n+\n+use std::cell::Cell;\n+\n+struct Foo<'a> {\n+    x: Cell<Option<&'a int>>,\n+}\n+\n+fn use_<'short,'long>(c: Foo<'short>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+    let _: Foo<'long> = c; //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}"}, {"sha": "97310fd9ad2e61cb04c41b1d653d73faf549a47e", "filename": "src/test/run-pass/cell-does-not-clone.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Frun-pass%2Fcell-does-not-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Frun-pass%2Fcell-does-not-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcell-does-not-clone.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+\n+struct Foo {\n+    x: int\n+}\n+\n+impl Clone for Foo {\n+    fn clone(&self) -> Foo {\n+        // Using Cell in any way should never cause clone() to be\n+        // invoked -- after all, that would permit evil user code to\n+        // abuse `Cell` and trigger crashes.\n+\n+        fail!();\n+    }\n+}\n+\n+pub fn main() {\n+    let x = Cell::new(Foo { x: 22 });\n+    let _y = x.get();\n+    let _z = x.clone();\n+}"}, {"sha": "8b9d6af1017b5ca4d122586ec03ba07cc2b5bc5d", "filename": "src/test/run-pass/regions-infer-bivariance.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Frun-pass%2Fregions-infer-bivariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d8328517a6a2830438aaec1d7e747156b13be0/src%2Ftest%2Frun-pass%2Fregions-infer-bivariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-bivariance.rs?ref=81d8328517a6a2830438aaec1d7e747156b13be0", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type whose lifetime parameters is never used is\n+// inferred to be bivariant.\n+\n+use std::kinds::marker;\n+\n+struct Bivariant<'a>;\n+\n+fn use1<'short,'long>(c: Bivariant<'short>,\n+                      _where:Option<&'short &'long ()>) {\n+    let _: Bivariant<'long> = c;\n+}\n+\n+fn use2<'short,'long>(c: Bivariant<'long>,\n+                      _where:Option<&'short &'long ()>) {\n+    let _: Bivariant<'short> = c;\n+}\n+\n+pub fn main() {}"}]}