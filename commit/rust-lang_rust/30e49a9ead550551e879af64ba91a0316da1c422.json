{"sha": "30e49a9ead550551e879af64ba91a0316da1c422", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZTQ5YTllYWQ1NTA1NTFlODc5YWY2NGJhOTFhMDMxNmRhMWM0MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-14T12:01:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-14T12:01:55Z"}, "message": "Auto merge of #75272 - the8472:spec-copy, r=KodrAus\n\nspecialize io::copy to use copy_file_range, splice or sendfile\n\nFixes #74426.\nAlso covers #60689 but only as an optimization instead of an official API.\n\nThe specialization only covers std-owned structs so it should avoid the problems with #71091\n\nCurrently linux-only but it should be generalizable to other unix systems that have sendfile/sosplice and similar.\n\nThere is a bit of optimization potential around the syscall count. Right now it may end up doing more syscalls than the naive copy loop when doing short (<8KiB) copies between file descriptors.\n\nThe test case executes the following:\n\n```\n[pid 103776] statx(3, \"\", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_ALL|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=17, ...}) = 0\n[pid 103776] write(4, \"wxyz\", 4)        = 4\n[pid 103776] write(4, \"iklmn\", 5)       = 5\n[pid 103776] copy_file_range(3, NULL, 4, NULL, 5, 0) = 5\n\n```\n\n0-1 `stat` calls to identify the source file type. 0 if the type can be inferred from the struct from which the FD was extracted\n\ud835\uddac `write` to drain the `BufReader`/`BufWriter` wrappers. only happen when buffers are present. \ud835\uddac \u227e number of wrappers present. If there is a write buffer it may absorb the read buffer contents first so only result in a single write. Vectored writes would also be an option but that would require more invasive changes to `BufWriter`.\n\ud835\uddad `copy_file_range`/`splice`/`sendfile` until file size, EOF or the byte limit from `Take` is reached. This should generally be *much* more efficient than the read-write loop and also have other benefits such as DMA offload or extent sharing.\n\n## Benchmarks\n\n```\n\nOLD\n\ntest io::tests::bench_file_to_file_copy         ... bench:      21,002 ns/iter (+/- 750) = 6240 MB/s    [ext4]\ntest io::tests::bench_file_to_file_copy         ... bench:      35,704 ns/iter (+/- 1,108) = 3671 MB/s  [btrfs]\ntest io::tests::bench_file_to_socket_copy       ... bench:      57,002 ns/iter (+/- 4,205) = 2299 MB/s\ntest io::tests::bench_socket_pipe_socket_copy   ... bench:     142,640 ns/iter (+/- 77,851) = 918 MB/s\n\nNEW\n\ntest io::tests::bench_file_to_file_copy         ... bench:      14,745 ns/iter (+/- 519) = 8889 MB/s    [ext4]\ntest io::tests::bench_file_to_file_copy         ... bench:       6,128 ns/iter (+/- 227) = 21389 MB/s   [btrfs]\ntest io::tests::bench_file_to_socket_copy       ... bench:      13,767 ns/iter (+/- 3,767) = 9520 MB/s\ntest io::tests::bench_socket_pipe_socket_copy   ... bench:      26,471 ns/iter (+/- 6,412) = 4951 MB/s\n```", "tree": {"sha": "823b168363511d69d5432425cf60a06ceb15f6b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/823b168363511d69d5432425cf60a06ceb15f6b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30e49a9ead550551e879af64ba91a0316da1c422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30e49a9ead550551e879af64ba91a0316da1c422", "html_url": "https://github.com/rust-lang/rust/commit/30e49a9ead550551e879af64ba91a0316da1c422", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30e49a9ead550551e879af64ba91a0316da1c422/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66c1309446236985da64b56994ceca1127ca514e", "url": "https://api.github.com/repos/rust-lang/rust/commits/66c1309446236985da64b56994ceca1127ca514e", "html_url": "https://github.com/rust-lang/rust/commit/66c1309446236985da64b56994ceca1127ca514e"}, {"sha": "bbfa92c82debed28417350b15fc6a2f46135346d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbfa92c82debed28417350b15fc6a2f46135346d", "html_url": "https://github.com/rust-lang/rust/commit/bbfa92c82debed28417350b15fc6a2f46135346d"}], "stats": {"total": 1082, "additions": 930, "deletions": 152}, "files": [{"sha": "a4123cc15b8767c5d3d2c27403dd8c2cfd119387", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -1656,7 +1656,7 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// the length of the `to` file as reported by `metadata`.\n ///\n /// If you\u2019re wanting to copy the contents of one file to another and you\u2019re\n-/// working with [`File`]s, see the [`io::copy`] function.\n+/// working with [`File`]s, see the [`io::copy()`] function.\n ///\n /// # Platform-specific behavior\n ///"}, {"sha": "b88bca2f2b4ff04a6140f439f818a6e1f6da2fca", "filename": "library/std/src/io/copy.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -0,0 +1,88 @@\n+use crate::io::{self, ErrorKind, Read, Write};\n+use crate::mem::MaybeUninit;\n+\n+/// Copies the entire contents of a reader into a writer.\n+///\n+/// This function will continuously read data from `reader` and then\n+/// write it into `writer` in a streaming fashion until `reader`\n+/// returns EOF.\n+///\n+/// On success, the total number of bytes that were copied from\n+/// `reader` to `writer` is returned.\n+///\n+/// If you\u2019re wanting to copy the contents of one file to another and you\u2019re\n+/// working with filesystem paths, see the [`fs::copy`] function.\n+///\n+/// [`fs::copy`]: crate::fs::copy\n+///\n+/// # Errors\n+///\n+/// This function will return an error immediately if any call to [`read`] or\n+/// [`write`] returns an error. All instances of [`ErrorKind::Interrupted`] are\n+/// handled by this function and the underlying operation is retried.\n+///\n+/// [`read`]: Read::read\n+/// [`write`]: Write::write\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::io;\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut reader: &[u8] = b\"hello\";\n+///     let mut writer: Vec<u8> = vec![];\n+///\n+///     io::copy(&mut reader, &mut writer)?;\n+///\n+///     assert_eq!(&b\"hello\"[..], &writer[..]);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+where\n+    R: Read,\n+    W: Write,\n+{\n+    cfg_if::cfg_if! {\n+        if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n+            crate::sys::kernel_copy::copy_spec(reader, writer)\n+        } else {\n+            generic_copy(reader, writer)\n+        }\n+    }\n+}\n+\n+/// The general read-write-loop implementation of\n+/// `io::copy` that is used when specializations are not available or not applicable.\n+pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+where\n+    R: Read,\n+    W: Write,\n+{\n+    let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n+    // FIXME: #42788\n+    //\n+    //   - This creates a (mut) reference to a slice of\n+    //     _uninitialized_ integers, which is **undefined behavior**\n+    //\n+    //   - Only the standard library gets to soundly \"ignore\" this,\n+    //     based on its privileged knowledge of unstable rustc\n+    //     internals;\n+    unsafe {\n+        reader.initializer().initialize(buf.assume_init_mut());\n+    }\n+\n+    let mut written = 0;\n+    loop {\n+        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n+            Ok(0) => return Ok(written),\n+            Ok(len) => len,\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+            Err(e) => return Err(e),\n+        };\n+        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n+        written += len as u64;\n+    }\n+}"}, {"sha": "57413f9bc406348fcff6086cd7c39e392ee68eb6", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -266,6 +266,8 @@ pub use self::buffered::IntoInnerError;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::{BufReader, BufWriter, LineWriter};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::copy::copy;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::cursor::Cursor;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::error::{Error, ErrorKind, Result};\n@@ -279,11 +281,12 @@ pub use self::stdio::{_eprint, _print};\n #[doc(no_inline, hidden)]\n pub use self::stdio::{set_panic, set_print, LocalOutput};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::util::{copy, empty, repeat, sink, Empty, Repeat, Sink};\n+pub use self::util::{empty, repeat, sink, Empty, Repeat, Sink};\n \n pub(crate) use self::stdio::clone_io;\n \n mod buffered;\n+pub(crate) mod copy;\n mod cursor;\n mod error;\n mod impls;"}, {"sha": "8fbce09dd6362673602a42bd2580c43f7de1657c", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -409,6 +409,14 @@ impl Read for Stdin {\n     }\n }\n \n+// only used by platform-dependent io::copy specializations, i.e. unused on some platforms\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+impl StdinLock<'_> {\n+    pub(crate) fn as_mut_buf(&mut self) -> &mut BufReader<impl Read> {\n+        &mut self.inner\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for StdinLock<'_> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {"}, {"sha": "f176c2f088cb314e850d11057fbd3f4f120b5773", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -1,7 +1,7 @@\n use super::{repeat, Cursor, SeekFrom};\n use crate::cmp::{self, min};\n-use crate::io::prelude::*;\n use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{BufRead, Read, Seek, Write};\n use crate::ops::Deref;\n \n #[test]"}, {"sha": "db845457c96720397eaa99bfecd88e98a6a46984", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 1, "deletions": 72, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -4,78 +4,7 @@\n mod tests;\n \n use crate::fmt;\n-use crate::io::{self, BufRead, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Write};\n-use crate::mem::MaybeUninit;\n-\n-/// Copies the entire contents of a reader into a writer.\n-///\n-/// This function will continuously read data from `reader` and then\n-/// write it into `writer` in a streaming fashion until `reader`\n-/// returns EOF.\n-///\n-/// On success, the total number of bytes that were copied from\n-/// `reader` to `writer` is returned.\n-///\n-/// If you\u2019re wanting to copy the contents of one file to another and you\u2019re\n-/// working with filesystem paths, see the [`fs::copy`] function.\n-///\n-/// [`fs::copy`]: crate::fs::copy\n-///\n-/// # Errors\n-///\n-/// This function will return an error immediately if any call to [`read`] or\n-/// [`write`] returns an error. All instances of [`ErrorKind::Interrupted`] are\n-/// handled by this function and the underlying operation is retried.\n-///\n-/// [`read`]: Read::read\n-/// [`write`]: Write::write\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::io;\n-///\n-/// fn main() -> io::Result<()> {\n-///     let mut reader: &[u8] = b\"hello\";\n-///     let mut writer: Vec<u8> = vec![];\n-///\n-///     io::copy(&mut reader, &mut writer)?;\n-///\n-///     assert_eq!(&b\"hello\"[..], &writer[..]);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n-where\n-    R: Read,\n-    W: Write,\n-{\n-    let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n-    // FIXME: #42788\n-    //\n-    //   - This creates a (mut) reference to a slice of\n-    //     _uninitialized_ integers, which is **undefined behavior**\n-    //\n-    //   - Only the standard library gets to soundly \"ignore\" this,\n-    //     based on its privileged knowledge of unstable rustc\n-    //     internals;\n-    unsafe {\n-        reader.initializer().initialize(buf.assume_init_mut());\n-    }\n-\n-    let mut written = 0;\n-    loop {\n-        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n-            Ok(0) => return Ok(written),\n-            Ok(len) => len,\n-            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n-            Err(e) => return Err(e),\n-        };\n-        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n-        written += len as u64;\n-    }\n-}\n+use crate::io::{self, BufRead, Initializer, IoSlice, IoSliceMut, Read, Write};\n \n /// A reader which is always at EOF.\n ///"}, {"sha": "ffc9cf3f2eb14b0ab505c1276d7a40a0a31e7b04", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -317,6 +317,7 @@\n #![feature(toowned_clone_into)]\n #![feature(total_cmp)]\n #![feature(trace_macros)]\n+#![feature(try_blocks)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_block_in_unsafe_fn)]"}, {"sha": "13cf930379cbca9666c2ecd6e7750e04a0b51b71", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 8, "deletions": 77, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -1204,88 +1204,19 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n-    use crate::cmp;\n-    use crate::sync::atomic::{AtomicBool, Ordering};\n-\n-    // Kernel prior to 4.5 don't have copy_file_range\n-    // We store the availability in a global to avoid unnecessary syscalls\n-    static HAS_COPY_FILE_RANGE: AtomicBool = AtomicBool::new(true);\n-\n-    unsafe fn copy_file_range(\n-        fd_in: libc::c_int,\n-        off_in: *mut libc::loff_t,\n-        fd_out: libc::c_int,\n-        off_out: *mut libc::loff_t,\n-        len: libc::size_t,\n-        flags: libc::c_uint,\n-    ) -> libc::c_long {\n-        libc::syscall(libc::SYS_copy_file_range, fd_in, off_in, fd_out, off_out, len, flags)\n-    }\n-\n     let (mut reader, reader_metadata) = open_from(from)?;\n     let max_len = u64::MAX;\n     let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n \n-    let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n-    let mut written = 0u64;\n-    while written < max_len {\n-        let copy_result = if has_copy_file_range {\n-            let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64) as usize;\n-            let copy_result = unsafe {\n-                // We actually don't have to adjust the offsets,\n-                // because copy_file_range adjusts the file offset automatically\n-                cvt(copy_file_range(\n-                    reader.as_raw_fd(),\n-                    ptr::null_mut(),\n-                    writer.as_raw_fd(),\n-                    ptr::null_mut(),\n-                    bytes_to_copy,\n-                    0,\n-                ))\n-            };\n-            if let Err(ref copy_err) = copy_result {\n-                match copy_err.raw_os_error() {\n-                    Some(libc::ENOSYS | libc::EPERM | libc::EOPNOTSUPP) => {\n-                        HAS_COPY_FILE_RANGE.store(false, Ordering::Relaxed);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            copy_result\n-        } else {\n-            Err(io::Error::from_raw_os_error(libc::ENOSYS))\n-        };\n-        match copy_result {\n-            Ok(0) if written == 0 => {\n-                // fallback to work around several kernel bugs where copy_file_range will fail to\n-                // copy any bytes and return 0 instead of an error if\n-                // - reading virtual files from the proc filesystem which appear to have 0 size\n-                //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n-                // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n-                return io::copy(&mut reader, &mut writer);\n-            }\n-            Ok(0) => return Ok(written), // reached EOF\n-            Ok(ret) => written += ret as u64,\n-            Err(err) => {\n-                match err.raw_os_error() {\n-                    Some(\n-                        libc::ENOSYS | libc::EXDEV | libc::EINVAL | libc::EPERM | libc::EOPNOTSUPP,\n-                    ) => {\n-                        // Try fallback io::copy if either:\n-                        // - Kernel version is < 4.5 (ENOSYS)\n-                        // - Files are mounted on different fs (EXDEV)\n-                        // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n-                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n-                        // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n-                        assert_eq!(written, 0);\n-                        return io::copy(&mut reader, &mut writer);\n-                    }\n-                    _ => return Err(err),\n-                }\n-            }\n-        }\n+    use super::kernel_copy::{copy_regular_files, CopyResult};\n+\n+    match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n+        CopyResult::Ended(result) => result,\n+        CopyResult::Fallback(written) => match io::copy::generic_copy(&mut reader, &mut writer) {\n+            Ok(bytes) => Ok(bytes + written),\n+            Err(e) => Err(e),\n+        },\n     }\n-    Ok(written)\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "ac2fcfcb53f72342af6f25f66f3bde14aaa2aec7", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "added", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -0,0 +1,603 @@\n+//! This module contains specializations that can offload `io::copy()` operations on file descriptor\n+//! containing types (`File`, `TcpStream`, etc.) to more efficient syscalls than `read(2)` and `write(2)`.\n+//!\n+//! Specialization is only applied to wholly std-owned types so that user code can't observe\n+//! that the `Read` and `Write` traits are not used.\n+//!\n+//! Since a copy operation involves a reader and writer side where each can consist of different types\n+//! and also involve generic wrappers (e.g. `Take`, `BufReader`) it is not practical to specialize\n+//! a single method on all possible combinations.\n+//!\n+//! Instead readers and writers are handled separately by the `CopyRead` and `CopyWrite` specialization\n+//! traits and then specialized on by the `Copier::copy` method.\n+//!\n+//! `Copier` uses the specialization traits to unpack the underlying file descriptors and\n+//! additional prerequisites and constraints imposed by the wrapper types.\n+//!\n+//! Once it has obtained all necessary pieces and brought any wrapper types into a state where they\n+//! can be safely bypassed it will attempt to use the `copy_file_range(2)`,\n+//! `sendfile(2)` or `splice(2)` syscalls to move data directly between file descriptors.\n+//! Since those syscalls have requirements that cannot be fully checked in advance and\n+//! gathering additional information about file descriptors would require additional syscalls\n+//! anyway it simply attempts to use them one after another (guided by inaccurate hints) to\n+//! figure out which one works and and falls back to the generic read-write copy loop if none of them\n+//! does.\n+//! Once a working syscall is found for a pair of file descriptors it will be called in a loop\n+//! until the copy operation is completed.\n+//!\n+//! Advantages of using these syscalls:\n+//!\n+//! * fewer context switches since reads and writes are coalesced into a single syscall\n+//!   and more bytes are transferred per syscall. This translates to higher throughput\n+//!   and fewer CPU cycles, at least for sufficiently large transfers to amortize the initial probing.\n+//! * `copy_file_range` creates reflink copies on CoW filesystems, thus moving less data and\n+//!   consuming less disk space\n+//! * `sendfile` and `splice` can perform zero-copy IO under some circumstances while\n+//!   a naive copy loop would move every byte through the CPU.\n+//!\n+//! Drawbacks:\n+//!\n+//! * copy operations smaller than the default buffer size can under some circumstances, especially\n+//!   on older kernels, incur more syscalls than the naive approach would. As mentioned above\n+//!   the syscall selection is guided by hints to minimize this possibility but they are not perfect.\n+//! * optimizations only apply to std types. If a user adds a custom wrapper type, e.g. to report\n+//!   progress, they can hit a performance cliff.\n+//! * complexity\n+\n+use crate::cmp::min;\n+use crate::convert::TryInto;\n+use crate::fs::{File, Metadata};\n+use crate::io::copy::generic_copy;\n+use crate::io::{\n+    BufRead, BufReader, BufWriter, Error, Read, Result, StderrLock, StdinLock, StdoutLock, Take,\n+    Write,\n+};\n+use crate::mem::ManuallyDrop;\n+use crate::net::TcpStream;\n+use crate::os::unix::fs::FileTypeExt;\n+use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n+use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sys::cvt;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+pub(crate) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n+    read: &mut R,\n+    write: &mut W,\n+) -> Result<u64> {\n+    let copier = Copier { read, write };\n+    SpecCopy::copy(copier)\n+}\n+\n+/// This type represents either the inferred `FileType` of a `RawFd` based on the source\n+/// type from which it was extracted or the actual metadata\n+///\n+/// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n+/// type may be wrong.\n+enum FdMeta {\n+    /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n+    /// because it is cheaper than probing all possible syscalls (reader side)\n+    Metadata(Metadata),\n+    Socket,\n+    Pipe,\n+    /// We don't have any metadata, e.g. because the original type was `File` which can represent\n+    /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n+    /// (writer side)\n+    NoneObtained,\n+}\n+\n+impl FdMeta {\n+    fn maybe_fifo(&self) -> bool {\n+        match self {\n+            FdMeta::Metadata(meta) => meta.file_type().is_fifo(),\n+            FdMeta::Socket => false,\n+            FdMeta::Pipe => true,\n+            FdMeta::NoneObtained => true,\n+        }\n+    }\n+\n+    fn potential_sendfile_source(&self) -> bool {\n+        match self {\n+            // procfs erronously shows 0 length on non-empty readable files.\n+            // and if a file is truly empty then a `read` syscall will determine that and skip the write syscall\n+            // thus there would be benefit from attempting sendfile\n+            FdMeta::Metadata(meta)\n+                if meta.file_type().is_file() && meta.len() > 0\n+                    || meta.file_type().is_block_device() =>\n+            {\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn copy_file_range_candidate(&self) -> bool {\n+        match self {\n+            // copy_file_range will fail on empty procfs files. `read` can determine whether EOF has been reached\n+            // without extra cost and skip the write, thus there is no benefit in attempting copy_file_range\n+            FdMeta::Metadata(meta) if meta.is_file() && meta.len() > 0 => true,\n+            FdMeta::NoneObtained => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+struct CopyParams(FdMeta, Option<RawFd>);\n+\n+struct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n+    read: &'a mut R,\n+    write: &'b mut W,\n+}\n+\n+trait SpecCopy {\n+    fn copy(self) -> Result<u64>;\n+}\n+\n+impl<R: Read + ?Sized, W: Write + ?Sized> SpecCopy for Copier<'_, '_, R, W> {\n+    default fn copy(self) -> Result<u64> {\n+        generic_copy(self.read, self.write)\n+    }\n+}\n+\n+impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n+    fn copy(self) -> Result<u64> {\n+        let (reader, writer) = (self.read, self.write);\n+        let r_cfg = reader.properties();\n+        let w_cfg = writer.properties();\n+\n+        // before direct operations on file descriptors ensure that all source and sink buffers are empty\n+        let mut flush = || -> crate::io::Result<u64> {\n+            let bytes = reader.drain_to(writer, u64::MAX)?;\n+            // BufWriter buffered bytes have already been accounted for in earlier write() calls\n+            writer.flush()?;\n+            Ok(bytes)\n+        };\n+\n+        let mut written = 0u64;\n+\n+        if let (CopyParams(input_meta, Some(readfd)), CopyParams(output_meta, Some(writefd))) =\n+            (r_cfg, w_cfg)\n+        {\n+            written += flush()?;\n+            let max_write = reader.min_limit();\n+\n+            if input_meta.copy_file_range_candidate() && output_meta.copy_file_range_candidate() {\n+                let result = copy_regular_files(readfd, writefd, max_write);\n+\n+                match result {\n+                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Fallback(bytes) => written += bytes,\n+                }\n+            }\n+\n+            // on modern kernels sendfile can copy from any mmapable type (some but not all regular files and block devices)\n+            // to any writable file descriptor. On older kernels the writer side can only be a socket.\n+            // So we just try and fallback if needed.\n+            // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n+            // fall back to the generic copy loop.\n+            if input_meta.potential_sendfile_source() {\n+                let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n+\n+                match result {\n+                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Fallback(bytes) => written += bytes,\n+                }\n+            }\n+\n+            if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n+                let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n+\n+                match result {\n+                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n+                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Fallback(0) => { /* use the fallback below */ }\n+                    CopyResult::Fallback(_) => {\n+                        unreachable!(\"splice should not return > 0 bytes on the fallback path\")\n+                    }\n+                }\n+            }\n+        }\n+\n+        // fallback if none of the more specialized syscalls wants to work with these file descriptors\n+        match generic_copy(reader, writer) {\n+            Ok(bytes) => Ok(bytes + written),\n+            err => err,\n+        }\n+    }\n+}\n+\n+#[rustc_specialization_trait]\n+trait CopyRead: Read {\n+    /// Implementations that contain buffers (i.e. `BufReader`) must transfer data from their internal\n+    /// buffers into `writer` until either the buffers are emptied or `limit` bytes have been\n+    /// transferred, whichever occurs sooner.\n+    /// If nested buffers are present the outer buffers must be drained first.\n+    ///\n+    /// This is necessary to directly bypass the wrapper types while preserving the data order\n+    /// when operating directly on the underlying file descriptors.\n+    fn drain_to<W: Write>(&mut self, _writer: &mut W, _limit: u64) -> Result<u64> {\n+        Ok(0)\n+    }\n+\n+    /// The minimum of the limit of all `Take<_>` wrappers, `u64::MAX` otherwise.\n+    /// This method does not account for data `BufReader` buffers and would underreport\n+    /// the limit of a `Take<BufReader<Take<_>>>` type. Thus its result is only valid\n+    /// after draining the buffers via `drain_to`.\n+    fn min_limit(&self) -> u64 {\n+        u64::MAX\n+    }\n+\n+    /// Extracts the file descriptor and hints/metadata, delegating through wrappers if necessary.\n+    fn properties(&self) -> CopyParams;\n+}\n+\n+#[rustc_specialization_trait]\n+trait CopyWrite: Write {\n+    /// Extracts the file descriptor and hints/metadata, delegating through wrappers if necessary.\n+    fn properties(&self) -> CopyParams;\n+}\n+\n+impl<T> CopyRead for &mut T\n+where\n+    T: CopyRead,\n+{\n+    fn drain_to<W: Write>(&mut self, writer: &mut W, limit: u64) -> Result<u64> {\n+        (**self).drain_to(writer, limit)\n+    }\n+\n+    fn min_limit(&self) -> u64 {\n+        (**self).min_limit()\n+    }\n+\n+    fn properties(&self) -> CopyParams {\n+        (**self).properties()\n+    }\n+}\n+\n+impl<T> CopyWrite for &mut T\n+where\n+    T: CopyWrite,\n+{\n+    fn properties(&self) -> CopyParams {\n+        (**self).properties()\n+    }\n+}\n+\n+impl CopyRead for File {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for &File {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for File {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for &File {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for TcpStream {\n+    fn properties(&self) -> CopyParams {\n+        // avoid the stat syscall since we can be fairly sure it's a socket\n+        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for &TcpStream {\n+    fn properties(&self) -> CopyParams {\n+        // avoid the stat syscall since we can be fairly sure it's a socket\n+        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for TcpStream {\n+    fn properties(&self) -> CopyParams {\n+        // avoid the stat syscall since we can be fairly sure it's a socket\n+        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for &TcpStream {\n+    fn properties(&self) -> CopyParams {\n+        // avoid the stat syscall since we can be fairly sure it's a socket\n+        CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for ChildStdin {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for ChildStdout {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for ChildStderr {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyRead for StdinLock<'_> {\n+    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+        let buf_reader = self.as_mut_buf();\n+        let buf = buf_reader.buffer();\n+        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n+        let bytes_drained = buf.len();\n+        writer.write_all(buf)?;\n+        buf_reader.consume(bytes_drained);\n+\n+        Ok(bytes_drained as u64)\n+    }\n+\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for StdoutLock<'_> {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl CopyWrite for StderrLock<'_> {\n+    fn properties(&self) -> CopyParams {\n+        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+    }\n+}\n+\n+impl<T: CopyRead> CopyRead for Take<T> {\n+    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+        let local_limit = self.limit();\n+        let combined_limit = min(outer_limit, local_limit);\n+        let bytes_drained = self.get_mut().drain_to(writer, combined_limit)?;\n+        // update limit since read() was bypassed\n+        self.set_limit(local_limit - bytes_drained);\n+\n+        Ok(bytes_drained)\n+    }\n+\n+    fn min_limit(&self) -> u64 {\n+        min(Take::limit(self), self.get_ref().min_limit())\n+    }\n+\n+    fn properties(&self) -> CopyParams {\n+        self.get_ref().properties()\n+    }\n+}\n+\n+impl<T: CopyRead> CopyRead for BufReader<T> {\n+    fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+        let buf = self.buffer();\n+        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n+        let bytes = buf.len();\n+        writer.write_all(buf)?;\n+        self.consume(bytes);\n+\n+        let remaining = outer_limit - bytes as u64;\n+\n+        // in case of nested bufreaders we also need to drain the ones closer to the source\n+        let inner_bytes = self.get_mut().drain_to(writer, remaining)?;\n+\n+        Ok(bytes as u64 + inner_bytes)\n+    }\n+\n+    fn min_limit(&self) -> u64 {\n+        self.get_ref().min_limit()\n+    }\n+\n+    fn properties(&self) -> CopyParams {\n+        self.get_ref().properties()\n+    }\n+}\n+\n+impl<T: CopyWrite> CopyWrite for BufWriter<T> {\n+    fn properties(&self) -> CopyParams {\n+        self.get_ref().properties()\n+    }\n+}\n+\n+fn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n+    let fd = fd.as_raw_fd();\n+    let file: ManuallyDrop<File> = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });\n+    match file.metadata() {\n+        Ok(meta) => FdMeta::Metadata(meta),\n+        Err(_) => FdMeta::NoneObtained,\n+    }\n+}\n+\n+pub(super) enum CopyResult {\n+    Ended(Result<u64>),\n+    Fallback(u64),\n+}\n+\n+/// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n+/// as the name says, it only works on regular files\n+///\n+/// Callers must handle fallback to a generic copy loop.\n+/// `Fallback` may indicate non-zero number of bytes already written\n+/// if one of the files' cursor +`max_len` would exceed u64::MAX (`EOVERFLOW`).\n+pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n+    use crate::cmp;\n+\n+    // Kernel prior to 4.5 don't have copy_file_range\n+    // We store the availability in a global to avoid unnecessary syscalls\n+    static HAS_COPY_FILE_RANGE: AtomicBool = AtomicBool::new(true);\n+\n+    unsafe fn copy_file_range(\n+        fd_in: libc::c_int,\n+        off_in: *mut libc::loff_t,\n+        fd_out: libc::c_int,\n+        off_out: *mut libc::loff_t,\n+        len: libc::size_t,\n+        flags: libc::c_uint,\n+    ) -> libc::c_long {\n+        libc::syscall(libc::SYS_copy_file_range, fd_in, off_in, fd_out, off_out, len, flags)\n+    }\n+\n+    let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n+    let mut written = 0u64;\n+    while written < max_len {\n+        let copy_result = if has_copy_file_range {\n+            let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n+            // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n+            // this allows us to copy large chunks without hitting EOVERFLOW,\n+            // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n+            let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n+            let copy_result = unsafe {\n+                // We actually don't have to adjust the offsets,\n+                // because copy_file_range adjusts the file offset automatically\n+                cvt(copy_file_range(\n+                    reader,\n+                    ptr::null_mut(),\n+                    writer,\n+                    ptr::null_mut(),\n+                    bytes_to_copy,\n+                    0,\n+                ))\n+            };\n+            if let Err(ref copy_err) = copy_result {\n+                match copy_err.raw_os_error() {\n+                    Some(libc::ENOSYS | libc::EPERM | libc::EOPNOTSUPP) => {\n+                        HAS_COPY_FILE_RANGE.store(false, Ordering::Relaxed);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            copy_result\n+        } else {\n+            Err(Error::from_raw_os_error(libc::ENOSYS))\n+        };\n+        match copy_result {\n+            Ok(0) if written == 0 => {\n+                // fallback to work around several kernel bugs where copy_file_range will fail to\n+                // copy any bytes and return 0 instead of an error if\n+                // - reading virtual files from the proc filesystem which appear to have 0 size\n+                //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n+                // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n+                return CopyResult::Fallback(0);\n+            }\n+            Ok(0) => return CopyResult::Ended(Ok(written)), // reached EOF\n+            Ok(ret) => written += ret as u64,\n+            Err(err) => {\n+                return match err.raw_os_error() {\n+                    // when file offset + max_length > u64::MAX\n+                    Some(libc::EOVERFLOW) => CopyResult::Fallback(written),\n+                    Some(\n+                        libc::ENOSYS | libc::EXDEV | libc::EINVAL | libc::EPERM | libc::EOPNOTSUPP,\n+                    ) => {\n+                        // Try fallback io::copy if either:\n+                        // - Kernel version is < 4.5 (ENOSYS)\n+                        // - Files are mounted on different fs (EXDEV)\n+                        // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n+                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n+                        // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n+                        assert_eq!(written, 0);\n+                        CopyResult::Fallback(0)\n+                    }\n+                    _ => CopyResult::Ended(Err(err)),\n+                };\n+            }\n+        }\n+    }\n+    CopyResult::Ended(Ok(written))\n+}\n+\n+#[derive(PartialEq)]\n+enum SpliceMode {\n+    Sendfile,\n+    Splice,\n+}\n+\n+/// performs splice or sendfile between file descriptors\n+/// Does _not_ fall back to a generic copy loop.\n+fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) -> CopyResult {\n+    static HAS_SENDFILE: AtomicBool = AtomicBool::new(true);\n+    static HAS_SPLICE: AtomicBool = AtomicBool::new(true);\n+\n+    syscall! {\n+        fn splice(\n+            srcfd: libc::c_int,\n+            src_offset: *const i64,\n+            dstfd: libc::c_int,\n+            dst_offset: *const i64,\n+            len: libc::size_t,\n+            flags: libc::c_int\n+        ) -> libc::ssize_t\n+    }\n+\n+    match mode {\n+        SpliceMode::Sendfile if !HAS_SENDFILE.load(Ordering::Relaxed) => {\n+            return CopyResult::Fallback(0);\n+        }\n+        SpliceMode::Splice if !HAS_SPLICE.load(Ordering::Relaxed) => {\n+            return CopyResult::Fallback(0);\n+        }\n+        _ => (),\n+    }\n+\n+    let mut written = 0u64;\n+    while written < len {\n+        // according to its manpage that's the maximum size sendfile() will copy per invocation\n+        let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n+\n+        let result = match mode {\n+            SpliceMode::Sendfile => {\n+                cvt(unsafe { libc::sendfile(writer, reader, ptr::null_mut(), chunk_size) })\n+            }\n+            SpliceMode::Splice => cvt(unsafe {\n+                splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n+            }),\n+        };\n+\n+        match result {\n+            Ok(0) => break, // EOF\n+            Ok(ret) => written += ret as u64,\n+            Err(err) => {\n+                return match err.raw_os_error() {\n+                    Some(libc::ENOSYS | libc::EPERM) => {\n+                        // syscall not supported (ENOSYS)\n+                        // syscall is disallowed, e.g. by seccomp (EPERM)\n+                        match mode {\n+                            SpliceMode::Sendfile => HAS_SENDFILE.store(false, Ordering::Relaxed),\n+                            SpliceMode::Splice => HAS_SPLICE.store(false, Ordering::Relaxed),\n+                        }\n+                        assert_eq!(written, 0);\n+                        CopyResult::Fallback(0)\n+                    }\n+                    Some(libc::EINVAL) => {\n+                        // splice/sendfile do not support this particular file descriptor (EINVAL)\n+                        assert_eq!(written, 0);\n+                        CopyResult::Fallback(0)\n+                    }\n+                    Some(os_err) if mode == SpliceMode::Sendfile && os_err == libc::EOVERFLOW => {\n+                        CopyResult::Fallback(written)\n+                    }\n+                    _ => CopyResult::Ended(Err(err)),\n+                };\n+            }\n+        }\n+    }\n+    CopyResult::Ended(Ok(written))\n+}"}, {"sha": "21b121c26fffc07ae45c42b1c5e24fd099210e7c", "filename": "library/std/src/sys/unix/kernel_copy/tests.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -0,0 +1,213 @@\n+use crate::env::temp_dir;\n+use crate::fs::OpenOptions;\n+use crate::io;\n+use crate::io::Result;\n+use crate::io::SeekFrom;\n+use crate::io::{BufRead, Read, Seek, Write};\n+use crate::os::unix::io::AsRawFd;\n+\n+#[test]\n+fn copy_specialization() -> Result<()> {\n+    use crate::io::{BufReader, BufWriter};\n+\n+    let path = crate::env::temp_dir();\n+    let source_path = path.join(\"copy-spec.source\");\n+    let sink_path = path.join(\"copy-spec.sink\");\n+\n+    let result: Result<()> = try {\n+        let mut source = crate::fs::OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(true)\n+            .truncate(true)\n+            .open(&source_path)?;\n+        source.write_all(b\"abcdefghiklmnopqr\")?;\n+        source.seek(SeekFrom::Start(8))?;\n+        let mut source = BufReader::with_capacity(8, source.take(5));\n+        source.fill_buf()?;\n+        assert_eq!(source.buffer(), b\"iklmn\");\n+        source.get_mut().set_limit(6);\n+        source.get_mut().get_mut().seek(SeekFrom::Start(1))?; // \"bcdefg\"\n+        let mut source = source.take(10); // \"iklmnbcdef\"\n+\n+        let mut sink = crate::fs::OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(true)\n+            .truncate(true)\n+            .open(&sink_path)?;\n+        sink.write_all(b\"000000\")?;\n+        let mut sink = BufWriter::with_capacity(5, sink);\n+        sink.write_all(b\"wxyz\")?;\n+        assert_eq!(sink.buffer(), b\"wxyz\");\n+\n+        let copied = crate::io::copy(&mut source, &mut sink)?;\n+        assert_eq!(copied, 10);\n+        assert_eq!(sink.buffer().len(), 0);\n+\n+        let mut sink = sink.into_inner()?;\n+        sink.seek(SeekFrom::Start(0))?;\n+        let mut copied = Vec::new();\n+        sink.read_to_end(&mut copied)?;\n+        assert_eq!(&copied, b\"000000wxyziklmnbcdef\");\n+    };\n+\n+    let rm1 = crate::fs::remove_file(source_path);\n+    let rm2 = crate::fs::remove_file(sink_path);\n+\n+    result.and(rm1).and(rm2)\n+}\n+\n+#[bench]\n+fn bench_file_to_file_copy(b: &mut test::Bencher) {\n+    const BYTES: usize = 128 * 1024;\n+    let src_path = temp_dir().join(\"file-copy-bench-src\");\n+    let mut src = crate::fs::OpenOptions::new()\n+        .create(true)\n+        .truncate(true)\n+        .read(true)\n+        .write(true)\n+        .open(src_path)\n+        .unwrap();\n+    src.write(&vec![0u8; BYTES]).unwrap();\n+\n+    let sink_path = temp_dir().join(\"file-copy-bench-sink\");\n+    let mut sink = crate::fs::OpenOptions::new()\n+        .create(true)\n+        .truncate(true)\n+        .write(true)\n+        .open(sink_path)\n+        .unwrap();\n+\n+    b.bytes = BYTES as u64;\n+    b.iter(|| {\n+        src.seek(SeekFrom::Start(0)).unwrap();\n+        sink.seek(SeekFrom::Start(0)).unwrap();\n+        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n+    });\n+}\n+\n+#[bench]\n+fn bench_file_to_socket_copy(b: &mut test::Bencher) {\n+    const BYTES: usize = 128 * 1024;\n+    let src_path = temp_dir().join(\"pipe-copy-bench-src\");\n+    let mut src = OpenOptions::new()\n+        .create(true)\n+        .truncate(true)\n+        .read(true)\n+        .write(true)\n+        .open(src_path)\n+        .unwrap();\n+    src.write(&vec![0u8; BYTES]).unwrap();\n+\n+    let sink_drainer = crate::net::TcpListener::bind(\"localhost:0\").unwrap();\n+    let mut sink = crate::net::TcpStream::connect(sink_drainer.local_addr().unwrap()).unwrap();\n+    let mut sink_drainer = sink_drainer.accept().unwrap().0;\n+\n+    crate::thread::spawn(move || {\n+        let mut sink_buf = vec![0u8; 1024 * 1024];\n+        loop {\n+            sink_drainer.read(&mut sink_buf[..]).unwrap();\n+        }\n+    });\n+\n+    b.bytes = BYTES as u64;\n+    b.iter(|| {\n+        src.seek(SeekFrom::Start(0)).unwrap();\n+        assert_eq!(BYTES as u64, io::copy(&mut src, &mut sink).unwrap());\n+    });\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+#[bench]\n+fn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n+    use super::CopyResult;\n+    use crate::io::ErrorKind;\n+    use crate::process::{ChildStdin, ChildStdout};\n+    use crate::sys_common::FromInner;\n+\n+    let (read_end, write_end) = crate::sys::pipe::anon_pipe().unwrap();\n+\n+    let mut read_end = ChildStdout::from_inner(read_end);\n+    let write_end = ChildStdin::from_inner(write_end);\n+\n+    let acceptor = crate::net::TcpListener::bind(\"localhost:0\").unwrap();\n+    let mut remote_end = crate::net::TcpStream::connect(acceptor.local_addr().unwrap()).unwrap();\n+\n+    let local_end = crate::sync::Arc::new(acceptor.accept().unwrap().0);\n+\n+    // the data flow in this benchmark:\n+    //\n+    //                      socket(tx)  local_source\n+    // remote_end (write)  +-------->   (splice to)\n+    //                                  write_end\n+    //                                     +\n+    //                                     |\n+    //                                     | pipe\n+    //                                     v\n+    //                                  read_end\n+    // remote_end (read)   <---------+  (splice to) *\n+    //                      socket(rx)  local_end\n+    //\n+    // * benchmark loop using io::copy\n+\n+    crate::thread::spawn(move || {\n+        let mut sink_buf = vec![0u8; 1024 * 1024];\n+        remote_end.set_nonblocking(true).unwrap();\n+        loop {\n+            match remote_end.write(&mut sink_buf[..]) {\n+                Err(err) if err.kind() == ErrorKind::WouldBlock => {}\n+                Ok(_) => {}\n+                err => {\n+                    err.expect(\"write failed\");\n+                }\n+            };\n+            match remote_end.read(&mut sink_buf[..]) {\n+                Err(err) if err.kind() == ErrorKind::WouldBlock => {}\n+                Ok(_) => {}\n+                err => {\n+                    err.expect(\"read failed\");\n+                }\n+            };\n+        }\n+    });\n+\n+    // check that splice works, otherwise the benchmark would hang\n+    let probe = super::sendfile_splice(\n+        super::SpliceMode::Splice,\n+        local_end.as_raw_fd(),\n+        write_end.as_raw_fd(),\n+        1,\n+    );\n+\n+    match probe {\n+        CopyResult::Ended(Ok(1)) => {\n+            // splice works\n+        }\n+        _ => {\n+            eprintln!(\"splice failed, skipping benchmark\");\n+            return;\n+        }\n+    }\n+\n+    let local_source = local_end.clone();\n+    crate::thread::spawn(move || {\n+        loop {\n+            super::sendfile_splice(\n+                super::SpliceMode::Splice,\n+                local_source.as_raw_fd(),\n+                write_end.as_raw_fd(),\n+                u64::MAX,\n+            );\n+        }\n+    });\n+\n+    const BYTES: usize = 128 * 1024;\n+    b.bytes = BYTES as u64;\n+    b.iter(|| {\n+        assert_eq!(\n+            BYTES as u64,\n+            io::copy(&mut (&mut read_end).take(BYTES as u64), &mut &*local_end).unwrap()\n+        );\n+    });\n+}"}, {"sha": "7609afbdd76aca9a13a10f53ab0e24cce0e15a7d", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e49a9ead550551e879af64ba91a0316da1c422/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=30e49a9ead550551e879af64ba91a0316da1c422", "patch": "@@ -51,6 +51,8 @@ pub mod fd;\n pub mod fs;\n pub mod futex;\n pub mod io;\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub mod kernel_copy;\n #[cfg(target_os = \"l4re\")]\n mod l4re;\n pub mod memchr;"}]}