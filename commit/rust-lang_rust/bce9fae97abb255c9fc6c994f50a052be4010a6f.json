{"sha": "bce9fae97abb255c9fc6c994f50a052be4010a6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZTlmYWU5N2FiYjI1NWM5ZmM2Yzk5NGY1MGEwNTJiZTQwMTBhNmY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-05-02T07:49:00Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-05-02T07:49:00Z"}, "message": "Add 'src/tools/clippy/' from commit 'd2708873ef711ec8ab45df1e984ecf24a96cd369'\n\ngit-subtree-dir: src/tools/clippy\ngit-subtree-mainline: 06c44816c1532e5ff08ad072f581fc068eb60e2e\ngit-subtree-split: d2708873ef711ec8ab45df1e984ecf24a96cd369", "tree": {"sha": "d88048931c569432e321c522d34795966c1c6647", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d88048931c569432e321c522d34795966c1c6647"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bce9fae97abb255c9fc6c994f50a052be4010a6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bce9fae97abb255c9fc6c994f50a052be4010a6f", "html_url": "https://github.com/rust-lang/rust/commit/bce9fae97abb255c9fc6c994f50a052be4010a6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bce9fae97abb255c9fc6c994f50a052be4010a6f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c44816c1532e5ff08ad072f581fc068eb60e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/06c44816c1532e5ff08ad072f581fc068eb60e2e", "html_url": "https://github.com/rust-lang/rust/commit/06c44816c1532e5ff08ad072f581fc068eb60e2e"}, {"sha": "d2708873ef711ec8ab45df1e984ecf24a96cd369", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2708873ef711ec8ab45df1e984ecf24a96cd369", "html_url": "https://github.com/rust-lang/rust/commit/d2708873ef711ec8ab45df1e984ecf24a96cd369"}], "stats": {"total": 114475, "additions": 114475, "deletions": 0}, "files": [{"sha": "2bad3b9c57f0c95f05d5071bd0c45560f55c88a5", "filename": "src/tools/clippy/.cargo/config", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.cargo%2Fconfig?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,6 @@\n+[alias]\n+uitest = \"test --test compile-test\"\n+dev = \"run --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n+\n+[build]\n+rustflags = [\"-Zunstable-options\"]"}, {"sha": "a13173544d80a7e8b3fe5c57e85af494ae31ffc9", "filename": "src/tools/clippy/.editorconfig", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.editorconfig?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,19 @@\n+# EditorConfig helps developers define and maintain consistent\n+# coding styles between different editors and IDEs\n+# editorconfig.org\n+\n+root = true\n+\n+[*]\n+end_of_line = lf\n+charset = utf-8\n+trim_trailing_whitespace = true\n+insert_final_newline = true\n+indent_style = space\n+indent_size = 4\n+\n+[*.md]\n+trim_trailing_whitespace = false\n+\n+[*.yml]\n+indent_size = 2"}, {"sha": "90cf33053c77587326cfec3e29e0f6caa73db1ca", "filename": "src/tools/clippy/.gitattributes", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.gitattributes?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,3 @@\n+* text=auto eol=lf\n+*.rs text eol=lf whitespace=tab-in-indent,trailing-space,tabwidth=4\n+*.fixed linguist-language=Rust"}, {"sha": "15006a07b44f2b1831ea8a685c47aeb75634729f", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,8 @@\n+<!--\n+Hi there! Whether you've come to make a suggestion for a new lint, an improvement to an existing lint or to report a bug or a false positive in Clippy, you've come to the right place.\n+\n+For bug reports and false positives, please include the output of `cargo clippy -V` in the report.\n+\n+Thank you for using Clippy!\n+\n+Write your comment below this line: -->"}, {"sha": "97aa220afea540e16a4a18ff05b67fc030f136c4", "filename": "src/tools/clippy/.github/PULL_REQUEST_TEMPLATE.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2FPULL_REQUEST_TEMPLATE.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2FPULL_REQUEST_TEMPLATE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FPULL_REQUEST_TEMPLATE.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,31 @@\n+Thank you for making Clippy better!\n+\n+We're collecting our changelog from pull request descriptions.\n+If your PR only updates to the latest nightly, you can leave the\n+`changelog` entry as `none`. Otherwise, please write a short comment\n+explaining your change.\n+\n+If your PR fixes an issue, you can add \"fixes #issue_number\" into this\n+PR description. This way the issue will be automatically closed when\n+your PR is merged.\n+\n+If you added a new lint, here's a checklist for things that will be\n+checked during review or continuous integration.\n+\n+- [ ] Followed [lint naming conventions][lint_naming]\n+- [ ] Added passing UI tests (including committed `.stderr` file)\n+- [ ] `cargo test` passes locally\n+- [ ] Executed `cargo dev update_lints`\n+- [ ] Added lint documentation\n+- [ ] Run `cargo dev fmt`\n+\n+[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n+\n+Note that you can skip the above if you are just opening a WIP PR in\n+order to get feedback.\n+\n+Delete this line and everything above before opening your PR.\n+\n+---\n+\n+changelog: none"}, {"sha": "3f425e5b7258d52580b162ba1b6aecac643d8191", "filename": "src/tools/clippy/.github/deploy.sh", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fdeploy.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fdeploy.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fdeploy.sh?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,57 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+echo \"Removing the current docs for master\"\n+rm -rf out/master/ || exit 0\n+\n+echo \"Making the docs for master\"\n+mkdir out/master/\n+cp util/gh-pages/index.html out/master\n+python3 ./util/export.py out/master/lints.json\n+\n+if [[ -n $TAG_NAME ]]; then\n+  echo \"Save the doc for the current tag ($TAG_NAME) and point stable/ to it\"\n+  cp -r out/master \"out/$TAG_NAME\"\n+  rm -f out/stable\n+  ln -s \"$TAG_NAME\" out/stable\n+fi\n+\n+if [[ $BETA = \"true\" ]]; then\n+  echo \"Update documentation for the beta release\"\n+  cp -r out/master out/beta\n+fi\n+\n+# Generate version index that is shown as root index page\n+cp util/gh-pages/versions.html out/index.html\n+\n+echo \"Making the versions.json file\"\n+python3 ./util/versions.py out\n+\n+cd out\n+# Now let's go have some fun with the cloned repo\n+git config user.name \"GHA CI\"\n+git config user.email \"gha@ci.invalid\"\n+\n+if git diff --exit-code --quiet; then\n+  echo \"No changes to the output on this push; exiting.\"\n+  exit 0\n+fi\n+\n+if [[ -n $TAG_NAME ]]; then\n+  # Add the new dir\n+  git add \"$TAG_NAME\"\n+  # Update the symlink\n+  git add stable\n+  # Update versions file\n+  git add versions.json\n+  git commit -m \"Add documentation for ${TAG_NAME} release: ${SHA}\"\n+elif [[ $BETA = \"true\" ]]; then\n+  git add beta\n+  git commit -m \"Automatic deploy to GitHub Pages (beta): ${SHA}\"\n+else\n+  git add .\n+  git commit -m \"Automatic deploy to GitHub Pages: ${SHA}\"\n+fi\n+\n+git push \"$SSH_REPO\" \"$TARGET_BRANCH\""}, {"sha": "a2e87f5eb3745837c4a71cc2dad41a3473677bd3", "filename": "src/tools/clippy/.github/driver.sh", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fdriver.sh?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,29 @@\n+#!/bin/bash\n+\n+set -ex\n+\n+# Check sysroot handling\n+sysroot=$(./target/debug/clippy-driver --print sysroot)\n+test \"$sysroot\" = \"$(rustc --print sysroot)\"\n+\n+if [[ ${OS} == \"Windows\" ]]; then\n+  desired_sysroot=C:/tmp\n+else\n+  desired_sysroot=/tmp\n+fi\n+sysroot=$(./target/debug/clippy-driver --sysroot $desired_sysroot --print sysroot)\n+test \"$sysroot\" = $desired_sysroot\n+\n+sysroot=$(SYSROOT=$desired_sysroot ./target/debug/clippy-driver --print sysroot)\n+test \"$sysroot\" = $desired_sysroot\n+\n+# Make sure this isn't set - clippy-driver should cope without it\n+unset CARGO_MANIFEST_DIR\n+\n+# Run a lint and make sure it produces the expected output. It's also expected to exit with code 1\n+# FIXME: How to match the clippy invocation in compile-test.rs?\n+./target/debug/clippy-driver -Dwarnings -Aunused -Zui-testing --emit metadata --crate-type bin tests/ui/cstring.rs 2> cstring.stderr && exit 1\n+sed -e \"s,tests/ui,\\$DIR,\" -e \"/= help/d\" cstring.stderr > normalized.stderr\n+diff normalized.stderr tests/ui/cstring.stderr\n+\n+# TODO: CLIPPY_CONF_DIR / CARGO_MANIFEST_DIR"}, {"sha": "8edf0c23860aa0915c860b9d0a3a255bf0f864eb", "filename": "src/tools/clippy/.github/workflows/clippy.yml", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,99 @@\n+name: Clippy Test\n+\n+on:\n+  push:\n+    # Ignore bors branches, since they are covered by `clippy_bors.yml`\n+    branches-ignore:\n+      - auto\n+      - try\n+    # Don't run Clippy tests, when only textfiles were modified\n+    paths-ignore:\n+    - 'COPYRIGHT'\n+    - 'LICENSE-*'\n+    - '**.md'\n+    - '**.txt'\n+  pull_request:\n+    # Don't run Clippy tests, when only textfiles were modified\n+    paths-ignore:\n+    - 'COPYRIGHT'\n+    - 'LICENSE-*'\n+    - '**.md'\n+    - '**.txt'\n+\n+env:\n+  RUST_BACKTRACE: 1\n+  CARGO_TARGET_DIR: '${{ github.workspace }}/target'\n+  NO_FMT_TEST: 1\n+\n+jobs:\n+  base:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    # Setup\n+    - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+      with:\n+        github_token: \"${{ secrets.github_token }}\"\n+\n+    - name: rust-toolchain\n+      uses: actions-rs/toolchain@v1.0.3\n+      with:\n+        toolchain: nightly\n+        target: x86_64-unknown-linux-gnu\n+        profile: minimal\n+\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+\n+    - name: Run cargo update\n+      run: cargo update\n+\n+    - name: Cache cargo dir\n+      uses: actions/cache@v1\n+      with:\n+        path: ~/.cargo\n+        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n+        restore-keys: |\n+          ${{ runner.os }}-x86_64-unknown-linux-gnu\n+\n+    - name: Master Toolchain Setup\n+      run: bash setup-toolchain.sh\n+\n+    # Run\n+    - name: Set LD_LIBRARY_PATH (Linux)\n+      run: |\n+        SYSROOT=$(rustc --print sysroot)\n+        echo \"::set-env name=LD_LIBRARY_PATH::${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\"\n+\n+    - name: Build\n+      run: cargo build --features deny-warnings\n+\n+    - name: Test\n+      run: cargo test --features deny-warnings\n+\n+    - name: Test clippy_lints\n+      run: cargo test --features deny-warnings\n+      working-directory: clippy_lints\n+\n+    - name: Test rustc_tools_util\n+      run: cargo test --features deny-warnings\n+      working-directory: rustc_tools_util\n+\n+    - name: Test clippy_dev\n+      run: cargo test --features deny-warnings\n+      working-directory: clippy_dev\n+\n+    - name: Test cargo-clippy\n+      run: ../target/debug/cargo-clippy\n+      working-directory: clippy_workspace_tests\n+\n+    - name: Test clippy-driver\n+      run: bash .github/driver.sh\n+      env:\n+        OS: ${{ runner.os }}\n+\n+    # Cleanup\n+    - name: Run cargo-cache --autoclean\n+      run: |\n+        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n+        cargo cache"}, {"sha": "6675a1029bbc8ad2cf7b86adbc6fc65c672530c2", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,329 @@\n+name: Clippy Test (bors)\n+\n+on:\n+  push:\n+    branches:\n+      - auto\n+      - try\n+\n+env:\n+  RUST_BACKTRACE: 1\n+  CARGO_TARGET_DIR: '${{ github.workspace }}/target'\n+  NO_FMT_TEST: 1\n+\n+jobs:\n+  changelog:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+      with:\n+        github_token: \"${{ secrets.github_token }}\"\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+      with:\n+        ref: ${{ github.ref }}\n+\n+    # Run\n+    - name: Check Changelog\n+      run: |\n+        MESSAGE=$(git log --format=%B -n 1)\n+        PR=$(echo \"$MESSAGE\" | grep -o \"#[0-9]*\" | head -1 | sed -e 's/^#//')\n+        output=$(curl -H \"Authorization: token ${{ secrets.GITHUB_TOKEN }}\" -s \"https://api.github.com/repos/rust-lang/rust-clippy/pulls/$PR\" | \\\n+          python -c \"import sys, json; print(json.load(sys.stdin)['body'])\" | \\\n+          grep \"^changelog: \" | \\\n+          sed \"s/changelog: //g\")\n+        if [[ -z \"$output\" ]]; then\n+          echo \"ERROR: PR body must contain 'changelog: ...'\"\n+          exit 1\n+        elif [[ \"$output\" = \"none\" ]]; then\n+          echo \"WARNING: changelog is 'none'\"\n+        fi\n+      env:\n+        PYTHONIOENCODING: 'utf-8'\n+  base:\n+    needs: changelog\n+    strategy:\n+      matrix:\n+        os: [ubuntu-latest, windows-latest, macos-latest]\n+        host: [x86_64-unknown-linux-gnu, i686-unknown-linux-gnu, x86_64-apple-darwin, x86_64-pc-windows-msvc]\n+        exclude:\n+        - os: ubuntu-latest\n+          host: x86_64-apple-darwin\n+        - os: ubuntu-latest\n+          host: x86_64-pc-windows-msvc\n+        - os: macos-latest\n+          host: x86_64-unknown-linux-gnu\n+        - os: macos-latest\n+          host: i686-unknown-linux-gnu\n+        - os: macos-latest\n+          host: x86_64-pc-windows-msvc\n+        - os: windows-latest\n+          host: x86_64-unknown-linux-gnu\n+        - os: windows-latest\n+          host: i686-unknown-linux-gnu\n+        - os: windows-latest\n+          host: x86_64-apple-darwin\n+\n+    runs-on: ${{ matrix.os }}\n+\n+    steps:\n+    # Setup\n+    - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+      with:\n+        github_token: \"${{ secrets.github_token }}\"\n+\n+    - name: Install dependencies (Linux-i686)\n+      run: |\n+        sudo dpkg --add-architecture i386\n+        sudo apt-get update\n+        sudo apt-get install gcc-multilib libssl-dev:i386 libgit2-dev:i386\n+      if: matrix.host == 'i686-unknown-linux-gnu'\n+\n+    - name: rust-toolchain\n+      uses: actions-rs/toolchain@v1.0.3\n+      with:\n+        toolchain: nightly\n+        target: ${{ matrix.host }}\n+        profile: minimal\n+\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+\n+    - name: Run cargo update\n+      run: cargo update\n+\n+    - name: Cache cargo dir\n+      uses: actions/cache@v1\n+      with:\n+        path: ~/.cargo\n+        key: ${{ runner.os }}-${{ matrix.host }}-${{ hashFiles('Cargo.lock') }}\n+        restore-keys: |\n+          ${{ runner.os }}-${{ matrix.host }}\n+\n+    - name: Master Toolchain Setup\n+      run: bash setup-toolchain.sh\n+      env:\n+        HOST_TOOLCHAIN: ${{ matrix.host }}\n+      shell: bash\n+\n+    # Run\n+    - name: Set LD_LIBRARY_PATH (Linux)\n+      if: runner.os == 'Linux'\n+      run: |\n+        SYSROOT=$(rustc --print sysroot)\n+        echo \"::set-env name=LD_LIBRARY_PATH::${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\"\n+    - name: Link rustc dylib (MacOS)\n+      if: runner.os == 'macOS'\n+      run: |\n+        SYSROOT=$(rustc --print sysroot)\n+        sudo mkdir -p /usr/local/lib\n+        sudo find \"${SYSROOT}/lib\" -maxdepth 1 -name '*dylib' -exec ln -s {} /usr/local/lib \\;\n+    - name: Set PATH (Windows)\n+      if: runner.os == 'Windows'\n+      run: |\n+        $sysroot = rustc --print sysroot\n+        $env:PATH += ';' + $sysroot + '\\bin'\n+        echo \"::set-env name=PATH::$env:PATH\"\n+\n+    - name: Build\n+      run: cargo build --features deny-warnings\n+      shell: bash\n+\n+    - name: Test\n+      run: cargo test --features deny-warnings\n+      shell: bash\n+\n+    - name: Test clippy_lints\n+      run: cargo test --features deny-warnings\n+      shell: bash\n+      working-directory: clippy_lints\n+\n+    - name: Test rustc_tools_util\n+      run: cargo test --features deny-warnings\n+      shell: bash\n+      working-directory: rustc_tools_util\n+\n+    - name: Test clippy_dev\n+      run: cargo test --features deny-warnings\n+      shell: bash\n+      working-directory: clippy_dev\n+\n+    - name: Test cargo-clippy\n+      run: ../target/debug/cargo-clippy\n+      shell: bash\n+      working-directory: clippy_workspace_tests\n+\n+    - name: Test clippy-driver\n+      run: bash .github/driver.sh\n+      shell: bash\n+      env:\n+        OS: ${{ runner.os }}\n+\n+    # Cleanup\n+    - name: Run cargo-cache --autoclean\n+      run: |\n+        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n+        cargo cache\n+      shell: bash\n+  integration_build:\n+    needs: changelog\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    # Setup\n+    - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+      with:\n+        github_token: \"${{ secrets.github_token }}\"\n+\n+    - name: rust-toolchain\n+      uses: actions-rs/toolchain@v1.0.3\n+      with:\n+        toolchain: nightly\n+        target: x86_64-unknown-linux-gnu\n+        profile: minimal\n+\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+\n+    - name: Run cargo update\n+      run: cargo update\n+\n+    - name: Cache cargo dir\n+      uses: actions/cache@v1\n+      with:\n+        path: ~/.cargo\n+        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n+        restore-keys: |\n+          ${{ runner.os }}-x86_64-unknown-linux-gnu\n+\n+    - name: Master Toolchain Setup\n+      run: bash setup-toolchain.sh\n+\n+    # Run\n+    - name: Build Integration Test\n+      run: cargo test --test integration --features integration --no-run\n+\n+    # Upload\n+    - name: Extract Binaries\n+      run: |\n+        DIR=$CARGO_TARGET_DIR/debug\n+        rm $DIR/deps/integration-*.d\n+        mv $DIR/deps/integration-* $DIR/integration\n+        find $DIR ! -executable -o -type d ! -path $DIR | xargs rm -rf\n+        rm -rf $CARGO_TARGET_DIR/release\n+\n+    - name: Upload Binaries\n+      uses: actions/upload-artifact@v1\n+      with:\n+        name: target\n+        path: target\n+\n+    # Cleanup\n+    - name: Run cargo-cache --autoclean\n+      run: |\n+        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n+        cargo cache\n+  integration:\n+    needs: integration_build\n+    strategy:\n+      fail-fast: false\n+      max-parallel: 6\n+      matrix:\n+        integration:\n+        - 'rust-lang/cargo'\n+        - 'rust-lang/rls'\n+        - 'rust-lang/chalk'\n+        - 'rust-lang/rustfmt'\n+        - 'Marwes/combine'\n+        - 'Geal/nom'\n+        - 'rust-lang/stdarch'\n+        - 'serde-rs/serde'\n+        - 'chronotope/chrono'\n+        - 'hyperium/hyper'\n+        - 'rust-random/rand'\n+        - 'rust-lang/futures-rs'\n+        - 'rust-itertools/itertools'\n+        - 'rust-lang-nursery/failure'\n+        - 'rust-lang/log'\n+\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    # Setup\n+    - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+      with:\n+        github_token: \"${{ secrets.github_token }}\"\n+\n+    - name: rust-toolchain\n+      uses: actions-rs/toolchain@v1.0.3\n+      with:\n+        toolchain: nightly\n+        target: x86_64-unknown-linux-gnu\n+        profile: minimal\n+\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+\n+    - name: Run cargo update\n+      run: cargo update\n+\n+    - name: Cache cargo dir\n+      uses: actions/cache@v1\n+      with:\n+        path: ~/.cargo\n+        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n+        restore-keys: |\n+          ${{ runner.os }}-x86_64-unknown-linux-gnu\n+\n+    - name: Master Toolchain Setup\n+      run: bash setup-toolchain.sh\n+\n+    # Download\n+    - name: Download target dir\n+      uses: actions/download-artifact@v1\n+      with:\n+        name: target\n+        path: target\n+\n+    - name: Make Binaries Executable\n+      run: chmod +x $CARGO_TARGET_DIR/debug/*\n+\n+    # Run\n+    - name: Test ${{ matrix.integration }}\n+      run: $CARGO_TARGET_DIR/debug/integration\n+      env:\n+        INTEGRATION: ${{ matrix.integration }}\n+        RUSTUP_TOOLCHAIN: master\n+\n+    # Cleanup\n+    - name: Run cargo-cache --autoclean\n+      run: |\n+        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n+        cargo cache\n+\n+  # These jobs doesn't actually test anything, but they're only used to tell\n+  # bors the build completed, as there is no practical way to detect when a\n+  # workflow is successful listening to webhooks only.\n+  #\n+  # ALL THE PREVIOUS JOBS NEED TO BE ADDED TO THE `needs` SECTION OF THIS JOB!\n+\n+  end-success:\n+    name: bors test finished\n+    if: github.event.pusher.name == 'bors' && success()\n+    runs-on: ubuntu-latest\n+    needs: [base, integration]\n+\n+    steps:\n+      - name: Mark the job as successful\n+        run: exit 0\n+\n+  end-failure:\n+    name: bors test finished\n+    if: github.event.pusher.name == 'bors' && (failure() || cancelled())\n+    runs-on: ubuntu-latest\n+    needs: [base, integration]\n+\n+    steps:\n+      - name: Mark the job as a failure\n+        run: exit 1"}, {"sha": "ec3b43c2f43bc950ee5d70a1a102161a9ecd8c7b", "filename": "src/tools/clippy/.github/workflows/clippy_dev.yml", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,74 @@\n+name: Clippy Dev Test\n+\n+on:\n+  push:\n+    branches:\n+      - auto\n+      - try\n+  pull_request:\n+    # Only run on paths, that get checked by the clippy_dev tool\n+    paths:\n+    - 'CHANGELOG.md'\n+    - 'README.md'\n+    - '**.stderr'\n+    - '**.rs'\n+\n+env:\n+  RUST_BACKTRACE: 1\n+\n+jobs:\n+  clippy_dev:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    # Setup\n+    - name: rust-toolchain\n+      uses: actions-rs/toolchain@v1.0.3\n+      with:\n+        toolchain: nightly\n+        target: x86_64-unknown-linux-gnu\n+        profile: minimal\n+        components: rustfmt\n+\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+\n+    # Run\n+    - name: Build\n+      run: cargo build --features deny-warnings\n+      working-directory: clippy_dev\n+\n+    - name: Test limit_stderr_length\n+      run: cargo dev limit_stderr_length\n+\n+    - name: Test update_lints\n+      run: cargo dev update_lints --check\n+\n+    - name: Test fmt\n+      run: cargo dev fmt --check\n+\n+  # These jobs doesn't actually test anything, but they're only used to tell\n+  # bors the build completed, as there is no practical way to detect when a\n+  # workflow is successful listening to webhooks only.\n+  #\n+  # ALL THE PREVIOUS JOBS NEED TO BE ADDED TO THE `needs` SECTION OF THIS JOB!\n+\n+  end-success:\n+    name: bors dev test finished\n+    if: github.event.pusher.name == 'bors' && success()\n+    runs-on: ubuntu-latest\n+    needs: [clippy_dev]\n+\n+    steps:\n+      - name: Mark the job as successful\n+        run: exit 0\n+\n+  end-failure:\n+    name: bors dev test finished\n+    if: github.event.pusher.name == 'bors' && (failure() || cancelled())\n+    runs-on: ubuntu-latest\n+    needs: [clippy_dev]\n+\n+    steps:\n+      - name: Mark the job as a failure\n+        run: exit 1"}, {"sha": "f542f9b02c17b3d16903329df6d9d2fb2348462a", "filename": "src/tools/clippy/.github/workflows/deploy.yml", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fdeploy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fdeploy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fdeploy.yml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,51 @@\n+name: Deploy\n+\n+on:\n+  push:\n+    branches:\n+      - master\n+      - beta\n+    tags:\n+      - rust-1.**\n+\n+env:\n+  TARGET_BRANCH: 'gh-pages'\n+  SHA: '${{ github.sha }}'\n+  SSH_REPO: 'git@github.com:${{ github.repository }}.git'\n+\n+jobs:\n+  deploy:\n+    runs-on: ubuntu-latest\n+    if: github.repository == 'rust-lang/rust-clippy'\n+\n+    steps:\n+    # Setup\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+      with:\n+        ref: ${{ env.TARGET_BRANCH }}\n+        path: 'out'\n+\n+    # Run\n+    - name: Set tag name\n+      if: startswith(github.ref, 'refs/tags/')\n+      run: |\n+        TAG=$(basename ${{ github.ref }})\n+        echo \"::set-env name=TAG_NAME::$TAG\"\n+    - name: Set beta to true\n+      if: github.ref == 'refs/heads/beta'\n+      run: echo \"::set-env name=BETA::true\"\n+\n+    - name: Use scripts and templates from master branch\n+      run: |\n+        git fetch --no-tags --prune --depth=1 origin master\n+        git checkout origin/master -- .github/deploy.sh util/gh-pages/ util/*.py\n+\n+    - name: Deploy\n+      run: |\n+        eval \"$(ssh-agent -s)\"\n+        ssh-add - <<< \"${{ secrets.DEPLOY_KEY }}\"\n+        bash .github/deploy.sh"}, {"sha": "cc175e8bf247f89b721b98fc5bd6e18f1dbd11c4", "filename": "src/tools/clippy/.github/workflows/remark.yml", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,55 @@\n+name: Remark\n+\n+on:\n+  push:\n+    branches:\n+      - auto\n+      - try\n+  pull_request:\n+    paths:\n+    - '**.md'\n+\n+jobs:\n+  remark:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    # Setup\n+    - name: Checkout\n+      uses: actions/checkout@v2.0.0\n+\n+    - name: Setup Node.js\n+      uses: actions/setup-node@v1.1.0\n+\n+    - name: Install remark\n+      run: npm install remark-cli remark-lint remark-lint-maximum-line-length remark-preset-lint-recommended\n+\n+    # Run\n+    - name: Check *.md files\n+      run: git ls-files -z '*.md' | xargs -0 -n 1 -I {} ./node_modules/.bin/remark {} -u lint -f > /dev/null\n+\n+  # These jobs doesn't actually test anything, but they're only used to tell\n+  # bors the build completed, as there is no practical way to detect when a\n+  # workflow is successful listening to webhooks only.\n+  #\n+  # ALL THE PREVIOUS JOBS NEED TO BE ADDED TO THE `needs` SECTION OF THIS JOB!\n+\n+  end-success:\n+    name: bors remark test finished\n+    if: github.event.pusher.name == 'bors' && success()\n+    runs-on: ubuntu-latest\n+    needs: [remark]\n+\n+    steps:\n+      - name: Mark the job as successful\n+        run: exit 0\n+\n+  end-failure:\n+    name: bors remark test finished\n+    if: github.event.pusher.name == 'bors' && (failure() || cancelled())\n+    runs-on: ubuntu-latest\n+    needs: [remark]\n+\n+    steps:\n+      - name: Mark the job as a failure\n+        run: exit 1"}, {"sha": "adf5e8feddf4c507efc627259e53cb146bdb45ea", "filename": "src/tools/clippy/.gitignore", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.gitignore?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,37 @@\n+# Used by CI to be able to push:\n+/.github/deploy_key\n+out\n+\n+# Compiled files\n+*.o\n+*.d\n+*.so\n+*.rlib\n+*.dll\n+*.pyc\n+*.rmeta\n+\n+# Executables\n+*.exe\n+\n+# Generated by Cargo\n+*Cargo.lock\n+/target\n+/clippy_lints/target\n+/clippy_workspace_tests/target\n+/clippy_dev/target\n+/rustc_tools_util/target\n+\n+# Generated by dogfood\n+/target_recur/\n+\n+# gh pages docs\n+util/gh-pages/lints.json\n+\n+# rustfmt backups\n+*.rs.bk\n+\n+helper.txt\n+*.iml\n+.vscode\n+.idea"}, {"sha": "0ede7ac75cb6f98d73d8a4efa0cc2cad09b55fa3", "filename": "src/tools/clippy/.remarkrc", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.remarkrc", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2F.remarkrc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.remarkrc?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,12 @@\n+{\n+  \"plugins\": [\n+    \"remark-preset-lint-recommended\",\n+    [\"remark-lint-list-item-indent\", false],\n+    [\"remark-lint-no-literal-urls\", false],\n+    [\"remark-lint-no-shortcut-reference-link\", false],\n+    [\"remark-lint-maximum-line-length\", 120]\n+  ],\n+  \"settings\": {\n+    \"commonmark\": true\n+  }\n+}"}, {"sha": "575773580c0be25ee59792a3e2d2e9a3aa0ebc6b", "filename": "src/tools/clippy/CHANGELOG.md", "status": "added", "additions": 1657, "deletions": 0, "changes": 1657, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,1657 @@\n+# Change Log\n+\n+All notable changes to this project will be documented in this file.\n+See [Changelog Update](doc/changelog_update.md) if you want to update this\n+document.\n+\n+## Unreleased / In Rust Nightly\n+\n+[891e1a8...master](https://github.com/rust-lang/rust-clippy/compare/891e1a8...master)\n+\n+## Rust 1.44\n+\n+Current beta, release 2020-06-04\n+\n+[204bb9b...891e1a8](https://github.com/rust-lang/rust-clippy/compare/204bb9b...891e1a8)\n+\n+### New lints\n+\n+* [`explicit_deref_methods`] [#5226](https://github.com/rust-lang/rust-clippy/pull/5226)\n+* [`implicit_saturating_sub`] [#5427](https://github.com/rust-lang/rust-clippy/pull/5427)\n+* [`macro_use_imports`] [#5230](https://github.com/rust-lang/rust-clippy/pull/5230)\n+* [`verbose_file_reads`] [#5272](https://github.com/rust-lang/rust-clippy/pull/5272)\n+* [`future_not_send`] [#5423](https://github.com/rust-lang/rust-clippy/pull/5423)\n+* [`redundant_pub_crate`] [#5319](https://github.com/rust-lang/rust-clippy/pull/5319)\n+* [`large_const_arrays`] [#5248](https://github.com/rust-lang/rust-clippy/pull/5248)\n+* [`result_map_or_into_option`] [#5415](https://github.com/rust-lang/rust-clippy/pull/5415)\n+* [`redundant_allocation`] [#5349](https://github.com/rust-lang/rust-clippy/pull/5349)\n+* [`fn_address_comparisons`] [#5294](https://github.com/rust-lang/rust-clippy/pull/5294)\n+* [`vtable_address_comparisons`] [#5294](https://github.com/rust-lang/rust-clippy/pull/5294)\n+\n+\n+### Moves and Deprecations\n+\n+* Deprecate [`replace_consts`] lint [#5380](https://github.com/rust-lang/rust-clippy/pull/5380)\n+* Move [`cognitive_complexity`] to nursery [#5428](https://github.com/rust-lang/rust-clippy/pull/5428)\n+* Move [`useless_transmute`] to nursery [#5364](https://github.com/rust-lang/rust-clippy/pull/5364)\n+* Downgrade [`inefficient_to_string`] to pedantic [#5412](https://github.com/rust-lang/rust-clippy/pull/5412)\n+* Downgrade [`option_option`] to pedantic [#5401](https://github.com/rust-lang/rust-clippy/pull/5401)\n+* Downgrade [`unreadable_literal`] to pedantic [#5419](https://github.com/rust-lang/rust-clippy/pull/5419)\n+* Downgrade [`let_unit_value`] to pedantic [#5409](https://github.com/rust-lang/rust-clippy/pull/5409)\n+* Downgrade [`trivially_copy_pass_by_ref`] to pedantic [#5410](https://github.com/rust-lang/rust-clippy/pull/5410)\n+* Downgrade [`implicit_hasher`] to pedantic [#5411](https://github.com/rust-lang/rust-clippy/pull/5411)\n+\n+### Enhancements\n+\n+* On _nightly_ you can now use `cargo clippy --fix -Z unstable-options` to\n+  auto-fix lints that support this [#5363](https://github.com/rust-lang/rust-clippy/pull/5363)\n+* Make [`redundant_clone`] also trigger on cases where the cloned value is not\n+  consumed. [#5304](https://github.com/rust-lang/rust-clippy/pull/5304)\n+* Expand [`integer_arithmetic`] to also disallow bit-shifting [#5430](https://github.com/rust-lang/rust-clippy/pull/5430)\n+* [`option_as_ref_deref`] now detects more deref cases [#5425](https://github.com/rust-lang/rust-clippy/pull/5425)\n+* [`large_enum_variant`] now report the sizes of the largest and second-largest variants [#5466](https://github.com/rust-lang/rust-clippy/pull/5466)\n+* [`bool_comparison`] now also checks for inequality comparisons that can be\n+  written more concisely [#5365](https://github.com/rust-lang/rust-clippy/pull/5365)\n+* Expand [`clone_on_copy`] to work in method call arguments as well [#5441](https://github.com/rust-lang/rust-clippy/pull/5441)\n+* [`redundant_pattern_matching`] now also handles `while let` [#5483](https://github.com/rust-lang/rust-clippy/pull/5483)\n+* [`integer_arithmetic`] now also lints references of integers [#5329](https://github.com/rust-lang/rust-clippy/pull/5329)\n+* Expand [`float_cmp_const`] to also work on arrays [#5345](https://github.com/rust-lang/rust-clippy/pull/5345)\n+* Trigger [`map_flatten`] when map is called on an `Option` [#5473](https://github.com/rust-lang/rust-clippy/pull/5473)\n+\n+### False Positive Fixes\n+\n+* [`many_single_char_names`] [#5468](https://github.com/rust-lang/rust-clippy/pull/5468)\n+* [`should_implement_trait`] [#5437](https://github.com/rust-lang/rust-clippy/pull/5437)\n+* [`unused_self`] [#5387](https://github.com/rust-lang/rust-clippy/pull/5387)\n+* [`redundant_clone`] [#5453](https://github.com/rust-lang/rust-clippy/pull/5453)\n+* [`precedence`] [#5445](https://github.com/rust-lang/rust-clippy/pull/5445)\n+* [`suspicious_op_assign_impl`] [#5424](https://github.com/rust-lang/rust-clippy/pull/5424)\n+* [`needless_lifetimes`] [#5293](https://github.com/rust-lang/rust-clippy/pull/5293)\n+* [`redundant_pattern`] [#5287](https://github.com/rust-lang/rust-clippy/pull/5287)\n+* [`inconsistent_digit_grouping`] [#5451](https://github.com/rust-lang/rust-clippy/pull/5451)\n+\n+\n+### Suggestion Improvements\n+\n+* Improved [`question_mark`] lint suggestion so that it doesn't add redundant `as_ref()` [#5481](https://github.com/rust-lang/rust-clippy/pull/5481)\n+* Improve the suggested placeholder in [`option_map_unit_fn`] [#5292](https://github.com/rust-lang/rust-clippy/pull/5292)\n+* Improve suggestion for [`match_single_binding`] when triggered inside a closure [#5350](https://github.com/rust-lang/rust-clippy/pull/5350)\n+\n+### ICE Fixes\n+\n+* Handle the unstable `trivial_bounds` feature [#5296](https://github.com/rust-lang/rust-clippy/pull/5296)\n+* `shadow_*` lints [#5297](https://github.com/rust-lang/rust-clippy/pull/5297)\n+\n+### Documentation\n+\n+* Fix documentation generation for configurable lints [#5353](https://github.com/rust-lang/rust-clippy/pull/5353)\n+* Update documentation for [`new_ret_no_self`] [#5448](https://github.com/rust-lang/rust-clippy/pull/5448)\n+* The documentation for [`option_option`] now suggest using a tri-state enum [#5403](https://github.com/rust-lang/rust-clippy/pull/5403)\n+* Fix bit mask example in [`verbose_bit_mask`] documentation [#5454](https://github.com/rust-lang/rust-clippy/pull/5454)\n+* [`wildcard_imports`] documentation now mentions that `use ...::prelude::*` is\n+  not linted [#5312](https://github.com/rust-lang/rust-clippy/pull/5312)\n+\n+## Rust 1.43\n+\n+Current stable, released 2020-04-23\n+\n+[4ee1206...204bb9b](https://github.com/rust-lang/rust-clippy/compare/4ee1206...204bb9b)\n+\n+### New lints\n+\n+* [`imprecise_flops`] [#4897](https://github.com/rust-lang/rust-clippy/pull/4897)\n+* [`suboptimal_flops`] [#4897](https://github.com/rust-lang/rust-clippy/pull/4897)\n+* [`wildcard_imports`] [#5029](https://github.com/rust-lang/rust-clippy/pull/5029)\n+* [`single_component_path_imports`] [#5058](https://github.com/rust-lang/rust-clippy/pull/5058)\n+* [`match_single_binding`] [#5061](https://github.com/rust-lang/rust-clippy/pull/5061)\n+* [`let_underscore_lock`] [#5101](https://github.com/rust-lang/rust-clippy/pull/5101)\n+* [`struct_excessive_bools`] [#5125](https://github.com/rust-lang/rust-clippy/pull/5125)\n+* [`fn_params_excessive_bools`] [#5125](https://github.com/rust-lang/rust-clippy/pull/5125)\n+* [`option_env_unwrap`] [#5148](https://github.com/rust-lang/rust-clippy/pull/5148)\n+* [`lossy_float_literal`] [#5202](https://github.com/rust-lang/rust-clippy/pull/5202)\n+* [`rest_pat_in_fully_bound_structs`] [#5258](https://github.com/rust-lang/rust-clippy/pull/5258)\n+\n+### Moves and Deprecations\n+\n+* Move [`unneeded_field_pattern`] to pedantic group [#5200](https://github.com/rust-lang/rust-clippy/pull/5200)\n+\n+### Enhancements\n+\n+* Make [`missing_errors_doc`] lint also trigger on `async` functions\n+  [#5181](https://github.com/rust-lang/rust-clippy/pull/5181)\n+* Add more constants to [`approx_constant`] [#5193](https://github.com/rust-lang/rust-clippy/pull/5193)\n+* Extend [`question_mark`] lint [#5266](https://github.com/rust-lang/rust-clippy/pull/5266)\n+\n+### False Positive Fixes\n+\n+* [`use_debug`] [#5047](https://github.com/rust-lang/rust-clippy/pull/5047)\n+* [`unnecessary_unwrap`] [#5132](https://github.com/rust-lang/rust-clippy/pull/5132)\n+* [`zero_prefixed_literal`] [#5170](https://github.com/rust-lang/rust-clippy/pull/5170)\n+* [`missing_const_for_fn`] [#5216](https://github.com/rust-lang/rust-clippy/pull/5216)\n+\n+### Suggestion Improvements\n+\n+* Improve suggestion when blocks of code are suggested [#5134](https://github.com/rust-lang/rust-clippy/pull/5134)\n+\n+### ICE Fixes\n+\n+* `misc_early` lints [#5129](https://github.com/rust-lang/rust-clippy/pull/5129)\n+* [`missing_errors_doc`] [#5213](https://github.com/rust-lang/rust-clippy/pull/5213)\n+* Fix ICE when evaluating `usize`s [#5256](https://github.com/rust-lang/rust-clippy/pull/5256)\n+\n+### Documentation\n+\n+* Improve documentation of [`iter_nth_zero`]\n+* Add documentation pages for stable releases [#5171](https://github.com/rust-lang/rust-clippy/pull/5171)\n+\n+### Others\n+\n+* Clippy now completely runs on GitHub Actions [#5190](https://github.com/rust-lang/rust-clippy/pull/5190)\n+\n+\n+## Rust 1.42\n+\n+Released 2020-03-12\n+\n+[69f99e7...4ee1206](https://github.com/rust-lang/rust-clippy/compare/69f99e7...4ee1206)\n+\n+### New lints\n+\n+* [`filetype_is_file`] [#4543](https://github.com/rust-lang/rust-clippy/pull/4543)\n+* [`let_underscore_must_use`] [#4823](https://github.com/rust-lang/rust-clippy/pull/4823)\n+* [`modulo_arithmetic`] [#4867](https://github.com/rust-lang/rust-clippy/pull/4867)\n+* [`mem_replace_with_default`] [#4881](https://github.com/rust-lang/rust-clippy/pull/4881)\n+* [`mutable_key_type`] [#4885](https://github.com/rust-lang/rust-clippy/pull/4885)\n+* [`option_as_ref_deref`] [#4945](https://github.com/rust-lang/rust-clippy/pull/4945)\n+* [`wildcard_in_or_patterns`] [#4960](https://github.com/rust-lang/rust-clippy/pull/4960)\n+* [`iter_nth_zero`] [#4966](https://github.com/rust-lang/rust-clippy/pull/4966)\n+* [`invalid_atomic_ordering`] [#4999](https://github.com/rust-lang/rust-clippy/pull/4999)\n+* [`skip_while_next`] [#5067](https://github.com/rust-lang/rust-clippy/pull/5067)\n+\n+### Moves and Deprecations\n+\n+* Move [`transmute_float_to_int`] from nursery to complexity group\n+  [#5015](https://github.com/rust-lang/rust-clippy/pull/5015)\n+* Move [`range_plus_one`] to pedantic group [#5057](https://github.com/rust-lang/rust-clippy/pull/5057)\n+* Move [`debug_assert_with_mut_call`] to nursery group [#5106](https://github.com/rust-lang/rust-clippy/pull/5106)\n+* Deprecate [`unused_label`] [#4930](https://github.com/rust-lang/rust-clippy/pull/4930)\n+\n+### Enhancements\n+\n+* Lint vectored IO in [`unused_io_amount`] [#5027](https://github.com/rust-lang/rust-clippy/pull/5027)\n+* Make [`vec_box`] configurable by adding a size threshold [#5081](https://github.com/rust-lang/rust-clippy/pull/5081)\n+* Also lint constants in [`cmp_nan`] [#4910](https://github.com/rust-lang/rust-clippy/pull/4910)\n+* Fix false negative in [`expect_fun_call`] [#4915](https://github.com/rust-lang/rust-clippy/pull/4915)\n+* Fix false negative in [`redundant_clone`] [#5017](https://github.com/rust-lang/rust-clippy/pull/5017)\n+\n+### False Positive Fixes\n+\n+* [`map_clone`] [#4937](https://github.com/rust-lang/rust-clippy/pull/4937)\n+* [`replace_consts`] [#4977](https://github.com/rust-lang/rust-clippy/pull/4977)\n+* [`let_and_return`] [#5008](https://github.com/rust-lang/rust-clippy/pull/5008)\n+* [`eq_op`] [#5079](https://github.com/rust-lang/rust-clippy/pull/5079)\n+* [`possible_missing_comma`] [#5083](https://github.com/rust-lang/rust-clippy/pull/5083)\n+* [`debug_assert_with_mut_call`] [#5106](https://github.com/rust-lang/rust-clippy/pull/5106)\n+* Don't trigger [`let_underscore_must_use`] in external macros\n+  [#5082](https://github.com/rust-lang/rust-clippy/pull/5082)\n+* Don't trigger [`empty_loop`] in `no_std` crates [#5086](https://github.com/rust-lang/rust-clippy/pull/5086)\n+\n+### Suggestion Improvements\n+\n+* [`option_map_unwrap_or`] [#4634](https://github.com/rust-lang/rust-clippy/pull/4634)\n+* [`wildcard_enum_match_arm`] [#4934](https://github.com/rust-lang/rust-clippy/pull/4934)\n+* [`cognitive_complexity`] [#4935](https://github.com/rust-lang/rust-clippy/pull/4935)\n+* [`decimal_literal_representation`] [#4956](https://github.com/rust-lang/rust-clippy/pull/4956)\n+* [`unknown_clippy_lints`] [#4963](https://github.com/rust-lang/rust-clippy/pull/4963)\n+* [`explicit_into_iter_loop`] [#4978](https://github.com/rust-lang/rust-clippy/pull/4978)\n+* [`useless_attribute`] [#5022](https://github.com/rust-lang/rust-clippy/pull/5022)\n+* [`if_let_some_result`] [#5032](https://github.com/rust-lang/rust-clippy/pull/5032)\n+\n+### ICE fixes\n+\n+* [`unsound_collection_transmute`] [#4975](https://github.com/rust-lang/rust-clippy/pull/4975)\n+\n+### Documentation\n+\n+* Improve documentation of [`empty_enum`], [`replace_consts`], [`redundant_clone`], and [`iterator_step_by_zero`]\n+\n+\n+## Rust 1.41\n+\n+Released 2020-01-30\n+\n+[c8e3cfb...69f99e7](https://github.com/rust-lang/rust-clippy/compare/c8e3cfb...69f99e7)\n+\n+* New Lints:\n+  * [`exit`] [#4697](https://github.com/rust-lang/rust-clippy/pull/4697)\n+  * [`to_digit_is_some`] [#4801](https://github.com/rust-lang/rust-clippy/pull/4801)\n+  * [`tabs_in_doc_comments`] [#4806](https://github.com/rust-lang/rust-clippy/pull/4806)\n+  * [`large_stack_arrays`] [#4807](https://github.com/rust-lang/rust-clippy/pull/4807)\n+  * [`same_functions_in_if_condition`] [#4814](https://github.com/rust-lang/rust-clippy/pull/4814)\n+  * [`zst_offset`] [#4816](https://github.com/rust-lang/rust-clippy/pull/4816)\n+  * [`as_conversions`] [#4821](https://github.com/rust-lang/rust-clippy/pull/4821)\n+  * [`missing_errors_doc`] [#4884](https://github.com/rust-lang/rust-clippy/pull/4884)\n+  * [`transmute_float_to_int`] [#4889](https://github.com/rust-lang/rust-clippy/pull/4889)\n+* Remove plugin interface, see\n+  [Inside Rust Blog](https://blog.rust-lang.org/inside-rust/2019/11/04/Clippy-removes-plugin-interface.html) for\n+  details [#4714](https://github.com/rust-lang/rust-clippy/pull/4714)\n+* Move [`use_self`] to nursery group [#4863](https://github.com/rust-lang/rust-clippy/pull/4863)\n+* Deprecate [`into_iter_on_array`] [#4788](https://github.com/rust-lang/rust-clippy/pull/4788)\n+* Expand [`string_lit_as_bytes`] to also trigger when literal has escapes\n+  [#4808](https://github.com/rust-lang/rust-clippy/pull/4808)\n+* Fix false positive in `comparison_chain` [#4842](https://github.com/rust-lang/rust-clippy/pull/4842)\n+* Fix false positive in `while_immutable_condition` [#4730](https://github.com/rust-lang/rust-clippy/pull/4730)\n+* Fix false positive in `explicit_counter_loop` [#4803](https://github.com/rust-lang/rust-clippy/pull/4803)\n+* Fix false positive in `must_use_candidate` [#4794](https://github.com/rust-lang/rust-clippy/pull/4794)\n+* Fix false positive in `print_with_newline` and `write_with_newline`\n+  [#4769](https://github.com/rust-lang/rust-clippy/pull/4769)\n+* Fix false positive in `derive_hash_xor_eq` [#4766](https://github.com/rust-lang/rust-clippy/pull/4766)\n+* Fix false positive in `missing_inline_in_public_items` [#4870](https://github.com/rust-lang/rust-clippy/pull/4870)\n+* Fix false positive in `string_add` [#4880](https://github.com/rust-lang/rust-clippy/pull/4880)\n+* Fix false positive in `float_arithmetic` [#4851](https://github.com/rust-lang/rust-clippy/pull/4851)\n+* Fix false positive in `cast_sign_loss` [#4883](https://github.com/rust-lang/rust-clippy/pull/4883)\n+* Fix false positive in `manual_swap` [#4877](https://github.com/rust-lang/rust-clippy/pull/4877)\n+* Fix ICEs occurring while checking some block expressions [#4772](https://github.com/rust-lang/rust-clippy/pull/4772)\n+* Fix ICE in `use_self` [#4776](https://github.com/rust-lang/rust-clippy/pull/4776)\n+* Fix ICEs related to `const_generics` [#4780](https://github.com/rust-lang/rust-clippy/pull/4780)\n+* Display help when running `clippy-driver` without arguments, instead of ICEing\n+  [#4810](https://github.com/rust-lang/rust-clippy/pull/4810)\n+* Clippy has its own ICE message now [#4588](https://github.com/rust-lang/rust-clippy/pull/4588)\n+* Show deprecated lints in the documentation again [#4757](https://github.com/rust-lang/rust-clippy/pull/4757)\n+* Improve Documentation by adding positive examples to some lints\n+  [#4832](https://github.com/rust-lang/rust-clippy/pull/4832)\n+\n+## Rust 1.40\n+\n+Released 2019-12-19\n+\n+[4e7e71b...c8e3cfb](https://github.com/rust-lang/rust-clippy/compare/4e7e71b...c8e3cfb)\n+\n+* New Lints:\n+  * [`unneeded_wildcard_pattern`] [#4537](https://github.com/rust-lang/rust-clippy/pull/4537)\n+  * [`needless_doctest_main`] [#4603](https://github.com/rust-lang/rust-clippy/pull/4603)\n+  * [`suspicious_unary_op_formatting`] [#4615](https://github.com/rust-lang/rust-clippy/pull/4615)\n+  * [`debug_assert_with_mut_call`] [#4680](https://github.com/rust-lang/rust-clippy/pull/4680)\n+  * [`unused_self`] [#4619](https://github.com/rust-lang/rust-clippy/pull/4619)\n+  * [`inefficient_to_string`] [#4683](https://github.com/rust-lang/rust-clippy/pull/4683)\n+  * [`must_use_unit`] [#4560](https://github.com/rust-lang/rust-clippy/pull/4560)\n+  * [`must_use_candidate`] [#4560](https://github.com/rust-lang/rust-clippy/pull/4560)\n+  * [`double_must_use`] [#4560](https://github.com/rust-lang/rust-clippy/pull/4560)\n+  * [`comparison_chain`] [#4569](https://github.com/rust-lang/rust-clippy/pull/4569)\n+  * [`unsound_collection_transmute`] [#4592](https://github.com/rust-lang/rust-clippy/pull/4592)\n+  * [`panic`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n+  * [`unreachable`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n+  * [`todo`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n+  * [`option_expect_used`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n+  * [`result_expect_used`] [#4657](https://github.com/rust-lang/rust-clippy/pull/4657)\n+* Move `redundant_clone` to perf group [#4509](https://github.com/rust-lang/rust-clippy/pull/4509)\n+* Move `manual_mul_add` to nursery group [#4736](https://github.com/rust-lang/rust-clippy/pull/4736)\n+* Expand `unit_cmp` to also work with `assert_eq!`, `debug_assert_eq!`, `assert_ne!` and `debug_assert_ne!` [#4613](https://github.com/rust-lang/rust-clippy/pull/4613)\n+* Expand `integer_arithmetic` to also detect mutating arithmetic like `+=` [#4585](https://github.com/rust-lang/rust-clippy/pull/4585)\n+* Fix false positive in `nonminimal_bool` [#4568](https://github.com/rust-lang/rust-clippy/pull/4568)\n+* Fix false positive in `missing_safety_doc` [#4611](https://github.com/rust-lang/rust-clippy/pull/4611)\n+* Fix false positive in `cast_sign_loss` [#4614](https://github.com/rust-lang/rust-clippy/pull/4614)\n+* Fix false positive in `redundant_clone` [#4509](https://github.com/rust-lang/rust-clippy/pull/4509)\n+* Fix false positive in `try_err` [#4721](https://github.com/rust-lang/rust-clippy/pull/4721)\n+* Fix false positive in `toplevel_ref_arg` [#4570](https://github.com/rust-lang/rust-clippy/pull/4570)\n+* Fix false positive in `multiple_inherent_impl` [#4593](https://github.com/rust-lang/rust-clippy/pull/4593)\n+* Improve more suggestions and tests in preparation for the unstable `cargo fix --clippy` [#4575](https://github.com/rust-lang/rust-clippy/pull/4575)\n+* Improve suggestion for `zero_ptr` [#4599](https://github.com/rust-lang/rust-clippy/pull/4599)\n+* Improve suggestion for `explicit_counter_loop` [#4691](https://github.com/rust-lang/rust-clippy/pull/4691)\n+* Improve suggestion for `mul_add` [#4602](https://github.com/rust-lang/rust-clippy/pull/4602)\n+* Improve suggestion for `assertions_on_constants` [#4635](https://github.com/rust-lang/rust-clippy/pull/4635)\n+* Fix ICE in `use_self` [#4671](https://github.com/rust-lang/rust-clippy/pull/4671)\n+* Fix ICE when encountering const casts [#4590](https://github.com/rust-lang/rust-clippy/pull/4590)\n+\n+## Rust 1.39\n+\n+Released 2019-11-07\n+\n+[3aea860...4e7e71b](https://github.com/rust-lang/rust-clippy/compare/3aea860...4e7e71b)\n+\n+* New Lints:\n+  * [`uninit_assumed_init`] [#4479](https://github.com/rust-lang/rust-clippy/pull/4479)\n+  * [`flat_map_identity`] [#4231](https://github.com/rust-lang/rust-clippy/pull/4231)\n+  * [`missing_safety_doc`] [#4535](https://github.com/rust-lang/rust-clippy/pull/4535)\n+  * [`mem_replace_with_uninit`] [#4511](https://github.com/rust-lang/rust-clippy/pull/4511)\n+  * [`suspicious_map`] [#4394](https://github.com/rust-lang/rust-clippy/pull/4394)\n+  * [`option_and_then_some`] [#4386](https://github.com/rust-lang/rust-clippy/pull/4386)\n+  * [`manual_saturating_arithmetic`] [#4498](https://github.com/rust-lang/rust-clippy/pull/4498)\n+* Deprecate `unused_collect` lint. This is fully covered by rustc's `#[must_use]` on `collect` [#4348](https://github.com/rust-lang/rust-clippy/pull/4348)\n+* Move `type_repetition_in_bounds` to pedantic group [#4403](https://github.com/rust-lang/rust-clippy/pull/4403)\n+* Move `cast_lossless` to pedantic group [#4539](https://github.com/rust-lang/rust-clippy/pull/4539)\n+* `temporary_cstring_as_ptr` now catches more cases [#4425](https://github.com/rust-lang/rust-clippy/pull/4425)\n+* `use_self` now works in constructors, too [#4525](https://github.com/rust-lang/rust-clippy/pull/4525)\n+* `cargo_common_metadata` now checks for license files [#4518](https://github.com/rust-lang/rust-clippy/pull/4518)\n+* `cognitive_complexity` now includes the measured complexity in the warning message [#4469](https://github.com/rust-lang/rust-clippy/pull/4469)\n+* Fix false positives in `block_in_if_*` lints [#4458](https://github.com/rust-lang/rust-clippy/pull/4458)\n+* Fix false positive in `cast_lossless` [#4473](https://github.com/rust-lang/rust-clippy/pull/4473)\n+* Fix false positive in `clone_on_copy` [#4411](https://github.com/rust-lang/rust-clippy/pull/4411)\n+* Fix false positive in `deref_addrof` [#4487](https://github.com/rust-lang/rust-clippy/pull/4487)\n+* Fix false positive in `too_many_lines` [#4490](https://github.com/rust-lang/rust-clippy/pull/4490)\n+* Fix false positive in `new_ret_no_self` [#4365](https://github.com/rust-lang/rust-clippy/pull/4365)\n+* Fix false positive in `manual_swap` [#4478](https://github.com/rust-lang/rust-clippy/pull/4478)\n+* Fix false positive in `missing_const_for_fn` [#4450](https://github.com/rust-lang/rust-clippy/pull/4450)\n+* Fix false positive in `extra_unused_lifetimes` [#4477](https://github.com/rust-lang/rust-clippy/pull/4477)\n+* Fix false positive in `inherent_to_string` [#4460](https://github.com/rust-lang/rust-clippy/pull/4460)\n+* Fix false positive in `map_entry` [#4495](https://github.com/rust-lang/rust-clippy/pull/4495)\n+* Fix false positive in `unused_unit` [#4445](https://github.com/rust-lang/rust-clippy/pull/4445)\n+* Fix false positive in `redundant_pattern` [#4489](https://github.com/rust-lang/rust-clippy/pull/4489)\n+* Fix false positive in `wrong_self_convention` [#4369](https://github.com/rust-lang/rust-clippy/pull/4369)\n+* Improve various suggestions and tests in preparation for the unstable `cargo fix --clippy` [#4558](https://github.com/rust-lang/rust-clippy/pull/4558)\n+* Improve suggestions for `redundant_pattern_matching` [#4352](https://github.com/rust-lang/rust-clippy/pull/4352)\n+* Improve suggestions for `explicit_write` [#4544](https://github.com/rust-lang/rust-clippy/pull/4544)\n+* Improve suggestion for `or_fun_call` [#4522](https://github.com/rust-lang/rust-clippy/pull/4522)\n+* Improve suggestion for `match_as_ref` [#4446](https://github.com/rust-lang/rust-clippy/pull/4446)\n+* Improve suggestion for `unnecessary_fold_span` [#4382](https://github.com/rust-lang/rust-clippy/pull/4382)\n+* Add suggestions for `unseparated_literal_suffix` [#4401](https://github.com/rust-lang/rust-clippy/pull/4401)\n+* Add suggestions for `char_lit_as_u8` [#4418](https://github.com/rust-lang/rust-clippy/pull/4418)\n+\n+## Rust 1.38\n+\n+Released 2019-09-26\n+\n+[e3cb40e...3aea860](https://github.com/rust-lang/rust-clippy/compare/e3cb40e...3aea860)\n+\n+* New Lints:\n+  * [`main_recursion`] [#4203](https://github.com/rust-lang/rust-clippy/pull/4203)\n+  * [`inherent_to_string`] [#4259](https://github.com/rust-lang/rust-clippy/pull/4259)\n+  * [`inherent_to_string_shadow_display`] [#4259](https://github.com/rust-lang/rust-clippy/pull/4259)\n+  * [`type_repetition_in_bounds`] [#3766](https://github.com/rust-lang/rust-clippy/pull/3766)\n+  * [`try_err`] [#4222](https://github.com/rust-lang/rust-clippy/pull/4222)\n+* Move `{unnnecessary,panicking}_unwrap` out of nursery [#4307](https://github.com/rust-lang/rust-clippy/pull/4307)\n+* Extend the `use_self` lint to suggest uses of `Self::Variant` [#4308](https://github.com/rust-lang/rust-clippy/pull/4308)\n+* Improve suggestion for needless return [#4262](https://github.com/rust-lang/rust-clippy/pull/4262)\n+* Add auto-fixable suggestion for `let_unit` [#4337](https://github.com/rust-lang/rust-clippy/pull/4337)\n+* Fix false positive in `pub_enum_variant_names` and `enum_variant_names` [#4345](https://github.com/rust-lang/rust-clippy/pull/4345)\n+* Fix false positive in `cast_ptr_alignment` [#4257](https://github.com/rust-lang/rust-clippy/pull/4257)\n+* Fix false positive in `string_lit_as_bytes` [#4233](https://github.com/rust-lang/rust-clippy/pull/4233)\n+* Fix false positive in `needless_lifetimes` [#4266](https://github.com/rust-lang/rust-clippy/pull/4266)\n+* Fix false positive in `float_cmp` [#4275](https://github.com/rust-lang/rust-clippy/pull/4275)\n+* Fix false positives in `needless_return` [#4274](https://github.com/rust-lang/rust-clippy/pull/4274)\n+* Fix false negative in `match_same_arms` [#4246](https://github.com/rust-lang/rust-clippy/pull/4246)\n+* Fix incorrect suggestion for `needless_bool` [#4335](https://github.com/rust-lang/rust-clippy/pull/4335)\n+* Improve suggestion for `cast_ptr_alignment` [#4257](https://github.com/rust-lang/rust-clippy/pull/4257)\n+* Improve suggestion for `single_char_literal` [#4361](https://github.com/rust-lang/rust-clippy/pull/4361)\n+* Improve suggestion for `len_zero` [#4314](https://github.com/rust-lang/rust-clippy/pull/4314)\n+* Fix ICE in `implicit_hasher` [#4268](https://github.com/rust-lang/rust-clippy/pull/4268)\n+* Fix allow bug in `trivially_copy_pass_by_ref` [#4250](https://github.com/rust-lang/rust-clippy/pull/4250)\n+\n+## Rust 1.37\n+\n+Released 2019-08-15\n+\n+[082cfa7...e3cb40e](https://github.com/rust-lang/rust-clippy/compare/082cfa7...e3cb40e)\n+\n+* New Lints:\n+  * [`checked_conversions`] [#4088](https://github.com/rust-lang/rust-clippy/pull/4088)\n+  * [`get_last_with_len`] [#3832](https://github.com/rust-lang/rust-clippy/pull/3832)\n+  * [`integer_division`] [#4195](https://github.com/rust-lang/rust-clippy/pull/4195)\n+* Renamed Lint: `const_static_lifetime` is now called [`redundant_static_lifetimes`].\n+  The lint now covers statics in addition to consts [#4162](https://github.com/rust-lang/rust-clippy/pull/4162)\n+* [`match_same_arms`] now warns for all identical arms, instead of only the first one [#4102](https://github.com/rust-lang/rust-clippy/pull/4102)\n+* [`needless_return`] now works with void functions [#4220](https://github.com/rust-lang/rust-clippy/pull/4220)\n+* Fix false positive in [`redundant_closure`] [#4190](https://github.com/rust-lang/rust-clippy/pull/4190)\n+* Fix false positive in [`useless_attribute`] [#4107](https://github.com/rust-lang/rust-clippy/pull/4107)\n+* Fix incorrect suggestion for [`float_cmp`] [#4214](https://github.com/rust-lang/rust-clippy/pull/4214)\n+* Add suggestions for [`print_with_newline`] and [`write_with_newline`] [#4136](https://github.com/rust-lang/rust-clippy/pull/4136)\n+* Improve suggestions for [`option_map_unwrap_or_else`] and [`result_map_unwrap_or_else`] [#4164](https://github.com/rust-lang/rust-clippy/pull/4164)\n+* Improve suggestions for [`non_ascii_literal`] [#4119](https://github.com/rust-lang/rust-clippy/pull/4119)\n+* Improve diagnostics for [`let_and_return`] [#4137](https://github.com/rust-lang/rust-clippy/pull/4137)\n+* Improve diagnostics for [`trivially_copy_pass_by_ref`] [#4071](https://github.com/rust-lang/rust-clippy/pull/4071)\n+* Add macro check for [`unreadable_literal`] [#4099](https://github.com/rust-lang/rust-clippy/pull/4099)\n+\n+## Rust 1.36\n+\n+Released 2019-07-04\n+\n+[eb9f9b1...082cfa7](https://github.com/rust-lang/rust-clippy/compare/eb9f9b1...082cfa7)\n+\n+* New lints: [`find_map`], [`filter_map_next`] [#4039](https://github.com/rust-lang/rust-clippy/pull/4039)\n+* New lint: [`path_buf_push_overwrite`] [#3954](https://github.com/rust-lang/rust-clippy/pull/3954)\n+* Move `path_buf_push_overwrite` to the nursery [#4013](https://github.com/rust-lang/rust-clippy/pull/4013)\n+* Split [`redundant_closure`] into [`redundant_closure`] and [`redundant_closure_for_method_calls`] [#4110](https://github.com/rust-lang/rust-clippy/pull/4101)\n+* Allow allowing of [`toplevel_ref_arg`] lint [#4007](https://github.com/rust-lang/rust-clippy/pull/4007)\n+* Fix false negative in [`or_fun_call`] pertaining to nested constructors [#4084](https://github.com/rust-lang/rust-clippy/pull/4084)\n+* Fix false positive in [`or_fun_call`] pertaining to enum variant constructors [#4018](https://github.com/rust-lang/rust-clippy/pull/4018)\n+* Fix false positive in [`useless_let_if_seq`] pertaining to interior mutability [#4035](https://github.com/rust-lang/rust-clippy/pull/4035)\n+* Fix false positive in [`redundant_closure`] pertaining to non-function types [#4008](https://github.com/rust-lang/rust-clippy/pull/4008)\n+* Fix false positive in [`let_and_return`] pertaining to attributes on `let`s [#4024](https://github.com/rust-lang/rust-clippy/pull/4024)\n+* Fix false positive in [`module_name_repetitions`] lint pertaining to attributes [#4006](https://github.com/rust-lang/rust-clippy/pull/4006)\n+* Fix false positive on [`assertions_on_constants`] pertaining to `debug_assert!` [#3989](https://github.com/rust-lang/rust-clippy/pull/3989)\n+* Improve suggestion in [`map_clone`] to suggest `.copied()` where applicable  [#3970](https://github.com/rust-lang/rust-clippy/pull/3970) [#4043](https://github.com/rust-lang/rust-clippy/pull/4043)\n+* Improve suggestion for [`search_is_some`] [#4049](https://github.com/rust-lang/rust-clippy/pull/4049)\n+* Improve suggestion applicability for [`naive_bytecount`] [#3984](https://github.com/rust-lang/rust-clippy/pull/3984)\n+* Improve suggestion applicability for [`while_let_loop`] [#3975](https://github.com/rust-lang/rust-clippy/pull/3975)\n+* Improve diagnostics for [`too_many_arguments`] [#4053](https://github.com/rust-lang/rust-clippy/pull/4053)\n+* Improve diagnostics for [`cast_lossless`] [#4021](https://github.com/rust-lang/rust-clippy/pull/4021)\n+* Deal with macro checks in desugarings better [#4082](https://github.com/rust-lang/rust-clippy/pull/4082)\n+* Add macro check for [`unnecessary_cast`]  [#4026](https://github.com/rust-lang/rust-clippy/pull/4026)\n+* Remove [`approx_constant`]'s documentation's \"Known problems\" section. [#4027](https://github.com/rust-lang/rust-clippy/pull/4027)\n+* Fix ICE in [`suspicious_else_formatting`] [#3960](https://github.com/rust-lang/rust-clippy/pull/3960)\n+* Fix ICE in [`decimal_literal_representation`] [#3931](https://github.com/rust-lang/rust-clippy/pull/3931)\n+\n+\n+## Rust 1.35\n+\n+Released 2019-05-20\n+\n+[1fac380..37f5c1e](https://github.com/rust-lang/rust-clippy/compare/1fac380...37f5c1e)\n+\n+* New lint: [`drop_bounds`] to detect `T: Drop` bounds\n+* Split [`redundant_closure`] into [`redundant_closure`] and [`redundant_closure_for_method_calls`] [#4110](https://github.com/rust-lang/rust-clippy/pull/4101)\n+* Rename `cyclomatic_complexity` to [`cognitive_complexity`], start work on making lint more practical for Rust code\n+* Move [`get_unwrap`] to the restriction category\n+* Improve suggestions for [`iter_cloned_collect`]\n+* Improve suggestions for [`cast_lossless`] to suggest suffixed literals\n+* Fix false positives in [`print_with_newline`] and [`write_with_newline`] pertaining to raw strings\n+* Fix false positive in [`needless_range_loop`] pertaining to structs without a `.iter()`\n+* Fix false positive in [`bool_comparison`] pertaining to non-bool types\n+* Fix false positive in [`redundant_closure`] pertaining to differences in borrows\n+* Fix false positive in [`option_map_unwrap_or`] on non-copy types\n+* Fix false positives in [`missing_const_for_fn`] pertaining to macros and trait method impls\n+* Fix false positive in [`needless_pass_by_value`] pertaining to procedural macros\n+* Fix false positive in [`needless_continue`] pertaining to loop labels\n+* Fix false positive for [`boxed_local`] pertaining to arguments moved into closures\n+* Fix false positive for [`use_self`] in nested functions\n+* Fix suggestion for [`expect_fun_call`] (https://github.com/rust-lang/rust-clippy/pull/3846)\n+* Fix suggestion for [`explicit_counter_loop`] to deal with parenthesizing range variables\n+* Fix suggestion for [`single_char_pattern`] to correctly escape single quotes\n+* Avoid triggering [`redundant_closure`] in macros\n+* ICE fixes: [#3805](https://github.com/rust-lang/rust-clippy/pull/3805), [#3772](https://github.com/rust-lang/rust-clippy/pull/3772), [#3741](https://github.com/rust-lang/rust-clippy/pull/3741)\n+\n+## Rust 1.34\n+\n+Released 2019-04-10\n+\n+[1b89724...1fac380](https://github.com/rust-lang/rust-clippy/compare/1b89724...1fac380)\n+\n+* New lint: [`assertions_on_constants`] to detect for example `assert!(true)`\n+* New lint: [`dbg_macro`] to detect uses of the `dbg!` macro\n+* New lint: [`missing_const_for_fn`] that can suggest functions to be made `const`\n+* New lint: [`too_many_lines`] to detect functions with excessive LOC. It can be\n+  configured using the `too-many-lines-threshold` configuration.\n+* New lint: [`wildcard_enum_match_arm`] to check for wildcard enum matches using `_`\n+* Expand `redundant_closure` to also work for methods (not only functions)\n+* Fix ICEs in `vec_box`, `needless_pass_by_value` and `implicit_hasher`\n+* Fix false positive in `cast_sign_loss`\n+* Fix false positive in `integer_arithmetic`\n+* Fix false positive in `unit_arg`\n+* Fix false positives in `implicit_return`\n+* Add suggestion to `explicit_write`\n+* Improve suggestions for `question_mark` lint\n+* Fix incorrect suggestion for `cast_lossless`\n+* Fix incorrect suggestion for `expect_fun_call`\n+* Fix incorrect suggestion for `needless_bool`\n+* Fix incorrect suggestion for `needless_range_loop`\n+* Fix incorrect suggestion for `use_self`\n+* Fix incorrect suggestion for `while_let_on_iterator`\n+* Clippy is now slightly easier to invoke in non-cargo contexts. See\n+  [#3665][pull3665] for more details.\n+* We now have [improved documentation][adding_lints] on how to add new lints\n+\n+## Rust 1.33\n+\n+Released 2019-02-26\n+\n+[b2601be...1b89724](https://github.com/rust-lang/rust-clippy/compare/b2601be...1b89724)\n+\n+* New lints: [`implicit_return`], [`vec_box`], [`cast_ref_to_mut`]\n+* The `rust-clippy` repository is now part of the `rust-lang` org.\n+* Rename `stutter` to `module_name_repetitions`\n+* Merge `new_without_default_derive` into `new_without_default` lint\n+* Move `large_digit_groups` from `style` group to `pedantic`\n+* Expand `bool_comparison` to check for `<`, `<=`, `>`, `>=`, and `!=`\n+  comparisons against booleans\n+* Expand `no_effect` to detect writes to constants such as `A_CONST.field = 2`\n+* Expand `redundant_clone` to work on struct fields\n+* Expand `suspicious_else_formatting` to detect `if .. {..} {..}`\n+* Expand `use_self` to work on tuple structs and also in local macros\n+* Fix ICE in `result_map_unit_fn` and `option_map_unit_fn`\n+* Fix false positives in `implicit_return`\n+* Fix false positives in `use_self`\n+* Fix false negative in `clone_on_copy`\n+* Fix false positive in `doc_markdown`\n+* Fix false positive in `empty_loop`\n+* Fix false positive in `if_same_then_else`\n+* Fix false positive in `infinite_iter`\n+* Fix false positive in `question_mark`\n+* Fix false positive in `useless_asref`\n+* Fix false positive in `wildcard_dependencies`\n+* Fix false positive in `write_with_newline`\n+* Add suggestion to `explicit_write`\n+* Improve suggestions for `question_mark` lint\n+* Fix incorrect suggestion for `get_unwrap`\n+\n+## Rust 1.32\n+\n+Released 2019-01-17\n+\n+[2e26fdc2...b2601be](https://github.com/rust-lang/rust-clippy/compare/2e26fdc2...b2601be)\n+\n+* New lints: [`slow_vector_initialization`], [`mem_discriminant_non_enum`],\n+  [`redundant_clone`], [`wildcard_dependencies`],\n+  [`into_iter_on_ref`], [`into_iter_on_array`], [`deprecated_cfg_attr`],\n+  [`mem_discriminant_non_enum`], [`cargo_common_metadata`]\n+* Add support for `u128` and `i128` to integer related lints\n+* Add float support to `mistyped_literal_suffixes`\n+* Fix false positives in `use_self`\n+* Fix false positives in `missing_comma`\n+* Fix false positives in `new_ret_no_self`\n+* Fix false positives in `possible_missing_comma`\n+* Fix false positive in `integer_arithmetic` in constant items\n+* Fix false positive in `needless_borrow`\n+* Fix false positive in `out_of_bounds_indexing`\n+* Fix false positive in `new_without_default_derive`\n+* Fix false positive in `string_lit_as_bytes`\n+* Fix false negative in `out_of_bounds_indexing`\n+* Fix false negative in `use_self`. It will now also check existential types\n+* Fix incorrect suggestion for `redundant_closure_call`\n+* Fix various suggestions that contained expanded macros\n+* Fix `bool_comparison` triggering 3 times on on on the same code\n+* Expand `trivially_copy_pass_by_ref` to work on trait methods\n+* Improve suggestion for `needless_range_loop`\n+* Move `needless_pass_by_value` from `pedantic` group to `style`\n+\n+## Rust 1.31\n+\n+Released 2018-12-06\n+\n+[125907ad..2e26fdc2](https://github.com/rust-lang/rust-clippy/compare/125907ad..2e26fdc2)\n+\n+* Clippy has been relicensed under a dual MIT / Apache license.\n+  See [#3093](https://github.com/rust-lang/rust-clippy/issues/3093) for more\n+  information.\n+* With Rust 1.31, Clippy is no longer available via crates.io. The recommended\n+  installation method is via `rustup component add clippy`.\n+* New lints: [`redundant_pattern_matching`], [`unnecessary_filter_map`],\n+  [`unused_unit`], [`map_flatten`], [`mem_replace_option_with_none`]\n+* Fix ICE in `if_let_redundant_pattern_matching`\n+* Fix ICE in `needless_pass_by_value` when encountering a generic function\n+  argument with a lifetime parameter\n+* Fix ICE in `needless_range_loop`\n+* Fix ICE in `single_char_pattern` when encountering a constant value\n+* Fix false positive in `assign_op_pattern`\n+* Fix false positive in `boxed_local` on trait implementations\n+* Fix false positive in `cmp_owned`\n+* Fix false positive in `collapsible_if` when conditionals have comments\n+* Fix false positive in `double_parens`\n+* Fix false positive in `excessive_precision`\n+* Fix false positive in `explicit_counter_loop`\n+* Fix false positive in `fn_to_numeric_cast_with_truncation`\n+* Fix false positive in `map_clone`\n+* Fix false positive in `new_ret_no_self`\n+* Fix false positive in `new_without_default` when `new` is unsafe\n+* Fix false positive in `type_complexity` when using extern types\n+* Fix false positive in `useless_format`\n+* Fix false positive in `wrong_self_convention`\n+* Fix incorrect suggestion for `excessive_precision`\n+* Fix incorrect suggestion for `expect_fun_call`\n+* Fix incorrect suggestion for `get_unwrap`\n+* Fix incorrect suggestion for `useless_format`\n+* `fn_to_numeric_cast_with_truncation` lint can be disabled again\n+* Improve suggestions for `manual_memcpy`\n+* Improve help message for `needless_lifetimes`\n+\n+## Rust 1.30\n+\n+Released 2018-10-25\n+\n+[14207503...125907ad](https://github.com/rust-lang/rust-clippy/compare/14207503...125907ad)\n+\n+* Deprecate `assign_ops` lint\n+* New lints: [`mistyped_literal_suffixes`], [`ptr_offset_with_cast`],\n+  [`needless_collect`], [`copy_iterator`]\n+* `cargo clippy -V` now includes the Clippy commit hash of the Rust\n+  Clippy component\n+* Fix ICE in `implicit_hasher`\n+* Fix ICE when encountering `println!(\"{}\" a);`\n+* Fix ICE when encountering a macro call in match statements\n+* Fix false positive in `default_trait_access`\n+* Fix false positive in `trivially_copy_pass_by_ref`\n+* Fix false positive in `similar_names`\n+* Fix false positive in `redundant_field_name`\n+* Fix false positive in `expect_fun_call`\n+* Fix false negative in `identity_conversion`\n+* Fix false negative in `explicit_counter_loop`\n+* Fix `range_plus_one` suggestion and false negative\n+* `print_with_newline` / `write_with_newline`: don't warn about string with several `\\n`s in them\n+* Fix `useless_attribute` to also whitelist `unused_extern_crates`\n+* Fix incorrect suggestion for `single_char_pattern`\n+* Improve suggestion for `identity_conversion` lint\n+* Move `explicit_iter_loop` and `explicit_into_iter_loop` from `style` group to `pedantic`\n+* Move `range_plus_one` and `range_minus_one` from `nursery` group to `complexity`\n+* Move `shadow_unrelated` from `restriction` group to `pedantic`\n+* Move `indexing_slicing` from `pedantic` group to `restriction`\n+\n+## Rust 1.29\n+\n+Released 2018-09-13\n+\n+[v0.0.212...14207503](https://github.com/rust-lang/rust-clippy/compare/v0.0.212...14207503)\n+\n+* :tada: :tada: **Rust 1.29 is the first stable Rust that includes a bundled Clippy** :tada:\n+  :tada:\n+  You can now run `rustup component add clippy-preview` and then `cargo\n+  clippy` to run Clippy. This should put an end to the continuous nightly\n+  upgrades for Clippy users.\n+* Clippy now follows the Rust versioning scheme instead of its own\n+* Fix ICE when encountering a `while let (..) = x.iter()` construct\n+* Fix false positives in `use_self`\n+* Fix false positive in `trivially_copy_pass_by_ref`\n+* Fix false positive in `useless_attribute` lint\n+* Fix false positive in `print_literal`\n+* Fix `use_self` regressions\n+* Improve lint message for `neg_cmp_op_on_partial_ord`\n+* Improve suggestion highlight for `single_char_pattern`\n+* Improve suggestions for various print/write macro lints\n+* Improve website header\n+\n+## 0.0.212 (2018-07-10)\n+* Rustup to *rustc 1.29.0-nightly (e06c87544 2018-07-06)*\n+\n+## 0.0.211\n+* Rustup to *rustc 1.28.0-nightly (e3bf634e0 2018-06-28)*\n+\n+## 0.0.210\n+* Rustup to *rustc 1.28.0-nightly (01cc982e9 2018-06-24)*\n+\n+## 0.0.209\n+* Rustup to *rustc 1.28.0-nightly (523097979 2018-06-18)*\n+\n+## 0.0.208\n+* Rustup to *rustc 1.28.0-nightly (86a8f1a63 2018-06-17)*\n+\n+## 0.0.207\n+* Rustup to *rustc 1.28.0-nightly (2a0062974 2018-06-09)*\n+\n+## 0.0.206\n+* Rustup to *rustc 1.28.0-nightly (5bf68db6e 2018-05-28)*\n+\n+## 0.0.205\n+* Rustup to *rustc 1.28.0-nightly (990d8aa74 2018-05-25)*\n+* Rename `unused_lifetimes` to `extra_unused_lifetimes` because of naming conflict with new rustc lint\n+\n+## 0.0.204\n+* Rustup to *rustc 1.28.0-nightly (71e87be38 2018-05-22)*\n+\n+## 0.0.203\n+* Rustup to *rustc 1.28.0-nightly (a3085756e 2018-05-19)*\n+* Clippy attributes are now of the form `clippy::cyclomatic_complexity` instead of `clippy(cyclomatic_complexity)`\n+\n+## 0.0.202\n+* Rustup to *rustc 1.28.0-nightly (952f344cd 2018-05-18)*\n+\n+## 0.0.201\n+* Rustup to *rustc 1.27.0-nightly (2f2a11dfc 2018-05-16)*\n+\n+## 0.0.200\n+* Rustup to *rustc 1.27.0-nightly (9fae15374 2018-05-13)*\n+\n+## 0.0.199\n+* Rustup to *rustc 1.27.0-nightly (ff2ac35db 2018-05-12)*\n+\n+## 0.0.198\n+* Rustup to *rustc 1.27.0-nightly (acd3871ba 2018-05-10)*\n+\n+## 0.0.197\n+* Rustup to *rustc 1.27.0-nightly (428ea5f6b 2018-05-06)*\n+\n+## 0.0.196\n+* Rustup to *rustc 1.27.0-nightly (e82261dfb 2018-05-03)*\n+\n+## 0.0.195\n+* Rustup to *rustc 1.27.0-nightly (ac3c2288f 2018-04-18)*\n+\n+## 0.0.194\n+* Rustup to *rustc 1.27.0-nightly (bd40cbbe1 2018-04-14)*\n+* New lints: [`cast_ptr_alignment`], [`transmute_ptr_to_ptr`], [`write_literal`], [`write_with_newline`], [`writeln_empty_string`]\n+\n+## 0.0.193\n+* Rustup to *rustc 1.27.0-nightly (eeea94c11 2018-04-06)*\n+\n+## 0.0.192\n+* Rustup to *rustc 1.27.0-nightly (fb44b4c0e 2018-04-04)*\n+* New lint: [`print_literal`]\n+\n+## 0.0.191\n+* Rustup to *rustc 1.26.0-nightly (ae544ee1c 2018-03-29)*\n+* Lint audit; categorize lints as style, correctness, complexity, pedantic, nursery, restriction.\n+\n+## 0.0.190\n+* Fix a bunch of intermittent cargo bugs\n+\n+## 0.0.189\n+* Rustup to *rustc 1.26.0-nightly (5508b2714 2018-03-18)*\n+\n+## 0.0.188\n+* Rustup to *rustc 1.26.0-nightly (392645394 2018-03-15)*\n+* New lint: [`while_immutable_condition`]\n+\n+## 0.0.187\n+* Rustup to *rustc 1.26.0-nightly (322d7f7b9 2018-02-25)*\n+* New lints: [`redundant_field_names`], [`suspicious_arithmetic_impl`], [`suspicious_op_assign_impl`]\n+\n+## 0.0.186\n+* Rustup to *rustc 1.25.0-nightly (0c6091fbd 2018-02-04)*\n+* Various false positive fixes\n+\n+## 0.0.185\n+* Rustup to *rustc 1.25.0-nightly (56733bc9f 2018-02-01)*\n+* New lint: [`question_mark`]\n+\n+## 0.0.184\n+* Rustup to *rustc 1.25.0-nightly (90eb44a58 2018-01-29)*\n+* New lints: [`double_comparisons`], [`empty_line_after_outer_attr`]\n+\n+## 0.0.183\n+* Rustup to *rustc 1.25.0-nightly (21882aad7 2018-01-28)*\n+* New lint: [`misaligned_transmute`]\n+\n+## 0.0.182\n+* Rustup to *rustc 1.25.0-nightly (a0dcecff9 2018-01-24)*\n+* New lint: [`decimal_literal_representation`]\n+\n+## 0.0.181\n+* Rustup to *rustc 1.25.0-nightly (97520ccb1 2018-01-21)*\n+* New lints: [`else_if_without_else`], [`option_option`], [`unit_arg`], [`unnecessary_fold`]\n+* Removed `unit_expr`\n+* Various false positive fixes for [`needless_pass_by_value`]\n+\n+## 0.0.180\n+* Rustup to *rustc 1.25.0-nightly (3f92e8d89 2018-01-14)*\n+\n+## 0.0.179\n+* Rustup to *rustc 1.25.0-nightly (61452e506 2018-01-09)*\n+\n+## 0.0.178\n+* Rustup to *rustc 1.25.0-nightly (ee220daca 2018-01-07)*\n+\n+## 0.0.177\n+* Rustup to *rustc 1.24.0-nightly (250b49205 2017-12-21)*\n+* New lint: [`match_as_ref`]\n+\n+## 0.0.176\n+* Rustup to *rustc 1.24.0-nightly (0077d128d 2017-12-14)*\n+\n+## 0.0.175\n+* Rustup to *rustc 1.24.0-nightly (bb42071f6 2017-12-01)*\n+\n+## 0.0.174\n+* Rustup to *rustc 1.23.0-nightly (63739ab7b 2017-11-21)*\n+\n+## 0.0.173\n+* Rustup to *rustc 1.23.0-nightly (33374fa9d 2017-11-20)*\n+\n+## 0.0.172\n+* Rustup to *rustc 1.23.0-nightly (d0f8e2913 2017-11-16)*\n+\n+## 0.0.171\n+* Rustup to *rustc 1.23.0-nightly (ff0f5de3b 2017-11-14)*\n+\n+## 0.0.170\n+* Rustup to *rustc 1.23.0-nightly (d6b06c63a 2017-11-09)*\n+\n+## 0.0.169\n+* Rustup to *rustc 1.23.0-nightly (3b82e4c74 2017-11-05)*\n+* New lints: [`just_underscores_and_digits`], [`result_map_unwrap_or_else`], [`transmute_bytes_to_str`]\n+\n+## 0.0.168\n+* Rustup to *rustc 1.23.0-nightly (f0fe716db 2017-10-30)*\n+\n+## 0.0.167\n+* Rustup to *rustc 1.23.0-nightly (90ef3372e 2017-10-29)*\n+* New lints: `const_static_lifetime`, [`erasing_op`], [`fallible_impl_from`], [`println_empty_string`], [`useless_asref`]\n+\n+## 0.0.166\n+* Rustup to *rustc 1.22.0-nightly (b7960878b 2017-10-18)*\n+* New lints: [`explicit_write`], [`identity_conversion`], [`implicit_hasher`], [`invalid_ref`], [`option_map_or_none`],\n+  [`range_minus_one`], [`range_plus_one`], [`transmute_int_to_bool`], [`transmute_int_to_char`],\n+  [`transmute_int_to_float`]\n+\n+## 0.0.165\n+* Rust upgrade to rustc 1.22.0-nightly (0e6f4cf51 2017-09-27)\n+* New lint: [`mut_range_bound`]\n+\n+## 0.0.164\n+* Update to *rustc 1.22.0-nightly (6c476ce46 2017-09-25)*\n+* New lint: [`int_plus_one`]\n+\n+## 0.0.163\n+* Update to *rustc 1.22.0-nightly (14039a42a 2017-09-22)*\n+\n+## 0.0.162\n+* Update to *rustc 1.22.0-nightly (0701b37d9 2017-09-18)*\n+* New lint: [`chars_last_cmp`]\n+* Improved suggestions for [`needless_borrow`], [`ptr_arg`],\n+\n+## 0.0.161\n+* Update to *rustc 1.22.0-nightly (539f2083d 2017-09-13)*\n+\n+## 0.0.160\n+* Update to *rustc 1.22.0-nightly (dd08c3070 2017-09-12)*\n+\n+## 0.0.159\n+* Update to *rustc 1.22.0-nightly (eba374fb2 2017-09-11)*\n+* New lint: [`clone_on_ref_ptr`]\n+\n+## 0.0.158\n+* New lint: [`manual_memcpy`]\n+* [`cast_lossless`] no longer has redundant parentheses in its suggestions\n+* Update to *rustc 1.22.0-nightly (dead08cb3 2017-09-08)*\n+\n+## 0.0.157 - 2017-09-04\n+* Update to *rustc 1.22.0-nightly (981ce7d8d 2017-09-03)*\n+* New lint: `unit_expr`\n+\n+## 0.0.156 - 2017-09-03\n+* Update to *rustc 1.22.0-nightly (744dd6c1d 2017-09-02)*\n+\n+## 0.0.155\n+* Update to *rustc 1.21.0-nightly (c11f689d2 2017-08-29)*\n+* New lint: [`infinite_iter`], [`maybe_infinite_iter`], [`cast_lossless`]\n+\n+## 0.0.154\n+* Update to *rustc 1.21.0-nightly (2c0558f63 2017-08-24)*\n+* Fix [`use_self`] triggering inside derives\n+* Add support for linting an entire workspace with `cargo clippy --all`\n+* New lint: [`naive_bytecount`]\n+\n+## 0.0.153\n+* Update to *rustc 1.21.0-nightly (8c303ed87 2017-08-20)*\n+* New lint: [`use_self`]\n+\n+## 0.0.152\n+* Update to *rustc 1.21.0-nightly (df511d554 2017-08-14)*\n+\n+## 0.0.151\n+* Update to *rustc 1.21.0-nightly (13d94d5fa 2017-08-10)*\n+\n+## 0.0.150\n+* Update to *rustc 1.21.0-nightly (215e0b10e 2017-08-08)*\n+\n+## 0.0.148\n+* Update to *rustc 1.21.0-nightly (37c7d0ebb 2017-07-31)*\n+* New lints: [`unreadable_literal`], [`inconsistent_digit_grouping`], [`large_digit_groups`]\n+\n+## 0.0.147\n+* Update to *rustc 1.21.0-nightly (aac223f4f 2017-07-30)*\n+\n+## 0.0.146\n+* Update to *rustc 1.21.0-nightly (52a330969 2017-07-27)*\n+* Fixes false positives in `inline_always`\n+* Fixes false negatives in `panic_params`\n+\n+## 0.0.145\n+* Update to *rustc 1.20.0-nightly (afe145d22 2017-07-23)*\n+\n+## 0.0.144\n+* Update to *rustc 1.20.0-nightly (086eaa78e 2017-07-15)*\n+\n+## 0.0.143\n+* Update to *rustc 1.20.0-nightly (d84693b93 2017-07-09)*\n+* Fix `cargo clippy` crashing on `dylib` projects\n+* Fix false positives around `nested_while_let` and `never_loop`\n+\n+## 0.0.142\n+* Update to *rustc 1.20.0-nightly (067971139 2017-07-02)*\n+\n+## 0.0.141\n+* Rewrite of the `doc_markdown` lint.\n+* Deprecated [`range_step_by_zero`]\n+* New lint: [`iterator_step_by_zero`]\n+* New lint: [`needless_borrowed_reference`]\n+* Update to *rustc 1.20.0-nightly (69c65d296 2017-06-28)*\n+\n+## 0.0.140 - 2017-06-16\n+* Update to *rustc 1.19.0-nightly (258ae6dd9 2017-06-15)*\n+\n+## 0.0.139 \u2014 2017-06-10\n+* Update to *rustc 1.19.0-nightly (4bf5c99af 2017-06-10)*\n+* Fix bugs with for loop desugaring\n+* Check for [`AsRef`]/[`AsMut`] arguments in [`wrong_self_convention`]\n+\n+## 0.0.138 \u2014 2017-06-05\n+* Update to *rustc 1.19.0-nightly (0418fa9d3 2017-06-04)*\n+\n+## 0.0.137 \u2014 2017-06-05\n+* Update to *rustc 1.19.0-nightly (6684d176c 2017-06-03)*\n+\n+## 0.0.136 \u2014 2017\u201405\u201426\n+* Update to *rustc 1.19.0-nightly (557967766 2017-05-26)*\n+\n+## 0.0.135 \u2014 2017\u201405\u201424\n+* Update to *rustc 1.19.0-nightly (5b13bff52 2017-05-23)*\n+\n+## 0.0.134 \u2014 2017\u201405\u201419\n+* Update to *rustc 1.19.0-nightly (0ed1ec9f9 2017-05-18)*\n+\n+## 0.0.133 \u2014 2017\u201405\u201414\n+* Update to *rustc 1.19.0-nightly (826d8f385 2017-05-13)*\n+\n+## 0.0.132 \u2014 2017\u201405\u201405\n+* Fix various bugs and some ices\n+\n+## 0.0.131 \u2014 2017\u201405\u201404\n+* Update to *rustc 1.19.0-nightly (2d4ed8e0c 2017-05-03)*\n+\n+## 0.0.130 \u2014 2017\u201405\u201403\n+* Update to *rustc 1.19.0-nightly (6a5fc9eec 2017-05-02)*\n+\n+## 0.0.129 \u2014 2017-05-01\n+* Update to *rustc 1.19.0-nightly (06fb4d256 2017-04-30)*\n+\n+## 0.0.128 \u2014 2017-04-28\n+* Update to *rustc 1.18.0-nightly (94e884b63 2017-04-27)*\n+\n+## 0.0.127 \u2014 2017-04-27\n+* Update to *rustc 1.18.0-nightly (036983201 2017-04-26)*\n+* New lint: [`needless_continue`]\n+\n+## 0.0.126 \u2014 2017-04-24\n+* Update to *rustc 1.18.0-nightly (2bd4b5c6d 2017-04-23)*\n+\n+## 0.0.125 \u2014 2017-04-19\n+* Update to *rustc 1.18.0-nightly (9f2abadca 2017-04-18)*\n+\n+## 0.0.124 \u2014 2017-04-16\n+* Update to *rustc 1.18.0-nightly (d5cf1cb64 2017-04-15)*\n+\n+## 0.0.123 \u2014 2017-04-07\n+* Fix various false positives\n+\n+## 0.0.122 \u2014 2017-04-07\n+* Rustup to *rustc 1.18.0-nightly (91ae22a01 2017-04-05)*\n+* New lint: [`op_ref`]\n+\n+## 0.0.121 \u2014 2017-03-21\n+* Rustup to *rustc 1.17.0-nightly (134c4a0f0 2017-03-20)*\n+\n+## 0.0.120 \u2014 2017-03-17\n+* Rustup to *rustc 1.17.0-nightly (0aeb9c129 2017-03-15)*\n+\n+## 0.0.119 \u2014 2017-03-13\n+* Rustup to *rustc 1.17.0-nightly (824c9ebbd 2017-03-12)*\n+\n+## 0.0.118 \u2014 2017-03-05\n+* Rustup to *rustc 1.17.0-nightly (b1e31766d 2017-03-03)*\n+\n+## 0.0.117 \u2014 2017-03-01\n+* Rustup to *rustc 1.17.0-nightly (be760566c 2017-02-28)*\n+\n+## 0.0.116 \u2014 2017-02-28\n+* Fix `cargo clippy` on 64 bit windows systems\n+\n+## 0.0.115 \u2014 2017-02-27\n+* Rustup to *rustc 1.17.0-nightly (60a0edc6c 2017-02-26)*\n+* New lints: [`zero_ptr`], [`never_loop`], [`mut_from_ref`]\n+\n+## 0.0.114 \u2014 2017-02-08\n+* Rustup to *rustc 1.17.0-nightly (c49d10207 2017-02-07)*\n+* Tests are now ui tests (testing the exact output of rustc)\n+\n+## 0.0.113 \u2014 2017-02-04\n+* Rustup to *rustc 1.16.0-nightly (eedaa94e3 2017-02-02)*\n+* New lint: [`large_enum_variant`]\n+* `explicit_into_iter_loop` provides suggestions\n+\n+## 0.0.112 \u2014 2017-01-27\n+* Rustup to *rustc 1.16.0-nightly (df8debf6d 2017-01-25)*\n+\n+## 0.0.111 \u2014 2017-01-21\n+* Rustup to *rustc 1.16.0-nightly (a52da95ce 2017-01-20)*\n+\n+## 0.0.110 \u2014 2017-01-20\n+* Add badges and categories to `Cargo.toml`\n+\n+## 0.0.109 \u2014 2017-01-19\n+* Update to *rustc 1.16.0-nightly (c07a6ae77 2017-01-17)*\n+\n+## 0.0.108 \u2014 2017-01-12\n+* Update to *rustc 1.16.0-nightly (2782e8f8f 2017-01-12)*\n+\n+## 0.0.107 \u2014 2017-01-11\n+* Update regex dependency\n+* Fix FP when matching `&&mut` by `&ref`\n+* Reintroduce `for (_, x) in &mut hash_map` -> `for x in hash_map.values_mut()`\n+* New lints: [`unused_io_amount`], [`forget_ref`], [`short_circuit_statement`]\n+\n+## 0.0.106 \u2014 2017-01-04\n+* Fix FP introduced by rustup in [`wrong_self_convention`]\n+\n+## 0.0.105 \u2014 2017-01-04\n+* Update to *rustc 1.16.0-nightly (468227129 2017-01-03)*\n+* New lints: [`deref_addrof`], [`double_parens`], [`pub_enum_variant_names`]\n+* Fix suggestion in [`new_without_default`]\n+* FP fix in [`absurd_extreme_comparisons`]\n+\n+## 0.0.104 \u2014 2016-12-15\n+* Update to *rustc 1.15.0-nightly (8f02c429a 2016-12-15)*\n+\n+## 0.0.103 \u2014 2016-11-25\n+* Update to *rustc 1.15.0-nightly (d5814b03e 2016-11-23)*\n+\n+## 0.0.102 \u2014 2016-11-24\n+* Update to *rustc 1.15.0-nightly (3bf2be9ce 2016-11-22)*\n+\n+## 0.0.101 \u2014 2016-11-23\n+* Update to *rustc 1.15.0-nightly (7b3eeea22 2016-11-21)*\n+* New lint: [`string_extend_chars`]\n+\n+## 0.0.100 \u2014 2016-11-20\n+* Update to *rustc 1.15.0-nightly (ac635aa95 2016-11-18)*\n+\n+## 0.0.99 \u2014 2016-11-18\n+* Update to rustc 1.15.0-nightly (0ed951993 2016-11-14)\n+* New lint: [`get_unwrap`]\n+\n+## 0.0.98 \u2014 2016-11-08\n+* Fixes an issue due to a change in how cargo handles `--sysroot`, which broke `cargo clippy`\n+\n+## 0.0.97 \u2014 2016-11-03\n+* For convenience, `cargo clippy` defines a `cargo-clippy` feature. This was\n+  previously added for a short time under the name `clippy` but removed for\n+  compatibility.\n+* `cargo clippy --help` is more helping (and less helpful :smile:)\n+* Rustup to *rustc 1.14.0-nightly (5665bdf3e 2016-11-02)*\n+* New lints: [`if_let_redundant_pattern_matching`], [`partialeq_ne_impl`]\n+\n+## 0.0.96 \u2014 2016-10-22\n+* Rustup to *rustc 1.14.0-nightly (f09420685 2016-10-20)*\n+* New lint: [`iter_skip_next`]\n+\n+## 0.0.95 \u2014 2016-10-06\n+* Rustup to *rustc 1.14.0-nightly (3210fd5c2 2016-10-05)*\n+\n+## 0.0.94 \u2014 2016-10-04\n+* Fixes bustage on Windows due to forbidden directory name\n+\n+## 0.0.93 \u2014 2016-10-03\n+* Rustup to *rustc 1.14.0-nightly (144af3e97 2016-10-02)*\n+* [`option_map_unwrap_or`] and [`option_map_unwrap_or_else`] are now\n+  allowed by default.\n+* New lint: [`explicit_into_iter_loop`]\n+\n+## 0.0.92 \u2014 2016-09-30\n+* Rustup to *rustc 1.14.0-nightly (289f3a4ca 2016-09-29)*\n+\n+## 0.0.91 \u2014 2016-09-28\n+* Rustup to *rustc 1.13.0-nightly (d0623cf7b 2016-09-26)*\n+\n+## 0.0.90 \u2014 2016-09-09\n+* Rustup to *rustc 1.13.0-nightly (f1f40f850 2016-09-09)*\n+\n+## 0.0.89 \u2014 2016-09-06\n+* Rustup to *rustc 1.13.0-nightly (cbe4de78e 2016-09-05)*\n+\n+## 0.0.88 \u2014 2016-09-04\n+* Rustup to *rustc 1.13.0-nightly (70598e04f 2016-09-03)*\n+* The following lints are not new but were only usable through the `clippy`\n+  lint groups: [`filter_next`], [`for_loop_over_option`],\n+  [`for_loop_over_result`] and [`match_overlapping_arm`]. You should now be\n+  able to `#[allow/deny]` them individually and they are available directly\n+  through `cargo clippy`.\n+\n+## 0.0.87 \u2014 2016-08-31\n+* Rustup to *rustc 1.13.0-nightly (eac41469d 2016-08-30)*\n+* New lints: [`builtin_type_shadow`]\n+* Fix FP in [`zero_prefixed_literal`] and `0b`/`0o`\n+\n+## 0.0.86 \u2014 2016-08-28\n+* Rustup to *rustc 1.13.0-nightly (a23064af5 2016-08-27)*\n+* New lints: [`missing_docs_in_private_items`], [`zero_prefixed_literal`]\n+\n+## 0.0.85 \u2014 2016-08-19\n+* Fix ICE with [`useless_attribute`]\n+* [`useless_attribute`] ignores `unused_imports` on `use` statements\n+\n+## 0.0.84 \u2014 2016-08-18\n+* Rustup to *rustc 1.13.0-nightly (aef6971ca 2016-08-17)*\n+\n+## 0.0.83 \u2014 2016-08-17\n+* Rustup to *rustc 1.12.0-nightly (1bf5fa326 2016-08-16)*\n+* New lints: [`print_with_newline`], [`useless_attribute`]\n+\n+## 0.0.82 \u2014 2016-08-17\n+* Rustup to *rustc 1.12.0-nightly (197be89f3 2016-08-15)*\n+* New lint: [`module_inception`]\n+\n+## 0.0.81 \u2014 2016-08-14\n+* Rustup to *rustc 1.12.0-nightly (1deb02ea6 2016-08-12)*\n+* New lints: [`eval_order_dependence`], [`mixed_case_hex_literals`], [`unseparated_literal_suffix`]\n+* False positive fix in [`too_many_arguments`]\n+* Addition of functionality to [`needless_borrow`]\n+* Suggestions for [`clone_on_copy`]\n+* Bug fix in [`wrong_self_convention`]\n+* Doc improvements\n+\n+## 0.0.80 \u2014 2016-07-31\n+* Rustup to *rustc 1.12.0-nightly (1225e122f 2016-07-30)*\n+* New lints: [`misrefactored_assign_op`], [`serde_api_misuse`]\n+\n+## 0.0.79 \u2014 2016-07-10\n+* Rustup to *rustc 1.12.0-nightly (f93aaf84c 2016-07-09)*\n+* Major suggestions refactoring\n+\n+## 0.0.78 \u2014 2016-07-02\n+* Rustup to *rustc 1.11.0-nightly (01411937f 2016-07-01)*\n+* New lints: [`wrong_transmute`], [`double_neg`], [`filter_map`]\n+* For compatibility, `cargo clippy` does not defines the `clippy` feature\n+  introduced in 0.0.76 anymore\n+* [`collapsible_if`] now considers `if let`\n+\n+## 0.0.77 \u2014 2016-06-21\n+* Rustup to *rustc 1.11.0-nightly (5522e678b 2016-06-20)*\n+* New lints: `stutter` and [`iter_nth`]\n+\n+## 0.0.76 \u2014 2016-06-10\n+* Rustup to *rustc 1.11.0-nightly (7d2f75a95 2016-06-09)*\n+* `cargo clippy` now automatically defines the `clippy` feature\n+* New lint: [`not_unsafe_ptr_arg_deref`]\n+\n+## 0.0.75 \u2014 2016-06-08\n+* Rustup to *rustc 1.11.0-nightly (763f9234b 2016-06-06)*\n+\n+## 0.0.74 \u2014 2016-06-07\n+* Fix bug with `cargo-clippy` JSON parsing\n+* Add the `CLIPPY_DISABLE_DOCS_LINKS` environment variable to deactivate the\n+  \u201cfor further information visit *lint-link*\u201d message.\n+\n+## 0.0.73 \u2014 2016-06-05\n+* Fix false positives in [`useless_let_if_seq`]\n+\n+## 0.0.72 \u2014 2016-06-04\n+* Fix false positives in [`useless_let_if_seq`]\n+\n+## 0.0.71 \u2014 2016-05-31\n+* Rustup to *rustc 1.11.0-nightly (a967611d8 2016-05-30)*\n+* New lint: [`useless_let_if_seq`]\n+\n+## 0.0.70 \u2014 2016-05-28\n+* Rustup to *rustc 1.10.0-nightly (7bddce693 2016-05-27)*\n+* [`invalid_regex`] and [`trivial_regex`] can now warn on `RegexSet::new`,\n+  `RegexBuilder::new` and byte regexes\n+\n+## 0.0.69 \u2014 2016-05-20\n+* Rustup to *rustc 1.10.0-nightly (476fe6eef 2016-05-21)*\n+* [`used_underscore_binding`] has been made `Allow` temporarily\n+\n+## 0.0.68 \u2014 2016-05-17\n+* Rustup to *rustc 1.10.0-nightly (cd6a40017 2016-05-16)*\n+* New lint: [`unnecessary_operation`]\n+\n+## 0.0.67 \u2014 2016-05-12\n+* Rustup to *rustc 1.10.0-nightly (22ac88f1a 2016-05-11)*\n+\n+## 0.0.66 \u2014 2016-05-11\n+* New `cargo clippy` subcommand\n+* New lints: [`assign_op_pattern`], [`assign_ops`], [`needless_borrow`]\n+\n+## 0.0.65 \u2014 2016-05-08\n+* Rustup to *rustc 1.10.0-nightly (62e2b2fb7 2016-05-06)*\n+* New lints: [`float_arithmetic`], [`integer_arithmetic`]\n+\n+## 0.0.64 \u2014 2016-04-26\n+* Rustup to *rustc 1.10.0-nightly (645dd013a 2016-04-24)*\n+* New lints: [`temporary_cstring_as_ptr`], [`unsafe_removed_from_name`], and [`mem_forget`]\n+\n+## 0.0.63 \u2014 2016-04-08\n+* Rustup to *rustc 1.9.0-nightly (7979dd608 2016-04-07)*\n+\n+## 0.0.62 \u2014 2016-04-07\n+* Rustup to *rustc 1.9.0-nightly (bf5da36f1 2016-04-06)*\n+\n+## 0.0.61 \u2014 2016-04-03\n+* Rustup to *rustc 1.9.0-nightly (5ab11d72c 2016-04-02)*\n+* New lint: [`invalid_upcast_comparisons`]\n+\n+## 0.0.60 \u2014 2016-04-01\n+* Rustup to *rustc 1.9.0-nightly (e1195c24b 2016-03-31)*\n+\n+## 0.0.59 \u2014 2016-03-31\n+* Rustup to *rustc 1.9.0-nightly (30a3849f2 2016-03-30)*\n+* New lints: [`logic_bug`], [`nonminimal_bool`]\n+* Fixed: [`match_same_arms`] now ignores arms with guards\n+* Improved: [`useless_vec`] now warns on `for \u2026 in vec![\u2026]`\n+\n+## 0.0.58 \u2014 2016-03-27\n+* Rustup to *rustc 1.9.0-nightly (d5a91e695 2016-03-26)*\n+* New lint: [`doc_markdown`]\n+\n+## 0.0.57 \u2014 2016-03-27\n+* Update to *rustc 1.9.0-nightly (a1e29daf1 2016-03-25)*\n+* Deprecated lints: [`str_to_string`], [`string_to_string`], [`unstable_as_slice`], [`unstable_as_mut_slice`]\n+* New lint: [`crosspointer_transmute`]\n+\n+## 0.0.56 \u2014 2016-03-23\n+* Update to *rustc 1.9.0-nightly (0dcc413e4 2016-03-22)*\n+* New lints: [`many_single_char_names`] and [`similar_names`]\n+\n+## 0.0.55 \u2014 2016-03-21\n+* Update to *rustc 1.9.0-nightly (02310fd31 2016-03-19)*\n+\n+## 0.0.54 \u2014 2016-03-16\n+* Update to *rustc 1.9.0-nightly (c66d2380a 2016-03-15)*\n+\n+## 0.0.53 \u2014 2016-03-15\n+* Add a [configuration file]\n+\n+## ~~0.0.52~~\n+\n+## 0.0.51 \u2014 2016-03-13\n+* Add `str` to types considered by [`len_zero`]\n+* New lints: [`indexing_slicing`]\n+\n+## 0.0.50 \u2014 2016-03-11\n+* Update to *rustc 1.9.0-nightly (c9629d61c 2016-03-10)*\n+\n+## 0.0.49 \u2014 2016-03-09\n+* Update to *rustc 1.9.0-nightly (eabfc160f 2016-03-08)*\n+* New lints: [`overflow_check_conditional`], [`unused_label`], [`new_without_default`]\n+\n+## 0.0.48 \u2014 2016-03-07\n+* Fixed: ICE in [`needless_range_loop`] with globals\n+\n+## 0.0.47 \u2014 2016-03-07\n+* Update to *rustc 1.9.0-nightly (998a6720b 2016-03-07)*\n+* New lint: [`redundant_closure_call`]\n+\n+[`AsMut`]: https://doc.rust-lang.org/std/convert/trait.AsMut.html\n+[`AsRef`]: https://doc.rust-lang.org/std/convert/trait.AsRef.html\n+[configuration file]: ./rust-clippy#configuration\n+[pull3665]: https://github.com/rust-lang/rust-clippy/pull/3665\n+[adding_lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md\n+\n+<!-- lint disable no-unused-definitions -->\n+<!-- begin autogenerated links to lint list -->\n+[`absurd_extreme_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n+[`almost_swapped`]: https://rust-lang.github.io/rust-clippy/master/index.html#almost_swapped\n+[`approx_constant`]: https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n+[`as_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_conversions\n+[`assertions_on_constants`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants\n+[`assign_op_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n+[`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n+[`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n+[`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n+[`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n+[`block_in_if_condition_expr`]: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_expr\n+[`block_in_if_condition_stmt`]: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_stmt\n+[`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n+[`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n+[`borrowed_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrowed_box\n+[`box_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_vec\n+[`boxed_local`]: https://rust-lang.github.io/rust-clippy/master/index.html#boxed_local\n+[`builtin_type_shadow`]: https://rust-lang.github.io/rust-clippy/master/index.html#builtin_type_shadow\n+[`cargo_common_metadata`]: https://rust-lang.github.io/rust-clippy/master/index.html#cargo_common_metadata\n+[`cast_lossless`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_lossless\n+[`cast_possible_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_truncation\n+[`cast_possible_wrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_wrap\n+[`cast_precision_loss`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_precision_loss\n+[`cast_ptr_alignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_ptr_alignment\n+[`cast_ref_to_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_ref_to_mut\n+[`cast_sign_loss`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_sign_loss\n+[`char_lit_as_u8`]: https://rust-lang.github.io/rust-clippy/master/index.html#char_lit_as_u8\n+[`chars_last_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_last_cmp\n+[`chars_next_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_next_cmp\n+[`checked_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#checked_conversions\n+[`clone_double_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref\n+[`clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy\n+[`clone_on_ref_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_ref_ptr\n+[`cmp_nan`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_nan\n+[`cmp_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_null\n+[`cmp_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_owned\n+[`cognitive_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity\n+[`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n+[`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n+[`copy_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#copy_iterator\n+[`crosspointer_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#crosspointer_transmute\n+[`dbg_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#dbg_macro\n+[`debug_assert_with_mut_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call\n+[`decimal_literal_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation\n+[`declare_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n+[`default_trait_access`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_trait_access\n+[`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n+[`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n+[`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n+[`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n+[`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n+[`doc_markdown`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown\n+[`double_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_comparisons\n+[`double_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_must_use\n+[`double_neg`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_neg\n+[`double_parens`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_parens\n+[`drop_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_bounds\n+[`drop_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_copy\n+[`drop_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_ref\n+[`duplicate_underscore_argument`]: https://rust-lang.github.io/rust-clippy/master/index.html#duplicate_underscore_argument\n+[`duration_subsec`]: https://rust-lang.github.io/rust-clippy/master/index.html#duration_subsec\n+[`else_if_without_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#else_if_without_else\n+[`empty_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_enum\n+[`empty_line_after_outer_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_line_after_outer_attr\n+[`empty_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_loop\n+[`enum_clike_unportable_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#enum_clike_unportable_variant\n+[`enum_glob_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#enum_glob_use\n+[`enum_variant_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#enum_variant_names\n+[`eq_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#eq_op\n+[`erasing_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#erasing_op\n+[`eval_order_dependence`]: https://rust-lang.github.io/rust-clippy/master/index.html#eval_order_dependence\n+[`excessive_precision`]: https://rust-lang.github.io/rust-clippy/master/index.html#excessive_precision\n+[`exit`]: https://rust-lang.github.io/rust-clippy/master/index.html#exit\n+[`expect_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_fun_call\n+[`expl_impl_clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#expl_impl_clone_on_copy\n+[`explicit_counter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_counter_loop\n+[`explicit_deref_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_deref_methods\n+[`explicit_into_iter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_into_iter_loop\n+[`explicit_iter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_iter_loop\n+[`explicit_write`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_write\n+[`extend_from_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#extend_from_slice\n+[`extra_unused_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#extra_unused_lifetimes\n+[`fallible_impl_from`]: https://rust-lang.github.io/rust-clippy/master/index.html#fallible_impl_from\n+[`filetype_is_file`]: https://rust-lang.github.io/rust-clippy/master/index.html#filetype_is_file\n+[`filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#filter_map\n+[`filter_map_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#filter_map_next\n+[`filter_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#filter_next\n+[`find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#find_map\n+[`flat_map_identity`]: https://rust-lang.github.io/rust-clippy/master/index.html#flat_map_identity\n+[`float_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_arithmetic\n+[`float_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_cmp\n+[`float_cmp_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#float_cmp_const\n+[`fn_address_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_address_comparisons\n+[`fn_params_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_params_excessive_bools\n+[`fn_to_numeric_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast\n+[`fn_to_numeric_cast_with_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast_with_truncation\n+[`for_kv_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_kv_map\n+[`for_loop_over_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loop_over_option\n+[`for_loop_over_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loop_over_result\n+[`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n+[`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n+[`future_not_send`]: https://rust-lang.github.io/rust-clippy/master/index.html#future_not_send\n+[`get_last_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_last_with_len\n+[`get_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_unwrap\n+[`identity_conversion`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_conversion\n+[`identity_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_op\n+[`if_let_mutex`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_mutex\n+[`if_let_redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_redundant_pattern_matching\n+[`if_let_some_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_some_result\n+[`if_not_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_not_else\n+[`if_same_then_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_same_then_else\n+[`ifs_same_cond`]: https://rust-lang.github.io/rust-clippy/master/index.html#ifs_same_cond\n+[`implicit_hasher`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_hasher\n+[`implicit_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_return\n+[`implicit_saturating_sub`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_saturating_sub\n+[`imprecise_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#imprecise_flops\n+[`inconsistent_digit_grouping`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_digit_grouping\n+[`indexing_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing\n+[`ineffective_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#ineffective_bit_mask\n+[`inefficient_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#inefficient_to_string\n+[`infallible_destructuring_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#infallible_destructuring_match\n+[`infinite_iter`]: https://rust-lang.github.io/rust-clippy/master/index.html#infinite_iter\n+[`inherent_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#inherent_to_string\n+[`inherent_to_string_shadow_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#inherent_to_string_shadow_display\n+[`inline_always`]: https://rust-lang.github.io/rust-clippy/master/index.html#inline_always\n+[`inline_fn_without_body`]: https://rust-lang.github.io/rust-clippy/master/index.html#inline_fn_without_body\n+[`int_plus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#int_plus_one\n+[`integer_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_arithmetic\n+[`integer_division`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_division\n+[`into_iter_on_array`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_array\n+[`into_iter_on_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_ref\n+[`invalid_atomic_ordering`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_atomic_ordering\n+[`invalid_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_ref\n+[`invalid_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_regex\n+[`invalid_upcast_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons\n+[`items_after_statements`]: https://rust-lang.github.io/rust-clippy/master/index.html#items_after_statements\n+[`iter_cloned_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_cloned_collect\n+[`iter_next_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_loop\n+[`iter_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth\n+[`iter_nth_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth_zero\n+[`iter_skip_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_skip_next\n+[`iterator_step_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iterator_step_by_zero\n+[`just_underscores_and_digits`]: https://rust-lang.github.io/rust-clippy/master/index.html#just_underscores_and_digits\n+[`large_const_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_const_arrays\n+[`large_digit_groups`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_digit_groups\n+[`large_enum_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant\n+[`large_stack_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays\n+[`len_without_is_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n+[`len_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n+[`let_and_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\n+[`let_underscore_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_lock\n+[`let_underscore_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_must_use\n+[`let_unit_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_unit_value\n+[`linkedlist`]: https://rust-lang.github.io/rust-clippy/master/index.html#linkedlist\n+[`logic_bug`]: https://rust-lang.github.io/rust-clippy/master/index.html#logic_bug\n+[`lossy_float_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#lossy_float_literal\n+[`macro_use_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#macro_use_imports\n+[`main_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#main_recursion\n+[`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n+[`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n+[`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n+[`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n+[`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry\n+[`map_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_flatten\n+[`match_as_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_as_ref\n+[`match_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_bool\n+[`match_on_vec_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_on_vec_items\n+[`match_overlapping_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_overlapping_arm\n+[`match_ref_pats`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_ref_pats\n+[`match_same_arms`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_same_arms\n+[`match_single_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_single_binding\n+[`match_wild_err_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wild_err_arm\n+[`maybe_infinite_iter`]: https://rust-lang.github.io/rust-clippy/master/index.html#maybe_infinite_iter\n+[`mem_discriminant_non_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_discriminant_non_enum\n+[`mem_forget`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_forget\n+[`mem_replace_option_with_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_option_with_none\n+[`mem_replace_with_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_with_default\n+[`mem_replace_with_uninit`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_with_uninit\n+[`min_max`]: https://rust-lang.github.io/rust-clippy/master/index.html#min_max\n+[`misaligned_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#misaligned_transmute\n+[`mismatched_target_os`]: https://rust-lang.github.io/rust-clippy/master/index.html#mismatched_target_os\n+[`misrefactored_assign_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#misrefactored_assign_op\n+[`missing_const_for_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_const_for_fn\n+[`missing_docs_in_private_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items\n+[`missing_errors_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc\n+[`missing_inline_in_public_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_inline_in_public_items\n+[`missing_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc\n+[`mistyped_literal_suffixes`]: https://rust-lang.github.io/rust-clippy/master/index.html#mistyped_literal_suffixes\n+[`mixed_case_hex_literals`]: https://rust-lang.github.io/rust-clippy/master/index.html#mixed_case_hex_literals\n+[`module_inception`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_inception\n+[`module_name_repetitions`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_name_repetitions\n+[`modulo_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#modulo_arithmetic\n+[`modulo_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#modulo_one\n+[`multiple_crate_versions`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_crate_versions\n+[`multiple_inherent_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#multiple_inherent_impl\n+[`must_use_candidate`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_candidate\n+[`must_use_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#must_use_unit\n+[`mut_from_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_from_ref\n+[`mut_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_mut\n+[`mut_range_bound`]: https://rust-lang.github.io/rust-clippy/master/index.html#mut_range_bound\n+[`mutable_key_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutable_key_type\n+[`mutex_atomic`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutex_atomic\n+[`mutex_integer`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutex_integer\n+[`naive_bytecount`]: https://rust-lang.github.io/rust-clippy/master/index.html#naive_bytecount\n+[`needless_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_bool\n+[`needless_borrow`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n+[`needless_borrowed_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrowed_reference\n+[`needless_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_collect\n+[`needless_continue`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_continue\n+[`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n+[`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n+[`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n+[`needless_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop\n+[`needless_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_return\n+[`needless_update`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_update\n+[`neg_cmp_op_on_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#neg_cmp_op_on_partial_ord\n+[`neg_multiply`]: https://rust-lang.github.io/rust-clippy/master/index.html#neg_multiply\n+[`never_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#never_loop\n+[`new_ret_no_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_ret_no_self\n+[`new_without_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n+[`no_effect`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect\n+[`non_ascii_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_ascii_literal\n+[`nonminimal_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonminimal_bool\n+[`nonsensical_open_options`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonsensical_open_options\n+[`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n+[`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n+[`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n+[`option_and_then_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_and_then_some\n+[`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n+[`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n+[`option_expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_expect_used\n+[`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n+[`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n+[`option_map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unwrap_or\n+[`option_map_unwrap_or_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unwrap_or_else\n+[`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option\n+[`option_unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_unwrap_used\n+[`or_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#or_fun_call\n+[`out_of_bounds_indexing`]: https://rust-lang.github.io/rust-clippy/master/index.html#out_of_bounds_indexing\n+[`overflow_check_conditional`]: https://rust-lang.github.io/rust-clippy/master/index.html#overflow_check_conditional\n+[`panic`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic\n+[`panic_params`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_params\n+[`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n+[`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n+[`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n+[`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n+[`precedence`]: https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n+[`print_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_literal\n+[`print_stdout`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_stdout\n+[`print_with_newline`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_with_newline\n+[`println_empty_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#println_empty_string\n+[`ptr_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg\n+[`ptr_offset_with_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_offset_with_cast\n+[`pub_enum_variant_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#pub_enum_variant_names\n+[`question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#question_mark\n+[`range_minus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_minus_one\n+[`range_plus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_plus_one\n+[`range_step_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_step_by_zero\n+[`range_zip_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_zip_with_len\n+[`redundant_allocation`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_allocation\n+[`redundant_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone\n+[`redundant_closure`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n+[`redundant_closure_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_call\n+[`redundant_closure_for_method_calls`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_for_method_calls\n+[`redundant_field_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n+[`redundant_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern\n+[`redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching\n+[`redundant_pub_crate`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pub_crate\n+[`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n+[`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n+[`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n+[`replace_consts`]: https://rust-lang.github.io/rust-clippy/master/index.html#replace_consts\n+[`rest_pat_in_fully_bound_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#rest_pat_in_fully_bound_structs\n+[`result_expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_expect_used\n+[`result_map_or_into_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_or_into_option\n+[`result_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unit_fn\n+[`result_map_unwrap_or_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unwrap_or_else\n+[`result_unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_unwrap_used\n+[`reverse_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#reverse_range_loop\n+[`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n+[`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n+[`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n+[`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse\n+[`shadow_same`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_same\n+[`shadow_unrelated`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_unrelated\n+[`short_circuit_statement`]: https://rust-lang.github.io/rust-clippy/master/index.html#short_circuit_statement\n+[`should_assert_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_assert_eq\n+[`should_implement_trait`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\n+[`similar_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#similar_names\n+[`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n+[`single_component_path_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_component_path_imports\n+[`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n+[`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n+[`skip_while_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#skip_while_next\n+[`slow_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#slow_vector_initialization\n+[`str_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#str_to_string\n+[`string_add`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add\n+[`string_add_assign`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add_assign\n+[`string_extend_chars`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_extend_chars\n+[`string_lit_as_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_lit_as_bytes\n+[`string_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_to_string\n+[`struct_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#struct_excessive_bools\n+[`suboptimal_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#suboptimal_flops\n+[`suspicious_arithmetic_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_arithmetic_impl\n+[`suspicious_assignment_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_assignment_formatting\n+[`suspicious_else_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_else_formatting\n+[`suspicious_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_map\n+[`suspicious_op_assign_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_op_assign_impl\n+[`suspicious_unary_op_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_unary_op_formatting\n+[`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n+[`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n+[`temporary_cstring_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_cstring_as_ptr\n+[`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n+[`todo`]: https://rust-lang.github.io/rust-clippy/master/index.html#todo\n+[`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n+[`too_many_lines`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines\n+[`toplevel_ref_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#toplevel_ref_arg\n+[`transmute_bytes_to_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_bytes_to_str\n+[`transmute_float_to_int`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_float_to_int\n+[`transmute_int_to_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_bool\n+[`transmute_int_to_char`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_char\n+[`transmute_int_to_float`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_float\n+[`transmute_ptr_to_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ptr\n+[`transmute_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n+[`transmuting_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmuting_null\n+[`trivial_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivial_regex\n+[`trivially_copy_pass_by_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\n+[`try_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#try_err\n+[`type_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_complexity\n+[`type_repetition_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_repetition_in_bounds\n+[`unicode_not_nfc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unicode_not_nfc\n+[`unimplemented`]: https://rust-lang.github.io/rust-clippy/master/index.html#unimplemented\n+[`uninit_assumed_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_assumed_init\n+[`unit_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_arg\n+[`unit_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_cmp\n+[`unknown_clippy_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#unknown_clippy_lints\n+[`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n+[`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n+[`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n+[`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n+[`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n+[`unnecessary_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap\n+[`unneeded_field_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern\n+[`unneeded_wildcard_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_wildcard_pattern\n+[`unreachable`]: https://rust-lang.github.io/rust-clippy/master/index.html#unreachable\n+[`unreadable_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#unreadable_literal\n+[`unsafe_derive_deserialize`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_derive_deserialize\n+[`unsafe_removed_from_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_removed_from_name\n+[`unsafe_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_vector_initialization\n+[`unseparated_literal_suffix`]: https://rust-lang.github.io/rust-clippy/master/index.html#unseparated_literal_suffix\n+[`unsound_collection_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsound_collection_transmute\n+[`unstable_as_mut_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_mut_slice\n+[`unstable_as_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_slice\n+[`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n+[`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n+[`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n+[`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n+[`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n+[`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug\n+[`use_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_self\n+[`used_underscore_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#used_underscore_binding\n+[`useless_asref`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_asref\n+[`useless_attribute`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_attribute\n+[`useless_format`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n+[`useless_let_if_seq`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_let_if_seq\n+[`useless_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n+[`useless_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_vec\n+[`vec_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_box\n+[`verbose_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#verbose_bit_mask\n+[`verbose_file_reads`]: https://rust-lang.github.io/rust-clippy/master/index.html#verbose_file_reads\n+[`vtable_address_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#vtable_address_comparisons\n+[`while_immutable_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#while_immutable_condition\n+[`while_let_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#while_let_loop\n+[`while_let_on_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#while_let_on_iterator\n+[`wildcard_dependencies`]: https://rust-lang.github.io/rust-clippy/master/index.html#wildcard_dependencies\n+[`wildcard_enum_match_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#wildcard_enum_match_arm\n+[`wildcard_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#wildcard_imports\n+[`wildcard_in_or_patterns`]: https://rust-lang.github.io/rust-clippy/master/index.html#wildcard_in_or_patterns\n+[`write_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#write_literal\n+[`write_with_newline`]: https://rust-lang.github.io/rust-clippy/master/index.html#write_with_newline\n+[`writeln_empty_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#writeln_empty_string\n+[`wrong_pub_self_convention`]: https://rust-lang.github.io/rust-clippy/master/index.html#wrong_pub_self_convention\n+[`wrong_self_convention`]: https://rust-lang.github.io/rust-clippy/master/index.html#wrong_self_convention\n+[`wrong_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#wrong_transmute\n+[`zero_divided_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_divided_by_zero\n+[`zero_prefixed_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_prefixed_literal\n+[`zero_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_ptr\n+[`zero_width_space`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_width_space\n+[`zst_offset`]: https://rust-lang.github.io/rust-clippy/master/index.html#zst_offset\n+<!-- end autogenerated links to lint list -->"}, {"sha": "dec13e44a17f88a7ff734f3b6b4492d9e86cfd21", "filename": "src/tools/clippy/CODE_OF_CONDUCT.md", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCODE_OF_CONDUCT.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,70 @@\n+# The Rust Code of Conduct\n+\n+A version of this document [can be found online](https://www.rust-lang.org/conduct.html).\n+\n+## Conduct\n+\n+**Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n+\n+* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience,\n+  gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age,\n+  religion, nationality, or other similar characteristic.\n+* On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and\n+  welcoming environment for all.\n+* Please be kind and courteous. There's no need to be mean or rude.\n+* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and\n+  numerous costs. There is seldom a right answer.\n+* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and\n+  see how it works.\n+* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We\n+  interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen\n+  Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their\n+  definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n+* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or\n+  made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation\n+  team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a\n+  safe place for you and we've got your back.\n+* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n+\n+## Moderation\n+\n+\n+These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation,\n+please contact the [Rust moderation team][mod_team].\n+\n+1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks,\n+   are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)\n+2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.\n+3. Moderators will first respond to such remarks with a warning.\n+4. If the warning is unheeded, the user will be \"kicked,\" i.e., kicked out of the communication channel to cool off.\n+5. If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.\n+6. Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended\n+   party a genuine apology.\n+7. If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a\n+   different moderator, **in private**. Complaints about bans in-channel are not allowed.\n+8. Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate\n+   situation, they should expect less leeway than others.\n+\n+In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically\n+unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly\n+if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can\n+drive people away from the community entirely.\n+\n+And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was\n+they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good\n+there was something you could've communicated better \u2014 remember that it's your responsibility to make your fellow\n+Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about\n+cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their\n+trust.\n+\n+The enforcement policies listed above apply to all official Rust venues; including official IRC channels (#rust,\n+#rust-internals, #rust-tools, #rust-libs, #rustc, #rust-beginners, #rust-docs, #rust-community, #rust-lang, and #cargo);\n+GitHub repositories under rust-lang, rust-lang-nursery, and rust-lang-deprecated; and all forums under rust-lang.org\n+(users.rust-lang.org, internals.rust-lang.org). For other projects adopting the Rust Code of Conduct, please contact the\n+maintainers of those projects for enforcement. If you wish to use this code of conduct for your own project, consider\n+explicitly mentioning your moderation policy or making a copy with your own moderation policy so as to avoid confusion.\n+\n+*Adapted from the [Node.js Policy on Trolling](http://blog.izs.me/post/30036893703/policy-on-trolling) as well as the\n+[Contributor Covenant v1.3.0](https://www.contributor-covenant.org/version/1/3/0/).*\n+\n+[mod_team]: https://www.rust-lang.org/team.html#Moderation-team"}, {"sha": "50a5ee8bbf3c83bc0e583927d97ace463b3a3794", "filename": "src/tools/clippy/CONTRIBUTING.md", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCONTRIBUTING.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,243 @@\n+# Contributing to Clippy\n+\n+Hello fellow Rustacean! Great to see your interest in compiler internals and lints!\n+\n+**First**: if you're unsure or afraid of _anything_, just ask or submit the issue or pull request anyway. You won't be\n+yelled at for giving it your best effort. The worst that can happen is that you'll be politely asked to change\n+something. We appreciate any sort of contributions, and don't want a wall of rules to get in the way of that.\n+\n+Clippy welcomes contributions from everyone. There are many ways to contribute to Clippy and the following document\n+explains how you can contribute and how to get started.  If you have any questions about contributing or need help with\n+anything, feel free to ask questions on issues or visit the `#clippy` on [Discord].\n+\n+All contributors are expected to follow the [Rust Code of Conduct].\n+\n+* [Getting started](#getting-started)\n+  * [Finding something to fix/improve](#finding-something-to-fiximprove)\n+* [Writing code](#writing-code)\n+* [How Clippy works](#how-clippy-works)\n+* [Fixing nightly build failures](#fixing-build-failures-caused-by-rust)\n+* [Issue and PR Triage](#issue-and-pr-triage)\n+* [Bors and Homu](#bors-and-homu)\n+* [Contributions](#contributions)\n+\n+[Discord]: https://discord.gg/rust-lang\n+[Rust Code of Conduct]: https://www.rust-lang.org/policies/code-of-conduct\n+\n+## Getting started\n+\n+High level approach:\n+\n+1. Find something to fix/improve\n+2. Change code (likely some file in `clippy_lints/src/`)\n+3. Follow the instructions in the [docs for writing lints](doc/adding_lints.md) such as running the `setup-toolchain.sh` script\n+4. Run `cargo test` in the root directory and wiggle code until it passes\n+5. Open a PR (also can be done after 2. if you run into problems)\n+\n+### Finding something to fix/improve\n+\n+All issues on Clippy are mentored, if you want help with a bug just ask\n+@Manishearth, @flip1995, @phansch or @yaahc.\n+\n+Some issues are easier than others. The [`good first issue`] label can be used to find the easy issues.\n+If you want to work on an issue, please leave a comment so that we can assign it to you!\n+\n+There are also some abandoned PRs, marked with [`S-inactive-closed`].\n+Pretty often these PRs are nearly completed and just need some extra steps\n+(formatting, addressing review comments, ...) to be merged. If you want to\n+complete such a PR, please leave a comment in the PR and open a new one based\n+on it.\n+\n+Issues marked [`T-AST`] involve simple matching of the syntax tree structure,\n+and are generally easier than [`T-middle`] issues, which involve types\n+and resolved paths.\n+\n+[`T-AST`] issues will generally need you to match against a predefined syntax structure.\n+To figure out how this syntax structure is encoded in the AST, it is recommended to run\n+`rustc -Z ast-json` on an example of the structure and compare with the [nodes in the AST docs].\n+Usually the lint will end up to be a nested series of matches and ifs, [like so][deep-nesting].\n+But we can make it nest-less by using [if_chain] macro, [like this][nest-less].\n+\n+[`E-medium`] issues are generally pretty easy too, though it's recommended you work on an E-easy issue first.\n+They are mostly classified as [`E-medium`], since they might be somewhat involved code wise,\n+but not difficult per-se.\n+\n+[`T-middle`] issues can be more involved and require verifying types. The [`ty`] module contains a\n+lot of methods that are useful, though one of the most useful would be `expr_ty` (gives the type of\n+an AST expression). `match_def_path()` in Clippy's `utils` module can also be useful.\n+\n+[`good first issue`]: https://github.com/rust-lang/rust-clippy/labels/good%20first%20issue\n+[`S-inactive-closed`]: https://github.com/rust-lang/rust-clippy/pulls?q=is%3Aclosed+label%3AS-inactive-closed\n+[`T-AST`]: https://github.com/rust-lang/rust-clippy/labels/T-AST\n+[`T-middle`]: https://github.com/rust-lang/rust-clippy/labels/T-middle\n+[`E-medium`]: https://github.com/rust-lang/rust-clippy/labels/E-medium\n+[`ty`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty\n+[nodes in the AST docs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/\n+[deep-nesting]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/mem_forget.rs#L29-L43\n+[if_chain]: https://docs.rs/if_chain/*/if_chain\n+[nest-less]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/bit_mask.rs#L124-L150\n+\n+## Writing code\n+\n+Have a look at the [docs for writing lints][adding_lints] for more details.\n+\n+If you want to add a new lint or change existing ones apart from bugfixing, it's\n+also a good idea to give the [stability guarantees][rfc_stability] and\n+[lint categories][rfc_lint_cats] sections of the [Clippy 1.0 RFC][clippy_rfc] a\n+quick read.\n+\n+[adding_lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md\n+[clippy_rfc]: https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md\n+[rfc_stability]: https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#stability-guarantees\n+[rfc_lint_cats]: https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#lint-audit-and-categories\n+\n+## How Clippy works\n+\n+[`clippy_lints/src/lib.rs`][lint_crate_entry] imports all the different lint modules and registers in the [`LintStore`].\n+For example, the [`else_if_without_else`][else_if_without_else] lint is registered like this:\n+\n+```rust\n+// ./clippy_lints/src/lib.rs\n+\n+// ...\n+pub mod else_if_without_else;\n+// ...\n+\n+pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf: &Conf) {\n+    // ...\n+    store.register_early_pass(|| box else_if_without_else::ElseIfWithoutElse);\n+    // ...\n+\n+    store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n+        // ...\n+        LintId::of(&else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n+        // ...\n+    ]);\n+}\n+```\n+\n+The [`rustc_lint::LintStore`][`LintStore`] provides two methods to register lints:\n+[register_early_pass][reg_early_pass] and [register_late_pass][reg_late_pass]. Both take an object\n+that implements an [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass] respectively. This is done in\n+every single lint. It's worth noting that the majority of `clippy_lints/src/lib.rs` is autogenerated by `cargo dev\n+update_lints`. When you are writing your own lint, you can use that script to save you some time.\n+\n+```rust\n+// ./clippy_lints/src/else_if_without_else.rs\n+\n+use rustc_lint::{EarlyLintPass, EarlyContext};\n+\n+// ...\n+\n+pub struct ElseIfWithoutElse;\n+\n+// ...\n+\n+impl EarlyLintPass for ElseIfWithoutElse {\n+    // ... the functions needed, to make the lint work\n+}\n+```\n+\n+The difference between `EarlyLintPass` and `LateLintPass` is that the methods of the `EarlyLintPass` trait only provide\n+AST information. The methods of the `LateLintPass` trait are executed after type checking and contain type information\n+via the `LateContext` parameter.\n+\n+That's why the `else_if_without_else` example uses the `register_early_pass` function. Because the\n+[actual lint logic][else_if_without_else] does not depend on any type information.\n+\n+[lint_crate_entry]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lib.rs\n+[else_if_without_else]: https://github.com/rust-lang/rust-clippy/blob/4253aa7137cb7378acc96133c787e49a345c2b3c/clippy_lints/src/else_if_without_else.rs\n+[`LintStore`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LintStore.html\n+[reg_early_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LintStore.html#method.register_early_pass\n+[reg_late_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LintStore.html#method.register_late_pass\n+[early_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html\n+[late_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html\n+\n+## Fixing build failures caused by Rust\n+\n+Clippy will sometimes fail to build from source because building it depends on unstable internal Rust features. Most of\n+the times we have to adapt to the changes and only very rarely there's an actual bug in Rust. Fixing build failures\n+caused by Rust updates, can be a good way to learn about Rust internals.\n+\n+In order to find out why Clippy does not work properly with a new Rust commit, you can use the [rust-toolstate commit\n+history][toolstate_commit_history]. You will then have to look for the last commit that contains\n+`test-pass -> build-fail` or `test-pass -> test-fail` for the `clippy-driver` component.\n+[Here][toolstate_commit] is an example.\n+\n+The commit message contains a link to the PR. The PRs are usually small enough to discover the breaking API change and\n+if they are bigger, they likely include some discussion that may help you to fix Clippy.\n+\n+To check if Clippy is available for a specific target platform, you can check\n+the [rustup component history][rustup_component_history].\n+\n+If you decide to make Clippy work again with a Rust commit that breaks it,\n+you probably want to install the latest Rust from master locally and run Clippy\n+using that version of Rust.\n+\n+You can set up the master toolchain by running `./setup-toolchain.sh`. That script will install\n+[rustup-toolchain-install-master][rtim] and master toolchain, then run `rustup override set master`.\n+\n+After fixing the build failure on this repository, we can submit a pull request\n+to [`rust-lang/rust`] to fix the toolstate.\n+\n+To submit a pull request, you should follow these steps:\n+\n+```bash\n+# Assuming you already cloned the rust-lang/rust repo and you're in the correct directory\n+git submodule update --remote src/tools/clippy\n+cargo update -p clippy\n+git add -u\n+git commit -m \"Update Clippy\"\n+./x.py test -i --stage 1 src/tools/clippy # This is optional and should succeed anyway\n+# Open a PR in rust-lang/rust\n+```\n+\n+[rustup_component_history]: https://rust-lang.github.io/rustup-components-history\n+[toolstate_commit_history]: https://github.com/rust-lang-nursery/rust-toolstate/commits/master\n+[toolstate_commit]: https://github.com/rust-lang-nursery/rust-toolstate/commit/aad74d8294e198a7cf8ac81a91aebb7f3bbcf727\n+[rtim]: https://github.com/kennytm/rustup-toolchain-install-master\n+[`rust-lang/rust`]: https://github.com/rust-lang/rust\n+\n+## Issue and PR triage\n+\n+Clippy is following the [Rust triage procedure][triage] for issues and pull\n+requests.\n+\n+However, we are a smaller project with all contributors being volunteers\n+currently. Between writing new lints, fixing issues, reviewing pull requests and\n+responding to issues there may not always be enough time to stay on top of it\n+all.\n+\n+Our highest priority is fixing [crashes][l-crash] and [bugs][l-bug]. We don't\n+want Clippy to crash on your code and we want it to be as reliable as the\n+suggestions from Rust compiler errors.\n+\n+## Bors and Homu\n+\n+We use a bot powered by [Homu][homu] to help automate testing and landing of pull\n+requests in Clippy. The bot's username is @bors.\n+\n+You can find the Clippy bors queue [here][homu_queue].\n+\n+If you have @bors permissions, you can find an overview of the available\n+commands [here][homu_instructions].\n+\n+[triage]: https://forge.rust-lang.org/release/triage-procedure.html\n+[l-crash]: https://github.com/rust-lang/rust-clippy/labels/L-crash%20%3Aboom%3A\n+[l-bug]: https://github.com/rust-lang/rust-clippy/labels/L-bug%20%3Abeetle%3A\n+[homu]: https://github.com/rust-lang/homu\n+[homu_instructions]: https://buildbot2.rust-lang.org/homu/\n+[homu_queue]: https://buildbot2.rust-lang.org/homu/queue/clippy\n+\n+## Contributions\n+\n+Contributions to Clippy should be made in the form of GitHub pull requests. Each pull request will\n+be reviewed by a core contributor (someone with permission to land patches) and either landed in the\n+main tree or given feedback for changes that would be required.\n+\n+All code in this repository is under the [Apache-2.0] or the [MIT] license.\n+\n+<!-- adapted from https://github.com/servo/servo/blob/master/CONTRIBUTING.md -->\n+\n+[Apache-2.0]: https://www.apache.org/licenses/LICENSE-2.0\n+[MIT]: https://opensource.org/licenses/MIT"}, {"sha": "80d64472c70a68f4d4f8cbbff6b028d33eab91cc", "filename": "src/tools/clippy/COPYRIGHT", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCOPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCOPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCOPYRIGHT?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,7 @@\n+Copyright 2014-2020 The Rust Project Developers\n+\n+Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+<LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+option. All files in the project carrying such notice may not be\n+copied, modified, or distributed except according to those terms."}, {"sha": "63ce2cd8cad776ccf14c5da2da075358fbaf4660", "filename": "src/tools/clippy/Cargo.toml", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,59 @@\n+[package]\n+name = \"clippy\"\n+version = \"0.0.212\"\n+authors = [\n+\t\"Manish Goregaokar <manishsmail@gmail.com>\",\n+\t\"Andre Bogus <bogusandre@gmail.com>\",\n+\t\"Georg Brandl <georg@python.org>\",\n+\t\"Martin Carton <cartonmartin@gmail.com>\",\n+\t\"Oliver Schneider <clippy-iethah7aipeen8neex1a@oli-obk.de>\"\n+]\n+description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+repository = \"https://github.com/rust-lang/rust-clippy\"\n+readme = \"README.md\"\n+license = \"MIT OR Apache-2.0\"\n+keywords = [\"clippy\", \"lint\", \"plugin\"]\n+categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+build = \"build.rs\"\n+edition = \"2018\"\n+publish = false\n+\n+[[bin]]\n+name = \"cargo-clippy\"\n+test = false\n+path = \"src/main.rs\"\n+\n+[[bin]]\n+name = \"clippy-driver\"\n+path = \"src/driver.rs\"\n+\n+[dependencies]\n+# begin automatic update\n+clippy_lints = { version = \"0.0.212\", path = \"clippy_lints\" }\n+# end automatic update\n+regex = \"1\"\n+semver = \"0.9\"\n+rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n+tempfile = { version = \"3.1.0\", optional = true }\n+lazy_static = \"1.0\"\n+\n+[dev-dependencies]\n+cargo_metadata = \"0.9.0\"\n+compiletest_rs = { version = \"0.5.0\", features = [\"tmp\"] }\n+tester = \"0.7\"\n+lazy_static = \"1.0\"\n+clippy-mini-macro-test = { version = \"0.2\", path = \"mini-macro\" }\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+derive-new = \"0.5\"\n+\n+# A noop dependency that changes in the Rust repository, it's a bit of a hack.\n+# See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n+# for more information.\n+rustc-workspace-hack = \"1.0.0\"\n+\n+[build-dependencies]\n+rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n+\n+[features]\n+deny-warnings = []\n+integration = [\"tempfile\"]"}, {"sha": "d821a4de2bed8ac8de70cc84f22ca07ef3aae661", "filename": "src/tools/clippy/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FLICENSE-APACHE?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright 2014-2020 The Rust Project Developers\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "b7c70dd4026d9c96fdc5edd502b259bb0a83dc61", "filename": "src/tools/clippy/LICENSE-MIT", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FLICENSE-MIT?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,27 @@\n+MIT License\n+\n+Copyright (c) 2014-2020 The Rust Project Developers\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "222b81023a7705aa87847ea6fd913d50a380036c", "filename": "src/tools/clippy/README.md", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,193 @@\n+# Clippy\n+\n+[![Clippy Test](https://github.com/rust-lang/rust-clippy/workflows/Clippy%20Test/badge.svg?branch=auto&event=push)](https://github.com/rust-lang/rust-clippy/actions?query=workflow%3A%22Clippy+Test%22+event%3Apush+branch%3Aauto)\n+[![License: MIT OR Apache-2.0](https://img.shields.io/crates/l/clippy.svg)](#license)\n+\n+A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n+\n+[There are over 350 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+\n+We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n+\n+* `clippy::all` (everything that is on by default: all the categories below except for `nursery`, `pedantic`, and `cargo`)\n+* `clippy::correctness` (code that is just **outright wrong** or **very very useless**, causes hard errors by default)\n+* `clippy::style` (code that should be written in a more idiomatic way)\n+* `clippy::complexity` (code that does something simple but in a complex way)\n+* `clippy::perf` (code that can be written in a faster way)\n+* `clippy::pedantic` (lints which are rather strict, off by default)\n+* `clippy::nursery` (new lints that aren't quite ready yet, off by default)\n+* `clippy::cargo` (checks against the cargo manifest, off by default)\n+\n+More to come, please [file an issue](https://github.com/rust-lang/rust-clippy/issues) if you have ideas!\n+\n+Only the following of those categories are enabled by default:\n+\n+* `clippy::style`\n+* `clippy::correctness`\n+* `clippy::complexity`\n+* `clippy::perf`\n+\n+Other categories need to be enabled in order for their lints to be executed.\n+\n+The [lint list](https://rust-lang.github.io/rust-clippy/master/index.html) also contains \"restriction lints\", which are\n+for things which are usually not considered \"bad\", but may be useful to turn on in specific cases. These should be used\n+very selectively, if at all.\n+\n+Table of contents:\n+\n+*   [Usage instructions](#usage)\n+*   [Configuration](#configuration)\n+*   [Contributing](#contributing)\n+*   [License](#license)\n+\n+## Usage\n+\n+Since this is a tool for helping the developer of a library or application\n+write better code, it is recommended not to include Clippy as a hard dependency.\n+Options include using it as an optional dependency, as a cargo subcommand, or\n+as an included feature during build. These options are detailed below.\n+\n+### As a cargo subcommand (`cargo clippy`)\n+\n+One way to use Clippy is by installing Clippy through rustup as a cargo\n+subcommand.\n+\n+#### Step 1: Install rustup\n+\n+You can install [rustup](https://rustup.rs/) on supported platforms. This will help\n+us install Clippy and its dependencies.\n+\n+If you already have rustup installed, update to ensure you have the latest\n+rustup and compiler:\n+\n+```terminal\n+rustup update\n+```\n+\n+#### Step 2: Install Clippy\n+\n+Once you have rustup and the latest stable release (at least Rust 1.29) installed, run the following command:\n+\n+```terminal\n+rustup component add clippy\n+```\n+If it says that it can't find the `clippy` component, please run `rustup self update`.\n+\n+#### Step 3: Run Clippy\n+\n+Now you can run Clippy by invoking the following command:\n+\n+```terminal\n+cargo clippy\n+```\n+\n+#### Automatically applying Clippy suggestions\n+\n+Clippy can automatically apply some lint suggestions.\n+Note that this is still experimental and only supported on the nightly channel:\n+\n+```terminal\n+cargo clippy --fix -Z unstable-options\n+```\n+\n+### Running Clippy from the command line without installing it\n+\n+To have cargo compile your crate with Clippy without Clippy installation\n+in your code, you can use:\n+\n+```terminal\n+cargo run --bin cargo-clippy --manifest-path=path_to_clippys_Cargo.toml\n+```\n+\n+*Note:* Be sure that Clippy was compiled with the same version of rustc that cargo invokes here!\n+\n+### Travis CI\n+\n+You can add Clippy to Travis CI in the same way you use it locally:\n+\n+```yml\n+language: rust\n+rust:\n+  - stable\n+  - beta\n+before_script:\n+  - rustup component add clippy\n+script:\n+  - cargo clippy\n+  # if you want the build job to fail when encountering warnings, use\n+  - cargo clippy -- -D warnings\n+  # in order to also check tests and non-default crate features, use\n+  - cargo clippy --all-targets --all-features -- -D warnings\n+  - cargo test\n+  # etc.\n+```\n+\n+If you are on nightly, It might happen that Clippy is not available for a certain nightly release.\n+In this case you can try to conditionally install Clippy from the Git repo.\n+\n+```yaml\n+language: rust\n+rust:\n+  - nightly\n+before_script:\n+   - rustup component add clippy --toolchain=nightly || cargo install --git https://github.com/rust-lang/rust-clippy/ --force clippy\n+   # etc.\n+```\n+\n+Note that adding `-D warnings` will cause your build to fail if **any** warnings are found in your code.\n+That includes warnings found by rustc (e.g. `dead_code`, etc.). If you want to avoid this and only cause\n+an error for Clippy warnings, use `#![deny(clippy::all)]` in your code or `-D clippy::all` on the command\n+line. (You can swap `clippy::all` with the specific lint category you are targeting.)\n+\n+## Configuration\n+\n+Some lints can be configured in a TOML file named `clippy.toml` or `.clippy.toml`. It contains a basic `variable =\n+value` mapping eg.\n+\n+```toml\n+blacklisted-names = [\"toto\", \"tata\", \"titi\"]\n+cognitive-complexity-threshold = 30\n+```\n+\n+See the [list of lints](https://rust-lang.github.io/rust-clippy/master/index.html) for more information about which\n+lints can be configured and the meaning of the variables.\n+\n+To deactivate the \u201cfor further information visit *lint-link*\u201d message you can\n+define the `CLIPPY_DISABLE_DOCS_LINKS` environment variable.\n+\n+### Allowing/denying lints\n+\n+You can add options to your code to `allow`/`warn`/`deny` Clippy lints:\n+\n+*   the whole set of `Warn` lints using the `clippy` lint group (`#![deny(clippy::all)]`)\n+\n+*   all lints using both the `clippy` and `clippy::pedantic` lint groups (`#![deny(clippy::all)]`,\n+    `#![deny(clippy::pedantic)]`). Note that `clippy::pedantic` contains some very aggressive\n+    lints prone to false positives.\n+\n+*   only some lints (`#![deny(clippy::single_match, clippy::box_vec)]`, etc.)\n+\n+*   `allow`/`warn`/`deny` can be limited to a single function or module using `#[allow(...)]`, etc.\n+\n+Note: `deny` produces errors instead of warnings.\n+\n+If you do not want to include your lint levels in your code, you can globally enable/disable lints by passing extra\n+flags to Clippy during the run: `cargo clippy -- -A clippy::lint_name` will run Clippy with `lint_name` disabled and\n+`cargo clippy -- -W clippy::lint_name` will run it with that enabled. This also works with lint groups. For example you\n+can run Clippy with warnings for all lints enabled: `cargo clippy -- -W clippy::pedantic`\n+If you care only about a single lint, you can allow all others and then explicitly reenable\n+the lint(s) you are interested in: `cargo clippy -- -Aclippy::all -Wclippy::useless_format -Wclippy::...`\n+\n+## Contributing\n+\n+If you want to contribute to Clippy, you can find more information in [CONTRIBUTING.md](https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md).\n+\n+## License\n+\n+Copyright 2014-2020 The Rust Project Developers\n+\n+Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+[https://www.apache.org/licenses/LICENSE-2.0](https://www.apache.org/licenses/LICENSE-2.0)> or the MIT license\n+<LICENSE-MIT or [https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT)>, at your\n+option. Files in the project may not be\n+copied, modified, or distributed except according to those terms."}, {"sha": "018375dbada874db7ddb8fc908222da41b83a1df", "filename": "src/tools/clippy/build.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbuild.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,19 @@\n+fn main() {\n+    // Forward the profile to the main compilation\n+    println!(\"cargo:rustc-env=PROFILE={}\", std::env::var(\"PROFILE\").unwrap());\n+    // Don't rebuild even if nothing changed\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    // forward git repo hashes we build at\n+    println!(\n+        \"cargo:rustc-env=GIT_HASH={}\",\n+        rustc_tools_util::get_commit_hash().unwrap_or_default()\n+    );\n+    println!(\n+        \"cargo:rustc-env=COMMIT_DATE={}\",\n+        rustc_tools_util::get_commit_date().unwrap_or_default()\n+    );\n+    println!(\n+        \"cargo:rustc-env=RUSTC_RELEASE_CHANNEL={}\",\n+        rustc_tools_util::get_channel().unwrap_or_default()\n+    );\n+}"}, {"sha": "c861efc8afb5032e42c0a8592a0eb1ff26c5e6a6", "filename": "src/tools/clippy/clippy_dev/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+name = \"clippy_dev\"\n+version = \"0.0.1\"\n+authors = [\"Philipp Hansch <dev@phansch.net>\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+bytecount = \"0.6\"\n+clap = \"2.33\"\n+itertools = \"0.9\"\n+regex = \"1\"\n+lazy_static = \"1.0\"\n+shell-escape = \"0.1\"\n+walkdir = \"2\"\n+\n+[features]\n+deny-warnings = []"}, {"sha": "6ae3f58c1f2ada5a24893ee825872c9cfa1d8c2d", "filename": "src/tools/clippy/clippy_dev/src/fmt.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,175 @@\n+use crate::clippy_project_root;\n+use shell_escape::escape;\n+use std::ffi::OsStr;\n+use std::io;\n+use std::path::Path;\n+use std::process::{self, Command};\n+use walkdir::WalkDir;\n+\n+#[derive(Debug)]\n+pub enum CliError {\n+    CommandFailed(String),\n+    IoError(io::Error),\n+    RustfmtNotInstalled,\n+    WalkDirError(walkdir::Error),\n+}\n+\n+impl From<io::Error> for CliError {\n+    fn from(error: io::Error) -> Self {\n+        Self::IoError(error)\n+    }\n+}\n+\n+impl From<walkdir::Error> for CliError {\n+    fn from(error: walkdir::Error) -> Self {\n+        Self::WalkDirError(error)\n+    }\n+}\n+\n+struct FmtContext {\n+    check: bool,\n+    verbose: bool,\n+}\n+\n+pub fn run(check: bool, verbose: bool) {\n+    fn try_run(context: &FmtContext) -> Result<bool, CliError> {\n+        let mut success = true;\n+\n+        let project_root = clippy_project_root();\n+\n+        rustfmt_test(context)?;\n+\n+        success &= cargo_fmt(context, project_root.as_path())?;\n+        success &= cargo_fmt(context, &project_root.join(\"clippy_dev\"))?;\n+        success &= cargo_fmt(context, &project_root.join(\"rustc_tools_util\"))?;\n+\n+        for entry in WalkDir::new(project_root.join(\"tests\")) {\n+            let entry = entry?;\n+            let path = entry.path();\n+\n+            if path.extension() != Some(\"rs\".as_ref())\n+                || entry.file_name() == \"ice-3891.rs\"\n+                // Avoid rustfmt bug rust-lang/rustfmt#1873\n+                || cfg!(windows) && entry.file_name() == \"implicit_hasher.rs\"\n+            {\n+                continue;\n+            }\n+\n+            success &= rustfmt(context, &path)?;\n+        }\n+\n+        Ok(success)\n+    }\n+\n+    fn output_err(err: CliError) {\n+        match err {\n+            CliError::CommandFailed(command) => {\n+                eprintln!(\"error: A command failed! `{}`\", command);\n+            },\n+            CliError::IoError(err) => {\n+                eprintln!(\"error: {}\", err);\n+            },\n+            CliError::RustfmtNotInstalled => {\n+                eprintln!(\"error: rustfmt nightly is not installed.\");\n+            },\n+            CliError::WalkDirError(err) => {\n+                eprintln!(\"error: {}\", err);\n+            },\n+        }\n+    }\n+\n+    let context = FmtContext { check, verbose };\n+    let result = try_run(&context);\n+    let code = match result {\n+        Ok(true) => 0,\n+        Ok(false) => {\n+            eprintln!();\n+            eprintln!(\"Formatting check failed.\");\n+            eprintln!(\"Run `cargo dev fmt` to update formatting.\");\n+            1\n+        },\n+        Err(err) => {\n+            output_err(err);\n+            1\n+        },\n+    };\n+    process::exit(code);\n+}\n+\n+fn format_command(program: impl AsRef<OsStr>, dir: impl AsRef<Path>, args: &[impl AsRef<OsStr>]) -> String {\n+    let arg_display: Vec<_> = args.iter().map(|a| escape(a.as_ref().to_string_lossy())).collect();\n+\n+    format!(\n+        \"cd {} && {} {}\",\n+        escape(dir.as_ref().to_string_lossy()),\n+        escape(program.as_ref().to_string_lossy()),\n+        arg_display.join(\" \")\n+    )\n+}\n+\n+fn exec(\n+    context: &FmtContext,\n+    program: impl AsRef<OsStr>,\n+    dir: impl AsRef<Path>,\n+    args: &[impl AsRef<OsStr>],\n+) -> Result<bool, CliError> {\n+    if context.verbose {\n+        println!(\"{}\", format_command(&program, &dir, args));\n+    }\n+\n+    let mut child = Command::new(&program).current_dir(&dir).args(args.iter()).spawn()?;\n+    let code = child.wait()?;\n+    let success = code.success();\n+\n+    if !context.check && !success {\n+        return Err(CliError::CommandFailed(format_command(&program, &dir, args)));\n+    }\n+\n+    Ok(success)\n+}\n+\n+fn cargo_fmt(context: &FmtContext, path: &Path) -> Result<bool, CliError> {\n+    let mut args = vec![\"+nightly\", \"fmt\", \"--all\"];\n+    if context.check {\n+        args.push(\"--\");\n+        args.push(\"--check\");\n+    }\n+    let success = exec(context, \"cargo\", path, &args)?;\n+\n+    Ok(success)\n+}\n+\n+fn rustfmt_test(context: &FmtContext) -> Result<(), CliError> {\n+    let program = \"rustfmt\";\n+    let dir = std::env::current_dir()?;\n+    let args = &[\"+nightly\", \"--version\"];\n+\n+    if context.verbose {\n+        println!(\"{}\", format_command(&program, &dir, args));\n+    }\n+\n+    let output = Command::new(&program).current_dir(&dir).args(args.iter()).output()?;\n+\n+    if output.status.success() {\n+        Ok(())\n+    } else if std::str::from_utf8(&output.stderr)\n+        .unwrap_or(\"\")\n+        .starts_with(\"error: 'rustfmt' is not installed\")\n+    {\n+        Err(CliError::RustfmtNotInstalled)\n+    } else {\n+        Err(CliError::CommandFailed(format_command(&program, &dir, args)))\n+    }\n+}\n+\n+fn rustfmt(context: &FmtContext, path: &Path) -> Result<bool, CliError> {\n+    let mut args = vec![\"+nightly\".as_ref(), path.as_os_str()];\n+    if context.check {\n+        args.push(\"--check\".as_ref());\n+    }\n+    let success = exec(context, \"rustfmt\", std::env::current_dir()?, &args)?;\n+    if !success {\n+        eprintln!(\"rustfmt failed on {}\", path.display());\n+    }\n+    Ok(success)\n+}"}, {"sha": "6fdd282c6849e0a1ec511de5fae54ceb3f343102", "filename": "src/tools/clippy/clippy_dev/src/lib.rs", "status": "added", "additions": 524, "deletions": 0, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,524 @@\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+\n+use itertools::Itertools;\n+use lazy_static::lazy_static;\n+use regex::Regex;\n+use std::collections::HashMap;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use walkdir::WalkDir;\n+\n+pub mod fmt;\n+pub mod new_lint;\n+pub mod stderr_length_check;\n+pub mod update_lints;\n+\n+lazy_static! {\n+    static ref DEC_CLIPPY_LINT_RE: Regex = Regex::new(\n+        r#\"(?x)\n+        declare_clippy_lint!\\s*[\\{(]\n+        (?:\\s+///.*)*\n+        \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n+        (?P<cat>[a-z_]+)\\s*,\\s*\n+        \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n+    \"#\n+    )\n+    .unwrap();\n+    static ref DEC_DEPRECATED_LINT_RE: Regex = Regex::new(\n+        r#\"(?x)\n+        declare_deprecated_lint!\\s*[{(]\\s*\n+        (?:\\s+///.*)*\n+        \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n+        \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n+    \"#\n+    )\n+    .unwrap();\n+    static ref NL_ESCAPE_RE: Regex = Regex::new(r#\"\\\\\\n\\s*\"#).unwrap();\n+}\n+\n+pub static DOCS_LINK: &str = \"https://rust-lang.github.io/rust-clippy/master/index.html\";\n+\n+/// Lint data parsed from the Clippy source code.\n+#[derive(Clone, PartialEq, Debug)]\n+pub struct Lint {\n+    pub name: String,\n+    pub group: String,\n+    pub desc: String,\n+    pub deprecation: Option<String>,\n+    pub module: String,\n+}\n+\n+impl Lint {\n+    #[must_use]\n+    pub fn new(name: &str, group: &str, desc: &str, deprecation: Option<&str>, module: &str) -> Self {\n+        Self {\n+            name: name.to_lowercase(),\n+            group: group.to_string(),\n+            desc: NL_ESCAPE_RE.replace(&desc.replace(\"\\\\\\\"\", \"\\\"\"), \"\").to_string(),\n+            deprecation: deprecation.map(ToString::to_string),\n+            module: module.to_string(),\n+        }\n+    }\n+\n+    /// Returns all non-deprecated lints and non-internal lints\n+    #[must_use]\n+    pub fn usable_lints(lints: &[Self]) -> Vec<Self> {\n+        lints\n+            .iter()\n+            .filter(|l| l.deprecation.is_none() && !l.group.starts_with(\"internal\"))\n+            .cloned()\n+            .collect()\n+    }\n+\n+    /// Returns all internal lints (not `internal_warn` lints)\n+    #[must_use]\n+    pub fn internal_lints(lints: &[Self]) -> Vec<Self> {\n+        lints.iter().filter(|l| l.group == \"internal\").cloned().collect()\n+    }\n+\n+    /// Returns all deprecated lints\n+    #[must_use]\n+    pub fn deprecated_lints(lints: &[Self]) -> Vec<Self> {\n+        lints.iter().filter(|l| l.deprecation.is_some()).cloned().collect()\n+    }\n+\n+    /// Returns the lints in a `HashMap`, grouped by the different lint groups\n+    #[must_use]\n+    pub fn by_lint_group(lints: impl Iterator<Item = Self>) -> HashMap<String, Vec<Self>> {\n+        lints.map(|lint| (lint.group.to_string(), lint)).into_group_map()\n+    }\n+}\n+\n+/// Generates the Vec items for `register_lint_group` calls in `clippy_lints/src/lib.rs`.\n+#[must_use]\n+pub fn gen_lint_group_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n+    lints\n+        .map(|l| format!(\"        LintId::of(&{}::{}),\", l.module, l.name.to_uppercase()))\n+        .sorted()\n+        .collect::<Vec<String>>()\n+}\n+\n+/// Generates the `pub mod module_name` list in `clippy_lints/src/lib.rs`.\n+#[must_use]\n+pub fn gen_modules_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n+    lints\n+        .map(|l| &l.module)\n+        .unique()\n+        .map(|module| format!(\"mod {};\", module))\n+        .sorted()\n+        .collect::<Vec<String>>()\n+}\n+\n+/// Generates the list of lint links at the bottom of the README\n+#[must_use]\n+pub fn gen_changelog_lint_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n+    lints\n+        .sorted_by_key(|l| &l.name)\n+        .map(|l| format!(\"[`{}`]: {}#{}\", l.name, DOCS_LINK, l.name))\n+        .collect()\n+}\n+\n+/// Generates the `register_removed` code in `./clippy_lints/src/lib.rs`.\n+#[must_use]\n+pub fn gen_deprecated<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n+    lints\n+        .flat_map(|l| {\n+            l.deprecation\n+                .clone()\n+                .map(|depr_text| {\n+                    vec![\n+                        \"    store.register_removed(\".to_string(),\n+                        format!(\"        \\\"clippy::{}\\\",\", l.name),\n+                        format!(\"        \\\"{}\\\",\", depr_text),\n+                        \"    );\".to_string(),\n+                    ]\n+                })\n+                .expect(\"only deprecated lints should be passed\")\n+        })\n+        .collect::<Vec<String>>()\n+}\n+\n+#[must_use]\n+pub fn gen_register_lint_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n+    let pre = \"    store.register_lints(&[\".to_string();\n+    let post = \"    ]);\".to_string();\n+    let mut inner = lints\n+        .map(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n+        .sorted()\n+        .collect::<Vec<String>>();\n+    inner.insert(0, pre);\n+    inner.push(post);\n+    inner\n+}\n+\n+/// Gathers all files in `src/clippy_lints` and gathers all lints inside\n+pub fn gather_all() -> impl Iterator<Item = Lint> {\n+    lint_files().flat_map(|f| gather_from_file(&f))\n+}\n+\n+fn gather_from_file(dir_entry: &walkdir::DirEntry) -> impl Iterator<Item = Lint> {\n+    let content = fs::read_to_string(dir_entry.path()).unwrap();\n+    let path = dir_entry.path();\n+    let filename = path.file_stem().unwrap();\n+    let path_buf = path.with_file_name(filename);\n+    let mut rel_path = path_buf\n+        .strip_prefix(clippy_project_root().join(\"clippy_lints/src\"))\n+        .expect(\"only files in `clippy_lints/src` should be looked at\");\n+    // If the lints are stored in mod.rs, we get the module name from\n+    // the containing directory:\n+    if filename == \"mod\" {\n+        rel_path = rel_path.parent().unwrap();\n+    }\n+\n+    let module = rel_path\n+        .components()\n+        .map(|c| c.as_os_str().to_str().unwrap())\n+        .collect::<Vec<_>>()\n+        .join(\"::\");\n+\n+    parse_contents(&content, &module)\n+}\n+\n+fn parse_contents(content: &str, module: &str) -> impl Iterator<Item = Lint> {\n+    let lints = DEC_CLIPPY_LINT_RE\n+        .captures_iter(content)\n+        .map(|m| Lint::new(&m[\"name\"], &m[\"cat\"], &m[\"desc\"], None, module));\n+    let deprecated = DEC_DEPRECATED_LINT_RE\n+        .captures_iter(content)\n+        .map(|m| Lint::new(&m[\"name\"], \"Deprecated\", &m[\"desc\"], Some(&m[\"desc\"]), module));\n+    // Removing the `.collect::<Vec<Lint>>().into_iter()` causes some lifetime issues due to the map\n+    lints.chain(deprecated).collect::<Vec<Lint>>().into_iter()\n+}\n+\n+/// Collects all .rs files in the `clippy_lints/src` directory\n+fn lint_files() -> impl Iterator<Item = walkdir::DirEntry> {\n+    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n+    // Otherwise we would not collect all the lints, for example in `clippy_lints/src/methods/`.\n+    let path = clippy_project_root().join(\"clippy_lints/src\");\n+    WalkDir::new(path)\n+        .into_iter()\n+        .filter_map(Result::ok)\n+        .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n+}\n+\n+/// Whether a file has had its text changed or not\n+#[derive(PartialEq, Debug)]\n+pub struct FileChange {\n+    pub changed: bool,\n+    pub new_lines: String,\n+}\n+\n+/// Replaces a region in a file delimited by two lines matching regexes.\n+///\n+/// `path` is the relative path to the file on which you want to perform the replacement.\n+///\n+/// See `replace_region_in_text` for documentation of the other options.\n+pub fn replace_region_in_file<F>(\n+    path: &Path,\n+    start: &str,\n+    end: &str,\n+    replace_start: bool,\n+    write_back: bool,\n+    replacements: F,\n+) -> FileChange\n+where\n+    F: FnOnce() -> Vec<String>,\n+{\n+    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from {}: {}\", path.display(), e));\n+    let file_change = replace_region_in_text(&contents, start, end, replace_start, replacements);\n+\n+    if write_back {\n+        if let Err(e) = fs::write(path, file_change.new_lines.as_bytes()) {\n+            panic!(\"Cannot write to {}: {}\", path.display(), e);\n+        }\n+    }\n+    file_change\n+}\n+\n+/// Replaces a region in a text delimited by two lines matching regexes.\n+///\n+/// * `text` is the input text on which you want to perform the replacement\n+/// * `start` is a `&str` that describes the delimiter line before the region you want to replace.\n+///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n+/// * `end` is a `&str` that describes the delimiter line until where the replacement should happen.\n+///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n+/// * If `replace_start` is true, the `start` delimiter line is replaced as well. The `end`\n+///   delimiter line is never replaced.\n+/// * `replacements` is a closure that has to return a `Vec<String>` which contains the new text.\n+///\n+/// If you want to perform the replacement on files instead of already parsed text,\n+/// use `replace_region_in_file`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let the_text = \"replace_start\\nsome text\\nthat will be replaced\\nreplace_end\";\n+/// let result =\n+///     clippy_dev::replace_region_in_text(the_text, \"replace_start\", \"replace_end\", false, || {\n+///         vec![\"a different\".to_string(), \"text\".to_string()]\n+///     })\n+///     .new_lines;\n+/// assert_eq!(\"replace_start\\na different\\ntext\\nreplace_end\", result);\n+/// ```\n+pub fn replace_region_in_text<F>(text: &str, start: &str, end: &str, replace_start: bool, replacements: F) -> FileChange\n+where\n+    F: FnOnce() -> Vec<String>,\n+{\n+    let replace_it = replacements();\n+    let mut in_old_region = false;\n+    let mut found = false;\n+    let mut new_lines = vec![];\n+    let start = Regex::new(start).unwrap();\n+    let end = Regex::new(end).unwrap();\n+\n+    for line in text.lines() {\n+        if in_old_region {\n+            if end.is_match(line) {\n+                in_old_region = false;\n+                new_lines.extend(replace_it.clone());\n+                new_lines.push(line.to_string());\n+            }\n+        } else if start.is_match(line) {\n+            if !replace_start {\n+                new_lines.push(line.to_string());\n+            }\n+            in_old_region = true;\n+            found = true;\n+        } else {\n+            new_lines.push(line.to_string());\n+        }\n+    }\n+\n+    if !found {\n+        // This happens if the provided regex in `clippy_dev/src/main.rs` does not match in the\n+        // given text or file. Most likely this is an error on the programmer's side and the Regex\n+        // is incorrect.\n+        eprintln!(\"error: regex \\n{:?}\\ndoesn't match. You may have to update it.\", start);\n+        std::process::exit(1);\n+    }\n+\n+    let mut new_lines = new_lines.join(\"\\n\");\n+    if text.ends_with('\\n') {\n+        new_lines.push('\\n');\n+    }\n+    let changed = new_lines != text;\n+    FileChange { changed, new_lines }\n+}\n+\n+/// Returns the path to the Clippy project directory\n+#[must_use]\n+pub fn clippy_project_root() -> PathBuf {\n+    let current_dir = std::env::current_dir().unwrap();\n+    for path in current_dir.ancestors() {\n+        let result = std::fs::read_to_string(path.join(\"Cargo.toml\"));\n+        if let Err(err) = &result {\n+            if err.kind() == std::io::ErrorKind::NotFound {\n+                continue;\n+            }\n+        }\n+\n+        let content = result.unwrap();\n+        if content.contains(\"[package]\\nname = \\\"clippy\\\"\") {\n+            return path.to_path_buf();\n+        }\n+    }\n+    panic!(\"error: Can't determine root of project. Please run inside a Clippy working dir.\");\n+}\n+\n+#[test]\n+fn test_parse_contents() {\n+    let result: Vec<Lint> = parse_contents(\n+        r#\"\n+declare_clippy_lint! {\n+    pub PTR_ARG,\n+    style,\n+    \"really long \\\n+     text\"\n+}\n+\n+declare_clippy_lint!{\n+    pub DOC_MARKDOWN,\n+    pedantic,\n+    \"single line\"\n+}\n+\n+/// some doc comment\n+declare_deprecated_lint! {\n+    pub SHOULD_ASSERT_EQ,\n+    \"`assert!()` will be more flexible with RFC 2011\"\n+}\n+    \"#,\n+        \"module_name\",\n+    )\n+    .collect();\n+\n+    let expected = vec![\n+        Lint::new(\"ptr_arg\", \"style\", \"really long text\", None, \"module_name\"),\n+        Lint::new(\"doc_markdown\", \"pedantic\", \"single line\", None, \"module_name\"),\n+        Lint::new(\n+            \"should_assert_eq\",\n+            \"Deprecated\",\n+            \"`assert!()` will be more flexible with RFC 2011\",\n+            Some(\"`assert!()` will be more flexible with RFC 2011\"),\n+            \"module_name\",\n+        ),\n+    ];\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_replace_region() {\n+    let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n+    let expected = FileChange {\n+        changed: true,\n+        new_lines: \"\\nabc\\nhello world\\ndef\\nghi\".to_string(),\n+    };\n+    let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, false, || {\n+        vec![\"hello world\".to_string()]\n+    });\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_replace_region_with_start() {\n+    let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n+    let expected = FileChange {\n+        changed: true,\n+        new_lines: \"\\nhello world\\ndef\\nghi\".to_string(),\n+    };\n+    let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, true, || {\n+        vec![\"hello world\".to_string()]\n+    });\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_replace_region_no_changes() {\n+    let text = \"123\\n456\\n789\";\n+    let expected = FileChange {\n+        changed: false,\n+        new_lines: \"123\\n456\\n789\".to_string(),\n+    };\n+    let result = replace_region_in_text(text, r#\"^\\s*123$\"#, r#\"^\\s*456\"#, false, || vec![]);\n+    assert_eq!(expected, result);\n+}\n+\n+#[test]\n+fn test_usable_lints() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"Deprecated\", \"abc\", Some(\"Reason\"), \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"internal\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"internal_style\", \"abc\", None, \"module_name\"),\n+    ];\n+    let expected = vec![Lint::new(\n+        \"should_assert_eq2\",\n+        \"Not Deprecated\",\n+        \"abc\",\n+        None,\n+        \"module_name\",\n+    )];\n+    assert_eq!(expected, Lint::usable_lints(&lints));\n+}\n+\n+#[test]\n+fn test_by_lint_group() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n+    ];\n+    let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n+    expected.insert(\n+        \"group1\".to_string(),\n+        vec![\n+            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+            Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n+        ],\n+    );\n+    expected.insert(\n+        \"group2\".to_string(),\n+        vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")],\n+    );\n+    assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n+}\n+\n+#[test]\n+fn test_gen_changelog_lint_list() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n+    ];\n+    let expected = vec![\n+        format!(\"[`should_assert_eq`]: {}#should_assert_eq\", DOCS_LINK.to_string()),\n+        format!(\"[`should_assert_eq2`]: {}#should_assert_eq2\", DOCS_LINK.to_string()),\n+    ];\n+    assert_eq!(expected, gen_changelog_lint_list(lints.iter()));\n+}\n+\n+#[test]\n+fn test_gen_deprecated() {\n+    let lints = vec![\n+        Lint::new(\n+            \"should_assert_eq\",\n+            \"group1\",\n+            \"abc\",\n+            Some(\"has been superseded by should_assert_eq2\"),\n+            \"module_name\",\n+        ),\n+        Lint::new(\n+            \"another_deprecated\",\n+            \"group2\",\n+            \"abc\",\n+            Some(\"will be removed\"),\n+            \"module_name\",\n+        ),\n+    ];\n+    let expected: Vec<String> = vec![\n+        \"    store.register_removed(\",\n+        \"        \\\"clippy::should_assert_eq\\\",\",\n+        \"        \\\"has been superseded by should_assert_eq2\\\",\",\n+        \"    );\",\n+        \"    store.register_removed(\",\n+        \"        \\\"clippy::another_deprecated\\\",\",\n+        \"        \\\"will be removed\\\",\",\n+        \"    );\",\n+    ]\n+    .into_iter()\n+    .map(String::from)\n+    .collect();\n+    assert_eq!(expected, gen_deprecated(lints.iter()));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_gen_deprecated_fail() {\n+    let lints = vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")];\n+    let _ = gen_deprecated(lints.iter());\n+}\n+\n+#[test]\n+fn test_gen_modules_list() {\n+    let lints = vec![\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"incorrect_stuff\", \"group3\", \"abc\", None, \"another_module\"),\n+    ];\n+    let expected = vec![\"mod another_module;\".to_string(), \"mod module_name;\".to_string()];\n+    assert_eq!(expected, gen_modules_list(lints.iter()));\n+}\n+\n+#[test]\n+fn test_gen_lint_group_list() {\n+    let lints = vec![\n+        Lint::new(\"abc\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n+        Lint::new(\"internal\", \"internal_style\", \"abc\", None, \"module_name\"),\n+    ];\n+    let expected = vec![\n+        \"        LintId::of(&module_name::ABC),\".to_string(),\n+        \"        LintId::of(&module_name::INTERNAL),\".to_string(),\n+        \"        LintId::of(&module_name::SHOULD_ASSERT_EQ),\".to_string(),\n+    ];\n+    assert_eq!(expected, gen_lint_group_list(lints.iter()));\n+}"}, {"sha": "d99235f7c07a7cf649498f5266468fdd89b49cfb", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,120 @@\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+\n+use clap::{App, Arg, SubCommand};\n+use clippy_dev::{fmt, new_lint, stderr_length_check, update_lints};\n+\n+fn main() {\n+    let matches = App::new(\"Clippy developer tooling\")\n+        .subcommand(\n+            SubCommand::with_name(\"fmt\")\n+                .about(\"Run rustfmt on all projects and tests\")\n+                .arg(\n+                    Arg::with_name(\"check\")\n+                        .long(\"check\")\n+                        .help(\"Use the rustfmt --check option\"),\n+                )\n+                .arg(\n+                    Arg::with_name(\"verbose\")\n+                        .short(\"v\")\n+                        .long(\"verbose\")\n+                        .help(\"Echo commands run\"),\n+                ),\n+        )\n+        .subcommand(\n+            SubCommand::with_name(\"update_lints\")\n+                .about(\"Updates lint registration and information from the source code\")\n+                .long_about(\n+                    \"Makes sure that:\\n \\\n+                     * the lint count in README.md is correct\\n \\\n+                     * the changelog contains markdown link references at the bottom\\n \\\n+                     * all lint groups include the correct lints\\n \\\n+                     * lint modules in `clippy_lints/*` are visible in `src/lib.rs` via `pub mod`\\n \\\n+                     * all lints are registered in the lint store\",\n+                )\n+                .arg(Arg::with_name(\"print-only\").long(\"print-only\").help(\n+                    \"Print a table of lints to STDOUT. \\\n+                     This does not include deprecated and internal lints. \\\n+                     (Does not modify any files)\",\n+                ))\n+                .arg(\n+                    Arg::with_name(\"check\")\n+                        .long(\"check\")\n+                        .help(\"Checks that `cargo dev update_lints` has been run. Used on CI.\"),\n+                ),\n+        )\n+        .subcommand(\n+            SubCommand::with_name(\"new_lint\")\n+                .about(\"Create new lint and run `cargo dev update_lints`\")\n+                .arg(\n+                    Arg::with_name(\"pass\")\n+                        .short(\"p\")\n+                        .long(\"pass\")\n+                        .help(\"Specify whether the lint runs during the early or late pass\")\n+                        .takes_value(true)\n+                        .possible_values(&[\"early\", \"late\"])\n+                        .required(true),\n+                )\n+                .arg(\n+                    Arg::with_name(\"name\")\n+                        .short(\"n\")\n+                        .long(\"name\")\n+                        .help(\"Name of the new lint in snake case, ex: fn_too_long\")\n+                        .takes_value(true)\n+                        .required(true),\n+                )\n+                .arg(\n+                    Arg::with_name(\"category\")\n+                        .short(\"c\")\n+                        .long(\"category\")\n+                        .help(\"What category the lint belongs to\")\n+                        .default_value(\"nursery\")\n+                        .possible_values(&[\n+                            \"style\",\n+                            \"correctness\",\n+                            \"complexity\",\n+                            \"perf\",\n+                            \"pedantic\",\n+                            \"restriction\",\n+                            \"cargo\",\n+                            \"nursery\",\n+                            \"internal\",\n+                            \"internal_warn\",\n+                        ])\n+                        .takes_value(true),\n+                ),\n+        )\n+        .subcommand(\n+            SubCommand::with_name(\"limit_stderr_length\")\n+                .about(\"Ensures that stderr files do not grow longer than a certain amount of lines.\"),\n+        )\n+        .get_matches();\n+\n+    match matches.subcommand() {\n+        (\"fmt\", Some(matches)) => {\n+            fmt::run(matches.is_present(\"check\"), matches.is_present(\"verbose\"));\n+        },\n+        (\"update_lints\", Some(matches)) => {\n+            if matches.is_present(\"print-only\") {\n+                update_lints::print_lints();\n+            } else if matches.is_present(\"check\") {\n+                update_lints::run(update_lints::UpdateMode::Check);\n+            } else {\n+                update_lints::run(update_lints::UpdateMode::Change);\n+            }\n+        },\n+        (\"new_lint\", Some(matches)) => {\n+            match new_lint::create(\n+                matches.value_of(\"pass\"),\n+                matches.value_of(\"name\"),\n+                matches.value_of(\"category\"),\n+            ) {\n+                Ok(_) => update_lints::run(update_lints::UpdateMode::Change),\n+                Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n+            }\n+        },\n+        (\"limit_stderr_length\", _) => {\n+            stderr_length_check::check();\n+        },\n+        _ => {},\n+    }\n+}"}, {"sha": "44b2a5383d2113f367c1a6262e351b236ea33e16", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,177 @@\n+use crate::clippy_project_root;\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::io::prelude::*;\n+use std::io::ErrorKind;\n+use std::path::Path;\n+\n+/// Creates files required to implement and test a new lint and runs `update_lints`.\n+///\n+/// # Errors\n+///\n+/// This function errors, if the files couldn't be created\n+pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str>) -> Result<(), io::Error> {\n+    let pass = pass.expect(\"`pass` argument is validated by clap\");\n+    let lint_name = lint_name.expect(\"`name` argument is validated by clap\");\n+    let category = category.expect(\"`category` argument is validated by clap\");\n+\n+    match open_files(lint_name) {\n+        Ok((mut test_file, mut lint_file)) => {\n+            let (pass_type, pass_lifetimes, pass_import, context_import) = match pass {\n+                \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n+                \"late\" => (\"LateLintPass\", \"<'_, '_>\", \"use rustc_hir::*;\", \"LateContext\"),\n+                _ => {\n+                    unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n+                },\n+            };\n+\n+            let camel_case_name = to_camel_case(lint_name);\n+\n+            if let Err(e) = test_file.write_all(get_test_file_contents(lint_name).as_bytes()) {\n+                return Err(io::Error::new(\n+                    ErrorKind::Other,\n+                    format!(\"Could not write to test file: {}\", e),\n+                ));\n+            };\n+\n+            if let Err(e) = lint_file.write_all(\n+                get_lint_file_contents(\n+                    pass_type,\n+                    pass_lifetimes,\n+                    lint_name,\n+                    &camel_case_name,\n+                    category,\n+                    pass_import,\n+                    context_import,\n+                )\n+                .as_bytes(),\n+            ) {\n+                return Err(io::Error::new(\n+                    ErrorKind::Other,\n+                    format!(\"Could not write to lint file: {}\", e),\n+                ));\n+            }\n+            Ok(())\n+        },\n+        Err(e) => Err(io::Error::new(\n+            ErrorKind::Other,\n+            format!(\"Unable to create lint: {}\", e),\n+        )),\n+    }\n+}\n+\n+fn open_files(lint_name: &str) -> Result<(File, File), io::Error> {\n+    let project_root = clippy_project_root();\n+\n+    let test_file_path = project_root.join(\"tests\").join(\"ui\").join(format!(\"{}.rs\", lint_name));\n+    let lint_file_path = project_root\n+        .join(\"clippy_lints\")\n+        .join(\"src\")\n+        .join(format!(\"{}.rs\", lint_name));\n+\n+    if Path::new(&test_file_path).exists() {\n+        return Err(io::Error::new(\n+            ErrorKind::AlreadyExists,\n+            format!(\"test file {:?} already exists\", test_file_path),\n+        ));\n+    }\n+    if Path::new(&lint_file_path).exists() {\n+        return Err(io::Error::new(\n+            ErrorKind::AlreadyExists,\n+            format!(\"lint file {:?} already exists\", lint_file_path),\n+        ));\n+    }\n+\n+    let test_file = OpenOptions::new().write(true).create_new(true).open(test_file_path)?;\n+    let lint_file = OpenOptions::new().write(true).create_new(true).open(lint_file_path)?;\n+\n+    Ok((test_file, lint_file))\n+}\n+\n+fn to_camel_case(name: &str) -> String {\n+    name.split('_')\n+        .map(|s| {\n+            if s.is_empty() {\n+                String::from(\"\")\n+            } else {\n+                [&s[0..1].to_uppercase(), &s[1..]].concat()\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn get_test_file_contents(lint_name: &str) -> String {\n+    format!(\n+        \"#![warn(clippy::{})]\n+\n+fn main() {{\n+    // test code goes here\n+}}\n+\",\n+        lint_name\n+    )\n+}\n+\n+fn get_lint_file_contents(\n+    pass_type: &str,\n+    pass_lifetimes: &str,\n+    lint_name: &str,\n+    camel_case_name: &str,\n+    category: &str,\n+    pass_import: &str,\n+    context_import: &str,\n+) -> String {\n+    format!(\n+        \"use rustc_lint::{{{type}, {context_import}}};\n+use rustc_session::{{declare_lint_pass, declare_tool_lint}};\n+{pass_import}\n+\n+declare_clippy_lint! {{\n+    /// **What it does:**\n+    ///\n+    /// **Why is this bad?**\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // example code where clippy issues a warning\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// // example code which does not raise clippy warning\n+    /// ```\n+    pub {name_upper},\n+    {category},\n+    \\\"default lint description\\\"\n+}}\n+\n+declare_lint_pass!({name_camel} => [{name_upper}]);\n+\n+impl {type}{lifetimes} for {name_camel} {{}}\n+\",\n+        type=pass_type,\n+        lifetimes=pass_lifetimes,\n+        name_upper=lint_name.to_uppercase(),\n+        name_camel=camel_case_name,\n+        category=category,\n+        pass_import=pass_import,\n+        context_import=context_import\n+    )\n+}\n+\n+#[test]\n+fn test_camel_case() {\n+    let s = \"a_lint\";\n+    let s2 = to_camel_case(s);\n+    assert_eq!(s2, \"ALint\");\n+\n+    let name = \"a_really_long_new_lint\";\n+    let name2 = to_camel_case(name);\n+    assert_eq!(name2, \"AReallyLongNewLint\");\n+\n+    let name3 = \"lint__name\";\n+    let name4 = to_camel_case(name3);\n+    assert_eq!(name4, \"LintName\");\n+}"}, {"sha": "e02b6f7da5f7b66e7653403d2f823984eb000ce4", "filename": "src/tools/clippy/clippy_dev/src/stderr_length_check.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fstderr_length_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fstderr_length_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fstderr_length_check.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,51 @@\n+use crate::clippy_project_root;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use walkdir::WalkDir;\n+\n+// The maximum length allowed for stderr files.\n+//\n+// We limit this because small files are easier to deal with than bigger files.\n+const LENGTH_LIMIT: usize = 200;\n+\n+pub fn check() {\n+    let exceeding_files: Vec<_> = exceeding_stderr_files();\n+\n+    if !exceeding_files.is_empty() {\n+        eprintln!(\"Error: stderr files exceeding limit of {} lines:\", LENGTH_LIMIT);\n+        for (path, count) in exceeding_files {\n+            println!(\"{}: {}\", path.display(), count);\n+        }\n+        std::process::exit(1);\n+    }\n+}\n+\n+fn exceeding_stderr_files() -> Vec<(PathBuf, usize)> {\n+    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n+    WalkDir::new(clippy_project_root().join(\"tests/ui\"))\n+        .into_iter()\n+        .filter_map(Result::ok)\n+        .filter(|f| !f.file_type().is_dir())\n+        .filter_map(|e| {\n+            let p = e.into_path();\n+            let count = count_linenumbers(&p);\n+            if p.extension() == Some(OsStr::new(\"stderr\")) && count > LENGTH_LIMIT {\n+                Some((p, count))\n+            } else {\n+                None\n+            }\n+        })\n+        .collect()\n+}\n+\n+#[must_use]\n+fn count_linenumbers(filepath: &Path) -> usize {\n+    match fs::read(filepath) {\n+        Ok(content) => bytecount::count(&content, b'\\n'),\n+        Err(e) => {\n+            eprintln!(\"Failed to read file: {}\", e);\n+            0\n+        },\n+    }\n+}"}, {"sha": "a9a7092994269b7cc84075756d74f0eda57a3af0", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,162 @@\n+use crate::{\n+    gather_all, gen_changelog_lint_list, gen_deprecated, gen_lint_group_list, gen_modules_list, gen_register_lint_list,\n+    replace_region_in_file, Lint, DOCS_LINK,\n+};\n+use std::path::Path;\n+\n+#[derive(Clone, Copy, PartialEq)]\n+pub enum UpdateMode {\n+    Check,\n+    Change,\n+}\n+\n+#[allow(clippy::too_many_lines)]\n+pub fn run(update_mode: UpdateMode) {\n+    let lint_list: Vec<Lint> = gather_all().collect();\n+\n+    let internal_lints = Lint::internal_lints(&lint_list);\n+    let deprecated_lints = Lint::deprecated_lints(&lint_list);\n+    let usable_lints = Lint::usable_lints(&lint_list);\n+    let mut sorted_usable_lints = usable_lints.clone();\n+    sorted_usable_lints.sort_by_key(|lint| lint.name.clone());\n+\n+    let usable_lint_count = round_to_fifty(usable_lints.len());\n+\n+    let mut file_change = replace_region_in_file(\n+        Path::new(\"src/lintlist/mod.rs\"),\n+        \"begin lint list\",\n+        \"end lint list\",\n+        false,\n+        update_mode == UpdateMode::Change,\n+        || {\n+            format!(\"pub static ref ALL_LINTS: Vec<Lint> = vec!{:#?};\", sorted_usable_lints)\n+                .lines()\n+                .map(ToString::to_string)\n+                .collect::<Vec<_>>()\n+        },\n+    )\n+    .changed;\n+\n+    file_change |= replace_region_in_file(\n+        Path::new(\"README.md\"),\n+        &format!(\n+            r#\"\\[There are over \\d+ lints included in this crate!\\]\\({}\\)\"#,\n+            DOCS_LINK\n+        ),\n+        \"\",\n+        true,\n+        update_mode == UpdateMode::Change,\n+        || {\n+            vec![format!(\n+                \"[There are over {} lints included in this crate!]({})\",\n+                usable_lint_count, DOCS_LINK\n+            )]\n+        },\n+    )\n+    .changed;\n+\n+    file_change |= replace_region_in_file(\n+        Path::new(\"CHANGELOG.md\"),\n+        \"<!-- begin autogenerated links to lint list -->\",\n+        \"<!-- end autogenerated links to lint list -->\",\n+        false,\n+        update_mode == UpdateMode::Change,\n+        || gen_changelog_lint_list(usable_lints.iter().chain(deprecated_lints.iter())),\n+    )\n+    .changed;\n+\n+    file_change |= replace_region_in_file(\n+        Path::new(\"clippy_lints/src/lib.rs\"),\n+        \"begin deprecated lints\",\n+        \"end deprecated lints\",\n+        false,\n+        update_mode == UpdateMode::Change,\n+        || gen_deprecated(deprecated_lints.iter()),\n+    )\n+    .changed;\n+\n+    file_change |= replace_region_in_file(\n+        Path::new(\"clippy_lints/src/lib.rs\"),\n+        \"begin register lints\",\n+        \"end register lints\",\n+        false,\n+        update_mode == UpdateMode::Change,\n+        || gen_register_lint_list(usable_lints.iter().chain(internal_lints.iter())),\n+    )\n+    .changed;\n+\n+    file_change |= replace_region_in_file(\n+        Path::new(\"clippy_lints/src/lib.rs\"),\n+        \"begin lints modules\",\n+        \"end lints modules\",\n+        false,\n+        update_mode == UpdateMode::Change,\n+        || gen_modules_list(usable_lints.iter()),\n+    )\n+    .changed;\n+\n+    // Generate lists of lints in the clippy::all lint group\n+    file_change |= replace_region_in_file(\n+        Path::new(\"clippy_lints/src/lib.rs\"),\n+        r#\"store.register_group\\(true, \"clippy::all\"\"#,\n+        r#\"\\]\\);\"#,\n+        false,\n+        update_mode == UpdateMode::Change,\n+        || {\n+            // clippy::all should only include the following lint groups:\n+            let all_group_lints = usable_lints.iter().filter(|l| {\n+                l.group == \"correctness\" || l.group == \"style\" || l.group == \"complexity\" || l.group == \"perf\"\n+            });\n+\n+            gen_lint_group_list(all_group_lints)\n+        },\n+    )\n+    .changed;\n+\n+    // Generate the list of lints for all other lint groups\n+    for (lint_group, lints) in Lint::by_lint_group(usable_lints.into_iter().chain(internal_lints)) {\n+        file_change |= replace_region_in_file(\n+            Path::new(\"clippy_lints/src/lib.rs\"),\n+            &format!(\"store.register_group\\\\(true, \\\"clippy::{}\\\"\", lint_group),\n+            r#\"\\]\\);\"#,\n+            false,\n+            update_mode == UpdateMode::Change,\n+            || gen_lint_group_list(lints.iter()),\n+        )\n+        .changed;\n+    }\n+\n+    if update_mode == UpdateMode::Check && file_change {\n+        println!(\n+            \"Not all lints defined properly. \\\n+             Please run `cargo dev update_lints` to make sure all lints are defined properly.\"\n+        );\n+        std::process::exit(1);\n+    }\n+}\n+\n+pub fn print_lints() {\n+    let lint_list: Vec<Lint> = gather_all().collect();\n+    let usable_lints = Lint::usable_lints(&lint_list);\n+    let usable_lint_count = usable_lints.len();\n+    let grouped_by_lint_group = Lint::by_lint_group(usable_lints.into_iter());\n+\n+    for (lint_group, mut lints) in grouped_by_lint_group {\n+        if lint_group == \"Deprecated\" {\n+            continue;\n+        }\n+        println!(\"\\n## {}\", lint_group);\n+\n+        lints.sort_by_key(|l| l.name.clone());\n+\n+        for lint in lints {\n+            println!(\"* [{}]({}#{}) ({})\", lint.name, DOCS_LINK, lint.name, lint.desc);\n+        }\n+    }\n+\n+    println!(\"there are {} lints\", usable_lint_count);\n+}\n+\n+fn round_to_fifty(count: usize) -> usize {\n+    count / 50 * 50\n+}"}, {"sha": "7b11795fafdc511e6e79e6cbffb9e155bea5901f", "filename": "src/tools/clippy/clippy_dummy/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dummy%2FCargo.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+name = \"clippy_dummy\" # rename to clippy before publishing\n+version = \"0.0.303\"\n+authors = [\"Manish Goregaokar <manishsmail@gmail.com>\"]\n+edition = \"2018\"\n+readme = \"crates-readme.md\"\n+description = \"A bunch of helpful lints to avoid common pitfalls in Rust.\"\n+build = 'build.rs'\n+\n+repository = \"https://github.com/rust-lang/rust-clippy\"\n+\n+license = \"MIT OR Apache-2.0\"\n+keywords = [\"clippy\", \"lint\", \"plugin\"]\n+categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+\n+[build-dependencies]\n+term = \"0.6\""}, {"sha": "8e420ec959a26a85f79d186b922ef698333d3bdf", "filename": "src/tools/clippy/clippy_dummy/PUBLISH.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2FPUBLISH.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2FPUBLISH.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dummy%2FPUBLISH.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,6 @@\n+This is a dummy crate to publish to crates.io. It primarily exists to ensure\n+that folks trying to install clippy from crates.io get redirected to the\n+`rustup` technique.\n+\n+Before publishing, be sure to rename `clippy_dummy` to `clippy` in `Cargo.toml`,\n+it has a different name to avoid workspace issues."}, {"sha": "21af4f8244f44f93d5d2b73c5cde5af59162c8aa", "filename": "src/tools/clippy/clippy_dummy/build.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fbuild.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,42 @@\n+use term::color::{GREEN, RED, WHITE};\n+use term::{Attr, Error, Result};\n+\n+fn main() {\n+    if foo().is_err() {\n+        eprintln!(\n+            \"error: Clippy is no longer available via crates.io\\n\\n\\\n+             help: please run `rustup component add clippy` instead\"\n+        );\n+    }\n+    std::process::exit(1);\n+}\n+\n+fn foo() -> Result<()> {\n+    let mut t = term::stderr().ok_or(Error::NotSupported)?;\n+\n+    t.attr(Attr::Bold)?;\n+    t.fg(RED)?;\n+    write!(t, \"\\nerror: \")?;\n+\n+    t.reset()?;\n+    t.fg(WHITE)?;\n+    writeln!(t, \"Clippy is no longer available via crates.io\\n\")?;\n+\n+    t.attr(Attr::Bold)?;\n+    t.fg(GREEN)?;\n+    write!(t, \"help: \")?;\n+\n+    t.reset()?;\n+    t.fg(WHITE)?;\n+    write!(t, \"please run `\")?;\n+\n+    t.attr(Attr::Bold)?;\n+    write!(t, \"rustup component add clippy\")?;\n+\n+    t.reset()?;\n+    t.fg(WHITE)?;\n+    writeln!(t, \"` instead\")?;\n+\n+    t.reset()?;\n+    Ok(())\n+}"}, {"sha": "0decae8b9103d680516a611f740b5d691ad7abba", "filename": "src/tools/clippy/clippy_dummy/crates-readme.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fcrates-readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fcrates-readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fcrates-readme.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,9 @@\n+Installing clippy via crates.io is deprecated. Please use the following:\n+\n+```terminal\n+rustup component add clippy\n+```\n+\n+on a Rust version 1.29 or later. You may need to run `rustup self update` if it complains about a missing clippy binary.\n+\n+See [the homepage](https://github.com/rust-lang/rust-clippy/#clippy) for more information"}, {"sha": "a118834f1fd47cb1b44ebac6fcdea1456e76b615", "filename": "src/tools/clippy/clippy_dummy/src/main.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dummy%2Fsrc%2Fmain.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    panic!(\"This shouldn't even compile\")\n+}"}, {"sha": "1c0be727834625b54970c77b3209613bcf26c3e5", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,37 @@\n+[package]\n+name = \"clippy_lints\"\n+# begin automatic update\n+version = \"0.0.212\"\n+# end automatic update\n+authors = [\n+\t\"Manish Goregaokar <manishsmail@gmail.com>\",\n+\t\"Andre Bogus <bogusandre@gmail.com>\",\n+\t\"Georg Brandl <georg@python.org>\",\n+\t\"Martin Carton <cartonmartin@gmail.com>\"\n+]\n+description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+repository = \"https://github.com/rust-lang/rust-clippy\"\n+readme = \"README.md\"\n+license = \"MIT OR Apache-2.0\"\n+keywords = [\"clippy\", \"lint\", \"plugin\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+cargo_metadata = \"0.9.0\"\n+if_chain = \"1.0.0\"\n+itertools = \"0.9\"\n+lazy_static = \"1.0.2\"\n+pulldown-cmark = { version = \"0.7\", default-features = false }\n+quine-mc_cluskey = \"0.2.2\"\n+regex-syntax = \"0.6\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+smallvec = { version = \"1\", features = [\"union\"] }\n+toml = \"0.5.3\"\n+unicode-normalization = \"0.1\"\n+semver = \"0.9.0\"\n+# NOTE: cargo requires serde feat in its url dep\n+# see <https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864>\n+url = { version =  \"2.1.0\", features = [\"serde\"] }\n+\n+[features]\n+deny-warnings = []"}, {"sha": "513583b7e349ee689d0a4fa130635cf1ee3a214a", "filename": "src/tools/clippy/clippy_lints/README.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FREADME.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1 @@\n+This crate contains Clippy lints. For the main crate, check [GitHub](https://github.com/rust-lang/rust-clippy)."}, {"sha": "7e6e2c7eaebeaa8cc7bf2bdccdec8accbca3be88", "filename": "src/tools/clippy/clippy_lints/src/approx_const.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,117 @@\n+use crate::utils::span_lint;\n+use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol;\n+use std::f64::consts as f64;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for floating point literals that approximate\n+    /// constants which are defined in\n+    /// [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n+    /// or\n+    /// [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n+    /// respectively, suggesting to use the predefined constant.\n+    ///\n+    /// **Why is this bad?** Usually, the definition in the standard library is more\n+    /// precise than what people come up with. If you find that your definition is\n+    /// actually more precise, please [file a Rust\n+    /// issue](https://github.com/rust-lang/rust/issues).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 3.14;\n+    /// let y = 1_f64 / x;\n+    /// ```\n+    /// Use predefined constants instead:\n+    /// ```rust\n+    /// let x = std::f32::consts::PI;\n+    /// let y = std::f64::consts::FRAC_1_PI;\n+    /// ```\n+    pub APPROX_CONSTANT,\n+    correctness,\n+    \"the approximate of a known float constant (in `std::fXX::consts`)\"\n+}\n+\n+// Tuples are of the form (constant, name, min_digits)\n+const KNOWN_CONSTS: [(f64, &str, usize); 18] = [\n+    (f64::E, \"E\", 4),\n+    (f64::FRAC_1_PI, \"FRAC_1_PI\", 4),\n+    (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\", 5),\n+    (f64::FRAC_2_PI, \"FRAC_2_PI\", 5),\n+    (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\", 5),\n+    (f64::FRAC_PI_2, \"FRAC_PI_2\", 5),\n+    (f64::FRAC_PI_3, \"FRAC_PI_3\", 5),\n+    (f64::FRAC_PI_4, \"FRAC_PI_4\", 5),\n+    (f64::FRAC_PI_6, \"FRAC_PI_6\", 5),\n+    (f64::FRAC_PI_8, \"FRAC_PI_8\", 5),\n+    (f64::LN_10, \"LN_10\", 5),\n+    (f64::LN_2, \"LN_2\", 5),\n+    (f64::LOG10_E, \"LOG10_E\", 5),\n+    (f64::LOG2_E, \"LOG2_E\", 5),\n+    (f64::LOG2_10, \"LOG2_10\", 5),\n+    (f64::LOG10_2, \"LOG10_2\", 5),\n+    (f64::PI, \"PI\", 3),\n+    (f64::SQRT_2, \"SQRT_2\", 5),\n+];\n+\n+declare_lint_pass!(ApproxConstant => [APPROX_CONSTANT]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ApproxConstant {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Lit(lit) = &e.kind {\n+            check_lit(cx, &lit.node, e);\n+        }\n+    }\n+}\n+\n+fn check_lit(cx: &LateContext<'_, '_>, lit: &LitKind, e: &Expr<'_>) {\n+    match *lit {\n+        LitKind::Float(s, LitFloatType::Suffixed(fty)) => match fty {\n+            FloatTy::F32 => check_known_consts(cx, e, s, \"f32\"),\n+            FloatTy::F64 => check_known_consts(cx, e, s, \"f64\"),\n+        },\n+        LitKind::Float(s, LitFloatType::Unsuffixed) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n+        _ => (),\n+    }\n+}\n+\n+fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr<'_>, s: symbol::Symbol, module: &str) {\n+    let s = s.as_str();\n+    if s.parse::<f64>().is_ok() {\n+        for &(constant, name, min_digits) in &KNOWN_CONSTS {\n+            if is_approx_const(constant, &s, min_digits) {\n+                span_lint(\n+                    cx,\n+                    APPROX_CONSTANT,\n+                    e.span,\n+                    &format!(\n+                        \"approximate value of `{}::consts::{}` found. \\\n+                         Consider using it directly\",\n+                        module, &name\n+                    ),\n+                );\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns `false` if the number of significant figures in `value` are\n+/// less than `min_digits`; otherwise, returns true if `value` is equal\n+/// to `constant`, rounded to the number of digits present in `value`.\n+#[must_use]\n+fn is_approx_const(constant: f64, value: &str, min_digits: usize) -> bool {\n+    if value.len() <= min_digits {\n+        false\n+    } else if constant.to_string().starts_with(value) {\n+        // The value is a truncated constant\n+        true\n+    } else {\n+        let round_const = format!(\"{:.*}\", value.len() - 2, constant);\n+        value == round_const\n+    }\n+}"}, {"sha": "6cbe10a5352d1d1cf3b91caccfd3c59f8408c2da", "filename": "src/tools/clippy/clippy_lints/src/arithmetic.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,149 @@\n+use crate::consts::constant_simple;\n+use crate::utils::span_lint;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for integer arithmetic operations which could overflow or panic.\n+    ///\n+    /// Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n+    /// of overflowing according to the [Rust\n+    /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n+    /// or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n+    /// attempted.\n+    ///\n+    /// **Why is this bad?** Integer overflow will trigger a panic in debug builds or will wrap in\n+    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n+    /// wants explicitly checked, wrapping or saturating arithmetic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let a = 0;\n+    /// a + 1;\n+    /// ```\n+    pub INTEGER_ARITHMETIC,\n+    restriction,\n+    \"any integer arithmetic expression which could overflow or panic\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for float arithmetic.\n+    ///\n+    /// **Why is this bad?** For some embedded systems or kernel development, it\n+    /// can be useful to rule out floating-point numbers.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let a = 0.0;\n+    /// a + 1.0;\n+    /// ```\n+    pub FLOAT_ARITHMETIC,\n+    restriction,\n+    \"any floating-point arithmetic statement\"\n+}\n+\n+#[derive(Copy, Clone, Default)]\n+pub struct Arithmetic {\n+    expr_span: Option<Span>,\n+    /// This field is used to check whether expressions are constants, such as in enum discriminants\n+    /// and consts\n+    const_span: Option<Span>,\n+}\n+\n+impl_lint_pass!(Arithmetic => [INTEGER_ARITHMETIC, FLOAT_ARITHMETIC]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if self.expr_span.is_some() {\n+            return;\n+        }\n+\n+        if let Some(span) = self.const_span {\n+            if span.contains(expr.span) {\n+                return;\n+            }\n+        }\n+        match &expr.kind {\n+            hir::ExprKind::Binary(op, l, r) | hir::ExprKind::AssignOp(op, l, r) => {\n+                match op.node {\n+                    hir::BinOpKind::And\n+                    | hir::BinOpKind::Or\n+                    | hir::BinOpKind::BitAnd\n+                    | hir::BinOpKind::BitOr\n+                    | hir::BinOpKind::BitXor\n+                    | hir::BinOpKind::Eq\n+                    | hir::BinOpKind::Lt\n+                    | hir::BinOpKind::Le\n+                    | hir::BinOpKind::Ne\n+                    | hir::BinOpKind::Ge\n+                    | hir::BinOpKind::Gt => return,\n+                    _ => (),\n+                }\n+\n+                let (l_ty, r_ty) = (cx.tables.expr_ty(l), cx.tables.expr_ty(r));\n+                if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n+                    span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                    self.expr_span = Some(expr.span);\n+                } else if l_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n+                    span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+                    self.expr_span = Some(expr.span);\n+                }\n+            },\n+            hir::ExprKind::Unary(hir::UnOp::UnNeg, arg) => {\n+                let ty = cx.tables.expr_ty(arg);\n+                if constant_simple(cx, cx.tables, expr).is_none() {\n+                    if ty.is_integral() {\n+                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                        self.expr_span = Some(expr.span);\n+                    } else if ty.is_floating_point() {\n+                        span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+                        self.expr_span = Some(expr.span);\n+                    }\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if Some(expr.span) == self.expr_span {\n+            self.expr_span = None;\n+        }\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+\n+        match cx.tcx.hir().body_owner_kind(body_owner) {\n+            hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n+                let body_span = cx.tcx.hir().span(body_owner);\n+\n+                if let Some(span) = self.const_span {\n+                    if span.contains(body_span) {\n+                        return;\n+                    }\n+                }\n+                self.const_span = Some(body_span);\n+            },\n+            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => (),\n+        }\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'_, '_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_span = cx.tcx.hir().span(body_owner);\n+\n+        if let Some(span) = self.const_span {\n+            if span.contains(body_span) {\n+                return;\n+            }\n+        }\n+        self.const_span = None;\n+    }\n+}"}, {"sha": "0c8efd755146ec2f03426b0b2f0d8c1950d6e957", "filename": "src/tools/clippy/clippy_lints/src/as_conversions.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,58 @@\n+use rustc_ast::ast::{Expr, ExprKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::span_lint_and_help;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `as` conversions.\n+    ///\n+    /// **Why is this bad?** `as` conversions will perform many kinds of\n+    /// conversions, including silently lossy conversions and dangerous coercions.\n+    /// There are cases when it makes sense to use `as`, so the lint is\n+    /// Allow by default.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let a: u32;\n+    /// ...\n+    /// f(a as u16);\n+    /// ```\n+    ///\n+    /// Usually better represents the semantics you expect:\n+    /// ```rust,ignore\n+    /// f(a.try_into()?);\n+    /// ```\n+    /// or\n+    /// ```rust,ignore\n+    /// f(a.try_into().expect(\"Unexpected u16 overflow in f\"));\n+    /// ```\n+    ///\n+    pub AS_CONVERSIONS,\n+    restriction,\n+    \"using a potentially dangerous silent `as` conversion\"\n+}\n+\n+declare_lint_pass!(AsConversions => [AS_CONVERSIONS]);\n+\n+impl EarlyLintPass for AsConversions {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+\n+        if let ExprKind::Cast(_, _) = expr.kind {\n+            span_lint_and_help(\n+                cx,\n+                AS_CONVERSIONS,\n+                expr.span,\n+                \"using a potentially dangerous silent `as` conversion\",\n+                None,\n+                \"consider using a safe wrapper for this conversion\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "f8a8fdcd3aa35e9753f3b8cfa79c069b2df403c6", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,152 @@\n+use crate::consts::{constant, Constant};\n+use crate::utils::paths;\n+use crate::utils::{is_direct_expn_of, is_expn_of, match_function_call, snippet_opt, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::{Expr, ExprKind, PatKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `assert!(true)` and `assert!(false)` calls.\n+    ///\n+    /// **Why is this bad?** Will be optimized out by the compiler or should probably be replaced by a\n+    /// `panic!()` or `unreachable!()`\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// assert!(false)\n+    /// assert!(true)\n+    /// const B: bool = false;\n+    /// assert!(B)\n+    /// ```\n+    pub ASSERTIONS_ON_CONSTANTS,\n+    style,\n+    \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\"\n+}\n+\n+declare_lint_pass!(AssertionsOnConstants => [ASSERTIONS_ON_CONSTANTS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        let lint_true = |is_debug: bool| {\n+            span_lint_and_help(\n+                cx,\n+                ASSERTIONS_ON_CONSTANTS,\n+                e.span,\n+                if is_debug {\n+                    \"`debug_assert!(true)` will be optimized out by the compiler\"\n+                } else {\n+                    \"`assert!(true)` will be optimized out by the compiler\"\n+                },\n+                None,\n+                \"remove it\",\n+            );\n+        };\n+        let lint_false_without_message = || {\n+            span_lint_and_help(\n+                cx,\n+                ASSERTIONS_ON_CONSTANTS,\n+                e.span,\n+                \"`assert!(false)` should probably be replaced\",\n+                None,\n+                \"use `panic!()` or `unreachable!()`\",\n+            );\n+        };\n+        let lint_false_with_message = |panic_message: String| {\n+            span_lint_and_help(\n+                cx,\n+                ASSERTIONS_ON_CONSTANTS,\n+                e.span,\n+                &format!(\"`assert!(false, {})` should probably be replaced\", panic_message),\n+                None,\n+                &format!(\"use `panic!({})` or `unreachable!({})`\", panic_message, panic_message),\n+            )\n+        };\n+\n+        if let Some(debug_assert_span) = is_expn_of(e.span, \"debug_assert\") {\n+            if debug_assert_span.from_expansion() {\n+                return;\n+            }\n+            if_chain! {\n+                if let ExprKind::Unary(_, ref lit) = e.kind;\n+                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables, lit);\n+                if is_true;\n+                then {\n+                    lint_true(true);\n+                }\n+            };\n+        } else if let Some(assert_span) = is_direct_expn_of(e.span, \"assert\") {\n+            if assert_span.from_expansion() {\n+                return;\n+            }\n+            if let Some(assert_match) = match_assert_with_message(&cx, e) {\n+                match assert_match {\n+                    // matched assert but not message\n+                    AssertKind::WithoutMessage(false) => lint_false_without_message(),\n+                    AssertKind::WithoutMessage(true) | AssertKind::WithMessage(_, true) => lint_true(false),\n+                    AssertKind::WithMessage(panic_message, false) => lint_false_with_message(panic_message),\n+                };\n+            }\n+        }\n+    }\n+}\n+\n+/// Result of calling `match_assert_with_message`.\n+enum AssertKind {\n+    WithMessage(String, bool),\n+    WithoutMessage(bool),\n+}\n+\n+/// Check if the expression matches\n+///\n+/// ```rust,ignore\n+/// match { let _t = !c; _t } {\n+///     true => {\n+///         {\n+///             ::std::rt::begin_panic(message, _)\n+///         }\n+///     }\n+///     _ => { }\n+/// };\n+/// ```\n+///\n+/// where `message` is any expression and `c` is a constant bool.\n+fn match_assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n+    if_chain! {\n+        if let ExprKind::Match(ref expr, ref arms, _) = expr.kind;\n+        // matches { let _t = expr; _t }\n+        if let ExprKind::DropTemps(ref expr) = expr.kind;\n+        if let ExprKind::Unary(UnOp::UnNot, ref expr) = expr.kind;\n+        // bind the first argument of the `assert!` macro\n+        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables, expr);\n+        // arm 1 pattern\n+        if let PatKind::Lit(ref lit_expr) = arms[0].pat.kind;\n+        if let ExprKind::Lit(ref lit) = lit_expr.kind;\n+        if let LitKind::Bool(true) = lit.node;\n+        // arm 1 block\n+        if let ExprKind::Block(ref block, _) = arms[0].body.kind;\n+        if block.stmts.is_empty();\n+        if let Some(block_expr) = &block.expr;\n+        if let ExprKind::Block(ref inner_block, _) = block_expr.kind;\n+        if let Some(begin_panic_call) = &inner_block.expr;\n+        // function call\n+        if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n+        if args.len() == 1;\n+        // bind the second argument of the `assert!` macro if it exists\n+        if let panic_message = snippet_opt(cx, args[0].span);\n+        // second argument of begin_panic is irrelevant\n+        // as is the second match arm\n+        then {\n+            // an empty message occurs when it was generated by the macro\n+            // (and not passed by the user)\n+            return panic_message\n+                .filter(|msg| !msg.is_empty())\n+                .map(|msg| AssertKind::WithMessage(msg, is_true))\n+                .or(Some(AssertKind::WithoutMessage(is_true)));\n+        }\n+    }\n+    None\n+}"}, {"sha": "05e2650d0b715b06cc2aa67dcb4c8d0db0c187f6", "filename": "src/tools/clippy/clippy_lints/src/assign_ops.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,261 @@\n+use crate::utils::{\n+    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n+};\n+use crate::utils::{higher, sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n+    /// patterns.\n+    ///\n+    /// **Why is this bad?** These can be written as the shorter `a op= b`.\n+    ///\n+    /// **Known problems:** While forbidden by the spec, `OpAssign` traits may have\n+    /// implementations that differ from the regular `Op` impl.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 0;\n+    /// // ...\n+    /// a = a + b;\n+    /// ```\n+    pub ASSIGN_OP_PATTERN,\n+    style,\n+    \"assigning the result of an operation on a variable to that same variable\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `a op= a op b` or `a op= b op a` patterns.\n+    ///\n+    /// **Why is this bad?** Most likely these are bugs where one meant to write `a\n+    /// op= b`.\n+    ///\n+    /// **Known problems:** Clippy cannot know for sure if `a op= a op b` should have\n+    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n+    /// If `a op= a op b` is really the correct behaviour it should be\n+    /// written as `a = a op a op b` as it's less confusing.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 2;\n+    /// // ...\n+    /// a += a + b;\n+    /// ```\n+    pub MISREFACTORED_ASSIGN_OP,\n+    complexity,\n+    \"having a variable on both sides of an assign op\"\n+}\n+\n+declare_lint_pass!(AssignOps => [ASSIGN_OP_PATTERN, MISREFACTORED_ASSIGN_OP]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        match &expr.kind {\n+            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n+                if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n+                    if op.node != binop.node {\n+                        return;\n+                    }\n+                    // lhs op= l op r\n+                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n+                    }\n+                    // lhs op= l commutative_op r\n+                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::Assign(assignee, e, _) => {\n+                if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n+                    let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n+                        let ty = cx.tables.expr_ty(assignee);\n+                        let rty = cx.tables.expr_ty(rhs);\n+                        macro_rules! ops {\n+                            ($op:expr,\n+                             $cx:expr,\n+                             $ty:expr,\n+                             $rty:expr,\n+                             $($trait_name:ident),+) => {\n+                                match $op {\n+                                    $(hir::BinOpKind::$trait_name => {\n+                                        let [krate, module] = crate::utils::paths::OPS_MODULE;\n+                                        let path: [&str; 3] = [krate, module, concat!(stringify!($trait_name), \"Assign\")];\n+                                        let trait_id = if let Some(trait_id) = get_trait_def_id($cx, &path) {\n+                                            trait_id\n+                                        } else {\n+                                            return; // useless if the trait doesn't exist\n+                                        };\n+                                        // check that we are not inside an `impl AssignOp` of this exact operation\n+                                        let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n+                                        if_chain! {\n+                                            if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n+                                            if trait_ref.path.res.def_id() == trait_id;\n+                                            then { return; }\n+                                        }\n+                                        implements_trait($cx, $ty, trait_id, &[$rty])\n+                                    },)*\n+                                    _ => false,\n+                                }\n+                            }\n+                        }\n+                        if ops!(\n+                            op.node,\n+                            cx,\n+                            ty,\n+                            rty.into(),\n+                            Add,\n+                            Sub,\n+                            Mul,\n+                            Div,\n+                            Rem,\n+                            And,\n+                            Or,\n+                            BitAnd,\n+                            BitOr,\n+                            BitXor,\n+                            Shr,\n+                            Shl\n+                        ) {\n+                            span_lint_and_then(\n+                                cx,\n+                                ASSIGN_OP_PATTERN,\n+                                expr.span,\n+                                \"manual implementation of an assign operation\",\n+                                |diag| {\n+                                    if let (Some(snip_a), Some(snip_r)) =\n+                                        (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n+                                    {\n+                                        diag.span_suggestion(\n+                                            expr.span,\n+                                            \"replace it with\",\n+                                            format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                                            Applicability::MachineApplicable,\n+                                        );\n+                                    }\n+                                },\n+                            );\n+                        }\n+                    };\n+\n+                    let mut visitor = ExprVisitor {\n+                        assignee,\n+                        counter: 0,\n+                        cx,\n+                    };\n+\n+                    walk_expr(&mut visitor, e);\n+\n+                    if visitor.counter == 1 {\n+                        // a = a op b\n+                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, l) {\n+                            lint(assignee, r);\n+                        }\n+                        // a = b commutative_op a\n+                        // Limited to primitive type as these ops are know to be commutative\n+                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n+                            && cx.tables.expr_ty(assignee).is_primitive_ty()\n+                        {\n+                            match op.node {\n+                                hir::BinOpKind::Add\n+                                | hir::BinOpKind::Mul\n+                                | hir::BinOpKind::And\n+                                | hir::BinOpKind::Or\n+                                | hir::BinOpKind::BitXor\n+                                | hir::BinOpKind::BitAnd\n+                                | hir::BinOpKind::BitOr => {\n+                                    lint(assignee, l);\n+                                },\n+                                _ => {},\n+                            }\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn lint_misrefactored_assign_op(\n+    cx: &LateContext<'_, '_>,\n+    expr: &hir::Expr<'_>,\n+    op: hir::BinOp,\n+    rhs: &hir::Expr<'_>,\n+    assignee: &hir::Expr<'_>,\n+    rhs_other: &hir::Expr<'_>,\n+) {\n+    span_lint_and_then(\n+        cx,\n+        MISREFACTORED_ASSIGN_OP,\n+        expr.span,\n+        \"variable appears on both sides of an assignment operation\",\n+        |diag| {\n+            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n+                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n+                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n+                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(higher::binop(op.node), a, r));\n+                diag.span_suggestion(\n+                    expr.span,\n+                    &format!(\n+                        \"Did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n+                        snip_a,\n+                        snip_a,\n+                        op.node.as_str(),\n+                        snip_r,\n+                        long\n+                    ),\n+                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"or\",\n+                    long,\n+                    Applicability::MaybeIncorrect, // snippet\n+                );\n+            }\n+        },\n+    );\n+}\n+\n+#[must_use]\n+fn is_commutative(op: hir::BinOpKind) -> bool {\n+    use rustc_hir::BinOpKind::{\n+        Add, And, BitAnd, BitOr, BitXor, Div, Eq, Ge, Gt, Le, Lt, Mul, Ne, Or, Rem, Shl, Shr, Sub,\n+    };\n+    match op {\n+        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n+        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n+    }\n+}\n+\n+struct ExprVisitor<'a, 'tcx> {\n+    assignee: &'a hir::Expr<'a>,\n+    counter: u8,\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        if SpanlessEq::new(self.cx).ignore_fn().eq_expr(self.assignee, expr) {\n+            self.counter += 1;\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "73b4cef472505ee4e5bc21e14028e615ce9dbeb2", "filename": "src/tools/clippy/clippy_lints/src/atomic_ordering.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,135 @@\n+use crate::utils::{match_def_path, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of invalid atomic\n+    /// ordering in atomic loads/stores and memory fences.\n+    ///\n+    /// **Why is this bad?** Using an invalid atomic ordering\n+    /// will cause a panic at run-time.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,no_run\n+    /// # use std::sync::atomic::{self, AtomicBool, Ordering};\n+    ///\n+    /// let x = AtomicBool::new(true);\n+    ///\n+    /// let _ = x.load(Ordering::Release);\n+    /// let _ = x.load(Ordering::AcqRel);\n+    ///\n+    /// x.store(false, Ordering::Acquire);\n+    /// x.store(false, Ordering::AcqRel);\n+    ///\n+    /// atomic::fence(Ordering::Relaxed);\n+    /// atomic::compiler_fence(Ordering::Relaxed);\n+    /// ```\n+    pub INVALID_ATOMIC_ORDERING,\n+    correctness,\n+    \"usage of invalid atomic ordering in atomic loads/stores and memory fences\"\n+}\n+\n+declare_lint_pass!(AtomicOrdering => [INVALID_ATOMIC_ORDERING]);\n+\n+const ATOMIC_TYPES: [&str; 12] = [\n+    \"AtomicBool\",\n+    \"AtomicI8\",\n+    \"AtomicI16\",\n+    \"AtomicI32\",\n+    \"AtomicI64\",\n+    \"AtomicIsize\",\n+    \"AtomicPtr\",\n+    \"AtomicU8\",\n+    \"AtomicU16\",\n+    \"AtomicU32\",\n+    \"AtomicU64\",\n+    \"AtomicUsize\",\n+];\n+\n+fn type_is_atomic(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.tables.expr_ty(expr).kind {\n+        ATOMIC_TYPES\n+            .iter()\n+            .any(|ty| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", ty]))\n+    } else {\n+        false\n+    }\n+}\n+\n+fn match_ordering_def_path(cx: &LateContext<'_, '_>, did: DefId, orderings: &[&str]) -> bool {\n+    orderings\n+        .iter()\n+        .any(|ordering| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", \"Ordering\", ordering]))\n+}\n+\n+fn check_atomic_load_store(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method_path, _, args) = &expr.kind;\n+        let method = method_path.ident.name.as_str();\n+        if type_is_atomic(cx, &args[0]);\n+        if method == \"load\" || method == \"store\";\n+        let ordering_arg = if method == \"load\" { &args[1] } else { &args[2] };\n+        if let ExprKind::Path(ref ordering_qpath) = ordering_arg.kind;\n+        if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n+        then {\n+            if method == \"load\" &&\n+                match_ordering_def_path(cx, ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n+                span_lint_and_help(\n+                    cx,\n+                    INVALID_ATOMIC_ORDERING,\n+                    ordering_arg.span,\n+                    \"atomic loads cannot have `Release` and `AcqRel` ordering\",\n+                    None,\n+                    \"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\"\n+                );\n+            } else if method == \"store\" &&\n+                match_ordering_def_path(cx, ordering_def_id, &[\"Acquire\", \"AcqRel\"]) {\n+                span_lint_and_help(\n+                    cx,\n+                    INVALID_ATOMIC_ORDERING,\n+                    ordering_arg.span,\n+                    \"atomic stores cannot have `Acquire` and `AcqRel` ordering\",\n+                    None,\n+                    \"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\"\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn check_memory_fence(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Call(ref func, ref args) = expr.kind;\n+        if let ExprKind::Path(ref func_qpath) = func.kind;\n+        if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if [\"fence\", \"compiler_fence\"]\n+            .iter()\n+            .any(|func| match_def_path(cx, def_id, &[\"core\", \"sync\", \"atomic\", func]));\n+        if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n+        if let Some(ordering_def_id) = cx.tables.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n+        if match_ordering_def_path(cx, ordering_def_id, &[\"Relaxed\"]);\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                INVALID_ATOMIC_ORDERING,\n+                args[0].span,\n+                \"memory fences cannot have `Relaxed` ordering\",\n+                None,\n+                \"consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\"\n+            );\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AtomicOrdering {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        check_atomic_load_store(cx, expr);\n+        check_memory_fence(cx, expr);\n+    }\n+}"}, {"sha": "64abc9fdc71742ed7a488a47b9f8b3fc9eaad20b", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "added", "additions": 657, "deletions": 0, "changes": 657, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,657 @@\n+//! checks for attributes\n+\n+use crate::reexport::Name;\n+use crate::utils::{\n+    first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg,\n+    span_lint_and_then, without_block_comments,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,\n+};\n+use rustc_lint::{CheckLintNameResult, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n+use semver::Version;\n+\n+static UNIX_SYSTEMS: &[&str] = &[\n+    \"android\",\n+    \"dragonfly\",\n+    \"emscripten\",\n+    \"freebsd\",\n+    \"fuchsia\",\n+    \"haiku\",\n+    \"illumos\",\n+    \"ios\",\n+    \"l4re\",\n+    \"linux\",\n+    \"macos\",\n+    \"netbsd\",\n+    \"openbsd\",\n+    \"redox\",\n+    \"solaris\",\n+    \"vxworks\",\n+];\n+\n+// NOTE: windows is excluded from the list because it's also a valid target family.\n+static NON_UNIX_SYSTEMS: &[&str] = &[\"cloudabi\", \"hermit\", \"none\", \"wasi\"];\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n+    /// unless the annotated function is empty or simply panics.\n+    ///\n+    /// **Why is this bad?** While there are valid uses of this annotation (and once\n+    /// you know when to use it, by all means `allow` this lint), it's a common\n+    /// newbie-mistake to pepper one's code with it.\n+    ///\n+    /// As a rule of thumb, before slapping `#[inline(always)]` on a function,\n+    /// measure if that additional function call really affects your runtime profile\n+    /// sufficiently to make up for the increase in compile time.\n+    ///\n+    /// **Known problems:** False positives, big time. This lint is meant to be\n+    /// deactivated by everyone doing serious performance work. This means having\n+    /// done the measurement.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// #[inline(always)]\n+    /// fn not_quite_hot_code(..) { ... }\n+    /// ```\n+    pub INLINE_ALWAYS,\n+    pedantic,\n+    \"use of `#[inline(always)]`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `extern crate` and `use` items annotated with\n+    /// lint attributes.\n+    ///\n+    /// This lint whitelists `#[allow(unused_imports)]`, `#[allow(deprecated)]` and\n+    /// `#[allow(unreachable_pub)]` on `use` items and `#[allow(unused_imports)]` on\n+    /// `extern crate` items with a `#[macro_use]` attribute.\n+    ///\n+    /// **Why is this bad?** Lint attributes have no effect on crate imports. Most\n+    /// likely a `!` was forgotten.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// // Bad\n+    /// #[deny(dead_code)]\n+    /// extern crate foo;\n+    /// #[forbid(dead_code)]\n+    /// use foo::bar;\n+    ///\n+    /// // Ok\n+    /// #[allow(unused_imports)]\n+    /// use foo::baz;\n+    /// #[allow(unused_imports)]\n+    /// #[macro_use]\n+    /// extern crate baz;\n+    /// ```\n+    pub USELESS_ATTRIBUTE,\n+    correctness,\n+    \"use of lint attributes on `extern crate` items\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[deprecated]` annotations with a `since`\n+    /// field that is not a valid semantic version.\n+    ///\n+    /// **Why is this bad?** For checking the version of the deprecation, it must be\n+    /// a valid semver. Failing that, the contained information is useless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[deprecated(since = \"forever\")]\n+    /// fn something_else() { /* ... */ }\n+    /// ```\n+    pub DEPRECATED_SEMVER,\n+    correctness,\n+    \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for empty lines after outer attributes\n+    ///\n+    /// **Why is this bad?**\n+    /// Most likely the attribute was meant to be an inner attribute using a '!'.\n+    /// If it was meant to be an outer attribute, then the following item\n+    /// should not be separated by empty lines.\n+    ///\n+    /// **Known problems:** Can cause false positives.\n+    ///\n+    /// From the clippy side it's difficult to detect empty lines between an attributes and the\n+    /// following item because empty lines and comments are not part of the AST. The parsing\n+    /// currently works for basic cases but is not perfect.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Good (as inner attribute)\n+    /// #![inline(always)]\n+    ///\n+    /// fn this_is_fine() { }\n+    ///\n+    /// // Bad\n+    /// #[inline(always)]\n+    ///\n+    /// fn not_quite_good_code() { }\n+    ///\n+    /// // Good (as outer attribute)\n+    /// #[inline(always)]\n+    /// fn this_is_fine_too() { }\n+    /// ```\n+    pub EMPTY_LINE_AFTER_OUTER_ATTR,\n+    nursery,\n+    \"empty line after outer attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `allow`/`warn`/`deny`/`forbid` attributes with scoped clippy\n+    /// lints and if those lints exist in clippy. If there is an uppercase letter in the lint name\n+    /// (not the tool name) and a lowercase version of this lint exists, it will suggest to lowercase\n+    /// the lint name.\n+    ///\n+    /// **Why is this bad?** A lint attribute with a mistyped lint name won't have an effect.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust\n+    /// #![warn(if_not_els)]\n+    /// #![deny(clippy::All)]\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #![warn(if_not_else)]\n+    /// #![deny(clippy::all)]\n+    /// ```\n+    pub UNKNOWN_CLIPPY_LINTS,\n+    style,\n+    \"unknown_lints for scoped Clippy lints\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n+    /// with `#[rustfmt::skip]`.\n+    ///\n+    /// **Why is this bad?** Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\n+    /// are stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n+    ///\n+    /// **Known problems:** This lint doesn't detect crate level inner attributes, because they get\n+    /// processed before the PreExpansionPass lints get executed. See\n+    /// [#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Bad:\n+    /// ```rust\n+    /// #[cfg_attr(rustfmt, rustfmt_skip)]\n+    /// fn main() { }\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #[rustfmt::skip]\n+    /// fn main() { }\n+    /// ```\n+    pub DEPRECATED_CFG_ATTR,\n+    complexity,\n+    \"usage of `cfg_attr(rustfmt)` instead of tool attributes\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for cfg attributes having operating systems used in target family position.\n+    ///\n+    /// **Why is this bad?** The configuration option will not be recognised and the related item will not be included\n+    /// by the conditional compilation engine.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Bad:\n+    /// ```rust\n+    /// #[cfg(linux)]\n+    /// fn conditional() { }\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #[cfg(target_os = \"linux\")]\n+    /// fn conditional() { }\n+    /// ```\n+    ///\n+    /// Or:\n+    /// ```rust\n+    /// #[cfg(unix)]\n+    /// fn conditional() { }\n+    /// ```\n+    /// Check the [Rust Reference](https://doc.rust-lang.org/reference/conditional-compilation.html#target_os) for more details.\n+    pub MISMATCHED_TARGET_OS,\n+    correctness,\n+    \"usage of `cfg(operating_system)` instead of `cfg(target_os = \\\"operating_system\\\")`\"\n+}\n+\n+declare_lint_pass!(Attributes => [\n+    INLINE_ALWAYS,\n+    DEPRECATED_SEMVER,\n+    USELESS_ATTRIBUTE,\n+    EMPTY_LINE_AFTER_OUTER_ATTR,\n+    UNKNOWN_CLIPPY_LINTS,\n+]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n+    fn check_attribute(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n+        if let Some(items) = &attr.meta_item_list() {\n+            if let Some(ident) = attr.ident() {\n+                match &*ident.as_str() {\n+                    \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                        check_clippy_lint_names(cx, items);\n+                    },\n+                    _ => {},\n+                }\n+                if items.is_empty() || !attr.check_name(sym!(deprecated)) {\n+                    return;\n+                }\n+                for item in items {\n+                    if_chain! {\n+                        if let NestedMetaItem::MetaItem(mi) = &item;\n+                        if let MetaItemKind::NameValue(lit) = &mi.kind;\n+                        if mi.check_name(sym!(since));\n+                        then {\n+                            check_semver(cx, item.span(), lit);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+        if is_relevant_item(cx, item) {\n+            check_attrs(cx, item.span, item.ident.name, &item.attrs)\n+        }\n+        match item.kind {\n+            ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.check_name(sym!(macro_use)));\n+\n+                for attr in item.attrs {\n+                    if in_external_macro(cx.sess(), attr.span) {\n+                        return;\n+                    }\n+                    if let Some(lint_list) = &attr.meta_item_list() {\n+                        if let Some(ident) = attr.ident() {\n+                            match &*ident.as_str() {\n+                                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                                    // whitelist `unused_imports`, `deprecated` and `unreachable_pub` for `use` items\n+                                    // and `unused_imports` for `extern crate` items with `macro_use`\n+                                    for lint in lint_list {\n+                                        match item.kind {\n+                                            ItemKind::Use(..) => {\n+                                                if is_word(lint, sym!(unused_imports))\n+                                                    || is_word(lint, sym!(deprecated))\n+                                                    || is_word(lint, sym!(unreachable_pub))\n+                                                    || is_word(lint, sym!(unused))\n+                                                {\n+                                                    return;\n+                                                }\n+                                            },\n+                                            ItemKind::ExternCrate(..) => {\n+                                                if is_word(lint, sym!(unused_imports)) && skip_unused_imports {\n+                                                    return;\n+                                                }\n+                                                if is_word(lint, sym!(unused_extern_crates)) {\n+                                                    return;\n+                                                }\n+                                            },\n+                                            _ => {},\n+                                        }\n+                                    }\n+                                    let line_span = first_line_of_span(cx, attr.span);\n+\n+                                    if let Some(mut sugg) = snippet_opt(cx, line_span) {\n+                                        if sugg.contains(\"#[\") {\n+                                            span_lint_and_then(\n+                                                cx,\n+                                                USELESS_ATTRIBUTE,\n+                                                line_span,\n+                                                \"useless lint attribute\",\n+                                                |diag| {\n+                                                    sugg = sugg.replacen(\"#[\", \"#![\", 1);\n+                                                    diag.span_suggestion(\n+                                                        line_span,\n+                                                        \"if you just forgot a `!`, use\",\n+                                                        sugg,\n+                                                        Applicability::MaybeIncorrect,\n+                                                    );\n+                                                },\n+                                            );\n+                                        }\n+                                    }\n+                                },\n+                                _ => {},\n+                            }\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem<'_>) {\n+        if is_relevant_impl(cx, item) {\n+            check_attrs(cx, item.span, item.ident.name, &item.attrs)\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem<'_>) {\n+        if is_relevant_trait(cx, item) {\n+            check_attrs(cx, item.span, item.ident.name, &item.attrs)\n+        }\n+    }\n+}\n+\n+#[allow(clippy::single_match_else)]\n+fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n+    let lint_store = cx.lints();\n+    for lint in items {\n+        if_chain! {\n+            if let Some(meta_item) = lint.meta_item();\n+            if meta_item.path.segments.len() > 1;\n+            if let tool_name = meta_item.path.segments[0].ident;\n+            if tool_name.as_str() == \"clippy\";\n+            let name = meta_item.path.segments.last().unwrap().ident.name;\n+            if let CheckLintNameResult::Tool(Err((None, _))) = lint_store.check_lint_name(\n+                &name.as_str(),\n+                Some(tool_name.name),\n+            );\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    UNKNOWN_CLIPPY_LINTS,\n+                    lint.span(),\n+                    &format!(\"unknown clippy lint: clippy::{}\", name),\n+                    |diag| {\n+                        let name_lower = name.as_str().to_lowercase();\n+                        let symbols = lint_store.get_lints().iter().map(\n+                            |l| Symbol::intern(&l.name_lower())\n+                        ).collect::<Vec<_>>();\n+                        let sugg = find_best_match_for_name(\n+                            symbols.iter(),\n+                            &format!(\"clippy::{}\", name_lower),\n+                            None,\n+                        );\n+                        if name.as_str().chars().any(char::is_uppercase)\n+                            && lint_store.find_lints(&format!(\"clippy::{}\", name_lower)).is_ok() {\n+                            diag.span_suggestion(\n+                                lint.span(),\n+                                \"lowercase the lint name\",\n+                                format!(\"clippy::{}\", name_lower),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else if let Some(sugg) = sugg {\n+                            diag.span_suggestion(\n+                                lint.span(),\n+                                \"did you mean\",\n+                                sugg.to_string(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                );\n+            }\n+        };\n+    }\n+}\n+\n+fn is_relevant_item(cx: &LateContext<'_, '_>, item: &Item<'_>) -> bool {\n+    if let ItemKind::Fn(_, _, eid) = item.kind {\n+        is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n+    } else {\n+        true\n+    }\n+}\n+\n+fn is_relevant_impl(cx: &LateContext<'_, '_>, item: &ImplItem<'_>) -> bool {\n+    match item.kind {\n+        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value),\n+        _ => false,\n+    }\n+}\n+\n+fn is_relevant_trait(cx: &LateContext<'_, '_>, item: &TraitItem<'_>) -> bool {\n+    match item.kind {\n+        TraitItemKind::Fn(_, TraitFn::Required(_)) => true,\n+        TraitItemKind::Fn(_, TraitFn::Provided(eid)) => {\n+            is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n+        },\n+        _ => false,\n+    }\n+}\n+\n+fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n+    if let Some(stmt) = block.stmts.first() {\n+        match &stmt.kind {\n+            StmtKind::Local(_) => true,\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, tables, expr),\n+            _ => false,\n+        }\n+    } else {\n+        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e))\n+    }\n+}\n+\n+fn is_relevant_expr(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n+    match &expr.kind {\n+        ExprKind::Block(block, _) => is_relevant_block(cx, tables, block),\n+        ExprKind::Ret(Some(e)) => is_relevant_expr(cx, tables, e),\n+        ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n+        ExprKind::Call(path_expr, _) => {\n+            if let ExprKind::Path(qpath) = &path_expr.kind {\n+                if let Some(fun_id) = tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n+                    !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n+                } else {\n+                    true\n+                }\n+            } else {\n+                true\n+            }\n+        },\n+        _ => true,\n+    }\n+}\n+\n+fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attribute]) {\n+    if span.from_expansion() {\n+        return;\n+    }\n+\n+    for attr in attrs {\n+        let attr_item = if let AttrKind::Normal(ref attr) = attr.kind {\n+            attr\n+        } else {\n+            continue;\n+        };\n+\n+        if attr.style == AttrStyle::Outer {\n+            if attr_item.args.inner_tokens().is_empty() || !is_present_in_source(cx, attr.span) {\n+                return;\n+            }\n+\n+            let begin_of_attr_to_item = Span::new(attr.span.lo(), span.lo(), span.ctxt());\n+            let end_of_attr_to_item = Span::new(attr.span.hi(), span.lo(), span.ctxt());\n+\n+            if let Some(snippet) = snippet_opt(cx, end_of_attr_to_item) {\n+                let lines = snippet.split('\\n').collect::<Vec<_>>();\n+                let lines = without_block_comments(lines);\n+\n+                if lines.iter().filter(|l| l.trim().is_empty()).count() > 2 {\n+                    span_lint(\n+                        cx,\n+                        EMPTY_LINE_AFTER_OUTER_ATTR,\n+                        begin_of_attr_to_item,\n+                        \"Found an empty line after an outer attribute. \\\n+                         Perhaps you forgot to add a `!` to make it an inner attribute?\",\n+                    );\n+                }\n+            }\n+        }\n+\n+        if let Some(values) = attr.meta_item_list() {\n+            if values.len() != 1 || !attr.check_name(sym!(inline)) {\n+                continue;\n+            }\n+            if is_word(&values[0], sym!(always)) {\n+                span_lint(\n+                    cx,\n+                    INLINE_ALWAYS,\n+                    attr.span,\n+                    &format!(\n+                        \"you have declared `#[inline(always)]` on `{}`. This is usually a bad idea\",\n+                        name\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n+    if let LitKind::Str(is, _) = lit.kind {\n+        if Version::parse(&is.as_str()).is_ok() {\n+            return;\n+        }\n+    }\n+    span_lint(\n+        cx,\n+        DEPRECATED_SEMVER,\n+        span,\n+        \"the since field must contain a semver-compliant version\",\n+    );\n+}\n+\n+fn is_word(nmi: &NestedMetaItem, expected: Symbol) -> bool {\n+    if let NestedMetaItem::MetaItem(mi) = &nmi {\n+        mi.is_word() && mi.check_name(expected)\n+    } else {\n+        false\n+    }\n+}\n+\n+declare_lint_pass!(EarlyAttributes => [DEPRECATED_CFG_ATTR, MISMATCHED_TARGET_OS]);\n+\n+impl EarlyLintPass for EarlyAttributes {\n+    fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &Attribute) {\n+        check_deprecated_cfg_attr(cx, attr);\n+        check_mismatched_target_os(cx, attr);\n+    }\n+}\n+\n+fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute) {\n+    if_chain! {\n+        // check cfg_attr\n+        if attr.check_name(sym!(cfg_attr));\n+        if let Some(items) = attr.meta_item_list();\n+        if items.len() == 2;\n+        // check for `rustfmt`\n+        if let Some(feature_item) = items[0].meta_item();\n+        if feature_item.check_name(sym!(rustfmt));\n+        // check for `rustfmt_skip` and `rustfmt::skip`\n+        if let Some(skip_item) = &items[1].meta_item();\n+        if skip_item.check_name(sym!(rustfmt_skip)) ||\n+            skip_item.path.segments.last().expect(\"empty path in attribute\").ident.name == sym!(skip);\n+        // Only lint outer attributes, because custom inner attributes are unstable\n+        // Tracking issue: https://github.com/rust-lang/rust/issues/54726\n+        if let AttrStyle::Outer = attr.style;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                DEPRECATED_CFG_ATTR,\n+                attr.span,\n+                \"`cfg_attr` is deprecated for rustfmt and got replaced by tool attributes\",\n+                \"use\",\n+                \"#[rustfmt::skip]\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n+    fn find_os(name: &str) -> Option<&'static str> {\n+        UNIX_SYSTEMS\n+            .iter()\n+            .chain(NON_UNIX_SYSTEMS.iter())\n+            .find(|&&os| os == name)\n+            .copied()\n+    }\n+\n+    fn is_unix(name: &str) -> bool {\n+        UNIX_SYSTEMS.iter().any(|&os| os == name)\n+    }\n+\n+    fn find_mismatched_target_os(items: &[NestedMetaItem]) -> Vec<(&str, Span)> {\n+        let mut mismatched = Vec::new();\n+\n+        for item in items {\n+            if let NestedMetaItem::MetaItem(meta) = item {\n+                match &meta.kind {\n+                    MetaItemKind::List(list) => {\n+                        mismatched.extend(find_mismatched_target_os(&list));\n+                    },\n+                    MetaItemKind::Word => {\n+                        if_chain! {\n+                            if let Some(ident) = meta.ident();\n+                            if let Some(os) = find_os(&*ident.name.as_str());\n+                            then {\n+                                mismatched.push((os, ident.span));\n+                            }\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+\n+        mismatched\n+    }\n+\n+    if_chain! {\n+        if attr.check_name(sym!(cfg));\n+        if let Some(list) = attr.meta_item_list();\n+        let mismatched = find_mismatched_target_os(&list);\n+        if !mismatched.is_empty();\n+        then {\n+            let mess = \"operating system used in target family position\";\n+\n+            span_lint_and_then(cx, MISMATCHED_TARGET_OS, attr.span, &mess, |diag| {\n+                // Avoid showing the unix suggestion multiple times in case\n+                // we have more than one mismatch for unix-like systems\n+                let mut unix_suggested = false;\n+\n+                for (os, span) in mismatched {\n+                    let sugg = format!(\"target_os = \\\"{}\\\"\", os);\n+                    diag.span_suggestion(span, \"try\", sugg, Applicability::MaybeIncorrect);\n+\n+                    if !unix_suggested && is_unix(os) {\n+                        diag.help(\"Did you mean `unix`?\");\n+                        unix_suggested = true;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+}"}, {"sha": "832910763e60c99e55b4adb7f1bcc00e292c556e", "filename": "src/tools/clippy/clippy_lints/src/await_holding_lock.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,97 @@\n+use crate::utils::{match_def_path, paths, span_lint_and_note};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::GeneratorInteriorTypeCause;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to await while holding a\n+    /// non-async-aware MutexGuard.\n+    ///\n+    /// **Why is this bad?** The Mutex types found in syd::sync and parking_lot\n+    /// are not designed to operator in an async context across await points.\n+    ///\n+    /// There are two potential solutions. One is to use an asynx-aware Mutex\n+    /// type. Many asynchronous foundation crates provide such a Mutex type. The\n+    /// other solution is to ensure the mutex is unlocked before calling await,\n+    /// either by introducing a scope or an explicit call to Drop::drop.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use std::sync::Mutex;\n+    ///\n+    /// async fn foo(x: &Mutex<u32>) {\n+    ///   let guard = x.lock().unwrap();\n+    ///   *guard += 1;\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use std::sync::Mutex;\n+    ///\n+    /// async fn foo(x: &Mutex<u32>) {\n+    ///   {\n+    ///     let guard = x.lock().unwrap();\n+    ///     *guard += 1;\n+    ///   }\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    pub AWAIT_HOLDING_LOCK,\n+    pedantic,\n+    \"Inside an async function, holding a MutexGuard while calling await\"\n+}\n+\n+declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n+\n+impl LateLintPass<'_, '_> for AwaitHoldingLock {\n+    fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &'_ Body<'_>) {\n+        use AsyncGeneratorKind::{Block, Closure, Fn};\n+        match body.generator_kind {\n+            Some(GeneratorKind::Async(Block))\n+            | Some(GeneratorKind::Async(Closure))\n+            | Some(GeneratorKind::Async(Fn)) => {\n+                let body_id = BodyId {\n+                    hir_id: body.value.hir_id,\n+                };\n+                let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n+                let tables = cx.tcx.typeck_tables_of(def_id);\n+                check_interior_types(cx, &tables.generator_interior_types, body.value.span);\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn check_interior_types(cx: &LateContext<'_, '_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+    for ty_cause in ty_causes {\n+        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind {\n+            if is_mutex_guard(cx, adt.did) {\n+                span_lint_and_note(\n+                    cx,\n+                    AWAIT_HOLDING_LOCK,\n+                    ty_cause.span,\n+                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\",\n+                    ty_cause.scope_span.or(Some(span)),\n+                    \"these are all the await points this lock is held through\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_mutex_guard(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n+    match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n+        || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n+        || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_MUTEX_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)\n+}"}, {"sha": "ccb62cb038fd0a4c7aab05a7178d31e840d7e6e1", "filename": "src/tools/clippy/clippy_lints/src/bit_mask.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,326 @@\n+use crate::consts::{constant, Constant};\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{span_lint, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for incompatible bit masks in comparisons.\n+    ///\n+    /// The formula for detecting if an expression of the type `_ <bit_op> m\n+    /// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n+    /// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n+    /// table:\n+    ///\n+    /// |Comparison  |Bit Op|Example     |is always|Formula               |\n+    /// |------------|------|------------|---------|----------------------|\n+    /// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n+    /// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n+    /// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n+    /// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n+    /// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n+    /// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n+    ///\n+    /// **Why is this bad?** If the bits that the comparison cares about are always\n+    /// set to zero or one by the bit mask, the comparison is constant `true` or\n+    /// `false` (depending on mask, compared value, and operators).\n+    ///\n+    /// So the code is actively misleading, and the only reason someone would write\n+    /// this intentionally is to win an underhanded Rust contest or create a\n+    /// test-case for this lint.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if (x & 1 == 2) { }\n+    /// ```\n+    pub BAD_BIT_MASK,\n+    correctness,\n+    \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for bit masks in comparisons which can be removed\n+    /// without changing the outcome. The basic structure can be seen in the\n+    /// following table:\n+    ///\n+    /// |Comparison| Bit Op  |Example    |equals |\n+    /// |----------|---------|-----------|-------|\n+    /// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n+    /// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n+    ///\n+    /// **Why is this bad?** Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n+    /// but still a bit misleading, because the bit mask is ineffective.\n+    ///\n+    /// **Known problems:** False negatives: This lint will only match instances\n+    /// where we have figured out the math (which is for a power-of-two compared\n+    /// value). This means things like `x | 1 >= 7` (which would be better written\n+    /// as `x >= 6`) will not be reported (but bit masks like this are fairly\n+    /// uncommon).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if (x | 1 > 3) {  }\n+    /// ```\n+    pub INEFFECTIVE_BIT_MASK,\n+    correctness,\n+    \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for bit masks that can be replaced by a call\n+    /// to `trailing_zeros`\n+    ///\n+    /// **Why is this bad?** `x.trailing_zeros() > 4` is much clearer than `x & 15\n+    /// == 0`\n+    ///\n+    /// **Known problems:** llvm generates better code for `x & 15 == 0` on x86\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if x & 0b1111 == 0 { }\n+    /// ```\n+    pub VERBOSE_BIT_MASK,\n+    style,\n+    \"expressions where a bit mask is less readable than the corresponding method call\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct BitMask {\n+    verbose_bit_mask_threshold: u64,\n+}\n+\n+impl BitMask {\n+    #[must_use]\n+    pub fn new(verbose_bit_mask_threshold: u64) -> Self {\n+        Self {\n+            verbose_bit_mask_threshold,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(BitMask => [BAD_BIT_MASK, INEFFECTIVE_BIT_MASK, VERBOSE_BIT_MASK]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(cmp, left, right) = &e.kind {\n+            if cmp.node.is_comparison() {\n+                if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n+                    check_compare(cx, left, cmp.node, cmp_opt, e.span)\n+                } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n+                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, e.span)\n+                }\n+            }\n+        }\n+        if_chain! {\n+            if let ExprKind::Binary(op, left, right) = &e.kind;\n+            if BinOpKind::Eq == op.node;\n+            if let ExprKind::Binary(op1, left1, right1) = &left.kind;\n+            if BinOpKind::BitAnd == op1.node;\n+            if let ExprKind::Lit(lit) = &right1.kind;\n+            if let LitKind::Int(n, _) = lit.node;\n+            if let ExprKind::Lit(lit1) = &right.kind;\n+            if let LitKind::Int(0, _) = lit1.node;\n+            if n.leading_zeros() == n.count_zeros();\n+            if n > u128::from(self.verbose_bit_mask_threshold);\n+            then {\n+                span_lint_and_then(cx,\n+                                   VERBOSE_BIT_MASK,\n+                                   e.span,\n+                                   \"bit mask could be simplified with a call to `trailing_zeros`\",\n+                                   |diag| {\n+                    let sugg = Sugg::hir(cx, left1, \"...\").maybe_par();\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"try\",\n+                        format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+#[must_use]\n+fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n+    match cmp {\n+        BinOpKind::Eq => BinOpKind::Eq,\n+        BinOpKind::Ne => BinOpKind::Ne,\n+        BinOpKind::Lt => BinOpKind::Gt,\n+        BinOpKind::Gt => BinOpKind::Lt,\n+        BinOpKind::Le => BinOpKind::Ge,\n+        BinOpKind::Ge => BinOpKind::Le,\n+        _ => BinOpKind::Or, // Dummy\n+    }\n+}\n+\n+fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr<'_>, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n+    if let ExprKind::Binary(op, left, right) = &bit_op.kind {\n+        if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n+            return;\n+        }\n+        fetch_int_literal(cx, right)\n+            .or_else(|| fetch_int_literal(cx, left))\n+            .map_or((), |mask| check_bit_mask(cx, op.node, cmp_op, mask, cmp_value, span))\n+    }\n+}\n+\n+#[allow(clippy::too_many_lines)]\n+fn check_bit_mask(\n+    cx: &LateContext<'_, '_>,\n+    bit_op: BinOpKind,\n+    cmp_op: BinOpKind,\n+    mask_value: u128,\n+    cmp_value: u128,\n+    span: Span,\n+) {\n+    match cmp_op {\n+        BinOpKind::Eq | BinOpKind::Ne => match bit_op {\n+            BinOpKind::BitAnd => {\n+                if mask_value & cmp_value != cmp_value {\n+                    if cmp_value != 0 {\n+                        span_lint(\n+                            cx,\n+                            BAD_BIT_MASK,\n+                            span,\n+                            &format!(\n+                                \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n+                                mask_value, cmp_value\n+                            ),\n+                        );\n+                    }\n+                } else if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n+                }\n+            },\n+            BinOpKind::BitOr => {\n+                if mask_value | cmp_value != cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                }\n+            },\n+            _ => (),\n+        },\n+        BinOpKind::Lt | BinOpKind::Ge => match bit_op {\n+            BinOpKind::BitAnd => {\n+                if mask_value < cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                } else if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n+                }\n+            },\n+            BinOpKind::BitOr => {\n+                if mask_value >= cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                } else {\n+                    check_ineffective_lt(cx, span, mask_value, cmp_value, \"|\");\n+                }\n+            },\n+            BinOpKind::BitXor => check_ineffective_lt(cx, span, mask_value, cmp_value, \"^\"),\n+            _ => (),\n+        },\n+        BinOpKind::Le | BinOpKind::Gt => match bit_op {\n+            BinOpKind::BitAnd => {\n+                if mask_value <= cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                } else if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n+                }\n+            },\n+            BinOpKind::BitOr => {\n+                if mask_value > cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                } else {\n+                    check_ineffective_gt(cx, span, mask_value, cmp_value, \"|\");\n+                }\n+            },\n+            BinOpKind::BitXor => check_ineffective_gt(cx, span, mask_value, cmp_value, \"^\"),\n+            _ => (),\n+        },\n+        _ => (),\n+    }\n+}\n+\n+fn check_ineffective_lt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n+    if c.is_power_of_two() && m < c {\n+        span_lint(\n+            cx,\n+            INEFFECTIVE_BIT_MASK,\n+            span,\n+            &format!(\n+                \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n+                op, m, c\n+            ),\n+        );\n+    }\n+}\n+\n+fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n+    if (c + 1).is_power_of_two() && m <= c {\n+        span_lint(\n+            cx,\n+            INEFFECTIVE_BIT_MASK,\n+            span,\n+            &format!(\n+                \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n+                op, m, c\n+            ),\n+        );\n+    }\n+}\n+\n+fn fetch_int_literal(cx: &LateContext<'_, '_>, lit: &Expr<'_>) -> Option<u128> {\n+    match constant(cx, cx.tables, lit)?.0 {\n+        Constant::Int(n) => Some(n),\n+        _ => None,\n+    }\n+}"}, {"sha": "6f26f031431dbfb0eb7cda8e722a59fc14ebf1bc", "filename": "src/tools/clippy/clippy_lints/src/blacklisted_name.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,51 @@\n+use crate::utils::span_lint;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{Pat, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of blacklisted names for variables, such\n+    /// as `foo`.\n+    ///\n+    /// **Why is this bad?** These names are usually placeholder names and should be\n+    /// avoided.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let foo = 3.14;\n+    /// ```\n+    pub BLACKLISTED_NAME,\n+    style,\n+    \"usage of a blacklisted/placeholder name\"\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct BlacklistedName {\n+    blacklist: FxHashSet<String>,\n+}\n+\n+impl BlacklistedName {\n+    pub fn new(blacklist: FxHashSet<String>) -> Self {\n+        Self { blacklist }\n+    }\n+}\n+\n+impl_lint_pass!(BlacklistedName => [BLACKLISTED_NAME]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlacklistedName {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat<'_>) {\n+        if let PatKind::Binding(.., ident, _) = pat.kind {\n+            if self.blacklist.contains(&ident.name.to_string()) {\n+                span_lint(\n+                    cx,\n+                    BLACKLISTED_NAME,\n+                    ident.span,\n+                    &format!(\"use of a blacklisted/placeholder name `{}`\", ident.name),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "9e533eaa32c93a08e5866245f52741238378af52", "filename": "src/tools/clippy/clippy_lints/src/block_in_if_condition.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,148 @@\n+use crate::utils::{differing_macro_contexts, higher, snippet_block_with_applicability, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{BlockCheckMode, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `if` conditions that use blocks to contain an\n+    /// expression.\n+    ///\n+    /// **Why is this bad?** It isn't really Rust style, same as using parentheses\n+    /// to contain expressions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if { true } { /* ... */ }\n+    /// ```\n+    pub BLOCK_IN_IF_CONDITION_EXPR,\n+    style,\n+    \"braces that can be eliminated in conditions, e.g., `if { true } ...`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `if` conditions that use blocks containing\n+    /// statements, or conditions that use closures with blocks.\n+    ///\n+    /// **Why is this bad?** Using blocks in the condition makes it hard to read.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// if { let x = somefunc(); x } {}\n+    /// // or\n+    /// if somefunc(|x| { x == 47 }) {}\n+    /// ```\n+    pub BLOCK_IN_IF_CONDITION_STMT,\n+    style,\n+    \"complex blocks in conditions, e.g., `if { let x = true; x } ...`\"\n+}\n+\n+declare_lint_pass!(BlockInIfCondition => [BLOCK_IN_IF_CONDITION_EXPR, BLOCK_IN_IF_CONDITION_STMT]);\n+\n+struct ExVisitor<'a, 'tcx> {\n+    found_block: Option<&'tcx Expr<'tcx>>,\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if let ExprKind::Closure(_, _, eid, _, _) = expr.kind {\n+            let body = self.cx.tcx.hir().body(eid);\n+            let ex = &body.value;\n+            if matches!(ex.kind, ExprKind::Block(_, _)) && !body.value.span.from_expansion() {\n+                self.found_block = Some(ex);\n+                return;\n+            }\n+        }\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+const BRACED_EXPR_MESSAGE: &str = \"omit braces around single expression condition\";\n+const COMPLEX_BLOCK_MESSAGE: &str = \"in an `if` condition, avoid complex blocks or closures with blocks; \\\n+                                     instead, move the block or closure higher and bind it with a `let`\";\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+        if let Some((cond, _, _)) = higher::if_block(&expr) {\n+            if let ExprKind::Block(block, _) = &cond.kind {\n+                if block.rules == BlockCheckMode::DefaultBlock {\n+                    if block.stmts.is_empty() {\n+                        if let Some(ex) = &block.expr {\n+                            // don't dig into the expression here, just suggest that they remove\n+                            // the block\n+                            if expr.span.from_expansion() || differing_macro_contexts(expr.span, ex.span) {\n+                                return;\n+                            }\n+                            let mut applicability = Applicability::MachineApplicable;\n+                            span_lint_and_sugg(\n+                                cx,\n+                                BLOCK_IN_IF_CONDITION_EXPR,\n+                                cond.span,\n+                                BRACED_EXPR_MESSAGE,\n+                                \"try\",\n+                                format!(\n+                                    \"{}\",\n+                                    snippet_block_with_applicability(\n+                                        cx,\n+                                        ex.span,\n+                                        \"..\",\n+                                        Some(expr.span),\n+                                        &mut applicability\n+                                    )\n+                                ),\n+                                applicability,\n+                            );\n+                        }\n+                    } else {\n+                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n+                        if span.from_expansion() || differing_macro_contexts(expr.span, span) {\n+                            return;\n+                        }\n+                        // move block higher\n+                        let mut applicability = Applicability::MachineApplicable;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            BLOCK_IN_IF_CONDITION_STMT,\n+                            expr.span.with_hi(cond.span.hi()),\n+                            COMPLEX_BLOCK_MESSAGE,\n+                            \"try\",\n+                            format!(\n+                                \"let res = {}; if res\",\n+                                snippet_block_with_applicability(\n+                                    cx,\n+                                    block.span,\n+                                    \"..\",\n+                                    Some(expr.span),\n+                                    &mut applicability\n+                                ),\n+                            ),\n+                            applicability,\n+                        );\n+                    }\n+                }\n+            } else {\n+                let mut visitor = ExVisitor { found_block: None, cx };\n+                walk_expr(&mut visitor, cond);\n+                if let Some(block) = visitor.found_block {\n+                    span_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "8031052e073d5f8eacf8c45187ca7e0bf185ddb2", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "added", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,499 @@\n+use crate::utils::{\n+    get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt, span_lint_and_sugg,\n+    span_lint_and_then, SpanlessEq,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for boolean expressions that can be written more\n+    /// concisely.\n+    ///\n+    /// **Why is this bad?** Readability of boolean expressions suffers from\n+    /// unnecessary duplication.\n+    ///\n+    /// **Known problems:** Ignores short circuiting behavior of `||` and\n+    /// `&&`. Ignores `|`, `&` and `^`.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if a && true  // should be: if a\n+    /// if !(a == b)  // should be: if a != b\n+    /// ```\n+    pub NONMINIMAL_BOOL,\n+    complexity,\n+    \"boolean expressions that can be written more concisely\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for boolean expressions that contain terminals that\n+    /// can be eliminated.\n+    ///\n+    /// **Why is this bad?** This is most likely a logic bug.\n+    ///\n+    /// **Known problems:** Ignores short circuiting behavior.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if a && b || a { ... }\n+    /// ```\n+    /// The `b` is unnecessary, the expression is equivalent to `if a`.\n+    pub LOGIC_BUG,\n+    correctness,\n+    \"boolean expressions that contain terminals which can be eliminated\"\n+}\n+\n+// For each pairs, both orders are considered.\n+const METHODS_WITH_NEGATION: [(&str, &str); 2] = [(\"is_some\", \"is_none\"), (\"is_err\", \"is_ok\")];\n+\n+declare_lint_pass!(NonminimalBool => [NONMINIMAL_BOOL, LOGIC_BUG]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonminimalBool {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        _: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        _: Span,\n+        _: HirId,\n+    ) {\n+        NonminimalBoolVisitor { cx }.visit_body(body)\n+    }\n+}\n+\n+struct NonminimalBoolVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+use quine_mc_cluskey::Bool;\n+struct Hir2Qmm<'a, 'tcx, 'v> {\n+    terminals: Vec<&'v Expr<'v>>,\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n+    fn extract(&mut self, op: BinOpKind, a: &[&'v Expr<'_>], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n+        for a in a {\n+            if let ExprKind::Binary(binop, lhs, rhs) = &a.kind {\n+                if binop.node == op {\n+                    v = self.extract(op, &[lhs, rhs], v)?;\n+                    continue;\n+                }\n+            }\n+            v.push(self.run(a)?);\n+        }\n+        Ok(v)\n+    }\n+\n+    fn run(&mut self, e: &'v Expr<'_>) -> Result<Bool, String> {\n+        fn negate(bin_op_kind: BinOpKind) -> Option<BinOpKind> {\n+            match bin_op_kind {\n+                BinOpKind::Eq => Some(BinOpKind::Ne),\n+                BinOpKind::Ne => Some(BinOpKind::Eq),\n+                BinOpKind::Gt => Some(BinOpKind::Le),\n+                BinOpKind::Ge => Some(BinOpKind::Lt),\n+                BinOpKind::Lt => Some(BinOpKind::Ge),\n+                BinOpKind::Le => Some(BinOpKind::Gt),\n+                _ => None,\n+            }\n+        }\n+\n+        // prevent folding of `cfg!` macros and the like\n+        if !e.span.from_expansion() {\n+            match &e.kind {\n+                ExprKind::Unary(UnOp::UnNot, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprKind::Binary(binop, lhs, rhs) => match &binop.node {\n+                    BinOpKind::Or => return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?)),\n+                    BinOpKind::And => return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?)),\n+                    _ => (),\n+                },\n+                ExprKind::Lit(lit) => match lit.node {\n+                    LitKind::Bool(true) => return Ok(Bool::True),\n+                    LitKind::Bool(false) => return Ok(Bool::False),\n+                    _ => (),\n+                },\n+                _ => (),\n+            }\n+        }\n+        for (n, expr) in self.terminals.iter().enumerate() {\n+            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e, expr) {\n+                #[allow(clippy::cast_possible_truncation)]\n+                return Ok(Bool::Term(n as u8));\n+            }\n+\n+            if_chain! {\n+                if let ExprKind::Binary(e_binop, e_lhs, e_rhs) = &e.kind;\n+                if implements_ord(self.cx, e_lhs);\n+                if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.kind;\n+                if negate(e_binop.node) == Some(expr_binop.node);\n+                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_lhs, expr_lhs);\n+                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_rhs, expr_rhs);\n+                then {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n+                }\n+            }\n+        }\n+        let n = self.terminals.len();\n+        self.terminals.push(e);\n+        if n < 32 {\n+            #[allow(clippy::cast_possible_truncation)]\n+            Ok(Bool::Term(n as u8))\n+        } else {\n+            Err(\"too many literals\".to_owned())\n+        }\n+    }\n+}\n+\n+struct SuggestContext<'a, 'tcx, 'v> {\n+    terminals: &'v [&'v Expr<'v>],\n+    cx: &'a LateContext<'a, 'tcx>,\n+    output: String,\n+}\n+\n+impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n+    fn recurse(&mut self, suggestion: &Bool) -> Option<()> {\n+        use quine_mc_cluskey::Bool::{And, False, Not, Or, Term, True};\n+        match suggestion {\n+            True => {\n+                self.output.push_str(\"true\");\n+            },\n+            False => {\n+                self.output.push_str(\"false\");\n+            },\n+            Not(inner) => match **inner {\n+                And(_) | Or(_) => {\n+                    self.output.push('!');\n+                    self.output.push('(');\n+                    self.recurse(inner);\n+                    self.output.push(')');\n+                },\n+                Term(n) => {\n+                    let terminal = self.terminals[n as usize];\n+                    if let Some(str) = simplify_not(self.cx, terminal) {\n+                        self.output.push_str(&str)\n+                    } else {\n+                        self.output.push('!');\n+                        let snip = snippet_opt(self.cx, terminal.span)?;\n+                        self.output.push_str(&snip);\n+                    }\n+                },\n+                True | False | Not(_) => {\n+                    self.output.push('!');\n+                    self.recurse(inner)?;\n+                },\n+            },\n+            And(v) => {\n+                for (index, inner) in v.iter().enumerate() {\n+                    if index > 0 {\n+                        self.output.push_str(\" && \");\n+                    }\n+                    if let Or(_) = *inner {\n+                        self.output.push('(');\n+                        self.recurse(inner);\n+                        self.output.push(')');\n+                    } else {\n+                        self.recurse(inner);\n+                    }\n+                }\n+            },\n+            Or(v) => {\n+                for (index, inner) in v.iter().rev().enumerate() {\n+                    if index > 0 {\n+                        self.output.push_str(\" || \");\n+                    }\n+                    self.recurse(inner);\n+                }\n+            },\n+            &Term(n) => {\n+                let snip = snippet_opt(self.cx, self.terminals[n as usize].span)?;\n+                self.output.push_str(&snip);\n+            },\n+        }\n+        Some(())\n+    }\n+}\n+\n+fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<String> {\n+    match &expr.kind {\n+        ExprKind::Binary(binop, lhs, rhs) => {\n+            if !implements_ord(cx, lhs) {\n+                return None;\n+            }\n+\n+            match binop.node {\n+                BinOpKind::Eq => Some(\" != \"),\n+                BinOpKind::Ne => Some(\" == \"),\n+                BinOpKind::Lt => Some(\" >= \"),\n+                BinOpKind::Gt => Some(\" <= \"),\n+                BinOpKind::Le => Some(\" > \"),\n+                BinOpKind::Ge => Some(\" < \"),\n+                _ => None,\n+            }\n+            .and_then(|op| {\n+                Some(format!(\n+                    \"{}{}{}\",\n+                    snippet_opt(cx, lhs.span)?,\n+                    op,\n+                    snippet_opt(cx, rhs.span)?\n+                ))\n+            })\n+        },\n+        ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n+            let type_of_receiver = cx.tables.expr_ty(&args[0]);\n+            if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type))\n+                && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type))\n+            {\n+                return None;\n+            }\n+            METHODS_WITH_NEGATION\n+                .iter()\n+                .cloned()\n+                .flat_map(|(a, b)| vec![(a, b), (b, a)])\n+                .find(|&(a, _)| {\n+                    let path: &str = &path.ident.name.as_str();\n+                    a == path\n+                })\n+                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, args[0].span)?, neg_method)))\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr<'_>]) -> String {\n+    let mut suggest_context = SuggestContext {\n+        terminals,\n+        cx,\n+        output: String::new(),\n+    };\n+    suggest_context.recurse(suggestion);\n+    suggest_context.output\n+}\n+\n+fn simple_negate(b: Bool) -> Bool {\n+    use quine_mc_cluskey::Bool::{And, False, Not, Or, Term, True};\n+    match b {\n+        True => False,\n+        False => True,\n+        t @ Term(_) => Not(Box::new(t)),\n+        And(mut v) => {\n+            for el in &mut v {\n+                *el = simple_negate(::std::mem::replace(el, True));\n+            }\n+            Or(v)\n+        },\n+        Or(mut v) => {\n+            for el in &mut v {\n+                *el = simple_negate(::std::mem::replace(el, True));\n+            }\n+            And(v)\n+        },\n+        Not(inner) => *inner,\n+    }\n+}\n+\n+#[derive(Default)]\n+struct Stats {\n+    terminals: [usize; 32],\n+    negations: usize,\n+    ops: usize,\n+}\n+\n+fn terminal_stats(b: &Bool) -> Stats {\n+    fn recurse(b: &Bool, stats: &mut Stats) {\n+        match b {\n+            True | False => stats.ops += 1,\n+            Not(inner) => {\n+                match **inner {\n+                    And(_) | Or(_) => stats.ops += 1, // brackets are also operations\n+                    _ => stats.negations += 1,\n+                }\n+                recurse(inner, stats);\n+            },\n+            And(v) | Or(v) => {\n+                stats.ops += v.len() - 1;\n+                for inner in v {\n+                    recurse(inner, stats);\n+                }\n+            },\n+            &Term(n) => stats.terminals[n as usize] += 1,\n+        }\n+    }\n+    use quine_mc_cluskey::Bool::{And, False, Not, Or, Term, True};\n+    let mut stats = Stats::default();\n+    recurse(b, &mut stats);\n+    stats\n+}\n+\n+impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n+    fn bool_expr(&self, e: &'tcx Expr<'_>) {\n+        let mut h2q = Hir2Qmm {\n+            terminals: Vec::new(),\n+            cx: self.cx,\n+        };\n+        if let Ok(expr) = h2q.run(e) {\n+            if h2q.terminals.len() > 8 {\n+                // QMC has exponentially slow behavior as the number of terminals increases\n+                // 8 is reasonable, it takes approximately 0.2 seconds.\n+                // See #825\n+                return;\n+            }\n+\n+            let stats = terminal_stats(&expr);\n+            let mut simplified = expr.simplify();\n+            for simple in Bool::Not(Box::new(expr)).simplify() {\n+                match simple {\n+                    Bool::Not(_) | Bool::True | Bool::False => {},\n+                    _ => simplified.push(Bool::Not(Box::new(simple.clone()))),\n+                }\n+                let simple_negated = simple_negate(simple);\n+                if simplified.iter().any(|s| *s == simple_negated) {\n+                    continue;\n+                }\n+                simplified.push(simple_negated);\n+            }\n+            let mut improvements = Vec::with_capacity(simplified.len());\n+            'simplified: for suggestion in &simplified {\n+                let simplified_stats = terminal_stats(suggestion);\n+                let mut improvement = false;\n+                for i in 0..32 {\n+                    // ignore any \"simplifications\" that end up requiring a terminal more often\n+                    // than in the original expression\n+                    if stats.terminals[i] < simplified_stats.terminals[i] {\n+                        continue 'simplified;\n+                    }\n+                    if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n+                        span_lint_and_then(\n+                            self.cx,\n+                            LOGIC_BUG,\n+                            e.span,\n+                            \"this boolean expression contains a logic bug\",\n+                            |diag| {\n+                                diag.span_help(\n+                                    h2q.terminals[i].span,\n+                                    \"this expression can be optimized out by applying boolean operations to the \\\n+                                     outer expression\",\n+                                );\n+                                diag.span_suggestion(\n+                                    e.span,\n+                                    \"it would look like the following\",\n+                                    suggest(self.cx, suggestion, &h2q.terminals),\n+                                    // nonminimal_bool can produce minimal but\n+                                    // not human readable expressions (#3141)\n+                                    Applicability::Unspecified,\n+                                );\n+                            },\n+                        );\n+                        // don't also lint `NONMINIMAL_BOOL`\n+                        return;\n+                    }\n+                    // if the number of occurrences of a terminal decreases or any of the stats\n+                    // decreases while none increases\n+                    improvement |= (stats.terminals[i] > simplified_stats.terminals[i])\n+                        || (stats.negations > simplified_stats.negations && stats.ops == simplified_stats.ops)\n+                        || (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n+                }\n+                if improvement {\n+                    improvements.push(suggestion);\n+                }\n+            }\n+            let nonminimal_bool_lint = |suggestions: Vec<_>| {\n+                span_lint_and_then(\n+                    self.cx,\n+                    NONMINIMAL_BOOL,\n+                    e.span,\n+                    \"this boolean expression can be simplified\",\n+                    |diag| {\n+                        diag.span_suggestions(\n+                            e.span,\n+                            \"try\",\n+                            suggestions.into_iter(),\n+                            // nonminimal_bool can produce minimal but\n+                            // not human readable expressions (#3141)\n+                            Applicability::Unspecified,\n+                        );\n+                    },\n+                );\n+            };\n+            if improvements.is_empty() {\n+                let mut visitor = NotSimplificationVisitor { cx: self.cx };\n+                visitor.visit_expr(e);\n+            } else {\n+                nonminimal_bool_lint(\n+                    improvements\n+                        .into_iter()\n+                        .map(|suggestion| suggest(self.cx, suggestion, &h2q.terminals))\n+                        .collect(),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+        if in_macro(e.span) {\n+            return;\n+        }\n+        match &e.kind {\n+            ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n+                self.bool_expr(e)\n+            },\n+            ExprKind::Unary(UnOp::UnNot, inner) => {\n+                if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n+                    self.bool_expr(e);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            },\n+            _ => walk_expr(self, e),\n+        }\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n+    let ty = cx.tables.expr_ty(expr);\n+    get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+}\n+\n+struct NotSimplificationVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Unary(UnOp::UnNot, inner) = &expr.kind {\n+            if let Some(suggestion) = simplify_not(self.cx, inner) {\n+                span_lint_and_sugg(\n+                    self.cx,\n+                    NONMINIMAL_BOOL,\n+                    expr.span,\n+                    \"this boolean expression can be simplified\",\n+                    \"try\",\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "91d3e47d7870c21ab7f6034e0d9c7f56dfeac100", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,117 @@\n+use crate::utils::{\n+    contains_name, get_pat_name, match_type, paths, single_segment_path, snippet_with_applicability,\n+    span_lint_and_sugg, walk_ptrs_ty,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{Name, UintTy};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for naive byte counts\n+    ///\n+    /// **Why is this bad?** The [`bytecount`](https://crates.io/crates/bytecount)\n+    /// crate has methods to count your bytes faster, especially for large slices.\n+    ///\n+    /// **Known problems:** If you have predominantly small slices, the\n+    /// `bytecount::count(..)` method may actually be slower. However, if you can\n+    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n+    /// faster in those cases.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # let vec = vec![1_u8];\n+    /// &vec.iter().filter(|x| **x == 0u8).count(); // use bytecount::count instead\n+    /// ```\n+    pub NAIVE_BYTECOUNT,\n+    perf,\n+    \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n+}\n+\n+declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.kind;\n+            if count.ident.name == sym!(count);\n+            if count_args.len() == 1;\n+            if let ExprKind::MethodCall(ref filter, _, ref filter_args) = count_args[0].kind;\n+            if filter.ident.name == sym!(filter);\n+            if filter_args.len() == 2;\n+            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n+            then {\n+                let body = cx.tcx.hir().body(body_id);\n+                if_chain! {\n+                    if body.params.len() == 1;\n+                    if let Some(argname) = get_pat_name(&body.params[0].pat);\n+                    if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n+                    if op.node == BinOpKind::Eq;\n+                    if match_type(cx,\n+                               walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n+                               &paths::SLICE_ITER);\n+                    then {\n+                        let needle = match get_path_name(l) {\n+                            Some(name) if check_arg(name, argname, r) => r,\n+                            _ => match get_path_name(r) {\n+                                Some(name) if check_arg(name, argname, l) => l,\n+                                _ => { return; }\n+                            }\n+                        };\n+                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).kind {\n+                            return;\n+                        }\n+                        let haystack = if let ExprKind::MethodCall(ref path, _, ref args) =\n+                                filter_args[0].kind {\n+                            let p = path.ident.name;\n+                            if (p == sym!(iter) || p == sym!(iter_mut)) && args.len() == 1 {\n+                                &args[0]\n+                            } else {\n+                                &filter_args[0]\n+                            }\n+                        } else {\n+                            &filter_args[0]\n+                        };\n+                        let mut applicability = Applicability::MaybeIncorrect;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            NAIVE_BYTECOUNT,\n+                            expr.span,\n+                            \"You appear to be counting bytes the naive way\",\n+                            \"Consider using the bytecount crate\",\n+                            format!(\"bytecount::count({}, {})\",\n+                                    snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n+                                    snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n+                            applicability,\n+                        );\n+                    }\n+                };\n+            }\n+        };\n+    }\n+}\n+\n+fn check_arg(name: Name, arg: Name, needle: &Expr<'_>) -> bool {\n+    name == arg && !contains_name(name, needle)\n+}\n+\n+fn get_path_name(expr: &Expr<'_>) -> Option<Name> {\n+    match expr.kind {\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) | ExprKind::Unary(UnOp::UnDeref, ref e) => {\n+            get_path_name(e)\n+        },\n+        ExprKind::Block(ref b, _) => {\n+            if b.stmts.is_empty() {\n+                b.expr.as_ref().and_then(|p| get_path_name(p))\n+            } else {\n+                None\n+            }\n+        },\n+        ExprKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n+        _ => None,\n+    }\n+}"}, {"sha": "782da249808d0e71b3af319d9ef86cdb66236338", "filename": "src/tools/clippy/clippy_lints/src/cargo_common_metadata.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,105 @@\n+//! lint on missing cargo common metadata\n+\n+use std::path::PathBuf;\n+\n+use crate::utils::{run_lints, span_lint};\n+use rustc_hir::{hir_id::CRATE_HIR_ID, Crate};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::DUMMY_SP;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks to see if all common metadata is defined in\n+    /// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n+    ///\n+    /// **Why is this bad?** It will be more difficult for users to discover the\n+    /// purpose of the crate, and key information related to it.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```toml\n+    /// # This `Cargo.toml` is missing an authors field:\n+    /// [package]\n+    /// name = \"clippy\"\n+    /// version = \"0.0.212\"\n+    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n+    /// readme = \"README.md\"\n+    /// license = \"MIT OR Apache-2.0\"\n+    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n+    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+    /// ```\n+    pub CARGO_COMMON_METADATA,\n+    cargo,\n+    \"common metadata is defined in `Cargo.toml`\"\n+}\n+\n+fn warning(cx: &LateContext<'_, '_>, message: &str) {\n+    span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, message);\n+}\n+\n+fn missing_warning(cx: &LateContext<'_, '_>, package: &cargo_metadata::Package, field: &str) {\n+    let message = format!(\"package `{}` is missing `{}` metadata\", package.name, field);\n+    warning(cx, &message);\n+}\n+\n+fn is_empty_str(value: &Option<String>) -> bool {\n+    value.as_ref().map_or(true, String::is_empty)\n+}\n+\n+fn is_empty_path(value: &Option<PathBuf>) -> bool {\n+    value.as_ref().and_then(|x| x.to_str()).map_or(true, str::is_empty)\n+}\n+\n+fn is_empty_vec(value: &[String]) -> bool {\n+    // This works because empty iterators return true\n+    value.iter().all(String::is_empty)\n+}\n+\n+declare_lint_pass!(CargoCommonMetadata => [CARGO_COMMON_METADATA]);\n+\n+impl LateLintPass<'_, '_> for CargoCommonMetadata {\n+    fn check_crate(&mut self, cx: &LateContext<'_, '_>, _: &Crate<'_>) {\n+        if !run_lints(cx, &[CARGO_COMMON_METADATA], CRATE_HIR_ID) {\n+            return;\n+        }\n+\n+        let metadata = if let Ok(metadata) = cargo_metadata::MetadataCommand::new().no_deps().exec() {\n+            metadata\n+        } else {\n+            warning(cx, \"could not read cargo metadata\");\n+            return;\n+        };\n+\n+        for package in metadata.packages {\n+            if is_empty_vec(&package.authors) {\n+                missing_warning(cx, &package, \"package.authors\");\n+            }\n+\n+            if is_empty_str(&package.description) {\n+                missing_warning(cx, &package, \"package.description\");\n+            }\n+\n+            if is_empty_str(&package.license) && is_empty_path(&package.license_file) {\n+                missing_warning(cx, &package, \"either package.license or package.license_file\");\n+            }\n+\n+            if is_empty_str(&package.repository) {\n+                missing_warning(cx, &package, \"package.repository\");\n+            }\n+\n+            if is_empty_path(&package.readme) {\n+                missing_warning(cx, &package, \"package.readme\");\n+            }\n+\n+            if is_empty_vec(&package.keywords) {\n+                missing_warning(cx, &package, \"package.keywords\");\n+            }\n+\n+            if is_empty_vec(&package.categories) {\n+                missing_warning(cx, &package, \"package.categories\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "d9776dd50a836add3ab5635534b41bbe225c6180", "filename": "src/tools/clippy/clippy_lints/src/checked_conversions.rs", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,345 @@\n+//! lint on manually implemented checked conversions that could be transformed into `try_from`\n+\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, QPath, TyKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit bounds checking when casting.\n+    ///\n+    /// **Why is this bad?** Reduces the readability of statements & is error prone.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let foo: u32 = 5;\n+    /// # let _ =\n+    /// foo <= i32::MAX as u32\n+    /// # ;\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// # use std::convert::TryFrom;\n+    /// # let foo = 1;\n+    /// # let _ =\n+    /// i32::try_from(foo).is_ok()\n+    /// # ;\n+    /// ```\n+    pub CHECKED_CONVERSIONS,\n+    pedantic,\n+    \"`try_from` could replace manual bounds checking when casting\"\n+}\n+\n+declare_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CheckedConversions {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, item: &Expr<'_>) {\n+        let result = if_chain! {\n+            if !in_external_macro(cx.sess(), item.span);\n+            if let ExprKind::Binary(op, ref left, ref right) = &item.kind;\n+\n+            then {\n+                match op.node {\n+                    BinOpKind::Ge | BinOpKind::Le => single_check(item),\n+                    BinOpKind::And => double_check(cx, left, right),\n+                    _ => None,\n+                }\n+            } else {\n+                None\n+            }\n+        };\n+\n+        if_chain! {\n+            if let Some(cv) = result;\n+            if let Some(to_type) = cv.to_type;\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let snippet = snippet_with_applicability(cx, cv.expr_to_cast.span, \"_\", &mut\n+                                applicability);\n+                span_lint_and_sugg(\n+                    cx,\n+                    CHECKED_CONVERSIONS,\n+                    item.span,\n+                    \"Checked cast can be simplified.\",\n+                    \"try\",\n+                    format!(\"{}::try_from({}).is_ok()\",\n+                            to_type,\n+                            snippet),\n+                    applicability\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Searches for a single check from unsigned to _ is done\n+/// todo: check for case signed -> larger unsigned == only x >= 0\n+fn single_check<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n+    check_upper_bound(expr).filter(|cv| cv.cvt == ConversionType::FromUnsigned)\n+}\n+\n+/// Searches for a combination of upper & lower bound checks\n+fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr<'_>, right: &'a Expr<'_>) -> Option<Conversion<'a>> {\n+    let upper_lower = |l, r| {\n+        let upper = check_upper_bound(l);\n+        let lower = check_lower_bound(r);\n+\n+        transpose(upper, lower).and_then(|(l, r)| l.combine(r, cx))\n+    };\n+\n+    upper_lower(left, right).or_else(|| upper_lower(right, left))\n+}\n+\n+/// Contains the result of a tried conversion check\n+#[derive(Clone, Debug)]\n+struct Conversion<'a> {\n+    cvt: ConversionType,\n+    expr_to_cast: &'a Expr<'a>,\n+    to_type: Option<&'a str>,\n+}\n+\n+/// The kind of conversion that is checked\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum ConversionType {\n+    SignedToUnsigned,\n+    SignedToSigned,\n+    FromUnsigned,\n+}\n+\n+impl<'a> Conversion<'a> {\n+    /// Combine multiple conversions if the are compatible\n+    pub fn combine(self, other: Self, cx: &LateContext<'_, '_>) -> Option<Conversion<'a>> {\n+        if self.is_compatible(&other, cx) {\n+            // Prefer a Conversion that contains a type-constraint\n+            Some(if self.to_type.is_some() { self } else { other })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Checks if two conversions are compatible\n+    /// same type of conversion, same 'castee' and same 'to type'\n+    pub fn is_compatible(&self, other: &Self, cx: &LateContext<'_, '_>) -> bool {\n+        (self.cvt == other.cvt)\n+            && (SpanlessEq::new(cx).eq_expr(self.expr_to_cast, other.expr_to_cast))\n+            && (self.has_compatible_to_type(other))\n+    }\n+\n+    /// Checks if the to-type is the same (if there is a type constraint)\n+    fn has_compatible_to_type(&self, other: &Self) -> bool {\n+        transpose(self.to_type.as_ref(), other.to_type.as_ref()).map_or(true, |(l, r)| l == r)\n+    }\n+\n+    /// Try to construct a new conversion if the conversion type is valid\n+    fn try_new(expr_to_cast: &'a Expr<'_>, from_type: &str, to_type: &'a str) -> Option<Conversion<'a>> {\n+        ConversionType::try_new(from_type, to_type).map(|cvt| Conversion {\n+            cvt,\n+            expr_to_cast,\n+            to_type: Some(to_type),\n+        })\n+    }\n+\n+    /// Construct a new conversion without type constraint\n+    fn new_any(expr_to_cast: &'a Expr<'_>) -> Conversion<'a> {\n+        Conversion {\n+            cvt: ConversionType::SignedToUnsigned,\n+            expr_to_cast,\n+            to_type: None,\n+        }\n+    }\n+}\n+\n+impl ConversionType {\n+    /// Creates a conversion type if the type is allowed & conversion is valid\n+    #[must_use]\n+    fn try_new(from: &str, to: &str) -> Option<Self> {\n+        if UINTS.contains(&from) {\n+            Some(Self::FromUnsigned)\n+        } else if SINTS.contains(&from) {\n+            if UINTS.contains(&to) {\n+                Some(Self::SignedToUnsigned)\n+            } else if SINTS.contains(&to) {\n+                Some(Self::SignedToSigned)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr <= (to_type::MAX as from_type)`\n+fn check_upper_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n+    if_chain! {\n+         if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind;\n+         if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n+         if let Some((from, to)) = get_types_from_cast(check, MAX_VALUE, INTS);\n+\n+         then {\n+             Conversion::try_new(candidate, from, to)\n+         } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr >= 0|(to_type::MIN as from_type)`\n+fn check_lower_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n+    fn check_function<'a>(candidate: &'a Expr<'a>, check: &'a Expr<'a>) -> Option<Conversion<'a>> {\n+        (check_lower_bound_zero(candidate, check)).or_else(|| (check_lower_bound_min(candidate, check)))\n+    }\n+\n+    // First of we need a binary containing the expression & the cast\n+    if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind {\n+        normalize_le_ge(op, right, left).and_then(|(l, r)| check_function(l, r))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Check for `expr >= 0`\n+fn check_lower_bound_zero<'a>(candidate: &'a Expr<'_>, check: &'a Expr<'_>) -> Option<Conversion<'a>> {\n+    if_chain! {\n+        if let ExprKind::Lit(ref lit) = &check.kind;\n+        if let LitKind::Int(0, _) = &lit.node;\n+\n+        then {\n+            Some(Conversion::new_any(candidate))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr >= (to_type::MIN as from_type)`\n+fn check_lower_bound_min<'a>(candidate: &'a Expr<'_>, check: &'a Expr<'_>) -> Option<Conversion<'a>> {\n+    if let Some((from, to)) = get_types_from_cast(check, MIN_VALUE, SINTS) {\n+        Conversion::try_new(candidate, from, to)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Tries to extract the from- and to-type from a cast expression\n+fn get_types_from_cast<'a>(expr: &'a Expr<'_>, func: &'a str, types: &'a [&str]) -> Option<(&'a str, &'a str)> {\n+    // `to_type::maxmin_value() as from_type`\n+    let call_from_cast: Option<(&Expr<'_>, &str)> = if_chain! {\n+        // to_type::maxmin_value(), from_type\n+        if let ExprKind::Cast(ref limit, ref from_type) = &expr.kind;\n+        if let TyKind::Path(ref from_type_path) = &from_type.kind;\n+        if let Some(from_sym) = int_ty_to_sym(from_type_path);\n+\n+        then {\n+            Some((limit, from_sym))\n+        } else {\n+            None\n+        }\n+    };\n+\n+    // `from_type::from(to_type::maxmin_value())`\n+    let limit_from: Option<(&Expr<'_>, &str)> = call_from_cast.or_else(|| {\n+        if_chain! {\n+            // `from_type::from, to_type::maxmin_value()`\n+            if let ExprKind::Call(ref from_func, ref args) = &expr.kind;\n+            // `to_type::maxmin_value()`\n+            if args.len() == 1;\n+            if let limit = &args[0];\n+            // `from_type::from`\n+            if let ExprKind::Path(ref path) = &from_func.kind;\n+            if let Some(from_sym) = get_implementing_type(path, INTS, FROM);\n+\n+            then {\n+                Some((limit, from_sym))\n+            } else {\n+                None\n+            }\n+        }\n+    });\n+\n+    if let Some((limit, from_type)) = limit_from {\n+        if_chain! {\n+            if let ExprKind::Call(ref fun_name, _) = &limit.kind;\n+            // `to_type, maxmin_value`\n+            if let ExprKind::Path(ref path) = &fun_name.kind;\n+            // `to_type`\n+            if let Some(to_type) = get_implementing_type(path, types, func);\n+\n+            then {\n+                Some((from_type, to_type))\n+            } else {\n+                None\n+            }\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Gets the type which implements the called function\n+fn get_implementing_type<'a>(path: &QPath<'_>, candidates: &'a [&str], function: &str) -> Option<&'a str> {\n+    if_chain! {\n+        if let QPath::TypeRelative(ref ty, ref path) = &path;\n+        if path.ident.name.as_str() == function;\n+        if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.kind;\n+        if let [int] = &*tp.segments;\n+        let name = &int.ident.name.as_str();\n+\n+        then {\n+            candidates.iter().find(|c| name == *c).cloned()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Gets the type as a string, if it is a supported integer\n+fn int_ty_to_sym<'tcx>(path: &QPath<'_>) -> Option<&'tcx str> {\n+    if_chain! {\n+        if let QPath::Resolved(_, ref path) = *path;\n+        if let [ty] = &*path.segments;\n+        let name = &ty.ident.name.as_str();\n+\n+        then {\n+            INTS.iter().find(|c| name == *c).cloned()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// (Option<T>, Option<U>) -> Option<(T, U)>\n+fn transpose<T, U>(lhs: Option<T>, rhs: Option<U>) -> Option<(T, U)> {\n+    match (lhs, rhs) {\n+        (Some(l), Some(r)) => Some((l, r)),\n+        _ => None,\n+    }\n+}\n+\n+/// Will return the expressions as if they were expr1 <= expr2\n+fn normalize_le_ge<'a>(op: &BinOp, left: &'a Expr<'a>, right: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n+    match op.node {\n+        BinOpKind::Le => Some((left, right)),\n+        BinOpKind::Ge => Some((right, left)),\n+        _ => None,\n+    }\n+}\n+\n+// Constants\n+const FROM: &str = \"from\";\n+const MAX_VALUE: &str = \"max_value\";\n+const MIN_VALUE: &str = \"min_value\";\n+\n+const UINTS: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"usize\"];\n+const SINTS: &[&str] = &[\"i8\", \"i16\", \"i32\", \"i64\", \"isize\"];\n+const INTS: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"isize\"];"}, {"sha": "3ba72e84fa827a7dace8698873b845b815fe1ae6", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,163 @@\n+//! calculate cognitive complexity and warn about overly complex functions\n+\n+use rustc_ast::ast::Attribute;\n+use rustc_hir::intravisit::{walk_expr, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Span;\n+use rustc_span::BytePos;\n+\n+use crate::utils::{is_type_diagnostic_item, snippet_opt, span_lint_and_help, LimitStack};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for methods with high cognitive complexity.\n+    ///\n+    /// **Why is this bad?** Methods of high cognitive complexity tend to be hard to\n+    /// both read and maintain. Also LLVM will tend to optimize small methods better.\n+    ///\n+    /// **Known problems:** Sometimes it's hard to find a way to reduce the\n+    /// complexity.\n+    ///\n+    /// **Example:** No. You'll see it when you get the warning.\n+    pub COGNITIVE_COMPLEXITY,\n+    nursery,\n+    \"functions that should be split up into multiple functions\"\n+}\n+\n+pub struct CognitiveComplexity {\n+    limit: LimitStack,\n+}\n+\n+impl CognitiveComplexity {\n+    #[must_use]\n+    pub fn new(limit: u64) -> Self {\n+        Self {\n+            limit: LimitStack::new(limit),\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(CognitiveComplexity => [COGNITIVE_COMPLEXITY]);\n+\n+impl CognitiveComplexity {\n+    #[allow(clippy::cast_possible_truncation)]\n+    fn check<'a, 'tcx>(\n+        &mut self,\n+        cx: &'a LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        body_span: Span,\n+    ) {\n+        if body_span.from_expansion() {\n+            return;\n+        }\n+\n+        let expr = &body.value;\n+\n+        let mut helper = CCHelper { cc: 1, returns: 0 };\n+        helper.visit_expr(expr);\n+        let CCHelper { cc, returns } = helper;\n+        let ret_ty = cx.tables.node_type(expr.hir_id);\n+        let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym!(result_type)) {\n+            returns\n+        } else {\n+            #[allow(clippy::integer_division)]\n+            (returns / 2)\n+        };\n+\n+        let mut rust_cc = cc;\n+        // prevent degenerate cases where unreachable code contains `return` statements\n+        if rust_cc >= ret_adjust {\n+            rust_cc -= ret_adjust;\n+        }\n+\n+        if rust_cc > self.limit.limit() {\n+            let fn_span = match kind {\n+                FnKind::ItemFn(ident, _, _, _, _) | FnKind::Method(ident, _, _, _) => ident.span,\n+                FnKind::Closure(_) => {\n+                    let header_span = body_span.with_hi(decl.output.span().lo());\n+                    let pos = snippet_opt(cx, header_span).and_then(|snip| {\n+                        let low_offset = snip.find('|')?;\n+                        let high_offset = 1 + snip.get(low_offset + 1..)?.find('|')?;\n+                        let low = header_span.lo() + BytePos(low_offset as u32);\n+                        let high = low + BytePos(high_offset as u32 + 1);\n+\n+                        Some((low, high))\n+                    });\n+\n+                    if let Some((low, high)) = pos {\n+                        Span::new(low, high, header_span.ctxt())\n+                    } else {\n+                        return;\n+                    }\n+                },\n+            };\n+\n+            span_lint_and_help(\n+                cx,\n+                COGNITIVE_COMPLEXITY,\n+                fn_span,\n+                &format!(\n+                    \"the function has a cognitive complexity of ({}/{})\",\n+                    rust_cc,\n+                    self.limit.limit()\n+                ),\n+                None,\n+                \"you could split it up into multiple smaller functions\",\n+            );\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CognitiveComplexity {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        let def_id = cx.tcx.hir().local_def_id(hir_id);\n+        if !cx.tcx.has_attr(def_id.to_def_id(), sym!(test)) {\n+            self.check(cx, kind, decl, body, span);\n+        }\n+    }\n+\n+    fn enter_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n+        self.limit.push_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n+    }\n+    fn exit_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n+        self.limit.pop_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n+    }\n+}\n+\n+struct CCHelper {\n+    cc: u64,\n+    returns: u64,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for CCHelper {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+        walk_expr(self, e);\n+        match e.kind {\n+            ExprKind::Match(_, ref arms, _) => {\n+                if arms.len() > 1 {\n+                    self.cc += 1;\n+                }\n+                self.cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n+            },\n+            ExprKind::Ret(_) => self.returns += 1,\n+            _ => {},\n+        }\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "8090f4673aae0e225f5507869893c6cfcd4c639b", "filename": "src/tools/clippy/clippy_lints/src/collapsible_if.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,170 @@\n+//! Checks for if expressions that contain only an if expression.\n+//!\n+//! For example, the lint would catch:\n+//!\n+//! ```rust,ignore\n+//! if x {\n+//!     if y {\n+//!         println!(\"Hello world\");\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! This lint is **warn** by default\n+\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{snippet_block, snippet_block_with_applicability, span_lint_and_sugg, span_lint_and_then};\n+use rustc_errors::Applicability;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for nested `if` statements which can be collapsed\n+    /// by `&&`-combining their conditions and for `else { if ... }` expressions\n+    /// that\n+    /// can be collapsed to `else if ...`.\n+    ///\n+    /// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n+    /// makes code look more complex than it really is.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// if x {\n+    ///     if y {\n+    ///         \u2026\n+    ///     }\n+    /// }\n+    ///\n+    /// // or\n+    ///\n+    /// if x {\n+    ///     \u2026\n+    /// } else {\n+    ///     if y {\n+    ///         \u2026\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Should be written:\n+    ///\n+    /// ```rust.ignore\n+    /// if x && y {\n+    ///     \u2026\n+    /// }\n+    ///\n+    /// // or\n+    ///\n+    /// if x {\n+    ///     \u2026\n+    /// } else if y {\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    pub COLLAPSIBLE_IF,\n+    style,\n+    \"`if`s that can be collapsed (e.g., `if x { if y { ... } }` and `else { if x { ... } }`)\"\n+}\n+\n+declare_lint_pass!(CollapsibleIf => [COLLAPSIBLE_IF]);\n+\n+impl EarlyLintPass for CollapsibleIf {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n+        if !expr.span.from_expansion() {\n+            check_if(cx, expr)\n+        }\n+    }\n+}\n+\n+fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n+    if let ast::ExprKind::If(check, then, else_) = &expr.kind {\n+        if let Some(else_) = else_ {\n+            check_collapsible_maybe_if_let(cx, else_);\n+        } else if let ast::ExprKind::Let(..) = check.kind {\n+            // Prevent triggering on `if let a = b { if c { .. } }`.\n+        } else {\n+            check_collapsible_no_if_let(cx, expr, check, then);\n+        }\n+    }\n+}\n+\n+fn block_starts_with_comment(cx: &EarlyContext<'_>, expr: &ast::Block) -> bool {\n+    // We trim all opening braces and whitespaces and then check if the next string is a comment.\n+    let trimmed_block_text = snippet_block(cx, expr.span, \"..\", None)\n+        .trim_start_matches(|c: char| c.is_whitespace() || c == '{')\n+        .to_owned();\n+    trimmed_block_text.starts_with(\"//\") || trimmed_block_text.starts_with(\"/*\")\n+}\n+\n+fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n+    if_chain! {\n+        if let ast::ExprKind::Block(ref block, _) = else_.kind;\n+        if !block_starts_with_comment(cx, block);\n+        if let Some(else_) = expr_block(block);\n+        if !else_.span.from_expansion();\n+        if let ast::ExprKind::If(..) = else_.kind;\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                COLLAPSIBLE_IF,\n+                block.span,\n+                \"this `else { if .. }` block can be collapsed\",\n+                \"try\",\n+                snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability).into_owned(),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n+    if_chain! {\n+        if !block_starts_with_comment(cx, then);\n+        if let Some(inner) = expr_block(then);\n+        if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.kind;\n+        then {\n+            if let ast::ExprKind::Let(..) = check_inner.kind {\n+                // Prevent triggering on `if c { if let a = b { .. } }`.\n+                return;\n+            }\n+\n+            if expr.span.ctxt() != inner.span.ctxt() {\n+                return;\n+            }\n+            span_lint_and_then(cx, COLLAPSIBLE_IF, expr.span, \"this `if` statement can be collapsed\", |diag| {\n+                let lhs = Sugg::ast(cx, check, \"..\");\n+                let rhs = Sugg::ast(cx, check_inner, \"..\");\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"try\",\n+                    format!(\n+                        \"if {} {}\",\n+                        lhs.and(&rhs),\n+                        snippet_block(cx, content.span, \"..\", Some(expr.span)),\n+                    ),\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            });\n+        }\n+    }\n+}\n+\n+/// If the block contains only one expression, return it.\n+fn expr_block(block: &ast::Block) -> Option<&ast::Expr> {\n+    let mut it = block.stmts.iter();\n+\n+    if let (Some(stmt), None) = (it.next(), it.next()) {\n+        match stmt.kind {\n+            ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => Some(expr),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "96df3ffe3ce6727650e8da1c95448c046aab2f74", "filename": "src/tools/clippy/clippy_lints/src/comparison_chain.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,118 @@\n+use crate::utils::{\n+    get_trait_def_id, if_sequence, implements_trait, parent_node_is_if_expr, paths, span_lint_and_help, SpanlessEq,\n+};\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks comparison chains written with `if` that can be\n+    /// rewritten with `match` and `cmp`.\n+    ///\n+    /// **Why is this bad?** `if` is not guaranteed to be exhaustive and conditionals can get\n+    /// repetitive\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// # fn a() {}\n+    /// # fn b() {}\n+    /// # fn c() {}\n+    /// fn f(x: u8, y: u8) {\n+    ///     if x > y {\n+    ///         a()\n+    ///     } else if x < y {\n+    ///         b()\n+    ///     } else {\n+    ///         c()\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust,ignore\n+    /// use std::cmp::Ordering;\n+    /// # fn a() {}\n+    /// # fn b() {}\n+    /// # fn c() {}\n+    /// fn f(x: u8, y: u8) {\n+    ///      match x.cmp(&y) {\n+    ///          Ordering::Greater => a(),\n+    ///          Ordering::Less => b(),\n+    ///          Ordering::Equal => c()\n+    ///      }\n+    /// }\n+    /// ```\n+    pub COMPARISON_CHAIN,\n+    style,\n+    \"`if`s that can be rewritten with `match` and `cmp`\"\n+}\n+\n+declare_lint_pass!(ComparisonChain => [COMPARISON_CHAIN]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ComparisonChain {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        // We only care about the top-most `if` in the chain\n+        if parent_node_is_if_expr(expr, cx) {\n+            return;\n+        }\n+\n+        // Check that there exists at least one explicit else condition\n+        let (conds, _) = if_sequence(expr);\n+        if conds.len() < 2 {\n+            return;\n+        }\n+\n+        for cond in conds.windows(2) {\n+            if let (\n+                &ExprKind::Binary(ref kind1, ref lhs1, ref rhs1),\n+                &ExprKind::Binary(ref kind2, ref lhs2, ref rhs2),\n+            ) = (&cond[0].kind, &cond[1].kind)\n+            {\n+                if !kind_is_cmp(kind1.node) || !kind_is_cmp(kind2.node) {\n+                    return;\n+                }\n+\n+                // Check that both sets of operands are equal\n+                let mut spanless_eq = SpanlessEq::new(cx);\n+                if (!spanless_eq.eq_expr(lhs1, lhs2) || !spanless_eq.eq_expr(rhs1, rhs2))\n+                    && (!spanless_eq.eq_expr(lhs1, rhs2) || !spanless_eq.eq_expr(rhs1, lhs2))\n+                {\n+                    return;\n+                }\n+\n+                // Check that the type being compared implements `core::cmp::Ord`\n+                let ty = cx.tables.expr_ty(lhs1);\n+                let is_ord = get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]));\n+\n+                if !is_ord {\n+                    return;\n+                }\n+            } else {\n+                // We only care about comparison chains\n+                return;\n+            }\n+        }\n+        span_lint_and_help(\n+            cx,\n+            COMPARISON_CHAIN,\n+            expr.span,\n+            \"`if` chain can be rewritten with `match`\",\n+            None,\n+            \"Consider rewriting the `if` chain to use `cmp` and `match`.\",\n+        )\n+    }\n+}\n+\n+fn kind_is_cmp(kind: BinOpKind) -> bool {\n+    match kind {\n+        BinOpKind::Lt | BinOpKind::Gt | BinOpKind::Eq => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "81ddc8c0067c7184dd0e35af2bd5129724e2e7d2", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "added", "additions": 559, "deletions": 0, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,559 @@\n+#![allow(clippy::float_cmp)]\n+\n+use crate::utils::{clip, higher, sext, unsext};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::{bug, span_bug};\n+use rustc_span::symbol::Symbol;\n+use std::cmp::Ordering::{self, Equal};\n+use std::convert::TryInto;\n+use std::hash::{Hash, Hasher};\n+\n+/// A `LitKind`-like enum to fold constant `Expr`s into.\n+#[derive(Debug, Clone)]\n+pub enum Constant {\n+    /// A `String` (e.g., \"abc\").\n+    Str(String),\n+    /// A binary string (e.g., `b\"abc\"`).\n+    Binary(Lrc<Vec<u8>>),\n+    /// A single `char` (e.g., `'a'`).\n+    Char(char),\n+    /// An integer's bit representation.\n+    Int(u128),\n+    /// An `f32`.\n+    F32(f32),\n+    /// An `f64`.\n+    F64(f64),\n+    /// `true` or `false`.\n+    Bool(bool),\n+    /// An array of constants.\n+    Vec(Vec<Constant>),\n+    /// Also an array, but with only one constant, repeated N times.\n+    Repeat(Box<Constant>, u64),\n+    /// A tuple of constants.\n+    Tuple(Vec<Constant>),\n+    /// A raw pointer.\n+    RawPtr(u128),\n+    /// A literal with syntax error.\n+    Err(Symbol),\n+}\n+\n+impl PartialEq for Constant {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n+            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (&Self::Char(l), &Self::Char(r)) => l == r,\n+            (&Self::Int(l), &Self::Int(r)) => l == r,\n+            (&Self::F64(l), &Self::F64(r)) => {\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n+                l.to_bits() == r.to_bits()\n+            },\n+            (&Self::F32(l), &Self::F32(r)) => {\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n+                f64::from(l).to_bits() == f64::from(r).to_bits()\n+            },\n+            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n+            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            // TODO: are there inter-type equalities?\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Hash for Constant {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        std::mem::discriminant(self).hash(state);\n+        match *self {\n+            Self::Str(ref s) => {\n+                s.hash(state);\n+            },\n+            Self::Binary(ref b) => {\n+                b.hash(state);\n+            },\n+            Self::Char(c) => {\n+                c.hash(state);\n+            },\n+            Self::Int(i) => {\n+                i.hash(state);\n+            },\n+            Self::F32(f) => {\n+                f64::from(f).to_bits().hash(state);\n+            },\n+            Self::F64(f) => {\n+                f.to_bits().hash(state);\n+            },\n+            Self::Bool(b) => {\n+                b.hash(state);\n+            },\n+            Self::Vec(ref v) | Self::Tuple(ref v) => {\n+                v.hash(state);\n+            },\n+            Self::Repeat(ref c, l) => {\n+                c.hash(state);\n+                l.hash(state);\n+            },\n+            Self::RawPtr(u) => {\n+                u.hash(state);\n+            },\n+            Self::Err(ref s) => {\n+                s.hash(state);\n+            },\n+        }\n+    }\n+}\n+\n+impl Constant {\n+    pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n+        match (left, right) {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n+            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (&Self::Int(l), &Self::Int(r)) => {\n+                if let ty::Int(int_ty) = cmp_type.kind {\n+                    Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n+                } else {\n+                    Some(l.cmp(&r))\n+                }\n+            },\n+            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n+            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n+            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n+                .iter()\n+                .zip(r.iter())\n+                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n+                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n+                match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n+                    Some(Equal) => Some(ls.cmp(rs)),\n+                    x => x,\n+                }\n+            },\n+            // TODO: are there any useful inter-type orderings?\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Parses a `LitKind` to a `Constant`.\n+pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n+    match *lit {\n+        LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n+        LitKind::Byte(b) => Constant::Int(u128::from(b)),\n+        LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::Char(c) => Constant::Char(c),\n+        LitKind::Int(n, _) => Constant::Int(n),\n+        LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n+            FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n+            FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n+        },\n+        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind {\n+            ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n+            ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n+            _ => bug!(),\n+        },\n+        LitKind::Bool(b) => Constant::Bool(b),\n+        LitKind::Err(s) => Constant::Err(s),\n+    }\n+}\n+\n+pub fn constant<'c, 'cc>(\n+    lcx: &LateContext<'c, 'cc>,\n+    tables: &'c ty::TypeckTables<'cc>,\n+    e: &Expr<'_>,\n+) -> Option<(Constant, bool)> {\n+    let mut cx = ConstEvalLateContext {\n+        lcx,\n+        tables,\n+        param_env: lcx.param_env,\n+        needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n+    };\n+    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n+}\n+\n+pub fn constant_simple<'c, 'cc>(\n+    lcx: &LateContext<'c, 'cc>,\n+    tables: &'c ty::TypeckTables<'cc>,\n+    e: &Expr<'_>,\n+) -> Option<Constant> {\n+    constant(lcx, tables, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+}\n+\n+/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckTables`.\n+pub fn constant_context<'c, 'cc>(\n+    lcx: &'c LateContext<'c, 'cc>,\n+    tables: &'c ty::TypeckTables<'cc>,\n+) -> ConstEvalLateContext<'c, 'cc> {\n+    ConstEvalLateContext {\n+        lcx,\n+        tables,\n+        param_env: lcx.param_env,\n+        needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n+    }\n+}\n+\n+pub struct ConstEvalLateContext<'a, 'tcx> {\n+    lcx: &'a LateContext<'a, 'tcx>,\n+    tables: &'a ty::TypeckTables<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    needed_resolution: bool,\n+    substs: SubstsRef<'tcx>,\n+}\n+\n+impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n+    /// Simple constant folding: Insert an expression, get a constant or none.\n+    pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n+        if let Some((ref cond, ref then, otherwise)) = higher::if_block(&e) {\n+            return self.ifthenelse(cond, then, otherwise);\n+        }\n+        match e.kind {\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.tables.expr_ty(e)),\n+            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty_opt(e))),\n+            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(ref value, _) => {\n+                let n = match self.tables.expr_ty(e).kind {\n+                    ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n+                    _ => span_bug!(e.span, \"typeck error\"),\n+                };\n+                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n+            },\n+            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+                UnOp::UnNot => self.constant_not(&o, self.tables.expr_ty(e)),\n+                UnOp::UnNeg => self.constant_negate(&o, self.tables.expr_ty(e)),\n+                UnOp::UnDeref => Some(o),\n+            }),\n+            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n+            ExprKind::Call(ref callee, ref args) => {\n+                // We only handle a few const functions for now.\n+                if_chain! {\n+                    if args.is_empty();\n+                    if let ExprKind::Path(qpath) = &callee.kind;\n+                    let res = self.tables.qpath_res(qpath, callee.hir_id);\n+                    if let Some(def_id) = res.opt_def_id();\n+                    let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n+                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n+                    if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n+                    then {\n+                       let value = match int_impl {\n+                           \"<impl i8>\" => i8::max_value() as u128,\n+                           \"<impl i16>\" => i16::max_value() as u128,\n+                           \"<impl i32>\" => i32::max_value() as u128,\n+                           \"<impl i64>\" => i64::max_value() as u128,\n+                           \"<impl i128>\" => i128::max_value() as u128,\n+                           _ => return None,\n+                       };\n+                       Some(Constant::Int(value))\n+                    }\n+                    else {\n+                        None\n+                    }\n+                }\n+            },\n+            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n+            // TODO: add other expressions.\n+            _ => None,\n+        }\n+    }\n+\n+    #[allow(clippy::cast_possible_wrap)]\n+    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n+        use self::Constant::{Bool, Int};\n+        match *o {\n+            Bool(b) => Some(Bool(!b)),\n+            Int(value) => {\n+                let value = !value;\n+                match ty.kind {\n+                    ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n+                    ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n+                    _ => None,\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n+        use self::Constant::{Int, F32, F64};\n+        match *o {\n+            Int(value) => {\n+                let ity = match ty.kind {\n+                    ty::Int(ity) => ity,\n+                    _ => return None,\n+                };\n+                // sign extend\n+                let value = sext(self.lcx.tcx, value, ity);\n+                let value = value.checked_neg()?;\n+                // clear unused bits\n+                Some(Int(unsext(self.lcx.tcx, value, ity)))\n+            },\n+            F32(f) => Some(F32(-f)),\n+            F64(f) => Some(F64(-f)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Create `Some(Vec![..])` of all constants, unless there is any\n+    /// non-constant part.\n+    fn multi(&mut self, vec: &[Expr<'_>]) -> Option<Vec<Constant>> {\n+        vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n+    }\n+\n+    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n+    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'cc>) -> Option<Constant> {\n+        let res = self.tables.qpath_res(qpath, id);\n+        match res {\n+            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n+                let substs = self.tables.node_substs(id);\n+                let substs = if self.substs.is_empty() {\n+                    substs\n+                } else {\n+                    substs.subst(self.lcx.tcx, self.substs)\n+                };\n+\n+                let result = self\n+                    .lcx\n+                    .tcx\n+                    .const_eval_resolve(self.param_env, def_id, substs, None, None)\n+                    .ok()\n+                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n+                let result = miri_to_const(&result);\n+                if result.is_some() {\n+                    self.needed_resolution = true;\n+                }\n+                result\n+            },\n+            // FIXME: cover all usable cases.\n+            _ => None,\n+        }\n+    }\n+\n+    fn index(&mut self, lhs: &'_ Expr<'_>, index: &'_ Expr<'_>) -> Option<Constant> {\n+        let lhs = self.expr(lhs);\n+        let index = self.expr(index);\n+\n+        match (lhs, index) {\n+            (Some(Constant::Vec(vec)), Some(Constant::Int(index))) => match vec.get(index as usize) {\n+                Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n+                Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n+                _ => None,\n+            },\n+            (Some(Constant::Vec(vec)), _) => {\n+                if !vec.is_empty() && vec.iter().all(|x| *x == vec[0]) {\n+                    match vec.get(0) {\n+                        Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n+                        Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n+                        _ => None,\n+                    }\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// A block can only yield a constant if it only has one constant expression.\n+    fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n+        if block.stmts.is_empty() {\n+            block.expr.as_ref().and_then(|b| self.expr(b))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn ifthenelse(&mut self, cond: &Expr<'_>, then: &Expr<'_>, otherwise: Option<&Expr<'_>>) -> Option<Constant> {\n+        if let Some(Constant::Bool(b)) = self.expr(cond) {\n+            if b {\n+                self.expr(&*then)\n+            } else {\n+                otherwise.as_ref().and_then(|expr| self.expr(expr))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn binop(&mut self, op: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> Option<Constant> {\n+        let l = self.expr(left)?;\n+        let r = self.expr(right);\n+        match (l, r) {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match self.tables.expr_ty(left).kind {\n+                ty::Int(ity) => {\n+                    let l = sext(self.lcx.tcx, l, ity);\n+                    let r = sext(self.lcx.tcx, r, ity);\n+                    let zext = |n: i128| Constant::Int(unsext(self.lcx.tcx, n, ity));\n+                    match op.node {\n+                        BinOpKind::Add => l.checked_add(r).map(zext),\n+                        BinOpKind::Sub => l.checked_sub(r).map(zext),\n+                        BinOpKind::Mul => l.checked_mul(r).map(zext),\n+                        BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n+                        BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n+                        BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::BitXor => Some(zext(l ^ r)),\n+                        BinOpKind::BitOr => Some(zext(l | r)),\n+                        BinOpKind::BitAnd => Some(zext(l & r)),\n+                        BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                        BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                        BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                        BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                        BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                        BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                        _ => None,\n+                    }\n+                },\n+                ty::Uint(_) => match op.node {\n+                    BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n+                    BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n+                    BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n+                    BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n+                    BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n+                    BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n+                    BinOpKind::BitOr => Some(Constant::Int(l | r)),\n+                    BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n+                    BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                    BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                    BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                    BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                    BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                    BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n+            (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n+                BinOpKind::Add => Some(Constant::F32(l + r)),\n+                BinOpKind::Sub => Some(Constant::F32(l - r)),\n+                BinOpKind::Mul => Some(Constant::F32(l * r)),\n+                BinOpKind::Div => Some(Constant::F32(l / r)),\n+                BinOpKind::Rem => Some(Constant::F32(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n+                BinOpKind::Add => Some(Constant::F64(l + r)),\n+                BinOpKind::Sub => Some(Constant::F64(l - r)),\n+                BinOpKind::Mul => Some(Constant::F64(l * r)),\n+                BinOpKind::Div => Some(Constant::F64(l / r)),\n+                BinOpKind::Rem => Some(Constant::F64(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (l, r) => match (op.node, l, r) {\n+                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n+                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n+                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => {\n+                    Some(r)\n+                },\n+                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n+                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n+                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n+                _ => None,\n+            },\n+        }\n+    }\n+}\n+\n+pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n+    use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+    match result.val {\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => match result.ty.kind {\n+            ty::Bool => Some(Constant::Bool(d == 1)),\n+            ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n+            ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n+                d.try_into().expect(\"invalid f32 bit representation\"),\n+            ))),\n+            ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n+                d.try_into().expect(\"invalid f64 bit representation\"),\n+            ))),\n+            ty::RawPtr(type_and_mut) => {\n+                if let ty::Uint(_) = type_and_mut.ty.kind {\n+                    return Some(Constant::RawPtr(d));\n+                }\n+                None\n+            },\n+            // FIXME: implement other conversions.\n+            _ => None,\n+        },\n+        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind {\n+            ty::Ref(_, tam, _) => match tam.kind {\n+                ty::Str => String::from_utf8(\n+                    data.inspect_with_undef_and_ptr_outside_interpreter(start..end)\n+                        .to_owned(),\n+                )\n+                .ok()\n+                .map(Constant::Str),\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind {\n+            ty::Array(sub_type, len) => match sub_type.kind {\n+                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inspect_with_undef_and_ptr_outside_interpreter(0..(4 * len as usize))\n+                        .to_owned()\n+                        .chunks(4)\n+                        .map(|chunk| {\n+                            Some(Constant::F32(f32::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inspect_with_undef_and_ptr_outside_interpreter(0..(8 * len as usize))\n+                        .to_owned()\n+                        .chunks(8)\n+                        .map(|chunk| {\n+                            Some(Constant::F64(f64::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                // FIXME: implement other array type conversions.\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        // FIXME: implement other conversions.\n+        _ => None,\n+    }\n+}"}, {"sha": "66722786eab49c52f1429ada6f21cd7e80a15b0b", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,417 @@\n+use crate::utils::{get_parent_expr, higher, if_sequence, same_tys, snippet, span_lint_and_note, span_lint_and_then};\n+use crate::utils::{SpanlessEq, SpanlessHash};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+use std::collections::hash_map::Entry;\n+use std::hash::BuildHasherDefault;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for consecutive `if`s with the same condition.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if a == b {\n+    ///     \u2026\n+    /// } else if a == b {\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that this lint ignores all conditions with a function call as it could\n+    /// have side effects:\n+    ///\n+    /// ```ignore\n+    /// if foo() {\n+    ///     \u2026\n+    /// } else if foo() { // not linted\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    pub IFS_SAME_COND,\n+    correctness,\n+    \"consecutive `if`s with the same condition\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for consecutive `if`s with the same function call.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error.\n+    /// Despite the fact that function can have side effects and `if` works as\n+    /// intended, such an approach is implicit and can be considered a \"code smell\".\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if foo() == bar {\n+    ///     \u2026\n+    /// } else if foo() == bar {\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    ///\n+    /// This probably should be:\n+    /// ```ignore\n+    /// if foo() == bar {\n+    ///     \u2026\n+    /// } else if foo() == baz {\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo and called function mutates a state,\n+    /// consider move the mutation out of the `if` condition to avoid similarity to\n+    /// a copy & paste error:\n+    ///\n+    /// ```ignore\n+    /// let first = foo();\n+    /// if first == bar {\n+    ///     \u2026\n+    /// } else {\n+    ///     let second = foo();\n+    ///     if second == bar {\n+    ///     \u2026\n+    ///     }\n+    /// }\n+    /// ```\n+    pub SAME_FUNCTIONS_IN_IF_CONDITION,\n+    pedantic,\n+    \"consecutive `if`s with the same function call\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `if/else` with the same body as the *then* part\n+    /// and the *else* part.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let foo = if \u2026 {\n+    ///     42\n+    /// } else {\n+    ///     42\n+    /// };\n+    /// ```\n+    pub IF_SAME_THEN_ELSE,\n+    correctness,\n+    \"`if` with the same `then` and `else` blocks\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `match` with identical arm bodies.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n+    /// are the same on purpose, you can factor them\n+    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+    ///\n+    /// **Known problems:** False positive possible with order dependent `match`\n+    /// (see issue\n+    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => bar(), // <= oops\n+    /// }\n+    /// ```\n+    ///\n+    /// This should probably be\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => baz(), // <= fixed\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo:\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar | Baz => bar(), // <= shows the intent better\n+    ///     Quz => quz(),\n+    /// }\n+    /// ```\n+    pub MATCH_SAME_ARMS,\n+    pedantic,\n+    \"`match` with identical arm bodies\"\n+}\n+\n+declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE, MATCH_SAME_ARMS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if !expr.span.from_expansion() {\n+            // skip ifs directly in else, it will be checked in the parent if\n+            if let Some(expr) = get_parent_expr(cx, expr) {\n+                if let Some((_, _, Some(ref else_expr))) = higher::if_block(&expr) {\n+                    if else_expr.hir_id == expr.hir_id {\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            let (conds, blocks) = if_sequence(expr);\n+            lint_same_then_else(cx, &blocks);\n+            lint_same_cond(cx, &conds);\n+            lint_same_fns_in_if_cond(cx, &conds);\n+            lint_match_arms(cx, expr);\n+        }\n+    }\n+}\n+\n+/// Implementation of `IF_SAME_THEN_ELSE`.\n+fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block<'_>]) {\n+    let eq: &dyn Fn(&&Block<'_>, &&Block<'_>) -> bool =\n+        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n+\n+    if let Some((i, j)) = search_same_sequenced(blocks, eq) {\n+        span_lint_and_note(\n+            cx,\n+            IF_SAME_THEN_ELSE,\n+            j.span,\n+            \"this `if` has identical blocks\",\n+            Some(i.span),\n+            \"same as this\",\n+        );\n+    }\n+}\n+\n+/// Implementation of `IFS_SAME_COND`.\n+fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n+    let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n+        let mut h = SpanlessHash::new(cx, cx.tables);\n+        h.hash_expr(expr);\n+        h.finish()\n+    };\n+\n+    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool =\n+        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n+\n+    for (i, j) in search_same(conds, hash, eq) {\n+        span_lint_and_note(\n+            cx,\n+            IFS_SAME_COND,\n+            j.span,\n+            \"this `if` has the same condition as a previous `if`\",\n+            Some(i.span),\n+            \"same as this\",\n+        );\n+    }\n+}\n+\n+/// Implementation of `SAME_FUNCTIONS_IN_IF_CONDITION`.\n+fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n+    let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n+        let mut h = SpanlessHash::new(cx, cx.tables);\n+        h.hash_expr(expr);\n+        h.finish()\n+    };\n+\n+    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n+        // Do not spawn warning if `IFS_SAME_COND` already produced it.\n+        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) {\n+            return false;\n+        }\n+        SpanlessEq::new(cx).eq_expr(lhs, rhs)\n+    };\n+\n+    for (i, j) in search_same(conds, hash, eq) {\n+        span_lint_and_note(\n+            cx,\n+            SAME_FUNCTIONS_IN_IF_CONDITION,\n+            j.span,\n+            \"this `if` has the same function call as a previous `if`\",\n+            Some(i.span),\n+            \"same as this\",\n+        );\n+    }\n+}\n+\n+/// Implementation of `MATCH_SAME_ARMS`.\n+fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>) {\n+    fn same_bindings<'tcx>(\n+        cx: &LateContext<'_, 'tcx>,\n+        lhs: &FxHashMap<Symbol, Ty<'tcx>>,\n+        rhs: &FxHashMap<Symbol, Ty<'tcx>>,\n+    ) -> bool {\n+        lhs.len() == rhs.len()\n+            && lhs\n+                .iter()\n+                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| same_tys(cx, l_ty, r_ty)))\n+    }\n+\n+    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n+        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+            let mut h = SpanlessHash::new(cx, cx.tables);\n+            h.hash_expr(&arm.body);\n+            h.finish()\n+        };\n+\n+        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+            let min_index = usize::min(lindex, rindex);\n+            let max_index = usize::max(lindex, rindex);\n+\n+            // Arms with a guard are ignored, those can\u2019t always be merged together\n+            // This is also the case for arms in-between each there is an arm with a guard\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n+                SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n+                // all patterns should have the same bindings\n+                same_bindings(cx, &bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n+        };\n+\n+        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                j.body.span,\n+                \"this `match` has identical arm bodies\",\n+                |diag| {\n+                    diag.span_note(i.body.span, \"same as this\");\n+\n+                    // Note: this does not use `span_suggestion` on purpose:\n+                    // there is no clean way\n+                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                    // makes an even more confusing error message. Also in order not to make up a\n+                    // span for the whole pattern, the suggestion is only shown when there is only\n+                    // one pattern. The user should know about `|` if they are already using it\u2026\n+\n+                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+\n+                    if let PatKind::Wild = j.pat.kind {\n+                        // if the last arm is _, then i could be integrated into _\n+                        // note that i.pat cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        diag.span_note(\n+                            i.body.span,\n+                            &format!(\n+                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                                lhs\n+                            ),\n+                        );\n+                    } else {\n+                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n+                    }\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+/// Returns the list of bindings in a pattern.\n+fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n+    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n+        match pat.kind {\n+            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatKind::TupleStruct(_, pats, _) => {\n+                for pat in pats {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Binding(.., ident, ref as_pat) => {\n+                if let Entry::Vacant(v) = map.entry(ident.name) {\n+                    v.insert(cx.tables.pat_ty(pat));\n+                }\n+                if let Some(ref as_pat) = *as_pat {\n+                    bindings_impl(cx, as_pat, map);\n+                }\n+            },\n+            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Struct(_, fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, &pat.pat, map);\n+                }\n+            },\n+            PatKind::Slice(lhs, ref mid, rhs) => {\n+                for pat in lhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+                if let Some(ref mid) = *mid {\n+                    bindings_impl(cx, mid, map);\n+                }\n+                for pat in rhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            },\n+            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n+        }\n+    }\n+\n+    let mut result = FxHashMap::default();\n+    bindings_impl(cx, pat, &mut result);\n+    result\n+}\n+\n+fn search_same_sequenced<T, Eq>(exprs: &[T], eq: Eq) -> Option<(&T, &T)>\n+where\n+    Eq: Fn(&T, &T) -> bool,\n+{\n+    for win in exprs.windows(2) {\n+        if eq(&win[0], &win[1]) {\n+            return Some((&win[0], &win[1]));\n+        }\n+    }\n+    None\n+}\n+\n+fn search_common_cases<'a, T, Eq>(exprs: &'a [T], eq: &Eq) -> Option<(&'a T, &'a T)>\n+where\n+    Eq: Fn(&T, &T) -> bool,\n+{\n+    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n+        Some((&exprs[0], &exprs[1]))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n+where\n+    Hash: Fn(&T) -> u64,\n+    Eq: Fn(&T, &T) -> bool,\n+{\n+    if let Some(expr) = search_common_cases(&exprs, &eq) {\n+        return vec![expr];\n+    }\n+\n+    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n+\n+    let mut map: FxHashMap<_, Vec<&_>> =\n+        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n+\n+    for expr in exprs {\n+        match map.entry(hash(expr)) {\n+            Entry::Occupied(mut o) => {\n+                for o in o.get() {\n+                    if eq(o, expr) {\n+                        match_expr_list.push((o, expr));\n+                    }\n+                }\n+                o.get_mut().push(expr);\n+            },\n+            Entry::Vacant(v) => {\n+                v.insert(vec![expr]);\n+            },\n+        }\n+    }\n+\n+    match_expr_list\n+}"}, {"sha": "d79aa2ef0209e1da9f8046572e73e79b46c40a41", "filename": "src/tools/clippy/clippy_lints/src/copy_iterator.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,55 @@\n+use crate::utils::{is_copy, match_path, paths, span_lint_and_note};\n+use rustc_hir::{Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for types that implement `Copy` as well as\n+    /// `Iterator`.\n+    ///\n+    /// **Why is this bad?** Implicit copies can be confusing when working with\n+    /// iterator combinators.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// #[derive(Copy, Clone)]\n+    /// struct Countdown(u8);\n+    ///\n+    /// impl Iterator for Countdown {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let a: Vec<_> = my_iterator.take(1).collect();\n+    /// let b: Vec<_> = my_iterator.collect();\n+    /// ```\n+    pub COPY_ITERATOR,\n+    pedantic,\n+    \"implementing `Iterator` on a `Copy` type\"\n+}\n+\n+declare_lint_pass!(CopyIterator => [COPY_ITERATOR]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyIterator {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+        if let ItemKind::Impl {\n+            of_trait: Some(ref trait_ref),\n+            ..\n+        } = item.kind\n+        {\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n+\n+            if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {\n+                span_lint_and_note(\n+                    cx,\n+                    COPY_ITERATOR,\n+                    item.span,\n+                    \"you are implementing `Iterator` on a `Copy` type\",\n+                    None,\n+                    \"consider implementing `IntoIterator` instead\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "e513dcce64e5349fb6668ceb1bf3fc864d577809", "filename": "src/tools/clippy/clippy_lints/src/dbg_macro.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,65 @@\n+use crate::utils::{snippet_opt, span_lint_and_help, span_lint_and_sugg};\n+use rustc_ast::ast;\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of dbg!() macro.\n+    ///\n+    /// **Why is this bad?** `dbg!` macro is intended as a debugging tool. It\n+    /// should not be in version control.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// dbg!(true)\n+    ///\n+    /// // Good\n+    /// true\n+    /// ```\n+    pub DBG_MACRO,\n+    restriction,\n+    \"`dbg!` macro is intended as a debugging tool\"\n+}\n+\n+declare_lint_pass!(DbgMacro => [DBG_MACRO]);\n+\n+impl EarlyLintPass for DbgMacro {\n+    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::MacCall) {\n+        if mac.path == sym!(dbg) {\n+            if let Some(sugg) = tts_span(mac.args.inner_tokens()).and_then(|span| snippet_opt(cx, span)) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    DBG_MACRO,\n+                    mac.span(),\n+                    \"`dbg!` macro is intended as a debugging tool\",\n+                    \"ensure to avoid having uses of it in version control\",\n+                    sugg,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                span_lint_and_help(\n+                    cx,\n+                    DBG_MACRO,\n+                    mac.span(),\n+                    \"`dbg!` macro is intended as a debugging tool\",\n+                    None,\n+                    \"ensure to avoid having uses of it in version control\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+// Get span enclosing entire the token stream.\n+fn tts_span(tts: TokenStream) -> Option<Span> {\n+    let mut cursor = tts.into_trees();\n+    let first = cursor.next()?.span();\n+    let span = cursor.last().map_or(first, |tree| first.to(tree.span()));\n+    Some(span)\n+}"}, {"sha": "635d609c382890f1a04ae880afdaf965f535c6f6", "filename": "src/tools/clippy/clippy_lints/src/default_trait_access.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,76 @@\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{any_parent_is_automatically_derived, match_def_path, paths, span_lint_and_sugg};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for literal calls to `Default::default()`.\n+    ///\n+    /// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n+    /// being gotten than the generic `Default`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let s: String = Default::default();\n+    ///\n+    /// // Good\n+    /// let s = String::default();\n+    /// ```\n+    pub DEFAULT_TRAIT_ACCESS,\n+    pedantic,\n+    \"checks for literal calls to `Default::default()`\"\n+}\n+\n+declare_lint_pass!(DefaultTraitAccess => [DEFAULT_TRAIT_ACCESS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(ref path, ..) = expr.kind;\n+            if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n+            if let ExprKind::Path(ref qpath) = path.kind;\n+            if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id();\n+            if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+            then {\n+                match qpath {\n+                    QPath::Resolved(..) => {\n+                        if_chain! {\n+                            // Detect and ignore <Foo as Default>::default() because these calls do\n+                            // explicitly name the type.\n+                            if let ExprKind::Call(ref method, ref _args) = expr.kind;\n+                            if let ExprKind::Path(ref p) = method.kind;\n+                            if let QPath::Resolved(Some(_ty), _path) = p;\n+                            then {\n+                                return;\n+                            }\n+                        }\n+\n+                        // TODO: Work out a way to put \"whatever the imported way of referencing\n+                        // this type in this file\" rather than a fully-qualified type.\n+                        let expr_ty = cx.tables.expr_ty(expr);\n+                        if let ty::Adt(..) = expr_ty.kind {\n+                            let replacement = format!(\"{}::default()\", expr_ty);\n+                            span_lint_and_sugg(\n+                                cx,\n+                                DEFAULT_TRAIT_ACCESS,\n+                                expr.span,\n+                                &format!(\"Calling `{}` is more clear than this expression\", replacement),\n+                                \"try\",\n+                                replacement,\n+                                Applicability::Unspecified, // First resolve the TODO above\n+                            );\n+                         }\n+                    },\n+                    QPath::TypeRelative(..) => {},\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "6e8ca647dd7ae930e9c7dde397c4ae78e0178314", "filename": "src/tools/clippy/clippy_lints/src/deprecated_lints.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,157 @@\n+macro_rules! declare_deprecated_lint {\n+    (pub $name: ident, $_reason: expr) => {\n+        declare_lint!(pub $name, Allow, \"deprecated lint\")\n+    }\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This used to check for `assert!(a == b)` and recommend\n+    /// replacement with `assert_eq!(a, b)`, but this is no longer needed after RFC 2011.\n+    pub SHOULD_ASSERT_EQ,\n+    \"`assert!()` will be more flexible with RFC 2011\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This used to check for `Vec::extend`, which was slower than\n+    /// `Vec::extend_from_slice`. Thanks to specialization, this is no longer true.\n+    pub EXTEND_FROM_SLICE,\n+    \"`.extend_from_slice(_)` is a faster way to extend a Vec by a slice\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** `Range::step_by(0)` used to be linted since it's\n+    /// an infinite iterator, which is better expressed by `iter::repeat`,\n+    /// but the method has been removed for `Iterator::step_by` which panics\n+    /// if given a zero\n+    pub RANGE_STEP_BY_ZERO,\n+    \"`iterator.step_by(0)` panics nowadays\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This used to check for `Vec::as_slice`, which was unstable with good\n+    /// stable alternatives. `Vec::as_slice` has now been stabilized.\n+    pub UNSTABLE_AS_SLICE,\n+    \"`Vec::as_slice` has been stabilized in 1.7\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This used to check for `Vec::as_mut_slice`, which was unstable with good\n+    /// stable alternatives. `Vec::as_mut_slice` has now been stabilized.\n+    pub UNSTABLE_AS_MUT_SLICE,\n+    \"`Vec::as_mut_slice` has been stabilized in 1.7\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This used to check for `.to_string()` method calls on values\n+    /// of type `&str`. This is not unidiomatic and with specialization coming, `to_string` could be\n+    /// specialized to be as efficient as `to_owned`.\n+    pub STR_TO_STRING,\n+    \"using `str::to_string` is common even today and specialization will likely happen soon\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This used to check for `.to_string()` method calls on values\n+    /// of type `String`. This is not unidiomatic and with specialization coming, `to_string` could be\n+    /// specialized to be as efficient as `clone`.\n+    pub STRING_TO_STRING,\n+    \"using `string::to_string` is common even today and specialization will likely happen soon\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This lint should never have applied to non-pointer types, as transmuting\n+    /// between non-pointer types of differing alignment is well-defined behavior (it's semantically\n+    /// equivalent to a memcpy). This lint has thus been refactored into two separate lints:\n+    /// cast_ptr_alignment and transmute_ptr_to_ptr.\n+    pub MISALIGNED_TRANSMUTE,\n+    \"this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This lint is too subjective, not having a good reason for being in clippy.\n+    /// Additionally, compound assignment operators may be overloaded separately from their non-assigning\n+    /// counterparts, so this lint may suggest a change in behavior or the code may not compile.\n+    pub ASSIGN_OPS,\n+    \"using compound assignment operators (e.g., `+=`) is harmless\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** The original rule will only lint for `if let`. After\n+    /// making it support to lint `match`, naming as `if let` is not suitable for it.\n+    /// So, this lint is deprecated.\n+    pub IF_LET_REDUNDANT_PATTERN_MATCHING,\n+    \"this lint has been changed to redundant_pattern_matching\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This lint used to suggest replacing `let mut vec =\n+    /// Vec::with_capacity(n); vec.set_len(n);` with `let vec = vec![0; n];`. The\n+    /// replacement has very different performance characteristics so the lint is\n+    /// deprecated.\n+    pub UNSAFE_VECTOR_INITIALIZATION,\n+    \"the replacement suggested by this lint had substantially different behavior\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This lint has been superseded by the warn-by-default\n+    /// `invalid_value` rustc lint.\n+    pub INVALID_REF,\n+    \"superseded by rustc lint `invalid_value`\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This lint has been superseded by #[must_use] in rustc.\n+    pub UNUSED_COLLECT,\n+    \"`collect` has been marked as #[must_use] in rustc and that covers all cases of this lint\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This lint has been uplifted to rustc and is now called\n+    /// `array_into_iter`.\n+    pub INTO_ITER_ON_ARRAY,\n+    \"this lint has been uplifted to rustc and is now called `array_into_iter`\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** This lint has been uplifted to rustc and is now called\n+    /// `unused_labels`.\n+    pub UNUSED_LABEL,\n+    \"this lint has been uplifted to rustc and is now called `unused_labels`\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** Associated-constants are now preferred.\n+    pub REPLACE_CONSTS,\n+    \"associated-constants `MIN`/`MAX` of integers are prefer to `{min,max}_value()` and module constants\"\n+}"}, {"sha": "68ec07e2bcb0f58f874bdbce221741d1559c7c54", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,113 @@\n+use crate::utils::{get_parent_expr, implements_trait, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX, PREC_PREFIX};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit `deref()` or `deref_mut()` method calls.\n+    ///\n+    /// **Why is this bad?** Derefencing by `&*x` or `&mut *x` is clearer and more concise,\n+    /// when not part of a method chain.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::ops::Deref;\n+    /// let a: &mut String = &mut String::from(\"foo\");\n+    /// let b: &str = a.deref();\n+    /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// let a: &mut String = &mut String::from(\"foo\");\n+    /// let b = &*a;\n+    /// ```\n+    ///\n+    /// This lint excludes\n+    /// ```rust,ignore\n+    /// let _ = d.unwrap().deref();\n+    /// ```\n+    pub EXPLICIT_DEREF_METHODS,\n+    pedantic,\n+    \"Explicit use of deref or deref_mut method while not in a method chain.\"\n+}\n+\n+declare_lint_pass!(Dereferencing => [\n+    EXPLICIT_DEREF_METHODS\n+]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Dereferencing {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if !expr.span.from_expansion();\n+            if let ExprKind::MethodCall(ref method_name, _, ref args) = &expr.kind;\n+            if args.len() == 1;\n+\n+            then {\n+                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n+                    // Check if we have the whole call chain here\n+                    if let ExprKind::MethodCall(..) = parent_expr.kind {\n+                        return;\n+                    }\n+                    // Check for Expr that we don't want to be linted\n+                    let precedence = parent_expr.precedence();\n+                    match precedence {\n+                        // Lint a Call is ok though\n+                        ExprPrecedence::Call | ExprPrecedence::AddrOf => (),\n+                        _ => {\n+                            if precedence.order() >= PREC_PREFIX && precedence.order() <= PREC_POSTFIX {\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+                let name = method_name.ident.as_str();\n+                lint_deref(cx, &*name, &args[0], args[0].span, expr.span);\n+            }\n+        }\n+    }\n+}\n+\n+fn lint_deref(cx: &LateContext<'_, '_>, method_name: &str, call_expr: &Expr<'_>, var_span: Span, expr_span: Span) {\n+    match method_name {\n+        \"deref\" => {\n+            if cx\n+                .tcx\n+                .lang_items()\n+                .deref_trait()\n+                .map_or(false, |id| implements_trait(cx, cx.tables.expr_ty(&call_expr), id, &[]))\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    EXPLICIT_DEREF_METHODS,\n+                    expr_span,\n+                    \"explicit deref method call\",\n+                    \"try this\",\n+                    format!(\"&*{}\", &snippet(cx, var_span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        },\n+        \"deref_mut\" => {\n+            if cx\n+                .tcx\n+                .lang_items()\n+                .deref_mut_trait()\n+                .map_or(false, |id| implements_trait(cx, cx.tables.expr_ty(&call_expr), id, &[]))\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    EXPLICIT_DEREF_METHODS,\n+                    expr_span,\n+                    \"explicit deref_mut method call\",\n+                    \"try this\",\n+                    format!(\"&mut *{}\", &snippet(cx, var_span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        },\n+        _ => (),\n+    }\n+}"}, {"sha": "3cbb8fa72f74f70f9cb9fcb6b8e25996a8d58814", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,309 @@\n+use crate::utils::paths;\n+use crate::utils::{\n+    is_automatically_derived, is_copy, match_path, span_lint_and_help, span_lint_and_note, span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::{\n+    BlockCheckMode, BodyId, Expr, ExprKind, FnDecl, HirId, Item, ItemKind, TraitRef, UnsafeSource, Unsafety,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n+    /// explicitly or vice versa.\n+    ///\n+    /// **Why is this bad?** The implementation of these traits must agree (for\n+    /// example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n+    /// default-generated `Hash` implementation with an explicitly defined\n+    /// `PartialEq`. In particular, the following must hold for any type:\n+    ///\n+    /// ```text\n+    /// k1 == k2 \u21d2 hash(k1) == hash(k2)\n+    /// ```\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// #[derive(Hash)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialEq for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n+    pub DERIVE_HASH_XOR_EQ,\n+    correctness,\n+    \"deriving `Hash` but implementing `PartialEq` explicitly\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n+    /// types.\n+    ///\n+    /// **Why is this bad?** To avoid surprising behaviour, these traits should\n+    /// agree and the behaviour of `Copy` cannot be overridden. In almost all\n+    /// situations a `Copy` type should have a `Clone` implementation that does\n+    /// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n+    /// gets you.\n+    ///\n+    /// **Known problems:** Bounds of generic types are sometimes wrong: https://github.com/rust-lang/rust/issues/26925\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// #[derive(Copy)]\n+    /// struct Foo;\n+    ///\n+    /// impl Clone for Foo {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub EXPL_IMPL_CLONE_ON_COPY,\n+    pedantic,\n+    \"implementing `Clone` explicitly on `Copy` types\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for deriving `serde::Deserialize` on a type that\n+    /// has methods using `unsafe`.\n+    ///\n+    /// **Why is this bad?** Deriving `serde::Deserialize` will create a constructor\n+    /// that may violate invariants hold by another constructor.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use serde::Deserialize;\n+    ///\n+    /// #[derive(Deserialize)]\n+    /// pub struct Foo {\n+    ///     // ..\n+    /// }\n+    ///\n+    /// impl Foo {\n+    ///     pub fn new() -> Self {\n+    ///         // setup here ..\n+    ///     }\n+    ///\n+    ///     pub unsafe fn parts() -> (&str, &str) {\n+    ///         // assumes invariants hold\n+    ///     }\n+    /// }\n+    /// ```\n+    pub UNSAFE_DERIVE_DESERIALIZE,\n+    pedantic,\n+    \"deriving `serde::Deserialize` on a type that has methods using `unsafe`\"\n+}\n+\n+declare_lint_pass!(Derive => [EXPL_IMPL_CLONE_ON_COPY, DERIVE_HASH_XOR_EQ, UNSAFE_DERIVE_DESERIALIZE]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+        if let ItemKind::Impl {\n+            of_trait: Some(ref trait_ref),\n+            ..\n+        } = item.kind\n+        {\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n+            let is_automatically_derived = is_automatically_derived(&*item.attrs);\n+\n+            check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n+\n+            if is_automatically_derived {\n+                check_unsafe_derive_deserialize(cx, item, trait_ref, ty);\n+            } else {\n+                check_copy_clone(cx, item, trait_ref, ty);\n+            }\n+        }\n+    }\n+}\n+\n+/// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n+fn check_hash_peq<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    span: Span,\n+    trait_ref: &TraitRef<'_>,\n+    ty: Ty<'tcx>,\n+    hash_is_automatically_derived: bool,\n+) {\n+    if_chain! {\n+        if match_path(&trait_ref.path, &paths::HASH);\n+        if let Some(peq_trait_def_id) = cx.tcx.lang_items().eq_trait();\n+        if let Some(def_id) = &trait_ref.trait_def_id();\n+        if !def_id.is_local();\n+        then {\n+            // Look for the PartialEq implementations for `ty`\n+            cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n+                let peq_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+\n+                if peq_is_automatically_derived == hash_is_automatically_derived {\n+                    return;\n+                }\n+\n+                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+\n+                // Only care about `impl PartialEq<Foo> for Foo`\n+                // For `impl PartialEq<B> for A, input_types is [A, B]\n+                if trait_ref.substs.type_at(1) == ty {\n+                    let mess = if peq_is_automatically_derived {\n+                        \"you are implementing `Hash` explicitly but have derived `PartialEq`\"\n+                    } else {\n+                        \"you are deriving `Hash` but have implemented `PartialEq` explicitly\"\n+                    };\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        DERIVE_HASH_XOR_EQ,\n+                        span,\n+                        mess,\n+                        |diag| {\n+                            if let Some(local_def_id) = impl_id.as_local() {\n+                                let hir_id = cx.tcx.hir().as_local_hir_id(local_def_id);\n+                                diag.span_note(\n+                                    cx.tcx.hir().span(hir_id),\n+                                    \"`PartialEq` implemented here\"\n+                                );\n+                            }\n+                        }\n+                    );\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+/// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n+fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n+    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n+        if !is_copy(cx, ty) {\n+            return;\n+        }\n+\n+        match ty.kind {\n+            ty::Adt(def, _) if def.is_union() => return,\n+\n+            // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n+            ty::Adt(def, substs) => {\n+                for variant in &def.variants {\n+                    for field in &variant.fields {\n+                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).kind {\n+                            return;\n+                        }\n+                    }\n+                    for subst in substs {\n+                        if let ty::subst::GenericArgKind::Type(subst) = subst.unpack() {\n+                            if let ty::Param(_) = subst.kind {\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+            },\n+            _ => (),\n+        }\n+\n+        span_lint_and_note(\n+            cx,\n+            EXPL_IMPL_CLONE_ON_COPY,\n+            item.span,\n+            \"you are implementing `Clone` explicitly on a `Copy` type\",\n+            Some(item.span),\n+            \"consider deriving `Clone` or removing `Copy`\",\n+        );\n+    }\n+}\n+\n+/// Implementation of the `UNSAFE_DERIVE_DESERIALIZE` lint.\n+fn check_unsafe_derive_deserialize<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    item: &Item<'_>,\n+    trait_ref: &TraitRef<'_>,\n+    ty: Ty<'tcx>,\n+) {\n+    fn item_from_def_id<'tcx>(cx: &LateContext<'_, 'tcx>, def_id: DefId) -> &'tcx Item<'tcx> {\n+        let hir_id = cx.tcx.hir().as_local_hir_id(def_id.expect_local());\n+        cx.tcx.hir().expect_item(hir_id)\n+    }\n+\n+    fn has_unsafe<'tcx>(cx: &LateContext<'_, 'tcx>, item: &'tcx Item<'_>) -> bool {\n+        let mut visitor = UnsafeVisitor { cx, has_unsafe: false };\n+        walk_item(&mut visitor, item);\n+        visitor.has_unsafe\n+    }\n+\n+    if_chain! {\n+        if match_path(&trait_ref.path, &paths::SERDE_DESERIALIZE);\n+        if let ty::Adt(def, _) = ty.kind;\n+        if def.did.is_local();\n+        if cx.tcx.inherent_impls(def.did)\n+            .iter()\n+            .map(|imp_did| item_from_def_id(cx, *imp_did))\n+            .any(|imp| has_unsafe(cx, imp));\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                UNSAFE_DERIVE_DESERIALIZE,\n+                item.span,\n+                \"you are deriving `serde::Deserialize` on a type that has methods using `unsafe`\",\n+                None,\n+                \"consider implementing `serde::Deserialize` manually. See https://serde.rs/impl-deserialize.html\"\n+            );\n+        }\n+    }\n+}\n+\n+struct UnsafeVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    has_unsafe: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for UnsafeVisitor<'_, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_fn(&mut self, kind: FnKind<'tcx>, decl: &'tcx FnDecl<'_>, body_id: BodyId, span: Span, id: HirId) {\n+        if self.has_unsafe {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let Some(header) = kind.header();\n+            if let Unsafety::Unsafe = header.unsafety;\n+            then {\n+                self.has_unsafe = true;\n+            }\n+        }\n+\n+        walk_fn(self, kind, decl, body_id, span, id);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.has_unsafe {\n+            return;\n+        }\n+\n+        if let ExprKind::Block(block, _) = expr.kind {\n+            match block.rules {\n+                BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n+                | BlockCheckMode::PushUnsafeBlock(UnsafeSource::UserProvided)\n+                | BlockCheckMode::PopUnsafeBlock(UnsafeSource::UserProvided) => {\n+                    self.has_unsafe = true;\n+                },\n+                _ => {},\n+            }\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+}"}, {"sha": "8d1e91f9adbd61f5aa97e0f896832c099e3d63b0", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,525 @@\n+use crate::utils::{implements_trait, is_entrypoint_fn, is_type_diagnostic_item, return_ty, span_lint};\n+use if_chain::if_chain;\n+use itertools::Itertools;\n+use rustc_ast::ast::{AttrKind, Attribute};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::{BytePos, MultiSpan, Span};\n+use rustc_span::Pos;\n+use std::ops::Range;\n+use url::Url;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for the presence of `_`, `::` or camel-case words\n+    /// outside ticks in documentation.\n+    ///\n+    /// **Why is this bad?** *Rustdoc* supports markdown formatting, `_`, `::` and\n+    /// camel-case probably indicates some code which should be included between\n+    /// ticks. `_` can also be used for emphasis in markdown, this lint tries to\n+    /// consider that.\n+    ///\n+    /// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks\n+    /// for is limited, and there are still false positives.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// /// Do something with the foo_bar parameter. See also\n+    /// /// that::other::module::foo.\n+    /// // ^ `foo_bar` and `that::other::module::foo` should be ticked.\n+    /// fn doit(foo_bar: usize) {}\n+    /// ```\n+    pub DOC_MARKDOWN,\n+    pedantic,\n+    \"presence of `_`, `::` or camel-case outside backticks in documentation\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for the doc comments of publicly visible\n+    /// unsafe functions and warns if there is no `# Safety` section.\n+    ///\n+    /// **Why is this bad?** Unsafe functions should document their safety\n+    /// preconditions, so that users can be sure they are using them safely.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    ///# type Universe = ();\n+    /// /// This function should really be documented\n+    /// pub unsafe fn start_apocalypse(u: &mut Universe) {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    ///\n+    /// At least write a line about safety:\n+    ///\n+    /// ```rust\n+    ///# type Universe = ();\n+    /// /// # Safety\n+    /// ///\n+    /// /// This function should not be called before the horsemen are ready.\n+    /// pub unsafe fn start_apocalypse(u: &mut Universe) {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    pub MISSING_SAFETY_DOC,\n+    style,\n+    \"`pub unsafe fn` without `# Safety` docs\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks the doc comments of publicly visible functions that\n+    /// return a `Result` type and warns if there is no `# Errors` section.\n+    ///\n+    /// **Why is this bad?** Documenting the type of errors that can be returned from a\n+    /// function can help callers write code to handle the errors appropriately.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    ///\n+    /// Since the following function returns a `Result` it has an `# Errors` section in\n+    /// its doc comment:\n+    ///\n+    /// ```rust\n+    ///# use std::io;\n+    /// /// # Errors\n+    /// ///\n+    /// /// Will return `Err` if `filename` does not exist or the user does not have\n+    /// /// permission to read it.\n+    /// pub fn read(filename: String) -> io::Result<String> {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    pub MISSING_ERRORS_DOC,\n+    pedantic,\n+    \"`pub fn` returns `Result` without `# Errors` in doc comment\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `fn main() { .. }` in doctests\n+    ///\n+    /// **Why is this bad?** The test can be shorter (and likely more readable)\n+    /// if the `fn main()` is left implicit.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ``````rust\n+    /// /// An example of a doctest with a `main()` function\n+    /// ///\n+    /// /// # Examples\n+    /// ///\n+    /// /// ```\n+    /// /// fn main() {\n+    /// ///     // this needs not be in an `fn`\n+    /// /// }\n+    /// /// ```\n+    /// fn needless_main() {\n+    ///     unimplemented!();\n+    /// }\n+    /// ``````\n+    pub NEEDLESS_DOCTEST_MAIN,\n+    style,\n+    \"presence of `fn main() {` in code examples\"\n+}\n+\n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Clone)]\n+pub struct DocMarkdown {\n+    valid_idents: FxHashSet<String>,\n+    in_trait_impl: bool,\n+}\n+\n+impl DocMarkdown {\n+    pub fn new(valid_idents: FxHashSet<String>) -> Self {\n+        Self {\n+            valid_idents,\n+            in_trait_impl: false,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(DocMarkdown => [DOC_MARKDOWN, MISSING_SAFETY_DOC, MISSING_ERRORS_DOC, NEEDLESS_DOCTEST_MAIN]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DocMarkdown {\n+    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate<'_>) {\n+        check_attrs(cx, &self.valid_idents, &krate.item.attrs);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+        let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n+        match item.kind {\n+            hir::ItemKind::Fn(ref sig, _, body_id) => {\n+                if !(is_entrypoint_fn(cx, cx.tcx.hir().local_def_id(item.hir_id).to_def_id())\n+                    || in_external_macro(cx.tcx.sess, item.span))\n+                {\n+                    lint_for_missing_headers(cx, item.hir_id, item.span, sig, headers, Some(body_id));\n+                }\n+            },\n+            hir::ItemKind::Impl {\n+                of_trait: ref trait_ref,\n+                ..\n+            } => {\n+                self.in_trait_impl = trait_ref.is_some();\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn check_item_post(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+        if let hir::ItemKind::Impl { .. } = item.kind {\n+            self.in_trait_impl = false;\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+        let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n+        if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n+            if !in_external_macro(cx.tcx.sess, item.span) {\n+                lint_for_missing_headers(cx, item.hir_id, item.span, sig, headers, None);\n+            }\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+        let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n+        if self.in_trait_impl || in_external_macro(cx.tcx.sess, item.span) {\n+            return;\n+        }\n+        if let hir::ImplItemKind::Fn(ref sig, body_id) = item.kind {\n+            lint_for_missing_headers(cx, item.hir_id, item.span, sig, headers, Some(body_id));\n+        }\n+    }\n+}\n+\n+fn lint_for_missing_headers<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    hir_id: hir::HirId,\n+    span: impl Into<MultiSpan> + Copy,\n+    sig: &hir::FnSig<'_>,\n+    headers: DocHeaders,\n+    body_id: Option<hir::BodyId>,\n+) {\n+    if !cx.access_levels.is_exported(hir_id) {\n+        return; // Private functions do not require doc comments\n+    }\n+    if !headers.safety && sig.header.unsafety == hir::Unsafety::Unsafe {\n+        span_lint(\n+            cx,\n+            MISSING_SAFETY_DOC,\n+            span,\n+            \"unsafe function's docs miss `# Safety` section\",\n+        );\n+    }\n+    if !headers.errors {\n+        if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n+            span_lint(\n+                cx,\n+                MISSING_ERRORS_DOC,\n+                span,\n+                \"docs for function returning `Result` missing `# Errors` section\",\n+            );\n+        } else {\n+            if_chain! {\n+                if let Some(body_id) = body_id;\n+                if let Some(future) = cx.tcx.lang_items().future_trait();\n+                let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n+                let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n+                let ret_ty = mir.return_ty();\n+                if implements_trait(cx, ret_ty, future, &[]);\n+                if let ty::Opaque(_, subs) = ret_ty.kind;\n+                if let Some(gen) = subs.types().next();\n+                if let ty::Generator(_, subs, _) = gen.kind;\n+                if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym!(result_type));\n+                then {\n+                    span_lint(\n+                        cx,\n+                        MISSING_ERRORS_DOC,\n+                        span,\n+                        \"docs for function returning `Result` missing `# Errors` section\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Cleanup documentation decoration (`///` and such).\n+///\n+/// We can't use `rustc_ast::attr::AttributeMethods::with_desugared_doc` or\n+/// `rustc_ast::parse::lexer::comments::strip_doc_comment_decoration` because we\n+/// need to keep track of\n+/// the spans but this function is inspired from the later.\n+#[allow(clippy::cast_possible_truncation)]\n+#[must_use]\n+pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(usize, Span)>) {\n+    // one-line comments lose their prefix\n+    const ONELINERS: &[&str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n+    for prefix in ONELINERS {\n+        if comment.starts_with(*prefix) {\n+            let doc = &comment[prefix.len()..];\n+            let mut doc = doc.to_owned();\n+            doc.push('\\n');\n+            return (\n+                doc.to_owned(),\n+                vec![(doc.len(), span.with_lo(span.lo() + BytePos(prefix.len() as u32)))],\n+            );\n+        }\n+    }\n+\n+    if comment.starts_with(\"/*\") {\n+        let doc = &comment[3..comment.len() - 2];\n+        let mut sizes = vec![];\n+        let mut contains_initial_stars = false;\n+        for line in doc.lines() {\n+            let offset = line.as_ptr() as usize - comment.as_ptr() as usize;\n+            debug_assert_eq!(offset as u32 as usize, offset);\n+            contains_initial_stars |= line.trim_start().starts_with('*');\n+            // +1 for the newline\n+            sizes.push((line.len() + 1, span.with_lo(span.lo() + BytePos(offset as u32))));\n+        }\n+        if !contains_initial_stars {\n+            return (doc.to_string(), sizes);\n+        }\n+        // remove the initial '*'s if any\n+        let mut no_stars = String::with_capacity(doc.len());\n+        for line in doc.lines() {\n+            let mut chars = line.chars();\n+            while let Some(c) = chars.next() {\n+                if c.is_whitespace() {\n+                    no_stars.push(c);\n+                } else {\n+                    no_stars.push(if c == '*' { ' ' } else { c });\n+                    break;\n+                }\n+            }\n+            no_stars.push_str(chars.as_str());\n+            no_stars.push('\\n');\n+        }\n+        return (no_stars, sizes);\n+    }\n+\n+    panic!(\"not a doc-comment: {}\", comment);\n+}\n+\n+#[derive(Copy, Clone)]\n+struct DocHeaders {\n+    safety: bool,\n+    errors: bool,\n+}\n+\n+fn check_attrs<'a>(cx: &LateContext<'_, '_>, valid_idents: &FxHashSet<String>, attrs: &'a [Attribute]) -> DocHeaders {\n+    let mut doc = String::new();\n+    let mut spans = vec![];\n+\n+    for attr in attrs {\n+        if let AttrKind::DocComment(ref comment) = attr.kind {\n+            let comment = comment.to_string();\n+            let (comment, current_spans) = strip_doc_comment_decoration(&comment, attr.span);\n+            spans.extend_from_slice(&current_spans);\n+            doc.push_str(&comment);\n+        } else if attr.check_name(sym!(doc)) {\n+            // ignore mix of sugared and non-sugared doc\n+            // don't trigger the safety or errors check\n+            return DocHeaders {\n+                safety: true,\n+                errors: true,\n+            };\n+        }\n+    }\n+\n+    let mut current = 0;\n+    for &mut (ref mut offset, _) in &mut spans {\n+        let offset_copy = *offset;\n+        *offset = current;\n+        current += offset_copy;\n+    }\n+\n+    if doc.is_empty() {\n+        return DocHeaders {\n+            safety: false,\n+            errors: false,\n+        };\n+    }\n+\n+    let parser = pulldown_cmark::Parser::new(&doc).into_offset_iter();\n+    // Iterate over all `Events` and combine consecutive events into one\n+    let events = parser.coalesce(|previous, current| {\n+        use pulldown_cmark::Event::Text;\n+\n+        let previous_range = previous.1;\n+        let current_range = current.1;\n+\n+        match (previous.0, current.0) {\n+            (Text(previous), Text(current)) => {\n+                let mut previous = previous.to_string();\n+                previous.push_str(&current);\n+                Ok((Text(previous.into()), previous_range))\n+            },\n+            (previous, current) => Err(((previous, previous_range), (current, current_range))),\n+        }\n+    });\n+    check_doc(cx, valid_idents, events, &spans)\n+}\n+\n+const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\", \"edition2018\"];\n+\n+fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize>)>>(\n+    cx: &LateContext<'_, '_>,\n+    valid_idents: &FxHashSet<String>,\n+    events: Events,\n+    spans: &[(usize, Span)],\n+) -> DocHeaders {\n+    // true if a safety header was found\n+    use pulldown_cmark::CodeBlockKind;\n+    use pulldown_cmark::Event::{\n+        Code, End, FootnoteReference, HardBreak, Html, Rule, SoftBreak, Start, TaskListMarker, Text,\n+    };\n+    use pulldown_cmark::Tag::{CodeBlock, Heading, Link};\n+\n+    let mut headers = DocHeaders {\n+        safety: false,\n+        errors: false,\n+    };\n+    let mut in_code = false;\n+    let mut in_link = None;\n+    let mut in_heading = false;\n+    let mut is_rust = false;\n+    for (event, range) in events {\n+        match event {\n+            Start(CodeBlock(ref kind)) => {\n+                in_code = true;\n+                if let CodeBlockKind::Fenced(lang) = kind {\n+                    is_rust =\n+                        lang.is_empty() || !lang.contains(\"ignore\") && lang.split(',').any(|i| RUST_CODE.contains(&i));\n+                }\n+            },\n+            End(CodeBlock(_)) => {\n+                in_code = false;\n+                is_rust = false;\n+            },\n+            Start(Link(_, url, _)) => in_link = Some(url),\n+            End(Link(..)) => in_link = None,\n+            Start(Heading(_)) => in_heading = true,\n+            End(Heading(_)) => in_heading = false,\n+            Start(_tag) | End(_tag) => (), // We don't care about other tags\n+            Html(_html) => (),             // HTML is weird, just ignore it\n+            SoftBreak | HardBreak | TaskListMarker(_) | Code(_) | Rule => (),\n+            FootnoteReference(text) | Text(text) => {\n+                if Some(&text) == in_link.as_ref() {\n+                    // Probably a link of the form `<http://example.com>`\n+                    // Which are represented as a link to \"http://example.com\" with\n+                    // text \"http://example.com\" by pulldown-cmark\n+                    continue;\n+                }\n+                headers.safety |= in_heading && text.trim() == \"Safety\";\n+                headers.errors |= in_heading && text.trim() == \"Errors\";\n+                let index = match spans.binary_search_by(|c| c.0.cmp(&range.start)) {\n+                    Ok(o) => o,\n+                    Err(e) => e - 1,\n+                };\n+                let (begin, span) = spans[index];\n+                if in_code {\n+                    if is_rust {\n+                        check_code(cx, &text, span);\n+                    }\n+                } else {\n+                    // Adjust for the beginning of the current `Event`\n+                    let span = span.with_lo(span.lo() + BytePos::from_usize(range.start - begin));\n+\n+                    check_text(cx, valid_idents, &text, span);\n+                }\n+            },\n+        }\n+    }\n+    headers\n+}\n+\n+static LEAVE_MAIN_PATTERNS: &[&str] = &[\"static\", \"fn main() {}\", \"extern crate\", \"async fn main() {\"];\n+\n+fn check_code(cx: &LateContext<'_, '_>, text: &str, span: Span) {\n+    if text.contains(\"fn main() {\") && !LEAVE_MAIN_PATTERNS.iter().any(|p| text.contains(p)) {\n+        span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n+    }\n+}\n+\n+fn check_text(cx: &LateContext<'_, '_>, valid_idents: &FxHashSet<String>, text: &str, span: Span) {\n+    for word in text.split(|c: char| c.is_whitespace() || c == '\\'') {\n+        // Trim punctuation as in `some comment (see foo::bar).`\n+        //                                                   ^^\n+        // Or even as in `_foo bar_` which is emphasized.\n+        let word = word.trim_matches(|c: char| !c.is_alphanumeric());\n+\n+        if valid_idents.contains(word) {\n+            continue;\n+        }\n+\n+        // Adjust for the current word\n+        let offset = word.as_ptr() as usize - text.as_ptr() as usize;\n+        let span = Span::new(\n+            span.lo() + BytePos::from_usize(offset),\n+            span.lo() + BytePos::from_usize(offset + word.len()),\n+            span.ctxt(),\n+        );\n+\n+        check_word(cx, word, span);\n+    }\n+}\n+\n+fn check_word(cx: &LateContext<'_, '_>, word: &str, span: Span) {\n+    /// Checks if a string is camel-case, i.e., contains at least two uppercase\n+    /// letters (`Clippy` is ok) and one lower-case letter (`NASA` is ok).\n+    /// Plurals are also excluded (`IDs` is ok).\n+    fn is_camel_case(s: &str) -> bool {\n+        if s.starts_with(|c: char| c.is_digit(10)) {\n+            return false;\n+        }\n+\n+        let s = if s.ends_with('s') { &s[..s.len() - 1] } else { s };\n+\n+        s.chars().all(char::is_alphanumeric)\n+            && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1\n+            && s.chars().filter(|&c| c.is_lowercase()).take(1).count() > 0\n+    }\n+\n+    fn has_underscore(s: &str) -> bool {\n+        s != \"_\" && !s.contains(\"\\\\_\") && s.contains('_')\n+    }\n+\n+    fn has_hyphen(s: &str) -> bool {\n+        s != \"-\" && s.contains('-')\n+    }\n+\n+    if let Ok(url) = Url::parse(word) {\n+        // try to get around the fact that `foo::bar` parses as a valid URL\n+        if !url.cannot_be_a_base() {\n+            span_lint(\n+                cx,\n+                DOC_MARKDOWN,\n+                span,\n+                \"you should put bare URLs between `<`/`>` or make a proper Markdown link\",\n+            );\n+\n+            return;\n+        }\n+    }\n+\n+    // We assume that mixed-case words are not meant to be put inside bacticks. (Issue #2343)\n+    if has_underscore(word) && has_hyphen(word) {\n+        return;\n+    }\n+\n+    if has_underscore(word) || word.contains(\"::\") || is_camel_case(word) {\n+        span_lint(\n+            cx,\n+            DOC_MARKDOWN,\n+            span,\n+            &format!(\"you should put `{}` between ticks in the documentation\", word),\n+        );\n+    }\n+}"}, {"sha": "44f85d1ea6e19cd77709f87fddeccf0b93db1139", "filename": "src/tools/clippy/clippy_lints/src/double_comparison.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,95 @@\n+//! Lint on unnecessary double comparisons. Some examples:\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for double comparisons that could be simplified to a single expression.\n+    ///\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let x = 1;\n+    /// # let y = 2;\n+    /// if x == y || x < y {}\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// # let x = 1;\n+    /// # let y = 2;\n+    /// if x <= y {}\n+    /// ```\n+    pub DOUBLE_COMPARISONS,\n+    complexity,\n+    \"unnecessary double comparisons that can be simplified\"\n+}\n+\n+declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n+\n+impl<'a, 'tcx> DoubleComparisons {\n+    #[allow(clippy::similar_names)]\n+    fn check_binop(cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n+        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n+            (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n+                (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n+            },\n+            _ => return,\n+        };\n+        let mut spanless_eq = SpanlessEq::new(cx).ignore_fn();\n+        if !(spanless_eq.eq_expr(&llhs, &rlhs) && spanless_eq.eq_expr(&lrhs, &rrhs)) {\n+            return;\n+        }\n+        macro_rules! lint_double_comparison {\n+            ($op:tt) => {{\n+                let mut applicability = Applicability::MachineApplicable;\n+                let lhs_str = snippet_with_applicability(cx, llhs.span, \"\", &mut applicability);\n+                let rhs_str = snippet_with_applicability(cx, lrhs.span, \"\", &mut applicability);\n+                let sugg = format!(\"{} {} {}\", lhs_str, stringify!($op), rhs_str);\n+                span_lint_and_sugg(\n+                    cx,\n+                    DOUBLE_COMPARISONS,\n+                    span,\n+                    \"This binary expression can be simplified\",\n+                    \"try\",\n+                    sugg,\n+                    applicability,\n+                );\n+            }};\n+        }\n+        #[rustfmt::skip]\n+        match (op, lkind, rkind) {\n+            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => {\n+                lint_double_comparison!(<=)\n+            },\n+            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => {\n+                lint_double_comparison!(>=)\n+            },\n+            (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => {\n+                lint_double_comparison!(!=)\n+            },\n+            (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => {\n+                lint_double_comparison!(==)\n+            },\n+            _ => (),\n+        };\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.kind {\n+            Self::check_binop(cx, kind.node, lhs, rhs, expr.span);\n+        }\n+    }\n+}"}, {"sha": "7f2ff8b9b26f62bb42252aca0293c3e49e3ca410", "filename": "src/tools/clippy/clippy_lints/src/double_parens.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,75 @@\n+use crate::utils::span_lint;\n+use rustc_ast::ast::{Expr, ExprKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for unnecessary double parentheses.\n+    ///\n+    /// **Why is this bad?** This makes code harder to read and might indicate a\n+    /// mistake.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # fn foo(bar: usize) {}\n+    /// ((0));\n+    /// foo((0));\n+    /// ((1, 2));\n+    /// ```\n+    pub DOUBLE_PARENS,\n+    complexity,\n+    \"Warn on unnecessary double parentheses\"\n+}\n+\n+declare_lint_pass!(DoubleParens => [DOUBLE_PARENS]);\n+\n+impl EarlyLintPass for DoubleParens {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Paren(ref in_paren) => match in_paren.kind {\n+                ExprKind::Paren(_) | ExprKind::Tup(_) => {\n+                    span_lint(\n+                        cx,\n+                        DOUBLE_PARENS,\n+                        expr.span,\n+                        \"Consider removing unnecessary double parentheses\",\n+                    );\n+                },\n+                _ => {},\n+            },\n+            ExprKind::Call(_, ref params) => {\n+                if params.len() == 1 {\n+                    let param = &params[0];\n+                    if let ExprKind::Paren(_) = param.kind {\n+                        span_lint(\n+                            cx,\n+                            DOUBLE_PARENS,\n+                            param.span,\n+                            \"Consider removing unnecessary double parentheses\",\n+                        );\n+                    }\n+                }\n+            },\n+            ExprKind::MethodCall(_, ref params) => {\n+                if params.len() == 2 {\n+                    let param = &params[1];\n+                    if let ExprKind::Paren(_) = param.kind {\n+                        span_lint(\n+                            cx,\n+                            DOUBLE_PARENS,\n+                            param.span,\n+                            \"Consider removing unnecessary double parentheses\",\n+                        );\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}"}, {"sha": "f49668082791392167b0ebf70af75a4e81ae433b", "filename": "src/tools/clippy/clippy_lints/src/drop_bounds.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,69 @@\n+use crate::utils::{match_def_path, paths, span_lint};\n+use if_chain::if_chain;\n+use rustc_hir::{GenericBound, GenericParam, WhereBoundPredicate, WherePredicate};\n+use rustc_lint::LateLintPass;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for generics with `std::ops::Drop` as bounds.\n+    ///\n+    /// **Why is this bad?** `Drop` bounds do not really accomplish anything.\n+    /// A type may have compiler-generated drop glue without implementing the\n+    /// `Drop` trait itself. The `Drop` trait also only has one method,\n+    /// `Drop::drop`, and that function is by fiat not callable in user code.\n+    /// So there is really no use case for using `Drop` in trait bounds.\n+    ///\n+    /// The most likely use case of a drop bound is to distinguish between types\n+    /// that have destructors and types that don't. Combined with specialization,\n+    /// a naive coder would write an implementation that assumed a type could be\n+    /// trivially dropped, then write a specialization for `T: Drop` that actually\n+    /// calls the destructor. Except that doing so is not correct; String, for\n+    /// example, doesn't actually implement Drop, but because String contains a\n+    /// Vec, assuming it can be trivially dropped will leak memory.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo<T: Drop>() {}\n+    /// ```\n+    pub DROP_BOUNDS,\n+    correctness,\n+    \"Bounds of the form `T: Drop` are useless\"\n+}\n+\n+const DROP_BOUNDS_SUMMARY: &str = \"Bounds of the form `T: Drop` are useless. \\\n+                                   Use `std::mem::needs_drop` to detect if a type has drop glue.\";\n+\n+declare_lint_pass!(DropBounds => [DROP_BOUNDS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropBounds {\n+    fn check_generic_param(&mut self, cx: &rustc_lint::LateContext<'a, 'tcx>, p: &'tcx GenericParam<'_>) {\n+        for bound in p.bounds.iter() {\n+            lint_bound(cx, bound);\n+        }\n+    }\n+    fn check_where_predicate(&mut self, cx: &rustc_lint::LateContext<'a, 'tcx>, p: &'tcx WherePredicate<'_>) {\n+        if let WherePredicate::BoundPredicate(WhereBoundPredicate { bounds, .. }) = p {\n+            for bound in *bounds {\n+                lint_bound(cx, bound);\n+            }\n+        }\n+    }\n+}\n+\n+fn lint_bound<'a, 'tcx>(cx: &rustc_lint::LateContext<'a, 'tcx>, bound: &'tcx GenericBound<'_>) {\n+    if_chain! {\n+        if let GenericBound::Trait(t, _) = bound;\n+        if let Some(def_id) = t.trait_ref.path.res.opt_def_id();\n+        if match_def_path(cx, def_id, &paths::DROP_TRAIT);\n+        then {\n+            span_lint(\n+                cx,\n+                DROP_BOUNDS,\n+                t.span,\n+                DROP_BOUNDS_SUMMARY\n+            );\n+        }\n+    }\n+}"}, {"sha": "9de9056c14029a8d1bb6bd7a8b4244068ca889d6", "filename": "src/tools/clippy/clippy_lints/src/drop_forget_ref.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,160 @@\n+use crate::utils::{is_copy, match_def_path, paths, qpath_res, span_lint_and_note};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::drop` with a reference\n+    /// instead of an owned value.\n+    ///\n+    /// **Why is this bad?** Calling `drop` on a reference will only drop the\n+    /// reference itself, which is a no-op. It will not call the `drop` method (from\n+    /// the `Drop` trait implementation) on the underlying referenced value, which\n+    /// is likely what was intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let mut lock_guard = mutex.lock();\n+    /// std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n+    /// // still locked\n+    /// operation_that_requires_mutex_to_be_unlocked();\n+    /// ```\n+    pub DROP_REF,\n+    correctness,\n+    \"calls to `std::mem::drop` with a reference instead of an owned value\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::forget` with a reference\n+    /// instead of an owned value.\n+    ///\n+    /// **Why is this bad?** Calling `forget` on a reference will only forget the\n+    /// reference itself, which is a no-op. It will not forget the underlying\n+    /// referenced\n+    /// value, which is likely what was intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Box::new(1);\n+    /// std::mem::forget(&x) // Should have been forget(x), x will still be dropped\n+    /// ```\n+    pub FORGET_REF,\n+    correctness,\n+    \"calls to `std::mem::forget` with a reference instead of an owned value\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::drop` with a value\n+    /// that derives the Copy trait\n+    ///\n+    /// **Why is this bad?** Calling `std::mem::drop` [does nothing for types that\n+    /// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n+    /// value will be copied and moved into the function on invocation.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: i32 = 42; // i32 implements Copy\n+    /// std::mem::drop(x) // A copy of x is passed to the function, leaving the\n+    ///                   // original unaffected\n+    /// ```\n+    pub DROP_COPY,\n+    correctness,\n+    \"calls to `std::mem::drop` with a value that implements Copy\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::forget` with a value that\n+    /// derives the Copy trait\n+    ///\n+    /// **Why is this bad?** Calling `std::mem::forget` [does nothing for types that\n+    /// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\n+    /// value will be copied and moved into the function on invocation.\n+    ///\n+    /// An alternative, but also valid, explanation is that Copy types do not\n+    /// implement\n+    /// the Drop trait, which means they have no destructors. Without a destructor,\n+    /// there\n+    /// is nothing for `std::mem::forget` to ignore.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: i32 = 42; // i32 implements Copy\n+    /// std::mem::forget(x) // A copy of x is passed to the function, leaving the\n+    ///                     // original unaffected\n+    /// ```\n+    pub FORGET_COPY,\n+    correctness,\n+    \"calls to `std::mem::forget` with a value that implements Copy\"\n+}\n+\n+const DROP_REF_SUMMARY: &str = \"calls to `std::mem::drop` with a reference instead of an owned value. \\\n+                                Dropping a reference does nothing.\";\n+const FORGET_REF_SUMMARY: &str = \"calls to `std::mem::forget` with a reference instead of an owned value. \\\n+                                  Forgetting a reference does nothing.\";\n+const DROP_COPY_SUMMARY: &str = \"calls to `std::mem::drop` with a value that implements `Copy`. \\\n+                                 Dropping a copy leaves the original intact.\";\n+const FORGET_COPY_SUMMARY: &str = \"calls to `std::mem::forget` with a value that implements `Copy`. \\\n+                                   Forgetting a copy leaves the original intact.\";\n+\n+declare_lint_pass!(DropForgetRef => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COPY]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(ref path, ref args) = expr.kind;\n+            if let ExprKind::Path(ref qpath) = path.kind;\n+            if args.len() == 1;\n+            if let Some(def_id) = qpath_res(cx, qpath, path.hir_id).opt_def_id();\n+            then {\n+                let lint;\n+                let msg;\n+                let arg = &args[0];\n+                let arg_ty = cx.tables.expr_ty(arg);\n+\n+                if let ty::Ref(..) = arg_ty.kind {\n+                    if match_def_path(cx, def_id, &paths::DROP) {\n+                        lint = DROP_REF;\n+                        msg = DROP_REF_SUMMARY.to_string();\n+                    } else if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n+                        lint = FORGET_REF;\n+                        msg = FORGET_REF_SUMMARY.to_string();\n+                    } else {\n+                        return;\n+                    }\n+                    span_lint_and_note(cx,\n+                                       lint,\n+                                       expr.span,\n+                                       &msg,\n+                                       Some(arg.span),\n+                                       &format!(\"argument has type `{}`\", arg_ty));\n+                } else if is_copy(cx, arg_ty) {\n+                    if match_def_path(cx, def_id, &paths::DROP) {\n+                        lint = DROP_COPY;\n+                        msg = DROP_COPY_SUMMARY.to_string();\n+                    } else if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n+                        lint = FORGET_COPY;\n+                        msg = FORGET_COPY_SUMMARY.to_string();\n+                    } else {\n+                        return;\n+                    }\n+                    span_lint_and_note(cx,\n+                                       lint,\n+                                       expr.span,\n+                                       &msg,\n+                                       Some(arg.span),\n+                                       &format!(\"argument has type {}\", arg_ty));\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "b35a8facf8b9951cef7d316e9829fe00fac3f75a", "filename": "src/tools/clippy/clippy_lints/src/duration_subsec.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,65 @@\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+\n+use crate::consts::{constant, Constant};\n+use crate::utils::paths;\n+use crate::utils::{match_type, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calculation of subsecond microseconds or milliseconds\n+    /// from other `Duration` methods.\n+    ///\n+    /// **Why is this bad?** It's more concise to call `Duration::subsec_micros()` or\n+    /// `Duration::subsec_millis()` than to calculate them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::time::Duration;\n+    /// let dur = Duration::new(5, 0);\n+    /// let _micros = dur.subsec_nanos() / 1_000;\n+    /// let _millis = dur.subsec_nanos() / 1_000_000;\n+    /// ```\n+    pub DURATION_SUBSEC,\n+    complexity,\n+    \"checks for calculation of subsecond microseconds or milliseconds\"\n+}\n+\n+declare_lint_pass!(DurationSubsec => [DURATION_SUBSEC]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n+            if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.kind;\n+            if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n+            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n+            then {\n+                let suggested_fn = match (method_path.ident.as_str().as_ref(), divisor) {\n+                    (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\",\n+                    (\"subsec_nanos\", 1_000) => \"subsec_micros\",\n+                    _ => return,\n+                };\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    DURATION_SUBSEC,\n+                    expr.span,\n+                    &format!(\"Calling `{}()` is more concise than this calculation\", suggested_fn),\n+                    \"try\",\n+                    format!(\n+                        \"{}.{}()\",\n+                        snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability),\n+                        suggested_fn\n+                    ),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "95123e6ff6fe2740b912e8438f426592dc3834d2", "filename": "src/tools/clippy/clippy_lints/src/else_if_without_else.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,72 @@\n+//! Lint on if expressions with an else if, but without a final else branch.\n+\n+use rustc_ast::ast::{Expr, ExprKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::span_lint_and_help;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of if expressions with an `else if` branch,\n+    /// but without a final `else` branch.\n+    ///\n+    /// **Why is this bad?** Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # fn a() {}\n+    /// # fn b() {}\n+    /// # let x: i32 = 1;\n+    /// if x.is_positive() {\n+    ///     a();\n+    /// } else if x.is_negative() {\n+    ///     b();\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// # fn a() {}\n+    /// # fn b() {}\n+    /// # let x: i32 = 1;\n+    /// if x.is_positive() {\n+    ///     a();\n+    /// } else if x.is_negative() {\n+    ///     b();\n+    /// } else {\n+    ///     // We don't care about zero.\n+    /// }\n+    /// ```\n+    pub ELSE_IF_WITHOUT_ELSE,\n+    restriction,\n+    \"`if` expression with an `else if`, but without a final `else` branch\"\n+}\n+\n+declare_lint_pass!(ElseIfWithoutElse => [ELSE_IF_WITHOUT_ELSE]);\n+\n+impl EarlyLintPass for ElseIfWithoutElse {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, mut item: &Expr) {\n+        if in_external_macro(cx.sess(), item.span) {\n+            return;\n+        }\n+\n+        while let ExprKind::If(_, _, Some(ref els)) = item.kind {\n+            if let ExprKind::If(_, _, None) = els.kind {\n+                span_lint_and_help(\n+                    cx,\n+                    ELSE_IF_WITHOUT_ELSE,\n+                    els.span,\n+                    \"`if` expression with an `else if`, but without a final `else`\",\n+                    None,\n+                    \"add an `else` block here\",\n+                );\n+            }\n+\n+            item = els;\n+        }\n+    }\n+}"}, {"sha": "3bfef6f4bed129bc2756dce58b9dca2bc3e7e938", "filename": "src/tools/clippy/clippy_lints/src/empty_enum.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,60 @@\n+//! lint when there is an enum with no variants\n+\n+use crate::utils::span_lint_and_help;\n+use rustc_hir::{Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `enum`s with no variants.\n+    ///\n+    /// **Why is this bad?** If you want to introduce a type which\n+    /// can't be instantiated, you should use `!` (the never type),\n+    /// or a wrapper around it, because `!` has more extensive\n+    /// compiler support (type inference, etc...) and wrappers\n+    /// around it are the conventional way to define an uninhabited type.\n+    /// For further information visit [never type documentation](https://doc.rust-lang.org/std/primitive.never.html)\n+    ///\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Bad:\n+    /// ```rust\n+    /// enum Test {}\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #![feature(never_type)]\n+    ///\n+    /// struct Test(!);\n+    /// ```\n+    pub EMPTY_ENUM,\n+    pedantic,\n+    \"enum with no variants\"\n+}\n+\n+declare_lint_pass!(EmptyEnum => [EMPTY_ENUM]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item<'_>) {\n+        let did = cx.tcx.hir().local_def_id(item.hir_id);\n+        if let ItemKind::Enum(..) = item.kind {\n+            let ty = cx.tcx.type_of(did);\n+            let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n+            if adt.variants.is_empty() {\n+                span_lint_and_help(\n+                    cx,\n+                    EMPTY_ENUM,\n+                    item.span,\n+                    \"enum with no variants\",\n+                    None,\n+                    \"consider using the uninhabited type `!` (never type) or a wrapper \\\n+                    around it to introduce a type which can't be instantiated\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "7b332c761a0c40b17ff3243e4457136c30d31887", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,187 @@\n+use crate::utils::SpanlessEq;\n+use crate::utils::{get_item_name, higher, is_type_diagnostic_item, match_type, paths, snippet, snippet_opt};\n+use crate::utils::{snippet_with_applicability, span_lint_and_then, walk_ptrs_ty};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n+    /// or `BTreeMap`.\n+    ///\n+    /// **Why is this bad?** Using `entry` is more efficient.\n+    ///\n+    /// **Known problems:** Some false negatives, eg.:\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # let mut map = HashMap::new();\n+    /// # let v = 1;\n+    /// # let k = 1;\n+    /// if !map.contains_key(&k) {\n+    ///     map.insert(k.clone(), v);\n+    /// }\n+    /// ```\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # let mut map = HashMap::new();\n+    /// # let k = 1;\n+    /// # let v = 1;\n+    /// if !map.contains_key(&k) {\n+    ///     map.insert(k, v);\n+    /// }\n+    /// ```\n+    /// can both be rewritten as:\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # let mut map = HashMap::new();\n+    /// # let k = 1;\n+    /// # let v = 1;\n+    /// map.entry(k).or_insert(v);\n+    /// ```\n+    pub MAP_ENTRY,\n+    perf,\n+    \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\"\n+}\n+\n+declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if let Some((ref check, ref then_block, ref else_block)) = higher::if_block(&expr) {\n+            if let ExprKind::Unary(UnOp::UnNot, ref check) = check.kind {\n+                if let Some((ty, map, key)) = check_cond(cx, check) {\n+                    // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n+                    // we can give a better error message\n+                    let sole_expr = {\n+                        else_block.is_none()\n+                            && if let ExprKind::Block(ref then_block, _) = then_block.kind {\n+                                (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n+                            } else {\n+                                true\n+                            }\n+                        // XXXManishearth we can also check for if/else blocks containing `None`.\n+                    };\n+\n+                    let mut visitor = InsertVisitor {\n+                        cx,\n+                        span: expr.span,\n+                        ty,\n+                        map,\n+                        key,\n+                        sole_expr,\n+                    };\n+\n+                    walk_expr(&mut visitor, &**then_block);\n+                }\n+            } else if let Some(ref else_block) = *else_block {\n+                if let Some((ty, map, key)) = check_cond(cx, check) {\n+                    let mut visitor = InsertVisitor {\n+                        cx,\n+                        span: expr.span,\n+                        ty,\n+                        map,\n+                        key,\n+                        sole_expr: false,\n+                    };\n+\n+                    walk_expr(&mut visitor, else_block);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_cond<'a, 'tcx, 'b>(\n+    cx: &'a LateContext<'a, 'tcx>,\n+    check: &'b Expr<'b>,\n+) -> Option<(&'static str, &'b Expr<'b>, &'b Expr<'b>)> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref path, _, ref params) = check.kind;\n+        if params.len() >= 2;\n+        if path.ident.name == sym!(contains_key);\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref key) = params[1].kind;\n+        then {\n+            let map = &params[0];\n+            let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n+\n+            return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n+                Some((\"BTreeMap\", map, key))\n+            }\n+            else if is_type_diagnostic_item(cx, obj_ty, sym!(hashmap_type)) {\n+                Some((\"HashMap\", map, key))\n+            }\n+            else {\n+                None\n+            };\n+        }\n+    }\n+\n+    None\n+}\n+\n+struct InsertVisitor<'a, 'tcx, 'b> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    span: Span,\n+    ty: &'static str,\n+    map: &'b Expr<'b>,\n+    key: &'b Expr<'b>,\n+    sole_expr: bool,\n+}\n+\n+impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::MethodCall(ref path, _, ref params) = expr.kind;\n+            if params.len() == 3;\n+            if path.ident.name == sym!(insert);\n+            if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);\n+            if SpanlessEq::new(self.cx).eq_expr(self.key, &params[1]);\n+            if snippet_opt(self.cx, self.map.span) == snippet_opt(self.cx, params[0].span);\n+            then {\n+                span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n+                                   &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", self.ty), |diag| {\n+                    if self.sole_expr {\n+                        let mut app = Applicability::MachineApplicable;\n+                        let help = format!(\"{}.entry({}).or_insert({});\",\n+                                           snippet_with_applicability(self.cx, self.map.span, \"map\", &mut app),\n+                                           snippet_with_applicability(self.cx, params[1].span, \"..\", &mut app),\n+                                           snippet_with_applicability(self.cx, params[2].span, \"..\", &mut app));\n+\n+                        diag.span_suggestion(\n+                            self.span,\n+                            \"consider using\",\n+                            help,\n+                            Applicability::MachineApplicable, // snippet\n+                        );\n+                    }\n+                    else {\n+                        let help = format!(\"consider using `{}.entry({})`\",\n+                                           snippet(self.cx, self.map.span, \"map\"),\n+                                           snippet(self.cx, params[1].span, \"..\"));\n+\n+                        diag.span_label(\n+                            self.span,\n+                            &help,\n+                        );\n+                    }\n+                });\n+            }\n+        }\n+\n+        if !self.sole_expr {\n+            walk_expr(self, expr);\n+        }\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "a1fed3fb6e205595ae9edccff2e49124ace435fb", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,82 @@\n+//! lint on C-like enums that are `repr(isize/usize)` and have values that\n+//! don't fit into an `i32`\n+\n+use crate::consts::{miri_to_const, Constant};\n+use crate::utils::span_lint;\n+use rustc_ast::ast::{IntTy, UintTy};\n+use rustc_hir::{Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_middle::ty::util::IntTypeExt;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use std::convert::TryFrom;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for C-like enumerations that are\n+    /// `repr(isize/usize)` and have values that don't fit into an `i32`.\n+    ///\n+    /// **Why is this bad?** This will truncate the variant value on 32 bit\n+    /// architectures, but works fine on 64 bit.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # #[cfg(target_pointer_width = \"64\")]\n+    /// #[repr(usize)]\n+    /// enum NonPortable {\n+    ///     X = 0x1_0000_0000,\n+    ///     Y = 0,\n+    /// }\n+    /// ```\n+    pub ENUM_CLIKE_UNPORTABLE_VARIANT,\n+    correctness,\n+    \"C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\"\n+}\n+\n+declare_lint_pass!(UnportableVariant => [ENUM_CLIKE_UNPORTABLE_VARIANT]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n+    #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap, clippy::cast_sign_loss)]\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+        if cx.tcx.data_layout.pointer_size.bits() != 64 {\n+            return;\n+        }\n+        if let ItemKind::Enum(def, _) = &item.kind {\n+            for var in def.variants {\n+                if let Some(anon_const) = &var.disr_expr {\n+                    let def_id = cx.tcx.hir().body_owner_def_id(anon_const.body);\n+                    let mut ty = cx.tcx.type_of(def_id.to_def_id());\n+                    let constant = cx\n+                        .tcx\n+                        .const_eval_poly(def_id.to_def_id())\n+                        .ok()\n+                        .map(|val| rustc_middle::ty::Const::from_value(cx.tcx, val, ty));\n+                    if let Some(Constant::Int(val)) = constant.and_then(miri_to_const) {\n+                        if let ty::Adt(adt, _) = ty.kind {\n+                            if adt.is_enum() {\n+                                ty = adt.repr.discr_type().to_ty(cx.tcx);\n+                            }\n+                        }\n+                        match ty.kind {\n+                            ty::Int(IntTy::Isize) => {\n+                                let val = ((val as i128) << 64) >> 64;\n+                                if i32::try_from(val).is_ok() {\n+                                    continue;\n+                                }\n+                            },\n+                            ty::Uint(UintTy::Usize) if val > u128::from(u32::max_value()) => {},\n+                            _ => continue,\n+                        }\n+                        span_lint(\n+                            cx,\n+                            ENUM_CLIKE_UNPORTABLE_VARIANT,\n+                            var.span,\n+                            \"Clike enum variant discriminant is not portable to 32-bit targets\",\n+                        );\n+                    };\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "a5871cf0cd4ddefda14a9341d4eb5803fd81dbd8", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,305 @@\n+//! lint on enum variants that are prefixed or suffixed by the same characters\n+\n+use crate::utils::{camel_case, is_present_in_source};\n+use crate::utils::{span_lint, span_lint_and_help};\n+use rustc_ast::ast::{EnumDef, Item, ItemKind, VisibilityKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass, Lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n+    /// by the same characters.\n+    ///\n+    /// **Why is this bad?** Enumeration variant names should specify their variant,\n+    /// not repeat the enumeration name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Cake {\n+    ///     BlackForestCake,\n+    ///     HummingbirdCake,\n+    ///     BattenbergCake,\n+    /// }\n+    /// ```\n+    pub ENUM_VARIANT_NAMES,\n+    style,\n+    \"enums where all variants share a prefix/postfix\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n+    /// by the same characters.\n+    ///\n+    /// **Why is this bad?** Enumeration variant names should specify their variant,\n+    /// not repeat the enumeration name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Cake {\n+    ///     BlackForestCake,\n+    ///     HummingbirdCake,\n+    ///     BattenbergCake,\n+    /// }\n+    /// ```\n+    pub PUB_ENUM_VARIANT_NAMES,\n+    pedantic,\n+    \"enums where all variants share a prefix/postfix\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects type names that are prefixed or suffixed by the\n+    /// containing module's name.\n+    ///\n+    /// **Why is this bad?** It requires the user to type the module name twice.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// mod cake {\n+    ///     struct BlackForestCake;\n+    /// }\n+    /// ```\n+    pub MODULE_NAME_REPETITIONS,\n+    pedantic,\n+    \"type names prefixed/postfixed with their containing module's name\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for modules that have the same name as their\n+    /// parent module\n+    ///\n+    /// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and\n+    /// again `mod foo { ..\n+    /// }` in `foo.rs`.\n+    /// The expectation is that items inside the inner `mod foo { .. }` are then\n+    /// available\n+    /// through `foo::x`, but they are only available through\n+    /// `foo::foo::x`.\n+    /// If this is done on purpose, it would be better to choose a more\n+    /// representative module name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// // lib.rs\n+    /// mod foo;\n+    /// // foo.rs\n+    /// mod foo {\n+    ///     ...\n+    /// }\n+    /// ```\n+    pub MODULE_INCEPTION,\n+    style,\n+    \"modules that have the same name as their parent module\"\n+}\n+\n+pub struct EnumVariantNames {\n+    modules: Vec<(Symbol, String)>,\n+    threshold: u64,\n+}\n+\n+impl EnumVariantNames {\n+    #[must_use]\n+    pub fn new(threshold: u64) -> Self {\n+        Self {\n+            modules: Vec::new(),\n+            threshold,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(EnumVariantNames => [\n+    ENUM_VARIANT_NAMES,\n+    PUB_ENUM_VARIANT_NAMES,\n+    MODULE_NAME_REPETITIONS,\n+    MODULE_INCEPTION\n+]);\n+\n+/// Returns the number of chars that match from the start\n+#[must_use]\n+fn partial_match(pre: &str, name: &str) -> usize {\n+    let mut name_iter = name.chars();\n+    let _ = name_iter.next_back(); // make sure the name is never fully matched\n+    pre.chars().zip(name_iter).take_while(|&(l, r)| l == r).count()\n+}\n+\n+/// Returns the number of chars that match from the end\n+#[must_use]\n+fn partial_rmatch(post: &str, name: &str) -> usize {\n+    let mut name_iter = name.chars();\n+    let _ = name_iter.next(); // make sure the name is never fully matched\n+    post.chars()\n+        .rev()\n+        .zip(name_iter.rev())\n+        .take_while(|&(l, r)| l == r)\n+        .count()\n+}\n+\n+fn check_variant(\n+    cx: &EarlyContext<'_>,\n+    threshold: u64,\n+    def: &EnumDef,\n+    item_name: &str,\n+    item_name_chars: usize,\n+    span: Span,\n+    lint: &'static Lint,\n+) {\n+    if (def.variants.len() as u64) < threshold {\n+        return;\n+    }\n+    for var in &def.variants {\n+        let name = var.ident.name.as_str();\n+        if partial_match(item_name, &name) == item_name_chars\n+            && name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase())\n+            && name.chars().nth(item_name_chars + 1).map_or(false, |c| !c.is_numeric())\n+        {\n+            span_lint(cx, lint, var.span, \"Variant name starts with the enum's name\");\n+        }\n+        if partial_rmatch(item_name, &name) == item_name_chars {\n+            span_lint(cx, lint, var.span, \"Variant name ends with the enum's name\");\n+        }\n+    }\n+    let first = &def.variants[0].ident.name.as_str();\n+    let mut pre = &first[..camel_case::until(&*first)];\n+    let mut post = &first[camel_case::from(&*first)..];\n+    for var in &def.variants {\n+        let name = var.ident.name.as_str();\n+\n+        let pre_match = partial_match(pre, &name);\n+        pre = &pre[..pre_match];\n+        let pre_camel = camel_case::until(pre);\n+        pre = &pre[..pre_camel];\n+        while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n+            if next.is_numeric() {\n+                return;\n+            }\n+            if next.is_lowercase() {\n+                let last = pre.len() - last.len_utf8();\n+                let last_camel = camel_case::until(&pre[..last]);\n+                pre = &pre[..last_camel];\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        let post_match = partial_rmatch(post, &name);\n+        let post_end = post.len() - post_match;\n+        post = &post[post_end..];\n+        let post_camel = camel_case::from(post);\n+        post = &post[post_camel..];\n+    }\n+    let (what, value) = match (pre.is_empty(), post.is_empty()) {\n+        (true, true) => return,\n+        (false, _) => (\"pre\", pre),\n+        (true, false) => (\"post\", post),\n+    };\n+    span_lint_and_help(\n+        cx,\n+        lint,\n+        span,\n+        &format!(\"All variants have the same {}fix: `{}`\", what, value),\n+        None,\n+        &format!(\n+            \"remove the {}fixes and use full paths to \\\n+             the variants instead of glob imports\",\n+            what\n+        ),\n+    );\n+}\n+\n+#[must_use]\n+fn to_camel_case(item_name: &str) -> String {\n+    let mut s = String::new();\n+    let mut up = true;\n+    for c in item_name.chars() {\n+        if c.is_uppercase() {\n+            // we only turn snake case text into CamelCase\n+            return item_name.to_string();\n+        }\n+        if c == '_' {\n+            up = true;\n+            continue;\n+        }\n+        if up {\n+            up = false;\n+            s.extend(c.to_uppercase());\n+        } else {\n+            s.push(c);\n+        }\n+    }\n+    s\n+}\n+\n+impl EarlyLintPass for EnumVariantNames {\n+    fn check_item_post(&mut self, _cx: &EarlyContext<'_>, _item: &Item) {\n+        let last = self.modules.pop();\n+        assert!(last.is_some());\n+    }\n+\n+    #[allow(clippy::similar_names)]\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        let item_name = item.ident.name.as_str();\n+        let item_name_chars = item_name.chars().count();\n+        let item_camel = to_camel_case(&item_name);\n+        if !item.span.from_expansion() && is_present_in_source(cx, item.span) {\n+            if let Some(&(ref mod_name, ref mod_camel)) = self.modules.last() {\n+                // constants don't have surrounding modules\n+                if !mod_camel.is_empty() {\n+                    if mod_name == &item.ident.name {\n+                        if let ItemKind::Mod(..) = item.kind {\n+                            span_lint(\n+                                cx,\n+                                MODULE_INCEPTION,\n+                                item.span,\n+                                \"module has the same name as its containing module\",\n+                            );\n+                        }\n+                    }\n+                    if item.vis.node.is_pub() {\n+                        let matching = partial_match(mod_camel, &item_camel);\n+                        let rmatching = partial_rmatch(mod_camel, &item_camel);\n+                        let nchars = mod_camel.chars().count();\n+\n+                        let is_word_beginning = |c: char| c == '_' || c.is_uppercase() || c.is_numeric();\n+\n+                        if matching == nchars {\n+                            match item_camel.chars().nth(nchars) {\n+                                Some(c) if is_word_beginning(c) => span_lint(\n+                                    cx,\n+                                    MODULE_NAME_REPETITIONS,\n+                                    item.span,\n+                                    \"item name starts with its containing module's name\",\n+                                ),\n+                                _ => (),\n+                            }\n+                        }\n+                        if rmatching == nchars {\n+                            span_lint(\n+                                cx,\n+                                MODULE_NAME_REPETITIONS,\n+                                item.span,\n+                                \"item name ends with its containing module's name\",\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if let ItemKind::Enum(ref def, _) = item.kind {\n+            let lint = match item.vis.node {\n+                VisibilityKind::Public => PUB_ENUM_VARIANT_NAMES,\n+                _ => ENUM_VARIANT_NAMES,\n+            };\n+            check_variant(cx, self.threshold, def, &item_name, item_name_chars, item.span, lint);\n+        }\n+        self.modules.push((item.ident.name, item_camel));\n+    }\n+}"}, {"sha": "098d47bdd40cb10aba75123be872c7e28aeae5af", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,229 @@\n+use crate::utils::{\n+    implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for equal operands to comparison, logical and\n+    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+    /// `||`, `&`, `|`, `^`, `-` and `/`).\n+    ///\n+    /// **Why is this bad?** This is usually just a typo or a copy and paste error.\n+    ///\n+    /// **Known problems:** False negatives: We had some false positives regarding\n+    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n+    /// calls. We may introduce a whitelist of known pure functions in the future.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if x + 1 == x + 1 {}\n+    /// ```\n+    pub EQ_OP,\n+    correctness,\n+    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for arguments to `==` which have their address\n+    /// taken to satisfy a bound\n+    /// and suggests to dereference the other argument instead\n+    ///\n+    /// **Why is this bad?** It is more idiomatic to dereference the other argument.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// &x == y\n+    /// ```\n+    pub OP_REF,\n+    style,\n+    \"taking a reference to satisfy the type constraints on `==`\"\n+}\n+\n+declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n+    #[allow(clippy::similar_names, clippy::too_many_lines)]\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(op, ref left, ref right) = e.kind {\n+            if e.span.from_expansion() {\n+                return;\n+            }\n+            let macro_with_not_op = |expr_kind: &ExprKind<'_>| {\n+                if let ExprKind::Unary(_, ref expr) = *expr_kind {\n+                    in_macro(expr.span)\n+                } else {\n+                    false\n+                }\n+            };\n+            if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n+                return;\n+            }\n+            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n+                span_lint(\n+                    cx,\n+                    EQ_OP,\n+                    e.span,\n+                    &format!(\"equal expressions as operands to `{}`\", op.node.as_str()),\n+                );\n+                return;\n+            }\n+            let (trait_id, requires_ref) = match op.node {\n+                BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n+                BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n+                BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n+                BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n+                BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n+                // don't lint short circuiting ops\n+                BinOpKind::And | BinOpKind::Or => return,\n+                BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n+                BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n+                BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n+                BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n+                BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n+                BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n+                BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => {\n+                    (cx.tcx.lang_items().partial_ord_trait(), true)\n+                },\n+            };\n+            if let Some(trait_id) = trait_id {\n+                #[allow(clippy::match_same_arms)]\n+                match (&left.kind, &right.kind) {\n+                    // do not suggest to dereference literals\n+                    (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n+                    // &foo == &bar\n+                    (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n+                        let lty = cx.tables.expr_ty(l);\n+                        let rty = cx.tables.expr_ty(r);\n+                        let lcpy = is_copy(cx, lty);\n+                        let rcpy = is_copy(cx, rty);\n+                        // either operator autorefs or both args are copyable\n+                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n+                            span_lint_and_then(\n+                                cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"needlessly taken reference of both operands\",\n+                                |diag| {\n+                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                    multispan_sugg(\n+                                        diag,\n+                                        \"use the values directly\".to_string(),\n+                                        vec![(left.span, lsnip), (right.span, rsnip)],\n+                                    );\n+                                },\n+                            )\n+                        } else if lcpy\n+                            && !rcpy\n+                            && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()])\n+                        {\n+                            span_lint_and_then(\n+                                cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"needlessly taken reference of left operand\",\n+                                |diag| {\n+                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                    diag.span_suggestion(\n+                                        left.span,\n+                                        \"use the left value directly\",\n+                                        lsnip,\n+                                        Applicability::MaybeIncorrect, // FIXME #2597\n+                                    );\n+                                },\n+                            )\n+                        } else if !lcpy\n+                            && rcpy\n+                            && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()])\n+                        {\n+                            span_lint_and_then(\n+                                cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"needlessly taken reference of right operand\",\n+                                |diag| {\n+                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                    diag.span_suggestion(\n+                                        right.span,\n+                                        \"use the right value directly\",\n+                                        rsnip,\n+                                        Applicability::MaybeIncorrect, // FIXME #2597\n+                                    );\n+                                },\n+                            )\n+                        }\n+                    },\n+                    // &foo == bar\n+                    (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), _) => {\n+                        let lty = cx.tables.expr_ty(l);\n+                        let lcpy = is_copy(cx, lty);\n+                        if (requires_ref || lcpy)\n+                            && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()])\n+                        {\n+                            span_lint_and_then(\n+                                cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"needlessly taken reference of left operand\",\n+                                |diag| {\n+                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                    diag.span_suggestion(\n+                                        left.span,\n+                                        \"use the left value directly\",\n+                                        lsnip,\n+                                        Applicability::MaybeIncorrect, // FIXME #2597\n+                                    );\n+                                },\n+                            )\n+                        }\n+                    },\n+                    // foo == &bar\n+                    (_, &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n+                        let rty = cx.tables.expr_ty(r);\n+                        let rcpy = is_copy(cx, rty);\n+                        if (requires_ref || rcpy)\n+                            && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()])\n+                        {\n+                            span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n+                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                diag.span_suggestion(\n+                                    right.span,\n+                                    \"use the right value directly\",\n+                                    rsnip,\n+                                    Applicability::MaybeIncorrect, // FIXME #2597\n+                                );\n+                            })\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_valid_operator(op: BinOp) -> bool {\n+    match op.node {\n+        BinOpKind::Sub\n+        | BinOpKind::Div\n+        | BinOpKind::Eq\n+        | BinOpKind::Lt\n+        | BinOpKind::Le\n+        | BinOpKind::Gt\n+        | BinOpKind::Ge\n+        | BinOpKind::Ne\n+        | BinOpKind::And\n+        | BinOpKind::Or\n+        | BinOpKind::BitXor\n+        | BinOpKind::BitAnd\n+        | BinOpKind::BitOr => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "3ff0506e28d007ffeefdcb784b2685a3029a1a0e", "filename": "src/tools/clippy/clippy_lints/src/erasing_op.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,59 @@\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+use crate::consts::{constant_simple, Constant};\n+use crate::utils::span_lint;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for erasing operations, e.g., `x * 0`.\n+    ///\n+    /// **Why is this bad?** The whole expression can be replaced by zero.\n+    /// This is most likely not the intended outcome and should probably be\n+    /// corrected\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 1;\n+    /// 0 / x;\n+    /// 0 * x;\n+    /// x & 0;\n+    /// ```\n+    pub ERASING_OP,\n+    correctness,\n+    \"using erasing operations, e.g., `x * 0` or `y & 0`\"\n+}\n+\n+declare_lint_pass!(ErasingOp => [ERASING_OP]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        if e.span.from_expansion() {\n+            return;\n+        }\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.kind {\n+            match cmp.node {\n+                BinOpKind::Mul | BinOpKind::BitAnd => {\n+                    check(cx, left, e.span);\n+                    check(cx, right, e.span);\n+                },\n+                BinOpKind::Div => check(cx, left, e.span),\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, span: Span) {\n+    if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables, e) {\n+        span_lint(\n+            cx,\n+            ERASING_OP,\n+            span,\n+            \"this operation will always return zero. This is likely not the intended outcome\",\n+        );\n+    }\n+}"}, {"sha": "1ec60a0e6e67ac9e00c42e4920d438fafd25ad8c", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,164 @@\n+use rustc_hir::intravisit;\n+use rustc_hir::{self, Body, FnDecl, HirId, HirIdSet, ItemKind, Node};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Span;\n+use rustc_target::abi::LayoutOf;\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+\n+use crate::utils::span_lint;\n+\n+#[derive(Copy, Clone)]\n+pub struct BoxedLocal {\n+    pub too_large_for_stack: u64,\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `Box<T>` where an unboxed `T` would\n+    /// work fine.\n+    ///\n+    /// **Why is this bad?** This is an unnecessary allocation, and bad for\n+    /// performance. It is only necessary to allocate if you wish to move the box\n+    /// into something.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # fn foo(bar: usize) {}\n+    /// let x = Box::new(1);\n+    /// foo(*x);\n+    /// println!(\"{}\", *x);\n+    /// ```\n+    pub BOXED_LOCAL,\n+    perf,\n+    \"using `Box<T>` where unnecessary\"\n+}\n+\n+fn is_non_trait_box(ty: Ty<'_>) -> bool {\n+    ty.is_box() && !ty.boxed_ty().is_trait()\n+}\n+\n+struct EscapeDelegate<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    set: HirIdSet,\n+    too_large_for_stack: u64,\n+}\n+\n+impl_lint_pass!(BoxedLocal => [BOXED_LOCAL]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxedLocal {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        _: Span,\n+        hir_id: HirId,\n+    ) {\n+        // If the method is an impl for a trait, don't warn.\n+        let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n+        let parent_node = cx.tcx.hir().find(parent_id);\n+\n+        if let Some(Node::Item(item)) = parent_node {\n+            if let ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n+                return;\n+            }\n+        }\n+\n+        let mut v = EscapeDelegate {\n+            cx,\n+            set: HirIdSet::default(),\n+            too_large_for_stack: self.too_large_for_stack,\n+        };\n+\n+        let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n+        cx.tcx.infer_ctxt().enter(|infcx| {\n+            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.tables).consume_body(body);\n+        });\n+\n+        for node in v.set {\n+            span_lint(\n+                cx,\n+                BOXED_LOCAL,\n+                cx.tcx.hir().span(node),\n+                \"local variable doesn't need to be boxed here\",\n+            );\n+        }\n+    }\n+}\n+\n+// TODO: Replace with Map::is_argument(..) when it's fixed\n+fn is_argument(map: rustc_middle::hir::map::Map<'_>, id: HirId) -> bool {\n+    match map.find(id) {\n+        Some(Node::Binding(_)) => (),\n+        _ => return false,\n+    }\n+\n+    match map.find(map.get_parent_node(id)) {\n+        Some(Node::Param(_)) => true,\n+        _ => false,\n+    }\n+}\n+\n+impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n+    fn consume(&mut self, cmt: &Place<'tcx>, mode: ConsumeMode) {\n+        if cmt.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.base {\n+                if let ConsumeMode::Move = mode {\n+                    // moved out or in. clearly can't be localized\n+                    self.set.remove(&lid);\n+                }\n+                let map = &self.cx.tcx.hir();\n+                if let Some(Node::Binding(_)) = map.find(cmt.hir_id) {\n+                    if self.set.contains(&lid) {\n+                        // let y = x where x is known\n+                        // remove x, insert y\n+                        self.set.insert(cmt.hir_id);\n+                        self.set.remove(&lid);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn borrow(&mut self, cmt: &Place<'tcx>, _: ty::BorrowKind) {\n+        if cmt.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.base {\n+                self.set.remove(&lid);\n+            }\n+        }\n+    }\n+\n+    fn mutate(&mut self, cmt: &Place<'tcx>) {\n+        if cmt.projections.is_empty() {\n+            let map = &self.cx.tcx.hir();\n+            if is_argument(*map, cmt.hir_id) {\n+                // Skip closure arguments\n+                let parent_id = map.get_parent_node(cmt.hir_id);\n+                if let Some(Node::Expr(..)) = map.find(map.get_parent_node(parent_id)) {\n+                    return;\n+                }\n+\n+                if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n+                    self.set.insert(cmt.hir_id);\n+                }\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {\n+    fn is_large_box(&self, ty: Ty<'tcx>) -> bool {\n+        // Large types need to be boxed to avoid stack overflows.\n+        if ty.is_box() {\n+            self.cx.layout_of(ty.boxed_ty()).map_or(0, |l| l.size.bytes()) > self.too_large_for_stack\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "e3e1136b67693aa856500090f28503b2f097bcef", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,227 @@\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def_id, Expr, ExprKind, Param, PatKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{\n+    implements_trait, is_adjusted, iter_input_pats, snippet_opt, span_lint_and_sugg, span_lint_and_then,\n+    type_is_unsafe_function,\n+};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for closures which just call another function where\n+    /// the function can be called directly. `unsafe` functions or calls where types\n+    /// get adjusted are ignored.\n+    ///\n+    /// **Why is this bad?** Needlessly creating a closure adds code for no benefit\n+    /// and gives the optimizer more work.\n+    ///\n+    /// **Known problems:** If creating the closure inside the closure has a side-\n+    /// effect then moving the closure creation out will change when that side-\n+    /// effect runs.\n+    /// See rust-lang/rust-clippy#1439 for more details.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// xs.map(|x| foo(x))\n+    /// ```\n+    /// where `foo(_)` is a plain function that takes the exact argument type of\n+    /// `x`.\n+    pub REDUNDANT_CLOSURE,\n+    style,\n+    \"redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for closures which only invoke a method on the closure\n+    /// argument and can be replaced by referencing the method directly.\n+    ///\n+    /// **Why is this bad?** It's unnecessary to create the closure.\n+    ///\n+    /// **Known problems:** rust-lang/rust-clippy#3071, rust-lang/rust-clippy#4002,\n+    /// rust-lang/rust-clippy#3942\n+    ///\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// Some('a').map(|s| s.to_uppercase());\n+    /// ```\n+    /// may be rewritten as\n+    /// ```rust,ignore\n+    /// Some('a').map(char::to_uppercase);\n+    /// ```\n+    pub REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n+    pedantic,\n+    \"redundant closures for method calls\"\n+}\n+\n+declare_lint_pass!(EtaReduction => [REDUNDANT_CLOSURE, REDUNDANT_CLOSURE_FOR_METHOD_CALLS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaReduction {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args) => {\n+                for arg in args {\n+                    check_closure(cx, arg)\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.kind {\n+        let body = cx.tcx.hir().body(eid);\n+        let ex = &body.value;\n+\n+        if_chain!(\n+            if let ExprKind::Call(ref caller, ref args) = ex.kind;\n+\n+            if let ExprKind::Path(_) = caller.kind;\n+\n+            // Not the same number of arguments, there is no way the closure is the same as the function return;\n+            if args.len() == decl.inputs.len();\n+\n+            // Are the expression or the arguments type-adjusted? Then we need the closure\n+            if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n+\n+            let fn_ty = cx.tables.expr_ty(caller);\n+\n+            if matches!(fn_ty.kind, ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n+\n+            if !type_is_unsafe_function(cx, fn_ty);\n+\n+            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n+\n+            then {\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |diag| {\n+                    if let Some(snippet) = snippet_opt(cx, caller.span) {\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"remove closure as shown\",\n+                            snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                });\n+            }\n+        );\n+\n+        if_chain!(\n+            if let ExprKind::MethodCall(ref path, _, ref args) = ex.kind;\n+\n+            // Not the same number of arguments, there is no way the closure is the same as the function return;\n+            if args.len() == decl.inputs.len();\n+\n+            // Are the expression or the arguments type-adjusted? Then we need the closure\n+            if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n+\n+            let method_def_id = cx.tables.type_dependent_def_id(ex.hir_id).unwrap();\n+            if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n+\n+            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n+\n+            if let Some(name) = get_ufcs_type_name(cx, method_def_id, &args[0]);\n+\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n+                    expr.span,\n+                    \"redundant closure found\",\n+                    \"remove closure as shown\",\n+                    format!(\"{}::{}\", name, path.ident.name),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        );\n+    }\n+}\n+\n+/// Tries to determine the type for universal function call to be used instead of the closure\n+fn get_ufcs_type_name(cx: &LateContext<'_, '_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n+    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n+    let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id);\n+\n+    if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n+        if match_borrow_depth(expected_type_of_self, &actual_type_of_self)\n+            && implements_trait(cx, actual_type_of_self, trait_id, &[])\n+        {\n+            return Some(cx.tcx.def_path_str(trait_id));\n+        }\n+    }\n+\n+    cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n+        //a type may implicitly implement other type's methods (e.g. Deref)\n+        if match_types(expected_type_of_self, &actual_type_of_self) {\n+            return Some(get_type_name(cx, &actual_type_of_self));\n+        }\n+        None\n+    })\n+}\n+\n+fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n+    match (&lhs.kind, &rhs.kind) {\n+        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n+        (l, r) => match (l, r) {\n+            (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n+            (_, _) => true,\n+        },\n+    }\n+}\n+\n+fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n+    match (&lhs.kind, &rhs.kind) {\n+        (ty::Bool, ty::Bool)\n+        | (ty::Char, ty::Char)\n+        | (ty::Int(_), ty::Int(_))\n+        | (ty::Uint(_), ty::Uint(_))\n+        | (ty::Str, ty::Str) => true,\n+        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_types(t1, t2),\n+        (ty::Array(t1, _), ty::Array(t2, _)) | (ty::Slice(t1), ty::Slice(t2)) => match_types(t1, t2),\n+        (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n+        (_, _) => false,\n+    }\n+}\n+\n+fn get_type_name(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> String {\n+    match ty.kind {\n+        ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n+        ty::Ref(_, r, _) => get_type_name(cx, &r),\n+        _ => ty.to_string(),\n+    }\n+}\n+\n+fn compare_inputs(\n+    closure_inputs: &mut dyn Iterator<Item = &Param<'_>>,\n+    call_args: &mut dyn Iterator<Item = &Expr<'_>>,\n+) -> bool {\n+    for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n+        if let PatKind::Binding(_, _, ident, _) = closure_input.pat.kind {\n+            // XXXManishearth Should I be checking the binding mode here?\n+            if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.kind {\n+                if p.segments.len() != 1 {\n+                    // If it's a proper path, it can't be a local variable\n+                    return false;\n+                }\n+                if p.segments[0].ident.name != ident.name {\n+                    // The two idents should be the same\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+    true\n+}"}, {"sha": "5206266ccf2a6d5e76d11b2c3be52c24c0537b63", "filename": "src/tools/clippy/clippy_lints/src/eval_order_dependence.rs", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,355 @@\n+use crate::utils::{get_parent_expr, span_lint, span_lint_and_note};\n+use if_chain::if_chain;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{def, BinOpKind, Block, Expr, ExprKind, Guard, HirId, Local, Node, QPath, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a read and a write to the same variable where\n+    /// whether the read occurs before or after the write depends on the evaluation\n+    /// order of sub-expressions.\n+    ///\n+    /// **Why is this bad?** It is often confusing to read. In addition, the\n+    /// sub-expression evaluation order for Rust is not well documented.\n+    ///\n+    /// **Known problems:** Code which intentionally depends on the evaluation\n+    /// order, or which is correct for any evaluation order.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut x = 0;\n+    /// let a = {\n+    ///     x = 1;\n+    ///     1\n+    /// } + x;\n+    /// // Unclear whether a is 1 or 2.\n+    /// ```\n+    pub EVAL_ORDER_DEPENDENCE,\n+    complexity,\n+    \"whether a variable read occurs before a write depends on sub-expression evaluation order\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for diverging calls that are not match arms or\n+    /// statements.\n+    ///\n+    /// **Why is this bad?** It is often confusing to read. In addition, the\n+    /// sub-expression evaluation order for Rust is not well documented.\n+    ///\n+    /// **Known problems:** Someone might want to use `some_bool || panic!()` as a\n+    /// shorthand.\n+    ///\n+    /// **Example:**\n+    /// ```rust,no_run\n+    /// # fn b() -> bool { true }\n+    /// # fn c() -> bool { true }\n+    /// let a = b() || panic!() || c();\n+    /// // `c()` is dead, `panic!()` is only called if `b()` returns `false`\n+    /// let x = (a, b, c, panic!());\n+    /// // can simply be replaced by `panic!()`\n+    /// ```\n+    pub DIVERGING_SUB_EXPRESSION,\n+    complexity,\n+    \"whether an expression contains a diverging sub expression\"\n+}\n+\n+declare_lint_pass!(EvalOrderDependence => [EVAL_ORDER_DEPENDENCE, DIVERGING_SUB_EXPRESSION]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        // Find a write to a local variable.\n+        match expr.kind {\n+            ExprKind::Assign(ref lhs, ..) | ExprKind::AssignOp(_, ref lhs, _) => {\n+                if let ExprKind::Path(ref qpath) = lhs.kind {\n+                    if let QPath::Resolved(_, ref path) = *qpath {\n+                        if path.segments.len() == 1 {\n+                            if let def::Res::Local(var) = cx.tables.qpath_res(qpath, lhs.hir_id) {\n+                                let mut visitor = ReadVisitor {\n+                                    cx,\n+                                    var,\n+                                    write_expr: expr,\n+                                    last_expr: expr,\n+                                };\n+                                check_for_unsequenced_reads(&mut visitor);\n+                            }\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n+        match stmt.kind {\n+            StmtKind::Local(ref local) => {\n+                if let Local { init: Some(ref e), .. } = **local {\n+                    DivergenceVisitor { cx }.visit_expr(e);\n+                }\n+            },\n+            StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n+            StmtKind::Item(..) => {},\n+        }\n+    }\n+}\n+\n+struct DivergenceVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n+    fn maybe_walk_expr(&mut self, e: &'tcx Expr<'_>) {\n+        match e.kind {\n+            ExprKind::Closure(..) => {},\n+            ExprKind::Match(ref e, arms, _) => {\n+                self.visit_expr(e);\n+                for arm in arms {\n+                    if let Some(Guard::If(if_expr)) = arm.guard {\n+                        self.visit_expr(if_expr)\n+                    }\n+                    // make sure top level arm expressions aren't linted\n+                    self.maybe_walk_expr(&*arm.body);\n+                }\n+            },\n+            _ => walk_expr(self, e),\n+        }\n+    }\n+    fn report_diverging_sub_expr(&mut self, e: &Expr<'_>) {\n+        span_lint(self.cx, DIVERGING_SUB_EXPRESSION, e.span, \"sub-expression diverges\");\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+        match e.kind {\n+            ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n+            ExprKind::Call(ref func, _) => {\n+                let typ = self.cx.tables.expr_ty(func);\n+                match typ.kind {\n+                    ty::FnDef(..) | ty::FnPtr(_) => {\n+                        let sig = typ.fn_sig(self.cx.tcx);\n+                        if let ty::Never = self.cx.tcx.erase_late_bound_regions(&sig).output().kind {\n+                            self.report_diverging_sub_expr(e);\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            },\n+            ExprKind::MethodCall(..) => {\n+                let borrowed_table = self.cx.tables;\n+                if borrowed_table.expr_ty(e).is_never() {\n+                    self.report_diverging_sub_expr(e);\n+                }\n+            },\n+            _ => {\n+                // do not lint expressions referencing objects of type `!`, as that required a\n+                // diverging expression\n+                // to begin with\n+            },\n+        }\n+        self.maybe_walk_expr(e);\n+    }\n+    fn visit_block(&mut self, _: &'tcx Block<'_>) {\n+        // don't continue over blocks, LateLintPass already does that\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Walks up the AST from the given write expression (`vis.write_expr`) looking\n+/// for reads to the same variable that are unsequenced relative to the write.\n+///\n+/// This means reads for which there is a common ancestor between the read and\n+/// the write such that\n+///\n+/// * evaluating the ancestor necessarily evaluates both the read and the write (for example, `&x`\n+///   and `|| x = 1` don't necessarily evaluate `x`), and\n+///\n+/// * which one is evaluated first depends on the order of sub-expression evaluation. Blocks, `if`s,\n+///   loops, `match`es, and the short-circuiting logical operators are considered to have a defined\n+///   evaluation order.\n+///\n+/// When such a read is found, the lint is triggered.\n+fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n+    let map = &vis.cx.tcx.hir();\n+    let mut cur_id = vis.write_expr.hir_id;\n+    loop {\n+        let parent_id = map.get_parent_node(cur_id);\n+        if parent_id == cur_id {\n+            break;\n+        }\n+        let parent_node = match map.find(parent_id) {\n+            Some(parent) => parent,\n+            None => break,\n+        };\n+\n+        let stop_early = match parent_node {\n+            Node::Expr(expr) => check_expr(vis, expr),\n+            Node::Stmt(stmt) => check_stmt(vis, stmt),\n+            Node::Item(_) => {\n+                // We reached the top of the function, stop.\n+                break;\n+            },\n+            _ => StopEarly::KeepGoing,\n+        };\n+        match stop_early {\n+            StopEarly::Stop => break,\n+            StopEarly::KeepGoing => {},\n+        }\n+\n+        cur_id = parent_id;\n+    }\n+}\n+\n+/// Whether to stop early for the loop in `check_for_unsequenced_reads`. (If\n+/// `check_expr` weren't an independent function, this would be unnecessary and\n+/// we could just use `break`).\n+enum StopEarly {\n+    KeepGoing,\n+    Stop,\n+}\n+\n+fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr<'_>) -> StopEarly {\n+    if expr.hir_id == vis.last_expr.hir_id {\n+        return StopEarly::KeepGoing;\n+    }\n+\n+    match expr.kind {\n+        ExprKind::Array(_)\n+        | ExprKind::Tup(_)\n+        | ExprKind::MethodCall(..)\n+        | ExprKind::Call(_, _)\n+        | ExprKind::Assign(..)\n+        | ExprKind::Index(_, _)\n+        | ExprKind::Repeat(_, _)\n+        | ExprKind::Struct(_, _, _) => {\n+            walk_expr(vis, expr);\n+        },\n+        ExprKind::Binary(op, _, _) | ExprKind::AssignOp(op, _, _) => {\n+            if op.node == BinOpKind::And || op.node == BinOpKind::Or {\n+                // x && y and x || y always evaluate x first, so these are\n+                // strictly sequenced.\n+            } else {\n+                walk_expr(vis, expr);\n+            }\n+        },\n+        ExprKind::Closure(_, _, _, _, _) => {\n+            // Either\n+            //\n+            // * `var` is defined in the closure body, in which case we've reached the top of the enclosing\n+            //   function and can stop, or\n+            //\n+            // * `var` is captured by the closure, in which case, because evaluating a closure does not evaluate\n+            //   its body, we don't necessarily have a write, so we need to stop to avoid generating false\n+            //   positives.\n+            //\n+            // This is also the only place we need to stop early (grrr).\n+            return StopEarly::Stop;\n+        },\n+        // All other expressions either have only one child or strictly\n+        // sequence the evaluation order of their sub-expressions.\n+        _ => {},\n+    }\n+\n+    vis.last_expr = expr;\n+\n+    StopEarly::KeepGoing\n+}\n+\n+fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt<'_>) -> StopEarly {\n+    match stmt.kind {\n+        StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => check_expr(vis, expr),\n+        // If the declaration is of a local variable, check its initializer\n+        // expression if it has one. Otherwise, keep going.\n+        StmtKind::Local(ref local) => local\n+            .init\n+            .as_ref()\n+            .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr)),\n+        _ => StopEarly::KeepGoing,\n+    }\n+}\n+\n+/// A visitor that looks for reads from a variable.\n+struct ReadVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    /// The ID of the variable we're looking for.\n+    var: HirId,\n+    /// The expressions where the write to the variable occurred (for reporting\n+    /// in the lint).\n+    write_expr: &'tcx Expr<'tcx>,\n+    /// The last (highest in the AST) expression we've checked, so we know not\n+    /// to recheck it.\n+    last_expr: &'tcx Expr<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if expr.hir_id == self.last_expr.hir_id {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Path(ref qpath) => {\n+                if_chain! {\n+                    if let QPath::Resolved(None, ref path) = *qpath;\n+                    if path.segments.len() == 1;\n+                    if let def::Res::Local(local_id) = self.cx.tables.qpath_res(qpath, expr.hir_id);\n+                    if local_id == self.var;\n+                    // Check that this is a read, not a write.\n+                    if !is_in_assignment_position(self.cx, expr);\n+                    then {\n+                        span_lint_and_note(\n+                            self.cx,\n+                            EVAL_ORDER_DEPENDENCE,\n+                            expr.span,\n+                            \"unsequenced read of a variable\",\n+                            Some(self.write_expr.span),\n+                            \"whether read occurs before this write depends on evaluation order\"\n+                        );\n+                    }\n+                }\n+            }\n+            // We're about to descend a closure. Since we don't know when (or\n+            // if) the closure will be evaluated, any reads in it might not\n+            // occur here (or ever). Like above, bail to avoid false positives.\n+            ExprKind::Closure(_, _, _, _, _) |\n+\n+            // We want to avoid a false positive when a variable name occurs\n+            // only to have its address taken, so we stop here. Technically,\n+            // this misses some weird cases, eg.\n+            //\n+            // ```rust\n+            // let mut x = 0;\n+            // let a = foo(&{x = 1; x}, x);\n+            // ```\n+            //\n+            // TODO: fix this\n+            ExprKind::AddrOf(_, _, _) => {\n+                return;\n+            }\n+            _ => {}\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Returns `true` if `expr` is the LHS of an assignment, like `expr = ...`.\n+fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    if let Some(parent) = get_parent_expr(cx, expr) {\n+        if let ExprKind::Assign(ref lhs, ..) = parent.kind {\n+            return lhs.hir_id == expr.hir_id;\n+        }\n+    }\n+    false\n+}"}, {"sha": "82ca4baacb7a9763cd390532f369c36a88924941", "filename": "src/tools/clippy/clippy_lints/src/excessive_bools.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,176 @@\n+use crate::utils::{attr_by_name, in_macro, match_path_ast, span_lint_and_help};\n+use rustc_ast::ast::{AssocItemKind, Extern, FnSig, Item, ItemKind, Ty, TyKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n+\n+use std::convert::TryInto;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for excessive\n+    /// use of bools in structs.\n+    ///\n+    /// **Why is this bad?** Excessive bools in a struct\n+    /// is often a sign that it's used as a state machine,\n+    /// which is much better implemented as an enum.\n+    /// If it's not the case, excessive bools usually benefit\n+    /// from refactoring into two-variant enums for better\n+    /// readability and API.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust\n+    /// struct S {\n+    ///     is_pending: bool,\n+    ///     is_processing: bool,\n+    ///     is_finished: bool,\n+    /// }\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// enum S {\n+    ///     Pending,\n+    ///     Processing,\n+    ///     Finished,\n+    /// }\n+    /// ```\n+    pub STRUCT_EXCESSIVE_BOOLS,\n+    pedantic,\n+    \"using too many bools in a struct\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for excessive use of\n+    /// bools in function definitions.\n+    ///\n+    /// **Why is this bad?** Calls to such functions\n+    /// are confusing and error prone, because it's\n+    /// hard to remember argument order and you have\n+    /// no type system support to back you up. Using\n+    /// two-variant enums instead of bools often makes\n+    /// API easier to use.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// fn f(is_round: bool, is_hot: bool) { ... }\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// enum Shape {\n+    ///     Round,\n+    ///     Spiky,\n+    /// }\n+    ///\n+    /// enum Temperature {\n+    ///     Hot,\n+    ///     IceCold,\n+    /// }\n+    ///\n+    /// fn f(shape: Shape, temperature: Temperature) { ... }\n+    /// ```\n+    pub FN_PARAMS_EXCESSIVE_BOOLS,\n+    pedantic,\n+    \"using too many bools in function parameters\"\n+}\n+\n+pub struct ExcessiveBools {\n+    max_struct_bools: u64,\n+    max_fn_params_bools: u64,\n+}\n+\n+impl ExcessiveBools {\n+    #[must_use]\n+    pub fn new(max_struct_bools: u64, max_fn_params_bools: u64) -> Self {\n+        Self {\n+            max_struct_bools,\n+            max_fn_params_bools,\n+        }\n+    }\n+\n+    fn check_fn_sig(&self, cx: &EarlyContext<'_>, fn_sig: &FnSig, span: Span) {\n+        match fn_sig.header.ext {\n+            Extern::Implicit | Extern::Explicit(_) => return,\n+            Extern::None => (),\n+        }\n+\n+        let fn_sig_bools = fn_sig\n+            .decl\n+            .inputs\n+            .iter()\n+            .filter(|param| is_bool_ty(&param.ty))\n+            .count()\n+            .try_into()\n+            .unwrap();\n+        if self.max_fn_params_bools < fn_sig_bools {\n+            span_lint_and_help(\n+                cx,\n+                FN_PARAMS_EXCESSIVE_BOOLS,\n+                span,\n+                &format!(\"more than {} bools in function parameters\", self.max_fn_params_bools),\n+                None,\n+                \"consider refactoring bools into two-variant enums\",\n+            );\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(ExcessiveBools => [STRUCT_EXCESSIVE_BOOLS, FN_PARAMS_EXCESSIVE_BOOLS]);\n+\n+fn is_bool_ty(ty: &Ty) -> bool {\n+    if let TyKind::Path(None, path) = &ty.kind {\n+        return match_path_ast(path, &[\"bool\"]);\n+    }\n+    false\n+}\n+\n+impl EarlyLintPass for ExcessiveBools {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if in_macro(item.span) {\n+            return;\n+        }\n+        match &item.kind {\n+            ItemKind::Struct(variant_data, _) => {\n+                if attr_by_name(&item.attrs, \"repr\").is_some() {\n+                    return;\n+                }\n+\n+                let struct_bools = variant_data\n+                    .fields()\n+                    .iter()\n+                    .filter(|field| is_bool_ty(&field.ty))\n+                    .count()\n+                    .try_into()\n+                    .unwrap();\n+                if self.max_struct_bools < struct_bools {\n+                    span_lint_and_help(\n+                        cx,\n+                        STRUCT_EXCESSIVE_BOOLS,\n+                        item.span,\n+                        &format!(\"more than {} bools in a struct\", self.max_struct_bools),\n+                        None,\n+                        \"consider using a state machine or refactoring bools into two-variant enums\",\n+                    );\n+                }\n+            },\n+            ItemKind::Impl {\n+                of_trait: None, items, ..\n+            }\n+            | ItemKind::Trait(_, _, _, _, items) => {\n+                for item in items {\n+                    if let AssocItemKind::Fn(_, fn_sig, _, _) = &item.kind {\n+                        self.check_fn_sig(cx, fn_sig, item.span);\n+                    }\n+                }\n+            },\n+            ItemKind::Fn(_, fn_sig, _, _) => self.check_fn_sig(cx, fn_sig, item.span),\n+            _ => (),\n+        }\n+    }\n+}"}, {"sha": "621d56185a9dd4fac7ebb73a33f5a359d8959d49", "filename": "src/tools/clippy/clippy_lints/src/exit.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,47 @@\n+use crate::utils::{is_entrypoint_fn, match_def_path, paths, qpath_res, span_lint};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, Item, ItemKind, Node};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** `exit()`  terminates the program and doesn't provide a\n+    /// stack trace.\n+    ///\n+    /// **Why is this bad?** Ideally a program is terminated by finishing\n+    /// the main function.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// std::process::exit(0)\n+    /// ```\n+    pub EXIT,\n+    restriction,\n+    \"`std::process::exit` is called, terminating the program\"\n+}\n+\n+declare_lint_pass!(Exit => [EXIT]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Exit {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(ref path_expr, ref _args) = e.kind;\n+            if let ExprKind::Path(ref path) = path_expr.kind;\n+            if let Some(def_id) = qpath_res(cx, path, path_expr.hir_id).opt_def_id();\n+            if match_def_path(cx, def_id, &paths::EXIT);\n+            then {\n+                let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n+                if let Some(Node::Item(Item{kind: ItemKind::Fn(..), ..})) = cx.tcx.hir().find(parent) {\n+                    // If the next item up is a function we check if it is an entry point\n+                    // and only then emit a linter warning\n+                    let def_id = cx.tcx.hir().local_def_id(parent);\n+                    if !is_entrypoint_fn(cx, def_id.to_def_id()) {\n+                        span_lint(cx, EXIT, e.span, \"usage of `process::exit`\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "320121b277140727d3a190bcacad260e5b46ac54", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,149 @@\n+use crate::utils::{is_expn_of, match_function_call, paths, span_lint, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `write!()` / `writeln()!` which can be\n+    /// replaced with `(e)print!()` / `(e)println!()`\n+    ///\n+    /// **Why is this bad?** Using `(e)println! is clearer and more concise\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::io::Write;\n+    /// # let bar = \"furchtbar\";\n+    /// // this would be clearer as `eprintln!(\"foo: {:?}\", bar);`\n+    /// writeln!(&mut std::io::stderr(), \"foo: {:?}\", bar).unwrap();\n+    /// ```\n+    pub EXPLICIT_WRITE,\n+    complexity,\n+    \"using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work\"\n+}\n+\n+declare_lint_pass!(ExplicitWrite => [EXPLICIT_WRITE]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            // match call to unwrap\n+            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.kind;\n+            if unwrap_fun.ident.name == sym!(unwrap);\n+            // match call to write_fmt\n+            if !unwrap_args.is_empty();\n+            if let ExprKind::MethodCall(ref write_fun, _, write_args) =\n+                unwrap_args[0].kind;\n+            if write_fun.ident.name == sym!(write_fmt);\n+            // match calls to std::io::stdout() / std::io::stderr ()\n+            if !write_args.is_empty();\n+            if let Some(dest_name) = if match_function_call(cx, &write_args[0], &paths::STDOUT).is_some() {\n+                Some(\"stdout\")\n+            } else if match_function_call(cx, &write_args[0], &paths::STDERR).is_some() {\n+                Some(\"stderr\")\n+            } else {\n+                None\n+            };\n+            then {\n+                let write_span = unwrap_args[0].span;\n+                let calling_macro =\n+                    // ordering is important here, since `writeln!` uses `write!` internally\n+                    if is_expn_of(write_span, \"writeln\").is_some() {\n+                        Some(\"writeln\")\n+                    } else if is_expn_of(write_span, \"write\").is_some() {\n+                        Some(\"write\")\n+                    } else {\n+                        None\n+                    };\n+                let prefix = if dest_name == \"stderr\" {\n+                    \"e\"\n+                } else {\n+                    \"\"\n+                };\n+\n+                // We need to remove the last trailing newline from the string because the\n+                // underlying `fmt::write` function doesn't know whether `println!` or `print!` was\n+                // used.\n+                if let Some(mut write_output) = write_output_string(write_args) {\n+                    if write_output.ends_with('\\n') {\n+                        write_output.pop();\n+                    }\n+\n+                    if let Some(macro_name) = calling_macro {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            EXPLICIT_WRITE,\n+                            expr.span,\n+                            &format!(\n+                                \"use of `{}!({}(), ...).unwrap()`\",\n+                                macro_name,\n+                                dest_name\n+                            ),\n+                            \"try this\",\n+                            format!(\"{}{}!(\\\"{}\\\")\", prefix, macro_name.replace(\"write\", \"print\"), write_output.escape_default()),\n+                            Applicability::MachineApplicable\n+                        );\n+                    } else {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            EXPLICIT_WRITE,\n+                            expr.span,\n+                            &format!(\"use of `{}().write_fmt(...).unwrap()`\", dest_name),\n+                            \"try this\",\n+                            format!(\"{}print!(\\\"{}\\\")\", prefix, write_output.escape_default()),\n+                            Applicability::MachineApplicable\n+                        );\n+                    }\n+                } else {\n+                    // We don't have a proper suggestion\n+                    if let Some(macro_name) = calling_macro {\n+                        span_lint(\n+                            cx,\n+                            EXPLICIT_WRITE,\n+                            expr.span,\n+                            &format!(\n+                                \"use of `{}!({}(), ...).unwrap()`. Consider using `{}{}!` instead\",\n+                                macro_name,\n+                                dest_name,\n+                                prefix,\n+                                macro_name.replace(\"write\", \"print\")\n+                            )\n+                        );\n+                    } else {\n+                        span_lint(\n+                            cx,\n+                            EXPLICIT_WRITE,\n+                            expr.span,\n+                            &format!(\"use of `{}().write_fmt(...).unwrap()`. Consider using `{}print!` instead\", dest_name, prefix),\n+                        );\n+                    }\n+                }\n+\n+            }\n+        }\n+    }\n+}\n+\n+// Extract the output string from the given `write_args`.\n+fn write_output_string(write_args: &[Expr<'_>]) -> Option<String> {\n+    if_chain! {\n+        // Obtain the string that should be printed\n+        if write_args.len() > 1;\n+        if let ExprKind::Call(_, ref output_args) = write_args[1].kind;\n+        if !output_args.is_empty();\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref output_string_expr) = output_args[0].kind;\n+        if let ExprKind::Array(ref string_exprs) = output_string_expr.kind;\n+        // we only want to provide an automatic suggestion for simple (non-format) strings\n+        if string_exprs.len() == 1;\n+        if let ExprKind::Lit(ref lit) = string_exprs[0].kind;\n+        if let LitKind::Str(ref write_output, _) = lit.node;\n+        then {\n+            return Some(write_output.to_string())\n+        }\n+    }\n+    None\n+}"}, {"sha": "17639cc2a0643798c4b2e701d87758869fcebb6b", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,130 @@\n+use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT};\n+use crate::utils::{\n+    is_expn_of, is_type_diagnostic_item, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty,\n+};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n+    ///\n+    /// **Why is this bad?** `TryFrom` should be used if there's a possibility of failure.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo(i32);\n+    /// impl From<String> for Foo {\n+    ///     fn from(s: String) -> Self {\n+    ///         Foo(s.parse().unwrap())\n+    ///     }\n+    /// }\n+    /// ```\n+    pub FALLIBLE_IMPL_FROM,\n+    nursery,\n+    \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\"\n+}\n+\n+declare_lint_pass!(FallibleImplFrom => [FALLIBLE_IMPL_FROM]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+        // check for `impl From<???> for ..`\n+        let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n+        if_chain! {\n+            if let hir::ItemKind::Impl{ items: impl_items, .. } = item.kind;\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n+            if match_def_path(cx, impl_trait_ref.def_id, &FROM_TRAIT);\n+            then {\n+                lint_impl_body(cx, item.span, impl_items);\n+            }\n+        }\n+    }\n+}\n+\n+fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_items: &[hir::ImplItemRef<'_>]) {\n+    use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+    use rustc_hir::{Expr, ExprKind, ImplItemKind, QPath};\n+\n+    struct FindPanicUnwrap<'a, 'tcx> {\n+        lcx: &'a LateContext<'a, 'tcx>,\n+        tables: &'tcx ty::TypeckTables<'tcx>,\n+        result: Vec<Span>,\n+    }\n+\n+    impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n+        type Map = Map<'tcx>;\n+\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+            // check for `begin_panic`\n+            if_chain! {\n+                if let ExprKind::Call(ref func_expr, _) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.kind;\n+                if let Some(path_def_id) = path.res.opt_def_id();\n+                if match_def_path(self.lcx, path_def_id, &BEGIN_PANIC) ||\n+                    match_def_path(self.lcx, path_def_id, &BEGIN_PANIC_FMT);\n+                if is_expn_of(expr.span, \"unreachable\").is_none();\n+                then {\n+                    self.result.push(expr.span);\n+                }\n+            }\n+\n+            // check for `unwrap`\n+            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+                let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n+                if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n+                    || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+                {\n+                    self.result.push(expr.span);\n+                }\n+            }\n+\n+            // and check sub-expressions\n+            intravisit::walk_expr(self, expr);\n+        }\n+\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+\n+    for impl_item in impl_items {\n+        if_chain! {\n+            if impl_item.ident.name == sym!(from);\n+            if let ImplItemKind::Fn(_, body_id) =\n+                cx.tcx.hir().impl_item(impl_item.id).kind;\n+            then {\n+                // check the body for `begin_panic` or `unwrap`\n+                let body = cx.tcx.hir().body(body_id);\n+                let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.id.hir_id);\n+                let mut fpu = FindPanicUnwrap {\n+                    lcx: cx,\n+                    tables: cx.tcx.typeck_tables_of(impl_item_def_id),\n+                    result: Vec::new(),\n+                };\n+                fpu.visit_expr(&body.value);\n+\n+                // if we've found one, lint\n+                if !fpu.result.is_empty() {\n+                    span_lint_and_then(\n+                        cx,\n+                        FALLIBLE_IMPL_FROM,\n+                        impl_span,\n+                        \"consider implementing `TryFrom` instead\",\n+                        move |diag| {\n+                            diag.help(\n+                                \"`From` is intended for infallible conversions only. \\\n+                                 Use `TryFrom` if there's a possibility for the conversion to fail.\");\n+                            diag.span_note(fpu.result, \"potential failure(s)\");\n+                        });\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3a52b1d3fc20bdd2580e38e052fb0614f8313e03", "filename": "src/tools/clippy/clippy_lints/src/float_literal.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,182 @@\n+use crate::utils::{numeric_literal, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use std::fmt;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for float literals with a precision greater\n+    /// than that supported by the underlying type.\n+    ///\n+    /// **Why is this bad?** Rust will truncate the literal silently.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let v: f32 = 0.123_456_789_9;\n+    /// println!(\"{}\", v); //  0.123_456_789\n+    ///\n+    /// // Good\n+    /// let v: f64 = 0.123_456_789_9;\n+    /// println!(\"{}\", v); //  0.123_456_789_9\n+    /// ```\n+    pub EXCESSIVE_PRECISION,\n+    style,\n+    \"excessive precision for float literal\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for whole number float literals that\n+    /// cannot be represented as the underlying type without loss.\n+    ///\n+    /// **Why is this bad?** Rust will silently lose precision during\n+    /// conversion to a float.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let _: f32 = 16_777_217.0; // 16_777_216.0\n+    ///\n+    /// // Good\n+    /// let _: f32 = 16_777_216.0;\n+    /// let _: f64 = 16_777_217.0;\n+    /// ```\n+    pub LOSSY_FLOAT_LITERAL,\n+    restriction,\n+    \"lossy whole number float literals\"\n+}\n+\n+declare_lint_pass!(FloatLiteral => [EXCESSIVE_PRECISION, LOSSY_FLOAT_LITERAL]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatLiteral {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            let ty = cx.tables.expr_ty(expr);\n+            if let ty::Float(fty) = ty.kind;\n+            if let hir::ExprKind::Lit(ref lit) = expr.kind;\n+            if let LitKind::Float(sym, lit_float_ty) = lit.node;\n+            then {\n+                let sym_str = sym.as_str();\n+                let formatter = FloatFormat::new(&sym_str);\n+                // Try to bail out if the float is for sure fine.\n+                // If its within the 2 decimal digits of being out of precision we\n+                // check if the parsed representation is the same as the string\n+                // since we'll need the truncated string anyway.\n+                let digits = count_digits(&sym_str);\n+                let max = max_digits(fty);\n+                let type_suffix = match lit_float_ty {\n+                    LitFloatType::Suffixed(FloatTy::F32) => Some(\"f32\"),\n+                    LitFloatType::Suffixed(FloatTy::F64) => Some(\"f64\"),\n+                    _ => None\n+                };\n+                let (is_whole, mut float_str) = match fty {\n+                    FloatTy::F32 => {\n+                        let value = sym_str.parse::<f32>().unwrap();\n+\n+                        (value.fract() == 0.0, formatter.format(value))\n+                    },\n+                    FloatTy::F64 => {\n+                        let value = sym_str.parse::<f64>().unwrap();\n+\n+                        (value.fract() == 0.0, formatter.format(value))\n+                    },\n+                };\n+\n+                if is_whole && !sym_str.contains(|c| c == 'e' || c == 'E') {\n+                    // Normalize the literal by stripping the fractional portion\n+                    if sym_str.split('.').next().unwrap() != float_str {\n+                        // If the type suffix is missing the suggestion would be\n+                        // incorrectly interpreted as an integer so adding a `.0`\n+                        // suffix to prevent that.\n+                        if type_suffix.is_none() {\n+                            float_str.push_str(\".0\");\n+                        }\n+\n+                        span_lint_and_sugg(\n+                            cx,\n+                            LOSSY_FLOAT_LITERAL,\n+                            expr.span,\n+                            \"literal cannot be represented as the underlying type without loss of precision\",\n+                            \"consider changing the type or replacing it with\",\n+                            numeric_literal::format(&float_str, type_suffix, true),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                } else if digits > max as usize && sym_str != float_str {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        EXCESSIVE_PRECISION,\n+                        expr.span,\n+                        \"float has excessive precision\",\n+                        \"consider changing the type or truncating it to\",\n+                        numeric_literal::format(&float_str, type_suffix, true),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[must_use]\n+fn max_digits(fty: FloatTy) -> u32 {\n+    match fty {\n+        FloatTy::F32 => f32::DIGITS,\n+        FloatTy::F64 => f64::DIGITS,\n+    }\n+}\n+\n+/// Counts the digits excluding leading zeros\n+#[must_use]\n+fn count_digits(s: &str) -> usize {\n+    // Note that s does not contain the f32/64 suffix, and underscores have been stripped\n+    s.chars()\n+        .filter(|c| *c != '-' && *c != '.')\n+        .take_while(|c| *c != 'e' && *c != 'E')\n+        .fold(0, |count, c| {\n+            // leading zeros\n+            if c == '0' && count == 0 {\n+                count\n+            } else {\n+                count + 1\n+            }\n+        })\n+}\n+\n+enum FloatFormat {\n+    LowerExp,\n+    UpperExp,\n+    Normal,\n+}\n+impl FloatFormat {\n+    #[must_use]\n+    fn new(s: &str) -> Self {\n+        s.chars()\n+            .find_map(|x| match x {\n+                'e' => Some(Self::LowerExp),\n+                'E' => Some(Self::UpperExp),\n+                _ => None,\n+            })\n+            .unwrap_or(Self::Normal)\n+    }\n+    fn format<T>(&self, f: T) -> String\n+    where\n+        T: fmt::UpperExp + fmt::LowerExp + fmt::Display,\n+    {\n+        match self {\n+            Self::LowerExp => format!(\"{:e}\", f),\n+            Self::UpperExp => format!(\"{:E}\", f),\n+            Self::Normal => format!(\"{}\", f),\n+        }\n+    }\n+}"}, {"sha": "86317fb8bd5c4767b9ed5d7a4e9543b7fc8ed17c", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,503 @@\n+use crate::consts::{\n+    constant, constant_simple, Constant,\n+    Constant::{F32, F64},\n+};\n+use crate::utils::{higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+\n+use rustc_ast::ast;\n+use std::f32::consts as f32_consts;\n+use std::f64::consts as f64_consts;\n+use sugg::Sugg;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Looks for floating-point expressions that\n+    /// can be expressed using built-in methods to improve accuracy\n+    /// at the cost of performance.\n+    ///\n+    /// **Why is this bad?** Negatively impacts accuracy.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    ///\n+    /// let a = 3f32;\n+    /// let _ = a.powf(1.0 / 3.0);\n+    /// let _ = (1.0 + a).ln();\n+    /// let _ = a.exp() - 1.0;\n+    /// ```\n+    ///\n+    /// is better expressed as\n+    ///\n+    /// ```rust\n+    ///\n+    /// let a = 3f32;\n+    /// let _ = a.cbrt();\n+    /// let _ = a.ln_1p();\n+    /// let _ = a.exp_m1();\n+    /// ```\n+    pub IMPRECISE_FLOPS,\n+    nursery,\n+    \"usage of imprecise floating point operations\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Looks for floating-point expressions that\n+    /// can be expressed using built-in methods to improve both\n+    /// accuracy and performance.\n+    ///\n+    /// **Why is this bad?** Negatively impacts accuracy and performance.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::f32::consts::E;\n+    ///\n+    /// let a = 3f32;\n+    /// let _ = (2f32).powf(a);\n+    /// let _ = E.powf(a);\n+    /// let _ = a.powf(1.0 / 2.0);\n+    /// let _ = a.log(2.0);\n+    /// let _ = a.log(10.0);\n+    /// let _ = a.log(E);\n+    /// let _ = a.powf(2.0);\n+    /// let _ = a * 2.0 + 4.0;\n+    /// let _ = if a < 0.0 {\n+    ///     -a\n+    /// } else {\n+    ///     a\n+    /// };\n+    /// let _ = if a < 0.0 {\n+    ///     a\n+    /// } else {\n+    ///     -a\n+    /// };\n+    /// ```\n+    ///\n+    /// is better expressed as\n+    ///\n+    /// ```rust\n+    /// use std::f32::consts::E;\n+    ///\n+    /// let a = 3f32;\n+    /// let _ = a.exp2();\n+    /// let _ = a.exp();\n+    /// let _ = a.sqrt();\n+    /// let _ = a.log2();\n+    /// let _ = a.log10();\n+    /// let _ = a.ln();\n+    /// let _ = a.powi(2);\n+    /// let _ = a.mul_add(2.0, 4.0);\n+    /// let _ = a.abs();\n+    /// let _ = -a.abs();\n+    /// ```\n+    pub SUBOPTIMAL_FLOPS,\n+    nursery,\n+    \"usage of sub-optimal floating point operations\"\n+}\n+\n+declare_lint_pass!(FloatingPointArithmetic => [\n+    IMPRECISE_FLOPS,\n+    SUBOPTIMAL_FLOPS\n+]);\n+\n+// Returns the specialized log method for a given base if base is constant\n+// and is one of 2, 10 and e\n+fn get_specialized_log_method(cx: &LateContext<'_, '_>, base: &Expr<'_>) -> Option<&'static str> {\n+    if let Some((value, _)) = constant(cx, cx.tables, base) {\n+        if F32(2.0) == value || F64(2.0) == value {\n+            return Some(\"log2\");\n+        } else if F32(10.0) == value || F64(10.0) == value {\n+            return Some(\"log10\");\n+        } else if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n+            return Some(\"ln\");\n+        }\n+    }\n+\n+    None\n+}\n+\n+// Adds type suffixes and parenthesis to method receivers if necessary\n+fn prepare_receiver_sugg<'a>(cx: &LateContext<'_, '_>, mut expr: &'a Expr<'a>) -> Sugg<'a> {\n+    let mut suggestion = Sugg::hir(cx, expr, \"..\");\n+\n+    if let ExprKind::Unary(UnOp::UnNeg, inner_expr) = &expr.kind {\n+        expr = &inner_expr;\n+    }\n+\n+    if_chain! {\n+        // if the expression is a float literal and it is unsuffixed then\n+        // add a suffix so the suggestion is valid and unambiguous\n+        if let ty::Float(float_ty) = cx.tables.expr_ty(expr).kind;\n+        if let ExprKind::Lit(lit) = &expr.kind;\n+        if let ast::LitKind::Float(sym, ast::LitFloatType::Unsuffixed) = lit.node;\n+        then {\n+            let op = format!(\n+                \"{}{}{}\",\n+                suggestion,\n+                // Check for float literals without numbers following the decimal\n+                // separator such as `2.` and adds a trailing zero\n+                if sym.as_str().ends_with('.') {\n+                    \"0\"\n+                } else {\n+                    \"\"\n+                },\n+                float_ty.name_str()\n+            ).into();\n+\n+            suggestion = match suggestion {\n+                Sugg::MaybeParen(_) => Sugg::MaybeParen(op),\n+                _ => Sugg::NonParen(op)\n+            };\n+        }\n+    }\n+\n+    suggestion.maybe_par()\n+}\n+\n+fn check_log_base(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some(method) = get_specialized_log_method(cx, &args[1]) {\n+        span_lint_and_sugg(\n+            cx,\n+            SUBOPTIMAL_FLOPS,\n+            expr.span,\n+            \"logarithm for bases 2, 10 and e can be computed more accurately\",\n+            \"consider using\",\n+            format!(\"{}.{}()\", Sugg::hir(cx, &args[0], \"..\"), method),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// TODO: Lint expressions of the form `(x + y).ln()` where y > 1 and\n+// suggest usage of `(x + (y - 1)).ln_1p()` instead\n+fn check_ln1p(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let ExprKind::Binary(\n+        Spanned {\n+            node: BinOpKind::Add, ..\n+        },\n+        lhs,\n+        rhs,\n+    ) = &args[0].kind\n+    {\n+        let recv = match (constant(cx, cx.tables, lhs), constant(cx, cx.tables, rhs)) {\n+            (Some((value, _)), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n+            (_, Some((value, _))) if F32(1.0) == value || F64(1.0) == value => lhs,\n+            _ => return,\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            IMPRECISE_FLOPS,\n+            expr.span,\n+            \"ln(1 + x) can be computed more accurately\",\n+            \"consider using\",\n+            format!(\"{}.ln_1p()\", prepare_receiver_sugg(cx, recv)),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// Returns an integer if the float constant is a whole number and it can be\n+// converted to an integer without loss of precision. For now we only check\n+// ranges [-16777215, 16777216) for type f32 as whole number floats outside\n+// this range are lossy and ambiguous.\n+#[allow(clippy::cast_possible_truncation)]\n+fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n+    match value {\n+        F32(num) if num.fract() == 0.0 => {\n+            if (-16_777_215.0..16_777_216.0).contains(num) {\n+                Some(num.round() as i32)\n+            } else {\n+                None\n+            }\n+        },\n+        F64(num) if num.fract() == 0.0 => {\n+            if (-2_147_483_648.0..2_147_483_648.0).contains(num) {\n+                Some(num.round() as i32)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    // Check receiver\n+    if let Some((value, _)) = constant(cx, cx.tables, &args[0]) {\n+        let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n+            \"exp\"\n+        } else if F32(2.0) == value || F64(2.0) == value {\n+            \"exp2\"\n+        } else {\n+            return;\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            SUBOPTIMAL_FLOPS,\n+            expr.span,\n+            \"exponent for bases 2 and e can be computed more accurately\",\n+            \"consider using\",\n+            format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[1]), method),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    // Check argument\n+    if let Some((value, _)) = constant(cx, cx.tables, &args[1]) {\n+        let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n+            (\n+                SUBOPTIMAL_FLOPS,\n+                \"square-root of a number can be computed more efficiently and accurately\",\n+                format!(\"{}.sqrt()\", Sugg::hir(cx, &args[0], \"..\")),\n+            )\n+        } else if F32(1.0 / 3.0) == value || F64(1.0 / 3.0) == value {\n+            (\n+                IMPRECISE_FLOPS,\n+                \"cube-root of a number can be computed more accurately\",\n+                format!(\"{}.cbrt()\", Sugg::hir(cx, &args[0], \"..\")),\n+            )\n+        } else if let Some(exponent) = get_integer_from_float_constant(&value) {\n+            (\n+                SUBOPTIMAL_FLOPS,\n+                \"exponentiation with integer powers can be computed more efficiently\",\n+                format!(\n+                    \"{}.powi({})\",\n+                    Sugg::hir(cx, &args[0], \"..\"),\n+                    numeric_literal::format(&exponent.to_string(), None, false)\n+                ),\n+            )\n+        } else {\n+            return;\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            lint,\n+            expr.span,\n+            help,\n+            \"consider using\",\n+            suggestion,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// TODO: Lint expressions of the form `x.exp() - y` where y > 1\n+// and suggest usage of `x.exp_m1() - (y - 1)` instead\n+fn check_expm1(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) = expr.kind;\n+        if cx.tables.expr_ty(lhs).is_floating_point();\n+        if let Some((value, _)) = constant(cx, cx.tables, rhs);\n+        if F32(1.0) == value || F64(1.0) == value;\n+        if let ExprKind::MethodCall(ref path, _, ref method_args) = lhs.kind;\n+        if cx.tables.expr_ty(&method_args[0]).is_floating_point();\n+        if path.ident.name.as_str() == \"exp\";\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                IMPRECISE_FLOPS,\n+                expr.span,\n+                \"(e.pow(x) - 1) can be computed more accurately\",\n+                \"consider using\",\n+                format!(\n+                    \"{}.exp_m1()\",\n+                    Sugg::hir(cx, &method_args[0], \"..\")\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn is_float_mul_expr<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n+    if_chain! {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lhs, ref rhs) = &expr.kind;\n+        if cx.tables.expr_ty(lhs).is_floating_point();\n+        if cx.tables.expr_ty(rhs).is_floating_point();\n+        then {\n+            return Some((lhs, rhs));\n+        }\n+    }\n+\n+    None\n+}\n+\n+// TODO: Fix rust-lang/rust-clippy#4735\n+fn check_mul_add(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if let ExprKind::Binary(\n+        Spanned {\n+            node: BinOpKind::Add, ..\n+        },\n+        lhs,\n+        rhs,\n+    ) = &expr.kind\n+    {\n+        let (recv, arg1, arg2) = if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, lhs) {\n+            (inner_lhs, inner_rhs, rhs)\n+        } else if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, rhs) {\n+            (inner_lhs, inner_rhs, lhs)\n+        } else {\n+            return;\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            SUBOPTIMAL_FLOPS,\n+            expr.span,\n+            \"multiply and add expressions can be calculated more efficiently and accurately\",\n+            \"consider using\",\n+            format!(\n+                \"{}.mul_add({}, {})\",\n+                prepare_receiver_sugg(cx, recv),\n+                Sugg::hir(cx, arg1, \"..\"),\n+                Sugg::hir(cx, arg2, \"..\"),\n+            ),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+/// Returns true iff expr is an expression which tests whether or not\n+/// test is positive or an expression which tests whether or not test\n+/// is nonnegative.\n+/// Used for check-custom-abs function below\n+fn is_testing_positive(cx: &LateContext<'_, '_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n+    if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n+        match op {\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+/// See [`is_testing_positive`]\n+fn is_testing_negative(cx: &LateContext<'_, '_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n+    if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n+        match op {\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn are_exprs_equal(cx: &LateContext<'_, '_>, expr1: &Expr<'_>, expr2: &Expr<'_>) -> bool {\n+    SpanlessEq::new(cx).ignore_fn().eq_expr(expr1, expr2)\n+}\n+\n+/// Returns true iff expr is some zero literal\n+fn is_zero(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    match constant_simple(cx, cx.tables, expr) {\n+        Some(Constant::Int(i)) => i == 0,\n+        Some(Constant::F32(f)) => f == 0.0,\n+        Some(Constant::F64(f)) => f == 0.0,\n+        _ => false,\n+    }\n+}\n+\n+/// If the two expressions are negations of each other, then it returns\n+/// a tuple, in which the first element is true iff expr1 is the\n+/// positive expressions, and the second element is the positive\n+/// one of the two expressions\n+/// If the two expressions are not negations of each other, then it\n+/// returns None.\n+fn are_negated<'a>(cx: &LateContext<'_, '_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n+    if let ExprKind::Unary(UnOp::UnNeg, expr1_negated) = &expr1.kind {\n+        if are_exprs_equal(cx, expr1_negated, expr2) {\n+            return Some((false, expr2));\n+        }\n+    }\n+    if let ExprKind::Unary(UnOp::UnNeg, expr2_negated) = &expr2.kind {\n+        if are_exprs_equal(cx, expr1, expr2_negated) {\n+            return Some((true, expr1));\n+        }\n+    }\n+    None\n+}\n+\n+fn check_custom_abs(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let Some((cond, body, Some(else_body))) = higher::if_block(&expr);\n+        if let ExprKind::Block(block, _) = body.kind;\n+        if block.stmts.is_empty();\n+        if let Some(if_body_expr) = block.expr;\n+        if let ExprKind::Block(else_block, _) = else_body.kind;\n+        if else_block.stmts.is_empty();\n+        if let Some(else_body_expr) = else_block.expr;\n+        if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);\n+        then {\n+            let positive_abs_sugg = (\n+                \"manual implementation of `abs` method\",\n+                format!(\"{}.abs()\", Sugg::hir(cx, body, \"..\")),\n+            );\n+            let negative_abs_sugg = (\n+                \"manual implementation of negation of `abs` method\",\n+                format!(\"-{}.abs()\", Sugg::hir(cx, body, \"..\")),\n+            );\n+            let sugg = if is_testing_positive(cx, cond, body) {\n+                if if_expr_positive {\n+                    positive_abs_sugg\n+                } else {\n+                    negative_abs_sugg\n+                }\n+            } else if is_testing_negative(cx, cond, body) {\n+                if if_expr_positive {\n+                    negative_abs_sugg\n+                } else {\n+                    positive_abs_sugg\n+                }\n+            } else {\n+                return;\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                SUBOPTIMAL_FLOPS,\n+                expr.span,\n+                sugg.0,\n+                \"try\",\n+                sugg.1,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::MethodCall(ref path, _, args) = &expr.kind {\n+            let recv_ty = cx.tables.expr_ty(&args[0]);\n+\n+            if recv_ty.is_floating_point() {\n+                match &*path.ident.name.as_str() {\n+                    \"ln\" => check_ln1p(cx, expr, args),\n+                    \"log\" => check_log_base(cx, expr, args),\n+                    \"powf\" => check_powf(cx, expr, args),\n+                    _ => {},\n+                }\n+            }\n+        } else {\n+            check_expm1(cx, expr);\n+            check_mul_add(cx, expr);\n+            check_custom_abs(cx, expr);\n+        }\n+    }\n+}"}, {"sha": "5b092526ce4f2921cafb6bc22747cec1cf3c7dfb", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,200 @@\n+use crate::utils::paths;\n+use crate::utils::{\n+    is_expn_of, is_type_diagnostic_item, last_path_segment, match_def_path, match_function_call, snippet,\n+    span_lint_and_then, walk_ptrs_ty,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, MatchSource, PatKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of `format!(\"string literal with no\n+    /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n+    ///\n+    /// **Why is this bad?** There is no point of doing that. `format!(\"foo\")` can\n+    /// be replaced by `\"foo\".to_owned()` if you really need a `String`. The even\n+    /// worse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\n+    /// foo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\n+    /// if `foo: &str`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// # let foo = \"foo\";\n+    /// format!(\"foo\");\n+    /// format!(\"{}\", foo);\n+    /// ```\n+    pub USELESS_FORMAT,\n+    complexity,\n+    \"useless use of `format!`\"\n+}\n+\n+declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessFormat {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        let span = match is_expn_of(expr.span, \"format\") {\n+            Some(s) if !s.from_expansion() => s,\n+            _ => return,\n+        };\n+\n+        // Operate on the only argument of `alloc::fmt::format`.\n+        if let Some(sugg) = on_new_v1(cx, expr) {\n+            span_useless_format(cx, span, \"consider using `.to_string()`\", sugg);\n+        } else if let Some(sugg) = on_new_v1_fmt(cx, expr) {\n+            span_useless_format(cx, span, \"consider using `.to_string()`\", sugg);\n+        }\n+    }\n+}\n+\n+fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg: String) {\n+    let to_replace = span.source_callsite();\n+\n+    // The callsite span contains the statement semicolon for some reason.\n+    let snippet = snippet(cx, to_replace, \"..\");\n+    if snippet.ends_with(';') {\n+        sugg.push(';');\n+    }\n+\n+    span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |diag| {\n+        diag.span_suggestion(\n+            to_replace,\n+            help,\n+            sugg,\n+            Applicability::MachineApplicable, // snippet\n+        );\n+    });\n+}\n+\n+fn on_argumentv1_new<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'_>],\n+) -> Option<String> {\n+    if_chain! {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref format_args) = expr.kind;\n+        if let ExprKind::Array(ref elems) = arms[0].body.kind;\n+        if elems.len() == 1;\n+        if let Some(args) = match_function_call(cx, &elems[0], &paths::FMT_ARGUMENTV1_NEW);\n+        // matches `core::fmt::Display::fmt`\n+        if args.len() == 2;\n+        if let ExprKind::Path(ref qpath) = args[1].kind;\n+        if let Some(did) = cx.tables.qpath_res(qpath, args[1].hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n+        // check `(arg0,)` in match block\n+        if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n+        if pats.len() == 1;\n+        then {\n+            let ty = walk_ptrs_ty(cx.tables.pat_ty(&pats[0]));\n+            if ty.kind != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+                return None;\n+            }\n+            if let ExprKind::Lit(ref lit) = format_args.kind {\n+                if let LitKind::Str(ref s, _) = lit.node {\n+                    return Some(format!(\"{:?}.to_string()\", s.as_str()));\n+                }\n+            } else {\n+                let snip = snippet(cx, format_args.span, \"<arg>\");\n+                if let ExprKind::MethodCall(ref path, _, _) = format_args.kind {\n+                    if path.ident.name == sym!(to_string) {\n+                        return Some(format!(\"{}\", snip));\n+                    }\n+                } else if let ExprKind::Binary(..) = format_args.kind {\n+                    return Some(format!(\"{}\", snip));\n+                }\n+                return Some(format!(\"{}.to_string()\", snip));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n+    if_chain! {\n+        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n+        if args.len() == 2;\n+        // Argument 1 in `new_v1()`\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arr) = args[0].kind;\n+        if let ExprKind::Array(ref pieces) = arr.kind;\n+        if pieces.len() == 1;\n+        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n+        if let LitKind::Str(ref s, _) = lit.node;\n+        // Argument 2 in `new_v1()`\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg1) = args[1].kind;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.kind;\n+        if arms.len() == 1;\n+        if let ExprKind::Tup(ref tup) = matchee.kind;\n+        then {\n+            // `format!(\"foo\")` expansion contains `match () { () => [], }`\n+            if tup.is_empty() {\n+                return Some(format!(\"{:?}.to_string()\", s.as_str()));\n+            } else if s.as_str().is_empty() {\n+                return on_argumentv1_new(cx, &tup[0], arms);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n+    if_chain! {\n+        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n+        if args.len() == 3;\n+        if check_unformatted(&args[2]);\n+        // Argument 1 in `new_v1_formatted()`\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arr) = args[0].kind;\n+        if let ExprKind::Array(ref pieces) = arr.kind;\n+        if pieces.len() == 1;\n+        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n+        if let LitKind::Str(..) = lit.node;\n+        // Argument 2 in `new_v1_formatted()`\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg1) = args[1].kind;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.kind;\n+        if arms.len() == 1;\n+        if let ExprKind::Tup(ref tup) = matchee.kind;\n+        then {\n+            return on_argumentv1_new(cx, &tup[0], arms);\n+        }\n+    }\n+    None\n+}\n+\n+/// Checks if the expression matches\n+/// ```rust,ignore\n+/// &[_ {\n+///    format: _ {\n+///         width: _::Implied,\n+///         precision: _::Implied,\n+///         ...\n+///    },\n+///    ...,\n+/// }]\n+/// ```\n+fn check_unformatted(expr: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) = expr.kind;\n+        if let ExprKind::Array(ref exprs) = expr.kind;\n+        if exprs.len() == 1;\n+        // struct `core::fmt::rt::v1::Argument`\n+        if let ExprKind::Struct(_, ref fields, _) = exprs[0].kind;\n+        if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym!(format));\n+        // struct `core::fmt::rt::v1::FormatSpec`\n+        if let ExprKind::Struct(_, ref fields, _) = format_field.expr.kind;\n+        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym!(precision));\n+        if let ExprKind::Path(ref precision_path) = precision_field.expr.kind;\n+        if last_path_segment(precision_path).ident.name == sym!(Implied);\n+        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n+        if let ExprKind::Path(ref width_qpath) = width_field.expr.kind;\n+        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "eb4b7a826f2ce10d8a05c9f2259f5098af96ce96", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,326 @@\n+use crate::utils::{differing_macro_contexts, snippet_opt, span_lint_and_help, span_lint_and_note};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-`\n+    /// operators.\n+    ///\n+    /// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or\n+    /// confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n+    /// ```\n+    pub SUSPICIOUS_ASSIGNMENT_FORMATTING,\n+    style,\n+    \"suspicious formatting of `*=`, `-=` or `!=`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks the formatting of a unary operator on the right hand side\n+    /// of a binary operator. It lints if there is no space between the binary and unary operators,\n+    /// but there is a space between the unary and its operand.\n+    ///\n+    /// **Why is this bad?** This is either a typo in the binary operator or confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// if foo <- 30 { // this should be `foo < -30` but looks like a different operator\n+    /// }\n+    ///\n+    /// if foo &&! bar { // this should be `foo && !bar` but looks like a different operator\n+    /// }\n+    /// ```\n+    pub SUSPICIOUS_UNARY_OP_FORMATTING,\n+    style,\n+    \"suspicious formatting of unary `-` or `!` on the RHS of a BinOp\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for formatting of `else`. It lints if the `else`\n+    /// is followed immediately by a newline or the `else` seems to be missing.\n+    ///\n+    /// **Why is this bad?** This is probably some refactoring remnant, even if the\n+    /// code is correct, it might look confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// if foo {\n+    /// } { // looks like an `else` is missing here\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } if bar { // looks like an `else` is missing here\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } else\n+    ///\n+    /// { // this is the `else` block of the previous `if`, but should it be?\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } else\n+    ///\n+    /// if bar { // this is the `else` block of the previous `if`, but should it be?\n+    /// }\n+    /// ```\n+    pub SUSPICIOUS_ELSE_FORMATTING,\n+    style,\n+    \"suspicious formatting of `else`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for possible missing comma in an array. It lints if\n+    /// an array element is a binary operator expression and it lies on two lines.\n+    ///\n+    /// **Why is this bad?** This could lead to unexpected results.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let a = &[\n+    ///     -1, -2, -3 // <= no comma here\n+    ///     -4, -5, -6\n+    /// ];\n+    /// ```\n+    pub POSSIBLE_MISSING_COMMA,\n+    correctness,\n+    \"possible missing comma in array\"\n+}\n+\n+declare_lint_pass!(Formatting => [\n+    SUSPICIOUS_ASSIGNMENT_FORMATTING,\n+    SUSPICIOUS_UNARY_OP_FORMATTING,\n+    SUSPICIOUS_ELSE_FORMATTING,\n+    POSSIBLE_MISSING_COMMA\n+]);\n+\n+impl EarlyLintPass for Formatting {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n+        for w in block.stmts.windows(2) {\n+            match (&w[0].kind, &w[1].kind) {\n+                (&StmtKind::Expr(ref first), &StmtKind::Expr(ref second))\n+                | (&StmtKind::Expr(ref first), &StmtKind::Semi(ref second)) => {\n+                    check_missing_else(cx, first, second);\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        check_assign(cx, expr);\n+        check_unop(cx, expr);\n+        check_else(cx, expr);\n+        check_array(cx, expr);\n+    }\n+}\n+\n+/// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n+fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n+    if let ExprKind::Assign(ref lhs, ref rhs, _) = expr.kind {\n+        if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion() {\n+            let eq_span = lhs.span.between(rhs.span);\n+            if let ExprKind::Unary(op, ref sub_rhs) = rhs.kind {\n+                if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n+                    let op = UnOp::to_string(op);\n+                    let eqop_span = lhs.span.between(sub_rhs.span);\n+                    if eq_snippet.ends_with('=') {\n+                        span_lint_and_note(\n+                            cx,\n+                            SUSPICIOUS_ASSIGNMENT_FORMATTING,\n+                            eqop_span,\n+                            &format!(\n+                                \"this looks like you are trying to use `.. {op}= ..`, but you \\\n+                                 really are doing `.. = ({op} ..)`\",\n+                                op = op\n+                            ),\n+                            None,\n+                            &format!(\"to remove this lint, use either `{op}=` or `= {op}`\", op = op),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Implementation of the `SUSPICIOUS_UNARY_OP_FORMATTING` lint.\n+fn check_unop(cx: &EarlyContext<'_>, expr: &Expr) {\n+    if_chain! {\n+        if let ExprKind::Binary(ref binop, ref lhs, ref rhs) = expr.kind;\n+        if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion();\n+        // span between BinOp LHS and RHS\n+        let binop_span = lhs.span.between(rhs.span);\n+        // if RHS is a UnOp\n+        if let ExprKind::Unary(op, ref un_rhs) = rhs.kind;\n+        // from UnOp operator to UnOp operand\n+        let unop_operand_span = rhs.span.until(un_rhs.span);\n+        if let Some(binop_snippet) = snippet_opt(cx, binop_span);\n+        if let Some(unop_operand_snippet) = snippet_opt(cx, unop_operand_span);\n+        let binop_str = BinOpKind::to_string(&binop.node);\n+        // no space after BinOp operator and space after UnOp operator\n+        if binop_snippet.ends_with(binop_str) && unop_operand_snippet.ends_with(' ');\n+        then {\n+            let unop_str = UnOp::to_string(op);\n+            let eqop_span = lhs.span.between(un_rhs.span);\n+            span_lint_and_help(\n+                cx,\n+                SUSPICIOUS_UNARY_OP_FORMATTING,\n+                eqop_span,\n+                &format!(\n+                    \"by not having a space between `{binop}` and `{unop}` it looks like \\\n+                     `{binop}{unop}` is a single operator\",\n+                    binop = binop_str,\n+                    unop = unop_str\n+                ),\n+                None,\n+                &format!(\n+                    \"put a space between `{binop}` and `{unop}` and remove the space after `{unop}`\",\n+                    binop = binop_str,\n+                    unop = unop_str\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+/// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for weird `else`.\n+fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n+    if_chain! {\n+        if let ExprKind::If(_, then, Some(else_)) = &expr.kind;\n+        if is_block(else_) || is_if(else_);\n+        if !differing_macro_contexts(then.span, else_.span);\n+        if !then.span.from_expansion() && !in_external_macro(cx.sess, expr.span);\n+\n+        // workaround for rust-lang/rust#43081\n+        if expr.span.lo().0 != 0 && expr.span.hi().0 != 0;\n+\n+        // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to\n+        // the \u201cif\u201d of the \u201celse if\u201d block (excluding)\n+        let else_span = then.span.between(else_.span);\n+\n+        // the snippet should look like \" else \\n    \" with maybe comments anywhere\n+        // it\u2019s bad when there is a \u2018\\n\u2019 after the \u201celse\u201d\n+        if let Some(else_snippet) = snippet_opt(cx, else_span);\n+        if let Some(else_pos) = else_snippet.find(\"else\");\n+        if else_snippet[else_pos..].contains('\\n');\n+        let else_desc = if is_if(else_) { \"if\" } else { \"{..}\" };\n+\n+        then {\n+            span_lint_and_note(\n+                cx,\n+                SUSPICIOUS_ELSE_FORMATTING,\n+                else_span,\n+                &format!(\"this is an `else {}` but the formatting might hide it\", else_desc),\n+                None,\n+                &format!(\n+                    \"to remove this lint, remove the `else` or remove the new line between \\\n+                     `else` and `{}`\",\n+                    else_desc,\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+#[must_use]\n+fn has_unary_equivalent(bin_op: BinOpKind) -> bool {\n+    // &, *, -\n+    bin_op == BinOpKind::And || bin_op == BinOpKind::Mul || bin_op == BinOpKind::Sub\n+}\n+\n+fn indentation(cx: &EarlyContext<'_>, span: Span) -> usize {\n+    cx.sess.source_map().lookup_char_pos(span.lo()).col.0\n+}\n+\n+/// Implementation of the `POSSIBLE_MISSING_COMMA` lint for array\n+fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n+    if let ExprKind::Array(ref array) = expr.kind {\n+        for element in array {\n+            if_chain! {\n+                if let ExprKind::Binary(ref op, ref lhs, _) = element.kind;\n+                if has_unary_equivalent(op.node) && !differing_macro_contexts(lhs.span, op.span);\n+                let space_span = lhs.span.between(op.span);\n+                if let Some(space_snippet) = snippet_opt(cx, space_span);\n+                let lint_span = lhs.span.with_lo(lhs.span.hi());\n+                if space_snippet.contains('\\n');\n+                if indentation(cx, op.span) <= indentation(cx, lhs.span);\n+                then {\n+                    span_lint_and_note(\n+                        cx,\n+                        POSSIBLE_MISSING_COMMA,\n+                        lint_span,\n+                        \"possibly missing a comma here\",\n+                        None,\n+                        \"to remove this lint, add a comma or write the expr in a single line\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n+    if !differing_macro_contexts(first.span, second.span)\n+        && !first.span.from_expansion()\n+        && is_if(first)\n+        && (is_block(second) || is_if(second))\n+    {\n+        // where the else would be\n+        let else_span = first.span.between(second.span);\n+\n+        if let Some(else_snippet) = snippet_opt(cx, else_span) {\n+            if !else_snippet.contains('\\n') {\n+                let (looks_like, next_thing) = if is_if(second) {\n+                    (\"an `else if`\", \"the second `if`\")\n+                } else {\n+                    (\"an `else {..}`\", \"the next block\")\n+                };\n+\n+                span_lint_and_note(\n+                    cx,\n+                    SUSPICIOUS_ELSE_FORMATTING,\n+                    else_span,\n+                    &format!(\"this looks like {} but the `else` is missing\", looks_like),\n+                    None,\n+                    &format!(\n+                        \"to remove this lint, add the missing `else` or add a new line before {}\",\n+                        next_thing,\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_block(expr: &Expr) -> bool {\n+    if let ExprKind::Block(..) = expr.kind {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Check if the expression is an `if` or `if let`\n+fn is_if(expr: &Expr) -> bool {\n+    if let ExprKind::If(..) = expr.kind {\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "c24a24733d7f3bfacd908e5a175eaac03a9cdda5", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,661 @@\n+use crate::utils::{\n+    attr_by_name, attrs::is_proc_macro, is_must_use_ty, is_trait_impl_item, iter_input_pats, match_def_path,\n+    must_use_attr, qpath_res, return_ty, snippet, snippet_opt, span_lint, span_lint_and_help, span_lint_and_then,\n+    trait_ref_of_method, type_is_unsafe_function,\n+};\n+use rustc_ast::ast::Attribute;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit;\n+use rustc_hir::{def::Res, def_id::DefId};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Span;\n+use rustc_target::spec::abi::Abi;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with too many parameters.\n+    ///\n+    /// **Why is this bad?** Functions with lots of parameters are considered bad\n+    /// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n+    /// grouping some parameters into a new type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # struct Color;\n+    /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub TOO_MANY_ARGUMENTS,\n+    complexity,\n+    \"functions with too many arguments\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with a large amount of lines.\n+    ///\n+    /// **Why is this bad?** Functions with a lot of lines are harder to understand\n+    /// due to having to look at a larger amount of code to understand what the\n+    /// function is doing. Consider splitting the body of the function into\n+    /// multiple functions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ``` rust\n+    /// fn im_too_long() {\n+    /// println!(\"\");\n+    /// // ... 100 more LoC\n+    /// println!(\"\");\n+    /// }\n+    /// ```\n+    pub TOO_MANY_LINES,\n+    pedantic,\n+    \"functions with too many lines\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that dereference raw pointer\n+    /// arguments but are not marked unsafe.\n+    ///\n+    /// **Why is this bad?** The function should probably be marked `unsafe`, since\n+    /// for an arbitrary raw pointer, there is no way of telling for sure if it is\n+    /// valid.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// * It does not check functions recursively so if the pointer is passed to a\n+    /// private non-`unsafe` function which does the dereferencing, the lint won't\n+    /// trigger.\n+    /// * It only checks for arguments whose type are raw pointers, not raw pointers\n+    /// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n+    /// `some_argument.get_raw_ptr()`).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// pub fn foo(x: *const u8) {\n+    ///     println!(\"{}\", unsafe { *x });\n+    /// }\n+    /// ```\n+    pub NOT_UNSAFE_PTR_ARG_DEREF,\n+    correctness,\n+    \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a [`#[must_use]`] attribute on\n+    /// unit-returning functions and methods.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** Unit values are useless. The attribute is likely\n+    /// a remnant of a refactoring that removed the return type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// #[must_use]\n+    /// fn useless() { }\n+    /// ```\n+    pub MUST_USE_UNIT,\n+    style,\n+    \"`#[must_use]` attribute on a unit-returning function / method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a [`#[must_use]`] attribute without\n+    /// further information on functions and methods that return a type already\n+    /// marked as `#[must_use]`.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** The attribute isn't needed. Not using the result\n+    /// will already be reported. Alternatively, one can add some text to the\n+    /// attribute to improve the lint message.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// #[must_use]\n+    /// fn double_must_use() -> Result<(), ()> {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    pub DOUBLE_MUST_USE,\n+    style,\n+    \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that have no\n+    /// [`#[must_use]`] attribute, but return something not already marked\n+    /// must-use, have no mutable arg and mutate no statics.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** Not bad at all, this lint just shows places where\n+    /// you could add the attribute.\n+    ///\n+    /// **Known problems:** The lint only checks the arguments for mutable\n+    /// types without looking if they are actually changed. On the other hand,\n+    /// it also ignores a broad range of potentially interesting side effects,\n+    /// because we cannot decide whether the programmer intends the function to\n+    /// be called for the side effect or the result. Expect many false\n+    /// positives. At least we don't lint if the result type is unit or already\n+    /// `#[must_use]`.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// // this could be annotated with `#[must_use]`.\n+    /// fn id<T>(t: T) -> T { t }\n+    /// ```\n+    pub MUST_USE_CANDIDATE,\n+    pedantic,\n+    \"function or method that could take a `#[must_use]` attribute\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Functions {\n+    threshold: u64,\n+    max_lines: u64,\n+}\n+\n+impl Functions {\n+    pub fn new(threshold: u64, max_lines: u64) -> Self {\n+        Self { threshold, max_lines }\n+    }\n+}\n+\n+impl_lint_pass!(Functions => [\n+    TOO_MANY_ARGUMENTS,\n+    TOO_MANY_LINES,\n+    NOT_UNSAFE_PTR_ARG_DEREF,\n+    MUST_USE_UNIT,\n+    DOUBLE_MUST_USE,\n+    MUST_USE_CANDIDATE,\n+]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: intravisit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl<'_>,\n+        body: &'tcx hir::Body<'_>,\n+        span: Span,\n+        hir_id: hir::HirId,\n+    ) {\n+        let unsafety = match kind {\n+            intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _, _) => unsafety,\n+            intravisit::FnKind::Method(_, sig, _, _) => sig.header.unsafety,\n+            intravisit::FnKind::Closure(_) => return,\n+        };\n+\n+        // don't warn for implementations, it's not their fault\n+        if !is_trait_impl_item(cx, hir_id) {\n+            // don't lint extern functions decls, it's not their fault either\n+            match kind {\n+                intravisit::FnKind::Method(\n+                    _,\n+                    &hir::FnSig {\n+                        header: hir::FnHeader { abi: Abi::Rust, .. },\n+                        ..\n+                    },\n+                    _,\n+                    _,\n+                )\n+                | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _, _) => {\n+                    self.check_arg_number(cx, decl, span.with_hi(decl.output.span().hi()))\n+                },\n+                _ => {},\n+            }\n+        }\n+\n+        Self::check_raw_ptr(cx, unsafety, decl, body, hir_id);\n+        self.check_line_number(cx, span, body);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n+        let attr = must_use_attr(&item.attrs);\n+        if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+            if let Some(attr) = attr {\n+                let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+                return;\n+            }\n+            if cx.access_levels.is_exported(item.hir_id)\n+                && !is_proc_macro(&item.attrs)\n+                && attr_by_name(&item.attrs, \"no_mangle\").is_none()\n+            {\n+                check_must_use_candidate(\n+                    cx,\n+                    &sig.decl,\n+                    cx.tcx.hir().body(*body_id),\n+                    item.span,\n+                    item.hir_id,\n+                    item.span.with_hi(sig.decl.output.span().hi()),\n+                    \"this function could have a `#[must_use]` attribute\",\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+        if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n+            let attr = must_use_attr(&item.attrs);\n+            if let Some(attr) = attr {\n+                let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+            } else if cx.access_levels.is_exported(item.hir_id)\n+                && !is_proc_macro(&item.attrs)\n+                && trait_ref_of_method(cx, item.hir_id).is_none()\n+            {\n+                check_must_use_candidate(\n+                    cx,\n+                    &sig.decl,\n+                    cx.tcx.hir().body(*body_id),\n+                    item.span,\n+                    item.hir_id,\n+                    item.span.with_hi(sig.decl.output.span().hi()),\n+                    \"this method could have a `#[must_use]` attribute\",\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+        if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n+            // don't lint extern functions decls, it's not their fault\n+            if sig.header.abi == Abi::Rust {\n+                self.check_arg_number(cx, &sig.decl, item.span.with_hi(sig.decl.output.span().hi()));\n+            }\n+\n+            let attr = must_use_attr(&item.attrs);\n+            if let Some(attr) = attr {\n+                let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+            }\n+            if let hir::TraitFn::Provided(eid) = *eid {\n+                let body = cx.tcx.hir().body(eid);\n+                Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n+\n+                if attr.is_none() && cx.access_levels.is_exported(item.hir_id) && !is_proc_macro(&item.attrs) {\n+                    check_must_use_candidate(\n+                        cx,\n+                        &sig.decl,\n+                        body,\n+                        item.span,\n+                        item.hir_id,\n+                        item.span.with_hi(sig.decl.output.span().hi()),\n+                        \"this method could have a `#[must_use]` attribute\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Functions {\n+    fn check_arg_number(self, cx: &LateContext<'_, '_>, decl: &hir::FnDecl<'_>, fn_span: Span) {\n+        let args = decl.inputs.len() as u64;\n+        if args > self.threshold {\n+            span_lint(\n+                cx,\n+                TOO_MANY_ARGUMENTS,\n+                fn_span,\n+                &format!(\"this function has too many arguments ({}/{})\", args, self.threshold),\n+            );\n+        }\n+    }\n+\n+    fn check_line_number(self, cx: &LateContext<'_, '_>, span: Span, body: &'tcx hir::Body<'_>) {\n+        if in_external_macro(cx.sess(), span) {\n+            return;\n+        }\n+\n+        let code_snippet = snippet(cx, body.value.span, \"..\");\n+        let mut line_count: u64 = 0;\n+        let mut in_comment = false;\n+        let mut code_in_line;\n+\n+        // Skip the surrounding function decl.\n+        let start_brace_idx = code_snippet.find('{').map_or(0, |i| i + 1);\n+        let end_brace_idx = code_snippet.rfind('}').unwrap_or_else(|| code_snippet.len());\n+        let function_lines = code_snippet[start_brace_idx..end_brace_idx].lines();\n+\n+        for mut line in function_lines {\n+            code_in_line = false;\n+            loop {\n+                line = line.trim_start();\n+                if line.is_empty() {\n+                    break;\n+                }\n+                if in_comment {\n+                    match line.find(\"*/\") {\n+                        Some(i) => {\n+                            line = &line[i + 2..];\n+                            in_comment = false;\n+                            continue;\n+                        },\n+                        None => break,\n+                    }\n+                } else {\n+                    let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n+                    let single_idx = line.find(\"//\").unwrap_or_else(|| line.len());\n+                    code_in_line |= multi_idx > 0 && single_idx > 0;\n+                    // Implies multi_idx is below line.len()\n+                    if multi_idx < single_idx {\n+                        line = &line[multi_idx + 2..];\n+                        in_comment = true;\n+                        continue;\n+                    }\n+                    break;\n+                }\n+            }\n+            if code_in_line {\n+                line_count += 1;\n+            }\n+        }\n+\n+        if line_count > self.max_lines {\n+            span_lint(cx, TOO_MANY_LINES, span, \"This function has a large number of lines.\")\n+        }\n+    }\n+\n+    fn check_raw_ptr(\n+        cx: &LateContext<'a, 'tcx>,\n+        unsafety: hir::Unsafety,\n+        decl: &'tcx hir::FnDecl<'_>,\n+        body: &'tcx hir::Body<'_>,\n+        hir_id: hir::HirId,\n+    ) {\n+        let expr = &body.value;\n+        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n+            let raw_ptrs = iter_input_pats(decl, body)\n+                .zip(decl.inputs.iter())\n+                .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n+                .collect::<FxHashSet<_>>();\n+\n+            if !raw_ptrs.is_empty() {\n+                let tables = cx.tcx.body_tables(body.id());\n+                let mut v = DerefVisitor {\n+                    cx,\n+                    ptrs: raw_ptrs,\n+                    tables,\n+                };\n+\n+                intravisit::walk_expr(&mut v, expr);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_needless_must_use(\n+    cx: &LateContext<'_, '_>,\n+    decl: &hir::FnDecl<'_>,\n+    item_id: hir::HirId,\n+    item_span: Span,\n+    fn_header_span: Span,\n+    attr: &Attribute,\n+) {\n+    if in_external_macro(cx.sess(), item_span) {\n+        return;\n+    }\n+    if returns_unit(decl) {\n+        span_lint_and_then(\n+            cx,\n+            MUST_USE_UNIT,\n+            fn_header_span,\n+            \"this unit-returning function has a `#[must_use]` attribute\",\n+            |diag| {\n+                diag.span_suggestion(\n+                    attr.span,\n+                    \"remove the attribute\",\n+                    \"\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        );\n+    } else if !attr.is_value_str() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n+        span_lint_and_help(\n+            cx,\n+            DOUBLE_MUST_USE,\n+            fn_header_span,\n+            \"this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\",\n+            None,\n+            \"either add some descriptive text or remove the attribute\",\n+        );\n+    }\n+}\n+\n+fn check_must_use_candidate<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: &'tcx hir::FnDecl<'_>,\n+    body: &'tcx hir::Body<'_>,\n+    item_span: Span,\n+    item_id: hir::HirId,\n+    fn_span: Span,\n+    msg: &str,\n+) {\n+    if has_mutable_arg(cx, body)\n+        || mutates_static(cx, body)\n+        || in_external_macro(cx.sess(), item_span)\n+        || returns_unit(decl)\n+        || !cx.access_levels.is_exported(item_id)\n+        || is_must_use_ty(cx, return_ty(cx, item_id))\n+    {\n+        return;\n+    }\n+    span_lint_and_then(cx, MUST_USE_CANDIDATE, fn_span, msg, |diag| {\n+        if let Some(snippet) = snippet_opt(cx, fn_span) {\n+            diag.span_suggestion(\n+                fn_span,\n+                \"add the attribute\",\n+                format!(\"#[must_use] {}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    });\n+}\n+\n+fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n+    match decl.output {\n+        hir::FnRetTy::DefaultReturn(_) => true,\n+        hir::FnRetTy::Return(ref ty) => match ty.kind {\n+            hir::TyKind::Tup(ref tys) => tys.is_empty(),\n+            hir::TyKind::Never => true,\n+            _ => false,\n+        },\n+    }\n+}\n+\n+fn has_mutable_arg(cx: &LateContext<'_, '_>, body: &hir::Body<'_>) -> bool {\n+    let mut tys = FxHashSet::default();\n+    body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n+}\n+\n+fn is_mutable_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n+    if let hir::PatKind::Wild = pat.kind {\n+        return false; // ignore `_` patterns\n+    }\n+    let def_id = pat.hir_id.owner.to_def_id();\n+    if cx.tcx.has_typeck_tables(def_id) {\n+        is_mutable_ty(\n+            cx,\n+            &cx.tcx.typeck_tables_of(def_id.expect_local()).pat_ty(pat),\n+            pat.span,\n+            tys,\n+        )\n+    } else {\n+        false\n+    }\n+}\n+\n+static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n+\n+fn is_mutable_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n+    match ty.kind {\n+        // primitive types are never mutable\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n+        ty::Adt(ref adt, ref substs) => {\n+            tys.insert(adt.did) && !ty.is_freeze(cx.tcx, cx.param_env, span)\n+                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n+                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n+        },\n+        ty::Tuple(ref substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n+        ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n+            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n+        },\n+        // calling something constitutes a side effect, so return true on all callables\n+        // also never calls need not be used, so return true for them, too\n+        _ => true,\n+    }\n+}\n+\n+fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n+        Some(id)\n+    } else {\n+        None\n+    }\n+}\n+\n+struct DerefVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    ptrs: FxHashSet<hir::HirId>,\n+    tables: &'a ty::TypeckTables<'tcx>,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        match expr.kind {\n+            hir::ExprKind::Call(ref f, args) => {\n+                let ty = self.tables.expr_ty(f);\n+\n+                if type_is_unsafe_function(self.cx, ty) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::MethodCall(_, _, args) => {\n+                let def_id = self.tables.type_dependent_def_id(expr.hir_id).unwrap();\n+                let base_type = self.cx.tcx.type_of(def_id);\n+\n+                if type_is_unsafe_function(self.cx, base_type) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::Unary(hir::UnOp::UnDeref, ref ptr) => self.check_arg(ptr),\n+            _ => (),\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n+    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n+        if let hir::ExprKind::Path(ref qpath) = ptr.kind {\n+            if let Res::Local(id) = qpath_res(self.cx, qpath, ptr.hir_id) {\n+                if self.ptrs.contains(&id) {\n+                    span_lint(\n+                        self.cx,\n+                        NOT_UNSAFE_PTR_ARG_DEREF,\n+                        ptr.span,\n+                        \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct StaticMutVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    mutates_static: bool,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n+\n+        if self.mutates_static {\n+            return;\n+        }\n+        match expr.kind {\n+            Call(_, args) | MethodCall(_, _, args) => {\n+                let mut tys = FxHashSet::default();\n+                for arg in args {\n+                    let def_id = arg.hir_id.owner.to_def_id();\n+                    if self.cx.tcx.has_typeck_tables(def_id)\n+                        && is_mutable_ty(\n+                            self.cx,\n+                            self.cx.tcx.typeck_tables_of(def_id.expect_local()).expr_ty(arg),\n+                            arg.span,\n+                            &mut tys,\n+                        )\n+                        && is_mutated_static(self.cx, arg)\n+                    {\n+                        self.mutates_static = true;\n+                        return;\n+                    }\n+                    tys.clear();\n+                }\n+            },\n+            Assign(ref target, ..) | AssignOp(_, ref target, _) | AddrOf(_, hir::Mutability::Mut, ref target) => {\n+                self.mutates_static |= is_mutated_static(self.cx, target)\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+fn is_mutated_static(cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) -> bool {\n+    use hir::ExprKind::{Field, Index, Path};\n+\n+    match e.kind {\n+        Path(ref qpath) => {\n+            if let Res::Local(_) = qpath_res(cx, qpath, e.hir_id) {\n+                false\n+            } else {\n+                true\n+            }\n+        },\n+        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(cx, inner),\n+        _ => false,\n+    }\n+}\n+\n+fn mutates_static<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+    let mut v = StaticMutVisitor {\n+        cx,\n+        mutates_static: false,\n+    };\n+    intravisit::walk_expr(&mut v, &body.value);\n+    v.mutates_static\n+}"}, {"sha": "704a95ec0a0909a50efc12f84fbec8f7d1ec54de", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,110 @@\n+use crate::utils;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, FnDecl, HirId};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{Opaque, Predicate::Trait, ToPolyTraitRef};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, Span};\n+use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, FulfillmentError, TraitEngine};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** This lint requires Future implementations returned from\n+    /// functions and methods to implement the `Send` marker trait. It is mostly\n+    /// used by library authors (public and internal) that target an audience where\n+    /// multithreaded executors are likely to be used for running these Futures.\n+    ///\n+    /// **Why is this bad?** A Future implementation captures some state that it\n+    /// needs to eventually produce its final value. When targeting a multithreaded\n+    /// executor (which is the norm on non-embedded devices) this means that this\n+    /// state may need to be transported to other threads, in other words the\n+    /// whole Future needs to implement the `Send` marker trait. If it does not,\n+    /// then the resulting Future cannot be submitted to a thread pool in the\n+    /// end user\u2019s code.\n+    ///\n+    /// Especially for generic functions it can be confusing to leave the\n+    /// discovery of this problem to the end user: the reported error location\n+    /// will be far from its cause and can in many cases not even be fixed without\n+    /// modifying the library where the offending Future implementation is\n+    /// produced.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// async fn not_send(bytes: std::rc::Rc<[u8]>) {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// async fn is_send(bytes: std::sync::Arc<[u8]>) {}\n+    /// ```\n+    pub FUTURE_NOT_SEND,\n+    nursery,\n+    \"public Futures must be Send\"\n+}\n+\n+declare_lint_pass!(FutureNotSend => [FUTURE_NOT_SEND]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FutureNotSend {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'tcx>,\n+        _: &'tcx Body<'tcx>,\n+        _: Span,\n+        hir_id: HirId,\n+    ) {\n+        if let FnKind::Closure(_) = kind {\n+            return;\n+        }\n+        let ret_ty = utils::return_ty(cx, hir_id);\n+        if let Opaque(id, subst) = ret_ty.kind {\n+            let preds = cx.tcx.predicates_of(id).instantiate(cx.tcx, subst);\n+            let mut is_future = false;\n+            for p in preds.predicates {\n+                if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n+                    if Some(trait_ref.def_id()) == cx.tcx.lang_items().future_trait() {\n+                        is_future = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            if is_future {\n+                let send_trait = cx.tcx.get_diagnostic_item(sym::send_trait).unwrap();\n+                let span = decl.output.span();\n+                let send_result = cx.tcx.infer_ctxt().enter(|infcx| {\n+                    let cause = traits::ObligationCause::misc(span, hir_id);\n+                    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                    fulfillment_cx.register_bound(&infcx, cx.param_env, ret_ty, send_trait, cause);\n+                    fulfillment_cx.select_all_or_error(&infcx)\n+                });\n+                if let Err(send_errors) = send_result {\n+                    utils::span_lint_and_then(\n+                        cx,\n+                        FUTURE_NOT_SEND,\n+                        span,\n+                        \"future cannot be sent between threads safely\",\n+                        |db| {\n+                            cx.tcx.infer_ctxt().enter(|infcx| {\n+                                for FulfillmentError { obligation, .. } in send_errors {\n+                                    infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n+                                    if let Trait(trait_pred, _) = obligation.predicate {\n+                                        let trait_ref = trait_pred.to_poly_trait_ref();\n+                                        db.note(&*format!(\n+                                            \"`{}` doesn't implement `{}`\",\n+                                            trait_ref.self_ty(),\n+                                            trait_ref.print_only_trait_path(),\n+                                        ));\n+                                    }\n+                                }\n+                            })\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "c32e0a2290d12c10caa16f6f6e18223bd56fe421", "filename": "src/tools/clippy/clippy_lints/src/get_last_with_len.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,103 @@\n+//! lint on using `x.get(x.len() - 1)` instead of `x.last()`\n+\n+use crate::utils::{is_type_diagnostic_item, snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for using `x.get(x.len() - 1)` instead of\n+    /// `x.last()`.\n+    ///\n+    /// **Why is this bad?** Using `x.last()` is easier to read and has the same\n+    /// result.\n+    ///\n+    /// Note that using `x[x.len() - 1]` is semantically different from\n+    /// `x.last()`.  Indexing into the array will panic on out-of-bounds\n+    /// accesses, while `x.get()` and `x.last()` will return `None`.\n+    ///\n+    /// There is another lint (get_unwrap) that covers the case of using\n+    /// `x.get(index).unwrap()` instead of `x[index]`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let x = vec![2, 3, 5];\n+    /// let last_element = x.get(x.len() - 1);\n+    ///\n+    /// // Good\n+    /// let x = vec![2, 3, 5];\n+    /// let last_element = x.last();\n+    /// ```\n+    pub GET_LAST_WITH_LEN,\n+    complexity,\n+    \"Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler\"\n+}\n+\n+declare_lint_pass!(GetLastWithLen => [GET_LAST_WITH_LEN]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for GetLastWithLen {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            // Is a method call\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n+\n+            // Method name is \"get\"\n+            if path.ident.name == sym!(get);\n+\n+            // Argument 0 (the struct we're calling the method on) is a vector\n+            if let Some(struct_calling_on) = args.get(0);\n+            let struct_ty = cx.tables.expr_ty(struct_calling_on);\n+            if is_type_diagnostic_item(cx, struct_ty, sym!(vec_type));\n+\n+            // Argument to \"get\" is a subtraction\n+            if let Some(get_index_arg) = args.get(1);\n+            if let ExprKind::Binary(\n+                Spanned {\n+                    node: BinOpKind::Sub,\n+                    ..\n+                },\n+                lhs,\n+                rhs,\n+            ) = &get_index_arg.kind;\n+\n+            // LHS of subtraction is \"x.len()\"\n+            if let ExprKind::MethodCall(arg_lhs_path, _, lhs_args) = &lhs.kind;\n+            if arg_lhs_path.ident.name == sym!(len);\n+            if let Some(arg_lhs_struct) = lhs_args.get(0);\n+\n+            // The two vectors referenced (x in x.get(...) and in x.len())\n+            if SpanlessEq::new(cx).eq_expr(struct_calling_on, arg_lhs_struct);\n+\n+            // RHS of subtraction is 1\n+            if let ExprKind::Lit(rhs_lit) = &rhs.kind;\n+            if let LitKind::Int(1, ..) = rhs_lit.node;\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let vec_name = snippet_with_applicability(\n+                    cx,\n+                    struct_calling_on.span, \"vec\",\n+                    &mut applicability,\n+                );\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    GET_LAST_WITH_LEN,\n+                    expr.span,\n+                    &format!(\"accessing last element with `{0}.get({0}.len() - 1)`\", vec_name),\n+                    \"try\",\n+                    format!(\"{}.last()\", vec_name),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "33a9478f058830adedb7cfea69f26c5f8c50f669", "filename": "src/tools/clippy/clippy_lints/src/identity_conversion.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,124 @@\n+use crate::utils::{\n+    match_def_path, match_trait_method, paths, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_sugg,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for always-identical `Into`/`From`/`IntoIter` conversions.\n+    ///\n+    /// **Why is this bad?** Redundant code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // format!() returns a `String`\n+    /// let s: String = format!(\"hello\").into();\n+    /// ```\n+    pub IDENTITY_CONVERSION,\n+    complexity,\n+    \"using always-identical `Into`/`From`/`IntoIter` conversions\"\n+}\n+\n+#[derive(Default)]\n+pub struct IdentityConversion {\n+    try_desugar_arm: Vec<HirId>,\n+}\n+\n+impl_lint_pass!(IdentityConversion => [IDENTITY_CONVERSION]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        if e.span.from_expansion() {\n+            return;\n+        }\n+\n+        if Some(&e.hir_id) == self.try_desugar_arm.last() {\n+            return;\n+        }\n+\n+        match e.kind {\n+            ExprKind::Match(_, ref arms, MatchSource::TryDesugar) => {\n+                let e = match arms[0].body.kind {\n+                    ExprKind::Ret(Some(ref e)) | ExprKind::Break(_, Some(ref e)) => e,\n+                    _ => return,\n+                };\n+                if let ExprKind::Call(_, ref args) = e.kind {\n+                    self.try_desugar_arm.push(args[0].hir_id);\n+                }\n+            },\n+\n+            ExprKind::MethodCall(ref name, .., ref args) => {\n+                if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n+                    let a = cx.tables.expr_ty(e);\n+                    let b = cx.tables.expr_ty(&args[0]);\n+                    if same_tys(cx, a, b) {\n+                        let sugg = snippet_with_macro_callsite(cx, args[0].span, \"<expr>\").to_string();\n+\n+                        span_lint_and_sugg(\n+                            cx,\n+                            IDENTITY_CONVERSION,\n+                            e.span,\n+                            \"identical conversion\",\n+                            \"consider removing `.into()`\",\n+                            sugg,\n+                            Applicability::MachineApplicable, // snippet\n+                        );\n+                    }\n+                }\n+                if match_trait_method(cx, e, &paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n+                    let a = cx.tables.expr_ty(e);\n+                    let b = cx.tables.expr_ty(&args[0]);\n+                    if same_tys(cx, a, b) {\n+                        let sugg = snippet(cx, args[0].span, \"<expr>\").into_owned();\n+                        span_lint_and_sugg(\n+                            cx,\n+                            IDENTITY_CONVERSION,\n+                            e.span,\n+                            \"identical conversion\",\n+                            \"consider removing `.into_iter()`\",\n+                            sugg,\n+                            Applicability::MachineApplicable, // snippet\n+                        );\n+                    }\n+                }\n+            },\n+\n+            ExprKind::Call(ref path, ref args) => {\n+                if let ExprKind::Path(ref qpath) = path.kind {\n+                    if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id() {\n+                        if match_def_path(cx, def_id, &paths::FROM_FROM) {\n+                            let a = cx.tables.expr_ty(e);\n+                            let b = cx.tables.expr_ty(&args[0]);\n+                            if same_tys(cx, a, b) {\n+                                let sugg = snippet(cx, args[0].span.source_callsite(), \"<expr>\").into_owned();\n+                                let sugg_msg =\n+                                    format!(\"consider removing `{}()`\", snippet(cx, path.span, \"From::from\"));\n+                                span_lint_and_sugg(\n+                                    cx,\n+                                    IDENTITY_CONVERSION,\n+                                    e.span,\n+                                    \"identical conversion\",\n+                                    &sugg_msg,\n+                                    sugg,\n+                                    Applicability::MachineApplicable, // snippet\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            },\n+\n+            _ => {},\n+        }\n+    }\n+\n+    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        if Some(&e.hir_id) == self.try_desugar_arm.last() {\n+            self.try_desugar_arm.pop();\n+        }\n+    }\n+}"}, {"sha": "088e4ab1921fb8a31f0d38397521dbb1cbeb2486", "filename": "src/tools/clippy/clippy_lints/src/identity_op.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,82 @@\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+use crate::consts::{constant_simple, Constant};\n+use crate::utils::{clip, snippet, span_lint, unsext};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for identity operations, e.g., `x + 0`.\n+    ///\n+    /// **Why is this bad?** This code can be removed without changing the\n+    /// meaning. So it just obscures what's going on. Delete it mercilessly.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let x = 1;\n+    /// x / 1 + 0 * 1 - 0 | 0;\n+    /// ```\n+    pub IDENTITY_OP,\n+    complexity,\n+    \"using identity operations, e.g., `x + 0` or `y / 1`\"\n+}\n+\n+declare_lint_pass!(IdentityOp => [IDENTITY_OP]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n+        if e.span.from_expansion() {\n+            return;\n+        }\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.kind {\n+            match cmp.node {\n+                BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n+                    check(cx, left, 0, e.span, right.span);\n+                    check(cx, right, 0, e.span, left.span);\n+                },\n+                BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => check(cx, right, 0, e.span, left.span),\n+                BinOpKind::Mul => {\n+                    check(cx, left, 1, e.span, right.span);\n+                    check(cx, right, 1, e.span, left.span);\n+                },\n+                BinOpKind::Div => check(cx, right, 1, e.span, left.span),\n+                BinOpKind::BitAnd => {\n+                    check(cx, left, -1, e.span, right.span);\n+                    check(cx, right, -1, e.span, left.span);\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+#[allow(clippy::cast_possible_wrap)]\n+fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n+        let check = match cx.tables.expr_ty(e).kind {\n+            ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n+            ty::Uint(uty) => clip(cx.tcx, !0, uty),\n+            _ => return,\n+        };\n+        if match m {\n+            0 => v == 0,\n+            -1 => v == check,\n+            1 => v == 1,\n+            _ => unreachable!(),\n+        } {\n+            span_lint(\n+                cx,\n+                IDENTITY_OP,\n+                span,\n+                &format!(\n+                    \"the operation is ineffective. Consider reducing it to `{}`\",\n+                    snippet(cx, arg, \"..\")\n+                ),\n+            );\n+        }\n+    }\n+}"}, {"sha": "ae92a96d16347646e0b5b7cd28c54cc132399d4a", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,160 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_hir::intravisit::{self as visit, NestedVisitorMap, Visitor};\n+use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `Mutex::lock` calls in `if let` expression\n+    /// with lock calls in any of the else blocks.\n+    ///\n+    /// **Why is this bad?** The Mutex lock remains held for the whole\n+    /// `if let ... else` block and deadlocks.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// if let Ok(thing) = mutex.lock() {\n+    ///     do_thing();\n+    /// } else {\n+    ///     mutex.lock();\n+    /// }\n+    /// ```\n+    /// Should be written\n+    /// ```rust,ignore\n+    /// let locked = mutex.lock();\n+    /// if let Ok(thing) = locked {\n+    ///     do_thing(thing);\n+    /// } else {\n+    ///     use_locked(locked);\n+    /// }\n+    /// ```\n+    pub IF_LET_MUTEX,\n+    correctness,\n+    \"locking a `Mutex` in an `if let` block can cause deadlocks\"\n+}\n+\n+declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n+\n+impl LateLintPass<'_, '_> for IfLetMutex {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, ex: &'_ Expr<'_>) {\n+        let mut arm_visit = ArmVisitor {\n+            mutex_lock_called: false,\n+            found_mutex: None,\n+            cx,\n+        };\n+        let mut op_visit = OppVisitor {\n+            mutex_lock_called: false,\n+            found_mutex: None,\n+            cx,\n+        };\n+        if let ExprKind::Match(\n+            ref op,\n+            ref arms,\n+            MatchSource::IfLetDesugar {\n+                contains_else_clause: true,\n+            },\n+        ) = ex.kind\n+        {\n+            op_visit.visit_expr(op);\n+            if op_visit.mutex_lock_called {\n+                for arm in *arms {\n+                    arm_visit.visit_arm(arm);\n+                }\n+\n+                if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n+                    span_lint_and_help(\n+                        cx,\n+                        IF_LET_MUTEX,\n+                        ex.span,\n+                        \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n+                        None,\n+                        \"move the lock call outside of the `if let ...` expression\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Checks if `Mutex::lock` is called in the `if let _ = expr.\n+pub struct OppVisitor<'tcx, 'l> {\n+    mutex_lock_called: bool,\n+    found_mutex: Option<&'tcx Expr<'tcx>>,\n+    cx: &'tcx LateContext<'tcx, 'l>,\n+}\n+\n+impl<'tcx, 'l> Visitor<'tcx> for OppVisitor<'tcx, 'l> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let Some(mutex) = is_mutex_lock_call(self.cx, expr);\n+            then {\n+                self.found_mutex = Some(mutex);\n+                self.mutex_lock_called = true;\n+                return;\n+            }\n+        }\n+        visit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Checks if `Mutex::lock` is called in any of the branches.\n+pub struct ArmVisitor<'tcx, 'l> {\n+    mutex_lock_called: bool,\n+    found_mutex: Option<&'tcx Expr<'tcx>>,\n+    cx: &'tcx LateContext<'tcx, 'l>,\n+}\n+\n+impl<'tcx, 'l> Visitor<'tcx> for ArmVisitor<'tcx, 'l> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if_chain! {\n+            if let Some(mutex) = is_mutex_lock_call(self.cx, expr);\n+            then {\n+                self.found_mutex = Some(mutex);\n+                self.mutex_lock_called = true;\n+                return;\n+            }\n+        }\n+        visit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n+    fn same_mutex(&self, cx: &LateContext<'_, '_>, op_mutex: &Expr<'_>) -> bool {\n+        if let Some(arm_mutex) = self.found_mutex {\n+            SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+fn is_mutex_lock_call<'a>(cx: &LateContext<'a, '_>, expr: &'a Expr<'_>) -> Option<&'a Expr<'a>> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(path, _span, args) = &expr.kind;\n+        if path.ident.to_string() == \"lock\";\n+        let ty = cx.tables.expr_ty(&args[0]);\n+        if is_type_diagnostic_item(cx, ty, sym!(mutex_type));\n+        then {\n+            Some(&args[0])\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "9b13f7609247a26f122252b9d97ac34dbd1c8b08", "filename": "src/tools/clippy/clippy_lints/src/if_let_some_result.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,72 @@\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, MatchSource, PatKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:*** Checks for unnecessary `ok()` in if let.\n+    ///\n+    /// **Why is this bad?** Calling `ok()` in if let is unnecessary, instead match\n+    /// on `Ok(pat)`\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for i in iter {\n+    ///     if let Some(value) = i.parse().ok() {\n+    ///         vec.push(value)\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Could be written:\n+    ///\n+    /// ```ignore\n+    /// for i in iter {\n+    ///     if let Ok(value) = i.parse() {\n+    ///         vec.push(value)\n+    ///     }\n+    /// }\n+    /// ```\n+    pub IF_LET_SOME_RESULT,\n+    style,\n+    \"usage of `ok()` in `if let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead\"\n+}\n+\n+declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! { //begin checking variables\n+            if let ExprKind::Match(ref op, ref body, source) = expr.kind; //test if expr is a match\n+            if let MatchSource::IfLetDesugar { .. } = source; //test if it is an If Let\n+            if let ExprKind::MethodCall(_, ok_span, ref result_types) = op.kind; //check is expr.ok() has type Result<T,E>.ok()\n+            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n+            if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n+            if is_type_diagnostic_item(cx, cx.tables.expr_ty(&result_types[0]), sym!(result_type));\n+            if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n+                let trimmed_ok = snippet_with_applicability(cx, op.span.until(ok_span), \"\", &mut applicability);\n+                let sugg = format!(\n+                    \"if let Ok({}) = {}\",\n+                    some_expr_string,\n+                    trimmed_ok.trim().trim_end_matches('.'),\n+                );\n+                span_lint_and_sugg(\n+                    cx,\n+                    IF_LET_SOME_RESULT,\n+                    expr.span.with_hi(op.span.hi()),\n+                    \"Matching on `Some` with `ok()` is redundant\",\n+                    &format!(\"Consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n+                    sugg,\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "c11e291f98e4b41766dbf22c8940d8f9fff3b74c", "filename": "src/tools/clippy/clippy_lints/src/if_not_else.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,83 @@\n+//! lint on if branches that could be swapped so no `!` operation is necessary\n+//! on the condition\n+\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::span_lint_and_help;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n+    /// else branch.\n+    ///\n+    /// **Why is this bad?** Negations reduce the readability of statements.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let v: Vec<usize> = vec![];\n+    /// # fn a() {}\n+    /// # fn b() {}\n+    /// if !v.is_empty() {\n+    ///     a()\n+    /// } else {\n+    ///     b()\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// # let v: Vec<usize> = vec![];\n+    /// # fn a() {}\n+    /// # fn b() {}\n+    /// if v.is_empty() {\n+    ///     b()\n+    /// } else {\n+    ///     a()\n+    /// }\n+    /// ```\n+    pub IF_NOT_ELSE,\n+    pedantic,\n+    \"`if` branches that could be swapped so no negation operation is necessary on the condition\"\n+}\n+\n+declare_lint_pass!(IfNotElse => [IF_NOT_ELSE]);\n+\n+impl EarlyLintPass for IfNotElse {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n+        if in_external_macro(cx.sess(), item.span) {\n+            return;\n+        }\n+        if let ExprKind::If(ref cond, _, Some(ref els)) = item.kind {\n+            if let ExprKind::Block(..) = els.kind {\n+                match cond.kind {\n+                    ExprKind::Unary(UnOp::Not, _) => {\n+                        span_lint_and_help(\n+                            cx,\n+                            IF_NOT_ELSE,\n+                            item.span,\n+                            \"Unnecessary boolean `not` operation\",\n+                            None,\n+                            \"remove the `!` and swap the blocks of the `if`/`else`\",\n+                        );\n+                    },\n+                    ExprKind::Binary(ref kind, _, _) if kind.node == BinOpKind::Ne => {\n+                        span_lint_and_help(\n+                            cx,\n+                            IF_NOT_ELSE,\n+                            item.span,\n+                            \"Unnecessary `!=` operation\",\n+                            None,\n+                            \"change to `==` and swap the blocks of the `if`/`else`\",\n+                        );\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "c4308fd26a3021092e9f653a016461e7904760c8", "filename": "src/tools/clippy/clippy_lints/src/implicit_return.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,150 @@\n+use crate::utils::{\n+    fn_has_unsatisfiable_preds, match_def_path,\n+    paths::{BEGIN_PANIC, BEGIN_PANIC_FMT},\n+    snippet_opt, span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId, MatchSource, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for missing return statements at the end of a block.\n+    ///\n+    /// **Why is this bad?** Actually omitting the return keyword is idiomatic Rust code. Programmers\n+    /// coming from other languages might prefer the expressiveness of `return`. It's possible to miss\n+    /// the last returning statement because the only difference is a missing `;`. Especially in bigger\n+    /// code with multiple return paths having a `return` keyword makes it easier to find the\n+    /// corresponding statements.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     x\n+    /// }\n+    /// ```\n+    /// add return\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     return x;\n+    /// }\n+    /// ```\n+    pub IMPLICIT_RETURN,\n+    restriction,\n+    \"use a return statement like `return expr` instead of an expression\"\n+}\n+\n+declare_lint_pass!(ImplicitReturn => [IMPLICIT_RETURN]);\n+\n+static LINT_BREAK: &str = \"change `break` to `return` as shown\";\n+static LINT_RETURN: &str = \"add `return` as shown\";\n+\n+fn lint(cx: &LateContext<'_, '_>, outer_span: Span, inner_span: Span, msg: &str) {\n+    let outer_span = outer_span.source_callsite();\n+    let inner_span = inner_span.source_callsite();\n+\n+    span_lint_and_then(cx, IMPLICIT_RETURN, outer_span, \"missing `return` statement\", |diag| {\n+        if let Some(snippet) = snippet_opt(cx, inner_span) {\n+            diag.span_suggestion(\n+                outer_span,\n+                msg,\n+                format!(\"return {}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    });\n+}\n+\n+fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    match expr.kind {\n+        // loops could be using `break` instead of `return`\n+        ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n+            if let Some(expr) = &block.expr {\n+                expr_match(cx, expr);\n+            }\n+            // only needed in the case of `break` with `;` at the end\n+            else if let Some(stmt) = block.stmts.last() {\n+                if_chain! {\n+                    if let StmtKind::Semi(expr, ..) = &stmt.kind;\n+                    // make sure it's a break, otherwise we want to skip\n+                    if let ExprKind::Break(.., break_expr) = &expr.kind;\n+                    if let Some(break_expr) = break_expr;\n+                    then {\n+                            lint(cx, expr.span, break_expr.span, LINT_BREAK);\n+                    }\n+                }\n+            }\n+        },\n+        // use `return` instead of `break`\n+        ExprKind::Break(.., break_expr) => {\n+            if let Some(break_expr) = break_expr {\n+                lint(cx, expr.span, break_expr.span, LINT_BREAK);\n+            }\n+        },\n+        ExprKind::Match(.., arms, source) => {\n+            let check_all_arms = match source {\n+                MatchSource::IfLetDesugar {\n+                    contains_else_clause: has_else,\n+                } => has_else,\n+                _ => true,\n+            };\n+\n+            if check_all_arms {\n+                for arm in arms {\n+                    expr_match(cx, &arm.body);\n+                }\n+            } else {\n+                expr_match(cx, &arms.first().expect(\"`if let` doesn't have a single arm\").body);\n+            }\n+        },\n+        // skip if it already has a return statement\n+        ExprKind::Ret(..) => (),\n+        // make sure it's not a call that panics\n+        ExprKind::Call(expr, ..) => {\n+            if_chain! {\n+                if let ExprKind::Path(qpath) = &expr.kind;\n+                if let Some(path_def_id) = cx.tables.qpath_res(qpath, expr.hir_id).opt_def_id();\n+                if match_def_path(cx, path_def_id, &BEGIN_PANIC) ||\n+                    match_def_path(cx, path_def_id, &BEGIN_PANIC_FMT);\n+                then { }\n+                else {\n+                    lint(cx, expr.span, expr.span, LINT_RETURN)\n+                }\n+            }\n+        },\n+        // everything else is missing `return`\n+        _ => lint(cx, expr.span, expr.span, LINT_RETURN),\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitReturn {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        _: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        span: Span,\n+        _: HirId,\n+    ) {\n+        let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n+\n+        // Building MIR for `fn`s with unsatisfiable preds results in ICE.\n+        if fn_has_unsatisfiable_preds(cx, def_id.to_def_id()) {\n+            return;\n+        }\n+\n+        let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n+\n+        // checking return type through MIR, HIR is not able to determine inferred closure return types\n+        // make sure it's not a macro\n+        if !mir.return_ty().is_unit() && !span.from_expansion() {\n+            expr_match(cx, &body.value);\n+        }\n+    }\n+}"}, {"sha": "155a93de4facfd5aeaef5a3e77397e6bd3c345c1", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,173 @@\n+use crate::utils::{higher, in_macro, match_qpath, span_lint_and_sugg, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, QPath, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for implicit saturating subtraction.\n+    ///\n+    /// **Why is this bad?** Simplicity and readability. Instead we can easily use an builtin function.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let end: u32 = 10;\n+    /// let start: u32 = 5;\n+    ///\n+    /// let mut i: u32 = end - start;\n+    ///\n+    /// // Bad\n+    /// if i != 0 {\n+    ///     i -= 1;\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let end: u32 = 10;\n+    /// let start: u32 = 5;\n+    ///\n+    /// let mut i: u32 = end - start;\n+    ///\n+    /// // Good\n+    /// i = i.saturating_sub(1);\n+    /// ```\n+    pub IMPLICIT_SATURATING_SUB,\n+    pedantic,\n+    \"Perform saturating subtraction instead of implicitly checking lower bound of data type\"\n+}\n+\n+declare_lint_pass!(ImplicitSaturatingSub => [IMPLICIT_SATURATING_SUB]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitSaturatingSub {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if in_macro(expr.span) {\n+            return;\n+        }\n+        if_chain! {\n+            if let Some((ref cond, ref then, None)) = higher::if_block(&expr);\n+\n+            // Check if the conditional expression is a binary operation\n+            if let ExprKind::Binary(ref cond_op, ref cond_left, ref cond_right) = cond.kind;\n+\n+            // Ensure that the binary operator is >, != and <\n+            if BinOpKind::Ne == cond_op.node || BinOpKind::Gt == cond_op.node || BinOpKind::Lt == cond_op.node;\n+\n+            // Check if the true condition block has only one statement\n+            if let ExprKind::Block(ref block, _) = then.kind;\n+            if block.stmts.len() == 1 && block.expr.is_none();\n+\n+            // Check if assign operation is done\n+            if let StmtKind::Semi(ref e) = block.stmts[0].kind;\n+            if let Some(target) = subtracts_one(cx, e);\n+\n+            // Extracting out the variable name\n+            if let ExprKind::Path(ref assign_path) = target.kind;\n+            if let QPath::Resolved(_, ref ares_path) = assign_path;\n+\n+            then {\n+                // Handle symmetric conditions in the if statement\n+                let (cond_var, cond_num_val) = if SpanlessEq::new(cx).eq_expr(cond_left, target) {\n+                    if BinOpKind::Gt == cond_op.node || BinOpKind::Ne == cond_op.node {\n+                        (cond_left, cond_right)\n+                    } else {\n+                        return;\n+                    }\n+                } else if SpanlessEq::new(cx).eq_expr(cond_right, target) {\n+                    if BinOpKind::Lt == cond_op.node || BinOpKind::Ne == cond_op.node {\n+                        (cond_right, cond_left)\n+                    } else {\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                };\n+\n+                // Check if the variable in the condition statement is an integer\n+                if !cx.tables.expr_ty(cond_var).is_integral() {\n+                    return;\n+                }\n+\n+                // Get the variable name\n+                let var_name = ares_path.segments[0].ident.name.as_str();\n+                const INT_TYPES: [&str; 5] = [\"i8\", \"i16\", \"i32\", \"i64\", \"i128\"];\n+\n+                match cond_num_val.kind {\n+                    ExprKind::Lit(ref cond_lit) => {\n+                        // Check if the constant is zero\n+                        if let LitKind::Int(0, _) = cond_lit.node {\n+                            if cx.tables.expr_ty(cond_left).is_signed() {\n+                            } else {\n+                                print_lint_and_sugg(cx, &var_name, expr);\n+                            };\n+                        }\n+                    },\n+                    ExprKind::Path(ref cond_num_path) => {\n+                        if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"MIN\"])) {\n+                            print_lint_and_sugg(cx, &var_name, expr);\n+                        };\n+                    },\n+                    ExprKind::Call(ref func, _) => {\n+                        if let ExprKind::Path(ref cond_num_path) = func.kind {\n+                            if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"min_value\"])) {\n+                                print_lint_and_sugg(cx, &var_name, expr);\n+                            }\n+                        };\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn subtracts_one<'a>(cx: &LateContext<'_, '_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n+    match expr.kind {\n+        ExprKind::AssignOp(ref op1, ref target, ref value) => {\n+            if_chain! {\n+                if BinOpKind::Sub == op1.node;\n+                // Check if literal being subtracted is one\n+                if let ExprKind::Lit(ref lit1) = value.kind;\n+                if let LitKind::Int(1, _) = lit1.node;\n+                then {\n+                    Some(target)\n+                } else {\n+                    None\n+                }\n+            }\n+        },\n+        ExprKind::Assign(ref target, ref value, _) => {\n+            if_chain! {\n+                if let ExprKind::Binary(ref op1, ref left1, ref right1) = value.kind;\n+                if BinOpKind::Sub == op1.node;\n+\n+                if SpanlessEq::new(cx).eq_expr(left1, target);\n+\n+                if let ExprKind::Lit(ref lit1) = right1.kind;\n+                if let LitKind::Int(1, _) = lit1.node;\n+                then {\n+                    Some(target)\n+                } else {\n+                    None\n+                }\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn print_lint_and_sugg(cx: &LateContext<'_, '_>, var_name: &str, expr: &Expr<'_>) {\n+    span_lint_and_sugg(\n+        cx,\n+        IMPLICIT_SATURATING_SUB,\n+        expr.span,\n+        \"Implicitly performing saturating subtraction\",\n+        \"try\",\n+        format!(\"{} = {}.saturating_sub({});\", var_name, var_name, 1.to_string()),\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "c5808dd540b6f43c3940e217d1328c549bf3f08b", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,193 @@\n+//! lint on indexing and slicing operations\n+\n+use crate::consts::{constant, Constant};\n+use crate::utils::{higher, span_lint, span_lint_and_help};\n+use rustc_ast::ast::RangeLimits;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for out of bounds array indexing with a constant\n+    /// index.\n+    ///\n+    /// **Why is this bad?** This will always panic at runtime.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// # #![allow(const_err)]\n+    /// let x = [1, 2, 3, 4];\n+    ///\n+    /// // Bad\n+    /// x[9];\n+    /// &x[2..9];\n+    ///\n+    /// // Good\n+    /// x[0];\n+    /// x[3];\n+    /// ```\n+    pub OUT_OF_BOUNDS_INDEXING,\n+    correctness,\n+    \"out of bounds constant indexing\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of indexing or slicing. Arrays are special cases, this lint\n+    /// does report on arrays if we can tell that slicing operations are in bounds and does not\n+    /// lint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n+    ///\n+    /// **Why is this bad?** Indexing and slicing can panic at runtime and there are\n+    /// safe alternatives.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```rust,no_run\n+    /// // Vector\n+    /// let x = vec![0; 5];\n+    ///\n+    /// // Bad\n+    /// x[2];\n+    /// &x[2..100];\n+    /// &x[2..];\n+    /// &x[..100];\n+    ///\n+    /// // Good\n+    /// x.get(2);\n+    /// x.get(2..100);\n+    /// x.get(2..);\n+    /// x.get(..100);\n+    ///\n+    /// // Array\n+    /// let y = [0, 1, 2, 3];\n+    ///\n+    /// // Bad\n+    /// &y[10..100];\n+    /// &y[10..];\n+    /// &y[..100];\n+    ///\n+    /// // Good\n+    /// &y[2..];\n+    /// &y[..2];\n+    /// &y[0..3];\n+    /// y.get(10);\n+    /// y.get(10..100);\n+    /// y.get(10..);\n+    /// y.get(..100);\n+    /// ```\n+    pub INDEXING_SLICING,\n+    restriction,\n+    \"indexing/slicing usage\"\n+}\n+\n+declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Index(ref array, ref index) = &expr.kind {\n+            let ty = cx.tables.expr_ty(array);\n+            if let Some(range) = higher::range(cx, index) {\n+                // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n+                if let ty::Array(_, s) = ty.kind {\n+                    let size: u128 = if let Some(size) = s.try_eval_usize(cx.tcx, cx.param_env) {\n+                        size.into()\n+                    } else {\n+                        return;\n+                    };\n+\n+                    let const_range = to_const_range(cx, range, size);\n+\n+                    if let (Some(start), _) = const_range {\n+                        if start > size {\n+                            span_lint(\n+                                cx,\n+                                OUT_OF_BOUNDS_INDEXING,\n+                                range.start.map_or(expr.span, |start| start.span),\n+                                \"range is out of bounds\",\n+                            );\n+                            return;\n+                        }\n+                    }\n+\n+                    if let (_, Some(end)) = const_range {\n+                        if end > size {\n+                            span_lint(\n+                                cx,\n+                                OUT_OF_BOUNDS_INDEXING,\n+                                range.end.map_or(expr.span, |end| end.span),\n+                                \"range is out of bounds\",\n+                            );\n+                            return;\n+                        }\n+                    }\n+\n+                    if let (Some(_), Some(_)) = const_range {\n+                        // early return because both start and end are constants\n+                        // and we have proven above that they are in bounds\n+                        return;\n+                    }\n+                }\n+\n+                let help_msg = match (range.start, range.end) {\n+                    (None, Some(_)) => \"Consider using `.get(..n)`or `.get_mut(..n)` instead\",\n+                    (Some(_), None) => \"Consider using `.get(n..)` or .get_mut(n..)` instead\",\n+                    (Some(_), Some(_)) => \"Consider using `.get(n..m)` or `.get_mut(n..m)` instead\",\n+                    (None, None) => return, // [..] is ok.\n+                };\n+\n+                span_lint_and_help(cx, INDEXING_SLICING, expr.span, \"slicing may panic.\", None, help_msg);\n+            } else {\n+                // Catchall non-range index, i.e., [n] or [n << m]\n+                if let ty::Array(..) = ty.kind {\n+                    // Index is a constant uint.\n+                    if let Some(..) = constant(cx, cx.tables, index) {\n+                        // Let rustc's `const_err` lint handle constant `usize` indexing on arrays.\n+                        return;\n+                    }\n+                }\n+\n+                span_lint_and_help(\n+                    cx,\n+                    INDEXING_SLICING,\n+                    expr.span,\n+                    \"indexing may panic.\",\n+                    None,\n+                    \"Consider using `.get(n)` or `.get_mut(n)` instead\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns a tuple of options with the start and end (exclusive) values of\n+/// the range. If the start or end is not constant, None is returned.\n+fn to_const_range<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    range: higher::Range<'_>,\n+    array_size: u128,\n+) -> (Option<u128>, Option<u128>) {\n+    let s = range.start.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let start = match s {\n+        Some(Some(Constant::Int(x))) => Some(x),\n+        Some(_) => None,\n+        None => Some(0),\n+    };\n+\n+    let e = range.end.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let end = match e {\n+        Some(Some(Constant::Int(x))) => {\n+            if range.limits == RangeLimits::Closed {\n+                Some(x + 1)\n+            } else {\n+                Some(x)\n+            }\n+        },\n+        Some(_) => None,\n+        None => Some(array_size),\n+    };\n+\n+    (start, end)\n+}"}, {"sha": "cd989c0ea6f67a0be9f872b89dd8a340def2db94", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,253 @@\n+use rustc_hir::{BorrowKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, match_type, paths, span_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for iteration that is guaranteed to be infinite.\n+    ///\n+    /// **Why is this bad?** While there may be places where this is acceptable\n+    /// (e.g., in event streams), in most cases this is simply an error.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// use std::iter;\n+    ///\n+    /// iter::repeat(1_u8).collect::<Vec<_>>();\n+    /// ```\n+    pub INFINITE_ITER,\n+    correctness,\n+    \"infinite iteration\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for iteration that may be infinite.\n+    ///\n+    /// **Why is this bad?** While there may be places where this is acceptable\n+    /// (e.g., in event streams), in most cases this is simply an error.\n+    ///\n+    /// **Known problems:** The code may have a condition to stop iteration, but\n+    /// this lint is not clever enough to analyze it.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let infinite_iter = 0..;\n+    /// [0..].iter().zip(infinite_iter.take_while(|x| *x > 5));\n+    /// ```\n+    pub MAYBE_INFINITE_ITER,\n+    pedantic,\n+    \"possible infinite iteration\"\n+}\n+\n+declare_lint_pass!(InfiniteIter => [INFINITE_ITER, MAYBE_INFINITE_ITER]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InfiniteIter {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        let (lint, msg) = match complete_infinite_iter(cx, expr) {\n+            Infinite => (INFINITE_ITER, \"infinite iteration detected\"),\n+            MaybeInfinite => (MAYBE_INFINITE_ITER, \"possible infinite iteration detected\"),\n+            Finite => {\n+                return;\n+            },\n+        };\n+        span_lint(cx, lint, expr.span, msg)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum Finiteness {\n+    Infinite,\n+    MaybeInfinite,\n+    Finite,\n+}\n+\n+use self::Finiteness::{Finite, Infinite, MaybeInfinite};\n+\n+impl Finiteness {\n+    #[must_use]\n+    fn and(self, b: Self) -> Self {\n+        match (self, b) {\n+            (Finite, _) | (_, Finite) => Finite,\n+            (MaybeInfinite, _) | (_, MaybeInfinite) => MaybeInfinite,\n+            _ => Infinite,\n+        }\n+    }\n+\n+    #[must_use]\n+    fn or(self, b: Self) -> Self {\n+        match (self, b) {\n+            (Infinite, _) | (_, Infinite) => Infinite,\n+            (MaybeInfinite, _) | (_, MaybeInfinite) => MaybeInfinite,\n+            _ => Finite,\n+        }\n+    }\n+}\n+\n+impl From<bool> for Finiteness {\n+    #[must_use]\n+    fn from(b: bool) -> Self {\n+        if b {\n+            Infinite\n+        } else {\n+            Finite\n+        }\n+    }\n+}\n+\n+/// This tells us what to look for to know if the iterator returned by\n+/// this method is infinite\n+#[derive(Copy, Clone)]\n+enum Heuristic {\n+    /// infinite no matter what\n+    Always,\n+    /// infinite if the first argument is\n+    First,\n+    /// infinite if any of the supplied arguments is\n+    Any,\n+    /// infinite if all of the supplied arguments are\n+    All,\n+}\n+\n+use self::Heuristic::{All, Always, Any, First};\n+\n+/// a slice of (method name, number of args, heuristic, bounds) tuples\n+/// that will be used to determine whether the method in question\n+/// returns an infinite or possibly infinite iterator. The finiteness\n+/// is an upper bound, e.g., some methods can return a possibly\n+/// infinite iterator at worst, e.g., `take_while`.\n+const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n+    (\"zip\", 2, All, Infinite),\n+    (\"chain\", 2, Any, Infinite),\n+    (\"cycle\", 1, Always, Infinite),\n+    (\"map\", 2, First, Infinite),\n+    (\"by_ref\", 1, First, Infinite),\n+    (\"cloned\", 1, First, Infinite),\n+    (\"rev\", 1, First, Infinite),\n+    (\"inspect\", 1, First, Infinite),\n+    (\"enumerate\", 1, First, Infinite),\n+    (\"peekable\", 2, First, Infinite),\n+    (\"fuse\", 1, First, Infinite),\n+    (\"skip\", 2, First, Infinite),\n+    (\"skip_while\", 1, First, Infinite),\n+    (\"filter\", 2, First, Infinite),\n+    (\"filter_map\", 2, First, Infinite),\n+    (\"flat_map\", 2, First, Infinite),\n+    (\"unzip\", 1, First, Infinite),\n+    (\"take_while\", 2, First, MaybeInfinite),\n+    (\"scan\", 3, First, MaybeInfinite),\n+];\n+\n+fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finiteness {\n+    match expr.kind {\n+        ExprKind::MethodCall(ref method, _, ref args) => {\n+            for &(name, len, heuristic, cap) in &HEURISTICS {\n+                if method.ident.name.as_str() == name && args.len() == len {\n+                    return (match heuristic {\n+                        Always => Infinite,\n+                        First => is_infinite(cx, &args[0]),\n+                        Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n+                        All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n+                    })\n+                    .and(cap);\n+                }\n+            }\n+            if method.ident.name == sym!(flat_map) && args.len() == 2 {\n+                if let ExprKind::Closure(_, _, body_id, _, _) = args[1].kind {\n+                    let body = cx.tcx.hir().body(body_id);\n+                    return is_infinite(cx, &body.value);\n+                }\n+            }\n+            Finite\n+        },\n+        ExprKind::Block(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) => is_infinite(cx, e),\n+        ExprKind::Call(ref path, _) => {\n+            if let ExprKind::Path(ref qpath) = path.kind {\n+                match_qpath(qpath, &paths::REPEAT).into()\n+            } else {\n+                Finite\n+            }\n+        },\n+        ExprKind::Struct(..) => higher::range(cx, expr).map_or(false, |r| r.end.is_none()).into(),\n+        _ => Finite,\n+    }\n+}\n+\n+/// the names and argument lengths of methods that *may* exhaust their\n+/// iterators\n+const POSSIBLY_COMPLETING_METHODS: [(&str, usize); 6] = [\n+    (\"find\", 2),\n+    (\"rfind\", 2),\n+    (\"position\", 2),\n+    (\"rposition\", 2),\n+    (\"any\", 2),\n+    (\"all\", 2),\n+];\n+\n+/// the names and argument lengths of methods that *always* exhaust\n+/// their iterators\n+const COMPLETING_METHODS: [(&str, usize); 12] = [\n+    (\"count\", 1),\n+    (\"fold\", 3),\n+    (\"for_each\", 2),\n+    (\"partition\", 2),\n+    (\"max\", 1),\n+    (\"max_by\", 2),\n+    (\"max_by_key\", 2),\n+    (\"min\", 1),\n+    (\"min_by\", 2),\n+    (\"min_by_key\", 2),\n+    (\"sum\", 1),\n+    (\"product\", 1),\n+];\n+\n+/// the paths of types that are known to be infinitely allocating\n+const INFINITE_COLLECTORS: [&[&str]; 8] = [\n+    &paths::BINARY_HEAP,\n+    &paths::BTREEMAP,\n+    &paths::BTREESET,\n+    &paths::HASHMAP,\n+    &paths::HASHSET,\n+    &paths::LINKED_LIST,\n+    &paths::VEC,\n+    &paths::VEC_DEQUE,\n+];\n+\n+fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finiteness {\n+    match expr.kind {\n+        ExprKind::MethodCall(ref method, _, ref args) => {\n+            for &(name, len) in &COMPLETING_METHODS {\n+                if method.ident.name.as_str() == name && args.len() == len {\n+                    return is_infinite(cx, &args[0]);\n+                }\n+            }\n+            for &(name, len) in &POSSIBLY_COMPLETING_METHODS {\n+                if method.ident.name.as_str() == name && args.len() == len {\n+                    return MaybeInfinite.and(is_infinite(cx, &args[0]));\n+                }\n+            }\n+            if method.ident.name == sym!(last) && args.len() == 1 {\n+                let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR)\n+                    .map_or(false, |id| !implements_trait(cx, cx.tables.expr_ty(&args[0]), id, &[]));\n+                if not_double_ended {\n+                    return is_infinite(cx, &args[0]);\n+                }\n+            } else if method.ident.name == sym!(collect) {\n+                let ty = cx.tables.expr_ty(expr);\n+                if INFINITE_COLLECTORS.iter().any(|path| match_type(cx, ty, path)) {\n+                    return is_infinite(cx, &args[0]);\n+                }\n+            }\n+        },\n+        ExprKind::Binary(op, ref l, ref r) => {\n+            if op.node.is_comparison() {\n+                return is_infinite(cx, l).and(is_infinite(cx, r)).and(MaybeInfinite);\n+            }\n+        }, // TODO: ExprKind::Loop + Match\n+        _ => (),\n+    }\n+    Finite\n+}"}, {"sha": "7e2975ac2ae907fe0ab7a4c8ac2111a3450edb46", "filename": "src/tools/clippy/clippy_lints/src/inherent_impl.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,94 @@\n+//! lint on inherent implementations\n+\n+use crate::utils::{in_macro, span_lint_and_then};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{def_id, Crate, Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for multiple inherent implementations of a struct\n+    ///\n+    /// **Why is this bad?** Splitting the implementation of a type makes the code harder to navigate.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct X;\n+    /// impl X {\n+    ///     fn one() {}\n+    /// }\n+    /// impl X {\n+    ///     fn other() {}\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// struct X;\n+    /// impl X {\n+    ///     fn one() {}\n+    ///     fn other() {}\n+    /// }\n+    /// ```\n+    pub MULTIPLE_INHERENT_IMPL,\n+    restriction,\n+    \"Multiple inherent impl that could be grouped\"\n+}\n+\n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Default)]\n+pub struct MultipleInherentImpl {\n+    impls: FxHashMap<def_id::DefId, Span>,\n+}\n+\n+impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MultipleInherentImpl {\n+    fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+        if let ItemKind::Impl {\n+            ref generics,\n+            of_trait: None,\n+            ..\n+        } = item.kind\n+        {\n+            // Remember for each inherent implementation encoutered its span and generics\n+            // but filter out implementations that have generic params (type or lifetime)\n+            // or are derived from a macro\n+            if !in_macro(item.span) && generics.params.is_empty() {\n+                self.impls.insert(item.hir_id.owner.to_def_id(), item.span);\n+            }\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx Crate<'_>) {\n+        if let Some(item) = krate.items.values().next() {\n+            // Retrieve all inherent implementations from the crate, grouped by type\n+            for impls in cx\n+                .tcx\n+                .crate_inherent_impls(item.hir_id.owner.to_def_id().krate)\n+                .inherent_impls\n+                .values()\n+            {\n+                // Filter out implementations that have generic params (type or lifetime)\n+                let mut impl_spans = impls.iter().filter_map(|impl_def| self.impls.get(impl_def));\n+                if let Some(initial_span) = impl_spans.next() {\n+                    impl_spans.for_each(|additional_span| {\n+                        span_lint_and_then(\n+                            cx,\n+                            MULTIPLE_INHERENT_IMPL,\n+                            *additional_span,\n+                            \"Multiple implementations of this structure\",\n+                            |diag| {\n+                                diag.span_note(*initial_span, \"First implementation here\");\n+                            },\n+                        )\n+                    })\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "289628a2752af81ded7e8fdbe848b219888f0b0b", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,156 @@\n+use if_chain::if_chain;\n+use rustc_hir::{ImplItem, ImplItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{\n+    get_trait_def_id, implements_trait, is_type_diagnostic_item, paths, return_ty, span_lint_and_help,\n+    trait_ref_of_method, walk_ptrs_ty,\n+};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for the definition of inherent methods with a signature of `to_string(&self) -> String`.\n+    ///\n+    /// **Why is this bad?** This method is also implicitly defined if a type implements the `Display` trait. As the functionality of `Display` is much more versatile, it should be preferred.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// ** Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// pub struct A;\n+    ///\n+    /// impl A {\n+    ///     pub fn to_string(&self) -> String {\n+    ///         \"I am A\".to_string()\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// // Good\n+    /// use std::fmt;\n+    ///\n+    /// pub struct A;\n+    ///\n+    /// impl fmt::Display for A {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"I am A\")\n+    ///     }\n+    /// }\n+    /// ```\n+    pub INHERENT_TO_STRING,\n+    style,\n+    \"type implements inherent method `to_string()`, but should instead implement the `Display` trait\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for the definition of inherent methods with a signature of `to_string(&self) -> String` and if the type implementing this method also implements the `Display` trait.\n+    ///\n+    /// **Why is this bad?** This method is also implicitly defined if a type implements the `Display` trait. The less versatile inherent method will then shadow the implementation introduced by `Display`.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// ** Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// use std::fmt;\n+    ///\n+    /// pub struct A;\n+    ///\n+    /// impl A {\n+    ///     pub fn to_string(&self) -> String {\n+    ///         \"I am A\".to_string()\n+    ///     }\n+    /// }\n+    ///\n+    /// impl fmt::Display for A {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"I am A, too\")\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// // Good\n+    /// use std::fmt;\n+    ///\n+    /// pub struct A;\n+    ///\n+    /// impl fmt::Display for A {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"I am A\")\n+    ///     }\n+    /// }\n+    /// ```\n+    pub INHERENT_TO_STRING_SHADOW_DISPLAY,\n+    correctness,\n+    \"type implements inherent method `to_string()`, which gets shadowed by the implementation of the `Display` trait\"\n+}\n+\n+declare_lint_pass!(InherentToString => [INHERENT_TO_STRING, INHERENT_TO_STRING_SHADOW_DISPLAY]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InherentToString {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem<'_>) {\n+        if impl_item.span.from_expansion() {\n+            return;\n+        }\n+\n+        if_chain! {\n+            // Check if item is a method, called to_string and has a parameter 'self'\n+            if let ImplItemKind::Fn(ref signature, _) = impl_item.kind;\n+            if impl_item.ident.name.as_str() == \"to_string\";\n+            let decl = &signature.decl;\n+            if decl.implicit_self.has_implicit_self();\n+            if decl.inputs.len() == 1;\n+\n+            // Check if return type is String\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type));\n+\n+            // Filters instances of to_string which are required by a trait\n+            if trait_ref_of_method(cx, impl_item.hir_id).is_none();\n+\n+            then {\n+                show_lint(cx, impl_item);\n+            }\n+        }\n+    }\n+}\n+\n+fn show_lint(cx: &LateContext<'_, '_>, item: &ImplItem<'_>) {\n+    let display_trait_id = get_trait_def_id(cx, &paths::DISPLAY_TRAIT).expect(\"Failed to get trait ID of `Display`!\");\n+\n+    // Get the real type of 'self'\n+    let fn_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n+    let self_type = cx.tcx.fn_sig(fn_def_id).input(0);\n+    let self_type = walk_ptrs_ty(self_type.skip_binder());\n+\n+    // Emit either a warning or an error\n+    if implements_trait(cx, self_type, display_trait_id, &[]) {\n+        span_lint_and_help(\n+            cx,\n+            INHERENT_TO_STRING_SHADOW_DISPLAY,\n+            item.span,\n+            &format!(\n+                \"type `{}` implements inherent method `to_string(&self) -> String` which shadows the implementation of `Display`\",\n+                self_type.to_string()\n+            ),\n+            None,\n+            &format!(\"remove the inherent method from type `{}`\", self_type.to_string())\n+        );\n+    } else {\n+        span_lint_and_help(\n+            cx,\n+            INHERENT_TO_STRING,\n+            item.span,\n+            &format!(\n+                \"implementation of inherent method `to_string(&self) -> String` for type `{}`\",\n+                self_type.to_string()\n+            ),\n+            None,\n+            &format!(\"implement trait `Display` for type `{}` instead\", self_type.to_string()),\n+        );\n+    }\n+}"}, {"sha": "1ebfb3c8162a1db111635a5428ad895c795798b9", "filename": "src/tools/clippy/clippy_lints/src/inline_fn_without_body.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,57 @@\n+//! checks for `#[inline]` on trait methods without bodies\n+\n+use crate::utils::span_lint_and_then;\n+use crate::utils::sugg::DiagnosticBuilderExt;\n+use rustc_ast::ast::{Attribute, Name};\n+use rustc_errors::Applicability;\n+use rustc_hir::{TraitFn, TraitItem, TraitItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[inline]` on trait methods without bodies\n+    ///\n+    /// **Why is this bad?** Only implementations of trait methods may be inlined.\n+    /// The inline attribute is ignored for trait methods without bodies.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// trait Animal {\n+    ///     #[inline]\n+    ///     fn name(&self) -> &'static str;\n+    /// }\n+    /// ```\n+    pub INLINE_FN_WITHOUT_BODY,\n+    correctness,\n+    \"use of `#[inline]` on trait methods without bodies\"\n+}\n+\n+declare_lint_pass!(InlineFnWithoutBody => [INLINE_FN_WITHOUT_BODY]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InlineFnWithoutBody {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem<'_>) {\n+        if let TraitItemKind::Fn(_, TraitFn::Required(_)) = item.kind {\n+            check_attrs(cx, item.ident.name, &item.attrs);\n+        }\n+    }\n+}\n+\n+fn check_attrs(cx: &LateContext<'_, '_>, name: Name, attrs: &[Attribute]) {\n+    for attr in attrs {\n+        if !attr.check_name(sym!(inline)) {\n+            continue;\n+        }\n+\n+        span_lint_and_then(\n+            cx,\n+            INLINE_FN_WITHOUT_BODY,\n+            attr.span,\n+            &format!(\"use of `#[inline]` on trait method `{}` which has no body\", name),\n+            |diag| {\n+                diag.suggest_remove_item(cx, attr.span, \"remove\", Applicability::MachineApplicable);\n+            },\n+        );\n+    }\n+}"}, {"sha": "d5dbd495680b2fca928e3a69131e6243127b6899", "filename": "src/tools/clippy/clippy_lints/src/int_plus_one.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,172 @@\n+//! lint on blocks unnecessarily using >= with a + 1 or - 1\n+\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, Lit, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{snippet_opt, span_lint_and_sugg};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n+    ///\n+    ///\n+    /// **Why is this bad?** Readability -- better to use `> y` instead of `>= y + 1`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let x = 1;\n+    /// # let y = 1;\n+    /// if x >= y + 1 {}\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// # let x = 1;\n+    /// # let y = 1;\n+    /// if x > y {}\n+    /// ```\n+    pub INT_PLUS_ONE,\n+    complexity,\n+    \"instead of using `x >= y + 1`, use `x > y`\"\n+}\n+\n+declare_lint_pass!(IntPlusOne => [INT_PLUS_ONE]);\n+\n+// cases:\n+// BinOpKind::Ge\n+// x >= y + 1\n+// x - 1 >= y\n+//\n+// BinOpKind::Le\n+// x + 1 <= y\n+// x <= y - 1\n+\n+#[derive(Copy, Clone)]\n+enum Side {\n+    LHS,\n+    RHS,\n+}\n+\n+impl IntPlusOne {\n+    #[allow(clippy::cast_sign_loss)]\n+    fn check_lit(lit: &Lit, target_value: i128) -> bool {\n+        if let LitKind::Int(value, ..) = lit.kind {\n+            return value == (target_value as u128);\n+        }\n+        false\n+    }\n+\n+    fn check_binop(cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n+        match (binop, &lhs.kind, &rhs.kind) {\n+            // case where `x - 1 >= ...` or `-1 + x >= ...`\n+            (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n+                match (lhskind.node, &lhslhs.kind, &lhsrhs.kind) {\n+                    // `-1 + x`\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if Self::check_lit(lit, -1) => {\n+                        Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n+                    },\n+                    // `x - 1`\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)\n+                    },\n+                    _ => None,\n+                }\n+            },\n+            // case where `... >= y + 1` or `... >= 1 + y`\n+            (BinOpKind::Ge, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs))\n+                if rhskind.node == BinOpKind::Add =>\n+            {\n+                match (&rhslhs.kind, &rhsrhs.kind) {\n+                    // `y + 1` and `1 + y`\n+                    (&ExprKind::Lit(ref lit), _) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n+                    },\n+                    (_, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)\n+                    },\n+                    _ => None,\n+                }\n+            }\n+            // case where `x + 1 <= ...` or `1 + x <= ...`\n+            (BinOpKind::Le, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _)\n+                if lhskind.node == BinOpKind::Add =>\n+            {\n+                match (&lhslhs.kind, &lhsrhs.kind) {\n+                    // `1 + x` and `x + 1`\n+                    (&ExprKind::Lit(ref lit), _) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n+                    },\n+                    (_, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)\n+                    },\n+                    _ => None,\n+                }\n+            }\n+            // case where `... >= y - 1` or `... >= -1 + y`\n+            (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n+                match (rhskind.node, &rhslhs.kind, &rhsrhs.kind) {\n+                    // `-1 + y`\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if Self::check_lit(lit, -1) => {\n+                        Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n+                    },\n+                    // `y - 1`\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)\n+                    },\n+                    _ => None,\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn generate_recommendation(\n+        cx: &EarlyContext<'_>,\n+        binop: BinOpKind,\n+        node: &Expr,\n+        other_side: &Expr,\n+        side: Side,\n+    ) -> Option<String> {\n+        let binop_string = match binop {\n+            BinOpKind::Ge => \">\",\n+            BinOpKind::Le => \"<\",\n+            _ => return None,\n+        };\n+        if let Some(snippet) = snippet_opt(cx, node.span) {\n+            if let Some(other_side_snippet) = snippet_opt(cx, other_side.span) {\n+                let rec = match side {\n+                    Side::LHS => Some(format!(\"{} {} {}\", snippet, binop_string, other_side_snippet)),\n+                    Side::RHS => Some(format!(\"{} {} {}\", other_side_snippet, binop_string, snippet)),\n+                };\n+                return rec;\n+            }\n+        }\n+        None\n+    }\n+\n+    fn emit_warning(cx: &EarlyContext<'_>, block: &Expr, recommendation: String) {\n+        span_lint_and_sugg(\n+            cx,\n+            INT_PLUS_ONE,\n+            block.span,\n+            \"Unnecessary `>= y + 1` or `x - 1 >=`\",\n+            \"change it to\",\n+            recommendation,\n+            Applicability::MachineApplicable, // snippet\n+        );\n+    }\n+}\n+\n+impl EarlyLintPass for IntPlusOne {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n+        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.kind {\n+            if let Some(ref rec) = Self::check_binop(cx, kind.node, lhs, rhs) {\n+                Self::emit_warning(cx, item, rec.clone());\n+            }\n+        }\n+    }\n+}"}, {"sha": "fe34d33fe652c2cf7f3ac258be6dc80840aa25b8", "filename": "src/tools/clippy/clippy_lints/src/integer_division.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,56 @@\n+use crate::utils::span_lint_and_help;\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for division of integers\n+    ///\n+    /// **Why is this bad?** When outside of some very specific algorithms,\n+    /// integer division is very often a mistake because it discards the\n+    /// remainder.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = 3 / 2;\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    pub INTEGER_DIVISION,\n+    restriction,\n+    \"integer division may cause loss of precision\"\n+}\n+\n+declare_lint_pass!(IntegerDivision => [INTEGER_DIVISION]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IntegerDivision {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_integer_division(cx, expr) {\n+            span_lint_and_help(\n+                cx,\n+                INTEGER_DIVISION,\n+                expr.span,\n+                \"integer division\",\n+                None,\n+                \"division of integers may cause loss of precision. consider using floats.\",\n+            );\n+        }\n+    }\n+}\n+\n+fn is_integer_division<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) -> bool {\n+    if_chain! {\n+        if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n+        if let hir::BinOpKind::Div = &binop.node;\n+        then {\n+            let (left_ty, right_ty) = (cx.tables.expr_ty(left), cx.tables.expr_ty(right));\n+            return left_ty.is_integral() && right_ty.is_integral();\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "e7062b7c16bb9b89905e8605d0471e436d82b31e", "filename": "src/tools/clippy/clippy_lints/src/items_after_statements.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,71 @@\n+//! lint when items are used after statements\n+\n+use crate::utils::span_lint;\n+use rustc_ast::ast::{Block, ItemKind, StmtKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for items declared after some statement in a block.\n+    ///\n+    /// **Why is this bad?** Items live for the entire scope they are declared\n+    /// in. But statements are processed in order. This might cause confusion as\n+    /// it's hard to figure out which item is meant in a statement.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo() {\n+    ///     println!(\"cake\");\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     foo(); // prints \"foo\"\n+    ///     fn foo() {\n+    ///         println!(\"foo\");\n+    ///     }\n+    ///     foo(); // prints \"foo\"\n+    /// }\n+    /// ```\n+    pub ITEMS_AFTER_STATEMENTS,\n+    pedantic,\n+    \"blocks where an item comes after a statement\"\n+}\n+\n+declare_lint_pass!(ItemsAfterStatements => [ITEMS_AFTER_STATEMENTS]);\n+\n+impl EarlyLintPass for ItemsAfterStatements {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n+        if item.span.from_expansion() {\n+            return;\n+        }\n+\n+        // skip initial items\n+        let stmts = item\n+            .stmts\n+            .iter()\n+            .map(|stmt| &stmt.kind)\n+            .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n+\n+        // lint on all further items\n+        for stmt in stmts {\n+            if let StmtKind::Item(ref it) = *stmt {\n+                if it.span.from_expansion() {\n+                    return;\n+                }\n+                if let ItemKind::MacroDef(..) = it.kind {\n+                    // do not lint `macro_rules`, but continue processing further statements\n+                    continue;\n+                }\n+                span_lint(\n+                    cx,\n+                    ITEMS_AFTER_STATEMENTS,\n+                    it.span,\n+                    \"adding items after statements is confusing, since items exist from the \\\n+                     start of the scope\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "c9e12fc535ec0ee3bd73228221679097e727285e", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,85 @@\n+use crate::rustc_target::abi::LayoutOf;\n+use crate::utils::span_lint_and_then;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::ty::{self, ConstKind};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{BytePos, Pos, Span};\n+use rustc_typeck::hir_ty_to_ty;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for large `const` arrays that should\n+    /// be defined as `static` instead.\n+    ///\n+    /// **Why is this bad?** Performance: const variables are inlined upon use.\n+    /// Static items result in only one instance and has a fixed location in memory.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// pub const a = [0u32; 1_000_000];\n+    ///\n+    /// // Good\n+    /// pub static a = [0u32; 1_000_000];\n+    /// ```\n+    pub LARGE_CONST_ARRAYS,\n+    perf,\n+    \"large non-scalar const array may cause performance overhead\"\n+}\n+\n+pub struct LargeConstArrays {\n+    maximum_allowed_size: u64,\n+}\n+\n+impl LargeConstArrays {\n+    #[must_use]\n+    pub fn new(maximum_allowed_size: u64) -> Self {\n+        Self { maximum_allowed_size }\n+    }\n+}\n+\n+impl_lint_pass!(LargeConstArrays => [LARGE_CONST_ARRAYS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeConstArrays {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+        if_chain! {\n+            if !item.span.from_expansion();\n+            if let ItemKind::Const(hir_ty, _) = &item.kind;\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+            if let ty::Array(element_type, cst) = ty.kind;\n+            if let ConstKind::Value(val) = cst.val;\n+            if let ConstValue::Scalar(element_count) = val;\n+            if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n+            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if self.maximum_allowed_size < element_count * element_size;\n+\n+            then {\n+                let hi_pos = item.ident.span.lo() - BytePos::from_usize(1);\n+                let sugg_span = Span::new(\n+                    hi_pos - BytePos::from_usize(\"const\".len()),\n+                    hi_pos,\n+                    item.span.ctxt(),\n+                );\n+                span_lint_and_then(\n+                    cx,\n+                    LARGE_CONST_ARRAYS,\n+                    item.span,\n+                    \"large array defined as const\",\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            sugg_span,\n+                            \"make this a static item\",\n+                            \"static\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "5bc3234e3252f2a3ca8ef5e323cd40da30f76096", "filename": "src/tools/clippy/clippy_lints/src/large_enum_variant.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,134 @@\n+//! lint when there is a large size difference between variants on an enum\n+\n+use crate::utils::{snippet_opt, span_lint_and_then};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Item, ItemKind, VariantData};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_target::abi::LayoutOf;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for large size differences between variants on\n+    /// `enum`s.\n+    ///\n+    /// **Why is this bad?** Enum size is bounded by the largest variant. Having a\n+    /// large variant can penalize the memory layout of that enum.\n+    ///\n+    /// **Known problems:** This lint obviously cannot take the distribution of\n+    /// variants in your running program into account. It is possible that the\n+    /// smaller variants make up less than 1% of all instances, in which case\n+    /// the overhead is negligible and the boxing is counter-productive. Always\n+    /// measure the change this lint suggests.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// enum Test {\n+    ///     A(i32),\n+    ///     B([i32; 8000]),\n+    /// }\n+    ///\n+    /// // Possibly better\n+    /// enum Test2 {\n+    ///     A(i32),\n+    ///     B(Box<[i32; 8000]>),\n+    /// }\n+    /// ```\n+    pub LARGE_ENUM_VARIANT,\n+    perf,\n+    \"large size difference between variants on an enum\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct LargeEnumVariant {\n+    maximum_size_difference_allowed: u64,\n+}\n+\n+impl LargeEnumVariant {\n+    #[must_use]\n+    pub fn new(maximum_size_difference_allowed: u64) -> Self {\n+        Self {\n+            maximum_size_difference_allowed,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(LargeEnumVariant => [LARGE_ENUM_VARIANT]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item<'_>) {\n+        let did = cx.tcx.hir().local_def_id(item.hir_id);\n+        if let ItemKind::Enum(ref def, _) = item.kind {\n+            let ty = cx.tcx.type_of(did);\n+            let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n+\n+            let mut largest_variant: Option<(_, _)> = None;\n+            let mut second_variant: Option<(_, _)> = None;\n+\n+            for (i, variant) in adt.variants.iter().enumerate() {\n+                let size: u64 = variant\n+                    .fields\n+                    .iter()\n+                    .filter_map(|f| {\n+                        let ty = cx.tcx.type_of(f.did);\n+                        // don't count generics by filtering out everything\n+                        // that does not have a layout\n+                        cx.layout_of(ty).ok().map(|l| l.size.bytes())\n+                    })\n+                    .sum();\n+\n+                let grouped = (size, (i, variant));\n+\n+                if grouped.0 >= largest_variant.map_or(0, |x| x.0) {\n+                    second_variant = largest_variant;\n+                    largest_variant = Some(grouped);\n+                }\n+            }\n+\n+            if let (Some(largest), Some(second)) = (largest_variant, second_variant) {\n+                let difference = largest.0 - second.0;\n+\n+                if difference > self.maximum_size_difference_allowed {\n+                    let (i, variant) = largest.1;\n+\n+                    let help_text = \"consider boxing the large fields to reduce the total size of the enum\";\n+                    span_lint_and_then(\n+                        cx,\n+                        LARGE_ENUM_VARIANT,\n+                        def.variants[i].span,\n+                        \"large size difference between variants\",\n+                        |diag| {\n+                            diag.span_label(\n+                                def.variants[(largest.1).0].span,\n+                                &format!(\"this variant is {} bytes\", largest.0),\n+                            );\n+                            diag.span_note(\n+                                def.variants[(second.1).0].span,\n+                                &format!(\"and the second-largest variant is {} bytes:\", second.0),\n+                            );\n+                            if variant.fields.len() == 1 {\n+                                let span = match def.variants[i].data {\n+                                    VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, ..) => {\n+                                        fields[0].ty.span\n+                                    },\n+                                    VariantData::Unit(..) => unreachable!(),\n+                                };\n+                                if let Some(snip) = snippet_opt(cx, span) {\n+                                    diag.span_suggestion(\n+                                        span,\n+                                        help_text,\n+                                        format!(\"Box<{}>\", snip),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                    return;\n+                                }\n+                            }\n+                            diag.span_help(def.variants[i].span, help_text);\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "deb57db1678965e946466bd042adc1d108e6e0e6", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,69 @@\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::ty::{self, ConstKind};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+use if_chain::if_chain;\n+\n+use crate::rustc_target::abi::LayoutOf;\n+use crate::utils::{snippet, span_lint_and_help};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for local arrays that may be too large.\n+    ///\n+    /// **Why is this bad?** Large local arrays may cause stack overflow.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let a = [0u32; 1_000_000];\n+    /// ```\n+    pub LARGE_STACK_ARRAYS,\n+    pedantic,\n+    \"allocating large arrays on stack may cause stack overflow\"\n+}\n+\n+pub struct LargeStackArrays {\n+    maximum_allowed_size: u64,\n+}\n+\n+impl LargeStackArrays {\n+    #[must_use]\n+    pub fn new(maximum_allowed_size: u64) -> Self {\n+        Self { maximum_allowed_size }\n+    }\n+}\n+\n+impl_lint_pass!(LargeStackArrays => [LARGE_STACK_ARRAYS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeStackArrays {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Repeat(_, _) = expr.kind;\n+            if let ty::Array(element_type, cst) = cx.tables.expr_ty(expr).kind;\n+            if let ConstKind::Value(val) = cst.val;\n+            if let ConstValue::Scalar(element_count) = val;\n+            if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n+            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if self.maximum_allowed_size < element_count * element_size;\n+            then {\n+                span_lint_and_help(\n+                    cx,\n+                    LARGE_STACK_ARRAYS,\n+                    expr.span,\n+                    &format!(\n+                        \"allocating a local array larger than {} bytes\",\n+                        self.maximum_allowed_size\n+                    ),\n+                    None,\n+                    &format!(\n+                        \"consider allocating on the heap with `vec!{}.into_boxed_slice()`\",\n+                        snippet(cx, expr.span, \"[...]\")\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "1d86ca9696f2bb778431b9dfdec0736a4df2f1d5", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,304 @@\n+use crate::utils::{get_item_name, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+use rustc_ast::ast::{LitKind, Name};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{AssocItemKind, BinOpKind, Expr, ExprKind, ImplItemRef, Item, ItemKind, TraitItemRef};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::{Span, Spanned};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for getting the length of something via `.len()`\n+    /// just to compare to zero, and suggests using `.is_empty()` where applicable.\n+    ///\n+    /// **Why is this bad?** Some structures can answer `.is_empty()` much faster\n+    /// than calculating their length. So it is good to get into the habit of using\n+    /// `.is_empty()`, and having it is cheap.\n+    /// Besides, it makes the intent clearer than a manual comparison in some contexts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// if x.len() == 0 {\n+    ///     ..\n+    /// }\n+    /// if y.len() != 0 {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// instead use\n+    /// ```ignore\n+    /// if x.is_empty() {\n+    ///     ..\n+    /// }\n+    /// if !y.is_empty() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub LEN_ZERO,\n+    style,\n+    \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for items that implement `.len()` but not\n+    /// `.is_empty()`.\n+    ///\n+    /// **Why is this bad?** It is good custom to have both methods, because for\n+    /// some data structures, asking about the length will be a costly operation,\n+    /// whereas `.is_empty()` can usually answer in constant time. Also it used to\n+    /// lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\n+    /// lint will ignore such entities.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// impl X {\n+    ///     pub fn len(&self) -> usize {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n+    pub LEN_WITHOUT_IS_EMPTY,\n+    style,\n+    \"traits or impls with a public `len` method but no corresponding `is_empty` method\"\n+}\n+\n+declare_lint_pass!(LenZero => [LEN_ZERO, LEN_WITHOUT_IS_EMPTY]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item<'_>) {\n+        if item.span.from_expansion() {\n+            return;\n+        }\n+\n+        match item.kind {\n+            ItemKind::Trait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n+            ItemKind::Impl {\n+                of_trait: None,\n+                items: ref impl_items,\n+                ..\n+            } => check_impl_items(cx, item, impl_items),\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.kind {\n+            match cmp {\n+                BinOpKind::Eq => {\n+                    check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n+                    check_cmp(cx, expr.span, right, left, \"\", 0); // 0 == len\n+                },\n+                BinOpKind::Ne => {\n+                    check_cmp(cx, expr.span, left, right, \"!\", 0); // len != 0\n+                    check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 != len\n+                },\n+                BinOpKind::Gt => {\n+                    check_cmp(cx, expr.span, left, right, \"!\", 0); // len > 0\n+                    check_cmp(cx, expr.span, right, left, \"\", 1); // 1 > len\n+                },\n+                BinOpKind::Lt => {\n+                    check_cmp(cx, expr.span, left, right, \"\", 1); // len < 1\n+                    check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 < len\n+                },\n+                BinOpKind::Ge => check_cmp(cx, expr.span, left, right, \"!\", 1), // len >= 1\n+                BinOpKind::Le => check_cmp(cx, expr.span, right, left, \"!\", 1), // 1 <= len\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item<'_>, trait_items: &[TraitItemRef]) {\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &TraitItemRef, name: &str) -> bool {\n+        item.ident.name.as_str() == name\n+            && if let AssocItemKind::Fn { has_self } = item.kind {\n+                has_self && {\n+                    let did = cx.tcx.hir().local_def_id(item.id.hir_id);\n+                    cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+                }\n+            } else {\n+                false\n+            }\n+    }\n+\n+    // fill the set with current and super traits\n+    fn fill_trait_set(traitt: DefId, set: &mut FxHashSet<DefId>, cx: &LateContext<'_, '_>) {\n+        if set.insert(traitt) {\n+            for supertrait in rustc_trait_selection::traits::supertrait_def_ids(cx.tcx, traitt) {\n+                fill_trait_set(supertrait, set, cx);\n+            }\n+        }\n+    }\n+\n+    if cx.access_levels.is_exported(visited_trait.hir_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n+        let mut current_and_super_traits = FxHashSet::default();\n+        let visited_trait_def_id = cx.tcx.hir().local_def_id(visited_trait.hir_id);\n+        fill_trait_set(visited_trait_def_id.to_def_id(), &mut current_and_super_traits, cx);\n+\n+        let is_empty_method_found = current_and_super_traits\n+            .iter()\n+            .flat_map(|&i| cx.tcx.associated_items(i).in_definition_order())\n+            .any(|i| {\n+                i.kind == ty::AssocKind::Fn\n+                    && i.fn_has_self_parameter\n+                    && i.ident.name == sym!(is_empty)\n+                    && cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n+            });\n+\n+        if !is_empty_method_found {\n+            span_lint(\n+                cx,\n+                LEN_WITHOUT_IS_EMPTY,\n+                visited_trait.span,\n+                &format!(\n+                    \"trait `{}` has a `len` method but no (possibly inherited) `is_empty` method\",\n+                    visited_trait.ident.name\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item<'_>, impl_items: &[ImplItemRef<'_>]) {\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &ImplItemRef<'_>, name: &str) -> bool {\n+        item.ident.name.as_str() == name\n+            && if let AssocItemKind::Fn { has_self } = item.kind {\n+                has_self && {\n+                    let did = cx.tcx.hir().local_def_id(item.id.hir_id);\n+                    cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+                }\n+            } else {\n+                false\n+            }\n+    }\n+\n+    let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n+        if cx.access_levels.is_exported(is_empty.id.hir_id) {\n+            return;\n+        } else {\n+            \"a private\"\n+        }\n+    } else {\n+        \"no corresponding\"\n+    };\n+\n+    if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n+        if cx.access_levels.is_exported(i.id.hir_id) {\n+            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n+            let ty = cx.tcx.type_of(def_id);\n+\n+            span_lint(\n+                cx,\n+                LEN_WITHOUT_IS_EMPTY,\n+                item.span,\n+                &format!(\n+                    \"item `{}` has a public `len` method but {} `is_empty` method\",\n+                    ty, is_empty\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n+    if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+        // check if we are in an is_empty() method\n+        if let Some(name) = get_item_name(cx, method) {\n+            if name.as_str() == \"is_empty\" {\n+                return;\n+            }\n+        }\n+\n+        check_len(cx, span, method_path.ident.name, args, &lit.node, op, compare_to)\n+    }\n+}\n+\n+fn check_len(\n+    cx: &LateContext<'_, '_>,\n+    span: Span,\n+    method_name: Name,\n+    args: &[Expr<'_>],\n+    lit: &LitKind,\n+    op: &str,\n+    compare_to: u32,\n+) {\n+    if let LitKind::Int(lit, _) = *lit {\n+        // check if length is compared to the specified number\n+        if lit != u128::from(compare_to) {\n+            return;\n+        }\n+\n+        if method_name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                LEN_ZERO,\n+                span,\n+                &format!(\"length comparison to {}\", if compare_to == 0 { \"zero\" } else { \"one\" }),\n+                &format!(\"using `{}is_empty` is clearer and more explicit\", op),\n+                format!(\n+                    \"{}{}.is_empty()\",\n+                    op,\n+                    snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+/// Checks if this type has an `is_empty` method.\n+fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n+    fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssocItem) -> bool {\n+        if let ty::AssocKind::Fn = item.kind {\n+            if item.ident.name.as_str() == \"is_empty\" {\n+                let sig = cx.tcx.fn_sig(item.def_id);\n+                let ty = sig.skip_binder();\n+                ty.inputs().len() == 1\n+            } else {\n+                false\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Checks the inherent impl's items for an `is_empty(self)` method.\n+    fn has_is_empty_impl(cx: &LateContext<'_, '_>, id: DefId) -> bool {\n+        cx.tcx.inherent_impls(id).iter().any(|imp| {\n+            cx.tcx\n+                .associated_items(*imp)\n+                .in_definition_order()\n+                .any(|item| is_is_empty(cx, &item))\n+        })\n+    }\n+\n+    let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n+    match ty.kind {\n+        ty::Dynamic(ref tt, ..) => {\n+            if let Some(principal) = tt.principal() {\n+                cx.tcx\n+                    .associated_items(principal.def_id())\n+                    .in_definition_order()\n+                    .any(|item| is_is_empty(cx, &item))\n+            } else {\n+                false\n+            }\n+        },\n+        ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n+        ty::Adt(id, _) => has_is_empty_impl(cx, id.did),\n+        ty::Array(..) | ty::Slice(..) | ty::Str => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "398a3103a037194ab5c1ffe557412244405d9cea", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,205 @@\n+use crate::utils::{higher, qpath_res, snippet, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_hir::intravisit;\n+use rustc_hir::BindingAnnotation;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for variable declarations immediately followed by a\n+    /// conditional affectation.\n+    ///\n+    /// **Why is this bad?** This is not idiomatic Rust.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let foo;\n+    ///\n+    /// if bar() {\n+    ///     foo = 42;\n+    /// } else {\n+    ///     foo = 0;\n+    /// }\n+    ///\n+    /// let mut baz = None;\n+    ///\n+    /// if bar() {\n+    ///     baz = Some(42);\n+    /// }\n+    /// ```\n+    ///\n+    /// should be written\n+    ///\n+    /// ```rust,ignore\n+    /// let foo = if bar() {\n+    ///     42\n+    /// } else {\n+    ///     0\n+    /// };\n+    ///\n+    /// let baz = if bar() {\n+    ///     Some(42)\n+    /// } else {\n+    ///     None\n+    /// };\n+    /// ```\n+    pub USELESS_LET_IF_SEQ,\n+    style,\n+    \"unidiomatic `let mut` declaration followed by initialization in `if`\"\n+}\n+\n+declare_lint_pass!(LetIfSeq => [USELESS_LET_IF_SEQ]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block<'_>) {\n+        let mut it = block.stmts.iter().peekable();\n+        while let Some(stmt) = it.next() {\n+            if_chain! {\n+                if let Some(expr) = it.peek();\n+                if let hir::StmtKind::Local(ref local) = stmt.kind;\n+                if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n+                if let hir::StmtKind::Expr(ref if_) = expr.kind;\n+                if let Some((ref cond, ref then, ref else_)) = higher::if_block(&if_);\n+                if !used_in_expr(cx, canonical_id, cond);\n+                if let hir::ExprKind::Block(ref then, _) = then.kind;\n+                if let Some(value) = check_assign(cx, canonical_id, &*then);\n+                if !used_in_expr(cx, canonical_id, value);\n+                then {\n+                    let span = stmt.span.to(if_.span);\n+\n+                    let has_interior_mutability = !cx.tables.node_type(canonical_id).is_freeze(\n+                        cx.tcx,\n+                        cx.param_env,\n+                        span\n+                    );\n+                    if has_interior_mutability { return; }\n+\n+                    let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n+                        if let hir::ExprKind::Block(ref else_, _) = else_.kind {\n+                            if let Some(default) = check_assign(cx, canonical_id, else_) {\n+                                (else_.stmts.len() > 1, default)\n+                            } else if let Some(ref default) = local.init {\n+                                (true, &**default)\n+                            } else {\n+                                continue;\n+                            }\n+                        } else {\n+                            continue;\n+                        }\n+                    } else if let Some(ref default) = local.init {\n+                        (false, &**default)\n+                    } else {\n+                        continue;\n+                    };\n+\n+                    let mutability = match mode {\n+                        BindingAnnotation::RefMut | BindingAnnotation::Mutable => \"<mut> \",\n+                        _ => \"\",\n+                    };\n+\n+                    // FIXME: this should not suggest `mut` if we can detect that the variable is not\n+                    // use mutably after the `if`\n+\n+                    let sug = format!(\n+                        \"let {mut}{name} = if {cond} {{{then} {value} }} else {{{else} {default} }};\",\n+                        mut=mutability,\n+                        name=ident.name,\n+                        cond=snippet(cx, cond.span, \"_\"),\n+                        then=if then.stmts.len() > 1 { \" ..;\" } else { \"\" },\n+                        else=if default_multi_stmts { \" ..;\" } else { \"\" },\n+                        value=snippet(cx, value.span, \"<value>\"),\n+                        default=snippet(cx, default.span, \"<default>\"),\n+                    );\n+                    span_lint_and_then(cx,\n+                                       USELESS_LET_IF_SEQ,\n+                                       span,\n+                                       \"`if _ { .. } else { .. }` is an expression\",\n+                                       |diag| {\n+                                           diag.span_suggestion(\n+                                                span,\n+                                                \"it is more idiomatic to write\",\n+                                                sug,\n+                                                Applicability::HasPlaceholders,\n+                                            );\n+                                           if !mutability.is_empty() {\n+                                               diag.note(\"you might not need `mut` at all\");\n+                                           }\n+                                       });\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct UsedVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    id: hir::HirId,\n+    used: bool,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            if let hir::ExprKind::Path(ref qpath) = expr.kind;\n+            if let Res::Local(local_id) = qpath_res(self.cx, qpath, expr.hir_id);\n+            if self.id == local_id;\n+            then {\n+                self.used = true;\n+                return;\n+            }\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+fn check_assign<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: hir::HirId,\n+    block: &'tcx hir::Block<'_>,\n+) -> Option<&'tcx hir::Expr<'tcx>> {\n+    if_chain! {\n+        if block.expr.is_none();\n+        if let Some(expr) = block.stmts.iter().last();\n+        if let hir::StmtKind::Semi(ref expr) = expr.kind;\n+        if let hir::ExprKind::Assign(ref var, ref value, _) = expr.kind;\n+        if let hir::ExprKind::Path(ref qpath) = var.kind;\n+        if let Res::Local(local_id) = qpath_res(cx, qpath, var.hir_id);\n+        if decl == local_id;\n+        then {\n+            let mut v = UsedVisitor {\n+                cx,\n+                id: decl,\n+                used: false,\n+            };\n+\n+            for s in block.stmts.iter().take(block.stmts.len()-1) {\n+                intravisit::walk_stmt(&mut v, s);\n+\n+                if v.used {\n+                    return None;\n+                }\n+            }\n+\n+            return Some(value);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn used_in_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> bool {\n+    let mut v = UsedVisitor { cx, id, used: false };\n+    intravisit::walk_expr(&mut v, expr);\n+    v.used\n+}"}, {"sha": "710dec8d33fc9e085d83582857e7698fb99389a7", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f", "patch": "@@ -0,0 +1,119 @@\n+use if_chain::if_chain;\n+use rustc_hir::{Local, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{is_must_use_func_call, is_must_use_ty, match_type, paths, span_lint_and_help};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `let _ = <expr>`\n+    /// where expr is #[must_use]\n+    ///\n+    /// **Why is this bad?** It's better to explicitly\n+    /// handle the value of a #[must_use] expr\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn f() -> Result<u32, u32> {\n+    ///     Ok(0)\n+    /// }\n+    ///\n+    /// let _ = f();\n+    /// // is_ok() is marked #[must_use]\n+    /// let _ = f().is_ok();\n+    /// ```\n+    pub LET_UNDERSCORE_MUST_USE,\n+    restriction,\n+    \"non-binding let on a `#[must_use]` expression\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `let _ = sync_lock`\n+    ///\n+    /// **Why is this bad?** This statement immediately drops the lock instead of\n+    /// extending it's lifetime to the end of the scope, which is often not intended.\n+    /// To extend lock lifetime to the end of the scope, use an underscore-prefixed\n+    /// name instead (i.e. _lock). If you want to explicitly drop the lock,\n+    /// `std::mem::drop` conveys your intention better and is less error-prone.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// let _ = mutex.lock();\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// let _lock = mutex.lock();\n+    /// ```\n+    pub LET_UNDERSCORE_LOCK,\n+    correctness,\n+    \"non-binding let on a synchronization lock\"\n+}\n+\n+declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK]);\n+\n+const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n+    &paths::MUTEX_GUARD,\n+    &paths::RWLOCK_READ_GUARD,\n+    &paths::RWLOCK_WRITE_GUARD,\n+];\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnderscore {\n+    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local<'_>) {\n+        if in_external_macro(cx.tcx.sess, local.span) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let PatKind::Wild = local.pat.kind;\n+            if let Some(ref init) = local.init;\n+            then {\n+                let init_ty = cx.tables.expr_ty(init);\n+                let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n+                    GenericArgKind::Type(inner_ty) => {\n+                        SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n+                    },\n+\n+                    GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+                });\n+                if contains_sync_guard {\n+                    span_lint_and_help(\n+                        cx,\n+                        LET_UNDERSCORE_LOCK,\n+                        local.span,\n+                        \"non-binding let on a synchronization lock\",\n+                        None,\n+                        \"consider using an underscore-prefixed named \\\n+                            binding or dropping explicitly with `std::mem::drop`\"\n+                    )\n+                } else if is_must_use_ty(cx, cx.tables.expr_ty(init)) {\n+                    span_lint_and_help(\n+                        cx,\n+                        LET_UNDERSCORE_MUST_USE,\n+                        local.span,\n+                        \"non-binding let on an expression with `#[must_use]` type\",\n+                        None,\n+                        \"consider explicitly using expression value\"\n+                    )\n+                } else if is_must_use_func_call(cx, init) {\n+                    span_lint_and_help(\n+                        cx,\n+                        LET_UNDERSCORE_MUST_USE,\n+                        local.span,\n+                        \"non-binding let on a result of a `#[must_use]` function\",\n+                        None,\n+                        \"consider explicitly using function result\"\n+                    )\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "c995be5edc25cacc01b05afd9072f0484f6e6c9b", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d80ad47ab2468d5f6c9f4f0d3a41ee33ee479861", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "ec7c4531ed7169c770ddb2ce0d17dae648d9ab60", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "f7c7fd82d833b6c71a93c7b3b97fc854d93f9af7", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "added", "additions": 2550, "deletions": 0, "changes": 2550, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "b1345d0b751ae3b22acf860b2a591fcf547e1f9a", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "8a0e47a3d31c552bd0026c366991ba82ac8ed4b4", "filename": "src/tools/clippy/clippy_lints/src/main_recursion.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "0b346393ac3892cede0117ea618d13ab9f803d65", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "fecd91c7814dcc8eb8fa3c3f2c58c7bb4ca0cb49", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4071406cc84c3366cd29e94d6e0012038ebe0cf1", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "8f86535ef1e0f25aeea9de1792099c8541815bc0", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "added", "additions": 1242, "deletions": 0, "changes": 1242, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3f953655670cfcee0cb5cf6bffbc4b8e4afc28de", "filename": "src/tools/clippy/clippy_lints/src/mem_discriminant.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "c6ddc5de63b0ed3a962777c28a497dcbc25b1a4b", "filename": "src/tools/clippy/clippy_lints/src/mem_forget.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "ab6865bf0f3b7675edd08a150d2c0dd0c4eee121", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "06138ab9783c34f19d8b1340a05d846c20237a3f", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "aaed6d75048c6299dae5c8cf8138f7bd19cbc311", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3676dc5b09d21d7fdddcda2a79e4fd5677f9d780", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "added", "additions": 3657, "deletions": 0, "changes": 3657, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "bf9dd3c9369298ad06f81d97acdaef7f90ad6971", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "41c9ce7cda3e61ab780854fd44c566e5be870523", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "b02c993de526b0478cacbcfc990f17d752d454f4", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "e1d524c2231e4841bb1c91366c92a240f1156f0e", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "added", "additions": 696, "deletions": 0, "changes": 696, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "adfd8dfb1c18af5abcdb6d4eca6414e9803ed86f", "filename": "src/tools/clippy/clippy_lints/src/misc_early.rs", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4301157e16440ccbea1f95732b57d81335514ca5", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "2eefb6bbaf4245b2ec30d66a2f4ff53738a24f47", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "5300fd2215b391a7c2c40a52e30d34484893de12", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4ca90455bc4d1e81b44bbd1c8fdc51e61a99561a", "filename": "src/tools/clippy/clippy_lints/src/modulo_arithmetic.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "ed85d0315bd25d7d232de53e96c9ef97bf53ca0a", "filename": "src/tools/clippy/clippy_lints/src/multiple_crate_versions.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "0b9b7e1b8cc1b3e8e951d2f97dc43ff080390638", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "f7a20a74b85e21d2e04ddb2399c24dff18a233f8", "filename": "src/tools/clippy/clippy_lints/src/mut_mut.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "e5680482e5bfba5251f8151c5c869f83b2163670", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "119e0905ff442f32a5ecec979165c7951cf1681d", "filename": "src/tools/clippy/clippy_lints/src/mutable_debug_assertion.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4e1a8be4892e6b841a9c95a7774422dc76daf15a", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "efa77db822dd039215796cfd100dec22baf9160b", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "9ee875d7516eba3d29e70f4a372f8797f3ed85ce", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "e56489c6d434d609829f2d8676417d5c922fd98d", "filename": "src/tools/clippy/clippy_lints/src/needless_borrowed_ref.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "28183810df48977e3c776f568b58ab92633b6479", "filename": "src/tools/clippy/clippy_lints/src/needless_continue.rs", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "a21818701dacc2fd059bb7387a3dc3f572adc4ea", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4b2586877e562a0f84b6a88308b22ddeeb4d7bf6", "filename": "src/tools/clippy/clippy_lints/src/needless_update.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "54536ed57d3e9ba9753a7e4152b70fdf94eb797e", "filename": "src/tools/clippy/clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4681e990df88a1880efa4484c8aceb1ffb2ca5f5", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "a599667b8d8a8a9f7214c0774f24b3658abe817d", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "b8bfa676a16088cd6b412626308b033b833ddb74", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "bb257e5a542d98632f9f25c31bac6342c72504b7", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "45809b359866168f5c5cde87a15d1c4cc749b846", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "9d3b67988dbb55d35612886ba7f8bd207b6e3292", "filename": "src/tools/clippy/clippy_lints/src/open_options.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "66dfa20edb5e724890f43177332bfd720d941d44", "filename": "src/tools/clippy/clippy_lints/src/option_env_unwrap.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "b90fdc232e72c825d406fce6df2035820e3db488", "filename": "src/tools/clippy/clippy_lints/src/overflow_check_conditional.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "2cd9200ddb252d291fd818853a152484e9d82a6b", "filename": "src/tools/clippy/clippy_lints/src/panic_unimplemented.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "1445df41c452f4aaa2856353f235c686cc08aec6", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "bdbaf2695c8ef84c697cfcb0b5cb46fa1d93d9fb", "filename": "src/tools/clippy/clippy_lints/src/path_buf_push_overwrite.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "cc783baa687232f7c01f6d898a8b8d3c3aa3853a", "filename": "src/tools/clippy/clippy_lints/src/precedence.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "2cdf96714195abbbec79deccf117807c16714113", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "ffc59d43750e043974eb5f6a1dfb60381d66662f", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "ea654467b86687cfc522ff22471572cf9bef39fb", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d7ce2e66d69fbb3af1fa666169e3f5c8f0b79443", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d5cace0c647461b4b1440f99b969366e51b464dc", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "added", "additions": 613, "deletions": 0, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "b12c3c344ef4cbfc1fd61078157edf224d3e1bbb", "filename": "src/tools/clippy/clippy_lints/src/redundant_field_names.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "7ee298e9833f2ffd17b9ca83ab3fbcc2db051d3d", "filename": "src/tools/clippy/clippy_lints/src/redundant_pattern_matching.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "6fc07f91660ee4f6b6503e6afa7bc379fc877a7e", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "c6f57298c2601a7287e8608fe2b536dff326bc78", "filename": "src/tools/clippy/clippy_lints/src/redundant_static_lifetimes.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d5797468e9d53b8ab4bf142e5fed34b2c1fa3444", "filename": "src/tools/clippy/clippy_lints/src/reference.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "30084e3e1ffce993a19efd30787bfd4c15fadf93", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "5c9117d5b81cd6c62de819caa00c87e626fe8b77", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "6820d1620bd187abec727ba6025f09e385926dc5", "filename": "src/tools/clippy/clippy_lints/src/serde_api.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "11360b0ef84955caf66cc128cbbbb2132cc96554", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "8d767a7fec88d60d88a47eabb0eb3210917cda3c", "filename": "src/tools/clippy/clippy_lints/src/single_component_path_imports.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "fb3706be1c2135bc581f42b66c27b072b20dec0d", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "2c51271e312dee312c7dac5a126390682b362061", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "f1e223d9a48c65c95268893cac55b88854afcb68", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "c52e6a643f2a28e0348c764a4836d545db10a082", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "7b673e15b764a101c0c267229575a952d472433a", "filename": "src/tools/clippy/clippy_lints/src/tabs_in_doc_comments.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "bbb883aaf328719555988ccfa567131f07399061", "filename": "src/tools/clippy/clippy_lints/src/temporary_assignment.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "c6302ca03d918ddee1fbc9ad93a94ee6fc8d79ac", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "67121729663c6aa4ec62fa46af4c673c42318171", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "e24d2c4f495dba2aeb01e8ef09a590f0f9000348", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "added", "additions": 653, "deletions": 0, "changes": 653, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "1d0332c580500f73433486c69fe798ee57cd07b5", "filename": "src/tools/clippy/clippy_lints/src/transmuting_null.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "2c101220c5d6897f943b0799d615993283d2194e", "filename": "src/tools/clippy/clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "7018fa6804ba71949c7892daf05d3c21ddbe4168", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "6d49f50d550e858d0a0f87bb92fa3e275f093e95", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "added", "additions": 2562, "deletions": 0, "changes": 2562, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d073c197656c61b5cac6e0d557f3ad3ae19ddd58", "filename": "src/tools/clippy/clippy_lints/src/unicode.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4e077b95b5c68024c9eaca1f78c343c62a2dfe9a", "filename": "src/tools/clippy/clippy_lints/src/unnamed_address.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "86c469a4dccf7377b62b916eaadd375f19f13c8c", "filename": "src/tools/clippy/clippy_lints/src/unsafe_removed_from_name.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "b85134e3d7a9aaa7a8f565f672408f2e3133061f", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3d5e2f9fd21556f33562794350a22915d1983d2c", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "5235c98efab13d1fa40884bb513ba02f35064fe6", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "f8e1aff33e7731f5e887c6a2fa5958b2b7664076", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4dcf6c105ec63666a7136c876b9b04d901cfbf52", "filename": "src/tools/clippy/clippy_lints/src/utils/attrs.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "74601008dca41e8ea1b74169af87ae55d653793f", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "added", "additions": 757, "deletions": 0, "changes": 757, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4192a26d3c80040ed440dd74f355db993cf39e67", "filename": "src/tools/clippy/clippy_lints/src/utils/camel_case.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fcamel_case.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "7a18d5e818fb1c607298209b6b344ef6a484021d", "filename": "src/tools/clippy/clippy_lints/src/utils/comparisons.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4b81ff33495c7c089c0ad55ffc96f5336958aa8a", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "522932f054d894eef06d81b7a53203fc255f9d89", "filename": "src/tools/clippy/clippy_lints/src/utils/constants.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconstants.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "24a1bdf1883f6b86edbe53f755d8a26821ca4265", "filename": "src/tools/clippy/clippy_lints/src/utils/diagnostics.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "33fba7df8d33660c13f03e7d397f586f76b09e63", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "02b721fd378ff5afb1137f60e16e1e60711e77bc", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "added", "additions": 694, "deletions": 0, "changes": 694, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "7e8c61ba24a22a5c5aa0d812f75b080ec0b50830", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "5bf9acdc5f7ce21e25144e2aa0d3b6cc3055ff58", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "added", "additions": 658, "deletions": 0, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "04b4b42376193c7dd31c1ce552db5bf49888a89e", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "added", "additions": 1491, "deletions": 0, "changes": 1491, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "99413153d49bbc08f28dd38deaabef9e62239988", "filename": "src/tools/clippy/clippy_lints/src/utils/numeric_literal.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "ca2c4ade15565bc0d45c1e3c607fb0c883a4b788", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "240bf2449cb5ebbbc928be17beb60bf83e870efb", "filename": "src/tools/clippy/clippy_lints/src/utils/ptr.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "a8fe637d3d978f0473e5a904f271a8dc48b970d6", "filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "273288c3d52c589db88d2f507b32e75534f24580", "filename": "src/tools/clippy/clippy_lints/src/utils/sym.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsym.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "c14da6aacea047de74149e8d09921aa20ca1e33f", "filename": "src/tools/clippy/clippy_lints/src/utils/usage.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "1174f421577493b20c80dd230057bda7d116c57a", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4d8d4438d881dade5084b16ccbb730e2019a4438", "filename": "src/tools/clippy/clippy_lints/src/verbose_file_reads.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d8d48eb15358d19d70cb82b07343e476714440ae", "filename": "src/tools/clippy/clippy_lints/src/wildcard_dependencies.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "f3038861cee2431c41795dd5db020f0fcedc16fd", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "5ad43ad55a36ab7ae3cb7012ee765dba490764f9", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "fb4700d8743fdab5465c66a4668a97d66702de57", "filename": "src/tools/clippy/clippy_lints/src/zero_div_zero.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "7a235b215d38d418b8ac0835f404706e72efc5f8", "filename": "src/tools/clippy/clippy_workspace_tests/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2FCargo.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "b322eca1db51d2cf71da534d254f47be4213c6d1", "filename": "src/tools/clippy/clippy_workspace_tests/src/main.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsrc%2Fmain.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "83ea5868160bbaeae2cd25b3a37a4e0b4ba38b2c", "filename": "src/tools/clippy/clippy_workspace_tests/subcrate/Cargo.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2FCargo.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "src/tools/clippy/clippy_workspace_tests/subcrate/src/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2Fsrc%2Flib.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "9ad1315c17521c146f2d396ae38f5a9f7b1d8017", "filename": "src/tools/clippy/doc/adding_lints.md", "status": "added", "additions": 477, "deletions": 0, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "259696658eababfe7496dfe0907f2d15f72399a6", "filename": "src/tools/clippy/doc/backport.md", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fdoc%2Fbackport.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fdoc%2Fbackport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fbackport.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "0b80cce6d23eaa15df2644b130267e78c30d1d0c", "filename": "src/tools/clippy/doc/changelog_update.md", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fdoc%2Fchangelog_update.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fdoc%2Fchangelog_update.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fchangelog_update.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "9d69fa8a7f69a3f17de0df63721b723fca6b4f8b", "filename": "src/tools/clippy/doc/release.md", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fdoc%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fdoc%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Frelease.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "fcd7abbf3f1693cc100c0e1f4a4e4326d26a40f3", "filename": "src/tools/clippy/etc/relicense/RELICENSE_DOCUMENTATION.md", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2FRELICENSE_DOCUMENTATION.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2FRELICENSE_DOCUMENTATION.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2FRELICENSE_DOCUMENTATION.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "e81ebf21484982358f88c848220735a794311840", "filename": "src/tools/clippy/etc/relicense/contributors.txt", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2Fcontributors.txt", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2Fcontributors.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2Fcontributors.txt?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "52c25eb201fb30d8b4aafe731d4691e169328cbd", "filename": "src/tools/clippy/etc/relicense/relicense_comments.txt", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2Frelicense_comments.txt", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2Frelicense_comments.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fetc%2Frelicense%2Frelicense_comments.txt?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "75ab17588a7f4415fdce9be4a565d3745a7b9491", "filename": "src/tools/clippy/mini-macro/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fmini-macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fmini-macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fmini-macro%2FCargo.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "92b6f7015557701aaee4c7fb07aa4fb2b26c5d02", "filename": "src/tools/clippy/mini-macro/src/lib.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fmini-macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fmini-macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fmini-macro%2Fsrc%2Flib.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "bf867e0ae5b6c08df1118a2ece970677bc479f1b", "filename": "src/tools/clippy/rust-toolchain", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "6f0fc5bee8f091cae4557d9512e9dbd2bea1e932", "filename": "src/tools/clippy/rustc_tools_util/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frustc_tools_util%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frustc_tools_util%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frustc_tools_util%2FCargo.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "6027538dc4ab22a74ee3a0299a2849667b450dcf", "filename": "src/tools/clippy/rustc_tools_util/README.md", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frustc_tools_util%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frustc_tools_util%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frustc_tools_util%2FREADME.md?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "ff2a7de572571d850872fb2dec4e081bc9224404", "filename": "src/tools/clippy/rustc_tools_util/src/lib.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frustc_tools_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frustc_tools_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frustc_tools_util%2Fsrc%2Flib.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "f1241e74b0a3d40e4bfb64912b27fec9711efb2f", "filename": "src/tools/clippy/rustfmt.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Frustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frustfmt.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "6038ed697f91ea7f2ccbec3672c6ac63bb2a695f", "filename": "src/tools/clippy/setup-toolchain.sh", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsetup-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsetup-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsetup-toolchain.sh?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "2c699998ea90e237cdb708de9eb62507f3d0c60c", "filename": "src/tools/clippy/src/driver.rs", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "c817d83b33aeb12df5817b1c5a2e891c3423df17", "filename": "src/tools/clippy/src/lintlist/lint.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Flint.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "72675c25175c98fdb421d25a79ed457ce795344e", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "added", "additions": 2633, "deletions": 0, "changes": 2633, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "bc43a34ed5d4aaa4e843306abfebab9970a955f2", "filename": "src/tools/clippy/src/main.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "624ca892add310fa3acd8197a9cd33c034781106", "filename": "src/tools/clippy/tests/auxiliary/test_macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fauxiliary%2Ftest_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fauxiliary%2Ftest_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fauxiliary%2Ftest_macro.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3c385343f7010a276050589bf0e23e9e13bde45d", "filename": "src/tools/clippy/tests/cargo/mod.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fcargo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fcargo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcargo%2Fmod.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "de2cf6d7873f8dac5276c3768531eaeb343a0661", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "81af3d3033b23c268a152258d74a30a8cd0d4ecc", "filename": "src/tools/clippy/tests/dogfood.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3aff8741f6051d7e6b95e525bc1a37812b3e2173", "filename": "src/tools/clippy/tests/fmt.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "a78273ce0da41238ae7a2f5ee4842b001cc8a61b", "filename": "src/tools/clippy/tests/integration.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d87bb4be3c3f976e26e94ddfad4135d6993cf45d", "filename": "src/tools/clippy/tests/missing-test-files.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fmissing-test-files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fmissing-test-files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fmissing-test-files.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "823e01a33b96172e13855c6c023599f2852e71f9", "filename": "src/tools/clippy/tests/ui-toml/bad_toml/clippy.toml", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3b9458fc2840e7494cab39c77c379854f0ddc777", "filename": "src/tools/clippy/tests/ui-toml/bad_toml/conf_bad_toml.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fconf_bad_toml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fconf_bad_toml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fconf_bad_toml.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "28c1a568a632befdff4d59cf085b3fbe065f458a", "filename": "src/tools/clippy/tests/ui-toml/bad_toml/conf_bad_toml.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fconf_bad_toml.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fconf_bad_toml.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml%2Fconf_bad_toml.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "168675394d7f45124940fcfa3433aab378c1fbd8", "filename": "src/tools/clippy/tests/ui-toml/bad_toml_type/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "8a0062423ad168f2cf09730cbb234d2c689a9f47", "filename": "src/tools/clippy/tests/ui-toml/bad_toml_type/conf_bad_type.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "efd02bcbb6e28968bdb1e227e74a4190289c1110", "filename": "src/tools/clippy/tests/ui-toml/bad_toml_type/conf_bad_type.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "ac47b195042ebfb3682978d7847888ef49a2f40f", "filename": "src/tools/clippy/tests/ui-toml/conf_deprecated_key/clippy.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "2577c1eef92bc5b987edef4cf3aa9d91be3e81f7", "filename": "src/tools/clippy/tests/ui-toml/conf_deprecated_key/conf_deprecated_key.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "34267c0daf7c2cfd50fc647b6cd3f2b891e32856", "filename": "src/tools/clippy/tests/ui-toml/conf_deprecated_key/conf_deprecated_key.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "022eec3e0e2bf2f021fd61709cb87746ee59425b", "filename": "src/tools/clippy/tests/ui-toml/fn_params_excessive_bools/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "42897b389edfc6e82d4279b78d1ca7633541ec20", "filename": "src/tools/clippy/tests/ui-toml/fn_params_excessive_bools/test.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Ftest.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d05adc3d36e3350d97cc31a27c3704321af0b254", "filename": "src/tools/clippy/tests/ui-toml/fn_params_excessive_bools/test.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffn_params_excessive_bools%2Ftest.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "951dbb523d9558c5b75e5197f0df52e4b8ee9448", "filename": "src/tools/clippy/tests/ui-toml/functions_maxlines/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "a47677a1f3a2e02c8bb6a5b3bdf3f742c6954e6c", "filename": "src/tools/clippy/tests/ui-toml/functions_maxlines/test.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4b77ac551e770f174b59e666841fbb2267cc2b76", "filename": "src/tools/clippy/tests/ui-toml/functions_maxlines/test.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "a1dd6b2f0819cb67361baacf14d6e51f1fcac992", "filename": "src/tools/clippy/tests/ui-toml/good_toml_no_false_negatives/clippy.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "270b9c5c43c138883d76aa4c7e4733576b6d68c7", "filename": "src/tools/clippy/tests/ui-toml/good_toml_no_false_negatives/conf_no_false_negatives.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fconf_no_false_negatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fconf_no_false_negatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fgood_toml_no_false_negatives%2Fconf_no_false_negatives.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3912ab542777dc5723cd4d602b157cec48469e41", "filename": "src/tools/clippy/tests/ui-toml/struct_excessive_bools/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "242984680e163bd9eef1de3b132ffe93c7663c73", "filename": "src/tools/clippy/tests/ui-toml/struct_excessive_bools/test.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Ftest.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "65861d10d0fdb52a37ac512694ce1f9161d75ebc", "filename": "src/tools/clippy/tests/ui-toml/struct_excessive_bools/test.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fstruct_excessive_bools%2Ftest.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "6abe5a3bbc2737feba84d51919176142eb8c7fd4", "filename": "src/tools/clippy/tests/ui-toml/toml_blacklist/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "cb35d0e8589d2e4f2052da05477757d0d609b5d3", "filename": "src/tools/clippy/tests/ui-toml/toml_blacklist/conf_french_blacklisted_name.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fconf_french_blacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fconf_french_blacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fconf_french_blacklisted_name.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "84ba77851f77e91bae30f9241053a44bf08e3170", "filename": "src/tools/clippy/tests/ui-toml/toml_blacklist/conf_french_blacklisted_name.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fconf_french_blacklisted_name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fconf_french_blacklisted_name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_blacklist%2Fconf_french_blacklisted_name.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3b96f1fd000bb0323c3ab37ae533ffd5637cc78f", "filename": "src/tools/clippy/tests/ui-toml/toml_trivially_copy/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "19019a2541631767abf56555c0411d03465af1af", "filename": "src/tools/clippy/tests/ui-toml/toml_trivially_copy/test.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "912761a8f009c2dfd2e856d7e62d12ad5113e94c", "filename": "src/tools/clippy/tests/ui-toml/toml_trivially_copy/test.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "554b87cc50be176bd8cb1920fbc26b11d0e557a0", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/clippy.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "a47569f62a3229590feb453f4a543ed7ab98317d", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "18f5d994ba8aaf1df45a039a5275c14c6264f49f", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "7028b251ea0307bb669524afb702a8d62a038924", "filename": "src/tools/clippy/tests/ui-toml/update-all-references.sh", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-all-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-all-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-all-references.sh?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "50d42678734e9caca32b8d6c806ed576f4b04a8e", "filename": "src/tools/clippy/tests/ui-toml/update-references.sh", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-references.sh?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "039ea47fc32d888f3a6233ab476d11eba84566e2", "filename": "src/tools/clippy/tests/ui-toml/vec_box_sized/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "bf04bee16373c3c9e22f09bc896632540e6705f5", "filename": "src/tools/clippy/tests/ui-toml/vec_box_sized/test.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Ftest.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3bdeca0bc8774a77fdd77f42f0ccdfd23fc03bc5", "filename": "src/tools/clippy/tests/ui-toml/vec_box_sized/test.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "42a1067b95edd2a3d4590c72c12bfb4a0dbc23b1", "filename": "src/tools/clippy/tests/ui-toml/zero_single_char_names/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fzero_single_char_names%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fzero_single_char_names%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fzero_single_char_names%2Fclippy.toml?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "22aaa242b9b9d94641798dac2ccaf349b1d9d8ca", "filename": "src/tools/clippy/tests/ui-toml/zero_single_char_names/zero_single_char_names.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fzero_single_char_names%2Fzero_single_char_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fzero_single_char_names%2Fzero_single_char_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fzero_single_char_names%2Fzero_single_char_names.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "d205b383d1ff64c745e1dd5b2842c22a1f66b570", "filename": "src/tools/clippy/tests/ui/absurd-extreme-comparisons.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fabsurd-extreme-comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fabsurd-extreme-comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fabsurd-extreme-comparisons.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "6de554378aaa97f1d0537bb1b7703ae59b9f46fc", "filename": "src/tools/clippy/tests/ui/absurd-extreme-comparisons.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fabsurd-extreme-comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fabsurd-extreme-comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fabsurd-extreme-comparisons.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "fb57a0becbb25e81b751bef0e1be0ddb0b559253", "filename": "src/tools/clippy/tests/ui/approx_const.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "98b85443f0b70dcab0ab82e4a8b2e087cc1acb35", "filename": "src/tools/clippy/tests/ui/approx_const.stderr", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "e01ba0c64df325535f88bb0909640657002f4047", "filename": "src/tools/clippy/tests/ui/as_conversions.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "312d3a7460ebe4a34a3753bcf01e9e17dee2693c", "filename": "src/tools/clippy/tests/ui/as_conversions.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "60d721c2f20495367b9a8b530845dc93e89c1cbb", "filename": "src/tools/clippy/tests/ui/assertions_on_constants.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "8f09c8ce9d52aec82b1fb2193ccb6df05dc480ba", "filename": "src/tools/clippy/tests/ui/assertions_on_constants.stderr", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "52b1b3afe16fe2ca265cbd0c7b420c9bc8a1e391", "filename": "src/tools/clippy/tests/ui/assign_ops.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.fixed?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "527a46b2c2bb90f4e0485bc925bdd5e55f4c6d14", "filename": "src/tools/clippy/tests/ui/assign_ops.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "3486bd8da4d07ed98b2ec55cf49949508d3c9603", "filename": "src/tools/clippy/tests/ui/assign_ops.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "4703a8c77778857405266a60d5f20977e1bc59ef", "filename": "src/tools/clippy/tests/ui/assign_ops2.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops2.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "70b15d18a568b878ea39cb6c2efe9869b1285828", "filename": "src/tools/clippy/tests/ui/assign_ops2.stderr", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassign_ops2.stderr?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}, {"sha": "cdbde79b19ebf53f8db58975f6258a9bd13e6abc", "filename": "src/tools/clippy/tests/ui/atomic_ordering_bool.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fatomic_ordering_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce9fae97abb255c9fc6c994f50a052be4010a6f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fatomic_ordering_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fatomic_ordering_bool.rs?ref=bce9fae97abb255c9fc6c994f50a052be4010a6f"}]}