{"sha": "54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZTNmZTdhZjBjNDQ4ODU4ZmIxYWM5YzJkNDhkYThiYzRmNmYxZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-07T03:43:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-07T03:43:14Z"}, "message": "Auto merge of #43062 - sfackler:connect-timeout, r=alexcrichton\n\nImplement TcpStream::connect_timeout\n\nThis breaks the \"single syscall rule\", but it's really annoying to hand\nwrite and is pretty foundational.\n\nr? @alexcrichton\n\ncc @rust-lang/libs", "tree": {"sha": "764f8b3e0db4fcb873e062698d1e8eaf5dd6b1f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/764f8b3e0db4fcb873e062698d1e8eaf5dd6b1f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "html_url": "https://github.com/rust-lang/rust/commit/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b80b659d674fa19b2b48142e4f7974544bc8d5f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b80b659d674fa19b2b48142e4f7974544bc8d5f6", "html_url": "https://github.com/rust-lang/rust/commit/b80b659d674fa19b2b48142e4f7974544bc8d5f6"}, {"sha": "8c92da3c518111b28f0b5fb297ab719bf353cdc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c92da3c518111b28f0b5fb297ab719bf353cdc6", "html_url": "https://github.com/rust-lang/rust/commit/8c92da3c518111b28f0b5fb297ab719bf353cdc6"}], "stats": {"total": 195, "additions": 193, "deletions": 2}, "files": [{"sha": "fdeca8bc5cac3836f2c22e67860fe6410b3b4c6e", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "patch": "@@ -134,6 +134,24 @@ impl TcpStream {\n         super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n     }\n \n+    /// Opens a TCP connection to a remote host with a timeout.\n+    ///\n+    /// Unlike `connect`, `connect_timeout` takes a single [`SocketAddr`] since\n+    /// timeout must be applied to individual addresses.\n+    ///\n+    /// It is an error to pass a zero `Duration` to this function.\n+    ///\n+    /// Unlike other methods on `TcpStream`, this does not correspond to a\n+    /// single system call. It instead calls `connect` in nonblocking mode and\n+    /// then uses an OS-specific mechanism to await the completion of the\n+    /// connection request.\n+    ///\n+    /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+    #[unstable(feature = \"tcpstream_connect_timeout\", issue = \"43709\")]\n+    pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {\n+        net_imp::TcpStream::connect_timeout(addr, timeout).map(TcpStream)\n+    }\n+\n     /// Returns the socket address of the remote peer of this TCP connection.\n     ///\n     /// # Examples\n@@ -1509,4 +1527,19 @@ mod tests {\n             t!(txdone.send(()));\n         })\n     }\n+\n+    #[test]\n+    fn connect_timeout_unroutable() {\n+        // this IP is unroutable, so connections should always time out.\n+        let addr = \"10.255.255.1:80\".parse().unwrap();\n+        let e = TcpStream::connect_timeout(&addr, Duration::from_millis(250)).unwrap_err();\n+        assert_eq!(e.kind(), io::ErrorKind::TimedOut);\n+    }\n+\n+    #[test]\n+    fn connect_timeout_valid() {\n+        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n+        let addr = listener.local_addr().unwrap();\n+        TcpStream::connect_timeout(&addr, Duration::from_secs(2)).unwrap();\n+    }\n }"}, {"sha": "5d1067e4039bad6908be7af1d481cfe4df0a79fa", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "patch": "@@ -32,6 +32,10 @@ impl TcpStream {\n         Ok(TcpStream(File::open(&Path::new(path.as_str()), &options)?))\n     }\n \n+    pub fn connect_timeout(_addr: &SocketAddr, _timeout: Duration) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::connect_timeout not implemented\"))\n+    }\n+\n     pub fn duplicate(&self) -> Result<TcpStream> {\n         Ok(TcpStream(self.0.dup(&[])?))\n     }"}, {"sha": "668b2f92aba0791ad9148fb2a3c1f64d683a21f3", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "patch": "@@ -17,7 +17,8 @@ use str;\n use sys::fd::FileDesc;\n use sys_common::{AsInner, FromInner, IntoInner};\n use sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n-use time::Duration;\n+use time::{Duration, Instant};\n+use cmp;\n \n pub use sys::{cvt, cvt_r};\n pub extern crate libc as netc;\n@@ -122,6 +123,70 @@ impl Socket {\n         }\n     }\n \n+    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n+        self.set_nonblocking(true)?;\n+        let r = unsafe {\n+            let (addrp, len) = addr.into_inner();\n+            cvt(libc::connect(self.0.raw(), addrp, len))\n+        };\n+        self.set_nonblocking(false)?;\n+\n+        match r {\n+            Ok(_) => return Ok(()),\n+            // there's no ErrorKind for EINPROGRESS :(\n+            Err(ref e) if e.raw_os_error() == Some(libc::EINPROGRESS) => {}\n+            Err(e) => return Err(e),\n+        }\n+\n+        let mut pollfd = libc::pollfd {\n+            fd: self.0.raw(),\n+            events: libc::POLLOUT,\n+            revents: 0,\n+        };\n+\n+        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"cannot set a 0 duration timeout\"));\n+        }\n+\n+        let start = Instant::now();\n+\n+        loop {\n+            let elapsed = start.elapsed();\n+            if elapsed >= timeout {\n+                return Err(io::Error::new(io::ErrorKind::TimedOut, \"connection timed out\"));\n+            }\n+\n+            let timeout = timeout - elapsed;\n+            let mut timeout = timeout.as_secs()\n+                .saturating_mul(1_000)\n+                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n+            if timeout == 0 {\n+                timeout = 1;\n+            }\n+\n+            let timeout = cmp::min(timeout, c_int::max_value() as u64) as c_int;\n+\n+            match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n+                -1 => {\n+                    let err = io::Error::last_os_error();\n+                    if err.kind() != io::ErrorKind::Interrupted {\n+                        return Err(err);\n+                    }\n+                }\n+                0 => {}\n+                _ => {\n+                    if pollfd.revents & libc::POLLOUT == 0 {\n+                        if let Some(e) = self.take_error()? {\n+                            return Err(e);\n+                        }\n+                    }\n+                    return Ok(());\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n                   -> io::Result<Socket> {\n         // Unfortunately the only known way right now to accept a socket and"}, {"sha": "4785cefd6b4b7a78a8c782eb98ebab9a72b61397", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "patch": "@@ -298,6 +298,8 @@ pub const PIPE_TYPE_BYTE: DWORD = 0x00000000;\n pub const PIPE_REJECT_REMOTE_CLIENTS: DWORD = 0x00000008;\n pub const PIPE_READMODE_BYTE: DWORD = 0x00000000;\n \n+pub const FD_SETSIZE: usize = 64;\n+\n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n@@ -837,6 +839,26 @@ pub struct CONSOLE_READCONSOLE_CONTROL {\n }\n pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;\n \n+#[repr(C)]\n+#[derive(Copy)]\n+pub struct fd_set {\n+    pub fd_count: c_uint,\n+    pub fd_array: [SOCKET; FD_SETSIZE],\n+}\n+\n+impl Clone for fd_set {\n+    fn clone(&self) -> fd_set {\n+        *self\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct timeval {\n+    pub tv_sec: c_long,\n+    pub tv_usec: c_long,\n+}\n+\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: WORD,\n                       lpWSAData: LPWSADATA) -> c_int;\n@@ -1125,6 +1147,11 @@ extern \"system\" {\n                                lpOverlapped: LPOVERLAPPED,\n                                lpNumberOfBytesTransferred: LPDWORD,\n                                bWait: BOOL) -> BOOL;\n+    pub fn select(nfds: c_int,\n+                  readfds: *mut fd_set,\n+                  writefds: *mut fd_set,\n+                  exceptfds: *mut fd_set,\n+                  timeout: *const timeval) -> c_int;\n }\n \n // Functions that aren't available on Windows XP, but we still use them and just"}, {"sha": "cd8acff6b0cb8eac7f027719b39af2678be725e8", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "patch": "@@ -12,7 +12,7 @@\n \n use cmp;\n use io::{self, Read};\n-use libc::{c_int, c_void, c_ulong};\n+use libc::{c_int, c_void, c_ulong, c_long};\n use mem;\n use net::{SocketAddr, Shutdown};\n use ptr;\n@@ -115,6 +115,60 @@ impl Socket {\n         Ok(socket)\n     }\n \n+    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n+        self.set_nonblocking(true)?;\n+        let r = unsafe {\n+            let (addrp, len) = addr.into_inner();\n+            cvt(c::connect(self.0, addrp, len))\n+        };\n+        self.set_nonblocking(false)?;\n+\n+        match r {\n+            Ok(_) => return Ok(()),\n+            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}\n+            Err(e) => return Err(e),\n+        }\n+\n+        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"cannot set a 0 duration timeout\"));\n+        }\n+\n+        let mut timeout = c::timeval {\n+            tv_sec: timeout.as_secs() as c_long,\n+            tv_usec: (timeout.subsec_nanos() / 1000) as c_long,\n+        };\n+        if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+            timeout.tv_usec = 1;\n+        }\n+\n+        let fds = unsafe {\n+            let mut fds = mem::zeroed::<c::fd_set>();\n+            fds.fd_count = 1;\n+            fds.fd_array[0] = self.0;\n+            fds\n+        };\n+\n+        let mut writefds = fds;\n+        let mut errorfds = fds;\n+\n+        let n = unsafe {\n+            cvt(c::select(1, ptr::null_mut(), &mut writefds, &mut errorfds, &timeout))?\n+        };\n+\n+        match n {\n+            0 => Err(io::Error::new(io::ErrorKind::TimedOut, \"connection timed out\")),\n+            _ => {\n+                if writefds.fd_count != 1 {\n+                    if let Some(e) = self.take_error()? {\n+                        return Err(e);\n+                    }\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n     pub fn accept(&self, storage: *mut c::SOCKADDR,\n                   len: *mut c_int) -> io::Result<Socket> {\n         let socket = unsafe {"}, {"sha": "5775dd4f1fcd44b89e170e5ce6e11b55d61f7dc1", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=54e3fe7af0c448858fb1ac9c2d48da8bc4f6f1f8", "patch": "@@ -215,6 +215,14 @@ impl TcpStream {\n         Ok(TcpStream { inner: sock })\n     }\n \n+    pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {\n+        init();\n+\n+        let sock = Socket::new(addr, c::SOCK_STREAM)?;\n+        sock.connect_timeout(addr, timeout)?;\n+        Ok(TcpStream { inner: sock })\n+    }\n+\n     pub fn socket(&self) -> &Socket { &self.inner }\n \n     pub fn into_socket(self) -> Socket { self.inner }"}]}