{"sha": "a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "node_id": "C_kwDOAAsO6NoAKGEyZTdlNGU0MmNjODllZmQwNWRmM2MwNDQ5M2E0ZGQzOTZjZWJjNDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T12:50:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T12:50:59Z"}, "message": "Auto merge of #12588 - Veykril:completions, r=Veykril\n\ninternal: More completion reorganizing", "tree": {"sha": "c0bd57c2d2accb28c98b6800201f9badbf0d3b3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0bd57c2d2accb28c98b6800201f9badbf0d3b3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "html_url": "https://github.com/rust-lang/rust/commit/a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "427061da19723f2206fe4dcb175c9c43b9a6193d", "url": "https://api.github.com/repos/rust-lang/rust/commits/427061da19723f2206fe4dcb175c9c43b9a6193d", "html_url": "https://github.com/rust-lang/rust/commit/427061da19723f2206fe4dcb175c9c43b9a6193d"}, {"sha": "90483321ee0b47d48a5019bd9bbb11b45a24ac84", "url": "https://api.github.com/repos/rust-lang/rust/commits/90483321ee0b47d48a5019bd9bbb11b45a24ac84", "html_url": "https://github.com/rust-lang/rust/commit/90483321ee0b47d48a5019bd9bbb11b45a24ac84"}], "stats": {"total": 800, "additions": 411, "deletions": 389}, "files": [{"sha": "c1081dbde32fe2b5d3ff555411c63b89a8bf154b", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 135, "deletions": 18, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -22,12 +22,15 @@ pub(crate) mod vis;\n \n use std::iter;\n \n-use hir::{db::HirDatabase, known, ScopeDef};\n+use hir::{known, ScopeDef};\n use ide_db::SymbolKind;\n use syntax::ast;\n \n use crate::{\n-    context::Visible,\n+    context::{\n+        ItemListKind, NameContext, NameKind, NameRefContext, NameRefKind, PathKind, PatternContext,\n+        TypeLocation, Visible,\n+    },\n     item::Builder,\n     render::{\n         const_::render_const,\n@@ -43,22 +46,6 @@ use crate::{\n     CompletionContext, CompletionItem, CompletionItemKind,\n };\n \n-fn module_or_attr(db: &dyn HirDatabase, def: ScopeDef) -> Option<ScopeDef> {\n-    match def {\n-        ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_attr(db) => Some(def),\n-        ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => Some(def),\n-        _ => None,\n-    }\n-}\n-\n-fn module_or_fn_macro(db: &dyn HirDatabase, def: ScopeDef) -> Option<ScopeDef> {\n-    match def {\n-        ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_fn_like(db) => Some(def),\n-        ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => Some(def),\n-        _ => None,\n-    }\n-}\n-\n /// Represents an in-progress set of completions being built.\n #[derive(Debug, Default)]\n pub struct Completions {\n@@ -181,6 +168,15 @@ impl Completions {\n         self.add(render_resolution_simple(RenderContext::new(ctx), local_name, resolution).build());\n     }\n \n+    pub(crate) fn add_module(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        module: hir::Module,\n+        local_name: hir::Name,\n+    ) {\n+        self.add_resolution(ctx, local_name, hir::ScopeDef::ModuleDef(module.into()));\n+    }\n+\n     pub(crate) fn add_macro(\n         &mut self,\n         ctx: &CompletionContext,\n@@ -437,3 +433,124 @@ fn enum_variants_with_paths(\n         }\n     }\n }\n+\n+pub(super) fn complete_name(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    NameContext { name, kind }: &NameContext,\n+) {\n+    match kind {\n+        NameKind::Const => {\n+            item_list::trait_impl::complete_trait_impl_const(acc, ctx, name);\n+        }\n+        NameKind::Function => {\n+            item_list::trait_impl::complete_trait_impl_fn(acc, ctx, name);\n+        }\n+        NameKind::IdentPat(pattern_ctx) => complete_patterns(acc, ctx, pattern_ctx),\n+        NameKind::Module(mod_under_caret) => {\n+            mod_::complete_mod(acc, ctx, mod_under_caret);\n+        }\n+        NameKind::TypeAlias => {\n+            item_list::trait_impl::complete_trait_impl_type_alias(acc, ctx, name);\n+        }\n+        NameKind::RecordField => {\n+            field::complete_field_list_record_variant(acc, ctx);\n+        }\n+        NameKind::ConstParam\n+        | NameKind::Enum\n+        | NameKind::MacroDef\n+        | NameKind::MacroRules\n+        | NameKind::Rename\n+        | NameKind::SelfParam\n+        | NameKind::Static\n+        | NameKind::Struct\n+        | NameKind::Trait\n+        | NameKind::TypeParam\n+        | NameKind::Union\n+        | NameKind::Variant => (),\n+    }\n+}\n+\n+pub(super) fn complete_name_ref(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    NameRefContext { nameref, kind }: &NameRefContext,\n+) {\n+    match kind {\n+        NameRefKind::Path(path_ctx) => {\n+            flyimport::import_on_the_fly_path(acc, ctx, path_ctx);\n+\n+            match &path_ctx.kind {\n+                PathKind::Expr { expr_ctx } => {\n+                    expr::complete_expr_path(acc, ctx, path_ctx, expr_ctx);\n+\n+                    dot::complete_undotted_self(acc, ctx, path_ctx, expr_ctx);\n+                    item_list::complete_item_list_in_expr(acc, ctx, path_ctx, expr_ctx);\n+                    record::complete_record_expr_func_update(acc, ctx, path_ctx, expr_ctx);\n+                    snippet::complete_expr_snippet(acc, ctx, path_ctx, expr_ctx);\n+                }\n+                PathKind::Type { location } => {\n+                    r#type::complete_type_path(acc, ctx, path_ctx, location);\n+\n+                    match location {\n+                        TypeLocation::TupleField => {\n+                            field::complete_field_list_tuple_variant(acc, ctx, path_ctx);\n+                        }\n+                        TypeLocation::TypeAscription(ascription) => {\n+                            r#type::complete_ascribed_type(acc, ctx, path_ctx, ascription);\n+                        }\n+                        TypeLocation::GenericArgList(_)\n+                        | TypeLocation::TypeBound\n+                        | TypeLocation::ImplTarget\n+                        | TypeLocation::ImplTrait\n+                        | TypeLocation::Other => (),\n+                    }\n+                }\n+                PathKind::Attr { attr_ctx } => {\n+                    attribute::complete_attribute_path(acc, ctx, path_ctx, attr_ctx);\n+                }\n+                PathKind::Derive { existing_derives } => {\n+                    attribute::complete_derive_path(acc, ctx, path_ctx, existing_derives);\n+                }\n+                PathKind::Item { kind } => {\n+                    item_list::complete_item_list(acc, ctx, path_ctx, kind);\n+\n+                    snippet::complete_item_snippet(acc, ctx, path_ctx, kind);\n+                    if let ItemListKind::TraitImpl(impl_) = kind {\n+                        item_list::trait_impl::complete_trait_impl_item_by_name(\n+                            acc, ctx, path_ctx, nameref, impl_,\n+                        );\n+                    }\n+                }\n+                PathKind::Pat { .. } => {\n+                    pattern::complete_pattern_path(acc, ctx, path_ctx);\n+                }\n+                PathKind::Vis { has_in_token } => {\n+                    vis::complete_vis_path(acc, ctx, path_ctx, has_in_token);\n+                }\n+                PathKind::Use => {\n+                    use_::complete_use_path(acc, ctx, path_ctx, nameref);\n+                }\n+            }\n+        }\n+        NameRefKind::DotAccess(dot_access) => {\n+            flyimport::import_on_the_fly_dot(acc, ctx, dot_access);\n+            dot::complete_dot(acc, ctx, dot_access);\n+            postfix::complete_postfix(acc, ctx, dot_access);\n+        }\n+        NameRefKind::Keyword(item) => {\n+            keyword::complete_for_and_where(acc, ctx, item);\n+        }\n+        NameRefKind::RecordExpr(record_expr) => {\n+            record::complete_record_expr_fields(acc, ctx, record_expr);\n+        }\n+        NameRefKind::Pattern(pattern_ctx) => complete_patterns(acc, ctx, pattern_ctx),\n+    }\n+}\n+\n+fn complete_patterns(acc: &mut Completions, ctx: &CompletionContext, pattern_ctx: &PatternContext) {\n+    flyimport::import_on_the_fly_pat(acc, ctx, pattern_ctx);\n+    fn_param::complete_fn_param(acc, ctx, pattern_ctx);\n+    pattern::complete_pattern(acc, ctx, pattern_ctx);\n+    record::complete_record_pattern_fields(acc, ctx, pattern_ctx);\n+}"}, {"sha": "37e042a160937f7f159487943faaca5c26b91873", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -17,8 +17,7 @@ use syntax::{\n };\n \n use crate::{\n-    completions::module_or_attr,\n-    context::{CompletionContext, PathCompletionCtx, PathKind, Qualified},\n+    context::{AttrCtx, CompletionContext, PathCompletionCtx, Qualified},\n     item::CompletionItem,\n     Completions,\n };\n@@ -28,7 +27,7 @@ mod derive;\n mod lint;\n mod repr;\n \n-pub(crate) use self::derive::complete_derive;\n+pub(crate) use self::derive::complete_derive_path;\n \n /// Complete inputs to known builtin attributes as well as derive attributes\n pub(crate) fn complete_known_attribute_input(\n@@ -69,19 +68,13 @@ pub(crate) fn complete_known_attribute_input(\n     Some(())\n }\n \n-pub(crate) fn complete_attribute(\n+pub(crate) fn complete_attribute_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    path_ctx: &PathCompletionCtx,\n+    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    &AttrCtx { kind, annotated_item_kind }: &AttrCtx,\n ) {\n-    let (qualified, is_inner, annotated_item_kind) = match path_ctx {\n-        &PathCompletionCtx {\n-            kind: PathKind::Attr { kind, annotated_item_kind },\n-            ref qualified,\n-            ..\n-        } => (qualified, kind == AttrKind::Inner, annotated_item_kind),\n-        _ => return,\n-    };\n+    let is_inner = kind == AttrKind::Inner;\n \n     match qualified {\n         Qualified::With {\n@@ -94,8 +87,14 @@ pub(crate) fn complete_attribute(\n             }\n \n             for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n-                if let Some(def) = module_or_attr(ctx.db, def) {\n-                    acc.add_resolution(ctx, name, def);\n+                match def {\n+                    hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_attr(ctx.db) => {\n+                        acc.add_macro(ctx, m, name)\n+                    }\n+                    hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n+                        acc.add_module(ctx, m, name)\n+                    }\n+                    _ => (),\n                 }\n             }\n             return;\n@@ -104,10 +103,12 @@ pub(crate) fn complete_attribute(\n         Qualified::Absolute => acc.add_crate_roots(ctx),\n         // only show modules in a fresh UseTree\n         Qualified::No => {\n-            ctx.process_all_names(&mut |name, def| {\n-                if let Some(def) = module_or_attr(ctx.db, def) {\n-                    acc.add_resolution(ctx, name, def);\n+            ctx.process_all_names(&mut |name, def| match def {\n+                hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_attr(ctx.db) => {\n+                    acc.add_macro(ctx, m, name)\n                 }\n+                hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n+                _ => (),\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }"}, {"sha": "0e10f381532fa5063a56d6d3de3fa9593fa3eceb", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -5,23 +5,17 @@ use itertools::Itertools;\n use syntax::SmolStr;\n \n use crate::{\n-    context::{CompletionContext, PathCompletionCtx, PathKind, Qualified},\n+    context::{CompletionContext, ExistingDerives, PathCompletionCtx, Qualified},\n     item::CompletionItem,\n     Completions,\n };\n \n-pub(crate) fn complete_derive(\n+pub(crate) fn complete_derive_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    path_ctx: &PathCompletionCtx,\n+    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    existing_derives: &ExistingDerives,\n ) {\n-    let (qualified, existing_derives) = match path_ctx {\n-        PathCompletionCtx { kind: PathKind::Derive { existing_derives }, qualified, .. } => {\n-            (qualified, existing_derives)\n-        }\n-        _ => return,\n-    };\n-\n     let core = ctx.famous_defs().core();\n \n     match qualified {\n@@ -35,15 +29,14 @@ pub(crate) fn complete_derive(\n             }\n \n             for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n-                let add_def = match def {\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n-                        !existing_derives.contains(&mac) && mac.is_derive(ctx.db)\n+                match def {\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac))\n+                        if !existing_derives.contains(&mac) && mac.is_derive(ctx.db) =>\n+                    {\n+                        acc.add_macro(ctx, mac, name)\n                     }\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n-                    _ => false,\n-                };\n-                if add_def {\n-                    acc.add_resolution(ctx, name, def);\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n+                    _ => (),\n                 }\n             }\n         }\n@@ -57,16 +50,16 @@ pub(crate) fn complete_derive(\n                     {\n                         mac\n                     }\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => {\n-                        return acc.add_resolution(ctx, name, def);\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n+                        return acc.add_module(ctx, m, name);\n                     }\n                     _ => return,\n                 };\n \n                 match (core, mac.module(ctx.db).krate()) {\n                     // show derive dependencies for `core`/`std` derives\n                     (Some(core), mac_krate) if core == mac_krate => {}\n-                    _ => return acc.add_resolution(ctx, name, def),\n+                    _ => return acc.add_macro(ctx, mac, name),\n                 };\n \n                 let name_ = name.to_smol_str();\n@@ -99,7 +92,7 @@ pub(crate) fn complete_derive(\n                         item.lookup_by(lookup);\n                         item.add_to(acc);\n                     }\n-                    None => acc.add_resolution(ctx, name, def),\n+                    None => acc.add_macro(ctx, mac, name),\n                 }\n             });\n             acc.add_nameref_keywords_with_colon(ctx);"}, {"sha": "a8a57c0c7ddf9d1f31ae2a8e49d23ec575535104", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -3,9 +3,7 @@\n use ide_db::FxHashSet;\n \n use crate::{\n-    context::{\n-        CompletionContext, DotAccess, DotAccessKind, PathCompletionCtx, PathKind, Qualified,\n-    },\n+    context::{CompletionContext, DotAccess, DotAccessKind, ExprCtx, PathCompletionCtx, Qualified},\n     CompletionItem, CompletionItemKind, Completions,\n };\n \n@@ -42,16 +40,22 @@ pub(crate) fn complete_undotted_self(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     path_ctx: &PathCompletionCtx,\n+    expr_ctx: &ExprCtx,\n ) {\n     if !ctx.config.enable_self_on_the_fly {\n         return;\n     }\n-    let self_param = match path_ctx {\n-        PathCompletionCtx {\n-            qualified: Qualified::No,\n-            kind: PathKind::Expr { self_param: Some(self_param), .. },\n-            ..\n-        } if path_ctx.is_trivial_path() && ctx.qualifier_ctx.none() => self_param,\n+    if !path_ctx.is_trivial_path() {\n+        return;\n+    }\n+    if !ctx.qualifier_ctx.none() {\n+        return;\n+    }\n+    if !matches!(path_ctx.qualified, Qualified::No) {\n+        return;\n+    }\n+    let self_param = match expr_ctx {\n+        ExprCtx { self_param: Some(self_param), .. } => self_param,\n         _ => return,\n     };\n "}, {"sha": "84ae596a8d0a185eda51b0fdd024c9cad024f151", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 19, "deletions": 46, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -4,61 +4,34 @@ use hir::ScopeDef;\n use ide_db::FxHashSet;\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind, Qualified},\n+    context::{ExprCtx, PathCompletionCtx, Qualified},\n     CompletionContext, Completions,\n };\n \n pub(crate) fn complete_expr_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    path_ctx: &PathCompletionCtx,\n-) {\n-    let _p = profile::span(\"complete_expr_path\");\n-    if !ctx.qualifier_ctx.none() {\n-        return;\n-    }\n-    let (\n-        qualified,\n+    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    &ExprCtx {\n         in_block_expr,\n         in_loop_body,\n-        is_func_update,\n         after_if_expr,\n-        wants_mut_token,\n         in_condition,\n-        ty,\n         incomplete_let,\n-        impl_,\n-    ) = match path_ctx {\n-        &PathCompletionCtx {\n-            kind:\n-                PathKind::Expr {\n-                    in_block_expr,\n-                    in_loop_body,\n-                    after_if_expr,\n-                    in_condition,\n-                    incomplete_let,\n-                    ref ref_expr_parent,\n-                    ref is_func_update,\n-                    ref innermost_ret_ty,\n-                    ref impl_,\n-                    ..\n-                },\n-            ref qualified,\n-            ..\n-        } => (\n-            qualified,\n-            in_block_expr,\n-            in_loop_body,\n-            is_func_update.is_some(),\n-            after_if_expr,\n-            ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false),\n-            in_condition,\n-            innermost_ret_ty,\n-            incomplete_let,\n-            impl_,\n-        ),\n-        _ => return,\n-    };\n+        ref ref_expr_parent,\n+        ref is_func_update,\n+        ref innermost_ret_ty,\n+        ref impl_,\n+        ..\n+    }: &ExprCtx,\n+) {\n+    let _p = profile::span(\"complete_expr_path\");\n+    if !ctx.qualifier_ctx.none() {\n+        return;\n+    }\n+\n+    let wants_mut_token =\n+        ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false);\n \n     let scope_def_applicable = |def| {\n         use hir::{GenericParam::*, ModuleDef::*};\n@@ -230,7 +203,7 @@ pub(crate) fn complete_expr_path(\n                 }\n             });\n \n-            if !is_func_update {\n+            if is_func_update.is_none() {\n                 let mut add_keyword =\n                     |kw, snippet| acc.add_keyword_snippet_expr(ctx, kw, snippet, incomplete_let);\n \n@@ -270,7 +243,7 @@ pub(crate) fn complete_expr_path(\n                     }\n                 }\n \n-                if let Some(ty) = ty {\n+                if let Some(ty) = innermost_ret_ty {\n                     add_keyword(\n                         \"return\",\n                         match (in_block_expr, ty.is_unit()) {"}, {"sha": "738c24574c9979255c53fb0d284c17210171bbe2", "filename": "crates/ide-completion/src/completions/field.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -1,7 +1,7 @@\n //! Completion of field list position.\n \n use crate::{\n-    context::{NameContext, NameKind, PathCompletionCtx, PathKind, Qualified, TypeLocation},\n+    context::{PathCompletionCtx, Qualified},\n     CompletionContext, Completions,\n };\n \n@@ -10,37 +10,31 @@ pub(crate) fn complete_field_list_tuple_variant(\n     ctx: &CompletionContext,\n     path_ctx: &PathCompletionCtx,\n ) {\n+    if ctx.qualifier_ctx.vis_node.is_some() {\n+        return;\n+    }\n     match path_ctx {\n         PathCompletionCtx {\n             has_macro_bang: false,\n             qualified: Qualified::No,\n             parent: None,\n-            kind: PathKind::Type { location: TypeLocation::TupleField },\n             has_type_args: false,\n             ..\n         } => {\n-            if ctx.qualifier_ctx.vis_node.is_none() {\n-                let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n-                add_keyword(\"pub(crate)\", \"pub(crate)\");\n-                add_keyword(\"pub(super)\", \"pub(super)\");\n-                add_keyword(\"pub\", \"pub\");\n-            }\n-        }\n-        _ => (),\n-    }\n-}\n-\n-pub(crate) fn complete_field_list_record_variant(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    name_ctx: &NameContext,\n-) {\n-    if let NameContext { kind: NameKind::RecordField, .. } = name_ctx {\n-        if ctx.qualifier_ctx.vis_node.is_none() {\n             let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n             add_keyword(\"pub(crate)\", \"pub(crate)\");\n             add_keyword(\"pub(super)\", \"pub(super)\");\n             add_keyword(\"pub\", \"pub\");\n         }\n+        _ => (),\n+    }\n+}\n+\n+pub(crate) fn complete_field_list_record_variant(acc: &mut Completions, ctx: &CompletionContext) {\n+    if ctx.qualifier_ctx.vis_node.is_none() {\n+        let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n+        add_keyword(\"pub(crate)\", \"pub(crate)\");\n+        add_keyword(\"pub(super)\", \"pub(super)\");\n+        add_keyword(\"pub\", \"pub\");\n     }\n }"}, {"sha": "e697e1971ea50b18367100df552783aa70d65672", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -1,34 +1,37 @@\n //! Completion of paths and keywords at item list position.\n \n use crate::{\n-    completions::module_or_fn_macro,\n-    context::{ItemListKind, PathCompletionCtx, PathKind, Qualified},\n+    context::{ExprCtx, ItemListKind, PathCompletionCtx, Qualified},\n     CompletionContext, Completions,\n };\n \n pub(crate) mod trait_impl;\n \n-pub(crate) fn complete_item_list(\n+pub(crate) fn complete_item_list_in_expr(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     path_ctx: &PathCompletionCtx,\n+    expr_ctx: &ExprCtx,\n+) {\n+    if !expr_ctx.in_block_expr {\n+        return;\n+    }\n+    if !path_ctx.is_trivial_path() {\n+        return;\n+    }\n+    add_keywords(acc, ctx, None);\n+}\n+\n+pub(crate) fn complete_item_list(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    kind: &ItemListKind,\n ) {\n     let _p = profile::span(\"complete_item_list\");\n-    let qualified = match path_ctx {\n-        PathCompletionCtx { kind: PathKind::Item { kind }, qualified, .. } => {\n-            if path_ctx.is_trivial_path() {\n-                add_keywords(acc, ctx, Some(kind));\n-            }\n-            qualified\n-        }\n-        PathCompletionCtx { kind: PathKind::Expr { in_block_expr: true, .. }, .. }\n-            if path_ctx.is_trivial_path() =>\n-        {\n-            add_keywords(acc, ctx, None);\n-            return;\n-        }\n-        _ => return,\n-    };\n+    if path_ctx.is_trivial_path() {\n+        add_keywords(acc, ctx, Some(kind));\n+    }\n \n     match qualified {\n         Qualified::With {\n@@ -37,8 +40,14 @@ pub(crate) fn complete_item_list(\n             ..\n         } => {\n             for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n-                if let Some(def) = module_or_fn_macro(ctx.db, def) {\n-                    acc.add_resolution(ctx, name, def);\n+                match def {\n+                    hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_fn_like(ctx.db) => {\n+                        acc.add_macro(ctx, m, name)\n+                    }\n+                    hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n+                        acc.add_module(ctx, m, name)\n+                    }\n+                    _ => (),\n                 }\n             }\n \n@@ -48,10 +57,12 @@ pub(crate) fn complete_item_list(\n         }\n         Qualified::Absolute => acc.add_crate_roots(ctx),\n         Qualified::No if ctx.qualifier_ctx.none() => {\n-            ctx.process_all_names(&mut |name, def| {\n-                if let Some(def) = module_or_fn_macro(ctx.db, def) {\n-                    acc.add_resolution(ctx, name, def);\n+            ctx.process_all_names(&mut |name, def| match def {\n+                hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_fn_like(ctx.db) => {\n+                    acc.add_macro(ctx, m, name)\n                 }\n+                hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n+                _ => (),\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }"}, {"sha": "972a7d2f21103abbc97fe81d2487c3d3d8fa78ca", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -43,11 +43,8 @@ use syntax::{\n use text_edit::TextEdit;\n \n use crate::{\n-    context::{\n-        ItemListKind, NameContext, NameKind, NameRefContext, NameRefKind, PathCompletionCtx,\n-        PathKind,\n-    },\n-    CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n+    context::PathCompletionCtx, CompletionContext, CompletionItem, CompletionItemKind,\n+    CompletionRelevance, Completions,\n };\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -58,17 +55,36 @@ enum ImplCompletionKind {\n     Const,\n }\n \n-pub(crate) fn complete_trait_impl_name(\n+pub(crate) fn complete_trait_impl_const(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    NameContext { name, kind, .. }: &NameContext,\n+    name: &Option<ast::Name>,\n+) -> Option<()> {\n+    complete_trait_impl_name(acc, ctx, name, ImplCompletionKind::Const)\n+}\n+\n+pub(crate) fn complete_trait_impl_type_alias(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    name: &Option<ast::Name>,\n+) -> Option<()> {\n+    complete_trait_impl_name(acc, ctx, name, ImplCompletionKind::TypeAlias)\n+}\n+\n+pub(crate) fn complete_trait_impl_fn(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    name: &Option<ast::Name>,\n+) -> Option<()> {\n+    complete_trait_impl_name(acc, ctx, name, ImplCompletionKind::Fn)\n+}\n+\n+fn complete_trait_impl_name(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    name: &Option<ast::Name>,\n+    kind: ImplCompletionKind,\n ) -> Option<()> {\n-    let kind = match kind {\n-        NameKind::Const => ImplCompletionKind::Const,\n-        NameKind::Function => ImplCompletionKind::Fn,\n-        NameKind::TypeAlias => ImplCompletionKind::TypeAlias,\n-        _ => return None,\n-    };\n     let token = ctx.token.clone();\n     let item = match name {\n         Some(name) => name.syntax().parent(),\n@@ -86,34 +102,28 @@ pub(crate) fn complete_trait_impl_name(\n     Some(())\n }\n \n-pub(crate) fn complete_trait_impl_name_ref(\n+pub(crate) fn complete_trait_impl_item_by_name(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    name_ref_ctx: &NameRefContext,\n-) -> Option<()> {\n-    match name_ref_ctx {\n-        NameRefContext {\n-            nameref,\n-            kind:\n-                NameRefKind::Path(\n-                    path_ctx @ PathCompletionCtx {\n-                        kind: PathKind::Item { kind: ItemListKind::TraitImpl(Some(impl_)) },\n-                        ..\n-                    },\n-                ),\n-        } if path_ctx.is_trivial_path() => complete_trait_impl(\n+    path_ctx: &PathCompletionCtx,\n+    name_ref: &Option<ast::NameRef>,\n+    impl_: &Option<ast::Impl>,\n+) {\n+    if !path_ctx.is_trivial_path() {\n+        return;\n+    }\n+    if let Some(impl_) = impl_ {\n+        complete_trait_impl(\n             acc,\n             ctx,\n             ImplCompletionKind::All,\n-            match nameref {\n+            match name_ref {\n                 Some(name) => name.syntax().text_range(),\n                 None => ctx.source_range(),\n             },\n             impl_,\n-        ),\n-        _ => (),\n+        );\n     }\n-    Some(())\n }\n \n fn complete_trait_impl("}, {"sha": "7d8d3a9636deb52b14f5ad8e69238081b50172b5", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -4,7 +4,7 @@ use syntax::ast::{self, Item};\n \n use crate::{CompletionContext, Completions};\n \n-pub(crate) fn complete_special_keywords(\n+pub(crate) fn complete_for_and_where(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     keyword_item: &ast::Item,\n@@ -60,8 +60,6 @@ mod tests {\n                 kw fn\n                 kw impl\n                 kw trait\n-                sn pd\n-                sn ppd\n             \"#]],\n         );\n     }"}, {"sha": "6f67c38dfdebb399c6ea59741f5b60680cad1f55", "filename": "crates/ide-completion/src/completions/mod_.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -9,21 +9,14 @@ use ide_db::{\n };\n use syntax::{ast, AstNode, SyntaxKind};\n \n-use crate::{\n-    context::{CompletionContext, NameContext, NameKind},\n-    CompletionItem, Completions,\n-};\n+use crate::{context::CompletionContext, CompletionItem, Completions};\n \n /// Complete mod declaration, i.e. `mod $0;`\n pub(crate) fn complete_mod(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    name_ctx: &NameContext,\n+    mod_under_caret: &ast::Module,\n ) -> Option<()> {\n-    let mod_under_caret = match name_ctx {\n-        NameContext { kind: NameKind::Module(mod_under_caret), .. } => mod_under_caret,\n-        _ => return None,\n-    };\n     if mod_under_caret.item_list().is_some() {\n         return None;\n     }"}, {"sha": "e2e8d3f205a474bf02095679db30405430a593bc", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -5,7 +5,7 @@ use ide_db::FxHashSet;\n use syntax::ast::Pat;\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind, PatternContext, PatternRefutability, Qualified},\n+    context::{PathCompletionCtx, PatternContext, PatternRefutability, Qualified},\n     CompletionContext, Completions,\n };\n \n@@ -108,14 +108,11 @@ pub(crate) fn complete_pattern(\n     });\n }\n \n-pub(crate) fn pattern_path_completion(\n+pub(crate) fn complete_pattern_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    PathCompletionCtx { qualified, kind, .. }: &PathCompletionCtx,\n+    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n ) {\n-    if !matches!(kind, PathKind::Pat { .. }) {\n-        return;\n-    }\n     match qualified {\n         Qualified::With { resolution: Some(resolution), is_super_chain, .. } => {\n             if *is_super_chain {"}, {"sha": "12c449bf352c757e9e4b5ea9ad4e9ba83d2abf0c", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -6,7 +6,7 @@ use syntax::{\n };\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind, PatternContext, Qualified},\n+    context::{ExprCtx, PathCompletionCtx, PatternContext, Qualified},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n     CompletionRelevancePostfixMatch, Completions,\n };\n@@ -20,7 +20,7 @@ pub(crate) fn complete_record_pattern_fields(\n         complete_fields(acc, ctx, ctx.sema.record_pattern_missing_fields(record_pat));\n     }\n }\n-pub(crate) fn complete_record_expr_fields_record_expr(\n+pub(crate) fn complete_record_expr_fields(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     record_expr: &ast::RecordExpr,\n@@ -85,13 +85,12 @@ pub(crate) fn complete_record_expr_func_update(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     path_ctx: &PathCompletionCtx,\n+    expr_ctx: &ExprCtx,\n ) {\n-    if let PathCompletionCtx {\n-        kind: PathKind::Expr { is_func_update: Some(record_expr), .. },\n-        qualified: Qualified::No,\n-        ..\n-    } = path_ctx\n-    {\n+    if !matches!(path_ctx.qualified, Qualified::No) {\n+        return;\n+    }\n+    if let ExprCtx { is_func_update: Some(record_expr), .. } = expr_ctx {\n         let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n \n         match ty.as_ref().and_then(|t| t.original.as_adt()) {"}, {"sha": "9992a81fe07402205c3199651ca47335f9abbe7a", "filename": "crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -4,7 +4,7 @@ use hir::Documentation;\n use ide_db::{imports::insert_use::ImportScope, SnippetCap};\n \n use crate::{\n-    context::{ItemListKind, PathCompletionCtx, PathKind, Qualified},\n+    context::{ExprCtx, ItemListKind, PathCompletionCtx, Qualified},\n     item::Builder,\n     CompletionContext, CompletionItem, CompletionItemKind, Completions, SnippetScope,\n };\n@@ -19,15 +19,14 @@ pub(crate) fn complete_expr_snippet(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     path_ctx: &PathCompletionCtx,\n+    &ExprCtx { in_block_expr, .. }: &ExprCtx,\n ) {\n-    let &can_be_stmt = match path_ctx {\n-        PathCompletionCtx {\n-            qualified: Qualified::No,\n-            kind: PathKind::Expr { in_block_expr, .. },\n-            ..\n-        } => in_block_expr,\n-        _ => return,\n-    };\n+    if !matches!(path_ctx.qualified, Qualified::No) {\n+        return;\n+    }\n+    if !ctx.qualifier_ctx.none() {\n+        return;\n+    }\n \n     let cap = match ctx.config.snippet_cap {\n         Some(it) => it,\n@@ -38,31 +37,35 @@ pub(crate) fn complete_expr_snippet(\n         add_custom_completions(acc, ctx, cap, SnippetScope::Expr);\n     }\n \n-    if can_be_stmt {\n+    if in_block_expr {\n         snippet(ctx, cap, \"pd\", \"eprintln!(\\\"$0 = {:?}\\\", $0);\").add_to(acc);\n         snippet(ctx, cap, \"ppd\", \"eprintln!(\\\"$0 = {:#?}\\\", $0);\").add_to(acc);\n+        let item = snippet(\n+            ctx,\n+            cap,\n+            \"macro_rules\",\n+            \"\\\n+macro_rules! $1 {\n+    ($2) => {\n+        $0\n+    };\n+}\",\n+        );\n+        item.add_to(acc);\n     }\n }\n \n pub(crate) fn complete_item_snippet(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     path_ctx: &PathCompletionCtx,\n+    kind: &ItemListKind,\n ) {\n-    let path_kind = match path_ctx {\n-        PathCompletionCtx {\n-            qualified: Qualified::No,\n-            kind: kind @ (PathKind::Item { .. } | PathKind::Expr { in_block_expr: true, .. }),\n-            ..\n-        } => kind,\n-        _ => return,\n-    };\n-    if !ctx.qualifier_ctx.none() {\n+    if !matches!(path_ctx.qualified, Qualified::No) {\n         return;\n     }\n-    if ctx.qualifier_ctx.vis_node.is_some() {\n-        return; // technically we could do some of these snippet completions if we were to put the\n-                // attributes before the vis node.\n+    if !ctx.qualifier_ctx.none() {\n+        return;\n     }\n     let cap = match ctx.config.snippet_cap {\n         Some(it) => it,\n@@ -74,8 +77,7 @@ pub(crate) fn complete_item_snippet(\n     }\n \n     // Test-related snippets shouldn't be shown in blocks.\n-    if let PathKind::Item { kind: ItemListKind::SourceFile | ItemListKind::Module, .. } = path_kind\n-    {\n+    if let ItemListKind::SourceFile | ItemListKind::Module = kind {\n         let mut item = snippet(\n             ctx,\n             cap,\n@@ -106,10 +108,7 @@ fn ${1:feature}() {\n         );\n         item.lookup_by(\"tfn\");\n         item.add_to(acc);\n-    }\n-    if let PathKind::Item { kind: ItemListKind::SourceFile | ItemListKind::Module, .. }\n-    | PathKind::Expr { .. } = path_kind\n-    {\n+\n         let item = snippet(\n             ctx,\n             cap,"}, {"sha": "0f7ca7586814d7ba6e5ae19695b7a81faa811b43", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -5,25 +5,19 @@ use ide_db::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind, Qualified, TypeAscriptionTarget, TypeLocation},\n+    context::{PathCompletionCtx, Qualified, TypeAscriptionTarget, TypeLocation},\n     render::render_type_inference,\n     CompletionContext, Completions,\n };\n \n pub(crate) fn complete_type_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    path_ctx: &PathCompletionCtx,\n+    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    location: &TypeLocation,\n ) {\n     let _p = profile::span(\"complete_type_path\");\n \n-    let (location, qualified) = match path_ctx {\n-        PathCompletionCtx { kind: PathKind::Type { location }, qualified, .. } => {\n-            (location, qualified)\n-        }\n-        _ => return,\n-    };\n-\n     let scope_def_applicable = |def| {\n         use hir::{GenericParam::*, ModuleDef::*};\n         match def {\n@@ -191,19 +185,16 @@ pub(crate) fn complete_type_path(\n     }\n }\n \n-pub(crate) fn complete_inferred_type(\n+pub(crate) fn complete_ascribed_type(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     path_ctx: &PathCompletionCtx,\n+    ascription: &TypeAscriptionTarget,\n ) -> Option<()> {\n-    let pat = match path_ctx {\n-        PathCompletionCtx {\n-            kind: PathKind::Type { location: TypeLocation::TypeAscription(ascription), .. },\n-            ..\n-        } if path_ctx.is_trivial_path() => ascription,\n-        _ => return None,\n-    };\n-    let x = match pat {\n+    if !path_ctx.is_trivial_path() {\n+        return None;\n+    }\n+    let x = match ascription {\n         TypeAscriptionTarget::Let(pat) | TypeAscriptionTarget::FnParam(pat) => {\n             ctx.sema.type_of_pat(pat.as_ref()?)\n         }"}, {"sha": "f262355fc06ee8d9b4512f2d6b5da4d870efac87", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -5,33 +5,17 @@ use ide_db::{FxHashSet, SymbolKind};\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{\n-        CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind, Qualified,\n-    },\n+    context::{CompletionContext, PathCompletionCtx, Qualified},\n     item::Builder,\n     CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n \n-pub(crate) fn complete_use_tree(\n+pub(crate) fn complete_use_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    name_ref_ctx: &NameRefContext,\n+    PathCompletionCtx { qualified, use_tree_parent, .. }: &PathCompletionCtx,\n+    name_ref: &Option<ast::NameRef>,\n ) {\n-    let (qualified, name_ref, use_tree_parent) = match name_ref_ctx {\n-        NameRefContext {\n-            kind:\n-                NameRefKind::Path(PathCompletionCtx {\n-                    kind: PathKind::Use,\n-                    qualified,\n-                    use_tree_parent,\n-                    ..\n-                }),\n-            nameref,\n-            ..\n-        } => (qualified, nameref, use_tree_parent),\n-        _ => return,\n-    };\n-\n     match qualified {\n         Qualified::With { path, resolution: Some(resolution), is_super_chain } => {\n             if *is_super_chain {\n@@ -112,8 +96,8 @@ pub(crate) fn complete_use_tree(\n             cov_mark::hit!(unqualified_path_selected_only);\n             ctx.process_all_names(&mut |name, res| {\n                 match res {\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => {\n-                        acc.add_resolution(ctx, name, res);\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(module)) => {\n+                        acc.add_module(ctx, module, name);\n                     }\n                     ScopeDef::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n                         // exclude prelude enum"}, {"sha": "30de0e94f7a5fc28e9d2efbbeb65a0301a605ae0", "filename": "crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -1,24 +1,16 @@\n //! Completion for visibility specifiers.\n \n-use hir::ScopeDef;\n-\n use crate::{\n-    context::{CompletionContext, PathCompletionCtx, PathKind, Qualified},\n+    context::{CompletionContext, PathCompletionCtx, Qualified},\n     Completions,\n };\n \n pub(crate) fn complete_vis_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    path_ctx: &PathCompletionCtx,\n+    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    &has_in_token: &bool,\n ) {\n-    let (qualified, &has_in_token) = match path_ctx {\n-        PathCompletionCtx { kind: PathKind::Vis { has_in_token }, qualified, .. } => {\n-            (qualified, has_in_token)\n-        }\n-        _ => return,\n-    };\n-\n     match qualified {\n         Qualified::With {\n             resolution: Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))),\n@@ -31,7 +23,7 @@ pub(crate) fn complete_vis_path(\n             if let Some(next) = next_towards_current {\n                 if let Some(name) = next.name(ctx.db) {\n                     cov_mark::hit!(visibility_qualified);\n-                    acc.add_resolution(ctx, name, ScopeDef::ModuleDef(next.into()));\n+                    acc.add_module(ctx, next, name);\n                 }\n             }\n "}, {"sha": "8c73709f4cefdf9cd32fac1fe966ae261d512fcd", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -88,27 +88,16 @@ impl PathCompletionCtx {\n #[derive(Debug, PartialEq, Eq)]\n pub(super) enum PathKind {\n     Expr {\n-        in_block_expr: bool,\n-        in_loop_body: bool,\n-        after_if_expr: bool,\n-        /// Whether this expression is the direct condition of an if or while expression\n-        in_condition: bool,\n-        incomplete_let: bool,\n-        ref_expr_parent: Option<ast::RefExpr>,\n-        is_func_update: Option<ast::RecordExpr>,\n-        self_param: Option<hir::SelfParam>,\n-        innermost_ret_ty: Option<hir::Type>,\n-        impl_: Option<ast::Impl>,\n+        expr_ctx: ExprCtx,\n     },\n     Type {\n         location: TypeLocation,\n     },\n     Attr {\n-        kind: AttrKind,\n-        annotated_item_kind: Option<SyntaxKind>,\n+        attr_ctx: AttrCtx,\n     },\n     Derive {\n-        existing_derives: FxHashSet<hir::Macro>,\n+        existing_derives: ExistingDerives,\n     },\n     /// Path in item position, that is inside an (Assoc)ItemList\n     Item {\n@@ -123,6 +112,29 @@ pub(super) enum PathKind {\n     Use,\n }\n \n+pub(crate) type ExistingDerives = FxHashSet<hir::Macro>;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct AttrCtx {\n+    pub(crate) kind: AttrKind,\n+    pub(crate) annotated_item_kind: Option<SyntaxKind>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ExprCtx {\n+    pub(crate) in_block_expr: bool,\n+    pub(crate) in_loop_body: bool,\n+    pub(crate) after_if_expr: bool,\n+    /// Whether this expression is the direct condition of an if or while expression\n+    pub(crate) in_condition: bool,\n+    pub(crate) incomplete_let: bool,\n+    pub(crate) ref_expr_parent: Option<ast::RefExpr>,\n+    pub(crate) is_func_update: Option<ast::RecordExpr>,\n+    pub(crate) self_param: Option<hir::SelfParam>,\n+    pub(crate) innermost_ret_ty: Option<hir::Type>,\n+    pub(crate) impl_: Option<ast::Impl>,\n+}\n+\n /// Original file ast nodes\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum TypeLocation {"}, {"sha": "551fa7fb865f1fc2bfa4d9f2fde9f54f98c7c837", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -11,10 +11,10 @@ use syntax::{\n };\n \n use crate::context::{\n-    CompletionContext, DotAccess, DotAccessKind, IdentContext, ItemListKind, LifetimeContext,\n-    LifetimeKind, NameContext, NameKind, NameRefContext, NameRefKind, ParamKind, PathCompletionCtx,\n-    PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx, TypeAscriptionTarget,\n-    TypeLocation, COMPLETION_MARKER,\n+    AttrCtx, CompletionContext, DotAccess, DotAccessKind, ExprCtx, IdentContext, ItemListKind,\n+    LifetimeContext, LifetimeKind, NameContext, NameKind, NameRefContext, NameRefKind, ParamKind,\n+    PathCompletionCtx, PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx,\n+    TypeAscriptionTarget, TypeLocation, COMPLETION_MARKER,\n };\n \n impl<'a> CompletionContext<'a> {\n@@ -765,16 +765,18 @@ impl<'a> CompletionContext<'a> {\n             let impl_ = fetch_immediate_impl(sema, original_file, expr.syntax());\n \n             PathKind::Expr {\n-                in_block_expr,\n-                in_loop_body,\n-                after_if_expr,\n-                in_condition,\n-                ref_expr_parent,\n-                is_func_update,\n-                innermost_ret_ty,\n-                self_param,\n-                incomplete_let,\n-                impl_,\n+                expr_ctx: ExprCtx {\n+                    in_block_expr,\n+                    in_loop_body,\n+                    after_if_expr,\n+                    in_condition,\n+                    ref_expr_parent,\n+                    is_func_update,\n+                    innermost_ret_ty,\n+                    self_param,\n+                    incomplete_let,\n+                    impl_,\n+                },\n             }\n         };\n         let make_path_kind_type = |ty: ast::Type| {\n@@ -858,8 +860,10 @@ impl<'a> CompletionContext<'a> {\n                             Some(attached.kind())\n                         };\n                         PathKind::Attr {\n-                            kind,\n-                            annotated_item_kind,\n+                            attr_ctx: AttrCtx {\n+                                kind,\n+                                annotated_item_kind,\n+                            }\n                         }\n                     },\n                     ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n@@ -914,7 +918,7 @@ impl<'a> CompletionContext<'a> {\n         if path_ctx.is_trivial_path() {\n             // fetch the full expression that may have qualifiers attached to it\n             let top_node = match path_ctx.kind {\n-                PathKind::Expr { in_block_expr: true, .. } => {\n+                PathKind::Expr { expr_ctx: ExprCtx { in_block_expr: true, .. } } => {\n                     parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n                         let parent = p.parent()?;\n                         if ast::StmtList::can_cast(parent.kind()) {"}, {"sha": "90e2628439fec5c6e4f7794007101ab7511aa982", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 13, "deletions": 61, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -24,7 +24,9 @@ use text_edit::TextEdit;\n \n use crate::{\n     completions::Completions,\n-    context::{CompletionContext, IdentContext, NameKind, NameRefContext, NameRefKind},\n+    context::{\n+        CompletionContext, IdentContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind,\n+    },\n };\n \n pub use crate::{\n@@ -151,10 +153,13 @@ pub fn completions(\n \n     // prevent `(` from triggering unwanted completion noise\n     if trigger_character == Some('(') {\n-        if let IdentContext::NameRef(NameRefContext { kind: NameRefKind::Path(path_ctx), .. }) =\n-            &ctx.ident_ctx\n-        {\n-            completions::vis::complete_vis_path(&mut completions, ctx, path_ctx);\n+        if let IdentContext::NameRef(NameRefContext { kind, .. }) = &ctx.ident_ctx {\n+            if let NameRefKind::Path(\n+                path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n+            ) = kind\n+            {\n+                completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n+            }\n         }\n         // prevent `(` from triggering unwanted completion noise\n         return Some(completions);\n@@ -164,62 +169,9 @@ pub fn completions(\n         let acc = &mut completions;\n \n         match &ctx.ident_ctx {\n-            IdentContext::Name(name_ctx) => {\n-                completions::field::complete_field_list_record_variant(acc, ctx, name_ctx);\n-                completions::item_list::trait_impl::complete_trait_impl_name(acc, ctx, name_ctx);\n-                completions::mod_::complete_mod(acc, ctx, name_ctx);\n-                if let NameKind::IdentPat(pattern_ctx) = &name_ctx.kind {\n-                    completions::flyimport::import_on_the_fly_pat(acc, ctx, pattern_ctx);\n-                    completions::fn_param::complete_fn_param(acc, ctx, pattern_ctx);\n-                    completions::pattern::complete_pattern(acc, ctx, pattern_ctx);\n-                    completions::record::complete_record_pattern_fields(acc, ctx, pattern_ctx);\n-                }\n-            }\n-            IdentContext::NameRef(name_ctx @ NameRefContext { kind, .. }) => {\n-                completions::item_list::trait_impl::complete_trait_impl_name_ref(\n-                    acc, ctx, name_ctx,\n-                );\n-                completions::use_::complete_use_tree(acc, ctx, name_ctx);\n-\n-                match kind {\n-                    NameRefKind::Path(path_ctx) => {\n-                        completions::attribute::complete_attribute(acc, ctx, path_ctx);\n-                        completions::attribute::complete_derive(acc, ctx, path_ctx);\n-                        completions::dot::complete_undotted_self(acc, ctx, path_ctx);\n-                        completions::expr::complete_expr_path(acc, ctx, path_ctx);\n-                        completions::field::complete_field_list_tuple_variant(acc, ctx, path_ctx);\n-                        completions::flyimport::import_on_the_fly_path(acc, ctx, path_ctx);\n-                        completions::item_list::complete_item_list(acc, ctx, path_ctx);\n-                        completions::pattern::pattern_path_completion(acc, ctx, path_ctx);\n-                        completions::r#type::complete_inferred_type(acc, ctx, path_ctx);\n-                        completions::r#type::complete_type_path(acc, ctx, path_ctx);\n-                        completions::record::complete_record_expr_func_update(acc, ctx, path_ctx);\n-                        completions::snippet::complete_expr_snippet(acc, ctx, path_ctx);\n-                        completions::snippet::complete_item_snippet(acc, ctx, path_ctx);\n-                        completions::vis::complete_vis_path(acc, ctx, path_ctx);\n-                    }\n-                    NameRefKind::DotAccess(dot_access) => {\n-                        completions::flyimport::import_on_the_fly_dot(acc, ctx, dot_access);\n-                        completions::dot::complete_dot(acc, ctx, dot_access);\n-                        completions::postfix::complete_postfix(acc, ctx, dot_access);\n-                    }\n-                    NameRefKind::Keyword(item) => {\n-                        completions::keyword::complete_special_keywords(acc, ctx, item);\n-                    }\n-                    NameRefKind::RecordExpr(record_expr) => {\n-                        completions::record::complete_record_expr_fields_record_expr(\n-                            acc,\n-                            ctx,\n-                            record_expr,\n-                        );\n-                    }\n-                    NameRefKind::Pattern(pattern_ctx) => {\n-                        completions::flyimport::import_on_the_fly_pat(acc, ctx, pattern_ctx);\n-                        completions::fn_param::complete_fn_param(acc, ctx, pattern_ctx);\n-                        completions::pattern::complete_pattern(acc, ctx, pattern_ctx);\n-                        completions::record::complete_record_pattern_fields(acc, ctx, pattern_ctx);\n-                    }\n-                }\n+            IdentContext::Name(name_ctx) => completions::complete_name(acc, ctx, name_ctx),\n+            IdentContext::NameRef(name_ref_ctx) => {\n+                completions::complete_name_ref(acc, ctx, name_ref_ctx)\n             }\n             IdentContext::Lifetime(lifetime_ctx) => {\n                 completions::lifetime::complete_label(acc, ctx, lifetime_ctx);"}, {"sha": "a6bb3d0648bb08877303898cb48ff3f1fac8345a", "filename": "crates/ide-completion/src/snippet.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e7e4e42cc89efd05df3c04493a4dd396cebc46/crates%2Fide-completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fsnippet.rs?ref=a2e7e4e42cc89efd05df3c04493a4dd396cebc46", "patch": "@@ -2,8 +2,6 @@\n //!\n //! Actual logic is implemented in [`crate::completions::postfix`] and [`crate::completions::snippet`] respectively.\n \n-use std::ops::Deref;\n-\n // Feature: User Snippet Completions\n //\n // rust-analyzer allows the user to define custom (postfix)-snippets that may depend on items to be accessible for the current scope to be applicable.\n@@ -146,8 +144,8 @@ impl Snippet {\n         let (requires, snippet, description) = validate_snippet(snippet, description, requires)?;\n         Some(Snippet {\n             // Box::into doesn't work as that has a Copy bound \ud83d\ude12\n-            postfix_triggers: postfix_triggers.iter().map(Deref::deref).map(Into::into).collect(),\n-            prefix_triggers: prefix_triggers.iter().map(Deref::deref).map(Into::into).collect(),\n+            postfix_triggers: postfix_triggers.iter().map(String::as_str).map(Into::into).collect(),\n+            prefix_triggers: prefix_triggers.iter().map(String::as_str).map(Into::into).collect(),\n             scope,\n             snippet,\n             description,"}]}