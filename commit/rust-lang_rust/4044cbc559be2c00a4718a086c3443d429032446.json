{"sha": "4044cbc559be2c00a4718a086c3443d429032446", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNDRjYmM1NTliZTJjMDBhNDcxOGEwODZjMzQ0M2Q0MjkwMzI0NDY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-07-04T18:38:56Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-07-18T10:06:04Z"}, "message": "rustc_metadata: Refactor away `CrateLocator::(dy,static)libname`", "tree": {"sha": "8fe16bc7316bec0f0c99cf90ffb6eff999b3173d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fe16bc7316bec0f0c99cf90ffb6eff999b3173d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4044cbc559be2c00a4718a086c3443d429032446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4044cbc559be2c00a4718a086c3443d429032446", "html_url": "https://github.com/rust-lang/rust/commit/4044cbc559be2c00a4718a086c3443d429032446", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4044cbc559be2c00a4718a086c3443d429032446/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "926ac5a2fd6cd4a0994b0c7cff5a43040c9c0e4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/926ac5a2fd6cd4a0994b0c7cff5a43040c9c0e4c", "html_url": "https://github.com/rust-lang/rust/commit/926ac5a2fd6cd4a0994b0c7cff5a43040c9c0e4c"}], "stats": {"total": 46, "additions": 19, "deletions": 27}, "files": [{"sha": "ecb2548c7469f44e6e91c3b8dea5e7d3cc9051c3", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4044cbc559be2c00a4718a086c3443d429032446/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4044cbc559be2c00a4718a086c3443d429032446/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=4044cbc559be2c00a4718a086c3443d429032446", "patch": "@@ -495,7 +495,6 @@ impl<'a> CrateLocator<'a> {\n         };\n \n         if !self.rejected_via_filename.is_empty() {\n-            let dylibname = self.dylibname();\n             let mismatches = self.rejected_via_filename.iter();\n             for &CrateMismatch { ref path, .. } in mismatches {\n                 err.note(&format!(\n@@ -505,7 +504,7 @@ impl<'a> CrateLocator<'a> {\n                 ))\n                 .help(&format!(\n                     \"file name should be lib*.rlib or {}*.{}\",\n-                    dylibname.0, dylibname.1\n+                    self.target.options.dll_prefix, self.target.options.dll_suffix\n                 ));\n             }\n         }\n@@ -520,13 +519,12 @@ impl<'a> CrateLocator<'a> {\n         extra_prefix: &str,\n         seen_paths: &mut FxHashSet<PathBuf>,\n     ) -> Option<Library> {\n-        let dypair = self.dylibname();\n-        let staticpair = self.staticlibname();\n-\n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}{}\", dypair.0, self.crate_name, extra_prefix);\n+        let dylib_prefix =\n+            format!(\"{}{}{}\", self.target.options.dll_prefix, self.crate_name, extra_prefix);\n         let rlib_prefix = format!(\"lib{}{}\", self.crate_name, extra_prefix);\n-        let staticlib_prefix = format!(\"{}{}{}\", staticpair.0, self.crate_name, extra_prefix);\n+        let staticlib_prefix =\n+            format!(\"{}{}{}\", self.target.options.staticlib_prefix, self.crate_name, extra_prefix);\n \n         let mut candidates: FxHashMap<_, (FxHashMap<_, _>, FxHashMap<_, _>, FxHashMap<_, _>)> =\n             Default::default();\n@@ -554,10 +552,18 @@ impl<'a> CrateLocator<'a> {\n                 (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n             } else if file.starts_with(&rlib_prefix) && file.ends_with(\".rmeta\") {\n                 (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n-            } else if file.starts_with(&dylib_prefix) && file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n+            } else if file.starts_with(&dylib_prefix)\n+                && file.ends_with(&self.target.options.dll_suffix)\n+            {\n+                (\n+                    &file\n+                        [(dylib_prefix.len())..(file.len() - self.target.options.dll_suffix.len())],\n+                    CrateFlavor::Dylib,\n+                )\n             } else {\n-                if file.starts_with(&staticlib_prefix) && file.ends_with(&staticpair.1) {\n+                if file.starts_with(&staticlib_prefix)\n+                    && file.ends_with(&self.target.options.staticlib_suffix)\n+                {\n                     staticlibs\n                         .push(CrateMismatch { path: spf.path.clone(), got: \"static\".to_string() });\n                 }\n@@ -859,32 +865,19 @@ impl<'a> CrateLocator<'a> {\n         Some(hash)\n     }\n \n-    // Returns the corresponding (prefix, suffix) that files need to have for\n-    // dynamic libraries\n-    fn dylibname(&self) -> (String, String) {\n-        let t = &self.target;\n-        (t.options.dll_prefix.clone(), t.options.dll_suffix.clone())\n-    }\n-\n-    // Returns the corresponding (prefix, suffix) that files need to have for\n-    // static libraries\n-    fn staticlibname(&self) -> (String, String) {\n-        let t = &self.target;\n-        (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n-    }\n-\n     fn find_commandline_library(&mut self) -> Option<Library> {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n         let sess = self.sess;\n-        let dylibname = self.dylibname();\n         let mut rlibs = FxHashMap::default();\n         let mut rmetas = FxHashMap::default();\n         let mut dylibs = FxHashMap::default();\n         {\n             let crate_name = self.crate_name;\n             let rejected_via_filename = &mut self.rejected_via_filename;\n+            let dll_prefix = &self.target.options.dll_prefix;\n+            let dll_suffix = &self.target.options.dll_suffix;\n             let locs = self.exact_paths.iter().filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\n@@ -909,8 +902,7 @@ impl<'a> CrateLocator<'a> {\n                 {\n                     return true;\n                 } else {\n-                    let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(&prefix[..]) && file.ends_with(&suffix[..]) {\n+                    if file.starts_with(dll_prefix) && file.ends_with(dll_suffix) {\n                         return true;\n                     }\n                 }"}]}