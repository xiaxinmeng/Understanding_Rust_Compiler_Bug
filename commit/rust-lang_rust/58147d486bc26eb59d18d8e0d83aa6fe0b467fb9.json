{"sha": "58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MTQ3ZDQ4NmJjMjZlYjU5ZDE4ZDhlMGQ4M2FhNmZlMGI0NjdmYjk=", "commit": {"author": {"name": "Dan Robertson", "email": "dan@dlrobertson.com", "date": "2018-11-30T15:53:44Z"}, "committer": {"name": "Dan Robertson", "email": "dan@dlrobertson.com", "date": "2019-02-27T15:21:35Z"}, "message": "Support defining C compatible variadic functions\n\nAdd support for defining C compatible variadic functions in unsafe rust\nwith extern \"C\".", "tree": {"sha": "3e25be958b33c7e5727b059511157ac9f1a22722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e25be958b33c7e5727b059511157ac9f1a22722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEkZ4/WpQ0/P8yWDLRTebu+Etcl4MFAlx2qwIACgkQTebu+Etc\nl4N0iw/+IG9SyUrkNA/XQDeUq97PVyrri0JhaxJj0XlxMFegYnIZWgMkPH27fWxk\nUVTe+KdM5J/u1XLDNOIw0Hbrserk5cIMumWYtQ0I/EoSUONbizJH486VRolC0QJ5\nxOdo2g4vOZqfe5hoI3XA8yH+luTxNrpC8in3/HB6DcdA3ihBfGdit5H8OGVDymv9\nxlW1ExWtAuDVU0V3FxDB+1ClwpGsmXFpQqT8+4Bumx9kS2UjMHhGbjUDkjevgUDC\nXR3aw4hCwywmV4irySZ46xTBLkCAa9LAbA3x5I0HTO3iOIfn+FZ0ihlfT2mm1ZRM\nHgOMHEEFuysd9ech/hPLIPfFXkNomyyKJ4IBJ6z0V5hA1qafUPifeFxeaCisY7ke\n5Cl+6rbbeTa6ee1/qp/OJQCLTagMZ4V6Nb1j9A43zivM0v+bIC1pu7N/Wllju0ow\nH8O1TUXHfKUz/EEKpAlhS9Wfr9i7OTCJfE36BTP0KgqzP96ZgKz2bdtTCvJ7n7Tw\nDC9bSFzfrGS5JeEfd6ZQp1zQKFuyehrWm2MkS4qZg0krWSSk79Q4jY4m6pFjhGNU\nayg3zSNj943LRSeguOuX4A9EnxD96AsUzHrU6f7ElT2eFuWpfEqxdq2C7ebGaMpB\nmkBZmkDeXdgei4Ie52tvZ/nwxJeAm0X5/K9hRMI7hTN9IlSDrK8=\n=zwzT\n-----END PGP SIGNATURE-----", "payload": "tree 3e25be958b33c7e5727b059511157ac9f1a22722\nparent cd56472cc47981e62c684ceada7922ac3731b785\nauthor Dan Robertson <dan@dlrobertson.com> 1543593224 +0000\ncommitter Dan Robertson <dan@dlrobertson.com> 1551280895 -0500\n\nSupport defining C compatible variadic functions\n\nAdd support for defining C compatible variadic functions in unsafe rust\nwith extern \"C\".\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "html_url": "https://github.com/rust-lang/rust/commit/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/comments", "author": {"login": "dlrobertson", "id": 7504153, "node_id": "MDQ6VXNlcjc1MDQxNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/7504153?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlrobertson", "html_url": "https://github.com/dlrobertson", "followers_url": "https://api.github.com/users/dlrobertson/followers", "following_url": "https://api.github.com/users/dlrobertson/following{/other_user}", "gists_url": "https://api.github.com/users/dlrobertson/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlrobertson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlrobertson/subscriptions", "organizations_url": "https://api.github.com/users/dlrobertson/orgs", "repos_url": "https://api.github.com/users/dlrobertson/repos", "events_url": "https://api.github.com/users/dlrobertson/events{/privacy}", "received_events_url": "https://api.github.com/users/dlrobertson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dlrobertson", "id": 7504153, "node_id": "MDQ6VXNlcjc1MDQxNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/7504153?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlrobertson", "html_url": "https://github.com/dlrobertson", "followers_url": "https://api.github.com/users/dlrobertson/followers", "following_url": "https://api.github.com/users/dlrobertson/following{/other_user}", "gists_url": "https://api.github.com/users/dlrobertson/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlrobertson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlrobertson/subscriptions", "organizations_url": "https://api.github.com/users/dlrobertson/orgs", "repos_url": "https://api.github.com/users/dlrobertson/repos", "events_url": "https://api.github.com/users/dlrobertson/events{/privacy}", "received_events_url": "https://api.github.com/users/dlrobertson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd56472cc47981e62c684ceada7922ac3731b785", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd56472cc47981e62c684ceada7922ac3731b785", "html_url": "https://github.com/rust-lang/rust/commit/cd56472cc47981e62c684ceada7922ac3731b785"}], "stats": {"total": 1000, "additions": 848, "deletions": 152}, "files": [{"sha": "8e4b9a5e8e641db7e529351fe4682b87cfc76d9b", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -617,6 +617,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }\n+        TyKind::CVarArgs(ref lt) => {\n+            visitor.visit_lifetime(lt)\n+        }\n         TyKind::Infer | TyKind::Err => {}\n     }\n }"}, {"sha": "0e2b34d4facf8fc1affb73a2071c4207e4143276", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1345,6 +1345,12 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n             TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n+            TyKind::CVarArgs => {\n+                // Create the implicit lifetime of the \"spoofed\" `VaList`.\n+                let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n+                let lt = self.new_implicit_lifetime(span);\n+                hir::TyKind::CVarArgs(lt)\n+            },\n         };\n \n         let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(t.id);"}, {"sha": "205109d18fe25830e93f318458b407062b8abf3e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1829,6 +1829,9 @@ pub enum TyKind {\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n     Err,\n+    /// Placeholder for C-variadic arguments. We \"spoof\" the `VaList` created\n+    /// from the variadic arguments. This type is only valid up to typeck.\n+    CVarArgs(Lifetime),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "8c252b0d0274360de3a593eede50049ae0434061", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -434,6 +434,9 @@ impl<'a> State<'a> {\n                 self.s.word(\"/*ERROR*/\")?;\n                 self.pclose()?;\n             }\n+            hir::TyKind::CVarArgs(_) => {\n+                self.s.word(\"...\")?;\n+            }\n         }\n         self.end()\n     }"}, {"sha": "b7ec5889d6ae200177fe2fc263d0c74694280c4d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -361,7 +361,8 @@ impl_stable_hash_for!(enum hir::TyKind {\n     TraitObject(trait_refs, lifetime),\n     Typeof(body_id),\n     Err,\n-    Infer\n+    Infer,\n+    CVarArgs(lt),\n });\n \n impl_stable_hash_for!(struct hir::FnDecl {"}, {"sha": "832391d44162bba2ca5610f3d7d88c11e0938207", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -764,6 +764,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     });\n                 }\n             }\n+            hir::TyKind::CVarArgs(ref lt) => {\n+                // Resolve the generated lifetime for the C-variadic arguments.\n+                // The lifetime is generated in AST -> HIR lowering.\n+                if lt.name.is_elided() {\n+                    self.resolve_elided_lifetimes(vec![lt])\n+                }\n+            }\n             _ => intravisit::walk_ty(self, ty),\n         }\n     }\n@@ -2225,18 +2232,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_in(1);\n                 }\n-                if let hir::TyKind::TraitObject(ref bounds, ref lifetime) = ty.node {\n-                    for bound in bounds {\n-                        self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                    }\n+                match ty.node {\n+                    hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+                        for bound in bounds {\n+                            self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                        }\n \n-                    // Stay on the safe side and don't include the object\n-                    // lifetime default (which may not end up being used).\n-                    if !lifetime.is_elided() {\n-                        self.visit_lifetime(lifetime);\n+                        // Stay on the safe side and don't include the object\n+                        // lifetime default (which may not end up being used).\n+                        if !lifetime.is_elided() {\n+                            self.visit_lifetime(lifetime);\n+                        }\n+                    }\n+                    hir::TyKind::CVarArgs(_) => {}\n+                    _ => {\n+                        intravisit::walk_ty(self, ty);\n                     }\n-                } else {\n-                    intravisit::walk_ty(self, ty);\n                 }\n                 if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_out(1);"}, {"sha": "7ade035ce8908b2d9c275a7b4d9b48f128ed57a7", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -977,9 +977,9 @@ impl<'tcx> PolyGenSig<'tcx> {\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n-/// - `inputs` is the list of arguments and their modes.\n-/// - `output` is the return type.\n-/// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n+/// - `inputs`: is the list of arguments and their modes.\n+/// - `output`: is the return type.\n+/// - `variadic`: indicates whether this is a C-variadic function.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx List<Ty<'tcx>>,"}, {"sha": "aea62360651c02918cfdab1b7052b00fcde5b01a", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -258,7 +258,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             val\n         };\n         match self.mode {\n-            PassMode::Ignore => {},\n+            PassMode::Ignore(_) => {}\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n@@ -507,6 +507,14 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             }\n         };\n \n+        // Store the index of the last argument. This is useful for working with\n+        // C-compatible variadic arguments.\n+        let last_arg_idx = if sig.inputs().is_empty() {\n+            None\n+        } else {\n+            Some(sig.inputs().len() - 1)\n+        };\n+\n         let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n             let is_return = arg_idx.is_none();\n             let mut arg = mk_arg_type(ty, arg_idx);\n@@ -516,7 +524,30 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 // The same is true for s390x-unknown-linux-gnu\n                 // and sparc64-unknown-linux-gnu.\n                 if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n-                    arg.mode = PassMode::Ignore;\n+                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n+                }\n+            }\n+\n+            // If this is a C-variadic function, this is not the return value,\n+            // and there is one or more fixed arguments; ensure that the `VaList`\n+            // is ignored as an argument.\n+            if sig.variadic {\n+                match (last_arg_idx, arg_idx) {\n+                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n+                        let va_list_did = match cx.tcx.lang_items().va_list() {\n+                            Some(did) => did,\n+                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n+                        };\n+                        match ty.sty {\n+                            ty::Adt(def, _) if def.did == va_list_did => {\n+                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n+                                // so that it will be ignored.\n+                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n+                            },\n+                            _ => (),\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n \n@@ -646,7 +677,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         );\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore => cx.type_void(),\n+            PassMode::Ignore(IgnoreMode::Zst) => cx.type_void(),\n+            PassMode::Ignore(IgnoreMode::CVarArgs) =>\n+                bug!(\"`va_list` should never be a return type\"),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n@@ -664,7 +697,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             }\n \n             let llarg_ty = match arg.mode {\n-                PassMode::Ignore => continue,\n+                PassMode::Ignore(_) => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 0, true));\n@@ -733,7 +766,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n-                PassMode::Ignore => {}\n+                PassMode::Ignore(_) => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs, None) => apply(attrs),\n                 PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n@@ -780,7 +813,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n-                PassMode::Ignore => {}\n+                PassMode::Ignore(_) => {}\n                 PassMode::Direct(ref attrs) |\n                 PassMode::Indirect(ref attrs, None) => apply(attrs),\n                 PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {"}, {"sha": "3268af396a2f4f475c2353b3ed76ea66083c8ec9", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -136,22 +136,18 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let tp_ty = substs.type_at(0);\n                 self.const_usize(self.size_of(tp_ty).bytes())\n             }\n-            func @ \"va_start\" | func @ \"va_end\" => {\n-                let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n-                    (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n-                    (Some(_), _) => self.load(args[0].immediate(),\n-                                              tcx.data_layout.pointer_align.abi),\n-                    (None, _) => bug!(\"va_list language item must be defined\")\n-                };\n-                let intrinsic = self.cx().get_intrinsic(&format!(\"llvm.{}\", func));\n-                self.call(intrinsic, &[va_list], None)\n+            \"va_start\" => {\n+                self.va_start(args[0].immediate())\n+            }\n+            \"va_end\" => {\n+                self.va_end(args[0].immediate())\n             }\n             \"va_copy\" => {\n                 let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n                     (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n                     (Some(_), _)  => self.load(args[0].immediate(),\n                                                tcx.data_layout.pointer_align.abi),\n-                    (None, _) => bug!(\"va_list language item must be defined\")\n+                    (None, _) => bug!(\"`va_list` language item must be defined\")\n                 };\n                 let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n                 self.call(intrinsic, &[llresult, va_list], None);\n@@ -722,6 +718,41 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let expect = self.get_intrinsic(&\"llvm.expect.i1\");\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n+\n+    fn va_start(&mut self, list: &'ll Value) -> &'ll Value {\n+        let target = &self.cx.tcx.sess.target.target;\n+        let arch = &target.arch;\n+        // A pointer to the architecture specific structure is passed to this\n+        // function. For pointer variants (i686, RISC-V, Windows, etc), we\n+        // should do do nothing, as the address to the pointer is needed. For\n+        // architectures with a architecture specific structure (`Aarch64`,\n+        // `X86_64`, etc), this function should load the structure from the\n+        // address provided.\n+        let va_list = match &**arch {\n+            _ if target.options.is_like_windows => list,\n+            \"aarch64\" if target.target_os == \"ios\" => list,\n+            \"aarch64\" | \"x86_64\" | \"powerpc\" =>\n+                self.load(list, self.tcx().data_layout.pointer_align.abi),\n+            _ => list,\n+        };\n+        let intrinsic = self.cx().get_intrinsic(\"llvm.va_start\");\n+        self.call(intrinsic, &[va_list], None)\n+    }\n+\n+    fn va_end(&mut self, list: &'ll Value) -> &'ll Value {\n+        let target = &self.cx.tcx.sess.target.target;\n+        let arch = &target.arch;\n+        // See the comment in `va_start` for the purpose of the following.\n+        let va_list = match &**arch {\n+            _ if target.options.is_like_windows => list,\n+            \"aarch64\" if target.target_os == \"ios\" => list,\n+            \"aarch64\" | \"x86_64\" | \"powerpc\" =>\n+                self.load(list, self.tcx().data_layout.pointer_align.abi),\n+            _ => list,\n+        };\n+        let intrinsic = self.cx().get_intrinsic(\"llvm.va_end\");\n+        self.call(intrinsic, &[va_list], None)\n+    }\n }\n \n fn copy_intrinsic("}, {"sha": "7f0cdb9f580088b1b49f0e0ee1d08596f42afcb7", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -36,10 +36,10 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn predefine_fn(&self,\n-                              instance: Instance<'tcx>,\n-                              linkage: Linkage,\n-                              visibility: Visibility,\n-                              symbol_name: &str) {\n+                    instance: Instance<'tcx>,\n+                    linkage: Linkage,\n+                    visibility: Visibility,\n+                    symbol_name: &str) {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n "}, {"sha": "7aceaea4510ceb156246f1cea7cafcb110b548fc", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -109,12 +109,12 @@ pub(super) fn emit_va_arg(\n                             Align::from_bytes(4).unwrap(), true)\n         }\n         // Windows Aarch64\n-        (\"aarch4\", true) => {\n+        (\"aarch64\", true) => {\n             emit_ptr_va_arg(bx, addr, target_ty, false,\n                             Align::from_bytes(8).unwrap(), false)\n         }\n         // iOS Aarch64\n-        (\"aarch4\", _) if target.target_os == \"ios\" => {\n+        (\"aarch64\", _) if target.target_os == \"ios\" => {\n             emit_ptr_va_arg(bx, addr, target_ty, false,\n                             Align::from_bytes(8).unwrap(), true)\n         }"}, {"sha": "f40aa0cb6d1286d2cbf52c99b7b02581d1d50d9d", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::interpret::EvalErrorKind;\n-use rustc_target::abi::call::{ArgType, FnType, PassMode};\n+use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n use rustc_target::spec::abi::Abi;\n use rustc_mir::monomorphize;\n use crate::base;\n@@ -18,7 +18,7 @@ use syntax_pos::Pos;\n \n use super::{FunctionCx, LocalRef};\n use super::place::PlaceRef;\n-use super::operand::OperandRef;\n+use super::operand::{OperandValue, OperandRef};\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -232,12 +232,21 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Return => {\n+                if self.fn_ty.variadic {\n+                    if let Some(va_list) = self.va_list_ref {\n+                        bx.va_end(va_list.llval);\n+                    }\n+                }\n                 let llval = match self.fn_ty.ret.mode {\n-                    PassMode::Ignore | PassMode::Indirect(..) => {\n+                    PassMode::Ignore(IgnoreMode::Zst) | PassMode::Indirect(..) => {\n                         bx.ret_void();\n                         return;\n                     }\n \n+                    PassMode::Ignore(IgnoreMode::CVarArgs) => {\n+                        bug!(\"C variadic arguments should never be the return type\");\n+                    }\n+\n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n                         let op =\n                             self.codegen_consume(&mut bx, &mir::Place::Local(mir::RETURN_PLACE));\n@@ -481,7 +490,10 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     return;\n                 }\n \n-                let extra_args = &args[sig.inputs().len()..];\n+                // The \"spoofed\" `VaList` added to a C-variadic functions signature\n+                // should not be included in the `extra_args` calculation.\n+                let extra_args_start_idx = sig.inputs().len() - if sig.variadic { 1 } else { 0 };\n+                let extra_args = &args[extra_args_start_idx..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n                     let op_ty = op_arg.ty(self.mir, bx.tcx());\n                     self.monomorphize(&op_ty)\n@@ -658,7 +670,37 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     (&args[..], None)\n                 };\n \n+                // Useful determining if the current argument is the \"spoofed\" `VaList`\n+                let last_arg_idx = if sig.inputs().is_empty() {\n+                    None\n+                } else {\n+                    Some(sig.inputs().len() - 1)\n+                };\n                 'make_args: for (i, arg) in first_args.iter().enumerate() {\n+                    // If this is a C-variadic function the function signature contains\n+                    // an \"spoofed\" `VaList`. This argument is ignored, but we need to\n+                    // populate it with a dummy operand so that the users real arguments\n+                    // are not overwritten.\n+                    let i = if sig.variadic && last_arg_idx.map(|x| x == i).unwrap_or(false) {\n+                        let layout = match tcx.lang_items().va_list() {\n+                            Some(did) => bx.cx().layout_of(bx.tcx().type_of(did)),\n+                            None => bug!(\"va_list language item required for C variadics\"),\n+                        };\n+                        let op = OperandRef {\n+                            val: OperandValue::Immediate(\n+                                bx.cx().const_undef(bx.cx().immediate_backend_type(layout))\n+                            ),\n+                            layout: layout,\n+                        };\n+                        self.codegen_argument(&mut bx, op, &mut llargs, &fn_ty.args[i]);\n+                        if i + 1 < fn_ty.args.len() {\n+                            i + 1\n+                        } else {\n+                            break 'make_args\n+                        }\n+                    } else {\n+                        i\n+                    };\n                     let mut op = self.codegen_operand(&mut bx, arg);\n \n                     if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {"}, {"sha": "95cf8cfe2d03930038472d53b2d4f788318817d5", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::{self, Mir};\n use rustc::ty::subst::SubstsRef;\n use rustc::session::config::DebugInfo;\n use rustc_mir::monomorphize::Instance;\n-use rustc_target::abi::call::{FnType, PassMode};\n+use rustc_target::abi::call::{FnType, PassMode, IgnoreMode};\n use crate::base;\n use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n@@ -86,6 +86,10 @@ pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n \n     /// If this function is being monomorphized, this contains the type substitutions used.\n     param_substs: SubstsRef<'tcx>,\n+\n+    /// If this function is a C-variadic function, this contains the `PlaceRef` of the\n+    /// \"spoofed\" `VaList`.\n+    va_list_ref: Option<PlaceRef<'tcx, Bx::Value>>,\n }\n \n impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -246,13 +250,18 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             assert!(!instance.substs.needs_infer());\n             instance.substs\n         },\n+        va_list_ref: None,\n     };\n \n     let memory_locals = analyze::non_ssa_locals(&fx);\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&mut bx, &fx, &fx.scopes, &memory_locals);\n+        // FIXME(dlrobertson): This is ugly. Find a better way of getting the `PlaceRef` or\n+        // `LocalRef` from `arg_local_refs`\n+        let mut va_list_ref = None;\n+        let args = arg_local_refs(&mut bx, &fx, &fx.scopes, &memory_locals, &mut va_list_ref);\n+        fx.va_list_ref = va_list_ref;\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n@@ -433,6 +442,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         debuginfo::MirDebugScope<Bx::DIScope>\n     >,\n     memory_locals: &BitSet<mir::Local>,\n+    va_list_ref: &mut Option<PlaceRef<'tcx, Bx::Value>>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n     let tcx = fx.cx.tcx();\n@@ -447,6 +457,15 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         None\n     };\n \n+    // Store the index of the last argument. This is used to\n+    // call va_start on the va_list instead of attempting\n+    // to store_fn_arg.\n+    let last_arg_idx = if fx.fn_ty.args.is_empty() {\n+        None\n+    } else {\n+        Some(fx.fn_ty.args.len() - 1)\n+    };\n+\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n@@ -510,9 +529,16 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             // of putting everything in allocas just so we can use llvm.dbg.declare.\n             let local = |op| LocalRef::Operand(Some(op));\n             match arg.mode {\n-                PassMode::Ignore => {\n+                PassMode::Ignore(IgnoreMode::Zst) => {\n                     return local(OperandRef::new_zst(bx.cx(), arg.layout));\n                 }\n+                PassMode::Ignore(IgnoreMode::CVarArgs) => {\n+                    let backend_type = bx.cx().immediate_backend_type(arg.layout);\n+                    return local(OperandRef {\n+                        val: OperandValue::Immediate(bx.cx().const_undef(backend_type)),\n+                        layout: arg.layout,\n+                    });\n+                }\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(bx.llfn(), llarg_idx as c_uint);\n                     bx.set_value_name(llarg, &name);\n@@ -559,9 +585,35 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n-            let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n-            bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n-            tmp\n+            if fx.fn_ty.variadic && last_arg_idx.map(|idx| arg_index == idx).unwrap_or(false) {\n+                let va_list_impl = match arg_decl.ty.ty_adt_def() {\n+                    Some(adt) => adt.non_enum_variant(),\n+                    None => bug!(\"`va_list` language item improperly constructed\")\n+                };\n+                match tcx.type_of(va_list_impl.fields[0].did).sty {\n+                    ty::Ref(_, ty, _) => {\n+                        // If the underlying structure the `VaList` contains is a structure,\n+                        // we need to allocate it (e.g., X86_64 on Linux).\n+                        let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+                        if let ty::Adt(..) = ty.sty {\n+                            let layout = bx.layout_of(ty);\n+                            // Create an unnamed allocation for the backing structure\n+                            // and store it in the the spoofed `VaList`.\n+                            let backing = PlaceRef::alloca(bx, layout, \"\");\n+                            bx.store(backing.llval, tmp.llval, layout.align.abi);\n+                        }\n+                        // Call `va_start` on the spoofed `VaList`.\n+                        bx.va_start(tmp.llval);\n+                        *va_list_ref = Some(tmp);\n+                        tmp\n+                    }\n+                    _ => bug!(\"improperly constructed `va_list` lang item\"),\n+                }\n+            } else {\n+                let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+                bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n+                tmp\n+            }\n         };\n         arg_scope.map(|scope| {\n             // Is this a regular argument?"}, {"sha": "cd5278989778ffac031c05d1b92e47883a5a808f", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -20,4 +20,10 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n+    /// Trait method used to inject `va_start` on the \"spoofed\" `VaList` in\n+    /// Rust defined C-variadic functions.\n+    fn va_start(&mut self, val: Self::Value) -> Self::Value;\n+    /// Trait method used to inject `va_end` on the \"spoofed\" `VaList` before\n+    /// Rust defined C-variadic functions return.\n+    fn va_end(&mut self, val: Self::Value) -> Self::Value;\n }"}, {"sha": "fb279a5d9b87910e73cabf1bfbed1831145ce573", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -766,8 +766,15 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n+        let inputs = if sig.variadic {\n+            // Don't include the spoofed `VaList` in the functions list\n+            // of inputs.\n+            &sig.inputs()[..sig.inputs().len() - 1]\n+        } else {\n+            &sig.inputs()[..]\n+        };\n \n-        for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n+        for (input_ty, input_hir) in inputs.iter().zip(&decl.inputs) {\n             self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty);\n         }\n "}, {"sha": "f897795d86f48f3ab6a25f354697cff65a1e4583", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1602,10 +1602,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         from_hir_call: bool,\n     ) {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n-        if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.variadic) {\n+        // Do not count the `VaList` argument as a \"true\" argument to\n+        // a C-variadic function.\n+        let inputs = if sig.variadic {\n+            &sig.inputs()[..sig.inputs().len() - 1]\n+        } else {\n+            &sig.inputs()[..]\n+        };\n+        if args.len() < inputs.len() || (args.len() > inputs.len() && !sig.variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n-        for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n+        for (n, (fn_arg, op_arg)) in inputs.iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n             let category = if from_hir_call {\n                 ConstraintCategory::CallArgument"}, {"sha": "222c43de3b7b1c2c74391c9460b00377fb8a67fa", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -190,6 +190,7 @@ impl Sig for ast::Ty {\n                 Ok(replace_text(nested, text))\n             }\n             ast::TyKind::Never => Ok(text_sig(\"!\".to_owned())),\n+            ast::TyKind::CVarArgs => Ok(text_sig(\"...\".to_owned())),\n             ast::TyKind::Tup(ref ts) => {\n                 let mut text = \"(\".to_owned();\n                 let mut defs = vec![];"}, {"sha": "8ada328a158430855f664d0a1ecfae52e0e35d2c", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -23,10 +23,18 @@ mod x86_64;\n mod x86_win64;\n mod wasm32;\n \n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum IgnoreMode {\n+    /// C-variadic arguments.\n+    CVarArgs,\n+    /// A zero-sized type.\n+    Zst,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum PassMode {\n-    /// Ignore the argument (useful for empty struct).\n-    Ignore,\n+    /// Ignore the argument (useful for empty structs and C-variadic args).\n+    Ignore(IgnoreMode),\n     /// Pass the argument directly.\n     Direct(ArgAttributes),\n     /// Pass a pair's elements directly in two arguments.\n@@ -481,7 +489,10 @@ impl<'a, Ty> ArgType<'a, Ty> {\n     }\n \n     pub fn is_ignore(&self) -> bool {\n-        self.mode == PassMode::Ignore\n+        match self.mode {\n+            PassMode::Ignore(_) => true,\n+            _ => false\n+        }\n     }\n }\n "}, {"sha": "6ca3ce88bd6eb37a9aa9aaadf0d35c23812bccfe", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -88,7 +88,7 @@ pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>, flavor: Fla\n \n         for arg in &mut fty.args {\n             let attrs = match arg.mode {\n-                PassMode::Ignore |\n+                PassMode::Ignore(_) |\n                 PassMode::Indirect(_, None) => continue,\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..) |"}, {"sha": "1d99584eec494e4d8fb5d5b40d35dad026862ff5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1822,6 +1822,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             hir::TyKind::Err => {\n                 tcx.types.err\n             }\n+            hir::TyKind::CVarArgs(lt) => {\n+                let va_list_did = match tcx.lang_items().va_list() {\n+                    Some(did) => did,\n+                    None => span_bug!(ast_ty.span,\n+                                      \"`va_list` lang item required for variadics\"),\n+                };\n+                let region = self.ast_region_to_region(&lt, None);\n+                tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n+            }\n         };\n \n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);"}, {"sha": "aeb43635eb780fd220715a1753b7f549a27aab75", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -368,17 +368,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .0;\n         let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n+        let inputs = if fn_sig.variadic {\n+            if fn_sig.inputs().len() > 1 {\n+                &fn_sig.inputs()[..fn_sig.inputs().len() - 1]\n+            } else {\n+                span_bug!(call_expr.span,\n+                          \"C-variadic functions are only valid with one or more fixed arguments\");\n+            }\n+        } else {\n+            &fn_sig.inputs()[..]\n+        };\n         // Call the generic checker.\n         let expected_arg_tys = self.expected_inputs_for_expected_output(\n             call_expr.span,\n             expected,\n             fn_sig.output(),\n-            fn_sig.inputs(),\n+            inputs,\n         );\n         self.check_argument_types(\n             call_expr.span,\n             call_expr.span,\n-            fn_sig.inputs(),\n+            inputs,\n             &expected_arg_tys[..],\n             arg_exprs,\n             fn_sig.variadic,"}, {"sha": "924ced2e2a3c77c1cd76729e63734ebd2384fd82", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -337,7 +337,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"va_start\" | \"va_end\" => {\n                 match mk_va_list_ty() {\n                     Some(va_list_ty) => (0, vec![va_list_ty], tcx.mk_unit()),\n-                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                    None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n@@ -364,14 +364,14 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         };\n                         (0, vec![tcx.mk_imm_ref(tcx.mk_region(env_region), va_list_ty)], ret_ty)\n                     }\n-                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                    None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n             \"va_arg\" => {\n                 match mk_va_list_ty() {\n                     Some(va_list_ty) => (1, vec![va_list_ty], param(0)),\n-                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                    None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n "}, {"sha": "53dcc258c690b592495010d0e2046700d03f48c3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1752,7 +1752,6 @@ impl Clean<Item> for doctree::Function {\n pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n-    pub variadic: bool,\n     pub attrs: Attributes,\n }\n \n@@ -1831,7 +1830,6 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n-            variadic: self.0.variadic,\n             attrs: Attributes::default()\n         }\n     }\n@@ -1849,7 +1847,6 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n         FnDecl {\n             output: Return(sig.skip_binder().output().clean(cx)),\n             attrs: Attributes::default(),\n-            variadic: sig.skip_binder().variadic,\n             inputs: Arguments {\n                 values: sig.skip_binder().inputs().iter().map(|t| {\n                     Argument {\n@@ -2252,6 +2249,7 @@ pub enum Type {\n     Slice(Box<Type>),\n     Array(Box<Type>, String),\n     Never,\n+    CVarArgs,\n     Unique(Box<Type>),\n     RawPointer(Mutability, Box<Type>),\n     BorrowedRef {\n@@ -2290,6 +2288,7 @@ pub enum PrimitiveType {\n     Reference,\n     Fn,\n     Never,\n+    CVarArgs,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n@@ -2469,6 +2468,7 @@ impl PrimitiveType {\n             Reference => \"reference\",\n             Fn => \"fn\",\n             Never => \"never\",\n+            CVarArgs => \"...\",\n         }\n     }\n \n@@ -2518,6 +2518,7 @@ impl Clean<Type> for hir::Ty {\n \n         match self.node {\n             TyKind::Never => Never,\n+            TyKind::CVarArgs(_) => CVarArgs,\n             TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyKind::Rptr(ref l, ref m) => {\n                 let lifetime = if l.is_elided() {\n@@ -3654,6 +3655,7 @@ fn build_deref_target_impls(cx: &DocContext<'_, '_, '_>,\n             Reference => None,\n             Fn => None,\n             Never => None,\n+            CVarArgs => tcx.lang_items().va_list(),\n         };\n         if let Some(did) = did {\n             if !did.is_local() {"}, {"sha": "d204a179ca62cb68098cbe9b2dd5ac5b6bf13da7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -609,6 +609,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))\n         }\n         clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n+        clean::CVarArgs => primitive_link(f, PrimitiveType::CVarArgs, \"...\"),\n         clean::RawPointer(m, ref t) => {\n             match **t {\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n@@ -834,18 +835,10 @@ impl fmt::Display for clean::FunctionRetTy {\n \n impl fmt::Display for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.variadic {\n-            if f.alternate() {\n-                write!(f, \"({args:#}, ...){arrow:#}\", args = self.inputs, arrow = self.output)\n-            } else {\n-                write!(f, \"({args}, ...){arrow}\", args = self.inputs, arrow = self.output)\n-            }\n+        if f.alternate() {\n+            write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n         } else {\n-            if f.alternate() {\n-                write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n-            } else {\n-                write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n-            }\n+            write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n         }\n     }\n }\n@@ -907,12 +900,7 @@ impl<'a> fmt::Display for Function<'a> {\n             }\n         }\n \n-        let mut args_plain = format!(\"({})\", args_plain);\n-\n-        if decl.variadic {\n-            args.push_str(\",<br> ...\");\n-            args_plain.push_str(\", ...\");\n-        }\n+        let args_plain = format!(\"({})\", args_plain);\n \n         let output = if let hir::IsAsync::Async = asyncness {\n             Cow::Owned(decl.sugared_async_return_type())"}, {"sha": "5bae00b9cb8462a94bbc0c810fc48656f7d71e2f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1643,6 +1643,8 @@ pub enum TyKind {\n     Mac(Mac),\n     /// Placeholder for a kind that has failed to be defined.\n     Err,\n+    /// Placeholder for a `va_list`.\n+    CVarArgs,\n }\n \n impl TyKind {"}, {"sha": "8efc4689cac82b4ed52cddc0b45639b613d00e03", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -401,7 +401,8 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n     let Ty { id, node, span } = ty.deref_mut();\n     vis.visit_id(id);\n     match node {\n-        TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err | TyKind::Never => {}\n+        TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err |\n+            TyKind::Never | TyKind::CVarArgs => {}\n         TyKind::Slice(ty) => vis.visit_ty(ty),\n         TyKind::Ptr(mt) => vis.visit_mt(mt),\n         TyKind::Rptr(lt, mt) => {"}, {"sha": "b58091b57da4e459b2e7aec02af5e18ad9e9d9d1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 58, "deletions": 48, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1543,7 +1543,7 @@ impl<'a> Parser<'a> {\n                 // definition...\n \n                 // We don't allow argument names to be left off in edition 2018.\n-                p.parse_arg_general(p.span.rust_2018(), true)\n+                p.parse_arg_general(p.span.rust_2018(), true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n \n@@ -1613,15 +1613,15 @@ impl<'a> Parser<'a> {\n     /// Parses an optional return type `[ -> TY ]` in a function declaration.\n     fn parse_ret_ty(&mut self, allow_plus: bool) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n-            Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true)?))\n+            Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true, false)?))\n         } else {\n             Ok(FunctionRetTy::Default(self.span.shrink_to_lo()))\n         }\n     }\n \n     /// Parses a type.\n     pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(true, true)\n+        self.parse_ty_common(true, true, false)\n     }\n \n     /// Parses a type in restricted contexts where `+` is not permitted.\n@@ -1631,11 +1631,11 @@ impl<'a> Parser<'a> {\n     /// Example 2: `value1 as TYPE + value2`\n     ///     `+` is prohibited to avoid interactions with expression grammar.\n     fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(false, true)\n+        self.parse_ty_common(false, true, false)\n     }\n \n-    fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool)\n-                       -> PResult<'a, P<Ty>> {\n+    fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool,\n+                       allow_variadic: bool) -> PResult<'a, P<Ty>> {\n         maybe_whole!(self, NtTy, |x| x);\n \n         let lo = self.span;\n@@ -1772,6 +1772,15 @@ impl<'a> Parser<'a> {\n                     TyKind::Path(None, path)\n                 }\n             }\n+        } else if self.check(&token::DotDotDot) {\n+            if allow_variadic {\n+                self.eat(&token::DotDotDot);\n+                TyKind::CVarArgs\n+            } else {\n+                return Err(self.fatal(\n+                    \"only foreign functions are allowed to be variadic\"\n+                ));\n+            }\n         } else {\n             let msg = format!(\"expected type, found {}\", self.this_token_descr());\n             return Err(self.fatal(&msg));\n@@ -1959,7 +1968,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// This version of parse arg doesn't necessarily require identifier names.\n-    fn parse_arg_general(&mut self, require_name: bool, is_trait_item: bool) -> PResult<'a, Arg> {\n+    fn parse_arg_general(&mut self, require_name: bool, is_trait_item: bool,\n+                         allow_variadic: bool) -> PResult<'a, Arg> {\n         maybe_whole!(self, NtArg, |x| x);\n \n         if let Ok(Some(_)) = self.parse_self_arg() {\n@@ -2008,12 +2018,12 @@ impl<'a> Parser<'a> {\n             }\n \n             self.eat_incorrect_doc_comment(\"a method argument's type\");\n-            (pat, self.parse_ty()?)\n+            (pat, self.parse_ty_common(true, true, allow_variadic)?)\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n             let parser_snapshot_before_ty = self.clone();\n             self.eat_incorrect_doc_comment(\"a method argument's type\");\n-            let mut ty = self.parse_ty();\n+            let mut ty = self.parse_ty_common(true, true, allow_variadic);\n             if ty.is_ok() && self.token != token::Comma &&\n                self.token != token::CloseDelim(token::Paren) {\n                 // This wasn't actually a type, but a pattern looking like a type,\n@@ -2032,6 +2042,11 @@ impl<'a> Parser<'a> {\n                     (pat, ty)\n                 }\n                 Err(mut err) => {\n+                    // If this is a variadic argument and we hit an error, return the\n+                    // error.\n+                    if self.token == token::DotDotDot {\n+                        return Err(err);\n+                    }\n                     // Recover from attempting to parse the argument as a type without pattern.\n                     err.cancel();\n                     mem::replace(self, parser_snapshot_before_ty);\n@@ -2068,7 +2083,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a single function argument.\n     crate fn parse_arg(&mut self) -> PResult<'a, Arg> {\n-        self.parse_arg_general(true, false)\n+        self.parse_arg_general(true, false, false)\n     }\n \n     /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n@@ -2406,7 +2421,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let span = lo.to(self.prev_span);\n                 let output = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty_common(false, false)?)\n+                    Some(self.parse_ty_common(false, false, false)?)\n                 } else {\n                     None\n                 };\n@@ -6118,44 +6133,38 @@ impl<'a> Parser<'a> {\n                 &token::CloseDelim(token::Paren),\n                 SeqSep::trailing_allowed(token::Comma),\n                 |p| {\n-                    if p.token == token::DotDotDot {\n-                        p.bump();\n-                        variadic = true;\n-                        if allow_variadic {\n-                            if p.token != token::CloseDelim(token::Paren) {\n-                                let span = p.span;\n-                                p.span_err(span,\n-                                    \"`...` must be last in argument list for variadic function\");\n-                            }\n-                            Ok(None)\n-                        } else {\n-                            let span = p.prev_span;\n-                            if p.token == token::CloseDelim(token::Paren) {\n-                                // continue parsing to present any further errors\n-                                p.struct_span_err(\n-                                    span,\n-                                    \"only foreign functions are allowed to be variadic\"\n-                                ).emit();\n-                                Ok(Some(dummy_arg(span)))\n-                           } else {\n-                               // this function definition looks beyond recovery, stop parsing\n-                                p.span_err(span,\n-                                           \"only foreign functions are allowed to be variadic\");\n-                                Ok(None)\n-                            }\n-                        }\n+                    // If the argument is a C-variadic argument we should not\n+                    // enforce named arguments.\n+                    let enforce_named_args = if p.token == token::DotDotDot {\n+                        false\n                     } else {\n-                        match p.parse_arg_general(named_args, false) {\n-                            Ok(arg) => Ok(Some(arg)),\n-                            Err(mut e) => {\n-                                e.emit();\n-                                let lo = p.prev_span;\n-                                // Skip every token until next possible arg or end.\n-                                p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n-                                // Create a placeholder argument for proper arg count (#34264).\n-                                let span = lo.to(p.prev_span);\n-                                Ok(Some(dummy_arg(span)))\n+                        named_args\n+                    };\n+                    match p.parse_arg_general(enforce_named_args, false,\n+                                              allow_variadic) {\n+                        Ok(arg) => {\n+                            if let TyKind::CVarArgs = arg.ty.node {\n+                                variadic = true;\n+                                if p.token != token::CloseDelim(token::Paren) {\n+                                    let span = p.span;\n+                                    p.span_err(span,\n+                                        \"`...` must be last in argument list in variadic function\");\n+                                    Ok(None)\n+                                } else {\n+                                    Ok(Some(arg))\n+                                }\n+                            } else {\n+                                Ok(Some(arg))\n                             }\n+                        },\n+                        Err(mut e) => {\n+                            e.emit();\n+                            let lo = p.prev_span;\n+                            // Skip every token until next possible arg or end.\n+                            p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                            // Create a placeholder argument for proper arg count (issue #34264).\n+                            let span = lo.to(p.prev_span);\n+                            Ok(Some(dummy_arg(span)))\n                         }\n                     }\n                 }\n@@ -6389,7 +6398,8 @@ impl<'a> Parser<'a> {\n                      abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl(false)?;\n+        let allow_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n+        let decl = self.parse_fn_decl(allow_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n         let header = FnHeader { unsafety, asyncness, constness, abi };"}, {"sha": "b3964d0ce9c8abfc0c99545585e45a7023ba1b38", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1118,6 +1118,9 @@ impl<'a> State<'a> {\n             ast::TyKind::Mac(ref m) => {\n                 self.print_mac(m)?;\n             }\n+            ast::TyKind::CVarArgs => {\n+                self.s.word(\"...\")?;\n+            }\n         }\n         self.end()\n     }"}, {"sha": "dd9f4f74d9e4812b4bcae9a834c0cdbfbd06587f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -315,7 +315,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Never => {},\n+        TyKind::Never | TyKind::CVarArgs => {}\n         TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }"}, {"sha": "09c18ed90b21655536d118ac39bc65da6607541b", "filename": "src/test/codegen/c-variadic.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fc-variadic.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -0,0 +1,69 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_variadic)]\n+#![no_std]\n+use core::ffi::VaList;\n+\n+extern \"C\" {\n+    fn foreign_c_variadic_0(_: i32, ...);\n+    fn foreign_c_variadic_1(_: VaList, ...);\n+}\n+\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_0() {\n+    // Ensure that we correctly call foreign C-variadic functions.\n+    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0(i32 0)\n+    foreign_c_variadic_0(0);\n+    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0(i32 0, i32 42)\n+    foreign_c_variadic_0(0, 42i32);\n+    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0(i32 0, i32 42, i32 1024)\n+    foreign_c_variadic_0(0, 42i32, 1024i32);\n+    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0(i32 0, i32 42, i32 1024, i32 0)\n+    foreign_c_variadic_0(0, 42i32, 1024i32, 0i32);\n+}\n+\n+// Ensure that we do not remove the `va_list` passed to the foreign function when\n+// removing the \"spoofed\" `VaList` that is used by Rust defined C-variadics.\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_1_0(ap: VaList) {\n+    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap)\n+    foreign_c_variadic_1(ap);\n+}\n+\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_1_1(ap: VaList) {\n+    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, i32 42)\n+    foreign_c_variadic_1(ap, 42i32);\n+}\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_1_2(ap: VaList) {\n+    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, i32 2, i32 42)\n+    foreign_c_variadic_1(ap, 2i32, 42i32);\n+}\n+\n+pub unsafe extern \"C\" fn use_foreign_c_variadic_1_3(ap: VaList) {\n+    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, i32 2, i32 42, i32 0)\n+    foreign_c_variadic_1(ap, 2i32, 42i32, 0i32);\n+}\n+\n+// Ensure that `va_start` and `va_end` are properly injected.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn c_variadic(n: i32, mut ap: ...) -> i32 {\n+    // CHECK: call void @llvm.va_start\n+    let mut sum = 0;\n+    for _ in 0..n {\n+        sum += ap.arg::<i32>();\n+    }\n+    sum\n+    // CHECK: call void @llvm.va_end\n+}\n+\n+// Ensure that we generate the correct `call` signature when calling a Rust\n+// defined C-variadic.\n+pub unsafe fn test_c_variadic_call() {\n+    // CHECK: call i32 (i32, ...) @c_variadic(i32 0)\n+    c_variadic(0);\n+    // CHECK: call i32 (i32, ...) @c_variadic(i32 0, i32 42)\n+    c_variadic(0, 42i32);\n+    // CHECK: call i32 (i32, ...) @c_variadic(i32 0, i32 42, i32 1024)\n+    c_variadic(0, 42i32, 1024i32);\n+    // CHECK: call i32 (i32, ...) @c_variadic(i32 0, i32 42, i32 1024, i32 0)\n+    c_variadic(0, 42i32, 1024i32, 0i32);\n+}"}, {"sha": "96a238afaec05039a5c515bd7b79cfa3317f0523", "filename": "src/test/run-make-fulldeps/c-link-to-rust-va-list-fn/checkrust.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Fcheckrust.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -18,8 +18,10 @@ macro_rules! continue_if {\n \n unsafe fn compare_c_str(ptr: *const c_char, val: &str) -> bool {\n     let cstr0 = CStr::from_ptr(ptr);\n-    let cstr1 = CString::new(val).unwrap();\n-    &*cstr1 == cstr0\n+    match CString::new(val) {\n+        Ok(cstr1) => &*cstr1 == cstr0,\n+        Err(_) => false,\n+    }\n }\n \n #[no_mangle]\n@@ -68,3 +70,24 @@ pub unsafe extern \"C\" fn check_list_copy_0(mut ap: VaList) -> usize {\n         }\n     })\n }\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn check_varargs_0(_: c_int, mut ap: ...) -> usize {\n+    continue_if!(ap.arg::<c_int>() == 42);\n+    continue_if!(compare_c_str(ap.arg::<*const c_char>(), \"Hello, World!\"));\n+    0\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn check_varargs_1(_: c_int, mut ap: ...) -> usize {\n+    continue_if!(ap.arg::<c_double>().floor() == 3.14f64.floor());\n+    continue_if!(ap.arg::<c_long>() == 12);\n+    continue_if!(ap.arg::<c_char>() == 'A' as c_char);\n+    continue_if!(ap.arg::<c_longlong>() == 1);\n+    0\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn check_varargs_2(_: c_int, mut ap: ...) -> usize {\n+    0\n+}"}, {"sha": "91b060dce26f436f6f9f5d21b7d038784dba115d", "filename": "src/test/run-make-fulldeps/c-link-to-rust-va-list-fn/test.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fc-link-to-rust-va-list-fn%2Ftest.c?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -8,6 +8,9 @@ extern size_t check_list_0(va_list ap);\n extern size_t check_list_1(va_list ap);\n extern size_t check_list_2(va_list ap);\n extern size_t check_list_copy_0(va_list ap);\n+extern size_t check_varargs_0(int fixed, ...);\n+extern size_t check_varargs_1(int fixed, ...);\n+extern size_t check_varargs_2(int fixed, ...);\n \n int test_rust(size_t (*fn)(va_list), ...) {\n     size_t ret = 0;\n@@ -26,5 +29,12 @@ int main(int argc, char* argv[]) {\n     assert(test_rust(check_list_2, 3.14, 12l, 'a', 6.28, \"Hello\", 42, \"World\") == 0);\n \n     assert(test_rust(check_list_copy_0, 6.28, 16, 'A', \"Skip Me!\", \"Correct\") == 0);\n+\n+    assert(check_varargs_0(0, 42, \"Hello, World!\") == 0);\n+\n+    assert(check_varargs_1(0, 3.14, 12l, 'A', 0x1LL) == 0);\n+\n+    assert(check_varargs_2(0, \"All\", \"of\", \"these\", \"are\", \"ignored\", \".\") == 0);\n+\n     return 0;\n }"}, {"sha": "5af2aea21fcacd94040f88f726176fedf46a66b4", "filename": "src/test/rustdoc/variadic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Frustdoc%2Fvariadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Frustdoc%2Fvariadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvariadic.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1,4 +1,4 @@\n extern \"C\" {\n-    // @has variadic/fn.foo.html //pre 'pub unsafe extern \"C\" fn foo(x: i32, ...)'\n+    // @has variadic/fn.foo.html //pre 'pub unsafe extern \"C\" fn foo(x: i32, _: ...)'\n     pub fn foo(x: i32, ...);\n }"}, {"sha": "61b2ad4bed576338b2822c765885087de599aac5", "filename": "src/test/ui/c-variadic/variadic-ffi-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "previous_filename": "src/test/ui/variadic/variadic-ffi.rs"}, {"sha": "52d7394d6af055823bedbed2fa67ad4176a88223", "filename": "src/test/ui/c-variadic/variadic-ffi-1.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-1.stderr?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -1,5 +1,5 @@\n error[E0045]: variadic function must have C or cdecl calling convention\n-  --> $DIR/variadic-ffi.rs:5:5\n+  --> $DIR/variadic-ffi-1.rs:5:5\n    |\n LL |     fn printf(_: *const u8, ...); //~ ERROR: variadic function must have C or cdecl calling\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variadics require C or cdecl calling convention", "previous_filename": "src/test/ui/variadic/variadic-ffi.stderr"}, {"sha": "224ac16f4586abefac49b224a727cf22f09a0faa", "filename": "src/test/ui/c-variadic/variadic-ffi-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "previous_filename": "src/test/ui/variadic/variadic-ffi-2.rs"}, {"sha": "cb2a9f874b7b34e317368b98076c3e164b7dd75b", "filename": "src/test/ui/c-variadic/variadic-ffi-2.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-2.stderr?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "previous_filename": "src/test/ui/variadic/variadic-ffi-2.stderr"}, {"sha": "c02d1f54e56492a3ca3c20dd4457f21e78dd73b3", "filename": "src/test/ui/c-variadic/variadic-ffi-3.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -14,12 +14,10 @@ fn main() {\n         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n         //~^ ERROR: mismatched types\n         //~| expected type `unsafe extern \"C\" fn(isize, u8)`\n-        //~| found type `unsafe extern \"C\" fn(isize, u8, ...) {foo}`\n \n         let y: extern \"C\" fn(f: isize, x: u8, ...) = bar;\n         //~^ ERROR: mismatched types\n-        //~| expected type `extern \"C\" fn(isize, u8, ...)`\n-        //~| found type `extern \"C\" fn(isize, u8) {bar}`\n+        //~| expected type `for<'r> extern \"C\" fn(isize, u8, std::ffi::VaList<'r>, ...)`\n \n         foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function\n         foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function", "previous_filename": "src/test/ui/variadic/variadic-ffi-3.rs"}, {"sha": "82e3c6cd06fc5218948ce34528ed5afd6ab3cad4", "filename": "src/test/ui/c-variadic/variadic-ffi-3.stderr", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-3.stderr?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -23,49 +23,49 @@ LL |         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n    |                                                        ^^^ expected non-variadic fn, found variadic function\n    |\n    = note: expected type `unsafe extern \"C\" fn(isize, u8)`\n-              found type `unsafe extern \"C\" fn(isize, u8, ...) {foo}`\n+              found type `for<'r> unsafe extern \"C\" fn(isize, u8, std::ffi::VaList<'r>, ...) {foo}`\n \n error[E0308]: mismatched types\n-  --> $DIR/variadic-ffi-3.rs:19:54\n+  --> $DIR/variadic-ffi-3.rs:18:54\n    |\n LL |         let y: extern \"C\" fn(f: isize, x: u8, ...) = bar;\n    |                                                      ^^^ expected variadic fn, found non-variadic function\n    |\n-   = note: expected type `extern \"C\" fn(isize, u8, ...)`\n+   = note: expected type `for<'r> extern \"C\" fn(isize, u8, std::ffi::VaList<'r>, ...)`\n               found type `extern \"C\" fn(isize, u8) {bar}`\n \n error[E0617]: can't pass `f32` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:24:19\n+  --> $DIR/variadic-ffi-3.rs:22:19\n    |\n LL |         foo(1, 2, 3f32); //~ ERROR can't pass `f32` to variadic function\n    |                   ^^^^ help: cast the value to `c_double`: `3f32 as c_double`\n \n error[E0617]: can't pass `bool` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:25:19\n+  --> $DIR/variadic-ffi-3.rs:23:19\n    |\n LL |         foo(1, 2, true); //~ ERROR can't pass `bool` to variadic function\n    |                   ^^^^ help: cast the value to `c_int`: `true as c_int`\n \n error[E0617]: can't pass `i8` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:26:19\n+  --> $DIR/variadic-ffi-3.rs:24:19\n    |\n LL |         foo(1, 2, 1i8); //~ ERROR can't pass `i8` to variadic function\n    |                   ^^^ help: cast the value to `c_int`: `1i8 as c_int`\n \n error[E0617]: can't pass `u8` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:27:19\n+  --> $DIR/variadic-ffi-3.rs:25:19\n    |\n LL |         foo(1, 2, 1u8); //~ ERROR can't pass `u8` to variadic function\n    |                   ^^^ help: cast the value to `c_uint`: `1u8 as c_uint`\n \n error[E0617]: can't pass `i16` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:28:19\n+  --> $DIR/variadic-ffi-3.rs:26:19\n    |\n LL |         foo(1, 2, 1i16); //~ ERROR can't pass `i16` to variadic function\n    |                   ^^^^ help: cast the value to `c_int`: `1i16 as c_int`\n \n error[E0617]: can't pass `u16` to variadic function\n-  --> $DIR/variadic-ffi-3.rs:29:19\n+  --> $DIR/variadic-ffi-3.rs:27:19\n    |\n LL |         foo(1, 2, 1u16); //~ ERROR can't pass `u16` to variadic function\n    |                   ^^^^ help: cast the value to `c_uint`: `1u16 as c_uint`", "previous_filename": "src/test/ui/variadic/variadic-ffi-3.stderr"}, {"sha": "9101be56456463361a4f6b6c5a19f413d8438e27", "filename": "src/test/ui/c-variadic/variadic-ffi-4.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -0,0 +1,29 @@\n+#![crate_type=\"lib\"]\n+#![no_std]\n+#![feature(c_variadic)]\n+\n+use core::ffi::VaList;\n+\n+pub unsafe extern \"C\" fn no_escape0<'a>(_: usize, ap: ...) -> VaList<'a> {\n+    ap //~ ERROR: explicit lifetime required\n+}\n+\n+pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaList<'static> {\n+    ap //~ ERROR: explicit lifetime required\n+}\n+\n+pub unsafe extern \"C\" fn no_escape2(_: usize, ap: ...) {\n+    let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+}\n+\n+pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+    *ap0 = ap1; //~ ERROR: mismatched types\n+}\n+\n+pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+    ap0 = &mut ap1;\n+    //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+    //~^^ ERROR: mismatched types\n+    //~^^^ ERROR: mismatched types\n+    //~^^^^ ERROR: cannot infer an appropriate lifetime\n+}"}, {"sha": "1d752be065c4aad1ef5924df62a3244c71dc9987", "filename": "src/test/ui/c-variadic/variadic-ffi-4.stderr", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -0,0 +1,198 @@\n+error[E0621]: explicit lifetime required in the type of `ap`\n+  --> $DIR/variadic-ffi-4.rs:8:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape0<'a>(_: usize, ap: ...) -> VaList<'a> {\n+   |                                                       --- help: add explicit lifetime `'a` to the type of `ap`: `core::ffi::VaList<'a>`\n+LL |     ap //~ ERROR: explicit lifetime required\n+   |     ^^ lifetime `'a` required\n+\n+error[E0621]: explicit lifetime required in the type of `ap`\n+  --> $DIR/variadic-ffi-4.rs:12:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaList<'static> {\n+   |                                                   --- help: add explicit lifetime `'static` to the type of `ap`: `core::ffi::VaList<'static>`\n+LL |     ap //~ ERROR: explicit lifetime required\n+   |     ^^ lifetime `'static` required\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/variadic-ffi-4.rs:16:28\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+   |                            ^^\n+   |\n+note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the body at 16:21...\n+  --> $DIR/variadic-ffi-4.rs:16:21\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+   |                     ^^^^^^^^^^^\n+   = note: ...so that the expression is assignable:\n+           expected core::ffi::VaList<'_>\n+              found core::ffi::VaList<'_>\n+note: but, the lifetime must be valid for the method call at 16:13...\n+  --> $DIR/variadic-ffi-4.rs:16:13\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+note: ...so type `core::ffi::VaList<'_>` of expression is valid during the expression\n+  --> $DIR/variadic-ffi-4.rs:16:13\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: cannot infer an appropriate lifetime\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variadic-ffi-4.rs:20:12\n+   |\n+LL |     *ap0 = ap1; //~ ERROR: mismatched types\n+   |            ^^^ lifetime mismatch\n+   |\n+   = note: expected type `core::ffi::VaList<'_>`\n+              found type `core::ffi::VaList<'_>`\n+note: the anonymous lifetime #3 defined on the function body at 19:1...\n+  --> $DIR/variadic-ffi-4.rs:19:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+LL | |     *ap0 = ap1; //~ ERROR: mismatched types\n+LL | | }\n+   | |_^\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 19:1\n+  --> $DIR/variadic-ffi-4.rs:19:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+LL | |     *ap0 = ap1; //~ ERROR: mismatched types\n+LL | | }\n+   | |_^\n+\n+error[E0490]: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^\n+   |\n+note: the type is valid for the anonymous lifetime #1 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: but the borrow lasts for the anonymous lifetime #3 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected type `&mut core::ffi::VaList<'_>`\n+              found type `&mut core::ffi::VaList<'_>`\n+note: the anonymous lifetime #3 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected type `&mut core::ffi::VaList<'_>`\n+              found type `&mut core::ffi::VaList<'_>`\n+note: the anonymous lifetime #2 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...does not necessarily outlive the anonymous lifetime #3 defined on the function body at 23:1\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+\n+error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^\n+   |\n+note: first, the lifetime cannot outlive the anonymous lifetime #3 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...so that the type `core::ffi::VaList<'_>` is not borrowed for too long\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^\n+note: but, the lifetime must be valid for the anonymous lifetime #1 defined on the function body at 23:1...\n+  --> $DIR/variadic-ffi-4.rs:23:1\n+   |\n+LL | / pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+LL | |     ap0 = &mut ap1;\n+LL | |     //~^ ERROR: a value of type `core::ffi::VaList<'_>` is borrowed for too long\n+LL | |     //~^^ ERROR: mismatched types\n+LL | |     //~^^^ ERROR: mismatched types\n+LL | |     //~^^^^ ERROR: cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/variadic-ffi-4.rs:24:11\n+   |\n+LL |     ap0 = &mut ap1;\n+   |           ^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors occurred: E0308, E0490, E0495, E0621.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "d96482ff4d17aa982052229bd788ea48cd5ddae6", "filename": "src/test/ui/c-variadic/variadic-ffi-5.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -0,0 +1,31 @@\n+#![crate_type=\"lib\"]\n+#![no_std]\n+#![feature(c_variadic)]\n+// The tests in this file are similar to that of variadic-ffi-4, but this\n+// one enables nll.\n+#![feature(nll)]\n+\n+use core::ffi::VaList;\n+\n+pub unsafe extern \"C\" fn no_escape0<'a>(_: usize, ap: ...) -> VaList<'a> {\n+    ap //~ ERROR: explicit lifetime required\n+}\n+\n+pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaList<'static> {\n+    ap //~ ERROR: explicit lifetime required\n+}\n+\n+pub unsafe extern \"C\" fn no_escape2(_: usize, ap: ...) {\n+    let _ = ap.copy(|ap| { ap }); //~ ERROR: lifetime may not live long enough\n+}\n+\n+pub unsafe extern \"C\" fn no_escape3(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+    *ap0 = ap1; //~ ERROR: lifetime may not live long enough\n+}\n+\n+pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+    ap0 = &mut ap1;\n+    //~^ ERROR: lifetime may not live long enough\n+    //~^^ ERROR: lifetime may not live long enough\n+    //~^^^ ERROR: `ap1` does not live long enough\n+}"}, {"sha": "2d452872baf4ecc06796ad37d0773a7fdfafca40", "filename": "src/test/ui/c-variadic/variadic-ffi-5.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-5.stderr?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -0,0 +1,73 @@\n+error[E0621]: explicit lifetime required in the type of `ap`\n+  --> $DIR/variadic-ffi-5.rs:11:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape0<'a>(_: usize, ap: ...) -> VaList<'a> {\n+   |                                                       --- help: add explicit lifetime `'a` to the type of `ap`: `core::ffi::VaList<'a>`\n+LL |     ap //~ ERROR: explicit lifetime required\n+   |     ^^ lifetime `'a` required\n+\n+error[E0621]: explicit lifetime required in the type of `ap`\n+  --> $DIR/variadic-ffi-5.rs:15:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape1(_: usize, ap: ...) -> VaList<'static> {\n+   |                                                   --- help: add explicit lifetime `'static` to the type of `ap`: `core::ffi::VaList<'static>`\n+LL |     ap //~ ERROR: explicit lifetime required\n+   |     ^^ lifetime `'static` required\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-5.rs:19:28\n+   |\n+LL |     let _ = ap.copy(|ap| { ap }); //~ ERROR: lifetime may not live long enough\n+   |                      ---   ^^ returning this value requires that `'1` must outlive `'2`\n+   |                      | |\n+   |                      | return type of closure is core::ffi::VaList<'2>\n+   |                      has type `core::ffi::VaList<'1>`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-5.rs:23:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape3(_: usize, ap0: &mut VaList, mut ap1: ...) {\n+   |                                               ---               ------- has type `core::ffi::VaList<'1>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaList<'2>`\n+LL |     *ap0 = ap1; //~ ERROR: lifetime may not live long enough\n+   |     ^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-5.rs:27:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+   |                                               -------               ------- has type `core::ffi::VaList<'2>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaList<'1>`\n+LL |     ap0 = &mut ap1;\n+   |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/variadic-ffi-5.rs:27:5\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+   |                                               -------               ------- has type `core::ffi::VaList<'1>`\n+   |                                               |\n+   |                                               has type `&mut core::ffi::VaList<'2>`\n+LL |     ap0 = &mut ap1;\n+   |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+\n+error[E0597]: `ap1` does not live long enough\n+  --> $DIR/variadic-ffi-5.rs:27:11\n+   |\n+LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaList, mut ap1: ...) {\n+   |                                                        - let's call the lifetime of this reference `'1`\n+LL |     ap0 = &mut ap1;\n+   |     ------^^^^^^^^\n+   |     |     |\n+   |     |     borrowed value does not live long enough\n+   |     assignment requires that `ap1` is borrowed for `'1`\n+...\n+LL | }\n+   |  - `ap1` dropped here while still borrowed\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors occurred: E0597, E0621.\n+For more information about an error, try `rustc --explain E0597`."}, {"sha": "9b5293fad3bf71e91e7a21553c764ee81d6230b6", "filename": "src/test/ui/c-variadic/variadic-ffi-6.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -0,0 +1,12 @@\n+#![crate_type=\"lib\"]\n+\n+pub unsafe extern \"C\" fn use_vararg_lifetime(\n+    x: usize,\n+    y: ...\n+) -> &usize { //~ ERROR missing lifetime specifier\n+    &0\n+}\n+\n+pub unsafe extern \"C\" fn use_normal_arg_lifetime(x: &usize, y: ...) -> &usize { // OK\n+    x\n+}"}, {"sha": "76bd18959a51f730bbc36c1e7b6f10d6c10cb3be", "filename": "src/test/ui/c-variadic/variadic-ffi-6.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-6.stderr?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -0,0 +1,11 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/variadic-ffi-6.rs:7:6\n+   |\n+LL | ) -> &usize { //~ ERROR missing lifetime specifier\n+   |      ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "51f13c7dbd5404e3670fb65327967bf2679e87e0", "filename": "src/test/ui/error-codes/E0617.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0617.rs?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -22,7 +22,7 @@ fn main() {\n         //~^ ERROR can't pass `u16` to variadic function\n         //~| HELP cast the value to `c_uint`\n         printf(::std::ptr::null(), printf);\n-        //~^ ERROR can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function\n-        //~| HELP cast the value to `unsafe extern \"C\" fn(*const i8, ...)`\n+        //~^ ERROR can't pass `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...) {printf}` to variadic function\n+        //~| HELP cast the value to `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...)`\n     }\n }"}, {"sha": "8387d5c7e93a5fb05d2bdb0f16f69c873a972935", "filename": "src/test/ui/error-codes/E0617.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0617.stderr?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -28,15 +28,15 @@ error[E0617]: can't pass `u16` to variadic function\n LL |         printf(::std::ptr::null(), 0u16);\n    |                                    ^^^^ help: cast the value to `c_uint`: `0u16 as c_uint`\n \n-error[E0617]: can't pass `unsafe extern \"C\" fn(*const i8, ...) {printf}` to variadic function\n+error[E0617]: can't pass `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...) {printf}` to variadic function\n   --> $DIR/E0617.rs:24:36\n    |\n LL |         printf(::std::ptr::null(), printf);\n    |                                    ^^^^^^\n-help: cast the value to `unsafe extern \"C\" fn(*const i8, ...)`\n+help: cast the value to `for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...)`\n    |\n-LL |         printf(::std::ptr::null(), printf as unsafe extern \"C\" fn(*const i8, ...));\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         printf(::std::ptr::null(), printf as for<'r> unsafe extern \"C\" fn(*const i8, std::ffi::VaList<'r>, ...));\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "b308e644ad9f89dc743cd8a58e5d34f2ce6198b1", "filename": "src/test/ui/parser/recover-enum2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fparser%2Frecover-enum2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58147d486bc26eb59d18d8e0d83aa6fe0b467fb9/src%2Ftest%2Fui%2Fparser%2Frecover-enum2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-enum2.stderr?ref=58147d486bc26eb59d18d8e0d83aa6fe0b467fb9", "patch": "@@ -10,11 +10,11 @@ error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `{`\n LL |             Nope(i32 {}) //~ ERROR: found `{`\n    |                      ^ expected one of 7 possible tokens here\n \n-error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `::`, `<`, `?`, `[`, `_`, `crate`, `dyn`, `extern`, `fn`, `for`, `impl`, `pub`, `unsafe`, `}`, or lifetime, found `{`\n+error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `...`, `::`, `<`, `?`, `[`, `_`, `crate`, `dyn`, `extern`, `fn`, `for`, `impl`, `pub`, `unsafe`, `}`, or lifetime, found `{`\n   --> $DIR/recover-enum2.rs:27:22\n    |\n LL |             Nope(i32 {}) //~ ERROR: found `{`\n-   |                      ^ expected one of 23 possible tokens here\n+   |                      ^ expected one of 24 possible tokens here\n \n error: expected expression, found reserved identifier `_`\n   --> $DIR/recover-enum2.rs:32:22"}]}