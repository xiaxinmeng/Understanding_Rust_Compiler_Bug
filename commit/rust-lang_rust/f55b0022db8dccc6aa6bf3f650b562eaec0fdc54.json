{"sha": "f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "node_id": "C_kwDOAAsO6NoAKGY1NWIwMDIyZGI4ZGNjYzZhYTZiZjNmNjUwYjU2MmVhZWMwZmRjNTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-29T22:14:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-29T22:14:18Z"}, "message": "Auto merge of #103019 - Kobzol:ci-multistage-python, r=Mark-Simulacrum\n\nPort pgo.sh to Python\n\nThis PR ports the `pgo.sh` multi stage build file from bash to Python, to make it easier to add new functionality and gather statistics. Main changes:\n\n1) `pgo.sh` rewritten from Bash to Python. Jump from ~200 Bash LOC to ~650 Python LOC. Bash is, unsurprisingly, more concise for running scripts and binaries.\n2) Better logging. Each separate stage is now clearly separated in logs, and the logs can be quickly grepped to find out which stage has completed or failed, and how long it took.\n3) Better statistics. At the end of the run, there is now a table that shows the duration of the individual stages, along with a percentual ratio of the total workflow run:\n\n```\n2023-01-15T18:13:49.9896916Z stage-build INFO: Timer results\n2023-01-15T18:13:49.9902185Z ---------------------------------------------------------\n2023-01-15T18:13:49.9902605Z Build rustc (LLVM PGO):                 1815.67s (21.47%)\n2023-01-15T18:13:49.9902949Z Gather profiles (LLVM PGO):              418.73s ( 4.95%)\n2023-01-15T18:13:49.9903269Z Build rustc (rustc PGO):                 584.46s ( 6.91%)\n2023-01-15T18:13:49.9903835Z Gather profiles (rustc PGO):             806.32s ( 9.53%)\n2023-01-15T18:13:49.9904154Z Build rustc (LLVM BOLT):                1662.92s (19.66%)\n2023-01-15T18:13:49.9904464Z Gather profiles (LLVM BOLT):             715.18s ( 8.46%)\n2023-01-15T18:13:49.9914463Z Final build:                            2454.00s (29.02%)\n2023-01-15T18:13:49.9914798Z Total duration:                         8457.27s\n2023-01-15T18:13:49.9915305Z ---------------------------------------------------------\n```\n\nA sample run can be seen [here](https://github.com/rust-lang/rust/actions/runs/3923980164/jobs/6707932029).\n\nI tried to keep the code compatible with Python 3.6 and don't use dependencies, which required me to reimplement some small pieces of functionality (like formatting bytes). I suppose that it shouldn't be so hard to upgrade to a newer Python or install dependencies in the CI container, but I'd like to avoid it if it won't be needed.\n\nThe code is in a single file `stage-build.py`, so it's a bit cluttered. I can also separate it into multiple files, although having it in a single file has some benefits. The code could definitely be nicer, but I'm a bit wary of introducing a lot of abstraction and similar stuff, as long as the code is stuffed into a single file.\n\nCurrently, the Python pipeline should faithfully mirror the bash pipeline one by one. After this PR, I'd like to try to optimize it, e.g. by caching the LLVM builds on S3.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "48d8a19d0dc528992d69e685e3713c2c5b37f754", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48d8a19d0dc528992d69e685e3713c2c5b37f754"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "html_url": "https://github.com/rust-lang/rust/commit/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e972bc8083d5228536dfd42913c8778b6bb04c8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e972bc8083d5228536dfd42913c8778b6bb04c8e", "html_url": "https://github.com/rust-lang/rust/commit/e972bc8083d5228536dfd42913c8778b6bb04c8e"}, {"sha": "5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee", "html_url": "https://github.com/rust-lang/rust/commit/5b77cb459fd358947ecf2173b5c46a0a5a86a2ee"}], "stats": {"total": 669, "additions": 666, "deletions": 3}, "files": [{"sha": "552680f06f66dd58390c69f5b1c09f3c4205acc8", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "patch": "@@ -447,7 +447,7 @@ jobs:\n           - name: dist-x86_64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler --set rust.lto=thin\"\n-              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist bootstrap --include-default-paths\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-i686-msvc"}, {"sha": "5feba4e0605ecb55b2b04bcaa30576014c5492ee", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile?ref=f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "patch": "@@ -81,7 +81,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --set rust.jemalloc \\\n       --set rust.use-lld=true \\\n       --set rust.lto=thin\n-ENV SCRIPT ../src/ci/pgo.sh python3 ../x.py dist \\\n+ENV SCRIPT python3 ../src/ci/stage-build.py python3 ../x.py dist \\\n     --host $HOSTS --target $HOSTS \\\n     --include-default-paths \\\n     build-manifest bootstrap"}, {"sha": "5e676a470a034e2a8ea842da13b4ee2b94761308", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "patch": "@@ -680,7 +680,7 @@ jobs:\n                 --enable-full-tools\n                 --enable-profiler\n                 --set rust.lto=thin\n-              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist bootstrap --include-default-paths\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             <<: *job-windows-xl\n "}, {"sha": "c373edfcf46a26ffefb1f21142f54afb0af4c198", "filename": "src/ci/stage-build.py", "status": "added", "additions": 663, "deletions": 0, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/f55b0022db8dccc6aa6bf3f650b562eaec0fdc54/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=f55b0022db8dccc6aa6bf3f650b562eaec0fdc54", "patch": "@@ -0,0 +1,663 @@\n+#!/usr/bin/env python3\n+# ignore-tidy-linelength\n+\n+# Compatible with Python 3.6+\n+\n+import contextlib\n+import getpass\n+import glob\n+import logging\n+import os\n+import pprint\n+import shutil\n+import subprocess\n+import sys\n+import time\n+import traceback\n+import urllib.request\n+from collections import OrderedDict\n+from io import StringIO\n+from pathlib import Path\n+from typing import Callable, Dict, Iterable, List, Optional, Union\n+\n+PGO_HOST = os.environ[\"PGO_HOST\"]\n+\n+LOGGER = logging.getLogger(\"stage-build\")\n+\n+LLVM_PGO_CRATES = [\n+    \"syn-1.0.89\",\n+    \"cargo-0.60.0\",\n+    \"serde-1.0.136\",\n+    \"ripgrep-13.0.0\",\n+    \"regex-1.5.5\",\n+    \"clap-3.1.6\",\n+    \"hyper-0.14.18\"\n+]\n+\n+RUSTC_PGO_CRATES = [\n+    \"externs\",\n+    \"ctfe-stress-5\",\n+    \"cargo-0.60.0\",\n+    \"token-stream-stress\",\n+    \"match-stress\",\n+    \"tuple-stress\",\n+    \"diesel-1.4.8\",\n+    \"bitmaps-3.1.0\"\n+]\n+\n+LLVM_BOLT_CRATES = LLVM_PGO_CRATES\n+\n+\n+class Pipeline:\n+    # Paths\n+    def checkout_path(self) -> Path:\n+        \"\"\"\n+        The root checkout, where the source is located.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def downloaded_llvm_dir(self) -> Path:\n+        \"\"\"\n+        Directory where the host LLVM is located.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def build_root(self) -> Path:\n+        \"\"\"\n+        The main directory where the build occurs.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def build_artifacts(self) -> Path:\n+        return self.build_root() / \"build\" / PGO_HOST\n+\n+    def rustc_stage_0(self) -> Path:\n+        return self.build_artifacts() / \"stage0\" / \"bin\" / \"rustc\"\n+\n+    def cargo_stage_0(self) -> Path:\n+        return self.build_artifacts() / \"stage0\" / \"bin\" / \"cargo\"\n+\n+    def rustc_stage_2(self) -> Path:\n+        return self.build_artifacts() / \"stage2\" / \"bin\" / \"rustc\"\n+\n+    def opt_artifacts(self) -> Path:\n+        raise NotImplementedError\n+\n+    def llvm_profile_dir_root(self) -> Path:\n+        return self.opt_artifacts() / \"llvm-pgo\"\n+\n+    def llvm_profile_merged_file(self) -> Path:\n+        return self.opt_artifacts() / \"llvm-pgo.profdata\"\n+\n+    def rustc_perf_dir(self) -> Path:\n+        return self.opt_artifacts() / \"rustc-perf\"\n+\n+    def build_rustc_perf(self):\n+        raise NotImplementedError()\n+\n+    def rustc_profile_dir_root(self) -> Path:\n+        return self.opt_artifacts() / \"rustc-pgo\"\n+\n+    def rustc_profile_merged_file(self) -> Path:\n+        return self.opt_artifacts() / \"rustc-pgo.profdata\"\n+\n+    def rustc_profile_template_path(self) -> Path:\n+        \"\"\"\n+        The profile data is written into a single filepath that is being repeatedly merged when each\n+        rustc invocation ends. Empirically, this can result in some profiling data being lost. That's\n+        why we override the profile path to include the PID. This will produce many more profiling\n+        files, but the resulting profile will produce a slightly faster rustc binary.\n+        \"\"\"\n+        return self.rustc_profile_dir_root() / \"default_%m_%p.profraw\"\n+\n+    def supports_bolt(self) -> bool:\n+        raise NotImplementedError\n+\n+    def llvm_bolt_profile_merged_file(self) -> Path:\n+        return self.opt_artifacts() / \"bolt.profdata\"\n+\n+\n+class LinuxPipeline(Pipeline):\n+    def checkout_path(self) -> Path:\n+        return Path(\"/checkout\")\n+\n+    def downloaded_llvm_dir(self) -> Path:\n+        return Path(\"/rustroot\")\n+\n+    def build_root(self) -> Path:\n+        return self.checkout_path() / \"obj\"\n+\n+    def opt_artifacts(self) -> Path:\n+        return Path(\"/tmp/tmp-multistage/opt-artifacts\")\n+\n+    def build_rustc_perf(self):\n+        # /tmp/rustc-perf comes from the Dockerfile\n+        shutil.copytree(\"/tmp/rustc-perf\", self.rustc_perf_dir())\n+        cmd([\"chown\", \"-R\", f\"{getpass.getuser()}:\", self.rustc_perf_dir()])\n+\n+        with change_cwd(self.rustc_perf_dir()):\n+            cmd([self.cargo_stage_0(), \"build\", \"-p\", \"collector\"], env=dict(\n+                RUSTC=str(self.rustc_stage_0()),\n+                RUSTC_BOOTSTRAP=\"1\"\n+            ))\n+\n+    def supports_bolt(self) -> bool:\n+        return True\n+\n+\n+class WindowsPipeline(Pipeline):\n+    def __init__(self):\n+        self.checkout_dir = Path(os.getcwd())\n+\n+    def checkout_path(self) -> Path:\n+        return self.checkout_dir\n+\n+    def downloaded_llvm_dir(self) -> Path:\n+        return self.checkout_path() / \"citools\" / \"clang-rust\"\n+\n+    def build_root(self) -> Path:\n+        return self.checkout_path()\n+\n+    def opt_artifacts(self) -> Path:\n+        return self.checkout_path() / \"opt-artifacts\"\n+\n+    def rustc_stage_0(self) -> Path:\n+        return super().rustc_stage_0().with_suffix(\".exe\")\n+\n+    def cargo_stage_0(self) -> Path:\n+        return super().cargo_stage_0().with_suffix(\".exe\")\n+\n+    def rustc_stage_2(self) -> Path:\n+        return super().rustc_stage_2().with_suffix(\".exe\")\n+\n+    def build_rustc_perf(self):\n+        # rustc-perf version from 2022-07-22\n+        perf_commit = \"3c253134664fdcba862c539d37f0de18557a9a4c\"\n+        rustc_perf_zip_path = self.opt_artifacts() / \"perf.zip\"\n+\n+        def download_rustc_perf():\n+            download_file(\n+                f\"https://github.com/rust-lang/rustc-perf/archive/{perf_commit}.zip\",\n+                rustc_perf_zip_path\n+            )\n+            with change_cwd(self.opt_artifacts()):\n+                unpack_archive(rustc_perf_zip_path)\n+                move_path(Path(f\"rustc-perf-{perf_commit}\"), self.rustc_perf_dir())\n+                delete_file(rustc_perf_zip_path)\n+\n+        retry_action(download_rustc_perf, \"Download rustc-perf\")\n+\n+        with change_cwd(self.rustc_perf_dir()):\n+            cmd([self.cargo_stage_0(), \"build\", \"-p\", \"collector\"], env=dict(\n+                RUSTC=str(self.rustc_stage_0()),\n+                RUSTC_BOOTSTRAP=\"1\"\n+            ))\n+\n+    def rustc_profile_template_path(self) -> Path:\n+        \"\"\"\n+        On Windows, we don't have enough space to use separate files for each rustc invocation.\n+        Therefore, we use a single file for the generated profiles.\n+        \"\"\"\n+        return self.rustc_profile_dir_root() / \"default_%m.profraw\"\n+\n+    def supports_bolt(self) -> bool:\n+        return False\n+\n+\n+class Timer:\n+    def __init__(self):\n+        # We want this dictionary to be ordered by insertion.\n+        # We use `OrderedDict` for compatibility with older Python versions.\n+        self.stages = OrderedDict()\n+\n+    @contextlib.contextmanager\n+    def stage(self, name: str):\n+        assert name not in self.stages\n+\n+        start = time.time()\n+        exc = None\n+        try:\n+            LOGGER.info(f\"Stage `{name}` starts\")\n+            yield\n+        except BaseException as exception:\n+            exc = exception\n+            raise\n+        finally:\n+            end = time.time()\n+            duration = end - start\n+            self.stages[name] = duration\n+            if exc is None:\n+                LOGGER.info(f\"Stage `{name}` ended: OK ({duration:.2f}s)\")\n+            else:\n+                LOGGER.info(f\"Stage `{name}` ended: FAIL ({duration:.2f}s)\")\n+\n+    def print_stats(self):\n+        total_duration = sum(self.stages.values())\n+\n+        # 57 is the width of the whole table\n+        divider = \"-\" * 57\n+\n+        with StringIO() as output:\n+            print(divider, file=output)\n+            for (name, duration) in self.stages.items():\n+                pct = (duration / total_duration) * 100\n+                name_str = f\"{name}:\"\n+                print(f\"{name_str:<34} {duration:>12.2f}s ({pct:>5.2f}%)\", file=output)\n+\n+            total_duration_label = \"Total duration:\"\n+            print(f\"{total_duration_label:<34} {total_duration:>12.2f}s\", file=output)\n+            print(divider, file=output, end=\"\")\n+            LOGGER.info(f\"Timer results\\n{output.getvalue()}\")\n+\n+\n+@contextlib.contextmanager\n+def change_cwd(dir: Path):\n+    \"\"\"\n+    Temporarily change working directory to `dir`.\n+    \"\"\"\n+    cwd = os.getcwd()\n+    LOGGER.debug(f\"Changing working dir from `{cwd}` to `{dir}`\")\n+    os.chdir(dir)\n+    try:\n+        yield\n+    finally:\n+        LOGGER.debug(f\"Reverting working dir to `{cwd}`\")\n+        os.chdir(cwd)\n+\n+\n+def move_path(src: Path, dst: Path):\n+    LOGGER.info(f\"Moving `{src}` to `{dst}`\")\n+    shutil.move(src, dst)\n+\n+\n+def delete_file(path: Path):\n+    LOGGER.info(f\"Deleting file `{path}`\")\n+    os.unlink(path)\n+\n+\n+def delete_directory(path: Path):\n+    LOGGER.info(f\"Deleting directory `{path}`\")\n+    shutil.rmtree(path)\n+\n+\n+def unpack_archive(archive: Path):\n+    LOGGER.info(f\"Unpacking archive `{archive}`\")\n+    shutil.unpack_archive(archive)\n+\n+\n+def download_file(src: str, target: Path):\n+    LOGGER.info(f\"Downloading `{src}` into `{target}`\")\n+    urllib.request.urlretrieve(src, str(target))\n+\n+\n+def retry_action(action, name: str, max_fails: int = 5):\n+    LOGGER.info(f\"Attempting to perform action `{name}` with retry\")\n+    for iteration in range(max_fails):\n+        LOGGER.info(f\"Attempt {iteration + 1}/{max_fails}\")\n+        try:\n+            action()\n+            return\n+        except:\n+            LOGGER.error(f\"Action `{name}` has failed\\n{traceback.format_exc()}\")\n+\n+    raise Exception(f\"Action `{name}` has failed after {max_fails} attempts\")\n+\n+\n+def cmd(\n+        args: List[Union[str, Path]],\n+        env: Optional[Dict[str, str]] = None,\n+        output_path: Optional[Path] = None\n+):\n+    args = [str(arg) for arg in args]\n+\n+    environment = os.environ.copy()\n+\n+    cmd_str = \"\"\n+    if env is not None:\n+        environment.update(env)\n+        cmd_str += \" \".join(f\"{k}={v}\" for (k, v) in (env or {}).items())\n+        cmd_str += \" \"\n+    cmd_str += \" \".join(args)\n+    if output_path is not None:\n+        cmd_str += f\" > {output_path}\"\n+    LOGGER.info(f\"Executing `{cmd_str}`\")\n+\n+    if output_path is not None:\n+        with open(output_path, \"w\") as f:\n+            return subprocess.run(\n+                args,\n+                env=environment,\n+                check=True,\n+                stdout=f\n+            )\n+    return subprocess.run(args, env=environment, check=True)\n+\n+\n+def run_compiler_benchmarks(\n+        pipeline: Pipeline,\n+        profiles: List[str],\n+        scenarios: List[str],\n+        crates: List[str],\n+        env: Optional[Dict[str, str]] = None\n+):\n+    env = env if env is not None else {}\n+\n+    # Compile libcore, both in opt-level=0 and opt-level=3\n+    with change_cwd(pipeline.build_root()):\n+        cmd([\n+            pipeline.rustc_stage_2(),\n+            \"--edition\", \"2021\",\n+            \"--crate-type\", \"lib\",\n+            str(pipeline.checkout_path() / \"library/core/src/lib.rs\"),\n+            \"--out-dir\", pipeline.opt_artifacts()\n+        ], env=dict(RUSTC_BOOTSTRAP=\"1\", **env))\n+\n+        cmd([\n+            pipeline.rustc_stage_2(),\n+            \"--edition\", \"2021\",\n+            \"--crate-type\", \"lib\",\n+            \"-Copt-level=3\",\n+            str(pipeline.checkout_path() / \"library/core/src/lib.rs\"),\n+            \"--out-dir\", pipeline.opt_artifacts()\n+        ], env=dict(RUSTC_BOOTSTRAP=\"1\", **env))\n+\n+    # Run rustc-perf benchmarks\n+    # Benchmark using profile_local with eprintln, which essentially just means\n+    # don't actually benchmark -- just make sure we run rustc a bunch of times.\n+    with change_cwd(pipeline.rustc_perf_dir()):\n+        cmd([\n+            pipeline.cargo_stage_0(),\n+            \"run\",\n+            \"-p\", \"collector\", \"--bin\", \"collector\", \"--\",\n+            \"profile_local\", \"eprintln\",\n+            pipeline.rustc_stage_2(),\n+            \"--id\", \"Test\",\n+            \"--cargo\", pipeline.cargo_stage_0(),\n+            \"--profiles\", \",\".join(profiles),\n+            \"--scenarios\", \",\".join(scenarios),\n+            \"--include\", \",\".join(crates)\n+        ], env=dict(\n+            RUST_LOG=\"collector=debug\",\n+            RUSTC=str(pipeline.rustc_stage_0()),\n+            RUSTC_BOOTSTRAP=\"1\",\n+            **env\n+        ))\n+\n+\n+# https://stackoverflow.com/a/31631711/1107768\n+def format_bytes(size: int) -> str:\n+    \"\"\"Return the given bytes as a human friendly KiB, MiB or GiB string.\"\"\"\n+    KB = 1024\n+    MB = KB ** 2  # 1,048,576\n+    GB = KB ** 3  # 1,073,741,824\n+    TB = KB ** 4  # 1,099,511,627,776\n+\n+    if size < KB:\n+        return f\"{size} B\"\n+    elif KB <= size < MB:\n+        return f\"{size / KB:.2f} KiB\"\n+    elif MB <= size < GB:\n+        return f\"{size / MB:.2f} MiB\"\n+    elif GB <= size < TB:\n+        return f\"{size / GB:.2f} GiB\"\n+    else:\n+        return str(size)\n+\n+\n+# https://stackoverflow.com/a/63307131/1107768\n+def count_files(path: Path) -> int:\n+    return sum(1 for p in path.rglob(\"*\") if p.is_file())\n+\n+\n+def count_files_with_prefix(path: Path) -> int:\n+    return sum(1 for p in glob.glob(f\"{path}*\") if Path(p).is_file())\n+\n+\n+# https://stackoverflow.com/a/55659577/1107768\n+def get_path_size(path: Path) -> int:\n+    if path.is_dir():\n+        return sum(p.stat().st_size for p in path.rglob(\"*\"))\n+    return path.stat().st_size\n+\n+\n+def get_path_prefix_size(path: Path) -> int:\n+    \"\"\"\n+    Get size of all files beginning with the prefix `path`.\n+    Alternative to shell `du -sh <path>*`.\n+    \"\"\"\n+    return sum(Path(p).stat().st_size for p in glob.glob(f\"{path}*\"))\n+\n+\n+def get_files(directory: Path, filter: Optional[Callable[[Path], bool]] = None) -> Iterable[Path]:\n+    for file in os.listdir(directory):\n+        path = directory / file\n+        if filter is None or filter(path):\n+            yield path\n+\n+\n+def build_rustc(\n+        pipeline: Pipeline,\n+        args: List[str],\n+        env: Optional[Dict[str, str]] = None\n+):\n+    arguments = [\n+                    sys.executable,\n+                    pipeline.checkout_path() / \"x.py\",\n+                    \"build\",\n+                    \"--target\", PGO_HOST,\n+                    \"--host\", PGO_HOST,\n+                    \"--stage\", \"2\",\n+                    \"library/std\"\n+                ] + args\n+    cmd(arguments, env=env)\n+\n+\n+def create_pipeline() -> Pipeline:\n+    if sys.platform == \"linux\":\n+        return LinuxPipeline()\n+    elif sys.platform in (\"cygwin\", \"win32\"):\n+        return WindowsPipeline()\n+    else:\n+        raise Exception(f\"Optimized build is not supported for platform {sys.platform}\")\n+\n+\n+def gather_llvm_profiles(pipeline: Pipeline):\n+    LOGGER.info(\"Running benchmarks with PGO instrumented LLVM\")\n+    run_compiler_benchmarks(\n+        pipeline,\n+        profiles=[\"Debug\", \"Opt\"],\n+        scenarios=[\"Full\"],\n+        crates=LLVM_PGO_CRATES\n+    )\n+\n+    profile_path = pipeline.llvm_profile_merged_file()\n+    LOGGER.info(f\"Merging LLVM PGO profiles to {profile_path}\")\n+    cmd([\n+        pipeline.downloaded_llvm_dir() / \"bin\" / \"llvm-profdata\",\n+        \"merge\",\n+        \"-o\", profile_path,\n+        pipeline.llvm_profile_dir_root()\n+    ])\n+\n+    LOGGER.info(\"LLVM PGO statistics\")\n+    LOGGER.info(f\"{profile_path}: {format_bytes(get_path_size(profile_path))}\")\n+    LOGGER.info(\n+        f\"{pipeline.llvm_profile_dir_root()}: {format_bytes(get_path_size(pipeline.llvm_profile_dir_root()))}\")\n+    LOGGER.info(f\"Profile file count: {count_files(pipeline.llvm_profile_dir_root())}\")\n+\n+    # We don't need the individual .profraw files now that they have been merged\n+    # into a final .profdata\n+    delete_directory(pipeline.llvm_profile_dir_root())\n+\n+\n+def gather_rustc_profiles(pipeline: Pipeline):\n+    LOGGER.info(\"Running benchmarks with PGO instrumented rustc\")\n+\n+    # Here we're profiling the `rustc` frontend, so we also include `Check`.\n+    # The benchmark set includes various stress tests that put the frontend under pressure.\n+    run_compiler_benchmarks(\n+        pipeline,\n+        profiles=[\"Check\", \"Debug\", \"Opt\"],\n+        scenarios=[\"All\"],\n+        crates=RUSTC_PGO_CRATES,\n+        env=dict(\n+            LLVM_PROFILE_FILE=str(pipeline.rustc_profile_template_path())\n+        )\n+    )\n+\n+    profile_path = pipeline.rustc_profile_merged_file()\n+    LOGGER.info(f\"Merging Rustc PGO profiles to {profile_path}\")\n+    cmd([\n+        pipeline.build_artifacts() / \"llvm\" / \"bin\" / \"llvm-profdata\",\n+        \"merge\",\n+        \"-o\", profile_path,\n+        pipeline.rustc_profile_dir_root()\n+    ])\n+\n+    LOGGER.info(\"Rustc PGO statistics\")\n+    LOGGER.info(f\"{profile_path}: {format_bytes(get_path_size(profile_path))}\")\n+    LOGGER.info(\n+        f\"{pipeline.rustc_profile_dir_root()}: {format_bytes(get_path_size(pipeline.rustc_profile_dir_root()))}\")\n+    LOGGER.info(f\"Profile file count: {count_files(pipeline.rustc_profile_dir_root())}\")\n+\n+    # We don't need the individual .profraw files now that they have been merged\n+    # into a final .profdata\n+    delete_directory(pipeline.rustc_profile_dir_root())\n+\n+\n+def gather_llvm_bolt_profiles(pipeline: Pipeline):\n+    LOGGER.info(\"Running benchmarks with BOLT instrumented LLVM\")\n+    run_compiler_benchmarks(\n+        pipeline,\n+        profiles=[\"Check\", \"Debug\", \"Opt\"],\n+        scenarios=[\"Full\"],\n+        crates=LLVM_BOLT_CRATES\n+    )\n+\n+    merged_profile_path = pipeline.llvm_bolt_profile_merged_file()\n+    profile_files_path = Path(\"/tmp/prof.fdata\")\n+    LOGGER.info(f\"Merging LLVM BOLT profiles to {merged_profile_path}\")\n+\n+    profile_files = sorted(glob.glob(f\"{profile_files_path}*\"))\n+    cmd([\n+        \"merge-fdata\",\n+        *profile_files,\n+    ], output_path=merged_profile_path)\n+\n+    LOGGER.info(\"LLVM BOLT statistics\")\n+    LOGGER.info(f\"{merged_profile_path}: {format_bytes(get_path_size(merged_profile_path))}\")\n+    LOGGER.info(\n+        f\"{profile_files_path}: {format_bytes(get_path_prefix_size(profile_files_path))}\")\n+    LOGGER.info(f\"Profile file count: {count_files_with_prefix(profile_files_path)}\")\n+\n+\n+def clear_llvm_files(pipeline: Pipeline):\n+    \"\"\"\n+    Rustbuild currently doesn't support rebuilding LLVM when PGO options\n+    change (or any other llvm-related options); so just clear out the relevant\n+    directories ourselves.\n+    \"\"\"\n+    LOGGER.info(\"Clearing LLVM build files\")\n+    delete_directory(pipeline.build_artifacts() / \"llvm\")\n+    delete_directory(pipeline.build_artifacts() / \"lld\")\n+\n+\n+def print_binary_sizes(pipeline: Pipeline):\n+    bin_dir = pipeline.build_artifacts() / \"stage2\" / \"bin\"\n+    binaries = get_files(bin_dir)\n+\n+    lib_dir = pipeline.build_artifacts() / \"stage2\" / \"lib\"\n+    libraries = get_files(lib_dir, lambda p: p.suffix == \".so\")\n+\n+    paths = sorted(binaries) + sorted(libraries)\n+    with StringIO() as output:\n+        for path in paths:\n+            path_str = f\"{path.name}:\"\n+            print(f\"{path_str:<30}{format_bytes(path.stat().st_size):>14}\", file=output)\n+        LOGGER.info(f\"Rustc binary size\\n{output.getvalue()}\")\n+\n+\n+def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: List[str]):\n+    # Clear and prepare tmp directory\n+    shutil.rmtree(pipeline.opt_artifacts(), ignore_errors=True)\n+    os.makedirs(pipeline.opt_artifacts(), exist_ok=True)\n+\n+    pipeline.build_rustc_perf()\n+\n+    # Stage 1: Build rustc + PGO instrumented LLVM\n+    with timer.stage(\"Build rustc (LLVM PGO)\"):\n+        build_rustc(pipeline, args=[\n+            \"--llvm-profile-generate\"\n+        ], env=dict(\n+            LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n+        ))\n+\n+    with timer.stage(\"Gather profiles (LLVM PGO)\"):\n+        gather_llvm_profiles(pipeline)\n+\n+    clear_llvm_files(pipeline)\n+    final_build_args += [\n+        \"--llvm-profile-use\",\n+        pipeline.llvm_profile_merged_file()\n+    ]\n+\n+    # Stage 2: Build PGO instrumented rustc + LLVM\n+    with timer.stage(\"Build rustc (rustc PGO)\"):\n+        build_rustc(pipeline, args=[\n+            \"--rust-profile-generate\",\n+            pipeline.rustc_profile_dir_root()\n+        ])\n+\n+    with timer.stage(\"Gather profiles (rustc PGO)\"):\n+        gather_rustc_profiles(pipeline)\n+\n+    clear_llvm_files(pipeline)\n+    final_build_args += [\n+        \"--rust-profile-use\",\n+        pipeline.rustc_profile_merged_file()\n+    ]\n+\n+    # Stage 3: Build rustc + BOLT instrumented LLVM\n+    if pipeline.supports_bolt():\n+        with timer.stage(\"Build rustc (LLVM BOLT)\"):\n+            build_rustc(pipeline, args=[\n+                \"--llvm-profile-use\",\n+                pipeline.llvm_profile_merged_file(),\n+                \"--llvm-bolt-profile-generate\",\n+            ])\n+        with timer.stage(\"Gather profiles (LLVM BOLT)\"):\n+            gather_llvm_bolt_profiles(pipeline)\n+\n+        clear_llvm_files(pipeline)\n+        final_build_args += [\n+            \"--llvm-bolt-profile-use\",\n+            pipeline.llvm_bolt_profile_merged_file()\n+        ]\n+\n+    # Stage 4: Build PGO optimized rustc + PGO/BOLT optimized LLVM\n+    with timer.stage(\"Final build\"):\n+        cmd(final_build_args)\n+\n+\n+if __name__ == \"__main__\":\n+    logging.basicConfig(\n+        level=logging.DEBUG,\n+        format=\"%(name)s %(levelname)-4s: %(message)s\",\n+    )\n+\n+    LOGGER.info(f\"Running multi-stage build using Python {sys.version}\")\n+    LOGGER.info(f\"Environment values\\n{pprint.pformat(dict(os.environ), indent=2)}\")\n+\n+    build_args = sys.argv[1:]\n+\n+    timer = Timer()\n+    pipeline = create_pipeline()\n+    try:\n+        execute_build_pipeline(timer, pipeline, build_args)\n+    except BaseException as e:\n+        LOGGER.error(\"The multi-stage build has failed\")\n+        raise e\n+    finally:\n+        timer.print_stats()\n+\n+    print_binary_sizes(pipeline)"}]}