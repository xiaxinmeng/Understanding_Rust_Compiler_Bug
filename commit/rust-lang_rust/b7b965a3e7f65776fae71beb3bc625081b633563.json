{"sha": "b7b965a3e7f65776fae71beb3bc625081b633563", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3Yjk2NWEzZTdmNjU3NzZmYWU3MWJlYjNiYzYyNTA4MWI2MzM1NjM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-06-30T11:18:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-07T18:05:21Z"}, "message": "return EvaluatedToRecur when evaluating a recursive obligation tree\n\nThis helps avoid cache pollution. Also add more comments explaining\nthat.", "tree": {"sha": "26caa7891c31601198c891cfdb7614ffa1ae5ccd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26caa7891c31601198c891cfdb7614ffa1ae5ccd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7b965a3e7f65776fae71beb3bc625081b633563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b965a3e7f65776fae71beb3bc625081b633563", "html_url": "https://github.com/rust-lang/rust/commit/b7b965a3e7f65776fae71beb3bc625081b633563", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7b965a3e7f65776fae71beb3bc625081b633563/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87a11812e14cff9141d15e18d1cd3323eb56a0b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/87a11812e14cff9141d15e18d1cd3323eb56a0b4", "html_url": "https://github.com/rust-lang/rust/commit/87a11812e14cff9141d15e18d1cd3323eb56a0b4"}], "stats": {"total": 124, "additions": 97, "deletions": 27}, "files": [{"sha": "452ad43cd699ffe538cfdc70a4892ddf26a709e1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 97, "deletions": 27, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b7b965a3e7f65776fae71beb3bc625081b633563/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b965a3e7f65776fae71beb3bc625081b633563/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b7b965a3e7f65776fae71beb3bc625081b633563", "patch": "@@ -43,6 +43,7 @@ use middle::lang_items;\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::cell::RefCell;\n+use std::cmp;\n use std::fmt;\n use std::marker::PhantomData;\n use std::mem;\n@@ -271,17 +272,101 @@ enum BuiltinImplConditions<'tcx> {\n /// The result of trait evaluation. The order is important\n /// here as the evaluation of a list is the maximum of the\n /// evaluations.\n+///\n+/// The evaluation results are ordered:\n+///     - `EvaluatedToOk` implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n+///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n+///     - the \"union\" of evaluation results is equal to their maximum -\n+///     all the \"potential success\" candidates can potentially succeed,\n+///     so they are no-ops when unioned with a definite error, and within\n+///     the categories it's easy to see that the unions are correct.\n enum EvaluationResult {\n     /// Evaluation successful\n     EvaluatedToOk,\n-    /// Evaluation failed because of recursion - treated as ambiguous\n-    EvaluatedToUnknown,\n-    /// Evaluation is known to be ambiguous\n+    /// Evaluation is known to be ambiguous - it *might* hold for some\n+    /// assignment of inference variables, but it might not.\n+    ///\n+    /// While this has the same meaning as `EvaluatedToUnknown` - we can't\n+    /// know whether this obligation holds or not - it is the result we\n+    /// would get with an empty stack, and therefore is cacheable.\n     EvaluatedToAmbig,\n+    /// Evaluation failed because of recursion involving inference\n+    /// variables. We are somewhat imprecise there, so we don't actually\n+    /// know the real result.\n+    ///\n+    /// This can't be trivially cached for the same reason as `EvaluatedToRecur`.\n+    EvaluatedToUnknown,\n+    /// Evaluation failed because we encountered an obligation we are already\n+    /// trying to prove on this branch.\n+    ///\n+    /// We know this branch can't be a part of a minimal proof-tree for\n+    /// the \"root\" of our cycle, because then we could cut out the recursion\n+    /// and maintain a valid proof tree. However, this does not mean\n+    /// that all the obligations on this branch do not hold - it's possible\n+    /// that we entered this branch \"speculatively\", and that there\n+    /// might be some other way to prove this obligation that does not\n+    /// go through this cycle - so we can't cache this as a failure.\n+    ///\n+    /// For example, suppose we have this:\n+    ///\n+    /// ```rust,ignore (pseudo-Rust)\n+    ///     pub trait Trait { fn xyz(); }\n+    ///     // This impl is \"useless\", but we can still have\n+    ///     // an `impl Trait for SomeUnsizedType` somewhere.\n+    ///     impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n+    ///\n+    ///     pub fn foo<T: Trait + ?Sized>() {\n+    ///         <T as Trait>::xyz();\n+    ///     }\n+    /// ```\n+    ///\n+    /// When checking `foo`, we have to prove `T: Trait`. This basically\n+    /// translates into this:\n+    ///\n+    ///     (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n+    ///\n+    /// When we try to prove it, we first go the first option, which\n+    /// recurses. This shows us that the impl is \"useless\" - it won't\n+    /// tell us that `T: Trait` unless it already implemented `Trait`\n+    /// by some other means. However, that does not prevent `T: Trait`\n+    /// does not hold, because of the bound (which can indeed be satisfied\n+    /// by `SomeUnsizedType` from another crate).\n+    ///\n+    /// FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n+    /// ought to convert it to an `EvaluatedToErr`, because we know\n+    /// there definitely isn't a proof tree for that obligation. Not\n+    /// doing so is still sound - there isn't any proof tree, so the\n+    /// branch still can't be a part of a minimal one - but does not\n+    /// re-enable caching.\n+    EvaluatedToRecur,\n     /// Evaluation failed\n     EvaluatedToErr,\n }\n \n+impl EvaluationResult {\n+    fn may_apply(self) -> bool {\n+        match self {\n+            EvaluatedToOk |\n+            EvaluatedToAmbig |\n+            EvaluatedToUnknown => true,\n+\n+            EvaluatedToErr |\n+            EvaluatedToRecur => false\n+        }\n+    }\n+\n+    fn is_stack_dependent(self) -> bool {\n+        match self {\n+            EvaluatedToUnknown |\n+            EvaluatedToRecur => true,\n+\n+            EvaluatedToOk |\n+            EvaluatedToAmbig |\n+            EvaluatedToErr => false,\n+        }\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n@@ -492,15 +577,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let eval = self.evaluate_predicate_recursively(stack, obligation);\n             debug!(\"evaluate_predicate_recursively({:?}) = {:?}\",\n                    obligation, eval);\n-            match eval {\n-                EvaluatedToErr => { return EvaluatedToErr; }\n-                EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n-                EvaluatedToUnknown => {\n-                    if result < EvaluatedToUnknown {\n-                        result = EvaluatedToUnknown;\n-                    }\n-                }\n-                EvaluatedToOk => { }\n+            if let EvaluatedToErr = eval {\n+                // fast-path - EvaluatedToErr is the top of the lattice,\n+                // so we don't need to look on the other predicates.\n+                return EvaluatedToErr;\n+            } else {\n+                result = cmp::max(result, eval);\n             }\n         }\n         result\n@@ -719,7 +801,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             } else {\n                 debug!(\"evaluate_stack({:?}) --> recursive, inductive\",\n                        stack.fresh_trait_ref);\n-                return EvaluatedToErr;\n+                return EvaluatedToRecur;\n             }\n         }\n \n@@ -807,10 +889,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                result: EvaluationResult)\n     {\n         // Avoid caching results that depend on more than just the trait-ref:\n-        // The stack can create EvaluatedToUnknown, and closure signatures\n+        // The stack can create recursion, and closure signatures\n         // being yet uninferred can create \"spurious\" EvaluatedToAmbig\n         // and EvaluatedToOk.\n-        if result == EvaluatedToUnknown ||\n+        if result.is_stack_dependent() ||\n             ((result == EvaluatedToAmbig || result == EvaluatedToOk)\n              && trait_ref.has_closure_types())\n         {\n@@ -3055,15 +3137,3 @@ impl<'o,'tcx> fmt::Debug for TraitObligationStack<'o,'tcx> {\n         write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n-\n-impl EvaluationResult {\n-    fn may_apply(&self) -> bool {\n-        match *self {\n-            EvaluatedToOk |\n-            EvaluatedToAmbig |\n-            EvaluatedToUnknown => true,\n-\n-            EvaluatedToErr => false\n-        }\n-    }\n-}"}]}