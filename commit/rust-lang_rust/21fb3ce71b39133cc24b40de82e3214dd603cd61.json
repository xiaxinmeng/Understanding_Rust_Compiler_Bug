{"sha": "21fb3ce71b39133cc24b40de82e3214dd603cd61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZmIzY2U3MWIzOTEzM2NjMjRiNDBkZTgyZTMyMTRkZDYwM2NkNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-06T09:16:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-06T09:16:32Z"}, "message": "Auto merge of #31967 - mitaa:rdoc-refactor, r=alexcrichton\n\nThis is mostly cleanup of individual code bits and code reuse for `clean::Attribute` handling.\n\nThe only change in behaviour should be that emitted sources are now being recorded and queried when trying to create src-links to local source-files.\n\nr? @alexcrichton", "tree": {"sha": "7681aed50d3e9d3c0e91a288ca76b12fe81da9c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7681aed50d3e9d3c0e91a288ca76b12fe81da9c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21fb3ce71b39133cc24b40de82e3214dd603cd61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21fb3ce71b39133cc24b40de82e3214dd603cd61", "html_url": "https://github.com/rust-lang/rust/commit/21fb3ce71b39133cc24b40de82e3214dd603cd61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21fb3ce71b39133cc24b40de82e3214dd603cd61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8484831d29392857d18f420e3fc69180306bf122", "url": "https://api.github.com/repos/rust-lang/rust/commits/8484831d29392857d18f420e3fc69180306bf122", "html_url": "https://github.com/rust-lang/rust/commit/8484831d29392857d18f420e3fc69180306bf122"}, {"sha": "938c8c18c406fc650c7c2c895aca3fb320ecbf18", "url": "https://api.github.com/repos/rust-lang/rust/commits/938c8c18c406fc650c7c2c895aca3fb320ecbf18", "html_url": "https://github.com/rust-lang/rust/commit/938c8c18c406fc650c7c2c895aca3fb320ecbf18"}], "stats": {"total": 898, "additions": 356, "deletions": 542}, "files": [{"sha": "32f3706675ad24b3b5f42b6f62443b241f440205", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=21fb3ce71b39133cc24b40de82e3214dd603cd61", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::const_eval;\n \n use core::DocContext;\n use doctree;\n-use clean;\n+use clean::{self, Attributes};\n \n use super::{Clean, ToSource};\n \n@@ -138,13 +138,10 @@ pub fn load_attrs(cx: &DocContext, tcx: &TyCtxt,\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n-    match cx.tcx_opt() {\n-        Some(tcx) => {\n-            let fqn = tcx.sess.cstore.extern_item_path(did);\n-            let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n-            cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n-        }\n-        None => {}\n+    if let Some(tcx) = cx.tcx_opt() {\n+        let fqn = tcx.sess.cstore.extern_item_path(did);\n+        let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n+        cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n     }\n }\n \n@@ -230,12 +227,9 @@ pub fn build_impls(cx: &DocContext, tcx: &TyCtxt,\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n-    match tcx.inherent_impls.borrow().get(&did) {\n-        None => {}\n-        Some(i) => {\n-            for &did in i.iter() {\n-                build_impl(cx, tcx, did, &mut impls);\n-            }\n+    if let Some(i) = tcx.inherent_impls.borrow().get(&did) {\n+        for &did in i.iter() {\n+            build_impl(cx, tcx, did, &mut impls);\n         }\n     }\n \n@@ -259,7 +253,7 @@ pub fn build_impls(cx: &DocContext, tcx: &TyCtxt,\n                 cstore::DlImpl(did) => build_impl(cx, tcx, did, impls),\n                 cstore::DlDef(Def::Mod(did)) => {\n                     // Don't recurse if this is a #[doc(hidden)] module\n-                    if load_attrs(cx, tcx, did).iter().any(|a| is_doc_hidden(a)) {\n+                    if load_attrs(cx, tcx, did).list_def(\"doc\").has_word(\"hidden\") {\n                         return;\n                     }\n \n@@ -288,7 +282,7 @@ pub fn build_impl(cx: &DocContext,\n     if let Some(ref t) = associated_trait {\n         // If this is an impl for a #[doc(hidden)] trait, be sure to not inline\n         let trait_attrs = load_attrs(cx, tcx, t.def_id);\n-        if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n+        if trait_attrs.list_def(\"doc\").has_word(\"hidden\") {\n             return\n         }\n     }\n@@ -428,20 +422,6 @@ pub fn build_impl(cx: &DocContext,\n     });\n }\n \n-fn is_doc_hidden(a: &clean::Attribute) -> bool {\n-    match *a {\n-        clean::List(ref name, ref inner) if *name == \"doc\" => {\n-            inner.iter().any(|a| {\n-                match *a {\n-                    clean::Word(ref s) => *s == \"hidden\",\n-                    _ => false,\n-                }\n-            })\n-        }\n-        _ => false\n-    }\n-}\n-\n fn build_module(cx: &DocContext, tcx: &TyCtxt,\n                 did: DefId) -> clean::Module {\n     let mut items = Vec::new();\n@@ -464,9 +444,8 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n                 }\n                 cstore::DlDef(def) if item.vis == hir::Public => {\n                     if !visited.insert(def) { continue }\n-                    match try_inline_def(cx, tcx, def) {\n-                        Some(i) => items.extend(i),\n-                        None => {}\n+                    if let Some(i) = try_inline_def(cx, tcx, def) {\n+                        items.extend(i)\n                     }\n                 }\n                 cstore::DlDef(..) => {}"}, {"sha": "6c9ee5287820175f60113776e36b78750393c4ef", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 101, "deletions": 119, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=21fb3ce71b39133cc24b40de82e3214dd603cd61", "patch": "@@ -100,10 +100,7 @@ impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n \n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     fn clean(&self, cx: &DocContext) -> Option<U> {\n-        match self {\n-            &None => None,\n-            &Some(ref v) => Some(v.clean(cx))\n-        }\n+        self.as_ref().map(|v| v.clean(cx))\n     }\n }\n \n@@ -178,9 +175,8 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n             };\n             let mut tmp = Vec::new();\n             for child in &mut m.items {\n-                match child.inner {\n-                    ModuleItem(..) => {}\n-                    _ => continue,\n+                if !child.is_mod() {\n+                    continue;\n                 }\n                 let prim = match PrimitiveType::find(&child.attrs) {\n                     Some(prim) => prim,\n@@ -261,7 +257,7 @@ pub struct Item {\n     pub source: Span,\n     /// Not everything has a name. E.g., impls\n     pub name: Option<String>,\n-    pub attrs: Vec<Attribute> ,\n+    pub attrs: Vec<Attribute>,\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n     pub def_id: DefId,\n@@ -270,51 +266,17 @@ pub struct Item {\n }\n \n impl Item {\n-    /// Finds the `doc` attribute as a List and returns the list of attributes\n-    /// nested inside.\n-    pub fn doc_list<'a>(&'a self) -> Option<&'a [Attribute]> {\n-        for attr in &self.attrs {\n-            match *attr {\n-                List(ref x, ref list) if \"doc\" == *x => {\n-                    return Some(list);\n-                }\n-                _ => {}\n-            }\n-        }\n-        return None;\n-    }\n-\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n-        for attr in &self.attrs {\n-            match *attr {\n-                NameValue(ref x, ref v) if \"doc\" == *x => {\n-                    return Some(v);\n-                }\n-                _ => {}\n-            }\n-        }\n-        return None;\n+        self.attrs.value(\"doc\")\n     }\n-\n-    pub fn is_hidden_from_doc(&self) -> bool {\n-        match self.doc_list() {\n-            Some(l) => {\n-                for innerattr in l {\n-                    match *innerattr {\n-                        Word(ref s) if \"hidden\" == *s => {\n-                            return true\n-                        }\n-                        _ => (),\n-                    }\n-                }\n-            },\n-            None => ()\n+    pub fn is_crate(&self) -> bool {\n+        match self.inner {\n+            ModuleItem(Module { items: _, is_crate: true }) => true,\n+            _ => false\n         }\n-        return false;\n     }\n-\n     pub fn is_mod(&self) -> bool {\n         match self.inner { ModuleItem(..) => true, _ => false }\n     }\n@@ -330,29 +292,34 @@ impl Item {\n     pub fn is_fn(&self) -> bool {\n         match self.inner { FunctionItem(..) => true, _ => false }\n     }\n+    pub fn is_associated_type(&self) -> bool {\n+        match self.inner { AssociatedTypeItem(..) => true, _ => false }\n+    }\n+    pub fn is_associated_const(&self) -> bool {\n+        match self.inner { AssociatedConstItem(..) => true, _ => false }\n+    }\n+    pub fn is_method(&self) -> bool {\n+        match self.inner { MethodItem(..) => true, _ => false }\n+    }\n+    pub fn is_ty_method(&self) -> bool {\n+        match self.inner { TyMethodItem(..) => true, _ => false }\n+    }\n \n     pub fn stability_class(&self) -> String {\n-        match self.stability {\n-            Some(ref s) => {\n-                let mut base = match s.level {\n-                    stability::Unstable => \"unstable\".to_string(),\n-                    stability::Stable => String::new(),\n-                };\n-                if !s.deprecated_since.is_empty() {\n-                    base.push_str(\" deprecated\");\n-                }\n-                base\n+        self.stability.as_ref().map(|ref s| {\n+            let mut base = match s.level {\n+                stability::Unstable => \"unstable\".to_string(),\n+                stability::Stable => String::new(),\n+            };\n+            if !s.deprecated_since.is_empty() {\n+                base.push_str(\" deprecated\");\n             }\n-            _ => String::new(),\n-        }\n+            base\n+        }).unwrap_or(String::new())\n     }\n \n     pub fn stable_since(&self) -> Option<&str> {\n-        if let Some(ref s) = self.stability {\n-            return Some(&s.since[..]);\n-        }\n-\n-        None\n+        self.stability.as_ref().map(|s| &s.since[..])\n     }\n }\n \n@@ -448,10 +415,54 @@ impl Clean<Item> for doctree::Module {\n     }\n }\n \n+pub trait Attributes {\n+    fn has_word(&self, &str) -> bool;\n+    fn value<'a>(&'a self, &str) -> Option<&'a str>;\n+    fn list_def<'a>(&'a self, &str) -> &'a [Attribute];\n+}\n+\n+impl Attributes for [Attribute] {\n+    /// Returns whether the attribute list contains a specific `Word`\n+    fn has_word(&self, word: &str) -> bool {\n+        for attr in self {\n+            if let Word(ref w) = *attr {\n+                if word == *w {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Finds an attribute as NameValue and returns the corresponding value found.\n+    fn value<'a>(&'a self, name: &str) -> Option<&'a str> {\n+        for attr in self {\n+            if let NameValue(ref x, ref v) = *attr {\n+                if name == *x {\n+                    return Some(v);\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Finds an attribute as List and returns the list of attributes nested inside.\n+    fn list_def<'a>(&'a self, name: &str) -> &'a [Attribute] {\n+        for attr in self {\n+            if let List(ref x, ref list) = *attr {\n+                if name == *x {\n+                    return &list[..];\n+                }\n+            }\n+        }\n+        &[]\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum Attribute {\n     Word(String),\n-    List(String, Vec<Attribute> ),\n+    List(String, Vec<Attribute>),\n     NameValue(String, String)\n }\n \n@@ -496,12 +507,6 @@ impl attr::AttrMetaMethods for Attribute {\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n     fn span(&self) -> codemap::Span { unimplemented!() }\n }\n-impl<'a> attr::AttrMetaMethods for &'a Attribute {\n-    fn name(&self) -> InternedString { (**self).name() }\n-    fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list(&self) -> Option<&[P<ast::MetaItem>]> { None }\n-    fn span(&self) -> codemap::Span { unimplemented!() }\n-}\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct TyParam {\n@@ -711,7 +716,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n                         if let &ty::Region::ReLateBound(_, _) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n-                                late_bounds.push(lt)\n+                                late_bounds.push(lt);\n                             }\n                         }\n                     }\n@@ -780,8 +785,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n     fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n-            ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n-                Some(Lifetime(name.to_string())),\n+            ty::ReLateBound(_, ty::BrNamed(_, name)) => Some(Lifetime(name.to_string())),\n             ty::ReEarlyBound(ref data) => Some(Lifetime(data.name.clean(cx))),\n \n             ty::ReLateBound(..) |\n@@ -1151,12 +1155,12 @@ impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if let Some(_) = cx.map.as_local_node_id(did) {\n+        let mut names = if cx.map.as_local_node_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n             cx.tcx().sess.cstore.method_arg_names(did).into_iter()\n         }.peekable();\n-        if names.peek().map(|s| &**s) == Some(\"self\") {\n+        if let Some(\"self\") = names.peek().map(|s| &s[..]) {\n             let _ = names.next();\n         }\n         FnDecl {\n@@ -1524,24 +1528,16 @@ impl PrimitiveType {\n     }\n \n     fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n-        for attr in attrs {\n-            let list = match *attr {\n-                List(ref k, ref l) if *k == \"doc\" => l,\n-                _ => continue,\n-            };\n-            for sub_attr in list {\n-                let value = match *sub_attr {\n-                    NameValue(ref k, ref v)\n-                        if *k == \"primitive\" => v,\n-                    _ => continue,\n-                };\n-                match PrimitiveType::from_str(value) {\n-                    Some(p) => return Some(p),\n-                    None => {}\n+        for attr in attrs.list_def(\"doc\") {\n+            if let NameValue(ref k, ref v) = *attr {\n+                if \"primitive\" == *k {\n+                    if let ret@Some(..) = PrimitiveType::from_str(v) {\n+                        return ret;\n+                    }\n                 }\n             }\n         }\n-        return None\n+        None\n     }\n \n     pub fn to_string(&self) -> &'static str {\n@@ -1627,15 +1623,9 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyPolyTraitRef(ref bounds) => {\n-                PolyTraitRef(bounds.clean(cx))\n-            },\n-            TyInfer => {\n-                Infer\n-            },\n-            TyTypeof(..) => {\n-                panic!(\"Unimplemented type {:?}\", self.node)\n-            },\n+            TyPolyTraitRef(ref bounds) => PolyTraitRef(bounds.clean(cx)),\n+            TyInfer => Infer,\n+            TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }\n     }\n }\n@@ -2253,7 +2243,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                 polarity: Some(self.polarity.clean(cx)),\n             }),\n         });\n-        return ret;\n+        ret\n     }\n }\n \n@@ -2393,9 +2383,8 @@ impl Clean<Vec<Item>> for doctree::Import {\n             }\n             hir::ViewPathSimple(name, ref p) => {\n                 if !denied {\n-                    match inline::try_inline(cx, self.id, Some(name)) {\n-                        Some(items) => return items,\n-                        None => {}\n+                    if let Some(items) = inline::try_inline(cx, self.id, Some(name)) {\n+                        return items;\n                     }\n                 }\n                 (vec![], SimpleImport(name.clean(cx),\n@@ -2460,9 +2449,8 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let mut items = self.items.clean(cx);\n         for item in &mut items {\n-            match item.inner {\n-                ForeignFunctionItem(ref mut f) => f.abi = self.abi,\n-                _ => {}\n+            if let ForeignFunctionItem(ref mut f) = item.inner {\n+                f.abi = self.abi;\n             }\n         }\n         items\n@@ -2598,11 +2586,7 @@ fn resolve_type(cx: &DocContext,\n             };\n         }\n     };\n-    let def = match tcx.def_map.borrow().get(&id) {\n-        Some(k) => k.full_def(),\n-        None => panic!(\"unresolved id not in defmap\")\n-    };\n-\n+    let def = tcx.def_map.borrow().get(&id).expect(\"unresolved id not in defmap\").full_def();\n     debug!(\"resolve_type: def={:?}\", def);\n \n     let is_generic = match def {\n@@ -2659,7 +2643,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         let t = inline::build_external_trait(cx, tcx, did);\n         cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n     }\n-    return did;\n+    did\n }\n \n fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSource {\n@@ -2732,12 +2716,10 @@ impl Clean<Stability> for attr::Stability {\n                 _=> \"\".to_string(),\n             },\n             reason: {\n-                if let Some(ref depr) = self.rustc_depr {\n-                    depr.reason.to_string()\n-                } else if let attr::Unstable {reason: Some(ref reason), ..} = self.level {\n-                    reason.to_string()\n-                } else {\n-                    \"\".to_string()\n+                match (&self.rustc_depr, &self.level) {\n+                    (&Some(ref depr), _) => depr.reason.to_string(),\n+                    (&None, &attr::Unstable {reason: Some(ref reason), ..}) => reason.to_string(),\n+                    _ => \"\".to_string(),\n                 }\n             },\n             issue: match self.level {"}, {"sha": "ceec80402c01e817a27b4bd6995bfb208f3eebf9", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=21fb3ce71b39133cc24b40de82e3214dd603cd61", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n use clean::*;\n-use std::collections::HashMap;\n-use std::mem::{replace, swap};\n \n pub trait DocFolder : Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n@@ -20,42 +18,36 @@ pub trait DocFolder : Sized {\n     /// don't override!\n     fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n         let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n-        let inner = inner;\n         let inner = match inner {\n             StructItem(mut i) => {\n-                let mut foo = Vec::new(); swap(&mut foo, &mut i.fields);\n-                let num_fields = foo.len();\n-                i.fields.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n+                let num_fields = i.fields.len();\n+                i.fields = i.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n                 i.fields_stripped |= num_fields != i.fields.len();\n                 StructItem(i)\n             },\n             ModuleItem(i) => {\n                 ModuleItem(self.fold_mod(i))\n             },\n             EnumItem(mut i) => {\n-                let mut foo = Vec::new(); swap(&mut foo, &mut i.variants);\n-                let num_variants = foo.len();\n-                i.variants.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n+                let num_variants = i.variants.len();\n+                i.variants = i.variants.into_iter().filter_map(|x| self.fold_item(x)).collect();\n                 i.variants_stripped |= num_variants != i.variants.len();\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n-                let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n-                i.items.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n+                i.items = i.items.into_iter().filter_map(|x| self.fold_item(x)).collect();\n                 TraitItem(i)\n             },\n             ImplItem(mut i) => {\n-                let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n-                i.items.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n+                i.items = i.items.into_iter().filter_map(|x| self.fold_item(x)).collect();\n                 ImplItem(i)\n             },\n             VariantItem(i) => {\n                 let i2 = i.clone(); // this clone is small\n                 match i.kind {\n                     StructVariant(mut j) => {\n-                        let mut foo = Vec::new(); swap(&mut foo, &mut j.fields);\n-                        let num_fields = foo.len();\n-                        j.fields.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n+                        let num_fields = j.fields.len();\n+                        j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n                         j.fields_stripped |= num_fields != j.fields.len();\n                         VariantItem(Variant {kind: StructVariant(j), ..i2})\n                     },\n@@ -78,16 +70,13 @@ pub trait DocFolder : Sized {\n     }\n \n     fn fold_crate(&mut self, mut c: Crate) -> Crate {\n-        c.module = match replace(&mut c.module, None) {\n-            Some(module) => self.fold_item(module), None => None\n-        };\n-        let external_traits = replace(&mut c.external_traits, HashMap::new());\n-        c.external_traits = external_traits.into_iter().map(|(k, mut v)| {\n-            let items = replace(&mut v.items, Vec::new());\n-            v.items = items.into_iter().filter_map(|i| self.fold_item(i))\n-                           .collect();\n+        c.module = c.module.and_then(|module| {\n+            self.fold_item(module)\n+        });\n+        c.external_traits = c.external_traits.into_iter().map(|(k, mut v)| {\n+            v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n             (k, v)\n         }).collect();\n-        return c;\n+        c\n     }\n }"}, {"sha": "2cb2b299e401709173db83d8856ce3c28a35c464", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 170, "deletions": 260, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=21fb3ce71b39133cc24b40de82e3214dd603cd61", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n use rustc_front::hir;\n \n-use clean::{self, SelfTy};\n+use clean::{self, SelfTy, Attributes};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -104,6 +104,8 @@ pub struct Context {\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n     pub include_sources: bool,\n+    /// The local file sources we've emitted and their respective url-paths.\n+    pub local_sources: HashMap<PathBuf, String>,\n     /// A flag, which when turned off, will render pages which redirect to the\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n@@ -262,8 +264,6 @@ pub struct Cache {\n struct SourceCollector<'a> {\n     cx: &'a mut Context,\n \n-    /// Processed source-file paths\n-    seen: HashSet<String>,\n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n }\n@@ -374,7 +374,7 @@ fn init_ids() -> HashMap<String, usize> {\n      \"deref-methods\",\n      \"implementations\",\n      \"derived_implementations\"\n-     ].into_iter().map(|id| (String::from(*id), 1)).collect::<HashMap<_, _>>()\n+     ].into_iter().map(|id| (String::from(*id), 1)).collect()\n }\n \n /// This method resets the local table of used ID attributes. This is typically\n@@ -423,6 +423,7 @@ pub fn run(mut krate: clean::Crate,\n             playground_url: \"\".to_string(),\n         },\n         include_sources: true,\n+        local_sources: HashMap::new(),\n         render_redirect_pages: false,\n         issue_tracker_base_url: None,\n     };\n@@ -431,42 +432,38 @@ pub fn run(mut krate: clean::Crate,\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n-    let default: &[_] = &[];\n-    match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(default)) {\n-        Some(attrs) => {\n-            for attr in attrs {\n-                match *attr {\n-                    clean::NameValue(ref x, ref s)\n-                            if \"html_favicon_url\" == *x => {\n-                        cx.layout.favicon = s.to_string();\n-                    }\n-                    clean::NameValue(ref x, ref s)\n-                            if \"html_logo_url\" == *x => {\n-                        cx.layout.logo = s.to_string();\n-                    }\n-                    clean::NameValue(ref x, ref s)\n-                            if \"html_playground_url\" == *x => {\n-                        cx.layout.playground_url = s.to_string();\n-                        markdown::PLAYGROUND_KRATE.with(|slot| {\n-                            if slot.borrow().is_none() {\n-                                let name = krate.name.clone();\n-                                *slot.borrow_mut() = Some(Some(name));\n-                            }\n-                        });\n-                    }\n-                    clean::NameValue(ref x, ref s)\n-                            if \"issue_tracker_base_url\" == *x => {\n-                        cx.issue_tracker_base_url = Some(s.to_string());\n-                    }\n-                    clean::Word(ref x)\n-                            if \"html_no_source\" == *x => {\n-                        cx.include_sources = false;\n-                    }\n-                    _ => {}\n+    if let Some(attrs) = krate.module.as_ref().map(|m| m.attrs.list_def(\"doc\")) {\n+        for attr in attrs {\n+            match *attr {\n+                clean::NameValue(ref x, ref s)\n+                        if \"html_favicon_url\" == *x => {\n+                    cx.layout.favicon = s.to_string();\n                 }\n+                clean::NameValue(ref x, ref s)\n+                        if \"html_logo_url\" == *x => {\n+                    cx.layout.logo = s.to_string();\n+                }\n+                clean::NameValue(ref x, ref s)\n+                        if \"html_playground_url\" == *x => {\n+                    cx.layout.playground_url = s.to_string();\n+                    markdown::PLAYGROUND_KRATE.with(|slot| {\n+                        if slot.borrow().is_none() {\n+                            let name = krate.name.clone();\n+                            *slot.borrow_mut() = Some(Some(name));\n+                        }\n+                    });\n+                }\n+                clean::NameValue(ref x, ref s)\n+                        if \"issue_tracker_base_url\" == *x => {\n+                    cx.issue_tracker_base_url = Some(s.to_string());\n+                }\n+                clean::Word(ref x)\n+                        if \"html_no_source\" == *x => {\n+                    cx.include_sources = false;\n+                }\n+                _ => {}\n             }\n         }\n-        None => {}\n     }\n \n     // Crawl the crate to build various caches used for the output\n@@ -770,11 +767,8 @@ fn render_sources(cx: &mut Context,\n     try_err!(mkdir(&dst), &dst);\n     let mut folder = SourceCollector {\n         dst: dst,\n-        seen: HashSet::new(),\n         cx: cx,\n     };\n-    // skip all invalid spans\n-    folder.seen.insert(\"\".to_string());\n     Ok(folder.fold_crate(krate))\n }\n \n@@ -838,35 +832,26 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    for attr in &e.attrs {\n-        match *attr {\n-            clean::List(ref x, ref list) if \"doc\" == *x => {\n-                for attr in list {\n-                    match *attr {\n-                        clean::NameValue(ref x, ref s)\n-                                if \"html_root_url\" == *x => {\n-                            if s.ends_with(\"/\") {\n-                                return Remote(s.to_string());\n-                            }\n-                            return Remote(format!(\"{}/\", s));\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            _ => {}\n+    e.attrs.list_def(\"doc\").value(\"html_root_url\").map(|url| {\n+        let mut url = url.to_owned();\n+        if !url.ends_with(\"/\") {\n+            url.push('/')\n         }\n-    }\n-\n-    // Well, at least we tried.\n-    return Unknown;\n+        Remote(url)\n+    }).unwrap_or(Unknown) // Well, at least we tried.\n }\n \n impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem\n-        if self.cx.include_sources && !self.seen.contains(&item.source.filename) {\n+        if self.cx.include_sources\n+            // skip all invalid spans\n+            && item.source.filename != \"\"\n+            // macros from other libraries get special filenames which we can\n+            // safely ignore\n+            && !(item.source.filename.starts_with(\"<\")\n+                && item.source.filename.ends_with(\"macros>\")) {\n \n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n@@ -884,7 +869,6 @@ impl<'a> DocFolder for SourceCollector<'a> {\n                     false\n                 }\n             };\n-            self.seen.insert(item.source.filename.clone());\n         }\n \n         self.fold_item_recur(item)\n@@ -895,19 +879,14 @@ impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n         let p = PathBuf::from(filename);\n+        if self.cx.local_sources.contains_key(&p) {\n+            // We've already emitted this source\n+            return Ok(());\n+        }\n \n-        // If we couldn't open this file, then just returns because it\n-        // probably means that it's some standard library macro thing and we\n-        // can't have the source to it anyway.\n         let mut contents = Vec::new();\n-        match File::open(&p).and_then(|mut f| f.read_to_end(&mut contents)) {\n-            Ok(r) => r,\n-            // macros from other libraries get special filenames which we can\n-            // safely ignore\n-            Err(..) if filename.starts_with(\"<\") &&\n-                       filename.ends_with(\"macros>\") => return Ok(()),\n-            Err(e) => return Err(e)\n-        };\n+        try!(File::open(&p).and_then(|mut f| f.read_to_end(&mut contents)));\n+\n         let contents = str::from_utf8(&contents).unwrap();\n \n         // Remove the utf-8 BOM if any\n@@ -920,16 +899,20 @@ impl<'a> SourceCollector<'a> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n+        let mut href = String::new();\n         clean_srcpath(&self.cx.src_root, &p, false, |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n+            href.push_str(component);\n+            href.push('/');\n         });\n-\n         let mut fname = p.file_name().expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n         cur.push(&fname[..]);\n+        href.push_str(&fname.to_string_lossy());\n+\n         let mut w = BufWriter::new(try!(File::create(&cur)));\n         let title = format!(\"{} -- source\", cur.file_name().unwrap()\n                                                .to_string_lossy());\n@@ -939,12 +922,13 @@ impl<'a> SourceCollector<'a> {\n             ty: \"source\",\n             root_path: &root_path,\n             description: &desc,\n-            keywords: get_basic_keywords(),\n+            keywords: BASIC_KEYWORDS,\n         };\n         try!(layout::render(&mut w, &self.cx.layout,\n                             &page, &(\"\"), &Source(contents)));\n         try!(w.flush());\n-        return Ok(());\n+        self.cx.local_sources.insert(p, href);\n+        Ok(())\n     }\n }\n \n@@ -983,15 +967,12 @@ impl DocFolder for Cache {\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = item.inner {\n-            match i.trait_ {\n-                Some(clean::ResolvedPath{ did, .. }) => {\n-                    self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n-                        def_id: item.def_id,\n-                        stability: item.stability.clone(),\n-                        impl_: i.clone(),\n-                    });\n-                }\n-                Some(..) | None => {}\n+            if let Some(clean::ResolvedPath{ did, .. }) = i.trait_ {\n+                self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n+                    def_id: item.def_id,\n+                    stability: item.stability.clone(),\n+                    impl_: i.clone(),\n+                });\n             }\n         }\n \n@@ -1051,6 +1032,9 @@ impl DocFolder for Cache {\n                         }\n                     });\n \n+                    // A crate has a module at its root, containing all items,\n+                    // which should not be indexed. The crate-item itself is\n+                    // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n                         self.search_index.push(IndexItem {\n                             ty: shortty(&item),\n@@ -1075,13 +1059,14 @@ impl DocFolder for Cache {\n         }\n \n         // Keep track of the fully qualified path for this item.\n-        let pushed = if item.name.is_some() {\n-            let n = item.name.as_ref().unwrap();\n-            if !n.is_empty() {\n+        let pushed = match item.name {\n+            Some(ref n) if !n.is_empty() => {\n                 self.stack.push(n.to_string());\n                 true\n-            } else { false }\n-        } else { false };\n+            }\n+            _ => false,\n+        };\n+\n         match item.inner {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n@@ -1150,60 +1135,40 @@ impl DocFolder for Cache {\n \n         // Once we've recursively found all the generics, then hoard off all the\n         // implementations elsewhere\n-        let ret = match self.fold_item_recur(item) {\n-            Some(item) => {\n-                match item {\n-                    clean::Item{ attrs, inner: clean::ImplItem(i), .. } => {\n-                        // extract relevant documentation for this impl\n-                        let dox = match attrs.into_iter().find(|a| {\n-                            match *a {\n-                                clean::NameValue(ref x, _)\n-                                        if \"doc\" == *x => {\n-                                    true\n-                                }\n-                                _ => false\n-                            }\n-                        }) {\n-                            Some(clean::NameValue(_, dox)) => Some(dox),\n-                            Some(..) | None => None,\n-                        };\n-\n-                        // Figure out the id of this impl. This may map to a\n-                        // primitive rather than always to a struct/enum.\n-                        let did = match i.for_ {\n-                            clean::ResolvedPath { did, .. } |\n-                            clean::BorrowedRef {\n-                                type_: box clean::ResolvedPath { did, .. }, ..\n-                            } => {\n-                                Some(did)\n-                            }\n-\n-                            ref t => {\n-                                t.primitive_type().and_then(|t| {\n-                                    self.primitive_locations.get(&t).map(|n| {\n-                                        let id = t.to_def_index();\n-                                        DefId { krate: *n, index: id }\n-                                    })\n-                                })\n-                            }\n-                        };\n-\n-                        if let Some(did) = did {\n-                            self.impls.entry(did).or_insert(vec![]).push(Impl {\n-                                impl_: i,\n-                                dox: dox,\n-                                stability: item.stability.clone(),\n-                            });\n-                        }\n+        let ret = self.fold_item_recur(item).and_then(|item| {\n+            if let clean::Item { attrs, inner: clean::ImplItem(i), .. } = item {\n+                // Figure out the id of this impl. This may map to a\n+                // primitive rather than always to a struct/enum.\n+                let did = match i.for_ {\n+                    clean::ResolvedPath { did, .. } |\n+                    clean::BorrowedRef {\n+                        type_: box clean::ResolvedPath { did, .. }, ..\n+                    } => {\n+                        Some(did)\n+                    }\n \n-                        None\n+                    ref t => {\n+                        t.primitive_type().and_then(|t| {\n+                            self.primitive_locations.get(&t).map(|n| {\n+                                let id = t.to_def_index();\n+                                DefId { krate: *n, index: id }\n+                            })\n+                        })\n                     }\n+                };\n \n-                    i => Some(i),\n+                if let Some(did) = did {\n+                    self.impls.entry(did).or_insert(vec![]).push(Impl {\n+                        impl_: i,\n+                        dox: attrs.value(\"doc\").map(|s|s.to_owned()),\n+                        stability: item.stability.clone(),\n+                    });\n                 }\n+                None\n+            } else {\n+                Some(item)\n             }\n-            i => i,\n-        };\n+        });\n \n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n@@ -1301,11 +1266,7 @@ impl Context {\n             }\n             title.push_str(\" - Rust\");\n             let tyname = shortty(it).to_static_str();\n-            let is_crate = match it.inner {\n-                clean::ModuleItem(clean::Module { items: _, is_crate: true }) => true,\n-                _ => false\n-            };\n-            let desc = if is_crate {\n+            let desc = if it.is_crate() {\n                 format!(\"API documentation for the Rust `{}` crate.\",\n                         cx.layout.krate)\n             } else {\n@@ -1459,7 +1420,7 @@ impl<'a> Item<'a> {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn href(&self, cx: &Context) -> Option<String> {\n+    fn href(&self) -> Option<String> {\n         let href = if self.item.source.loline == self.item.source.hiline {\n             format!(\"{}\", self.item.source.loline)\n         } else {\n@@ -1492,25 +1453,13 @@ impl<'a> Item<'a> {\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n         } else if self.item.def_id.is_local() {\n-            let mut path = Vec::new();\n-            clean_srcpath(&cx.src_root, Path::new(&self.item.source.filename),\n-                          true, |component| {\n-                path.push(component.to_string());\n-            });\n-\n-            // If the span points into an external macro the\n-            // source-file will be bogus, i.e `<foo macros>`\n-            let filename = &self.item.source.filename;\n-            if !(filename.starts_with(\"<\") && filename.ends_with(\"macros>\")) {\n-                Some(format!(\"{root}src/{krate}/{path}.html#{href}\",\n-                             root = self.cx.root_path,\n-                             krate = self.cx.layout.krate,\n-                             path = path.join(\"/\"),\n-                             href = href))\n-            } else {\n-                None\n-            }\n-\n+            self.cx.local_sources.get(&PathBuf::from(&self.item.source.filename)).map(|path| {\n+                format!(\"{root}src/{krate}/{path}.html#{href}\",\n+                        root = self.cx.root_path,\n+                        krate = self.cx.layout.krate,\n+                        path = path,\n+                        href = href)\n+            })\n         // If this item is not part of the local crate, then things get a little\n         // trickier. We don't actually know the span of the external item, but\n         // we know that the documentation on the other end knows the span!\n@@ -1590,13 +1539,10 @@ impl<'a> fmt::Display for Item<'a> {\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n         if self.cx.include_sources && !is_primitive {\n-            match self.href(self.cx) {\n-                Some(l) => {\n-                    try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n-                                       href='{}' title='{}'>[src]</a>\",\n-                                self.item.def_id.index.as_usize(), l, \"goto source code\"));\n-                }\n-                None => {}\n+            if let Some(l) = self.href() {\n+                try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n+                                   href='{}' title='{}'>[src]</a>\",\n+                            self.item.def_id.index.as_usize(), l, \"goto source code\"));\n             }\n         }\n \n@@ -1810,7 +1756,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n }\n \n fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Option<String> {\n-    let mut result = item.stability.as_ref().and_then(|stab| {\n+    item.stability.as_ref().and_then(|stab| {\n         let reason = if show_reason && !stab.reason.is_empty() {\n             format!(\": {}\", stab.reason)\n         } else {\n@@ -1845,10 +1791,8 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n         };\n         Some(format!(\"<em class='stab {}'>{}</em>\",\n                      item.stability_class(), text))\n-    });\n-\n-    if result.is_none() {\n-        result = item.deprecation.as_ref().and_then(|depr| {\n+    }).or_else(|| {\n+        item.deprecation.as_ref().and_then(|depr| {\n             let note = if show_reason && !depr.note.is_empty() {\n                 format!(\": {}\", depr.note)\n             } else {\n@@ -1862,10 +1806,8 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n \n             let text = format!(\"Deprecated{}{}\", since, Markdown(&note));\n             Some(format!(\"<em class='stab deprecated'>{}</em>\", text))\n-        });\n-    }\n-\n-    result\n+        })\n+    })\n }\n \n struct Initializer<'a>(&'a str);\n@@ -1945,18 +1887,10 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                   bounds,\n                   WhereClause(&t.generics)));\n \n-    let types = t.items.iter().filter(|m| {\n-        match m.inner { clean::AssociatedTypeItem(..) => true, _ => false }\n-    }).collect::<Vec<_>>();\n-    let consts = t.items.iter().filter(|m| {\n-        match m.inner { clean::AssociatedConstItem(..) => true, _ => false }\n-    }).collect::<Vec<_>>();\n-    let required = t.items.iter().filter(|m| {\n-        match m.inner { clean::TyMethodItem(_) => true, _ => false }\n-    }).collect::<Vec<_>>();\n-    let provided = t.items.iter().filter(|m| {\n-        match m.inner { clean::MethodItem(_) => true, _ => false }\n-    }).collect::<Vec<_>>();\n+    let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n+    let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n+    let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n+    let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n \n     if t.items.is_empty() {\n         try!(write!(w, \"{{ }}\"));\n@@ -2117,17 +2051,12 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n fn render_stability_since_raw<'a>(w: &mut fmt::Formatter,\n                                   ver: Option<&'a str>,\n                                   containing_ver: Option<&'a str>) -> fmt::Result {\n-    if containing_ver != ver {\n-        match ver {\n-            Some(v) =>\n-                if v.len() > 0 {\n-                        try!(write!(w, \"<span class=\\\"since\\\">{}</span>\",\n-                                    v))\n-                },\n-            None => {}\n+    if let Some(v) = ver {\n+        if containing_ver != ver && v.len() > 0 {\n+            try!(write!(w, \"<span class=\\\"since\\\">{}</span>\",\n+                        v))\n         }\n     }\n-\n     Ok(())\n }\n \n@@ -2298,43 +2227,33 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n                           name = variant.name.as_ref().unwrap()));\n             try!(document(w, cx, variant));\n-            match variant.inner {\n-                clean::VariantItem(ref var) => {\n-                    match var.kind {\n-                        clean::StructVariant(ref s) => {\n-                            let fields = s.fields.iter().filter(|f| {\n-                                match f.inner {\n-                                    clean::StructFieldItem(ref t) => match *t {\n-                                        clean::HiddenStructField => false,\n-                                        clean::TypedStructField(..) => true,\n-                                    },\n-                                    _ => false,\n-                                }\n-                            });\n-                            try!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n-                                              <table>\"));\n-                            for field in fields {\n-                                try!(write!(w, \"<tr><td \\\n-                                                  id='variant.{v}.field.{f}'>\\\n-                                                  <code>{f}</code></td><td>\",\n-                                              v = variant.name.as_ref().unwrap(),\n-                                              f = field.name.as_ref().unwrap()));\n-                                try!(document(w, cx, field));\n-                                try!(write!(w, \"</td></tr>\"));\n-                            }\n-                            try!(write!(w, \"</table>\"));\n-                        }\n-                        _ => ()\n+\n+            use clean::{Variant, StructVariant};\n+            if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n+                let fields = s.fields.iter().filter(|f| {\n+                    match f.inner {\n+                        clean::StructFieldItem(clean::TypedStructField(..)) => true,\n+                        _ => false,\n                     }\n+                });\n+                try!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n+                                  <table>\"));\n+                for field in fields {\n+                    try!(write!(w, \"<tr><td \\\n+                                      id='variant.{v}.field.{f}'>\\\n+                                      <code>{f}</code></td><td>\",\n+                                  v = variant.name.as_ref().unwrap(),\n+                                  f = field.name.as_ref().unwrap()));\n+                    try!(document(w, cx, field));\n+                    try!(write!(w, \"</td></tr>\"));\n                 }\n-                _ => ()\n+                try!(write!(w, \"</table>\"));\n             }\n             try!(write!(w, \"</td><td>\"));\n             try!(render_stability_since(w, variant, it));\n             try!(write!(w, \"</td></tr>\"));\n         }\n         try!(write!(w, \"</table>\"));\n-\n     }\n     try!(render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All));\n     Ok(())\n@@ -2365,9 +2284,8 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                   VisSpace(it.visibility),\n                   if structhead {\"struct \"} else {\"\"},\n                   it.name.as_ref().unwrap()));\n-    match g {\n-        Some(g) => try!(write!(w, \"{}{}\", *g, WhereClause(g))),\n-        None => {}\n+    if let Some(g) = g {\n+        try!(write!(w, \"{}{}\", *g, WhereClause(g)))\n     }\n     match ty {\n         doctree::Plain => {\n@@ -2461,7 +2379,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n-        return Ok(())\n+        return Ok(());\n     }\n     if !traits.is_empty() {\n         let deref_impl = traits.iter().find(|t| {\n@@ -2542,10 +2460,17 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                     link: AssocItemLink, render_static: bool,\n                     outer_version: Option<&str>) -> fmt::Result {\n         let name = item.name.as_ref().unwrap();\n+\n+        let is_static = match item.inner {\n+            clean::MethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n+            clean::TyMethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n+            _ => false\n+        };\n+\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n-                if !is_static_method(item) || render_static {\n+                if !is_static || render_static {\n                     let id = derive_id(format!(\"method.{}\", name));\n                     try!(write!(w, \"<h4 id='{}' class='{}'>\", id, shortty(item)));\n                     try!(render_stability_since_raw(w, item.stable_since(), outer_version));\n@@ -2581,22 +2506,11 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n \n-        return if let AssocItemLink::Anchor = link {\n-            if is_static_method(item) && !render_static {\n-                Ok(())\n-            } else {\n+        match link {\n+            AssocItemLink::Anchor if !is_static || render_static => {\n                 document(w, cx, item)\n-            }\n-        } else {\n-            Ok(())\n-        };\n-\n-        fn is_static_method(item: &clean::Item) -> bool {\n-            match item.inner {\n-                clean::MethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n-                clean::TyMethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n-                _ => false\n-            }\n+            },\n+            _ => Ok(()),\n         }\n     }\n \n@@ -2614,9 +2528,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                               outer_version: Option<&str>) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n-            match i.items.iter().find(|m| { m.name == n }) {\n-                Some(..) => continue,\n-                None => {}\n+            if i.items.iter().find(|m| { m.name == n }).is_some() {\n+                continue;\n             }\n \n             try!(doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static,\n@@ -2632,7 +2545,6 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n             try!(render_default_items(w, cx, did, t, &i.impl_, render_header, outer_version));\n-\n         }\n     }\n     try!(write!(w, \"</div>\"));\n@@ -2676,7 +2588,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         try!(write!(fmt, \"</p>\"));\n \n         // sidebar refers to the enclosing module, not this module\n-        let relpath = if shortty(it) == ItemType::Module { \"../\" } else { \"\" };\n+        let relpath = if it.is_mod() { \"../\" } else { \"\" };\n         try!(write!(fmt,\n                     \"<script>window.sidebarCurrent = {{\\\n                         name: '{name}', \\\n@@ -2734,12 +2646,10 @@ fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn get_basic_keywords() -> &'static str {\n-    \"rust, rustlang, rust-lang\"\n-}\n+const BASIC_KEYWORDS: &'static str = \"rust, rustlang, rust-lang\";\n \n fn make_item_keywords(it: &clean::Item) -> String {\n-    format!(\"{}, {}\", get_basic_keywords(), it.name.as_ref().unwrap())\n+    format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())\n }\n \n fn get_index_search_type(item: &clean::Item,"}, {"sha": "3c7aadb3533c414c764e3a1e9fde5c23f00cd990", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 34, "deletions": 60, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=21fb3ce71b39133cc24b40de82e3214dd603cd61", "patch": "@@ -94,6 +94,8 @@ pub mod visit_ast;\n pub mod test;\n mod flock;\n \n+use clean::Attributes;\n+\n type Pass = (&'static str,                                      // name\n              fn(clean::Crate) -> plugins::PluginResult,         // fn\n              &'static str);                                     // description\n@@ -283,19 +285,15 @@ pub fn main_args(args: &[String]) -> isize {\n     info!(\"going to format\");\n     match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n-            match html::render::run(krate, &external_html,\n-                                    output.unwrap_or(PathBuf::from(\"doc\")),\n-                                    passes.into_iter().collect()) {\n-                Ok(()) => {}\n-                Err(e) => panic!(\"failed to generate documentation: {}\", e),\n-            }\n+            html::render::run(krate, &external_html,\n+                              output.unwrap_or(PathBuf::from(\"doc\")),\n+                              passes.into_iter().collect())\n+                .expect(\"failed to generate documentation\")\n         }\n         Some(\"json\") => {\n-            match json_output(krate, json_plugins,\n-                              output.unwrap_or(PathBuf::from(\"doc.json\"))) {\n-                Ok(()) => {}\n-                Err(e) => panic!(\"failed to write json: {}\", e),\n-            }\n+            json_output(krate, json_plugins,\n+                        output.unwrap_or(PathBuf::from(\"doc.json\")))\n+                .expect(\"failed to write json\")\n         }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n@@ -332,18 +330,10 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n-        let name = match parts.next() {\n-            Some(s) => s,\n-            None => {\n-                return Err(\"--extern value must not be empty\".to_string());\n-            }\n-        };\n-        let location = match parts.next() {\n-            Some(s) => s,\n-            None => {\n-                return Err(\"--extern value must be of the format `foo=bar`\".to_string());\n-            }\n-        };\n+        let name = try!(parts.next().ok_or(\"--extern value must not be empty\".to_string()));\n+        let location = try!(parts.next()\n+                                 .ok_or(\"--extern value must be of the format `foo=bar`\"\n+                                    .to_string()));\n         let name = name.to_string();\n         externs.entry(name).or_insert(vec![]).push(location.to_string());\n     }\n@@ -391,32 +381,25 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run.\n-    match krate.module.as_ref().unwrap().doc_list() {\n-        Some(nested) => {\n-            for inner in nested {\n-                match *inner {\n-                    clean::Word(ref x)\n-                            if \"no_default_passes\" == *x => {\n-                        default_passes = false;\n-                    }\n-                    clean::NameValue(ref x, ref value)\n-                            if \"passes\" == *x => {\n-                        for pass in value.split_whitespace() {\n-                            passes.push(pass.to_string());\n-                        }\n-                    }\n-                    clean::NameValue(ref x, ref value)\n-                            if \"plugins\" == *x => {\n-                        for p in value.split_whitespace() {\n-                            plugins.push(p.to_string());\n-                        }\n-                    }\n-                    _ => {}\n+    for attr in krate.module.as_ref().unwrap().attrs.list_def(\"doc\") {\n+        match *attr {\n+            clean::Word(ref w) if \"no_default_passes\" == *w => {\n+                default_passes = false;\n+            },\n+            clean::NameValue(ref name, ref value) => {\n+                let sink = match &name[..] {\n+                    \"passes\" => &mut passes,\n+                    \"plugins\" => &mut plugins,\n+                    _ => continue,\n+                };\n+                for p in value.split_whitespace() {\n+                    sink.push(p.to_string());\n                 }\n             }\n+            _ => (),\n         }\n-        None => {}\n     }\n+\n     if default_passes {\n         for name in DEFAULT_PASSES.iter().rev() {\n             passes.insert(0, name.to_string());\n@@ -448,17 +431,16 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // Run everything!\n     info!(\"Executing passes/plugins\");\n     let (krate, json) = pm.run_plugins(krate);\n-    return Output { krate: krate, json_plugins: json, passes: passes, };\n+    Output { krate: krate, json_plugins: json, passes: passes }\n }\n \n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, String> {\n     let mut bytes = Vec::new();\n-    match File::open(input).and_then(|mut f| f.read_to_end(&mut bytes)) {\n-        Ok(_) => {}\n-        Err(e) => return Err(format!(\"couldn't open {}: {}\", input, e)),\n-    };\n+    if let Err(e) = File::open(input).and_then(|mut f| f.read_to_end(&mut bytes)) {\n+        return Err(format!(\"couldn't open {}: {}\", input, e))\n+    }\n     match json::from_reader(&mut &bytes[..]) {\n         Err(s) => Err(format!(\"{:?}\", s)),\n         Ok(Json::Object(obj)) => {\n@@ -507,21 +489,13 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     json.insert(\"schema\".to_string(), Json::String(SCHEMA_VERSION.to_string()));\n     let plugins_json = res.into_iter()\n                           .filter_map(|opt| {\n-                              match opt {\n-                                  None => None,\n-                                  Some((string, json)) => {\n-                                      Some((string.to_string(), json))\n-                                  }\n-                              }\n+                              opt.map(|(string, json)| (string.to_string(), json))\n                           }).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n     let crate_json_str = format!(\"{}\", json::as_json(&krate));\n-    let crate_json = match json::from_str(&crate_json_str) {\n-        Ok(j) => j,\n-        Err(e) => panic!(\"Rust generated JSON is invalid: {:?}\", e)\n-    };\n+    let crate_json = json::from_str(&crate_json_str).expect(\"Rust generated JSON is invalid\");\n \n     json.insert(\"crate\".to_string(), crate_json);\n     json.insert(\"plugins\".to_string(), Json::Object(plugins_json));"}, {"sha": "6f6a72fa9fe7d8ff114a461109ae43f928dd94e1", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=21fb3ce71b39133cc24b40de82e3214dd603cd61", "patch": "@@ -16,7 +16,7 @@ use std::string::String;\n use std::usize;\n use rustc_front::hir;\n \n-use clean;\n+use clean::{self, Attributes};\n use clean::Item;\n use plugins;\n use fold;\n@@ -33,7 +33,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n         }\n         impl<'a> fold::DocFolder for Stripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n-                if i.is_hidden_from_doc() {\n+                if i.attrs.list_def(\"doc\").has_word(\"hidden\") {\n                     debug!(\"found one in strip_hidden; removing\");\n                     self.stripped.insert(i.def_id);\n \n@@ -205,22 +205,19 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             self.fold_item_recur(i)\n         };\n \n-        match i {\n-            Some(i) => {\n-                match i.inner {\n-                    // emptied modules/impls have no need to exist\n-                    clean::ModuleItem(ref m)\n-                        if m.items.is_empty() &&\n-                           i.doc_value().is_none() => None,\n-                    clean::ImplItem(ref i) if i.items.is_empty() => None,\n-                    _ => {\n-                        self.retained.insert(i.def_id);\n-                        Some(i)\n-                    }\n+        i.and_then(|i| {\n+            match i.inner {\n+                // emptied modules/impls have no need to exist\n+                clean::ModuleItem(ref m)\n+                    if m.items.is_empty() &&\n+                       i.doc_value().is_none() => None,\n+                clean::ImplItem(ref i) if i.items.is_empty() => None,\n+                _ => {\n+                    self.retained.insert(i.def_id);\n+                    Some(i)\n                 }\n             }\n-            None => None,\n-        }\n+        })\n     }\n }\n \n@@ -246,8 +243,7 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n     struct CommentCleaner;\n     impl fold::DocFolder for CommentCleaner {\n-        fn fold_item(&mut self, i: Item) -> Option<Item> {\n-            let mut i = i;\n+        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n             let mut avec: Vec<clean::Attribute> = Vec::new();\n             for attr in &i.attrs {\n                 match attr {\n@@ -271,17 +267,14 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n     struct Collapser;\n     impl fold::DocFolder for Collapser {\n-        fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n             let mut docstr = String::new();\n-            let mut i = i;\n             for attr in &i.attrs {\n-                match *attr {\n-                    clean::NameValue(ref x, ref s)\n-                            if \"doc\" == *x => {\n+                if let clean::NameValue(ref x, ref s) = *attr {\n+                    if \"doc\" == *x {\n                         docstr.push_str(s);\n                         docstr.push('\\n');\n-                    },\n-                    _ => ()\n+                    }\n                 }\n             }\n             let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {"}, {"sha": "e97357f98898b47f90d52b6f4526a08cb8b903d4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=21fb3ce71b39133cc24b40de82e3214dd603cd61", "patch": "@@ -121,9 +121,8 @@ pub fn run(input: &str,\n     let mut v = RustdocVisitor::new(&ctx, None);\n     v.visit(ctx.map.krate());\n     let mut krate = v.clean(&ctx);\n-    match crate_name {\n-        Some(name) => krate.name = name,\n-        None => {}\n+    if let Some(name) = crate_name {\n+        krate.name = name;\n     }\n     let (krate, _) = passes::collapse_docs(krate);\n     let (krate, _) = passes::unindent_comments(krate);\n@@ -334,13 +333,10 @@ pub fn maketest(s: &str, cratename: Option<&str>, dont_insert_main: bool,\n     // Don't inject `extern crate std` because it's already injected by the\n     // compiler.\n     if !s.contains(\"extern crate\") && !opts.no_crate_inject && cratename != Some(\"std\") {\n-        match cratename {\n-            Some(cratename) => {\n-                if s.contains(cratename) {\n-                    prog.push_str(&format!(\"extern crate {};\\n\", cratename));\n-                }\n+        if let Some(cratename) = cratename {\n+            if s.contains(cratename) {\n+                prog.push_str(&format!(\"extern crate {};\\n\", cratename));\n             }\n-            None => {}\n         }\n     }\n     if dont_insert_main || s.contains(\"fn main\") {\n@@ -476,12 +472,7 @@ impl DocFolder for Collector {\n             _ => typename_if_impl(&item)\n         };\n \n-        let pushed = if let Some(name) = current_name {\n-            self.names.push(name);\n-            true\n-        } else {\n-            false\n-        };\n+        let pushed = current_name.map(|name| self.names.push(name)).is_some();\n \n         if let Some(doc) = item.doc_value() {\n             self.cnt = 0;"}, {"sha": "bc6b4f83984b04f695ad5b4e46acb963524bda5e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21fb3ce71b39133cc24b40de82e3214dd603cd61/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=21fb3ce71b39133cc24b40de82e3214dd603cd61", "patch": "@@ -263,13 +263,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let name = renamed.unwrap_or(item.name);\n         match item.node {\n             hir::ItemExternCrate(ref p) => {\n-                let path = match *p {\n-                    None => None,\n-                    Some(x) => Some(x.to_string()),\n-                };\n                 om.extern_crates.push(ExternCrate {\n                     name: name,\n-                    path: path,\n+                    path: p.map(|x|x.to_string()),\n                     vis: item.vis,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,"}]}