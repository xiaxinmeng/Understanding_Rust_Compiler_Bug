{"sha": "76b89476c3aa8ae96d544684218f772223b18031", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2Yjg5NDc2YzNhYThhZTk2ZDU0NDY4NDIxOGY3NzIyMjNiMTgwMzE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-28T09:24:33Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-29T09:03:55Z"}, "message": "[WIP] simd_shuffle*", "tree": {"sha": "436c0e67c769f55aa1e24f94a00f644014063b3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/436c0e67c769f55aa1e24f94a00f644014063b3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76b89476c3aa8ae96d544684218f772223b18031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76b89476c3aa8ae96d544684218f772223b18031", "html_url": "https://github.com/rust-lang/rust/commit/76b89476c3aa8ae96d544684218f772223b18031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76b89476c3aa8ae96d544684218f772223b18031/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78e0525366d0e2873797624a558fd026d8809cde", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e0525366d0e2873797624a558fd026d8809cde", "html_url": "https://github.com/rust-lang/rust/commit/78e0525366d0e2873797624a558fd026d8809cde"}], "stats": {"total": 137, "additions": 98, "deletions": 39}, "files": [{"sha": "8a4a6337ca7e1d7489ed0bf01984f009c63844a4", "filename": "example/std_example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b89476c3aa8ae96d544684218f772223b18031/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b89476c3aa8ae96d544684218f772223b18031/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=76b89476c3aa8ae96d544684218f772223b18031", "patch": "@@ -59,10 +59,12 @@ unsafe fn test_simd() {\n     let or = _mm_or_si128(x, y);\n     let cmp_eq = _mm_cmpeq_epi8(y, y);\n     let cmp_lt = _mm_cmplt_epi8(y, y);\n+    let shl = _mm_slli_si128(y, 1);\n \n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 0]);\n }\n \n #[derive(PartialEq)]"}, {"sha": "3de9ea60e71799260c247ef334f0c832fdc35b61", "filename": "src/abi.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/76b89476c3aa8ae96d544684218f772223b18031/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b89476c3aa8ae96d544684218f772223b18031/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=76b89476c3aa8ae96d544684218f772223b18031", "patch": "@@ -613,28 +613,6 @@ pub fn codegen_terminator_call<'a, 'tcx: 'a>(\n     let fn_ty = fx.monomorphize(&func.ty(fx.mir, fx.tcx));\n     let sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n-    // Unpack arguments tuple for closures\n-    let args = if sig.abi == Abi::RustCall {\n-        assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n-        let self_arg = trans_operand(fx, &args[0]);\n-        let pack_arg = trans_operand(fx, &args[1]);\n-        let mut args = Vec::new();\n-        args.push(self_arg);\n-        match pack_arg.layout().ty.sty {\n-            ty::Tuple(ref tupled_arguments) => {\n-                for (i, _) in tupled_arguments.iter().enumerate() {\n-                    args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n-                }\n-            }\n-            _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n-        }\n-        args\n-    } else {\n-        args.into_iter()\n-            .map(|arg| trans_operand(fx, arg))\n-            .collect::<Vec<_>>()\n-    };\n-\n     let destination = destination\n         .as_ref()\n         .map(|&(ref place, bb)| (trans_place(fx, place), bb));\n@@ -664,6 +642,28 @@ pub fn codegen_terminator_call<'a, 'tcx: 'a>(\n         }\n     }\n \n+    // Unpack arguments tuple for closures\n+    let args = if sig.abi == Abi::RustCall {\n+        assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n+        let self_arg = trans_operand(fx, &args[0]);\n+        let pack_arg = trans_operand(fx, &args[1]);\n+        let mut args = Vec::new();\n+        args.push(self_arg);\n+        match pack_arg.layout().ty.sty {\n+            ty::Tuple(ref tupled_arguments) => {\n+                for (i, _) in tupled_arguments.iter().enumerate() {\n+                    args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n+                }\n+            }\n+            _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n+        }\n+        args\n+    } else {\n+        args.into_iter()\n+            .map(|arg| trans_operand(fx, arg))\n+            .collect::<Vec<_>>()\n+    };\n+\n     codegen_call_inner(\n         fx,\n         Some(func),"}, {"sha": "c8d8bd7a793075bcd781a080779bada0084f0016", "filename": "src/intrinsics.rs", "status": "modified", "additions": 73, "deletions": 16, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/76b89476c3aa8ae96d544684218f772223b18031/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b89476c3aa8ae96d544684218f772223b18031/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=76b89476c3aa8ae96d544684218f772223b18031", "patch": "@@ -12,11 +12,14 @@ macro_rules! intrinsic_pat {\n }\n \n macro_rules! intrinsic_arg {\n-    (c $fx:expr, $arg:ident) => {\n+    (o $fx:expr, $arg:ident) => {\n         $arg\n     };\n+    (c $fx:expr, $arg:ident) => {\n+        trans_operand($fx, $arg)\n+    };\n     (v $fx:expr, $arg:ident) => {\n-        $arg.load_scalar($fx)\n+        trans_operand($fx, $arg).load_scalar($fx)\n     };\n }\n \n@@ -40,9 +43,9 @@ macro_rules! intrinsic_match {\n                         $(\n                             intrinsic_substs!($substs, 0, $($subst),*);\n                         )?\n-                        if let [$($arg),*] = *$args {\n-                            let ($($arg),*) = (\n-                                $(intrinsic_arg!($a $fx, $arg)),*\n+                        if let [$($arg),*] = $args {\n+                            let ($($arg,)*) = (\n+                                $(intrinsic_arg!($a $fx, $arg),)*\n                             );\n                             #[warn(unused_parens, non_snake_case)]\n                             {\n@@ -67,7 +70,10 @@ macro_rules! call_intrinsic_match {\n             $(\n                 stringify!($name) => {\n                     assert!($substs.is_noop());\n-                    if let [$($arg),*] = *$args {\n+                    if let [$(ref $arg),*] = *$args {\n+                        let ($($arg,)*) = (\n+                            $(trans_operand($fx, $arg),)*\n+                        );\n                         let res = $fx.easy_call(stringify!($func), &[$($arg),*], $fx.tcx.types.$ty);\n                         $ret.write_cvalue($fx, res);\n \n@@ -120,10 +126,10 @@ fn lane_type_and_count<'tcx>(\n     fx: &FunctionCx<'_, 'tcx, impl Backend>,\n     layout: TyLayout<'tcx>,\n     intrinsic: &str,\n-) -> (TyLayout<'tcx>, usize) {\n+) -> (TyLayout<'tcx>, u32) {\n     assert!(layout.ty.is_simd());\n     let lane_count = match layout.fields {\n-        layout::FieldPlacement::Array { stride: _, count } => usize::try_from(count).unwrap(),\n+        layout::FieldPlacement::Array { stride: _, count } => u32::try_from(count).unwrap(),\n         _ => panic!(\"Non vector type {:?} passed to or returned from simd_* intrinsic {}\", layout.ty, intrinsic),\n     };\n     let lane_layout = layout.field(fx, 0);\n@@ -146,7 +152,7 @@ fn simd_for_each_lane<'tcx, B: Backend>(\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane in 0..lane_count {\n-        let lane = mir::Field::new(lane);\n+        let lane = mir::Field::new(lane.try_into().unwrap());\n         let x_lane = x.value_field(fx, lane).load_scalar(fx);\n         let y_lane = y.value_field(fx, lane).load_scalar(fx);\n \n@@ -212,7 +218,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     def_id: DefId,\n     substs: SubstsRef<'tcx>,\n-    args: Vec<CValue<'tcx>>,\n+    args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) {\n     let intrinsic = fx.tcx.item_name(def_id).as_str();\n@@ -499,7 +505,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n             let base_val = base.load_scalar(fx);\n             let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n-            ret.write_cvalue(fx, CValue::by_val(res, args[0].layout()));\n+            ret.write_cvalue(fx, CValue::by_val(res, base.layout()));\n         };\n \n         transmute, <src_ty, dst_ty> (c from) {\n@@ -807,8 +813,8 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n \n         // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n-        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, c idx) {\n-            let n: usize = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n+        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+            let n: u32 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n \n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();\n@@ -821,9 +827,60 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n \n             let total_len = lane_count * 2;\n \n-            // TODO get shuffle indices\n-            fx.tcx.sess.warn(\"simd_shuffle* not yet implemented\");\n-            crate::trap::trap_unimplemented(fx, \"simd_shuffle* not yet implemented\");\n+            let indexes = {\n+                use rustc::mir::interpret::*;\n+                let idx_place = match idx {\n+                    Operand::Copy(idx_place) => {\n+                        idx_place\n+                    }\n+                    _ => panic!(\"simd_shuffle* idx is not Operand::Copy, but {:?}\", idx),\n+                };\n+\n+                assert!(idx_place.projection.is_none());\n+                let static_ = match &idx_place.base {\n+                    PlaceBase::Static(static_) => {\n+                        static_\n+                    }\n+                    PlaceBase::Local(_) => panic!(\"simd_shuffle* idx is not constant, but a local\"),\n+                };\n+\n+                let idx_const = match &static_.kind {\n+                    StaticKind::Static(_) => unimplemented!(),\n+                    StaticKind::Promoted(promoted) => {\n+                        fx.tcx.const_eval(ParamEnv::reveal_all().and(GlobalId {\n+                            instance: fx.instance,\n+                            promoted: Some(*promoted),\n+                        })).unwrap()\n+                    }\n+                };\n+\n+                let idx_bytes = match idx_const.val {\n+                    ConstValue::ByRef { align: _, offset, alloc } => {\n+                        let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n+                        let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n+                        alloc.get_bytes(fx, ptr, size).unwrap()\n+                    }\n+                    _ => unreachable!(\"{:?}\", idx_const),\n+                };\n+\n+                (0..ret_lane_count).map(|i| {\n+                    let i = usize::try_from(i).unwrap();\n+                    let idx = rustc::mir::interpret::read_target_uint(\n+                        fx.tcx.data_layout.endian,\n+                        &idx_bytes[4*i.. 4*i + 4],\n+                    ).expect(\"read_target_uint\");\n+                    u32::try_from(idx).expect(\"try_from u32\")\n+                }).collect::<Vec<u32>>()\n+            };\n+\n+            for &idx in &indexes {\n+                assert!(idx < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n+            }\n+\n+\n+\n+            println!(\"{:?}\", indexes);\n+            unimplemented!();\n         };\n \n         simd_add, (c x, c y) {"}, {"sha": "1ffd43bb7808f6814f8cee62d656d95f241c4569", "filename": "src/llvm_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b89476c3aa8ae96d544684218f772223b18031/src%2Fllvm_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b89476c3aa8ae96d544684218f772223b18031/src%2Fllvm_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm_intrinsics.rs?ref=76b89476c3aa8ae96d544684218f772223b18031", "patch": "@@ -6,7 +6,7 @@ pub fn codegen_llvm_intrinsic_call<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     intrinsic: &str,\n     substs: SubstsRef<'tcx>,\n-    args: Vec<CValue<'tcx>>,\n+    args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) {\n     fx.tcx.sess.warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));"}]}