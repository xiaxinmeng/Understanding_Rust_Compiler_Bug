{"sha": "207d6e177ffb80c8f4bb4d49d6770be1e97177de", "node_id": "C_kwDOAAsO6NoAKDIwN2Q2ZTE3N2ZmYjgwYzhmNGJiNGQ0OWQ2NzcwYmUxZTk3MTc3ZGU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-14T17:24:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-14T17:24:43Z"}, "message": "Rollup merge of #108039 - eggyal:traverse_refcounts_via_functors, r=oli-obk\n\nRefactor refcounted structural_impls via functors\n\nThe mapping of values in refcounted types can be extracted as a functor, simplifying the implementations in the type library (whose structural folding impls now all use such functors).  This functor could also prove more generally useful elsewhere.", "tree": {"sha": "df0d96acdfc25b1552285c4b958fb3f81f182fbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df0d96acdfc25b1552285c4b958fb3f81f182fbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/207d6e177ffb80c8f4bb4d49d6770be1e97177de", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj68PbCRBK7hj4Ov3rIwAAAXQIAH3yp9cPkC+mjxobOV24hRcD\nKKkgqez3MPxpx8E+EHnve1+FfZ1F0DyX8ZBhMWqyrQwVdoBBRqFl6HAS6rzp3bvN\njXD068BB4qOU3kzRaurbf1+F+BOeeJtWBMwVU7tWfZKCtGYuQqtTL+gM/Xvf361X\n2ImM5qQneM3te++RCPOcCR3kJOM1kxPwkoYCQwJuvZIY7Gp7rR5ZFjzUuIgUpS/B\nXb9Yytsz7lMsgvs+l7kvcAbVR2qcYdoYOPA2zfU9j2NLwsn98GqcobumeYFG5Giu\nxZWePX4xnTA+hD4s7ZGw9ThFfqWqmH8xDesZSS+St2I478srJbHYGzTBx8JDxYk=\n=k78K\n-----END PGP SIGNATURE-----\n", "payload": "tree df0d96acdfc25b1552285c4b958fb3f81f182fbc\nparent edcdab08a4da70c5d306d1203d04f039193dce7d\nparent 26e3363c5166effef80aa4bd22f2ea38ecc7cbc3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676395483 +0100\ncommitter GitHub <noreply@github.com> 1676395483 +0100\n\nRollup merge of #108039 - eggyal:traverse_refcounts_via_functors, r=oli-obk\n\nRefactor refcounted structural_impls via functors\n\nThe mapping of values in refcounted types can be extracted as a functor, simplifying the implementations in the type library (whose structural folding impls now all use such functors).  This functor could also prove more generally useful elsewhere.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/207d6e177ffb80c8f4bb4d49d6770be1e97177de", "html_url": "https://github.com/rust-lang/rust/commit/207d6e177ffb80c8f4bb4d49d6770be1e97177de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/207d6e177ffb80c8f4bb4d49d6770be1e97177de/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edcdab08a4da70c5d306d1203d04f039193dce7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/edcdab08a4da70c5d306d1203d04f039193dce7d", "html_url": "https://github.com/rust-lang/rust/commit/edcdab08a4da70c5d306d1203d04f039193dce7d"}, {"sha": "26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3", "html_url": "https://github.com/rust-lang/rust/commit/26e3363c5166effef80aa4bd22f2ea38ecc7cbc3"}], "stats": {"total": 124, "additions": 55, "deletions": 69}, "files": [{"sha": "28fcf80b31beec30ecf59eb015a86c0c84f577b2", "filename": "compiler/rustc_data_structures/src/functor.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/207d6e177ffb80c8f4bb4d49d6770be1e97177de/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/207d6e177ffb80c8f4bb4d49d6770be1e97177de/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs?ref=207d6e177ffb80c8f4bb4d49d6770be1e97177de", "patch": "@@ -1,5 +1,5 @@\n use rustc_index::vec::{Idx, IndexVec};\n-use std::mem;\n+use std::{mem, rc::Rc, sync::Arc};\n \n pub trait IdFunctor: Sized {\n     type Inner;\n@@ -65,3 +65,52 @@ impl<I: Idx, T> IdFunctor for IndexVec<I, T> {\n         self.raw.try_map_id(f).map(IndexVec::from_raw)\n     }\n }\n+\n+macro_rules! rc {\n+    ($($rc:ident),+) => {$(\n+        impl<T: Clone> IdFunctor for $rc<T> {\n+            type Inner = T;\n+\n+            #[inline]\n+            fn try_map_id<F, E>(mut self, mut f: F) -> Result<Self, E>\n+            where\n+                F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n+            {\n+                // We merely want to replace the contained `T`, if at all possible,\n+                // so that we don't needlessly allocate a new `$rc` or indeed clone\n+                // the contained type.\n+                unsafe {\n+                    // First step is to ensure that we have a unique reference to\n+                    // the contained type, which `$rc::make_mut` will accomplish (by\n+                    // allocating a new `$rc` and cloning the `T` only if required).\n+                    // This is done *before* casting to `$rc<ManuallyDrop<T>>` so that\n+                    // panicking during `make_mut` does not leak the `T`.\n+                    $rc::make_mut(&mut self);\n+\n+                    // Casting to `$rc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n+                    // is `repr(transparent)`.\n+                    let ptr = $rc::into_raw(self).cast::<mem::ManuallyDrop<T>>();\n+                    let mut unique = $rc::from_raw(ptr);\n+\n+                    // Call to `$rc::make_mut` above guarantees that `unique` is the\n+                    // sole reference to the contained value, so we can avoid doing\n+                    // a checked `get_mut` here.\n+                    let slot = $rc::get_mut_unchecked(&mut unique);\n+\n+                    // Semantically move the contained type out from `unique`, fold\n+                    // it, then move the folded value back into `unique`. Should\n+                    // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n+                    // value is not re-dropped.\n+                    let owned = mem::ManuallyDrop::take(slot);\n+                    let folded = f(owned)?;\n+                    *slot = mem::ManuallyDrop::new(folded);\n+\n+                    // Cast back to `$rc<T>`.\n+                    Ok($rc::from_raw($rc::into_raw(unique).cast()))\n+                }\n+            }\n+        }\n+    )+};\n+}\n+\n+rc! { Rc, Arc }"}, {"sha": "a94e52fdfe604d35a257942067ca4befd1fa3bcf", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/207d6e177ffb80c8f4bb4d49d6770be1e97177de/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/207d6e177ffb80c8f4bb4d49d6770be1e97177de/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=207d6e177ffb80c8f4bb4d49d6770be1e97177de", "patch": "@@ -26,6 +26,7 @@\n #![feature(test)]\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n+#![feature(get_mut_unchecked)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "9db1b0fd13da4edad8d193993533a89164497174", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/207d6e177ffb80c8f4bb4d49d6770be1e97177de/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/207d6e177ffb80c8f4bb4d49d6770be1e97177de/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=207d6e177ffb80c8f4bb4d49d6770be1e97177de", "patch": "@@ -1,6 +1,5 @@\n #![feature(associated_type_defaults)]\n #![feature(fmt_helpers_for_derive)]\n-#![feature(get_mut_unchecked)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]"}, {"sha": "3ebe241042f2596e3a0fdf8d9782b106bc575e15", "filename": "compiler/rustc_type_ir/src/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 67, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/207d6e177ffb80c8f4bb4d49d6770be1e97177de/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/207d6e177ffb80c8f4bb4d49d6770be1e97177de/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs?ref=207d6e177ffb80c8f4bb4d49d6770be1e97177de", "patch": "@@ -8,7 +8,6 @@ use crate::Interner;\n use rustc_data_structures::functor::IdFunctor;\n use rustc_index::vec::{Idx, IndexVec};\n \n-use std::mem::ManuallyDrop;\n use std::ops::ControlFlow;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -98,39 +97,8 @@ EnumTypeTraversalImpl! {\n }\n \n impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Rc<T> {\n-    fn try_fold_with<F: FallibleTypeFolder<I>>(mut self, folder: &mut F) -> Result<Self, F::Error> {\n-        // We merely want to replace the contained `T`, if at all possible,\n-        // so that we don't needlessly allocate a new `Rc` or indeed clone\n-        // the contained type.\n-        unsafe {\n-            // First step is to ensure that we have a unique reference to\n-            // the contained type, which `Rc::make_mut` will accomplish (by\n-            // allocating a new `Rc` and cloning the `T` only if required).\n-            // This is done *before* casting to `Rc<ManuallyDrop<T>>` so that\n-            // panicking during `make_mut` does not leak the `T`.\n-            Rc::make_mut(&mut self);\n-\n-            // Casting to `Rc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n-            // is `repr(transparent)`.\n-            let ptr = Rc::into_raw(self).cast::<ManuallyDrop<T>>();\n-            let mut unique = Rc::from_raw(ptr);\n-\n-            // Call to `Rc::make_mut` above guarantees that `unique` is the\n-            // sole reference to the contained value, so we can avoid doing\n-            // a checked `get_mut` here.\n-            let slot = Rc::get_mut_unchecked(&mut unique);\n-\n-            // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`. Should\n-            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n-            // value is not re-dropped.\n-            let owned = ManuallyDrop::take(slot);\n-            let folded = owned.try_fold_with(folder)?;\n-            *slot = ManuallyDrop::new(folded);\n-\n-            // Cast back to `Rc<T>`.\n-            Ok(Rc::from_raw(Rc::into_raw(unique).cast()))\n-        }\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|value| value.try_fold_with(folder))\n     }\n }\n \n@@ -141,39 +109,8 @@ impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Rc<T> {\n }\n \n impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Arc<T> {\n-    fn try_fold_with<F: FallibleTypeFolder<I>>(mut self, folder: &mut F) -> Result<Self, F::Error> {\n-        // We merely want to replace the contained `T`, if at all possible,\n-        // so that we don't needlessly allocate a new `Arc` or indeed clone\n-        // the contained type.\n-        unsafe {\n-            // First step is to ensure that we have a unique reference to\n-            // the contained type, which `Arc::make_mut` will accomplish (by\n-            // allocating a new `Arc` and cloning the `T` only if required).\n-            // This is done *before* casting to `Arc<ManuallyDrop<T>>` so that\n-            // panicking during `make_mut` does not leak the `T`.\n-            Arc::make_mut(&mut self);\n-\n-            // Casting to `Arc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n-            // is `repr(transparent)`.\n-            let ptr = Arc::into_raw(self).cast::<ManuallyDrop<T>>();\n-            let mut unique = Arc::from_raw(ptr);\n-\n-            // Call to `Arc::make_mut` above guarantees that `unique` is the\n-            // sole reference to the contained value, so we can avoid doing\n-            // a checked `get_mut` here.\n-            let slot = Arc::get_mut_unchecked(&mut unique);\n-\n-            // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`. Should\n-            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n-            // value is not re-dropped.\n-            let owned = ManuallyDrop::take(slot);\n-            let folded = owned.try_fold_with(folder)?;\n-            *slot = ManuallyDrop::new(folded);\n-\n-            // Cast back to `Arc<T>`.\n-            Ok(Arc::from_raw(Arc::into_raw(unique).cast()))\n-        }\n+    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|value| value.try_fold_with(folder))\n     }\n }\n "}]}