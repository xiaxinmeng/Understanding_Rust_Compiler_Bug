{"sha": "090a968fe7680cce0d3aa8fde25a5dc48948e43e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MGE5NjhmZTc2ODBjY2UwZDNhYThmZGUyNWE1ZGM0ODk0OGU0M2U=", "commit": {"author": {"name": "Ryan Cumming", "email": "etaoins@gmail.com", "date": "2018-01-10T09:13:03Z"}, "committer": {"name": "Ryan Cumming", "email": "etaoins@gmail.com", "date": "2018-01-15T19:30:44Z"}, "message": "Only link res_init() on GNU/*nix\n\nTo workaround a bug in glibc <= 2.26 lookup_host() calls res_init()\nbased on the glibc version detected at runtime. While this avoids\ncalling res_init() on platforms where it's not required we will still\nend up linking against the symbol.\n\nThis causes an issue on macOS where res_init() is implemented in a\nseparate library (libresolv.9.dylib) from the main libc. While this is\nharmless for standalone programs it becomes a problem if Rust code is\nstatically linked against another program. If the linked program doesn't\nalready specify -lresolv it will cause the link to fail. This is\ncaptured in issue #46797\n\nFix this by hooking in to the glibc workaround in `cvt_gai` and only\nactivating it for the \"gnu\" environment on Unix This should include all\nglibc platforms while excluding musl, windows-gnu, macOS, FreeBSD, etc.\n\nThis has the side benefit of removing the #[cfg] in sys_common; only\nunix.rs has code related to the workaround now.", "tree": {"sha": "6cb438656baf3111f840ff1a6ca405453da10bf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cb438656baf3111f840ff1a6ca405453da10bf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/090a968fe7680cce0d3aa8fde25a5dc48948e43e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/090a968fe7680cce0d3aa8fde25a5dc48948e43e", "html_url": "https://github.com/rust-lang/rust/commit/090a968fe7680cce0d3aa8fde25a5dc48948e43e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/090a968fe7680cce0d3aa8fde25a5dc48948e43e/comments", "author": {"login": "etaoins", "id": 687534, "node_id": "MDQ6VXNlcjY4NzUzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/687534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/etaoins", "html_url": "https://github.com/etaoins", "followers_url": "https://api.github.com/users/etaoins/followers", "following_url": "https://api.github.com/users/etaoins/following{/other_user}", "gists_url": "https://api.github.com/users/etaoins/gists{/gist_id}", "starred_url": "https://api.github.com/users/etaoins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/etaoins/subscriptions", "organizations_url": "https://api.github.com/users/etaoins/orgs", "repos_url": "https://api.github.com/users/etaoins/repos", "events_url": "https://api.github.com/users/etaoins/events{/privacy}", "received_events_url": "https://api.github.com/users/etaoins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "etaoins", "id": 687534, "node_id": "MDQ6VXNlcjY4NzUzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/687534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/etaoins", "html_url": "https://github.com/etaoins", "followers_url": "https://api.github.com/users/etaoins/followers", "following_url": "https://api.github.com/users/etaoins/following{/other_user}", "gists_url": "https://api.github.com/users/etaoins/gists{/gist_id}", "starred_url": "https://api.github.com/users/etaoins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/etaoins/subscriptions", "organizations_url": "https://api.github.com/users/etaoins/orgs", "repos_url": "https://api.github.com/users/etaoins/repos", "events_url": "https://api.github.com/users/etaoins/events{/privacy}", "received_events_url": "https://api.github.com/users/etaoins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ff449d505728276e822ca9a80c1e7b2da8288a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff449d505728276e822ca9a80c1e7b2da8288a2", "html_url": "https://github.com/rust-lang/rust/commit/8ff449d505728276e822ca9a80c1e7b2da8288a2"}], "stats": {"total": 48, "additions": 16, "deletions": 32}, "files": [{"sha": "21218489679393a92a655bf0012caa5ad242f962", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/090a968fe7680cce0d3aa8fde25a5dc48948e43e/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090a968fe7680cce0d3aa8fde25a5dc48948e43e/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=090a968fe7680cce0d3aa8fde25a5dc48948e43e", "patch": "@@ -437,9 +437,5 @@ pub mod net {\n     pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n         unimpl!();\n     }\n-\n-    pub fn res_init_if_glibc_before_2_26() -> io::Result<()> {\n-        unimpl!();\n-    }\n }\n "}, {"sha": "3f65975e608800a7198d6c36bb84832e4a437a62", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/090a968fe7680cce0d3aa8fde25a5dc48948e43e/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090a968fe7680cce0d3aa8fde25a5dc48948e43e/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=090a968fe7680cce0d3aa8fde25a5dc48948e43e", "patch": "@@ -51,6 +51,10 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 {\n         return Ok(())\n     }\n+\n+    // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n+    on_resolver_failure();\n+\n     if err == EAI_SYSTEM {\n         return Err(io::Error::last_os_error())\n     }\n@@ -377,21 +381,22 @@ impl IntoInner<c_int> for Socket {\n // res_init unconditionally, we call it only when we detect we're linking\n // against glibc version < 2.26. (That is, when we both know its needed and\n // believe it's thread-safe).\n-pub fn res_init_if_glibc_before_2_26() -> io::Result<()> {\n+#[cfg(target_env = \"gnu\")]\n+fn on_resolver_failure() {\n     // If the version fails to parse, we treat it the same as \"not glibc\".\n     if let Some(Ok(version_str)) = glibc_version_cstr().map(CStr::to_str) {\n         if let Some(version) = parse_glibc_version(version_str) {\n             if version < (2, 26) {\n-                let ret = unsafe { libc::res_init() };\n-                if ret != 0 {\n-                    return Err(io::Error::last_os_error());\n-                }\n+                unsafe { libc::res_init() };\n             }\n         }\n     }\n-    Ok(())\n }\n \n+#[cfg(not(target_env = \"gnu\"))]\n+fn on_resolver_failure() {}\n+\n+#[cfg(target_env = \"gnu\")]\n fn glibc_version_cstr() -> Option<&'static CStr> {\n     weak! {\n         fn gnu_get_libc_version() -> *const libc::c_char\n@@ -405,6 +410,7 @@ fn glibc_version_cstr() -> Option<&'static CStr> {\n \n // Returns Some((major, minor)) if the string is a valid \"x.y\" version,\n // ignoring any extra dot-separated parts. Otherwise return None.\n+#[cfg(target_env = \"gnu\")]\n fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n     let mut parsed_ints = version.split(\".\").map(str::parse::<usize>).fuse();\n     match (parsed_ints.next(), parsed_ints.next()) {\n@@ -413,7 +419,7 @@ fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, taget_env = \"gnu\"))]\n mod test {\n     use super::*;\n "}, {"sha": "b841afe1a5141dfd2db749ad09077400c8cc1933", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/090a968fe7680cce0d3aa8fde25a5dc48948e43e/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/090a968fe7680cce0d3aa8fde25a5dc48948e43e/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=090a968fe7680cce0d3aa8fde25a5dc48948e43e", "patch": "@@ -166,27 +166,9 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     hints.ai_socktype = c::SOCK_STREAM;\n     let mut res = ptr::null_mut();\n     unsafe {\n-        match cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)) {\n-            Ok(_) => {\n-                Ok(LookupHost { original: res, cur: res })\n-            },\n-            #[cfg(unix)]\n-            Err(e) => {\n-                // If we're running glibc prior to version 2.26, the lookup\n-                // failure could be caused by caching a stale /etc/resolv.conf.\n-                // We need to call libc::res_init() to clear the cache. But we\n-                // shouldn't call it in on any other platform, because other\n-                // res_init implementations aren't thread-safe. See\n-                // https://github.com/rust-lang/rust/issues/41570 and\n-                // https://github.com/rust-lang/rust/issues/43592.\n-                use sys::net::res_init_if_glibc_before_2_26;\n-                let _ = res_init_if_glibc_before_2_26();\n-                Err(e)\n-            },\n-            // the cfg is needed here to avoid an \"unreachable pattern\" warning\n-            #[cfg(not(unix))]\n-            Err(e) => Err(e),\n-        }\n+        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)).map(|_| {\n+            LookupHost { original: res, cur: res }\n+        })\n     }\n }\n "}]}