{"sha": "5521a757077df87667b3c131119ad827ccf80ee8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MjFhNzU3MDc3ZGY4NzY2N2IzYzEzMTExOWFkODI3Y2NmODBlZTg=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-13T21:19:36Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-13T21:19:36Z"}, "message": "Merge pull request #654 from mcarton/new\n\nLints about `new` methods", "tree": {"sha": "7192dce7948d6c3984a6b20992ca6008b0b3f6c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7192dce7948d6c3984a6b20992ca6008b0b3f6c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5521a757077df87667b3c131119ad827ccf80ee8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5521a757077df87667b3c131119ad827ccf80ee8", "html_url": "https://github.com/rust-lang/rust/commit/5521a757077df87667b3c131119ad827ccf80ee8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5521a757077df87667b3c131119ad827ccf80ee8/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed60e419174791eb797254f5c983ac5de0e38850", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed60e419174791eb797254f5c983ac5de0e38850", "html_url": "https://github.com/rust-lang/rust/commit/ed60e419174791eb797254f5c983ac5de0e38850"}, {"sha": "e8c2aa2997861c745c01c837aa14eec24627f584", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c2aa2997861c745c01c837aa14eec24627f584", "html_url": "https://github.com/rust-lang/rust/commit/e8c2aa2997861c745c01c837aa14eec24627f584"}], "stats": {"total": 182, "additions": 123, "deletions": 59}, "files": [{"sha": "483182a68f67ad574b4f7ddb1c04ab6d738741a9", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5521a757077df87667b3c131119ad827ccf80ee8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5521a757077df87667b3c131119ad827ccf80ee8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5521a757077df87667b3c131119ad827ccf80ee8", "patch": "@@ -8,7 +8,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 120 lints included in this crate:\n+There are 121 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -78,6 +78,7 @@ name\n [needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)                     | warn    | for-looping over a range of indices where an iterator over items would do\n [needless_return](https://github.com/Manishearth/rust-clippy/wiki#needless_return)                             | warn    | using a return statement like `return expr;` where an expression would suffice\n [needless_update](https://github.com/Manishearth/rust-clippy/wiki#needless_update)                             | warn    | using `{ ..base }` when there are no missing fields\n+[new_ret_no_self](https://github.com/Manishearth/rust-clippy/wiki#new_ret_no_self)                             | warn    | not returning `Self` in a `new` method\n [no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                         | warn    | statements with no effect\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                         | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)           | warn    | nonsensical combination of options for opening a file"}, {"sha": "8d29d6ab68aa6822136be7639afe73c692f70542", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5521a757077df87667b3c131119ad827ccf80ee8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5521a757077df87667b3c131119ad827ccf80ee8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5521a757077df87667b3c131119ad827ccf80ee8", "patch": "@@ -234,6 +234,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::CLONE_ON_COPY,\n         methods::EXTEND_FROM_SLICE,\n         methods::FILTER_NEXT,\n+        methods::NEW_RET_NO_SELF,\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_UNWRAP_OR,\n         methods::OPTION_MAP_UNWRAP_OR_ELSE,"}, {"sha": "ed3f61e4a727297720932b7e1b4e84ea70a68e52", "filename": "src/methods.rs", "status": "modified", "additions": 106, "deletions": 55, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/5521a757077df87667b3c131119ad827ccf80ee8/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5521a757077df87667b3c131119ad827ccf80ee8/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=5521a757077df87667b3c131119ad827ccf80ee8", "patch": "@@ -1,11 +1,11 @@\n-use rustc_front::hir::*;\n use rustc::lint::*;\n-use rustc::middle::ty;\n use rustc::middle::subst::{Subst, TypeSpace};\n-use std::iter;\n+use rustc::middle::ty;\n+use rustc_front::hir::*;\n use std::borrow::Cow;\n-use syntax::ptr::P;\n+use std::{fmt, iter};\n use syntax::codemap::Span;\n+use syntax::ptr::P;\n \n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n             match_type, method_chain_args, snippet, snippet_opt, span_lint, span_lint_and_then, span_note_and_lint,\n@@ -274,11 +274,27 @@ declare_lint! {\n ///    println!(\"{:p} {:p}\",*y, z); // prints out the same pointer\n /// }\n /// ```\n-/// \n declare_lint! {\n     pub CLONE_DOUBLE_REF, Warn, \"using `clone` on `&&T`\"\n }\n \n+/// **What it does:** This lint warns about `new` not returning `Self`.\n+///\n+/// **Why is this bad?** As a convention, `new` methods are used to make a new instance of a type.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// impl Foo {\n+///     fn new(..) -> NotAFoo {\n+///     }\n+/// }\n+/// ```\n+declare_lint! {\n+    pub NEW_RET_NO_SELF, Warn, \"not returning `Self` in a `new` method\"\n+}\n+\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(EXTEND_FROM_SLICE,\n@@ -295,7 +311,8 @@ impl LintPass for MethodsPass {\n                     OR_FUN_CALL,\n                     CHARS_NEXT_CMP,\n                     CLONE_ON_COPY,\n-                    CLONE_DOUBLE_REF)\n+                    CLONE_DOUBLE_REF,\n+                    NEW_RET_NO_SELF)\n     }\n }\n \n@@ -368,10 +385,11 @@ impl LateLintPass for MethodsPass {\n                             }\n                         }\n                     }\n+\n                     // check conventions w.r.t. conversion method names and predicates\n                     let is_copy = is_copy(cx, &ty, &item);\n-                    for &(prefix, self_kinds) in &CONVENTIONS {\n-                        if name.as_str().starts_with(prefix) &&\n+                    for &(ref conv, self_kinds) in &CONVENTIONS {\n+                        if conv.check(&name.as_str()) &&\n                            !self_kinds.iter().any(|k| k.matches(&sig.explicit_self.node, is_copy)) {\n                             let lint = if item.vis == Visibility::Public {\n                                 WRONG_PUB_SELF_CONVENTION\n@@ -381,15 +399,38 @@ impl LateLintPass for MethodsPass {\n                             span_lint(cx,\n                                       lint,\n                                       sig.explicit_self.span,\n-                                      &format!(\"methods called `{}*` usually take {}; consider choosing a less \\\n+                                      &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n                                                 ambiguous name\",\n-                                               prefix,\n+                                               conv,\n                                                &self_kinds.iter()\n                                                           .map(|k| k.description())\n                                                           .collect::<Vec<_>>()\n                                                           .join(\" or \")));\n                         }\n                     }\n+\n+                    if &name.as_str() == &\"new\" {\n+                        let returns_self = if let FunctionRetTy::Return(ref ret_ty) = sig.decl.output {\n+                            let ast_ty_to_ty_cache = cx.tcx.ast_ty_to_ty_cache.borrow();\n+                            let ty = ast_ty_to_ty_cache.get(&ty.id);\n+                            let ret_ty = ast_ty_to_ty_cache.get(&ret_ty.id);\n+\n+                            match (ty, ret_ty) {\n+                                (Some(&ty), Some(&ret_ty)) => ret_ty.walk().any(|t| t == ty),\n+                                _ => false,\n+                            }\n+                        }\n+                        else {\n+                            false\n+                        };\n+\n+                        if !returns_self {\n+                            span_lint(cx,\n+                                      NEW_RET_NO_SELF,\n+                                      sig.explicit_self.span,\n+                                      \"methods called `new` usually return `Self`\");\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -789,69 +830,61 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     None\n }\n \n-/// This checks whether a given type is known to implement Debug. It's\n-/// conservative, i.e. it should not return false positives, but will return\n-/// false negatives.\n+/// This checks whether a given type is known to implement Debug.\n fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n-    let no_ref_ty = walk_ptrs_ty(ty);\n-    let debug = match cx.tcx.lang_items.debug_trait() {\n-        Some(debug) => debug,\n-        None => return false,\n-    };\n-    let debug_def = cx.tcx.lookup_trait_def(debug);\n-    let mut debug_impl_exists = false;\n-    debug_def.for_each_relevant_impl(cx.tcx, no_ref_ty, |d| {\n-        let self_ty = &cx.tcx.impl_trait_ref(d).and_then(|im| im.substs.self_ty());\n-        if let Some(self_ty) = *self_ty {\n-            if !self_ty.flags.get().contains(ty::TypeFlags::HAS_PARAMS) {\n-                debug_impl_exists = true;\n-            }\n-        }\n-    });\n-    debug_impl_exists\n+    match cx.tcx.lang_items.debug_trait() {\n+        Some(debug) => implements_trait(cx, ty, debug, Some(vec![])),\n+        None => false,\n+    }\n+}\n+\n+enum Convention {\n+    Eq(&'static str),\n+    StartsWith(&'static str),\n }\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n-const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [\n-    (\"into_\", &[SelfKind::Value]),\n-    (\"to_\", &[SelfKind::Ref]),\n-    (\"as_\", &[SelfKind::Ref, SelfKind::RefMut]),\n-    (\"is_\", &[SelfKind::Ref, SelfKind::No]),\n-    (\"from_\", &[SelfKind::No]),\n+const CONVENTIONS: [(Convention, &'static [SelfKind]); 6] = [\n+    (Convention::Eq(\"new\"), &[SelfKind::No]),\n+    (Convention::StartsWith(\"as_\"), &[SelfKind::Ref, SelfKind::RefMut]),\n+    (Convention::StartsWith(\"from_\"), &[SelfKind::No]),\n+    (Convention::StartsWith(\"into_\"), &[SelfKind::Value]),\n+    (Convention::StartsWith(\"is_\"), &[SelfKind::Ref, SelfKind::No]),\n+    (Convention::StartsWith(\"to_\"), &[SelfKind::Ref]),\n ];\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [\n     (\"add\", 2, SelfKind::Value, OutType::Any, \"std::ops::Add\"),\n-    (\"sub\", 2, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n-    (\"mul\", 2, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n-    (\"div\", 2, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n-    (\"rem\", 2, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n-    (\"shl\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n-    (\"shr\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n+    (\"as_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n+    (\"as_ref\", 1, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n     (\"bitand\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitAnd\"),\n     (\"bitor\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitOr\"),\n     (\"bitxor\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitXor\"),\n-    (\"neg\", 1, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n-    (\"not\", 1, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n-    (\"drop\", 1, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n-    (\"index\", 2, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n-    (\"index_mut\", 2, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n-    (\"deref\", 1, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n-    (\"deref_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n-    (\"clone\", 1, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n     (\"borrow\", 1, SelfKind::Ref, OutType::Ref, \"std::borrow::Borrow\"),\n     (\"borrow_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n-    (\"as_ref\", 1, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n-    (\"as_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n-    (\"eq\", 2, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n+    (\"clone\", 1, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n     (\"cmp\", 2, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n     (\"default\", 0, SelfKind::No, OutType::Any, \"std::default::Default\"),\n-    (\"hash\", 2, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n-    (\"next\", 1, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n-    (\"into_iter\", 1, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n+    (\"deref\", 1, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n+    (\"deref_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n+    (\"div\", 2, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n+    (\"drop\", 1, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n+    (\"eq\", 2, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n     (\"from_iter\", 1, SelfKind::No, OutType::Any, \"std::iter::FromIterator\"),\n     (\"from_str\", 1, SelfKind::No, OutType::Any, \"std::str::FromStr\"),\n+    (\"hash\", 2, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n+    (\"index\", 2, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n+    (\"index_mut\", 2, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n+    (\"into_iter\", 1, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n+    (\"mul\", 2, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n+    (\"neg\", 1, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n+    (\"next\", 1, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n+    (\"not\", 1, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n+    (\"rem\", 2, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n+    (\"shl\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n+    (\"shr\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n+    (\"sub\", 2, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n ];\n \n #[derive(Clone, Copy)]\n@@ -896,6 +929,24 @@ impl SelfKind {\n     }\n }\n \n+impl Convention {\n+    fn check(&self, other: &str) -> bool {\n+        match *self {\n+            Convention::Eq(this) => this == other,\n+            Convention::StartsWith(this) => other.starts_with(this),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Convention {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        match *self {\n+            Convention::Eq(this) => this.fmt(f),\n+            Convention::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy)]\n enum OutType {\n     Unit,"}, {"sha": "afe056e3d05fabe01472fae36e2b3acfb812462b", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5521a757077df87667b3c131119ad827ccf80ee8/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5521a757077df87667b3c131119ad827ccf80ee8/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=5521a757077df87667b3c131119ad827ccf80ee8", "patch": "@@ -22,15 +22,28 @@ impl T {\n     fn into_u16(&self) -> u16 { 0 } //~ERROR methods called `into_*` usually take self by value\n \n     fn to_something(self) -> u32 { 0 } //~ERROR methods called `to_*` usually take self by reference\n+\n+    fn new(self) {}\n+    //~^ ERROR methods called `new` usually take no self\n+    //~| ERROR methods called `new` usually return `Self`\n }\n \n #[derive(Clone,Copy)]\n struct U;\n \n impl U {\n+    fn new() -> Self { U }\n     fn to_something(self) -> u32 { 0 } // ok because U is Copy\n }\n \n+struct V<T> {\n+    _dummy: T\n+}\n+\n+impl<T> V<T> {\n+    fn new() -> Option<V<T>> { None }\n+}\n+\n impl Mul<T> for T {\n     type Output = T;\n     fn mul(self, other: T) -> T { self } // no error, obviously\n@@ -274,10 +287,8 @@ fn main() {\n     // the error type implements `Debug`\n     let res2: Result<i32, MyError> = Ok(0);\n     res2.ok().expect(\"oh noes!\");\n-    // we currently don't warn if the error type has a type parameter\n-    // (but it would be nice if we did)\n     let res3: Result<u32, MyErrorWithParam<u8>>= Ok(0);\n-    res3.ok().expect(\"whoof\");\n+    res3.ok().expect(\"whoof\"); //~ERROR called `ok().expect()`\n     let res4: Result<u32, io::Error> = Ok(0);\n     res4.ok().expect(\"argh\"); //~ERROR called `ok().expect()`\n     let res5: io::Result<u32> = Ok(0);"}]}