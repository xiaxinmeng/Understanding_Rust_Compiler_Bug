{"sha": "4b79a58d9d30c09366e562691d50182b335aef6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNzlhNThkOWQzMGMwOTM2NmU1NjI2OTFkNTAxODJiMzM1YWVmNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-06T17:27:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-06T17:27:59Z"}, "message": "auto merge of #5252 : nikomatsakis/rust/issue-5087-make-trait-not-impl-self, r=pcwalton\n\nTwo changes:\r\n\r\n- The first fixes an inconsistency in coherence whereby extension methods were added to the inherent methods table, but only in cross-crate scenarios.  This causes some minor fallout in tests and so forth.  In one case (comm) I added inherent and trait methods so as to avoid the need to import traits like `GenericPort` just to use a port.\r\n\r\n- The second makes objects not implement the associated trait, as discussed in #5087.\r\n\r\nr? @pcwalton", "tree": {"sha": "6f58a75d27b074adabf091f77e4680888d2a9ff0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f58a75d27b074adabf091f77e4680888d2a9ff0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b79a58d9d30c09366e562691d50182b335aef6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b79a58d9d30c09366e562691d50182b335aef6e", "html_url": "https://github.com/rust-lang/rust/commit/4b79a58d9d30c09366e562691d50182b335aef6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b79a58d9d30c09366e562691d50182b335aef6e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67100ddb3519dedf8ab07371a381c7762f9fcc4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/67100ddb3519dedf8ab07371a381c7762f9fcc4f", "html_url": "https://github.com/rust-lang/rust/commit/67100ddb3519dedf8ab07371a381c7762f9fcc4f"}, {"sha": "5653fe666dcf35f1139f1b561288fd925d593783", "url": "https://api.github.com/repos/rust-lang/rust/commits/5653fe666dcf35f1139f1b561288fd925d593783", "html_url": "https://github.com/rust-lang/rust/commit/5653fe666dcf35f1139f1b561288fd925d593783"}], "stats": {"total": 764, "additions": 344, "deletions": 420}, "files": [{"sha": "18e049789445a181bebea5dc5e81ac3fb1efcdc9", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 150, "deletions": 88, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -104,64 +104,98 @@ pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     (Port_(Port_ { endp: Some(s) }), Chan_(Chan_{ endp: Some(c) }))\n }\n \n+// Add an inherent method so that imports of GenericChan are not\n+// required.\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T: Owned> Chan<T> {\n+    fn send(&self, x: T) { chan_send(self, x) }\n+    fn try_send(&self, x: T) -> bool { chan_try_send(self, x) }\n+}\n+\n impl<T: Owned> GenericChan<T> for Chan<T> {\n-    fn send(&self, x: T) {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        self.endp = Some(\n-            streamp::client::data(unwrap(endp), x))\n-    }\n+    fn send(&self, x: T) { chan_send(self, x) }\n }\n \n-impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+#[inline(always)]\n+fn chan_send<T:Owned>(self: &Chan<T>, x: T) {\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    self.endp = Some(\n+        streamp::client::data(unwrap(endp), x))\n+}\n \n+impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n     fn try_send(&self, x: T) -> bool {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        match streamp::client::try_data(unwrap(endp), x) {\n-            Some(next) => {\n-                self.endp = Some(next);\n-                true\n-            }\n-            None => false\n-        }\n+        chan_try_send(self, x)\n     }\n }\n \n-impl<T: Owned> GenericPort<T> for Port<T> {\n-    fn recv(&self) -> T {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        let streamp::data(x, endp) = recv(unwrap(endp));\n-        self.endp = Some(endp);\n-        x\n+#[inline(always)]\n+fn chan_try_send<T:Owned>(self: &Chan<T>, x: T) -> bool {\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    match streamp::client::try_data(unwrap(endp), x) {\n+        Some(next) => {\n+            self.endp = Some(next);\n+            true\n+        }\n+        None => false\n     }\n+}\n \n-    fn try_recv(&self) -> Option<T> {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        match try_recv(unwrap(endp)) {\n-          Some(streamp::data(x, endp)) => {\n+// Use an inherent impl so that imports are not required:\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T: Owned> Port<T> {\n+    fn recv(&self) -> T { port_recv(self) }\n+    fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n+    pure fn peek(&self) -> bool { port_peek(self) }\n+}\n+\n+impl<T: Owned> GenericPort<T> for Port<T> {\n+    // These two calls will prefer the inherent versions above:\n+    fn recv(&self) -> T { port_recv(self) }\n+    fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n+}\n+\n+#[inline(always)]\n+fn port_recv<T:Owned>(self: &Port<T>) -> T {\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    let streamp::data(x, endp) = recv(unwrap(endp));\n+    self.endp = Some(endp);\n+    x\n+}\n+\n+#[inline(always)]\n+fn port_try_recv<T:Owned>(self: &Port<T>) -> Option<T> {\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    match try_recv(unwrap(endp)) {\n+        Some(streamp::data(x, endp)) => {\n             self.endp = Some(endp);\n             Some(x)\n-          }\n-          None => None\n         }\n+        None => None\n     }\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    pure fn peek(&self) -> bool {\n-        unsafe {\n-            let mut endp = None;\n-            endp <-> self.endp;\n-            let peek = match &endp {\n-              &Some(ref endp) => peek(endp),\n-              &None => fail!(~\"peeking empty stream\")\n-            };\n-            self.endp <-> endp;\n-            peek\n-        }\n+    pure fn peek(&self) -> bool { port_peek(self) }\n+}\n+\n+#[inline(always)]\n+pure fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n+    unsafe {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        let peek = match &endp {\n+            &Some(ref endp) => peek(endp),\n+            &None => fail!(~\"peeking empty stream\")\n+        };\n+        self.endp <-> endp;\n+        peek\n     }\n }\n \n@@ -187,8 +221,16 @@ pub fn PortSet<T: Owned>() -> PortSet<T>{\n     }\n }\n \n-pub impl<T: Owned> PortSet<T> {\n+// Use an inherent impl so that imports are not required:\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T:Owned> PortSet<T> {\n+    fn recv(&self) -> T { port_set_recv(self) }\n+    fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n+    pure fn peek(&self) -> bool { port_set_peek(self) }\n+}\n \n+pub impl<T: Owned> PortSet<T> {\n     fn add(&self, port: Port<T>) {\n         self.ports.push(port)\n     }\n@@ -200,69 +242,89 @@ pub impl<T: Owned> PortSet<T> {\n     }\n }\n \n-impl<T: Owned> GenericPort<T> for PortSet<T> {\n-\n-    fn try_recv(&self) -> Option<T> {\n-        let mut result = None;\n-        // we have to swap the ports array so we aren't borrowing\n-        // aliasable mutable memory.\n-        let mut ports = ~[];\n-        ports <-> self.ports;\n-        while result.is_none() && ports.len() > 0 {\n-            let i = wait_many(ports);\n-            match ports[i].try_recv() {\n-                Some(m) => {\n-                  result = Some(m);\n-                }\n-                None => {\n-                    // Remove this port.\n-                    let _ = ports.swap_remove(i);\n-                }\n+impl<T:Owned> GenericPort<T> for PortSet<T> {\n+    fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n+    fn recv(&self) -> T { port_set_recv(self) }\n+}\n+\n+#[inline(always)]\n+fn port_set_recv<T:Owned>(self: &PortSet<T>) -> T {\n+    port_set_try_recv(self).expect(\"port_set: endpoints closed\")\n+}\n+\n+#[inline(always)]\n+fn port_set_try_recv<T:Owned>(self: &PortSet<T>) -> Option<T> {\n+    let mut result = None;\n+    // we have to swap the ports array so we aren't borrowing\n+    // aliasable mutable memory.\n+    let mut ports = ~[];\n+    ports <-> self.ports;\n+    while result.is_none() && ports.len() > 0 {\n+        let i = wait_many(ports);\n+        match ports[i].try_recv() {\n+            Some(m) => {\n+                result = Some(m);\n+            }\n+            None => {\n+                // Remove this port.\n+                let _ = ports.swap_remove(i);\n             }\n         }\n-        ports <-> self.ports;\n-        result\n     }\n-\n-    fn recv(&self) -> T {\n-        self.try_recv().expect(\"port_set: endpoints closed\")\n-    }\n-\n+    ports <-> self.ports;\n+    result\n }\n \n impl<T: Owned> Peekable<T> for PortSet<T> {\n-    pure fn peek(&self) -> bool {\n-        // It'd be nice to use self.port.each, but that version isn't\n-        // pure.\n-        for vec::each(self.ports) |p| {\n-            if p.peek() { return true }\n-        }\n-        false\n+    pure fn peek(&self) -> bool { port_set_peek(self) }\n+}\n+\n+#[inline(always)]\n+pure fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n+    // It'd be nice to use self.port.each, but that version isn't\n+    // pure.\n+    for vec::each(self.ports) |p| {\n+        if p.peek() { return true }\n     }\n+    false\n }\n \n+\n /// A channel that can be shared between many senders.\n pub type SharedChan<T> = unstable::Exclusive<Chan<T>>;\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T: Owned> SharedChan<T> {\n+    fn send(&self, x: T) { shared_chan_send(self, x) }\n+    fn try_send(&self, x: T) -> bool { shared_chan_try_send(self, x) }\n+}\n+\n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, x: T) {\n-        let mut xx = Some(x);\n-        do self.with_imm |chan| {\n-            let mut x = None;\n-            x <-> xx;\n-            chan.send(option::unwrap(x))\n-        }\n+    fn send(&self, x: T) { shared_chan_send(self, x) }\n+}\n+\n+#[inline(always)]\n+fn shared_chan_send<T:Owned>(self: &SharedChan<T>, x: T) {\n+    let mut xx = Some(x);\n+    do self.with_imm |chan| {\n+        let mut x = None;\n+        x <-> xx;\n+        chan.send(option::unwrap(x))\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, x: T) -> bool {\n-        let mut xx = Some(x);\n-        do self.with_imm |chan| {\n-            let mut x = None;\n-            x <-> xx;\n-            chan.try_send(option::unwrap(x))\n-        }\n+    fn try_send(&self, x: T) -> bool { shared_chan_try_send(self, x) }\n+}\n+\n+#[inline(always)]\n+fn shared_chan_try_send<T:Owned>(self: &SharedChan<T>, x: T) -> bool {\n+    let mut xx = Some(x);\n+    do self.with_imm |chan| {\n+        let mut x = None;\n+        x <-> xx;\n+        chan.try_send(option::unwrap(x))\n     }\n }\n "}, {"sha": "65879f88a5dad63dae45bd2c6f8d24cb2b0488b2", "filename": "src/libcore/io.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -69,6 +69,26 @@ pub trait Reader {\n     fn tell(&self) -> uint;\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Reader for @Reader {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n+        self.read(bytes, len)\n+    }\n+    fn read_byte(&self) -> int {\n+        self.read_byte()\n+    }\n+    fn eof(&self) -> bool {\n+        self.eof()\n+    }\n+    fn seek(&self, position: int, style: SeekStyle) {\n+        self.seek(position, style)\n+    }\n+    fn tell(&self) -> uint {\n+        self.tell()\n+    }\n+}\n+\n /// Generic utility functions defined on readers.\n pub trait ReaderUtil {\n \n@@ -631,6 +651,16 @@ pub trait Writer {\n     fn get_type(&self) -> WriterType;\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl Writer for @Writer {\n+    fn write(&self, v: &[const u8]) { self.write(v) }\n+    fn seek(&self, a: int, b: SeekStyle) { self.seek(a, b) }\n+    fn tell(&self) -> uint { self.tell() }\n+    fn flush(&self) -> int { self.flush() }\n+    fn get_type(&self) -> WriterType { self.get_type() }\n+}\n+\n impl<W:Writer,C> Writer for Wrapper<W, C> {\n     fn write(&self, bs: &[const u8]) { self.base.write(bs); }\n     fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n@@ -1067,8 +1097,8 @@ pub fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n // FIXME (#2004) it would be great if this could be a const\n // FIXME (#2004) why are these different from the way stdin() is\n // implemented?\n-pub fn stdout() -> Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n-pub fn stderr() -> Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n+pub fn stdout() -> @Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n+pub fn stderr() -> @Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n pub fn print(s: &str) { stdout().write_str(s); }\n pub fn println(s: &str) { stdout().write_line(s); }"}, {"sha": "8e74ec1dc4cb3904f039fefa8006007c05d22994", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -23,6 +23,7 @@ use middle::ty;\n use util::ppaux;\n \n use core::char;\n+use core::hash::Streaming;\n use core::hash;\n use core::io::{Writer, WriterUtil};\n use core::libc::{c_int, c_uint, c_char};"}, {"sha": "2c9a824471cee1c3bf56837d9d71853c727c28b3", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -26,7 +26,7 @@ use core::dvec;\n use core::flate;\n use core::hash::{Hash, HashUtil};\n use core::int;\n-use core::io::WriterUtil;\n+use core::io::{Writer, WriterUtil};\n use core::io;\n use core::str;\n use core::to_bytes::IterBytes;"}, {"sha": "e418aa35e1e861e69d2adbda6eafb73b05c84695", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -29,10 +29,11 @@ use core::{dvec, io, option, vec};\n use std::ebml::reader;\n use std::ebml;\n use std::serialize;\n-use std::serialize::{Encodable, EncoderHelpers, DecoderHelpers};\n-use std::serialize::Decodable;\n+use std::serialize::{Encoder, Encodable, EncoderHelpers, DecoderHelpers};\n+use std::serialize::{Decoder, Decodable};\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util::inlined_item_utils;\n use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n@@ -663,16 +664,6 @@ fn encode_vtable_origin(ecx: @e::EncodeContext,\n                 }\n             }\n           }\n-          typeck::vtable_trait(def_id, tys) => {\n-            do ebml_w.emit_enum_variant(~\"vtable_trait\", 1u, 3u) {\n-                do ebml_w.emit_enum_variant_arg(0u) {\n-                    ebml_w.emit_def_id(def_id)\n-                }\n-                do ebml_w.emit_enum_variant_arg(1u) {\n-                    ebml_w.emit_tys(ecx, /*bad*/copy tys);\n-                }\n-            }\n-          }\n         }\n     }\n \n@@ -719,16 +710,6 @@ impl vtable_decoder_helpers for reader::Decoder {\n                         }\n                     )\n                   }\n-                  2 => {\n-                    typeck::vtable_trait(\n-                        do self.read_enum_variant_arg(0u) {\n-                            self.read_def_id(xcx)\n-                        },\n-                        do self.read_enum_variant_arg(1u) {\n-                            self.read_tys(xcx)\n-                        }\n-                    )\n-                  }\n                   // hard to avoid - user input\n                   _ => fail!(~\"bad enum variant\")\n                 }"}, {"sha": "33b52c6e6b6ca9edd3a391a9a5dab3f276ca19b8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -1405,7 +1405,6 @@ pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n                 }\n             }\n         }\n-        vt => vt\n     }\n }\n "}, {"sha": "2f4e8d715e0a000f8296f658e501eb3bf33cf1b0", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -478,14 +478,6 @@ pub fn trans_monomorphized_callee(bcx: block,\n               })\n           }\n       }\n-      typeck::vtable_trait(_, _) => {\n-          trans_trait_callee(bcx,\n-                             callee_id,\n-                             n_method,\n-                             base,\n-                             ty::vstore_box,\n-                             mentry.explicit_self)\n-      }\n       typeck::vtable_param(*) => {\n           fail!(~\"vtable_param left in monomorphized function's \" +\n               \"vtable substs\");\n@@ -756,13 +748,7 @@ pub fn vtable_id(ccx: @CrateContext,\n                 None,\n                 None)\n         }\n-        typeck::vtable_trait(trait_id, substs) => {\n-            @mono_id_ {\n-                def: trait_id,\n-                params: vec::map(substs, |t| mono_precise(*t, None)),\n-                impl_did_opt: None\n-            }\n-        }\n+\n         // can't this be checked at the callee?\n         _ => fail!(~\"vtable_id\")\n     }"}, {"sha": "5d0b3f948e2d20236e485f954bf3320fbbc2d7ec", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -30,7 +30,7 @@ itself (note that inherent impls can only be defined in the same\n module as the type itself).\n \n Inherent candidates are not always derived from impls.  If you have a\n-trait instance, such as a value of type `ToStr`, then the trait\n+trait instance, such as a value of type `@ToStr`, then the trait\n methods (`to_str()`, in this case) are inherently associated with it.\n Another case is type parameters, in which case the methods of their\n bounds are inherent.\n@@ -1221,7 +1221,7 @@ pub impl LookupContext {\n             }\n             method_trait(trait_did, _, _) | method_self(trait_did, _)\n                 | method_super(trait_did, _) => {\n-                self.report_param_candidate(idx, trait_did)\n+                self.report_trait_candidate(idx, trait_did)\n             }\n         }\n     }"}, {"sha": "fa17c9438a22383eab3ca8f22f49704b16c003b4", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -18,7 +18,7 @@ use middle::typeck::infer::{fixup_err_to_str, InferCtxt};\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n use middle::typeck::{CrateCtxt, vtable_origin, vtable_param, vtable_res};\n-use middle::typeck::{vtable_static, vtable_trait};\n+use middle::typeck::{vtable_static};\n use util::common::indenter;\n use util::ppaux::tys_to_str;\n use util::ppaux;\n@@ -81,7 +81,6 @@ pub fn lookup_vtables(vcx: &VtableContext,\n                       location_info: &LocationInfo,\n                       bounds: @~[ty::param_bounds],\n                       substs: &ty::substs,\n-                      allow_unsafe: bool,\n                       is_early: bool) -> vtable_res {\n     debug!(\"lookup_vtables(location_info=%?,\n             # bounds=%?, \\\n@@ -110,8 +109,7 @@ pub fn lookup_vtables(vcx: &VtableContext,\n             debug!(\"after subst: %?\",\n                    ppaux::ty_to_str(tcx, trait_ty));\n \n-            match lookup_vtable(vcx, location_info, *ty, trait_ty,\n-                                allow_unsafe, is_early) {\n+            match lookup_vtable(vcx, location_info, *ty, trait_ty, is_early) {\n                 Some(vtable) => result.push(vtable),\n                 None => {\n                     vcx.tcx().sess.span_fatal(\n@@ -162,7 +160,6 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n                      ty: ty::t,\n                      trait_ty: ty::t,\n-                     allow_unsafe: bool,\n                      is_early: bool)\n                   -> Option<vtable_origin> {\n     debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n@@ -224,30 +221,6 @@ pub fn lookup_vtable(vcx: &VtableContext,\n             }\n         }\n \n-        ty::ty_trait(did, ref substs, _) if trait_id == did => {\n-            debug!(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n-                   did);\n-\n-            relate_trait_tys(vcx, location_info, trait_ty, ty);\n-            if !allow_unsafe && !is_early {\n-                for vec::each(*ty::trait_methods(tcx, did)) |m| {\n-                    if ty::type_has_self(ty::mk_bare_fn(tcx, copy m.fty)) {\n-                        tcx.sess.span_err(\n-                            location_info.span,\n-                            ~\"a boxed trait with self types may not be \\\n-                              passed as a bounded type\");\n-                    } else if (*m.tps).len() > 0u {\n-                        tcx.sess.span_err(\n-                            location_info.span,\n-                            ~\"a boxed trait with generic methods may not \\\n-                              be passed as a bounded type\");\n-\n-                    }\n-                }\n-            }\n-            return Some(vtable_trait(did, /*bad*/copy (*substs).tps));\n-        }\n-\n         _ => {\n             let mut found = ~[];\n \n@@ -411,7 +384,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                                               trait_vstore);\n                             let subres = lookup_vtables(\n                                 vcx, location_info, im_bs, &substs_f,\n-                                false, is_early);\n+                                is_early);\n \n                             // Finally, we register that we found a\n                             // matching impl, and record the def ID of\n@@ -542,8 +515,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                 }\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           item_ty.bounds, substs, false,\n-                                           is_early);\n+                                           item_ty.bounds, substs, is_early);\n                 if !is_early {\n                     let vtable_map = cx.vtable_map;\n                     vtable_map.insert(ex.id, vtbls);\n@@ -573,7 +545,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                 let substs = fcx.node_ty_substs(callee_id);\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           bounds, &substs, false, is_early);\n+                                           bounds, &substs, is_early);\n                 if !is_early {\n                     insert_vtables(cx, callee_id, vtbls);\n                 }\n@@ -607,7 +579,6 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                             location_info,\n                                             mt.ty,\n                                             target_ty,\n-                                            true,\n                                             is_early);\n                           match vtable_opt {\n                               Some(vtable) => {"}, {"sha": "5cfb7973b96a0934a9eb1b24f5f5d30c8cabafe4", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -22,7 +22,7 @@ use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::{resolve_type};\n use middle::typeck::infer;\n use middle::typeck::method_map_entry;\n-use middle::typeck::{vtable_param, vtable_trait, write_substs_to_tcx};\n+use middle::typeck::{vtable_param, write_substs_to_tcx};\n use middle::typeck::{write_ty_to_tcx};\n use util::ppaux;\n "}, {"sha": "2d1fab5f6a9c9198bca12b08d248b0b37941ab64", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -902,8 +902,12 @@ pub impl CoherenceChecker {\n                     // Nothing to do.\n                 }\n                 Some(base_type_def_id) => {\n-                    self.add_inherent_method(base_type_def_id,\n-                                             *implementation);\n+                    // inherent methods apply to `impl Type` but not\n+                    // `impl Trait for Type`:\n+                    if associated_traits.len() == 0 {\n+                        self.add_inherent_method(base_type_def_id,\n+                                                 *implementation);\n+                    }\n \n                     self.base_type_def_ids.insert(implementation.did,\n                                                   base_type_def_id);"}, {"sha": "81094e3fb97e3a1a70d4d30090f2e5f6ad2ab6eb", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -150,12 +150,7 @@ pub enum vtable_origin {\n       The first uint is the param number (identifying T in the example),\n       and the second is the bound number (identifying baz)\n      */\n-    vtable_param(uint, uint),\n-    /*\n-      Dynamic vtable, comes from something known to have a trait\n-      type. def_id refers to the trait item, tys are the substs\n-     */\n-    vtable_trait(ast::def_id, ~[ty::t]),\n+    vtable_param(uint, uint)\n }\n \n pub impl vtable_origin {\n@@ -171,12 +166,6 @@ pub impl vtable_origin {\n             vtable_param(x, y) => {\n                 fmt!(\"vtable_param(%?, %?)\", x, y)\n             }\n-\n-            vtable_trait(def_id, ref tys) => {\n-                fmt!(\"vtable_trait(%?:%s, %?)\",\n-                     def_id, ty::item_path_str(tcx, def_id),\n-                     tys.map(|t| ppaux::ty_to_str(tcx, *t)))\n-            }\n         }\n     }\n }"}, {"sha": "0f8463b0b3c93879a6f7ae05f344f8195556556c", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -35,6 +35,7 @@ use std::net::url;\n use std::{json, semver, getopts};\n use syntax::codemap::spanned;\n use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n+use core::container::Map;\n \n mod usage;\n mod util;"}, {"sha": "8cfb216d2a2a98be045079685645c51c68f1d720", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::*;\n+use core::hash::{Hash, HashUtil, Streaming};\n use core::hashmap::linear::LinearMap;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;"}, {"sha": "e3437fc57aaed8515de5d24ec65dbfcc7586acba", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -25,6 +25,27 @@ pub struct DuplexStream<T, U> {\n     priv port: Port<U>,\n }\n \n+// Allow these methods to be used without import:\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T:Owned,U:Owned> DuplexStream<T, U> {\n+    fn send(x: T) {\n+        self.chan.send(x)\n+    }\n+    fn try_send(x: T) -> bool {\n+        self.chan.try_send(x)\n+    }\n+    fn recv() -> U {\n+        self.port.recv()\n+    }\n+    fn try_recv() -> Option<U> {\n+        self.port.try_recv()\n+    }\n+    pure fn peek() -> bool {\n+        self.port.peek()\n+    }\n+}\n+\n impl<T:Owned,U:Owned> GenericChan<T> for DuplexStream<T, U> {\n     fn send(&self, x: T) {\n         self.chan.send(x)"}, {"sha": "0458636a401ef5be00402a224e8dd09c6673ae5d", "filename": "src/test/auxiliary/coherence_inherent_cc_lib.rs", "status": "renamed", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fauxiliary%2Fcoherence_inherent_cc_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fauxiliary%2Fcoherence_inherent_cc_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence_inherent_cc_lib.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -8,19 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait double {\n-    fn double() -> uint;\n-}\n+// See coherence_inherent_cc.rs\n \n-impl double for uint {\n-    fn double() -> uint { self * 2u }\n+pub trait TheTrait {\n+    fn the_fn(&self);\n }\n \n-fn is_equal<D:double>(x: @D, exp: uint) {\n-    assert x.double() == exp;\n-}\n+pub struct TheStruct;\n \n-pub fn main() {\n-    let x = @(@3u as @double);\n-    is_equal(x, 6);\n+impl TheTrait for TheStruct {\n+    fn the_fn(&self) {}\n }", "previous_filename": "src/test/run-pass/autoderef-method-on-trait-monomorphized.rs"}, {"sha": "590c12826e4fe834698c3604de827859d88754f5", "filename": "src/test/compile-fail/coherence_inherent.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that methods that implement a trait cannot be invoked\n+// unless the trait is imported.\n+\n+mod Lib {\n+    pub trait TheTrait {\n+        fn the_fn(&self);\n+    }\n+\n+    pub struct TheStruct;\n+\n+    impl TheTrait for TheStruct {\n+        fn the_fn(&self) {}\n+    }\n+}\n+\n+mod Import {\n+    // Trait is in scope here:\n+    use Lib::TheStruct;\n+    use Lib::TheTrait;\n+\n+    fn call_the_fn(s: &TheStruct) {\n+        s.the_fn();\n+    }\n+}\n+\n+mod NoImport {\n+    // Trait is not in scope here:\n+    use Lib::TheStruct;\n+\n+    fn call_the_fn(s: &TheStruct) {\n+        s.the_fn(); //~ ERROR does not implement any method in scope named `the_fn`\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "72c6df57c4ff580946ed9eb099c65565a6be6360", "filename": "src/test/compile-fail/coherence_inherent_cc.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+// aux-build:coherence_inherent_cc_lib.rs\n+\n+// Tests that methods that implement a trait cannot be invoked\n+// unless the trait is imported.\n+\n+extern mod coherence_inherent_cc_lib;\n+\n+mod Import {\n+    // Trait is in scope here:\n+    use coherence_inherent_cc_lib::TheStruct;\n+    use coherence_inherent_cc_lib::TheTrait;\n+\n+    fn call_the_fn(s: &TheStruct) {\n+        s.the_fn();\n+    }\n+}\n+\n+mod NoImport {\n+    // Trait is not in scope here:\n+    use coherence_inherent_cc_lib::TheStruct;\n+\n+    fn call_the_fn(s: &TheStruct) {\n+        s.the_fn(); //~ ERROR does not implement any method in scope named `the_fn`\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "886b849dbefc07b177150306178eeab7ee937709", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "renamed", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -8,19 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait double {\n-    fn double() -> uint;\n-}\n+// Test that an object type `@Foo` is not considered to implement the\n+// trait `Foo`. Issue #5087.\n \n-impl double for uint {\n-    fn double() -> uint { self * 2u }\n-}\n-\n-fn is_equal<D:double>(x: @D, exp: uint) {\n-    assert x.double() == exp;\n-}\n-\n-pub fn main() {\n-    let x = @(@3u as @double);\n-    is_equal(x, 6);\n-}\n+trait Foo {}\n+fn take_foo<F:Foo>(f: F) {}\n+fn take_object(f: @Foo) { take_foo(f); } //~ ERROR failed to find an implementation of trait\n+fn main() {}", "previous_filename": "src/test/run-pass/issue-3305.rs"}, {"sha": "a10c239617ec96a107ca7395fd249e17b17533cb", "filename": "src/test/compile-fail/regions-trait-3.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -16,8 +16,16 @@ fn make_gc1(gc: get_ctxt/&a) -> get_ctxt/&b  {\n     return gc; //~ ERROR mismatched types: expected `@get_ctxt/&b` but found `@get_ctxt/&a`\n }\n \n-fn make_gc2(gc: get_ctxt/&a) -> get_ctxt/&b  {\n-    return @gc as get_ctxt; //~ ERROR cannot infer an appropriate lifetime\n+struct Foo {\n+    r: &'self uint\n+}\n+\n+impl get_ctxt/&self for Foo/&self {\n+    fn get_ctxt() -> &self/uint { self.r }\n+}\n+\n+fn make_gc2(foo: Foo/&a) -> get_ctxt/&b  {\n+    return @foo as get_ctxt; //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "08b6c0f71fe6e34134601a1755b7ebfa67c7f49e", "filename": "src/test/compile-fail/selftype-astparam.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs?ref=67100ddb3519dedf8ab07371a381c7762f9fcc4f", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait add {\n-    fn plus(++x: Self) -> Self;\n-}\n-\n-impl add for int {\n-    fn plus(++x: int) -> int { self + x }\n-}\n-\n-fn do_add<A:add>(x: A, y: A) -> A { x.plus(y) }\n-\n-fn main() {\n-    let x = @3 as @add;\n-    let y = @4 as @add;\n-    do_add(x, y); //~ ERROR a boxed trait with self types may not be passed as a bounded type\n-}"}, {"sha": "d0738be09c7cdb48cd652c281dafe2090604f949", "filename": "src/test/compile-fail/trait-cast.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs?ref=67100ddb3519dedf8ab07371a381c7762f9fcc4f", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait foo<T> { }\n-\n-fn bar(x: foo<uint>) -> foo<int> {\n-    return (@x as foo::<int>);\n-    //~^ ERROR mismatched types: expected `@foo<int>` but found `@foo<uint>`\n-    //~^^ ERROR mismatched types: expected `@foo<int>` but found `@foo<uint>`\n-    // This is unfortunate -- new handling of parens means the error message\n-    // gets printed twice\n-}\n-\n-fn main() {}"}, {"sha": "53c50d7fca0c43d0a42ac8de61d38a67843e52bc", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -14,7 +14,7 @@ extern mod cci_class_cast;\n use core::to_str::ToStr;\n use cci_class_cast::kitty::*;\n \n-fn print_out<T:ToStr>(thing: T, expected: ~str) {\n+fn print_out(thing: @ToStr, expected: ~str) {\n   let actual = thing.to_str();\n   debug!(\"%s\", actual);\n   assert(actual == expected);"}, {"sha": "39466bb8c16700f214b09fdc5d263db977012c2d", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -79,7 +79,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n \n-fn annoy_neighbors<T:noisy>(critter: T) {\n+fn annoy_neighbors(critter: @noisy) {\n   for uint::range(0u, 10u) |i| { critter.speak(); }\n }\n "}, {"sha": "eb0d8de7eab8901ad19f376ec49341b5b507c121", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -56,7 +56,7 @@ impl ToStr for cat {\n   pure fn to_str(&self) -> ~str { copy self.name }\n }\n \n-fn print_out<T:ToStr>(thing: T, expected: ~str) {\n+fn print_out(thing: @ToStr, expected: ~str) {\n   let actual = thing.to_str();\n   debug!(\"%s\", actual);\n   assert(actual == expected);"}, {"sha": "92f745d7d5384da040b970c6207362cfa52cc92b", "filename": "src/test/run-pass/explicit-self-objects-ext-1.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs?ref=67100ddb3519dedf8ab07371a381c7762f9fcc4f", "patch": "@@ -1,39 +0,0 @@\n-pub trait Reader {\n-    // FIXME (#2004): Seekable really should be orthogonal.\n-\n-    /// Read up to len bytes (or EOF) and put them into bytes (which\n-    /// must be at least len bytes long). Return number of bytes read.\n-    // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n-}\n-\n-pub trait ReaderUtil {\n-\n-    /// Read len bytes into a new vec.\n-    fn read_bytes(&self, len: uint);\n-}\n-\n-impl<T:Reader> ReaderUtil for T {\n-\n-    fn read_bytes(&self, len: uint) {\n-        let mut count = self.read(&mut [0], len);\n-    }\n-\n-}\n-\n-struct S {\n-    x: int,\n-    y: int\n-}\n-\n-impl Reader for S {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        0\n-    }\n-}\n-\n-pub fn main() {\n-    let x = S { x: 1, y: 2 };\n-    let x = @x as @Reader;\n-    x.read_bytes(0);\n-}"}, {"sha": "92f745d7d5384da040b970c6207362cfa52cc92b", "filename": "src/test/run-pass/explicit-self-objects-ext-2.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs?ref=67100ddb3519dedf8ab07371a381c7762f9fcc4f", "patch": "@@ -1,39 +0,0 @@\n-pub trait Reader {\n-    // FIXME (#2004): Seekable really should be orthogonal.\n-\n-    /// Read up to len bytes (or EOF) and put them into bytes (which\n-    /// must be at least len bytes long). Return number of bytes read.\n-    // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n-}\n-\n-pub trait ReaderUtil {\n-\n-    /// Read len bytes into a new vec.\n-    fn read_bytes(&self, len: uint);\n-}\n-\n-impl<T:Reader> ReaderUtil for T {\n-\n-    fn read_bytes(&self, len: uint) {\n-        let mut count = self.read(&mut [0], len);\n-    }\n-\n-}\n-\n-struct S {\n-    x: int,\n-    y: int\n-}\n-\n-impl Reader for S {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        0\n-    }\n-}\n-\n-pub fn main() {\n-    let x = S { x: 1, y: 2 };\n-    let x = @x as @Reader;\n-    x.read_bytes(0);\n-}"}, {"sha": "2cfd327dc4e5388edc00e107179f28d7d7dbf53c", "filename": "src/test/run-pass/explicit-self-objects-ext-3.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs?ref=67100ddb3519dedf8ab07371a381c7762f9fcc4f", "patch": "@@ -1,39 +0,0 @@\n-pub trait Reader {\n-    // FIXME (#2004): Seekable really should be orthogonal.\n-\n-    /// Read up to len bytes (or EOF) and put them into bytes (which\n-    /// must be at least len bytes long). Return number of bytes read.\n-    // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n-}\n-\n-pub trait ReaderUtil {\n-\n-    /// Read len bytes into a new vec.\n-    fn read_bytes(len: uint);\n-}\n-\n-impl<T:Reader> ReaderUtil for T {\n-\n-    fn read_bytes(len: uint) {\n-        let mut count = self.read(&mut [0], len);\n-    }\n-\n-}\n-\n-struct S {\n-    x: int,\n-    y: int\n-}\n-\n-impl Reader for S {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        0\n-    }\n-}\n-\n-pub fn main() {\n-    let x = S { x: 1, y: 2 };\n-    let x = @x as @Reader;\n-    x.read_bytes(0);\n-}"}, {"sha": "3945be779041defc34a9f394023067ddc81b5227", "filename": "src/test/run-pass/explicit-self-objects-ext-4.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67100ddb3519dedf8ab07371a381c7762f9fcc4f/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs?ref=67100ddb3519dedf8ab07371a381c7762f9fcc4f", "patch": "@@ -1,39 +0,0 @@\n-pub trait Reader {\n-    // FIXME (#2004): Seekable really should be orthogonal.\n-\n-    /// Read up to len bytes (or EOF) and put them into bytes (which\n-    /// must be at least len bytes long). Return number of bytes read.\n-    // FIXME (#2982): This should probably return an error.\n-    fn read(bytes: &mut [u8], len: uint) -> uint;\n-}\n-\n-pub trait ReaderUtil {\n-\n-    /// Read len bytes into a new vec.\n-    fn read_bytes(len: uint);\n-}\n-\n-impl<T:Reader> ReaderUtil for T {\n-\n-    fn read_bytes(len: uint) {\n-        let mut count = self.read(&mut [0], len);\n-    }\n-\n-}\n-\n-struct S {\n-    x: int,\n-    y: int\n-}\n-\n-impl Reader for S {\n-    fn read(bytes: &mut [u8], len: uint) -> uint {\n-        0\n-    }\n-}\n-\n-pub fn main() {\n-    let x = S { x: 1, y: 2 };\n-    let x = @x as @Reader;\n-    x.read_bytes(0);\n-}"}, {"sha": "83cedc0fe502468b7c2dd001cce74e45decc0bcb", "filename": "src/test/run-pass/issue-2611.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -11,12 +11,12 @@\n use core::iter::BaseIter;\n \n trait FlatMapToVec<A> {\n-  fn flat_map_to_vec<B, IB:BaseIter<B>>(op: fn(&A) -> IB) -> ~[B];\n+  fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: fn(&A) -> IB) -> ~[B];\n }\n \n-impl<A:Copy> FlatMapToVec<A> for BaseIter<A> {\n-   fn flat_map_to_vec<B, IB:BaseIter<B>>(op: fn(&A) -> IB) -> ~[B] {\n-     iter::flat_map_to_vec(&self, op)\n+impl<A:Copy> FlatMapToVec<A> for ~[A] {\n+   fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: fn(&A) -> IB) -> ~[B] {\n+     iter::flat_map_to_vec(self, op)\n    }\n }\n "}, {"sha": "b0a3223bb3bc3d1385391f69e62b2343811b2032", "filename": "src/test/run-pass/issue-3168.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3168.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -18,13 +18,13 @@ pub fn main() {\n             p2.recv();\n             error!(\"sibling fails\");\n             fail!();\n-        }   \n+        }\n         let (p3,c3) = comm::stream();\n         c.send(c3);\n         c2.send(());\n         error!(\"child blocks\");\n         p3.recv();\n-    };  \n+    };\n     error!(\"parent tries\");\n     assert !p.recv().try_send(());\n     error!(\"all done!\");"}, {"sha": "01f68929b90a709366304f3cf8d83b11c711a0d7", "filename": "src/test/run-pass/pipe-presentation-examples.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -17,6 +17,7 @@\n \n use double_buffer::client::*;\n use double_buffer::give_buffer;\n+use core::comm::Selectable;\n \n macro_rules! select_if (\n     {"}, {"sha": "f344837a22d73f955efa28de18e7e79e74a34f5c", "filename": "src/test/run-pass/trait-inheritance-cross-trait-call-xc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b79a58d9d30c09366e562691d50182b335aef6e/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs?ref=4b79a58d9d30c09366e562691d50182b335aef6e", "patch": "@@ -13,7 +13,9 @@\n \n extern mod aux(name = \"trait_inheritance_cross_trait_call_xc_aux\");\n \n-trait Bar : aux::Foo {\n+use aux::Foo;\n+\n+trait Bar : Foo {\n     fn g() -> int;\n }\n "}]}