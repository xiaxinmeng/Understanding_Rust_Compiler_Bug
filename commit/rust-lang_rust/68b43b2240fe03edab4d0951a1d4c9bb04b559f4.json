{"sha": "68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YjQzYjIyNDBmZTAzZWRhYjRkMDk1MWExZDRjOWJiMDRiNTU5ZjQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-12-10T19:47:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-12-10T19:47:26Z"}, "message": "Merge pull request #2250 from topecongiro/rustfmt-skip-no-warning-on-items\n\nDo not report errors on skipped items or statements", "tree": {"sha": "09f65b215af6f7f33258f032b1b57faf59d04c7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09f65b215af6f7f33258f032b1b57faf59d04c7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaLY9OCRBK7hj4Ov3rIwAAdHIIACa2Y0RhP2HCWhuwNSM+J5wC\nUjmzSDp96a9ZTYY0CUZRTys3XuXiOsPHloz0kuQ9+uG+Kze0EGm60c+2b/hcWsGi\nTt2UEG5gsRuwLDthX6o8pIDPZgJe+jD45JQzACZnLANBBZZbpHjkwR8wY3M+JD6q\nKNE/kLoYTsvnOCW5ut3khNHpQaSdHKcBYOMB+GWMY4YdWSghSriVvfAWkQ58t8if\nM4Ch07BQi3BJ0XBDfyo3ZWEezWS3WXgWPWzF65ea4Sy4LwrULtYB8CvbIuguXkfa\nJ9D0YgVj9ljYOSLkA48jfEnq8Sn5dY0DKUZynPGR7SAqgN/LiC9OuvlWJxzJqY8=\n=wH+p\n-----END PGP SIGNATURE-----\n", "payload": "tree 09f65b215af6f7f33258f032b1b57faf59d04c7d\nparent db5d6dd702544925141061aab5aa2455ea7c5d02\nparent adc3b12ad496a014cd1b3cdbeabafbcd3f206796\nauthor Nick Cameron <nrc@ncameron.org> 1512935246 +1300\ncommitter GitHub <noreply@github.com> 1512935246 +1300\n\nMerge pull request #2250 from topecongiro/rustfmt-skip-no-warning-on-items\n\nDo not report errors on skipped items or statements "}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "html_url": "https://github.com/rust-lang/rust/commit/68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db5d6dd702544925141061aab5aa2455ea7c5d02", "url": "https://api.github.com/repos/rust-lang/rust/commits/db5d6dd702544925141061aab5aa2455ea7c5d02", "html_url": "https://github.com/rust-lang/rust/commit/db5d6dd702544925141061aab5aa2455ea7c5d02"}, {"sha": "adc3b12ad496a014cd1b3cdbeabafbcd3f206796", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc3b12ad496a014cd1b3cdbeabafbcd3f206796", "html_url": "https://github.com/rust-lang/rust/commit/adc3b12ad496a014cd1b3cdbeabafbcd3f206796"}], "stats": {"total": 188, "additions": 122, "deletions": 66}, "files": [{"sha": "1d38328d45cfff76724b0ec2b9f52ea7ce11e69a", "filename": "src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "patch": "@@ -285,7 +285,7 @@ impl<'a> FmtVisitor<'a> {\n             }\n             Some(ref s) => {\n                 self.format_missing_with_indent(source!(self, span).lo());\n-                self.buffer.push_str(s);\n+                self.push_str(s);\n                 self.last_pos = source!(self, span).hi();\n             }\n             None => {"}, {"sha": "44c03ebf95bad08b8224bec2bb2fd4796fc4ed5e", "filename": "src/items.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "patch": "@@ -240,12 +240,12 @@ impl<'a> FnSig<'a> {\n \n impl<'a> FmtVisitor<'a> {\n     fn format_item(&mut self, item: Item) {\n-        self.buffer.push_str(&item.abi);\n+        self.push_str(&item.abi);\n \n         let snippet = self.snippet(item.span);\n         let brace_pos = snippet.find_uncommented(\"{\").unwrap();\n \n-        self.buffer.push_str(\"{\");\n+        self.push_str(\"{\");\n         if !item.body.is_empty() || contains_comment(&snippet[brace_pos..]) {\n             // FIXME: this skips comments between the extern keyword and the opening\n             // brace.\n@@ -255,9 +255,8 @@ impl<'a> FmtVisitor<'a> {\n             if item.body.is_empty() {\n                 self.format_missing_no_indent(item.span.hi() - BytePos(1));\n                 self.block_indent = self.block_indent.block_unindent(self.config);\n-\n-                self.buffer\n-                    .push_str(&self.block_indent.to_string(self.config));\n+                let indent_str = self.block_indent.to_string(self.config);\n+                self.push_str(&indent_str);\n             } else {\n                 for item in &item.body {\n                     self.format_body_element(item);\n@@ -268,7 +267,7 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n \n-        self.buffer.push_str(\"}\");\n+        self.push_str(\"}\");\n         self.last_pos = item.span.hi();\n     }\n \n@@ -423,7 +422,7 @@ impl<'a> FmtVisitor<'a> {\n         span: Span,\n     ) {\n         let enum_header = format_header(\"enum \", ident, vis);\n-        self.buffer.push_str(&enum_header);\n+        self.push_str(&enum_header);\n \n         let enum_snippet = self.snippet(span);\n         let brace_pos = enum_snippet.find_uncommented(\"{\").unwrap();\n@@ -441,23 +440,23 @@ impl<'a> FmtVisitor<'a> {\n             mk_sp(span.lo(), body_start),\n             last_line_width(&enum_header),\n         ).unwrap();\n-        self.buffer.push_str(&generics_str);\n+        self.push_str(&generics_str);\n \n         self.last_pos = body_start;\n \n         self.block_indent = self.block_indent.block_indent(self.config);\n         let variant_list = self.format_variant_list(enum_def, body_start, span.hi() - BytePos(1));\n         match variant_list {\n-            Some(ref body_str) => self.buffer.push_str(body_str),\n+            Some(ref body_str) => self.push_str(body_str),\n             None => self.format_missing_no_indent(span.hi() - BytePos(1)),\n         }\n         self.block_indent = self.block_indent.block_unindent(self.config);\n \n         if variant_list.is_some() || contains_comment(&enum_snippet[brace_pos..]) {\n-            self.buffer\n-                .push_str(&self.block_indent.to_string(self.config));\n+            let indent_str = self.block_indent.to_string(self.config);\n+            self.push_str(&indent_str);\n         }\n-        self.buffer.push_str(\"}\");\n+        self.push_str(\"}\");\n         self.last_pos = span.hi();\n     }\n "}, {"sha": "18e802b1d2ed87692a4070089377e07bd2950fdc", "filename": "src/lib.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "patch": "@@ -300,7 +300,7 @@ fn format_ast<F>(\n     mut after_file: F,\n ) -> Result<(FileMap, bool), io::Error>\n where\n-    F: FnMut(&str, &mut StringBuffer) -> Result<bool, io::Error>,\n+    F: FnMut(&str, &mut StringBuffer, &[(usize, usize)]) -> Result<bool, io::Error>,\n {\n     let mut result = FileMap::new();\n     // diff mode: check if any files are differing\n@@ -338,7 +338,12 @@ where\n             visitor.format_separate_mod(module, &*filemap);\n         };\n \n-        has_diff |= match after_file(path_str, &mut visitor.buffer) {\n+        assert_eq!(\n+            visitor.line_number,\n+            ::utils::count_newlines(&format!(\"{}\", visitor.buffer))\n+        );\n+\n+        has_diff |= match after_file(path_str, &mut visitor.buffer, &visitor.skipped_range) {\n             Ok(result) => result,\n             Err(e) => {\n                 // Create a new error with path_str to help users see which files failed\n@@ -353,10 +358,23 @@ where\n     Ok((result, has_diff))\n }\n \n+/// Returns true if the line with the given line number was skipped by `#[rustfmt_skip]`.\n+fn is_skipped_line(line_number: usize, skipped_range: &[(usize, usize)]) -> bool {\n+    skipped_range\n+        .iter()\n+        .any(|&(lo, hi)| lo <= line_number && line_number <= hi)\n+}\n+\n // Formatting done on a char by char or line by line basis.\n // FIXME(#209) warn on bad license\n // FIXME(#20) other stuff for parity with make tidy\n-fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &mut FormatReport) {\n+fn format_lines(\n+    text: &mut StringBuffer,\n+    name: &str,\n+    skipped_range: &[(usize, usize)],\n+    config: &Config,\n+    report: &mut FormatReport,\n+) {\n     // Iterate over the chars in the file map.\n     let mut trims = vec![];\n     let mut last_wspace: Option<usize> = None;\n@@ -398,6 +416,7 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n \n                 // Check for any line width errors we couldn't correct.\n                 let report_error_on_line_overflow = config.error_on_line_overflow()\n+                    && !is_skipped_line(cur_line, skipped_range)\n                     && (config.error_on_line_overflow_comments() || !is_comment);\n                 if report_error_on_line_overflow && line_len > config.max_width() {\n                     errors.push(FormattingError {\n@@ -443,12 +462,14 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n     }\n \n     for &(l, _, _, ref b) in &trims {\n-        errors.push(FormattingError {\n-            line: l,\n-            kind: ErrorKind::TrailingWhitespace,\n-            is_comment: false,\n-            line_buffer: b.clone(),\n-        });\n+        if !is_skipped_line(l, skipped_range) {\n+            errors.push(FormattingError {\n+                line: l,\n+                kind: ErrorKind::TrailingWhitespace,\n+                is_comment: false,\n+                line_buffer: b.clone(),\n+            });\n+        }\n     }\n \n     report.file_error_map.insert(name.to_owned(), errors);\n@@ -541,12 +562,12 @@ pub fn format_input<T: Write>(\n         &mut parse_session,\n         &main_file,\n         config,\n-        |file_name, file| {\n+        |file_name, file, skipped_range| {\n             // For some reason, the codemap does not include terminating\n             // newlines so we must add one on for each file. This is sad.\n             filemap::append_newline(file);\n \n-            format_lines(file, file_name, config, &mut report);\n+            format_lines(file, file_name, skipped_range, config, &mut report);\n \n             if let Some(ref mut out) = out {\n                 return filemap::write_file(file, file_name, out, config);"}, {"sha": "2ed1f50182b883543134d5f3edba89f8083eea2e", "filename": "src/missed_spans.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "patch": "@@ -28,27 +28,25 @@ impl<'a> FmtVisitor<'a> {\n     // TODO these format_missing methods are ugly. Refactor and add unit tests\n     // for the central whitespace stripping loop.\n     pub fn format_missing(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, _| {\n-            this.buffer.push_str(last_snippet)\n-        })\n+        self.format_missing_inner(end, |this, last_snippet, _| this.push_str(last_snippet))\n     }\n \n     pub fn format_missing_with_indent(&mut self, end: BytePos) {\n         let config = self.config;\n         self.format_missing_inner(end, |this, last_snippet, snippet| {\n-            this.buffer.push_str(last_snippet.trim_right());\n+            this.push_str(last_snippet.trim_right());\n             if last_snippet == snippet && !this.output_at_start() {\n                 // No new lines in the snippet.\n-                this.buffer.push_str(\"\\n\");\n+                this.push_str(\"\\n\");\n             }\n             let indent = this.block_indent.to_string(config);\n-            this.buffer.push_str(&indent);\n+            this.push_str(&indent);\n         })\n     }\n \n     pub fn format_missing_no_indent(&mut self, end: BytePos) {\n         self.format_missing_inner(end, |this, last_snippet, _| {\n-            this.buffer.push_str(last_snippet.trim_right());\n+            this.push_str(last_snippet.trim_right());\n         })\n     }\n \n@@ -97,7 +95,7 @@ impl<'a> FmtVisitor<'a> {\n             newline_count = newline_lower_bound;\n         }\n         let blank_lines: String = repeat('\\n').take(newline_count).collect();\n-        self.buffer.push_str(&blank_lines);\n+        self.push_str(&blank_lines);\n     }\n \n     fn write_snippet<F>(&mut self, span: Span, process_last_snippet: F)\n@@ -154,12 +152,12 @@ impl<'a> FmtVisitor<'a> {\n         if status.rewrite_next_comment {\n             if fix_indent {\n                 if let Some('{') = last_char {\n-                    self.buffer.push_str(\"\\n\");\n+                    self.push_str(\"\\n\");\n                 }\n-                self.buffer\n-                    .push_str(&self.block_indent.to_string(self.config));\n+                let indent_str = self.block_indent.to_string(self.config);\n+                self.push_str(&indent_str);\n             } else {\n-                self.buffer.push_str(\" \");\n+                self.push_str(\" \");\n             }\n \n             let comment_width = ::std::cmp::min(\n@@ -170,7 +168,7 @@ impl<'a> FmtVisitor<'a> {\n             let comment_shape = Shape::legacy(comment_width, comment_indent);\n             let comment_str = rewrite_comment(subslice, false, comment_shape, self.config)\n                 .unwrap_or_else(|| String::from(subslice));\n-            self.buffer.push_str(&comment_str);\n+            self.push_str(&comment_str);\n \n             status.last_wspace = None;\n             status.line_start = offset + subslice.len();\n@@ -183,13 +181,13 @@ impl<'a> FmtVisitor<'a> {\n                     .any(|s| s.len() >= 2 && &s[0..2] == \"/*\")\n                 {\n                     // Add a newline after line comments\n-                    self.buffer.push_str(\"\\n\");\n+                    self.push_str(\"\\n\");\n                 }\n             } else if status.line_start <= snippet.len() {\n                 // For other comments add a newline if there isn't one at the end already\n                 match snippet[status.line_start..].chars().next() {\n                     Some('\\n') | Some('\\r') => (),\n-                    _ => self.buffer.push_str(\"\\n\"),\n+                    _ => self.push_str(\"\\n\"),\n                 }\n             }\n \n@@ -277,10 +275,10 @@ impl<'a> FmtVisitor<'a> {\n                         }\n \n                         if let Some(lw) = status.last_wspace {\n-                            self.buffer.push_str(&snippet[status.line_start..lw]);\n-                            self.buffer.push_str(\"\\n\");\n+                            self.push_str(&snippet[status.line_start..lw]);\n+                            self.push_str(\"\\n\");\n                         } else {\n-                            self.buffer.push_str(&snippet[status.line_start..i + 1]);\n+                            self.push_str(&snippet[status.line_start..i + 1]);\n                         }\n \n                         status.cur_line += 1;\n@@ -306,7 +304,7 @@ impl<'a> FmtVisitor<'a> {\n \n                 let remaining = snippet[status.line_start..subslice.len() + offset].trim();\n                 if !remaining.is_empty() {\n-                    self.buffer.push_str(remaining);\n+                    self.push_str(remaining);\n                     status.line_start = subslice.len() + offset;\n                     status.rewrite_next_comment = true;\n                 }"}, {"sha": "7181512273efc4801e16ee8cf159e255600f8ccb", "filename": "src/spanned.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "patch": "@@ -54,6 +54,8 @@ implement_spanned!(ast::Field);\n implement_spanned!(ast::ForeignItem);\n implement_spanned!(ast::Item);\n implement_spanned!(ast::Local);\n+implement_spanned!(ast::TraitItem);\n+implement_spanned!(ast::ImplItem);\n \n impl Spanned for ast::Stmt {\n     fn span(&self) -> Span {"}, {"sha": "ac5501cae4c08a4dc70ed0970ffefdcda2fd9186", "filename": "src/visitor.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b43b2240fe03edab4d0951a1d4c9bb04b559f4/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "patch": "@@ -81,6 +81,8 @@ pub struct FmtVisitor<'a> {\n     pub config: &'a Config,\n     pub is_if_else_block: bool,\n     pub snippet_provider: &'a SnippetProvider<'a>,\n+    pub line_number: usize,\n+    pub skipped_range: Vec<(usize, usize)>,\n }\n \n impl<'b, 'a: 'b> FmtVisitor<'a> {\n@@ -100,13 +102,17 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.visit_item(item);\n             }\n             ast::StmtKind::Local(..) | ast::StmtKind::Expr(..) | ast::StmtKind::Semi(..) => {\n-                let rewrite = stmt.rewrite(&self.get_context(), self.shape());\n-                self.push_rewrite(stmt.span(), rewrite)\n+                if contains_skip(get_attrs_from_stmt(stmt)) {\n+                    self.push_skipped_with_span(stmt.span());\n+                } else {\n+                    let rewrite = stmt.rewrite(&self.get_context(), self.shape());\n+                    self.push_rewrite(stmt.span(), rewrite)\n+                }\n             }\n             ast::StmtKind::Mac(ref mac) => {\n                 let (ref mac, _macro_style, ref attrs) = **mac;\n                 if self.visit_attrs(attrs, ast::AttrStyle::Outer) {\n-                    self.push_rewrite(stmt.span(), None);\n+                    self.push_skipped_with_span(stmt.span());\n                 } else {\n                     self.visit_mac(mac, None, MacroPosition::Statement);\n                 }\n@@ -132,7 +138,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n         self.last_pos = self.last_pos + brace_compensation;\n         self.block_indent = self.block_indent.block_indent(self.config);\n-        self.buffer.push_str(\"{\");\n+        self.push_str(\"{\");\n \n         if self.config.remove_blank_lines_at_start_or_end_of_block() {\n             if let Some(first_stmt) = b.stmts.first() {\n@@ -195,7 +201,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         if !b.stmts.is_empty() {\n             if let Some(expr) = utils::stmt_expr(&b.stmts[b.stmts.len() - 1]) {\n                 if utils::semicolon_for_expr(&self.get_context(), expr) {\n-                    self.buffer.push_str(\";\");\n+                    self.push_str(\";\");\n                 }\n             }\n         }\n@@ -255,7 +261,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             self.config.tab_spaces()\n         };\n         self.buffer.truncate(total_len - chars_too_many);\n-        self.buffer.push_str(\"}\");\n+        self.push_str(\"}\");\n         self.block_indent = self.block_indent.block_unindent(self.config);\n     }\n \n@@ -288,7 +294,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n         if let Some(fn_str) = rewrite {\n             self.format_missing_with_indent(source!(self, s).lo());\n-            self.buffer.push_str(&fn_str);\n+            self.push_str(&fn_str);\n             if let Some(c) = fn_str.chars().last() {\n                 if c == '}' {\n                     self.last_pos = source!(self, block.span).hi();\n@@ -320,7 +326,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     // Module is inline, in this case we treat modules like any\n                     // other item.\n                     if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n-                        self.push_rewrite(item.span, None);\n+                        self.push_skipped_with_span(item.span());\n                         return;\n                     }\n                 } else if contains_skip(&item.attrs) {\n@@ -348,7 +354,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             }\n             _ => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n-                    self.push_rewrite(item.span, None);\n+                    self.push_skipped_with_span(item.span());\n                     return;\n                 }\n             }\n@@ -435,7 +441,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         skip_out_of_file_lines_range_visitor!(self, ti.span);\n \n         if self.visit_attrs(&ti.attrs, ast::AttrStyle::Outer) {\n-            self.push_rewrite(ti.span, None);\n+            self.push_skipped_with_span(ti.span());\n             return;\n         }\n \n@@ -477,7 +483,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         skip_out_of_file_lines_range_visitor!(self, ii.span);\n \n         if self.visit_attrs(&ii.attrs, ast::AttrStyle::Outer) {\n-            self.push_rewrite(ii.span, None);\n+            self.push_skipped_with_span(ii.span());\n             return;\n         }\n \n@@ -519,17 +525,34 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.push_rewrite(mac.span, rewrite);\n     }\n \n-    pub fn push_rewrite(&mut self, span: Span, rewrite: Option<String>) {\n-        self.format_missing_with_indent(source!(self, span).lo());\n+    pub fn push_str(&mut self, s: &str) {\n+        self.line_number += count_newlines(s);\n+        self.buffer.push_str(s);\n+    }\n+\n+    fn push_rewrite_inner(&mut self, span: Span, rewrite: Option<String>) {\n         if let Some(ref s) = rewrite {\n-            self.buffer.push_str(s);\n+            self.push_str(s);\n         } else {\n             let snippet = self.snippet(span);\n-            self.buffer.push_str(snippet);\n+            self.push_str(snippet);\n         }\n         self.last_pos = source!(self, span).hi();\n     }\n \n+    pub fn push_rewrite(&mut self, span: Span, rewrite: Option<String>) {\n+        self.format_missing_with_indent(source!(self, span).lo());\n+        self.push_rewrite_inner(span, rewrite);\n+    }\n+\n+    pub fn push_skipped_with_span(&mut self, span: Span) {\n+        self.format_missing_with_indent(source!(self, span).lo());\n+        let lo = self.line_number + 1;\n+        self.push_rewrite_inner(span, None);\n+        let hi = self.line_number + 1;\n+        self.skipped_range.push((lo, hi));\n+    }\n+\n     pub fn from_context(ctx: &'a RewriteContext) -> FmtVisitor<'a> {\n         FmtVisitor::from_codemap(ctx.parse_session, ctx.config, ctx.snippet_provider)\n     }\n@@ -548,6 +571,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             config: config,\n             is_if_else_block: false,\n             snippet_provider: snippet_provider,\n+            line_number: 0,\n+            skipped_range: vec![],\n         }\n     }\n \n@@ -692,23 +717,25 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         let is_internal = !(inner_span.lo().0 == 0 && inner_span.hi().0 == 0)\n             && local_file_name == self.codemap.span_to_filename(inner_span);\n \n-        self.buffer.push_str(&*utils::format_visibility(vis));\n-        self.buffer.push_str(\"mod \");\n-        self.buffer.push_str(&ident.to_string());\n+        self.push_str(&*utils::format_visibility(vis));\n+        self.push_str(\"mod \");\n+        self.push_str(&ident.to_string());\n \n         if is_internal {\n             match self.config.brace_style() {\n-                BraceStyle::AlwaysNextLine => self.buffer\n-                    .push_str(&format!(\"\\n{}{{\", self.block_indent.to_string(self.config))),\n-                _ => self.buffer.push_str(\" {\"),\n+                BraceStyle::AlwaysNextLine => {\n+                    let sep_str = format!(\"\\n{}{{\", self.block_indent.to_string(self.config));\n+                    self.push_str(&sep_str);\n+                }\n+                _ => self.push_str(\" {\"),\n             }\n             // Hackery to account for the closing }.\n             let mod_lo = self.codemap.span_after(source!(self, s), \"{\");\n             let body_snippet =\n                 self.snippet(mk_sp(mod_lo, source!(self, m.inner).hi() - BytePos(1)));\n             let body_snippet = body_snippet.trim();\n             if body_snippet.is_empty() {\n-                self.buffer.push_str(\"}\");\n+                self.push_str(\"}\");\n             } else {\n                 self.last_pos = mod_lo;\n                 self.block_indent = self.block_indent.block_indent(self.config);\n@@ -719,7 +746,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             }\n             self.last_pos = source!(self, m.inner).hi();\n         } else {\n-            self.buffer.push_str(\";\");\n+            self.push_str(\";\");\n             self.last_pos = source!(self, s).hi();\n         }\n     }\n@@ -1049,3 +1076,12 @@ pub fn rewrite_extern_crate(context: &RewriteContext, item: &ast::Item) -> Optio\n         String::from(&*Regex::new(r\"\\s;\").unwrap().replace(no_whitespace, \";\"))\n     })\n }\n+\n+fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n+    match stmt.node {\n+        ast::StmtKind::Local(ref local) => &local.attrs,\n+        ast::StmtKind::Item(ref item) => &item.attrs,\n+        ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => &expr.attrs,\n+        ast::StmtKind::Mac(ref mac) => &mac.2,\n+    }\n+}"}]}