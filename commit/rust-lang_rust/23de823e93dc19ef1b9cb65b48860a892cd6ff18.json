{"sha": "23de823e93dc19ef1b9cb65b48860a892cd6ff18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzZGU4MjNlOTNkYzE5ZWYxYjljYjY1YjQ4ODYwYTg5MmNkNmZmMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-23T08:35:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-23T08:35:00Z"}, "message": "Auto merge of #41408 - eddyb:poly-const-eval, r=arielb1\n\nrustc: generalize monomorphic_const_eval to polymorphic constants.\n\nWith the addition of `Substs` to the query key, we can now evaluate *and cache* polymorphic constants.\n\nFixes #23898 by replacing the crippled explicit-discriminant-only local-crate-only `lookup_variant_by_id` with `ConstVal::Variant` which can describe variants irrespective of their discriminant.\n\nFixes #41394 by fixing #23898 (for the original testcase) and by not looping past the first discriminant.", "tree": {"sha": "9b91c1c746a4f520ae69502e0dde070ba23fd9f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b91c1c746a4f520ae69502e0dde070ba23fd9f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23de823e93dc19ef1b9cb65b48860a892cd6ff18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23de823e93dc19ef1b9cb65b48860a892cd6ff18", "html_url": "https://github.com/rust-lang/rust/commit/23de823e93dc19ef1b9cb65b48860a892cd6ff18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23de823e93dc19ef1b9cb65b48860a892cd6ff18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a94124488ae0dba1a8a4552a4724cddf9d266e2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a94124488ae0dba1a8a4552a4724cddf9d266e2f", "html_url": "https://github.com/rust-lang/rust/commit/a94124488ae0dba1a8a4552a4724cddf9d266e2f"}, {"sha": "8054377f8f4dfaf766bcff40e7a720c90c5e33be", "url": "https://api.github.com/repos/rust-lang/rust/commits/8054377f8f4dfaf766bcff40e7a720c90c5e33be", "html_url": "https://github.com/rust-lang/rust/commit/8054377f8f4dfaf766bcff40e7a720c90c5e33be"}], "stats": {"total": 550, "additions": 331, "deletions": 219}, "files": [{"sha": "9a6574385222a9347841bd8ecc4093fc9ef984e9", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -97,7 +97,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TypeckBodiesKrate,\n     TypeckTables(D),\n     UsedTraitImports(D),\n-    MonomorphicConstEval(D),\n+    ConstEval(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -233,7 +233,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n-            MonomorphicConstEval(ref d) => op(d).map(MonomorphicConstEval),\n+            ConstEval(ref d) => op(d).map(ConstEval),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "16af98c2035480ef382ab55f7dbed9a5b521fb9a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -273,6 +273,12 @@ for ::middle::const_val::ConstVal<'tcx> {\n             ConstVal::Bool(value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n+            ConstVal::Char(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Variant(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n             ConstVal::Function(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n@@ -296,9 +302,6 @@ for ::middle::const_val::ConstVal<'tcx> {\n                 value.hash_stable(hcx, hasher);\n                 times.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Char(value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n         }\n     }\n }"}, {"sha": "ec7b3c4dd8dffd4514205789364611c8a89a4a26", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -38,12 +38,13 @@ pub enum ConstVal<'tcx> {\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n+    Char(char),\n+    Variant(DefId),\n     Function(DefId, &'tcx Substs<'tcx>),\n     Struct(BTreeMap<ast::Name, ConstVal<'tcx>>),\n     Tuple(Vec<ConstVal<'tcx>>),\n     Array(Vec<ConstVal<'tcx>>),\n     Repeat(Box<ConstVal<'tcx>>, u64),\n-    Char(char),\n }\n \n impl<'tcx> ConstVal<'tcx> {\n@@ -54,12 +55,13 @@ impl<'tcx> ConstVal<'tcx> {\n             Str(_) => \"string literal\",\n             ByteStr(_) => \"byte string literal\",\n             Bool(_) => \"boolean\",\n+            Char(..) => \"char\",\n+            Variant(_) => \"enum variant\",\n             Struct(_) => \"struct\",\n             Tuple(_) => \"tuple\",\n             Function(..) => \"function definition\",\n             Array(..) => \"array\",\n             Repeat(..) => \"repeat\",\n-            Char(..) => \"char\",\n         }\n     }\n \n@@ -85,7 +87,6 @@ pub enum ErrKind<'tcx> {\n     MissingStructField,\n     NegateOn(ConstVal<'tcx>),\n     NotOn(ConstVal<'tcx>),\n-    CallOn(ConstVal<'tcx>),\n \n     NonConstPath,\n     UnimplementedConstVal(&'static str),\n@@ -145,7 +146,6 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n             CannotCast => simple!(\"can't cast this type\"),\n             NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n             NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n-            CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n \n             MissingStructField  => simple!(\"nonexistent struct field\"),\n             NonConstPath        => simple!(\"non-constant path in constant expression\"),\n@@ -227,7 +227,8 @@ pub fn eval_length(tcx: TyCtxt,\n {\n     let count_expr = &tcx.hir.body(count).value;\n     let count_def_id = tcx.hir.body_owner_def_id(count);\n-    match ty::queries::monomorphic_const_eval::get(tcx, count_expr.span, count_def_id) {\n+    let substs = Substs::empty();\n+    match ty::queries::const_eval::get(tcx, count_expr.span, (count_def_id, substs)) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);"}, {"sha": "3251addcb3283310ffaf7b32dcca5f5019c58d95", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -249,8 +249,8 @@ pub trait CrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                     -> Option<&'tcx hir::Body>;\n+    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> &'tcx hir::Body;\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body>;\n     fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool;\n \n@@ -399,9 +399,9 @@ impl CrateStore for DummyCrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                     -> Option<&'tcx hir::Body> {\n-        bug!(\"maybe_get_item_body\")\n+    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> &'tcx hir::Body {\n+        bug!(\"item_body\")\n     }\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {\n         bug!(\"item_body_nested_bodies\")"}, {"sha": "bfb72b5df7b2e7143d9dc058490c12f2444f375b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -1307,10 +1307,11 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n             write!(fmt, \"b\\\"{}\\\"\", escaped)\n         }\n         Bool(b) => write!(fmt, \"{:?}\", b),\n+        Char(c) => write!(fmt, \"{:?}\", c),\n+        Variant(def_id) |\n         Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n         Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n             bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n-        Char(c) => write!(fmt, \"{:?}\", c),\n     }\n }\n "}, {"sha": "4247bff0f50268bc8e6cbab39a8b1dcee4a020b4", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -16,6 +16,7 @@ use middle::privacy::AccessLevels;\n use mir;\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::subst::Substs;\n use util::nodemap::NodeSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -74,6 +75,15 @@ impl Key for (CrateNum, DefId) {\n     }\n }\n \n+impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -217,6 +227,13 @@ impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n+    fn describe(tcx: TyCtxt, (def_id, _): (DefId, &'tcx Substs<'tcx>)) -> String {\n+        format!(\"const-evaluating `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -446,16 +463,17 @@ define_maps! { <'tcx>\n     /// (Defined only for LOCAL_CRATE)\n     pub crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n \n-    /// Results of evaluating monomorphic constants embedded in\n-    /// other items, such as enum variant explicit discriminants.\n-    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> const_val::EvalResult<'tcx>,\n+    /// Results of evaluating const items or constants embedded in\n+    /// other items (such as enum variant explicit discriminants).\n+    pub const_eval: const_eval_dep_node((DefId, &'tcx Substs<'tcx>))\n+        -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n     pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n     pub reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    pub mir_shims: mir_shim(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n+    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -470,10 +488,14 @@ fn reachability_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Reachability\n }\n \n-fn mir_shim(instance: ty::InstanceDef) -> DepNode<DefId> {\n+fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepNode<DefId> {\n     instance.dep_node()\n }\n \n fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::TypeckBodiesKrate\n }\n+\n+fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n+    DepNode::ConstEval(def_id)\n+}"}, {"sha": "cc5eb768d9b3254e923dbe0c52a1586394d84359", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -1693,6 +1693,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    #[inline]\n     pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                          -> impl Iterator<Item=ConstInt> + 'a {\n         let repr_type = self.repr.discr_type();\n@@ -1701,11 +1702,18 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.variants.iter().map(move |v| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n+                let substs = Substs::empty();\n+                match queries::const_eval::get(tcx, DUMMY_SP, (expr_did, substs)) {\n                     Ok(ConstVal::Integral(v)) => {\n                         discr = v;\n                     }\n-                    _ => {}\n+                    err => {\n+                        if !expr_did.is_local() {\n+                            span_bug!(tcx.def_span(expr_did),\n+                                \"variant discriminant evaluation succeeded \\\n+                                 in its crate but failed locally: {:?}\", err);\n+                        }\n+                    }\n                 }\n             }\n             prev_discr = Some(discr);\n@@ -1733,12 +1741,21 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     explicit_index -= distance;\n                 }\n                 ty::VariantDiscr::Explicit(expr_did) => {\n-                    match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n+                    let substs = Substs::empty();\n+                    match queries::const_eval::get(tcx, DUMMY_SP, (expr_did, substs)) {\n                         Ok(ConstVal::Integral(v)) => {\n                             explicit_value = v;\n                             break;\n                         }\n-                        _ => {\n+                        err => {\n+                            if !expr_did.is_local() {\n+                                span_bug!(tcx.def_span(expr_did),\n+                                    \"variant discriminant evaluation succeeded \\\n+                                     in its crate but failed locally: {:?}\", err);\n+                            }\n+                            if explicit_index == 0 {\n+                                break;\n+                            }\n                             explicit_index -= 1;\n                         }\n                     }"}, {"sha": "e9352f53c92d68c724d5934465cc9ebe202a2abc", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 115, "deletions": 149, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::const_val::{ConstVal, ConstEvalErr, EvalResult, ErrKind};\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n@@ -48,110 +48,39 @@ macro_rules! math {\n     }\n }\n \n-fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  variant_def: DefId)\n-                                  -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)> {\n-    if let Some(variant_node_id) = tcx.hir.as_local_node_id(variant_def) {\n-        let enum_node_id = tcx.hir.get_parent(variant_node_id);\n-        if let Some(hir_map::NodeItem(it)) = tcx.hir.find(enum_node_id) {\n-            if let hir::ItemEnum(ref edef, _) = it.node {\n-                for variant in &edef.variants {\n-                    if variant.node.data.id() == variant_node_id {\n-                        return variant.node.disr_expr.map(|e| {\n-                            let def_id = tcx.hir.body_owner_def_id(e);\n-                            (&tcx.hir.body(e).value,\n-                             tcx.item_tables(def_id))\n-                        });\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    None\n-}\n-\n /// * `def_id` is the id of the constant.\n /// * `substs` is the monomorphized substitutions for the expression.\n ///\n /// `substs` is optional and is used for associated constants.\n /// This generally happens in late/trans const evaluation.\n-pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        def_id: DefId,\n-                                        substs: &'tcx Substs<'tcx>)\n-                                        -> Option<(&'tcx Expr,\n-                                                   &'a ty::TypeckTables<'tcx>)> {\n+pub fn lookup_const_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    def_id: DefId,\n+                                    substs: &'tcx Substs<'tcx>)\n+                                    -> Option<(DefId, &'tcx Substs<'tcx>)> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         match tcx.hir.find(node_id) {\n-            None => None,\n-            Some(hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemConst(_, body), ..\n-            })) |\n-            Some(hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Const(_, body), ..\n-            })) => {\n-                Some((&tcx.hir.body(body).value,\n-                      tcx.item_tables(def_id)))\n+            Some(hir_map::NodeTraitItem(_)) => {\n+                // If we have a trait item and the substitutions for it,\n+                // `resolve_trait_associated_const` will select an impl\n+                // or the default.\n+                resolve_trait_associated_const(tcx, def_id, substs)\n             }\n-            Some(hir_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::TraitItemKind::Const(_, default) => {\n-                    // If we have a trait item and the substitutions for it,\n-                    // `resolve_trait_associated_const` will select an impl\n-                    // or the default.\n-                    let trait_id = tcx.hir.get_parent(node_id);\n-                    let trait_id = tcx.hir.local_def_id(trait_id);\n-                    let default_value = default.map(|body| {\n-                        (&tcx.hir.body(body).value,\n-                            tcx.item_tables(def_id))\n-                    });\n-                    resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n-                }\n-                _ => None\n-            },\n-            Some(_) => None\n+            _ => Some((def_id, substs))\n         }\n     } else {\n-        let expr_and_tables = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-            (&body.value, tcx.item_tables(def_id))\n-        });\n         match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n-                let trait_id = tcx.sess.cstore.trait_of_item(def_id);\n                 // As mentioned in the comments above for in-crate\n                 // constants, we only try to find the expression for a\n                 // trait-associated const if the caller gives us the\n                 // substitutions for the reference to it.\n-                if let Some(trait_id) = trait_id {\n-                    resolve_trait_associated_const(tcx, def_id, expr_and_tables,\n-                                                   trait_id, substs)\n+                if tcx.sess.cstore.trait_of_item(def_id).is_some() {\n+                    resolve_trait_associated_const(tcx, def_id, substs)\n                 } else {\n-                    expr_and_tables\n+                    Some((def_id, substs))\n                 }\n-            },\n-            Some(Def::Const(..)) => expr_and_tables,\n-            _ => None\n-        }\n-    }\n-}\n-\n-fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> Option<(&'tcx hir::Body, &'a ty::TypeckTables<'tcx>)>\n-{\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        FnLikeNode::from_node(tcx.hir.get(node_id)).and_then(|fn_like| {\n-            if fn_like.constness() == hir::Constness::Const {\n-                Some((tcx.hir.body(fn_like.body()),\n-                      tcx.item_tables(def_id)))\n-            } else {\n-                None\n             }\n-        })\n-    } else {\n-        if tcx.sess.cstore.is_const_fn(def_id) {\n-            tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-                (body, tcx.item_tables(def_id))\n-            })\n-        } else {\n-            None\n+            _ => Some((def_id, substs))\n         }\n     }\n }\n@@ -338,9 +267,22 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprCast(ref base, _) => {\n-        match cast_const(tcx, cx.eval(base)?, ety) {\n-            Ok(val) => val,\n-            Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n+        let base_val = cx.eval(base)?;\n+        let base_ty = cx.tables.expr_ty(base);\n+\n+        // Avoid applying substitutions if they're empty, that'd ICE.\n+        let base_ty = if cx.substs.is_empty() {\n+            base_ty\n+        } else {\n+            base_ty.subst(tcx, cx.substs)\n+        };\n+        if ety == base_ty {\n+            base_val\n+        } else {\n+            match cast_const(tcx, base_val, ety) {\n+                Ok(val) => val,\n+                Err(kind) => signal!(e, kind),\n+            }\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n@@ -357,42 +299,29 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           match cx.tables.qpath_def(qpath, e.id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n-                  if let Some((expr, tables)) = lookup_const_by_id(tcx, def_id, substs) {\n-                      let cx = ConstContext::with_tables(tcx, tables);\n-                      match cx.eval(expr) {\n-                          Ok(val) => val,\n-                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n-                              signal!(e, TypeckError);\n-                          }\n-                          Err(err) => {\n-                              debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n-                              signal!(e, ErroneousReferencedConstant(box err))\n-                          },\n-                      }\n-                  } else {\n-                      signal!(e, TypeckError);\n-                  }\n+                    match ty::queries::const_eval::get(tcx, e.span, (def_id, substs)) {\n+                        Ok(val) => val,\n+                        Err(ConstEvalErr { kind: TypeckError, .. }) => {\n+                            signal!(e, TypeckError);\n+                        }\n+                        Err(err) => {\n+                            debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n+                            signal!(e, ErroneousReferencedConstant(box err))\n+                        },\n+                    }\n               },\n-              Def::VariantCtor(variant_def, ..) => {\n-                  if let Some((expr, tables)) = lookup_variant_by_id(tcx, variant_def) {\n-                      let cx = ConstContext::with_tables(tcx, tables);\n-                      match cx.eval(expr) {\n-                          Ok(val) => val,\n-                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n-                              signal!(e, TypeckError);\n-                          }\n-                          Err(err) => {\n-                              debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n-                              signal!(e, ErroneousReferencedConstant(box err))\n-                          },\n-                      }\n-                  } else {\n-                      signal!(e, UnimplementedConstVal(\"enum variants\"));\n-                  }\n+              Def::VariantCtor(variant_def, CtorKind::Const) => {\n+                Variant(variant_def)\n+              }\n+              Def::VariantCtor(_, CtorKind::Fn) => {\n+                  signal!(e, UnimplementedConstVal(\"enum variants\"));\n               }\n-              Def::StructCtor(..) => {\n+              Def::StructCtor(_, CtorKind::Const) => {\n                   ConstVal::Struct(Default::default())\n               }\n+              Def::StructCtor(_, CtorKind::Fn) => {\n+                  signal!(e, UnimplementedConstVal(\"tuple struct constructors\"))\n+              }\n               Def::Local(def_id) => {\n                   debug!(\"Def::Local({:?}): {:?}\", def_id, cx.fn_args);\n                   if let Some(val) = cx.fn_args.as_ref().and_then(|args| args.get(&def_id)) {\n@@ -407,14 +336,27 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let (did, substs) = match cx.eval(callee)? {\n-              Function(did, substs) => (did, substs),\n-              Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n-              callee => signal!(e, CallOn(callee)),\n+          let (def_id, substs) = match cx.eval(callee)? {\n+              Function(def_id, substs) => (def_id, substs),\n+              _ => signal!(e, TypeckError),\n           };\n-          let (body, tables) = match lookup_const_fn_by_id(tcx, did) {\n-              Some(x) => x,\n-              None => signal!(e, NonConstPath),\n+\n+          let body = if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+            if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+                if fn_like.constness() == hir::Constness::Const {\n+                    tcx.hir.body(fn_like.body())\n+                } else {\n+                    signal!(e, TypeckError)\n+                }\n+            } else {\n+                signal!(e, TypeckError)\n+            }\n+          } else {\n+            if tcx.sess.cstore.is_const_fn(def_id) {\n+                tcx.sess.cstore.item_body(tcx, def_id)\n+            } else {\n+                signal!(e, TypeckError)\n+            }\n           };\n \n           let arg_defs = body.arguments.iter().map(|arg| match arg.pat.node {\n@@ -434,7 +376,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           let callee_cx = ConstContext {\n             tcx: tcx,\n-            tables: tables,\n+            tables: tcx.item_tables(def_id),\n             substs: substs,\n             fn_args: Some(call_args)\n           };\n@@ -532,19 +474,16 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n     Ok(result)\n }\n \n-fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    trait_item_id: DefId,\n-    default_value: Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>,\n-    trait_id: DefId,\n-    rcvr_substs: &'tcx Substs<'tcx>\n-) -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>\n-{\n-    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n+fn resolve_trait_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                            def_id: DefId,\n+                                            substs: &'tcx Substs<'tcx>)\n+                                            -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+    let trait_item = tcx.associated_item(def_id);\n+    let trait_id = trait_item.container.id();\n+    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n     tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n@@ -569,12 +508,20 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n-                let name = tcx.associated_item(trait_item_id).name;\n+                let name = trait_item.name;\n                 let ac = tcx.associated_items(impl_data.impl_def_id)\n                     .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 match ac {\n-                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, Substs::empty()),\n-                    None => default_value,\n+                    // FIXME(eddyb) Use proper Instance resolution to\n+                    // get the correct Substs returned from here.\n+                    Some(ic) => Some((ic.def_id, Substs::empty())),\n+                    None => {\n+                        if trait_item.defaultness.has_value() {\n+                            Some((def_id, substs))\n+                        } else {\n+                            None\n+                        }\n+                    }\n                 }\n             }\n             _ => {\n@@ -615,7 +562,7 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             U8(u) => Ok(Char(u as char)),\n             _ => bug!(),\n         },\n-        _ => bug!(),\n+        _ => Err(CannotCast),\n     }\n }\n \n@@ -659,6 +606,11 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Bool(b) => cast_const_int(tcx, U8(b as u8), ty),\n         Float(f) => cast_const_float(tcx, f, ty),\n         Char(c) => cast_const_int(tcx, U32(c as u32), ty),\n+        Variant(v) => {\n+            let adt = tcx.lookup_adt_def(tcx.parent_def_id(v).unwrap());\n+            let idx = adt.variant_index_with_id(v);\n+            cast_const_int(tcx, adt.discriminant_for_variant(tcx, idx), ty)\n+        }\n         Function(..) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n         ByteStr(b) => match ty.sty {\n             ty::TyRawPtr(_) => {\n@@ -796,21 +748,35 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n-        monomorphic_const_eval,\n+        const_eval,\n         ..*providers\n     };\n }\n \n-fn monomorphic_const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    def_id: DefId)\n-                                    -> EvalResult<'tcx> {\n-    let cx = ConstContext::with_tables(tcx, tcx.item_tables(def_id));\n+fn const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        (def_id, substs): (DefId, &'tcx Substs<'tcx>))\n+                        -> EvalResult<'tcx> {\n+    let (def_id, substs) = if let Some(resolved) = lookup_const_by_id(tcx, def_id, substs) {\n+        resolved\n+    } else {\n+        return Err(ConstEvalErr {\n+            span: tcx.def_span(def_id),\n+            kind: TypeckError\n+        });\n+    };\n+\n+    let cx = ConstContext {\n+        tcx,\n+        tables: tcx.item_tables(def_id),\n+        substs: substs,\n+        fn_args: None\n+    };\n \n     let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n         ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n         tcx.hir.body(tcx.hir.body_owned_by(id))\n     } else {\n-        tcx.sess.cstore.maybe_get_item_body(tcx, def_id).unwrap()\n+        tcx.sess.cstore.item_body(tcx, def_id)\n     };\n     cx.eval(&body.value)\n }"}, {"sha": "0dfafeb6fb8362b95c7f8af1fc0953307e12e18e", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -116,6 +116,7 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::ByteStr(ref b) => write!(f, \"{:?}\", &b[..]),\n         ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n         ConstVal::Char(c) => write!(f, \"{:?}\", c),\n+        ConstVal::Variant(_) |\n         ConstVal::Struct(_) |\n         ConstVal::Tuple(_) |\n         ConstVal::Function(..) |\n@@ -587,11 +588,16 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let substs = self.tables.node_id_item_substs(id)\n                     .unwrap_or_else(|| tcx.intern_substs(&[]));\n                 match eval::lookup_const_by_id(tcx, def_id, substs) {\n-                    Some((const_expr, const_tables)) => {\n+                    Some((def_id, _substs)) => {\n                         // Enter the inlined constant's tables temporarily.\n                         let old_tables = self.tables;\n-                        self.tables = const_tables;\n-                        let pat = self.lower_const_expr(const_expr, pat_id, span);\n+                        self.tables = tcx.item_tables(def_id);\n+                        let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+                            tcx.hir.body(tcx.hir.body_owned_by(id))\n+                        } else {\n+                            tcx.sess.cstore.item_body(tcx, def_id)\n+                        };\n+                        let pat = self.lower_const_expr(&body.value, pat_id, span);\n                         self.tables = old_tables;\n                         return pat;\n                     }\n@@ -615,7 +621,12 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n         let const_cx = eval::ConstContext::with_tables(self.tcx.global_tcx(), self.tables);\n         match const_cx.eval(expr) {\n             Ok(value) => {\n-                PatternKind::Constant { value: value }\n+                if let ConstVal::Variant(def_id) = value {\n+                    let ty = self.tables.expr_ty(expr);\n+                    self.lower_variant_or_leaf(Def::Variant(def_id), ty, vec![])\n+                } else {\n+                    PatternKind::Constant { value: value }\n+                }\n             }\n             Err(e) => {\n                 self.errors.push(PatternError::ConstEval(e));"}, {"sha": "9e6a45e7f8b7c68ddfed3850f607392154f616e4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -420,19 +420,18 @@ impl CrateStore for cstore::CStore {\n         })\n     }\n \n-    fn maybe_get_item_body<'a, 'tcx>(&self,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> Option<&'tcx hir::Body>\n-    {\n+    fn item_body<'a, 'tcx>(&self,\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> &'tcx hir::Body {\n         if let Some(cached) = tcx.hir.get_inlined_body(def_id) {\n-            return Some(cached);\n+            return cached;\n         }\n \n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        debug!(\"maybe_get_item_body({}): inlining item\", tcx.item_path_str(def_id));\n+        debug!(\"item_body({}): inlining item\", tcx.item_path_str(def_id));\n \n-        self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index)\n+        self.get_crate_data(def_id.krate).item_body(tcx, def_id.index)\n     }\n \n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {"}, {"sha": "a9eae5281b241fa3ede78cdb699560f798ae501a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -750,16 +750,15 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn maybe_get_item_body(&self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               id: DefIndex)\n-                               -> Option<&'tcx hir::Body> {\n-        if self.is_proc_macro(id) { return None; }\n-        self.entry(id).ast.map(|ast| {\n-            let def_id = self.local_def_id(id);\n-            let body = ast.decode(self).body.decode(self);\n-            tcx.hir.intern_inlined_body(def_id, body)\n-        })\n+    pub fn item_body(&self,\n+                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     id: DefIndex)\n+                     -> &'tcx hir::Body {\n+        assert!(!self.is_proc_macro(id));\n+        let ast = self.entry(id).ast.unwrap();\n+        let def_id = self.local_def_id(id);\n+        let body = ast.decode(self).body.decode(self);\n+        tcx.hir.intern_inlined_body(def_id, body)\n     }\n \n     pub fn item_body_tables(&self,"}, {"sha": "736c076ea15446cb4b510cafb72e434290df6fef", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -593,7 +593,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, count) => {\n             let c = &cx.tcx.hir.body(count).value;\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n-            let count = match ty::queries::monomorphic_const_eval::get(cx.tcx, c.span, def_id) {\n+            let substs = Substs::empty();\n+            let count = match ty::queries::const_eval::get(cx.tcx, c.span, (def_id, substs)) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")"}, {"sha": "040194e63d07e0ec6f549244ec495d3f3951abae", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -100,15 +100,13 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n+            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n+            ConstVal::Function(..) => C_null(type_of::type_of(ccx, ty)),\n+            ConstVal::Variant(_) |\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |\n             ConstVal::Array(..) | ConstVal::Repeat(..) => {\n                 bug!(\"MIR must not use `{:?}` (aggregates are expanded to MIR rvalues)\", cv)\n             }\n-            ConstVal::Function(..) => {\n-                let llty = type_of::type_of(ccx, ty);\n-                return Const::new(C_null(llty), ty);\n-            }\n-            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n         };\n \n         assert!(!ty.has_erasable_regions());"}, {"sha": "660ce837043c1d02d6481d4396325e958730ed27", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -555,7 +555,8 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n-            let result = ty::queries::monomorphic_const_eval::get(tcx, variant.span, expr_did);\n+            let substs = Substs::empty();\n+            let result = ty::queries::const_eval::get(tcx, variant.span, (expr_did, substs));\n \n             // enum variant evaluation happens before the global constant check\n             // so we need to report the real error"}, {"sha": "6016fd488f56c8938e025e8c1783e85bde6d59ea", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -487,7 +487,7 @@ impl hir::print::PpAnn for InlinedConst {\n }\n \n fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    let body = cx.tcx.sess.cstore.maybe_get_item_body(cx.tcx, did).unwrap();\n+    let body = cx.tcx.sess.cstore.item_body(cx.tcx, did);\n     let inlined = InlinedConst {\n         nested_bodies: cx.tcx.sess.cstore.item_body_nested_bodies(did)\n     };"}, {"sha": "0745ac02d0723e620e82856f217cf666e1a21175", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -17,6 +17,4 @@ fn f(x: usize) -> usize {\n fn main() {\n     let _ = [0; f(2)];\n     //~^ ERROR calls in constants are limited to constant functions\n-    //~| ERROR constant evaluation error [E0080]\n-    //~| non-constant path in constant expression\n }"}, {"sha": "71cac3edbc188beb9542952db26707d3d81c05d0", "filename": "src/test/compile-fail/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -10,21 +10,22 @@\n \n #![feature(const_fn)]\n \n+#[derive(PartialEq, Eq)]\n enum Cake {\n     BlackForest,\n     Marmor,\n }\n use Cake::*;\n \n-const BOO: (Cake, Cake) = (Marmor, BlackForest);\n+struct Pair<A, B>(A, B);\n+\n+const BOO: Pair<Cake, Cake> = Pair(Marmor, BlackForest);\n //~^ ERROR: constant evaluation error [E0080]\n-//~| unimplemented constant expression: enum variants\n+//~| unimplemented constant expression: tuple struct constructors\n const FOO: Cake = BOO.1;\n \n const fn foo() -> Cake {\n     Marmor\n-        //~^ ERROR: constant evaluation error [E0080]\n-        //~| unimplemented constant expression: enum variants\n }\n \n const WORKS: Cake = Marmor;\n@@ -34,7 +35,7 @@ const GOO: Cake = foo();\n fn main() {\n     match BlackForest {\n         FOO => println!(\"hi\"), //~ NOTE: for pattern here\n-        GOO => println!(\"meh\"), //~ NOTE: for pattern here\n+        GOO => println!(\"meh\"),\n         WORKS => println!(\"m\u00f6p\"),\n         _ => println!(\"bye\"),\n     }"}, {"sha": "b7f767f109c0c7437ce421135f1c358bb7c16cfa", "filename": "src/test/compile-fail/issue-39559.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -28,10 +28,6 @@ pub struct Vector<T, D: Dim> {\n fn main() {\n     let array: [usize; Dim3::dim()]\n     //~^ ERROR calls in constants are limited to constant functions\n-    //~| ERROR constant evaluation error\n-    //~| non-constant path in constant expression\n         = [0; Dim3::dim()];\n         //~^ ERROR calls in constants are limited to constant functions\n-        //~| ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n }"}, {"sha": "1fb3b7c4ee120011142d88e045e36e8611977e6f", "filename": "src/test/compile-fail/issue-41394.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo {\n+    A = \"\" + 1\n+    //~^ ERROR binary operation `+` cannot be applied to type `&'static str`\n+}\n+\n+enum Bar {\n+    A = Foo::A as isize\n+}\n+\n+fn main() {}"}, {"sha": "f06b81279ac4135658dc7f343dbb087279aec110", "filename": "src/test/run-pass/auxiliary/issue-41394.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-41394.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+#[repr(u32)]\n+pub enum Foo {\n+    Foo = Private::Variant as u32\n+}\n+\n+#[repr(u8)]\n+enum Private {\n+    Variant = 42\n+}\n+\n+#[inline(always)]\n+pub fn foo() -> Foo {\n+    Foo::Foo\n+}"}, {"sha": "104ab6e19db672db5e51b2bf8001b9a4b821cdf8", "filename": "src/test/run-pass/const-pattern-variant.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Frun-pass%2Fconst-pattern-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Frun-pass%2Fconst-pattern-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-pattern-variant.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+#[derive(PartialEq, Eq)]\n+enum Cake {\n+    BlackForest,\n+    Marmor,\n+}\n+use Cake::*;\n+\n+const BOO: (Cake, Cake) = (Marmor, BlackForest);\n+const FOO: Cake = BOO.1;\n+\n+const fn foo() -> Cake {\n+    Marmor\n+}\n+\n+const WORKS: Cake = Marmor;\n+\n+const GOO: Cake = foo();\n+\n+fn main() {\n+    match BlackForest {\n+        FOO => println!(\"hi\"),\n+        GOO => println!(\"meh\"),\n+        WORKS => println!(\"m\u00f6p\"),\n+        _ => println!(\"bye\"),\n+    }\n+}"}, {"sha": "3f5546ce83ddf49a79c3daf69dc7b9f7f31b352a", "filename": "src/test/run-pass/issue-23898.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Frun-pass%2Fissue-23898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Frun-pass%2Fissue-23898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23898.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Note: This test is checking that we forbid a coding pattern that\n-// Issue #5873 explicitly wants to allow.\n+// Note: This test was used to demonstrate #5873 (now #23898).\n \n enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n     [State::ST_NULL; (State::ST_WHITESPACE as usize)];\n-    //~^ ERROR constant evaluation error\n-    //~| unimplemented constant expression: enum variants\n }", "previous_filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs"}, {"sha": "798905599a852f73b364863c22aec70e6d3701bd", "filename": "src/test/run-pass/issue-41394.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Frun-pass%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23de823e93dc19ef1b9cb65b48860a892cd6ff18/src%2Ftest%2Frun-pass%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41394.rs?ref=23de823e93dc19ef1b9cb65b48860a892cd6ff18", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-41394.rs\n+\n+extern crate issue_41394 as lib;\n+\n+fn main() {\n+    assert_eq!(lib::foo() as u32, 42);\n+}"}]}