{"sha": "4c65a86571420ba79bc00028460e9625484e151a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNjVhODY1NzE0MjBiYTc5YmMwMDAyODQ2MGU5NjI1NDg0ZTE1MWE=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-28T12:34:58Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-30T19:35:45Z"}, "message": "JSON cleanup\n\n* Tried to make the code more idiomatic\n* Renamed the `wr` field of the `Encoder` and `PrettyEncoder` structs to `writer`\n* Replaced some `from_utf8` by `from_utf8_owned` to avoid unnecessary allocations\n* Removed unnecessary `unsafe` code", "tree": {"sha": "3f9888ebe6260e31600c8a977a124404d3e2d7d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f9888ebe6260e31600c8a977a124404d3e2d7d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c65a86571420ba79bc00028460e9625484e151a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c65a86571420ba79bc00028460e9625484e151a", "html_url": "https://github.com/rust-lang/rust/commit/4c65a86571420ba79bc00028460e9625484e151a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c65a86571420ba79bc00028460e9625484e151a/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94343da1bdf4de84d0ece90d920400697ad7e143", "url": "https://api.github.com/repos/rust-lang/rust/commits/94343da1bdf4de84d0ece90d920400697ad7e143", "html_url": "https://github.com/rust-lang/rust/commit/94343da1bdf4de84d0ece90d920400697ad7e143"}], "stats": {"total": 447, "additions": 184, "deletions": 263}, "files": [{"sha": "0cbfd938e8c9bb8398fceb6f71b79a1e67b90cf8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 184, "deletions": 263, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/4c65a86571420ba79bc00028460e9625484e151a/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c65a86571420ba79bc00028460e9625484e151a/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=4c65a86571420ba79bc00028460e9625484e151a", "patch": "@@ -227,17 +227,13 @@ fn main() {\n \n */\n \n-use std::char;\n+use std;\n use std::collections::{HashMap, TreeMap};\n-use std::f64;\n-use std::fmt;\n+use std::{char, f64, fmt, io, num, str};\n use std::io::MemWriter;\n-use std::io;\n-use std::mem::{swap,transmute};\n+use std::mem::{swap, transmute};\n use std::num::{FPNaN, FPInfinite};\n-use std::num;\n use std::str::ScalarValue;\n-use std::str;\n use std::string::String;\n use std::vec::Vec;\n \n@@ -324,7 +320,6 @@ impl fmt::Show for ErrorCode {\n     }\n }\n \n-\n fn io_error_to_error(io: io::IoError) -> ParserError {\n     IoError(io.kind, io.desc)\n }\n@@ -363,41 +358,38 @@ fn spaces(n: uint) -> String {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n-    wr: &'a mut io::Writer,\n+    writer: &'a mut io::Writer,\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n-    pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n-        Encoder { wr: wr }\n+    pub fn new(writer: &'a mut io::Writer) -> Encoder<'a> {\n+        Encoder { writer: writer }\n     }\n \n     /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> Vec<u8>  {\n-       //Serialize the object in a string using a writer\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(object: &T) -> Vec<u8>  {\n+        //Serialize the object in a string using a writer\n         let mut m = MemWriter::new();\n         // FIXME(14302) remove the transmute and unsafe block.\n         unsafe {\n             let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n             // MemWriter never Errs\n-            let _ = to_encode_object.encode(transmute(&mut encoder));\n+            let _ = object.encode(transmute(&mut encoder));\n         }\n         m.unwrap()\n     }\n \n     /// Encode the specified struct into a json str\n-    pub fn str_encode<T:Encodable<Encoder<'a>,\n-                        io::IoError>>(\n-                      to_encode_object: &T)\n-                      -> String {\n-        let buff = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8(buff.as_slice()).unwrap().to_string()\n+    pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n+        let buff = Encoder::buffer_encode(object);\n+        str::from_utf8_owned(buff).unwrap()\n     }\n }\n \n impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n-    fn emit_nil(&mut self) -> EncodeResult { write!(self.wr, \"null\") }\n+    fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n@@ -413,27 +405,27 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n-            write!(self.wr, \"true\")\n+            write!(self.writer, \"true\")\n         } else {\n-            write!(self.wr, \"false\")\n+            write!(self.writer, \"false\")\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.wr, \"{}\", fmt_number_or_null(v))\n+        write!(self.writer, \"{}\", fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n \n     fn emit_char(&mut self, v: char) -> EncodeResult {\n         self.emit_str(str::from_char(v).as_slice())\n     }\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        write!(self.wr, \"{}\", escape_str(v))\n+        write!(self.writer, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self,\n-                 _name: &str,\n-                 f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult { f(self) }\n+    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+        f(self)\n+    }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n@@ -444,21 +436,21 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            write!(self.wr, \"{}\", escape_str(name))\n+            write!(self.writer, \"{}\", escape_str(name))\n         } else {\n-            try!(write!(self.wr, \"{{\\\"variant\\\":\"));\n-            try!(write!(self.wr, \"{}\", escape_str(name)));\n-            try!(write!(self.wr, \",\\\"fields\\\":[\"));\n+            try!(write!(self.writer, \"{{\\\"variant\\\":\"));\n+            try!(write!(self.writer, \"{}\", escape_str(name)));\n+            try!(write!(self.writer, \",\\\"fields\\\":[\"));\n             try!(f(self));\n-            write!(self.wr, \"]}}\")\n+            write!(self.writer, \"]}}\")\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n-            try!(write!(self.wr, \",\"));\n+            try!(write!(self.writer, \",\"));\n         }\n         f(self)\n     }\n@@ -482,17 +474,17 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n                    _: &str,\n                    _: uint,\n                    f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \"{{\"));\n+        try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n-        write!(self.wr, \"}}\")\n+        write!(self.writer, \"}}\")\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n                          f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        if idx != 0 { try!(write!(self.wr, \",\")); }\n-        try!(write!(self.wr, \"{}:\", escape_str(name)));\n+        if idx != 0 { try!(write!(self.writer, \",\")); }\n+        try!(write!(self.writer, \"{}:\", escape_str(name)));\n         f(self)\n     }\n \n@@ -526,29 +518,28 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n     }\n \n     fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \"[\"));\n+        try!(write!(self.writer, \"[\"));\n         try!(f(self));\n-        write!(self.wr, \"]\")\n+        write!(self.writer, \"]\")\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n-            try!(write!(self.wr, \",\"));\n+            try!(write!(self.writer, \",\"));\n         }\n         f(self)\n     }\n \n     fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \"{{\"));\n+        try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n-        write!(self.wr, \"}}\")\n+        write!(self.writer, \"}}\")\n     }\n \n     fn emit_map_elt_key(&mut self,\n                         idx: uint,\n                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        use std::str::from_utf8;\n-        if idx != 0 { try!(write!(self.wr, \",\")) }\n+        if idx != 0 { try!(write!(self.writer, \",\")) }\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n@@ -557,43 +548,39 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n             let mut check_encoder = Encoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let buf = buf.unwrap();\n-        let out = from_utf8(buf.as_slice()).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' &&\n-            out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        let out = str::from_utf8_owned(buf.unwrap()).unwrap();\n+        let out = out.as_slice();\n+        let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         Ok(())\n     }\n \n     fn emit_map_elt_val(&mut self,\n                         _idx: uint,\n                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \":\"));\n+        try!(write!(self.writer, \":\"));\n         f(self)\n     }\n }\n \n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder<'a> {\n-    wr: &'a mut io::Writer,\n+    writer: &'a mut io::Writer,\n     indent: uint,\n }\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n-        PrettyEncoder {\n-            wr: wr,\n-            indent: 0,\n-        }\n+    pub fn new<'a>(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+        PrettyEncoder { writer: writer, indent: 0 }\n     }\n }\n \n impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n-    fn emit_nil(&mut self) -> EncodeResult { write!(self.wr, \"null\") }\n+    fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n@@ -609,14 +596,14 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n-            write!(self.wr, \"true\")\n+            write!(self.writer, \"true\")\n         } else {\n-            write!(self.wr, \"false\")\n+            write!(self.writer, \"false\")\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.wr, \"{}\", fmt_number_or_null(v))\n+        write!(self.writer, \"{}\", fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n         self.emit_f64(v as f64)\n@@ -626,7 +613,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         self.emit_str(str::from_char(v).as_slice())\n     }\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        write!(self.wr, \"{}\", escape_str(v))\n+        write!(self.writer, \"{}\", escape_str(v))\n     }\n \n     fn emit_enum(&mut self,\n@@ -641,24 +628,24 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                          cnt: uint,\n                          f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if cnt == 0 {\n-            write!(self.wr, \"{}\", escape_str(name))\n+            write!(self.writer, \"{}\", escape_str(name))\n         } else {\n             self.indent += 2;\n-            try!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n+            try!(write!(self.writer, \"[\\n{}{},\\n\", spaces(self.indent),\n                           escape_str(name)));\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}]\", spaces(self.indent))\n+            write!(self.writer, \"\\n{}]\", spaces(self.indent))\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n-            try!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n@@ -683,13 +670,13 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                    len: uint,\n                    f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            write!(self.wr, \"{{}}\")\n+            write!(self.writer, \"{{}}\")\n         } else {\n-            try!(write!(self.wr, \"{{\"));\n+            try!(write!(self.writer, \"{{\"));\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}}}\", spaces(self.indent))\n+            write!(self.writer, \"\\n{}}}\", spaces(self.indent))\n         }\n     }\n \n@@ -698,11 +685,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                          idx: uint,\n                          f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.writer, \"\\n\"));\n         } else {\n-            try!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n+        try!(write!(self.writer, \"{}{}: \", spaces(self.indent), escape_str(name)));\n         f(self)\n     }\n \n@@ -741,52 +728,51 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                 len: uint,\n                 f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            write!(self.wr, \"[]\")\n+            write!(self.writer, \"[]\")\n         } else {\n-            try!(write!(self.wr, \"[\"));\n+            try!(write!(self.writer, \"[\"));\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}]\", spaces(self.indent))\n+            write!(self.writer, \"\\n{}]\", spaces(self.indent))\n         }\n     }\n \n     fn emit_seq_elt(&mut self,\n                     idx: uint,\n                     f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.writer, \"\\n\"));\n         } else {\n-            try!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n     fn emit_map(&mut self,\n                 len: uint,\n                 f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            write!(self.wr, \"{{}}\")\n+            write!(self.writer, \"{{}}\")\n         } else {\n-            try!(write!(self.wr, \"{{\"));\n+            try!(write!(self.writer, \"{{\"));\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}}}\", spaces(self.indent))\n+            write!(self.writer, \"\\n{}}}\", spaces(self.indent))\n         }\n     }\n \n     fn emit_map_elt_key(&mut self,\n                         idx: uint,\n                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n-        use std::str::from_utf8;\n         if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.writer, \"\\n\"));\n         } else {\n-            try!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n@@ -795,20 +781,19 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             let mut check_encoder = PrettyEncoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let buf = buf.unwrap();\n-        let out = from_utf8(buf.as_slice()).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' &&\n-            out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        let out = str::from_utf8_owned(buf.unwrap()).unwrap();\n+        let out = out.as_slice();\n+        let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         Ok(())\n     }\n \n     fn emit_map_elt_val(&mut self,\n                         _idx: uint,\n                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \": \"));\n+        try!(write!(self.writer, \": \"));\n         f(self)\n     }\n }\n@@ -827,24 +812,24 @@ impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n }\n \n impl Json {\n-    /// Encodes a json value into an io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: &mut io::Writer) -> EncodeResult {\n-        let mut encoder = Encoder::new(wr);\n+    /// Encodes a json value into an io::writer. Uses a single line.\n+    pub fn to_writer(&self, writer: &mut io::Writer) -> EncodeResult {\n+        let mut encoder = Encoder::new(writer);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into an io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: &mut io::Writer) -> EncodeResult {\n-        let mut encoder = PrettyEncoder::new(wr);\n+    pub fn to_pretty_writer(&self, writer: &mut io::Writer) -> EncodeResult {\n+        let mut encoder = PrettyEncoder::new(writer);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> String {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8(s.unwrap().as_slice()).unwrap().to_string()\n+        str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -1038,27 +1023,24 @@ enum InternalStackElement {\n \n impl Stack {\n     pub fn new() -> Stack {\n-        Stack {\n-            stack: Vec::new(),\n-            str_buffer: Vec::new(),\n-        }\n+        Stack { stack: Vec::new(), str_buffer: Vec::new() }\n     }\n \n     /// Returns The number of elements in the Stack.\n     pub fn len(&self) -> uint { self.stack.len() }\n \n-    /// Returns true if the stack is empty, equivalent to self.len() == 0.\n-    pub fn is_empty(&self) -> bool { self.stack.len() == 0 }\n+    /// Returns true if the stack is empty.\n+    pub fn is_empty(&self) -> bool { self.stack.is_empty() }\n \n     /// Provides access to the StackElement at a given index.\n     /// lower indices are at the bottom of the stack while higher indices are\n     /// at the top.\n     pub fn get<'l>(&'l self, idx: uint) -> StackElement<'l> {\n-        return match *self.stack.get(idx) {\n-          InternalIndex(i) => { Index(i) }\n-          InternalKey(start, size) => {\n-            Key(str::from_utf8(self.str_buffer.slice(start as uint, (start+size) as uint)).unwrap())\n-          }\n+        match *self.stack.get(idx) {\n+            InternalIndex(i) => { Index(i) }\n+            InternalKey(start, size) => {\n+                Key(str::from_utf8(self.str_buffer.slice(start as uint, (start+size) as uint)).unwrap())\n+            }\n         }\n     }\n \n@@ -1124,9 +1106,7 @@ impl Stack {\n         match *self.stack.last().unwrap() {\n             InternalKey(_, sz) => {\n                 let new_size = self.str_buffer.len() - sz as uint;\n-                unsafe {\n-                    self.str_buffer.set_len(new_size);\n-                }\n+                self.str_buffer.truncate(new_size);\n             }\n             InternalIndex(_) => {}\n         }\n@@ -1146,8 +1126,8 @@ impl Stack {\n     fn bump_index(&mut self) {\n         let len = self.stack.len();\n         let idx = match *self.stack.last().unwrap() {\n-          InternalIndex(i) => { i + 1 }\n-          _ => { fail!(); }\n+            InternalIndex(i) => { i + 1 }\n+            _ => { fail!(); }\n         };\n         *self.stack.get_mut(len - 1) = InternalIndex(idx);\n     }\n@@ -1249,23 +1229,14 @@ impl<T: Iterator<char>> Parser<T> {\n             neg = -1.0;\n         }\n \n-        let mut res = match self.parse_integer() {\n-          Ok(res) => res,\n-          Err(e) => return Err(e)\n-        };\n+        let mut res = try!(self.parse_integer());\n \n         if self.ch_is('.') {\n-            match self.parse_decimal(res) {\n-              Ok(r) => res = r,\n-              Err(e) => return Err(e)\n-            }\n+            res = try!(self.parse_decimal(res));\n         }\n \n         if self.ch_is('e') || self.ch_is('E') {\n-            match self.parse_exponent(res) {\n-              Ok(r) => res = r,\n-              Err(e) => return Err(e)\n-            }\n+            res = try!(self.parse_exponent(res));\n         }\n \n         Ok(neg * res)\n@@ -1301,7 +1272,7 @@ impl<T: Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn parse_decimal(&mut self, res: f64) -> Result<f64, ParserError> {\n+    fn parse_decimal(&mut self, mut res: f64) -> Result<f64, ParserError> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -1310,7 +1281,6 @@ impl<T: Iterator<char>> Parser<T> {\n              _ => return self.error(InvalidNumber)\n         }\n \n-        let mut res = res;\n         let mut dec = 1.0;\n         while !self.eof() {\n             match self.ch_or_null() {\n@@ -1356,7 +1326,7 @@ impl<T: Iterator<char>> Parser<T> {\n             }\n         }\n \n-        let exp: f64 = num::pow(10u as f64, exp);\n+        let exp = num::pow(10_f64, exp);\n         if neg_exp {\n             res /= exp;\n         } else {\n@@ -1369,24 +1339,24 @@ impl<T: Iterator<char>> Parser<T> {\n     fn decode_hex_escape(&mut self) -> Result<u16, ParserError> {\n         let mut i = 0u;\n         let mut n = 0u16;\n-        while i < 4u && !self.eof() {\n+        while i < 4 && !self.eof() {\n             self.bump();\n             n = match self.ch_or_null() {\n-                c @ '0' .. '9' => n * 16_u16 + ((c as u16) - ('0' as u16)),\n-                'a' | 'A' => n * 16_u16 + 10_u16,\n-                'b' | 'B' => n * 16_u16 + 11_u16,\n-                'c' | 'C' => n * 16_u16 + 12_u16,\n-                'd' | 'D' => n * 16_u16 + 13_u16,\n-                'e' | 'E' => n * 16_u16 + 14_u16,\n-                'f' | 'F' => n * 16_u16 + 15_u16,\n+                c @ '0' .. '9' => n * 16 + ((c as u16) - ('0' as u16)),\n+                'a' | 'A' => n * 16 + 10,\n+                'b' | 'B' => n * 16 + 11,\n+                'c' | 'C' => n * 16 + 12,\n+                'd' | 'D' => n * 16 + 13,\n+                'e' | 'E' => n * 16 + 14,\n+                'f' | 'F' => n * 16 + 15,\n                 _ => return self.error(InvalidEscape)\n             };\n \n             i += 1u;\n         }\n \n         // Error out if we didn't parse 4 digits.\n-        if i != 4u {\n+        if i != 4 {\n             return self.error(InvalidEscape);\n         }\n \n@@ -1419,9 +1389,7 @@ impl<T: Iterator<char>> Parser<T> {\n                         // Non-BMP characters are encoded as a sequence of\n                         // two hex escapes, representing UTF-16 surrogates.\n                         n1 @ 0xD800 .. 0xDBFF => {\n-                            let c1 = self.next_char();\n-                            let c2 = self.next_char();\n-                            match (c1, c2) {\n+                            match (self.next_char(), self.next_char()) {\n                                 (Some('\\\\'), Some('u')) => (),\n                                 _ => return self.error(UnexpectedEndOfHexEscape),\n                             }\n@@ -1636,37 +1604,37 @@ impl<T: Iterator<char>> Parser<T> {\n                 }\n             }\n             self.bump();\n-            return ObjectEnd;\n+            ObjectEnd\n         } else if self.eof() {\n-            return self.error_event(EOFWhileParsingObject);\n+            self.error_event(EOFWhileParsingObject)\n         } else {\n-            return self.error_event(InvalidSyntax);\n+            self.error_event(InvalidSyntax)\n         }\n     }\n \n     fn parse_value(&mut self) -> JsonEvent {\n         if self.eof() { return self.error_event(EOFWhileParsingValue); }\n         match self.ch_or_null() {\n-            'n' => { return self.parse_ident(\"ull\", NullValue); }\n-            't' => { return self.parse_ident(\"rue\", BooleanValue(true)); }\n-            'f' => { return self.parse_ident(\"alse\", BooleanValue(false)); }\n-            '0' .. '9' | '-' => return match self.parse_number() {\n+            'n' => { self.parse_ident(\"ull\", NullValue) }\n+            't' => { self.parse_ident(\"rue\", BooleanValue(true)) }\n+            'f' => { self.parse_ident(\"alse\", BooleanValue(false)) }\n+            '0' .. '9' | '-' => match self.parse_number() {\n                 Ok(f) => NumberValue(f),\n                 Err(e) => Error(e),\n             },\n-            '\"' => return match self.parse_str() {\n+            '\"' => match self.parse_str() {\n                 Ok(s) => StringValue(s),\n                 Err(e) => Error(e),\n             },\n             '[' => {\n                 self.bump();\n-                return ListStart;\n+                ListStart\n             }\n             '{' => {\n                 self.bump();\n-                return ObjectStart;\n+                ObjectStart\n             }\n-            _ => { return self.error_event(InvalidSyntax); }\n+            _ => { self.error_event(InvalidSyntax) }\n         }\n     }\n \n@@ -1694,10 +1662,7 @@ pub struct Builder<T> {\n impl<T: Iterator<char>> Builder<T> {\n     /// Create a JSON Builder.\n     pub fn new(src: T) -> Builder<T> {\n-        Builder {\n-            parser: Parser::new(src),\n-            token: None,\n-        }\n+        Builder { parser: Parser::new(src), token: None, }\n     }\n \n     // Decode a Json value from a Parser.\n@@ -1710,7 +1675,7 @@ impl<T: Iterator<char>> Builder<T> {\n             Some(Error(e)) => { return Err(e); }\n             ref tok => { fail!(\"unexpected token {}\", tok.clone()); }\n         }\n-        return result;\n+        result\n     }\n \n     fn bump(&mut self) {\n@@ -1757,7 +1722,7 @@ impl<T: Iterator<char>> Builder<T> {\n \n         let mut values = box TreeMap::new();\n \n-        while self.token != None {\n+        loop {\n             match self.token {\n                 Some(ObjectEnd) => { return Ok(Object(values)); }\n                 Some(Error(e)) => { return Err(e); }\n@@ -1778,16 +1743,15 @@ impl<T: Iterator<char>> Builder<T> {\n     }\n }\n \n-\n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n     let contents = match rdr.read_to_end() {\n         Ok(c) => c,\n         Err(e) => return Err(io_error_to_error(e))\n     };\n-    let s = match str::from_utf8(contents.as_slice()) {\n-        Some(s) => s.to_string(),\n-        None => return Err(SyntaxError(NotUtf8, 0, 0))\n+    let s = match str::from_utf8_owned(contents) {\n+        Ok(s) => s,\n+        _ => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n     let mut builder = Builder::new(s.as_slice().chars());\n     builder.build()\n@@ -1796,7 +1760,7 @@ pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n /// Decodes a json value from a string\n pub fn from_str(s: &str) -> Result<Json, BuilderError> {\n     let mut builder = Builder::new(s.chars());\n-    return builder.build();\n+    builder.build()\n }\n \n /// A structure to decode JSON to values in rust.\n@@ -1807,9 +1771,7 @@ pub struct Decoder {\n impl Decoder {\n     /// Creates a new decoder instance for decoding the specified JSON value.\n     pub fn new(json: Json) -> Decoder {\n-        Decoder {\n-            stack: vec!(json),\n-        }\n+        Decoder { stack: vec![json] }\n     }\n }\n \n@@ -1841,8 +1803,7 @@ macro_rules! expect(\n impl ::Decoder<DecoderError> for Decoder {\n     fn read_nil(&mut self) -> DecodeResult<()> {\n         debug!(\"read_nil\");\n-        try!(expect!(self.pop(), Null));\n-        Ok(())\n+        expect!(self.pop(), Null)\n     }\n \n     fn read_u64(&mut self)  -> DecodeResult<u64 > { Ok(try!(self.read_f64()) as u64) }\n@@ -1859,28 +1820,24 @@ impl ::Decoder<DecoderError> for Decoder {\n \n     fn read_bool(&mut self) -> DecodeResult<bool> {\n         debug!(\"read_bool\");\n-        Ok(try!(expect!(self.pop(), Boolean)))\n+        expect!(self.pop(), Boolean)\n     }\n \n     fn read_f64(&mut self) -> DecodeResult<f64> {\n-        use std::from_str::FromStr;\n         debug!(\"read_f64\");\n         match self.pop() {\n             Number(f) => Ok(f),\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n-                // is going to have a string here, as per JSON spec..\n-                Ok(FromStr::from_str(s.as_slice()).unwrap())\n+                // is going to have a string here, as per JSON spec.\n+                Ok(std::from_str::from_str(s.as_slice()).unwrap())\n             },\n             Null => Ok(f64::NAN),\n-            value => {\n-                Err(ExpectedError(\"Number\".to_string(),\n-                                  format!(\"{}\", value)))\n-            }\n+            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n         }\n     }\n \n-    fn read_f32(&mut self) -> DecodeResult<f32> { Ok(try!(self.read_f64()) as f32) }\n+    fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n \n     fn read_char(&mut self) -> DecodeResult<char> {\n         let s = try!(self.read_str());\n@@ -1892,13 +1849,12 @@ impl ::Decoder<DecoderError> for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_string(),\n-                          format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n     }\n \n     fn read_str(&mut self) -> DecodeResult<String> {\n         debug!(\"read_str\");\n-        Ok(try!(expect!(self.pop(), String)))\n+        expect!(self.pop(), String)\n     }\n \n     fn read_enum<T>(&mut self,\n@@ -1919,8 +1875,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 let n = match o.pop(&\"variant\".to_string()) {\n                     Some(String(s)) => s,\n                     Some(val) => {\n-                        return Err(ExpectedError(\"String\".to_string(),\n-                                                 format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n                         return Err(MissingFieldError(\"variant\".to_string()))\n@@ -1929,12 +1884,11 @@ impl ::Decoder<DecoderError> for Decoder {\n                 match o.pop(&\"fields\".to_string()) {\n                     Some(List(l)) => {\n                         for field in l.move_iter().rev() {\n-                            self.stack.push(field.clone());\n+                            self.stack.push(field);\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"List\".to_string(),\n-                                                 format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"List\".to_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n                         return Err(MissingFieldError(\"fields\".to_string()))\n@@ -1943,14 +1897,11 @@ impl ::Decoder<DecoderError> for Decoder {\n                 n\n             }\n             json => {\n-                return Err(ExpectedError(\"String or Object\".to_string(),\n-                                         format!(\"{}\", json)))\n+                return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n         let idx = match names.iter()\n-                             .position(|n| {\n-                                 str::eq_slice(*n, name.as_slice())\n-                             }) {\n+                             .position(|n| str::eq_slice(*n, name.as_slice())) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -2093,48 +2044,18 @@ pub trait ToJson {\n     fn to_json(&self) -> Json;\n }\n \n-impl ToJson for Json {\n-    fn to_json(&self) -> Json { (*self).clone() }\n-}\n-\n-impl ToJson for int {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i8 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i16 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i32 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i64 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for uint {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for u8 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for u16 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n+macro_rules! to_json_impl(\n+    ($($t:ty), +) => (\n+        $(impl ToJson for $t {\n+            fn to_json(&self) -> Json { Number(*self as f64) }\n+        })+\n+    )\n+)\n \n-impl ToJson for u32 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n+to_json_impl!(int, i8, i16, i32, i64, uint, u8, u16, u32, u64)\n \n-impl ToJson for u64 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n+impl ToJson for Json {\n+    fn to_json(&self) -> Json { self.clone() }\n }\n \n impl ToJson for f32 {\n@@ -2145,7 +2066,7 @@ impl ToJson for f64 {\n     fn to_json(&self) -> Json {\n         match self.classify() {\n             FPNaN | FPInfinite => Null,\n-            _ => Number(*self)\n+            _                  => Number(*self)\n         }\n     }\n }\n@@ -2162,35 +2083,35 @@ impl ToJson for String {\n     fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n-impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n+impl<A: ToJson, B: ToJson> ToJson for (A, B) {\n     fn to_json(&self) -> Json {\n         match *self {\n-          (ref a, ref b) => {\n-            List(vec![a.to_json(), b.to_json()])\n-          }\n+            (ref a, ref b) => {\n+                List(vec![a.to_json(), b.to_json()])\n+            }\n         }\n     }\n }\n \n-impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n+impl<A: ToJson, B: ToJson, C: ToJson> ToJson for (A, B, C) {\n     fn to_json(&self) -> Json {\n         match *self {\n-          (ref a, ref b, ref c) => {\n-            List(vec![a.to_json(), b.to_json(), c.to_json()])\n-          }\n+            (ref a, ref b, ref c) => {\n+                List(vec![a.to_json(), b.to_json(), c.to_json()])\n+            }\n         }\n     }\n }\n \n-impl<'a, A:ToJson> ToJson for &'a [A] {\n+impl<'a, A: ToJson> ToJson for &'a [A] {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A:ToJson> ToJson for Vec<A> {\n+impl<A: ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A:ToJson> ToJson for TreeMap<String, A> {\n+impl<A: ToJson> ToJson for TreeMap<String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2200,7 +2121,7 @@ impl<A:ToJson> ToJson for TreeMap<String, A> {\n     }\n }\n \n-impl<A:ToJson> ToJson for HashMap<String, A> {\n+impl<A: ToJson> ToJson for HashMap<String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2213,8 +2134,8 @@ impl<A:ToJson> ToJson for HashMap<String, A> {\n impl<A:ToJson> ToJson for Option<A> {\n     fn to_json(&self) -> Json {\n         match *self {\n-          None => Null,\n-          Some(ref value) => value.to_json()\n+            None => Null,\n+            Some(ref value) => value.to_json()\n         }\n     }\n }\n@@ -2437,31 +2358,31 @@ mod tests {\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = Encoder::new(wr);\n+            with_str_writer(|writer| {\n+                let mut encoder = Encoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n             \"\\\"Dog\\\"\".to_string()\n         );\n         assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::new(wr);\n+            with_str_writer(|writer| {\n+                let mut encoder = PrettyEncoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n             \"\\\"Dog\\\"\".to_string()\n         );\n \n         let animal = Frog(\"Henry\".to_string(), 349);\n         assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = Encoder::new(wr);\n+            with_str_writer(|writer| {\n+                let mut encoder = Encoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n             \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_string()\n         );\n         assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::new(wr);\n+            with_str_writer(|writer| {\n+                let mut encoder = PrettyEncoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n             \"\\\n@@ -2476,15 +2397,15 @@ mod tests {\n     #[test]\n     fn test_write_some() {\n         let value = Some(\"jodhpurs\".to_string());\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n+        let s = with_str_writer(|writer| {\n+            let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"\\\"jodhpurs\\\"\".to_string());\n \n         let value = Some(\"jodhpurs\".to_string());\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = PrettyEncoder::new(wr);\n+        let s = with_str_writer(|writer| {\n+            let mut encoder = PrettyEncoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"\\\"jodhpurs\\\"\".to_string());\n@@ -2493,14 +2414,14 @@ mod tests {\n     #[test]\n     fn test_write_none() {\n         let value: Option<String> = None;\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n+        let s = with_str_writer(|writer| {\n+            let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"null\".to_string());\n \n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n+        let s = with_str_writer(|writer| {\n+            let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"null\".to_string());"}]}