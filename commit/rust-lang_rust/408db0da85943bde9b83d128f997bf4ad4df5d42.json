{"sha": "408db0da85943bde9b83d128f997bf4ad4df5d42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwOGRiMGRhODU5NDNiZGU5YjgzZDEyOGY5OTdiZjRhZDRkZjVkNDI=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T18:38:25Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-16T04:22:00Z"}, "message": "Take sys/vxworks/{os,path,pipe} from sys/unix instead.", "tree": {"sha": "5053d4d605127166fb3e8d9cee6483acecff4f89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5053d4d605127166fb3e8d9cee6483acecff4f89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/408db0da85943bde9b83d128f997bf4ad4df5d42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/408db0da85943bde9b83d128f997bf4ad4df5d42", "html_url": "https://github.com/rust-lang/rust/commit/408db0da85943bde9b83d128f997bf4ad4df5d42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/408db0da85943bde9b83d128f997bf4ad4df5d42/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71bb1dc2a09ffc7334f07248669a42faf2a784eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/71bb1dc2a09ffc7334f07248669a42faf2a784eb", "html_url": "https://github.com/rust-lang/rust/commit/71bb1dc2a09ffc7334f07248669a42faf2a784eb"}], "stats": {"total": 479, "additions": 33, "deletions": 446}, "files": [{"sha": "d5e14bec7657298e2d4ced4951a300c5fa81ab51", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/408db0da85943bde9b83d128f997bf4ad4df5d42/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/408db0da85943bde9b83d128f997bf4ad4df5d42/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=408db0da85943bde9b83d128f997bf4ad4df5d42", "patch": "@@ -37,7 +37,7 @@ cfg_if::cfg_if! {\n }\n \n extern \"C\" {\n-    #[cfg(not(target_os = \"dragonfly\"))]\n+    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\n     #[cfg_attr(\n         any(\n             target_os = \"linux\",\n@@ -67,18 +67,28 @@ extern \"C\" {\n }\n \n /// Returns the platform-specific value of errno\n-#[cfg(not(target_os = \"dragonfly\"))]\n+#[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\n pub fn errno() -> i32 {\n     unsafe { (*errno_location()) as i32 }\n }\n \n /// Sets the platform-specific value of errno\n-#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\")))] // needed for readdir and syscall!\n+#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n #[allow(dead_code)] // but not all target cfgs actually end up using it\n pub fn set_errno(e: i32) {\n     unsafe { *errno_location() = e as c_int }\n }\n \n+#[cfg(target_os = \"vxworks\")]\n+pub fn errno() -> i32 {\n+    unsafe { libc::errnoGet() }\n+}\n+\n+#[cfg(target_os = \"vxworks\")]\n+pub fn set_errno(e: i32) {\n+    unsafe { libc::errnoSet(e as c_int) };\n+}\n+\n #[cfg(target_os = \"dragonfly\")]\n pub fn errno() -> i32 {\n     extern \"C\" {\n@@ -439,6 +449,19 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     Err(io::Error::new(ErrorKind::Other, \"Not yet implemented!\"))\n }\n \n+#[cfg(target_os = \"vxworks\")]\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    #[cfg(test)]\n+    use realstd::env;\n+\n+    #[cfg(not(test))]\n+    use crate::env;\n+\n+    let exe_path = env::args().next().unwrap();\n+    let path = path::Path::new(&exe_path);\n+    path.canonicalize()\n+}\n+\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n@@ -568,7 +591,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"android\",\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     unsafe fn fallback() -> Option<OsString> {\n         None\n@@ -577,7 +601,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"android\",\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     )))]\n     unsafe fn fallback() -> Option<OsString> {\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {"}, {"sha": "c20edaa1a4778a3761129eae4b1f79f9b7db8e25", "filename": "library/std/src/sys/vxworks/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/408db0da85943bde9b83d128f997bf4ad4df5d42/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/408db0da85943bde9b83d128f997bf4ad4df5d42/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs?ref=408db0da85943bde9b83d128f997bf4ad4df5d42", "patch": "@@ -34,8 +34,11 @@ pub mod memchr;\n pub mod mutex;\n #[path = \"../unix/net.rs\"]\n pub mod net;\n+#[path = \"../unix/os.rs\"]\n pub mod os;\n+#[path = \"../unix/path.rs\"]\n pub mod path;\n+#[path = \"../unix/pipe.rs\"]\n pub mod pipe;\n pub mod process;\n pub mod rand;"}, {"sha": "6eaec6f1e50df3054c6edf27313940285f6e9eca", "filename": "library/std/src/sys/vxworks/os.rs", "status": "removed", "additions": 0, "deletions": 315, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -1,315 +0,0 @@\n-use crate::error::Error as StdError;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n-use crate::fmt;\n-use crate::io;\n-use crate::iter;\n-use crate::marker::PhantomData;\n-use crate::mem;\n-use crate::memchr;\n-use crate::path::{self, Path, PathBuf};\n-use crate::slice;\n-use crate::str;\n-use crate::sys::cvt;\n-use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n-use libc::{self, c_char /*,c_void */, c_int};\n-/*use sys::fd; this one is probably important */\n-use crate::vec;\n-\n-const TMPBUF_SZ: usize = 128;\n-\n-// This is a terrible fix\n-use crate::sys::os_str::Buf;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n-\n-pub trait OsStringExt {\n-    fn from_vec(vec: Vec<u8>) -> Self;\n-    fn into_vec(self) -> Vec<u8>;\n-}\n-\n-impl OsStringExt for OsString {\n-    fn from_vec(vec: Vec<u8>) -> OsString {\n-        FromInner::from_inner(Buf { inner: vec })\n-    }\n-    fn into_vec(self) -> Vec<u8> {\n-        self.into_inner().inner\n-    }\n-}\n-\n-pub trait OsStrExt {\n-    fn from_bytes(slice: &[u8]) -> &Self;\n-    fn as_bytes(&self) -> &[u8];\n-}\n-\n-impl OsStrExt for OsStr {\n-    fn from_bytes(slice: &[u8]) -> &OsStr {\n-        unsafe { mem::transmute(slice) }\n-    }\n-    fn as_bytes(&self) -> &[u8] {\n-        &self.as_inner().inner\n-    }\n-}\n-\n-pub fn errno() -> i32 {\n-    unsafe { libc::errnoGet() }\n-}\n-\n-pub fn set_errno(e: i32) {\n-    unsafe {\n-        libc::errnoSet(e as c_int);\n-    }\n-}\n-\n-/// Gets a detailed string description for the given error number.\n-pub fn error_string(errno: i32) -> String {\n-    let mut buf = [0 as c_char; TMPBUF_SZ];\n-    extern \"C\" {\n-        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t) -> c_int;\n-    }\n-\n-    let p = buf.as_mut_ptr();\n-    unsafe {\n-        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n-            panic!(\"strerror_r failure\");\n-        }\n-        let p = p as *const _;\n-        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n-    }\n-}\n-\n-pub fn getcwd() -> io::Result<PathBuf> {\n-    let mut buf = Vec::with_capacity(512);\n-    loop {\n-        unsafe {\n-            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n-            if !libc::getcwd(ptr, buf.capacity() as libc::size_t).is_null() {\n-                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n-                buf.set_len(len);\n-                buf.shrink_to_fit();\n-                return Ok(PathBuf::from(OsString::from_vec(buf)));\n-            } else {\n-                let error = io::Error::last_os_error();\n-                if error.raw_os_error() != Some(libc::ERANGE) {\n-                    return Err(error);\n-                }\n-            }\n-            // Trigger the internal buffer resizing logic of `Vec` by requiring\n-            // more space than the current capacity.\n-            let cap = buf.capacity();\n-            buf.set_len(cap);\n-            buf.reserve(1);\n-        }\n-    }\n-}\n-\n-pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let p: &OsStr = p.as_ref();\n-    let p = CString::new(p.as_bytes())?;\n-    unsafe {\n-        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n-            true => Ok(()),\n-            false => Err(io::Error::last_os_error()),\n-        }\n-    }\n-}\n-\n-pub struct SplitPaths<'a> {\n-    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>, fn(&'a [u8]) -> PathBuf>,\n-}\n-\n-pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n-    fn bytes_to_path(b: &[u8]) -> PathBuf {\n-        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n-    }\n-    fn is_colon(b: &u8) -> bool {\n-        *b == b':'\n-    }\n-    let unparsed = unparsed.as_bytes();\n-    SplitPaths {\n-        iter: unparsed\n-            .split(is_colon as fn(&u8) -> bool)\n-            .map(bytes_to_path as fn(&[u8]) -> PathBuf),\n-    }\n-}\n-\n-impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = PathBuf;\n-    fn next(&mut self) -> Option<PathBuf> {\n-        self.iter.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct JoinPathsError;\n-\n-pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-where\n-    I: Iterator<Item = T>,\n-    T: AsRef<OsStr>,\n-{\n-    let mut joined = Vec::new();\n-    let sep = b':';\n-\n-    for (i, path) in paths.enumerate() {\n-        let path = path.as_ref().as_bytes();\n-        if i > 0 {\n-            joined.push(sep)\n-        }\n-        if path.contains(&sep) {\n-            return Err(JoinPathsError);\n-        }\n-        joined.extend_from_slice(path);\n-    }\n-    Ok(OsStringExt::from_vec(joined))\n-}\n-\n-impl fmt::Display for JoinPathsError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        \"path segment contains separator `:`\".fmt(f)\n-    }\n-}\n-\n-impl StdError for JoinPathsError {\n-    #[allow(deprecated)]\n-    fn description(&self) -> &str {\n-        \"failed to join paths\"\n-    }\n-}\n-\n-pub fn current_exe() -> io::Result<PathBuf> {\n-    #[cfg(test)]\n-    use realstd::env;\n-\n-    #[cfg(not(test))]\n-    use crate::env;\n-\n-    let exe_path = env::args().next().unwrap();\n-    let path = Path::new(&exe_path);\n-    path.canonicalize()\n-}\n-\n-pub struct Env {\n-    iter: vec::IntoIter<(OsString, OsString)>,\n-    _dont_send_or_sync_me: PhantomData<*mut ()>,\n-}\n-\n-impl Iterator for Env {\n-    type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> {\n-        self.iter.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-pub unsafe fn environ() -> *mut *const *const c_char {\n-    extern \"C\" {\n-        static mut environ: *const *const c_char;\n-    }\n-    &mut environ\n-}\n-\n-pub unsafe fn env_lock() -> StaticMutexGuard {\n-    // It is UB to attempt to acquire this mutex reentrantly!\n-    static ENV_LOCK: StaticMutex = StaticMutex::new();\n-    ENV_LOCK.lock()\n-}\n-\n-/// Returns a vector of (variable, value) byte-vector pairs for all the\n-/// environment variables of the current process.\n-pub fn env() -> Env {\n-    unsafe {\n-        let _guard = env_lock();\n-        let mut environ = *environ();\n-        if environ.is_null() {\n-            panic!(\"os::env() failure getting env string from OS: {}\", io::Error::last_os_error());\n-        }\n-        let mut result = Vec::new();\n-        while !(*environ).is_null() {\n-            if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n-                result.push(key_value);\n-            }\n-            environ = environ.add(1);\n-        }\n-        return Env { iter: result.into_iter(), _dont_send_or_sync_me: PhantomData };\n-    }\n-\n-    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n-        // Strategy (copied from glibc): Variable name and value are separated\n-        // by an ASCII equals sign '='. Since a variable name must not be\n-        // empty, allow variable names starting with an equals sign. Skip all\n-        // malformed lines.\n-        if input.is_empty() {\n-            return None;\n-        }\n-        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n-        pos.map(|p| {\n-            (\n-                OsStringExt::from_vec(input[..p].to_vec()),\n-                OsStringExt::from_vec(input[p + 1..].to_vec()),\n-            )\n-        })\n-    }\n-}\n-\n-pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    // environment variables with a nul byte can't be set, so their value is\n-    // always None as well\n-    let k = CString::new(k.as_bytes())?;\n-    unsafe {\n-        let _guard = env_lock();\n-        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n-        let ret = if s.is_null() {\n-            None\n-        } else {\n-            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n-        };\n-        Ok(ret)\n-    }\n-}\n-\n-pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    let k = CString::new(k.as_bytes())?;\n-    let v = CString::new(v.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = env_lock();\n-        cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n-    }\n-}\n-\n-pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n-    let nbuf = CString::new(n.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = env_lock();\n-        cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n-    }\n-}\n-\n-pub fn page_size() -> usize {\n-    unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }\n-}\n-\n-pub fn temp_dir() -> PathBuf {\n-    crate::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| PathBuf::from(\"/tmp\"))\n-}\n-\n-pub fn home_dir() -> Option<PathBuf> {\n-    crate::env::var_os(\"HOME\").or_else(|| None).map(PathBuf::from)\n-}\n-\n-pub fn exit(code: i32) -> ! {\n-    unsafe { libc::exit(code as c_int) }\n-}\n-\n-pub fn getpid() -> u32 {\n-    unsafe { libc::getpid() as u32 }\n-}\n-\n-pub fn getppid() -> u32 {\n-    unsafe { libc::getppid() as u32 }\n-}"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "library/std/src/sys/vxworks/path.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpath.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -1,19 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::path::Prefix;\n-\n-#[inline]\n-pub fn is_sep_byte(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-#[inline]\n-pub fn is_verbatim_sep(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n-    None\n-}\n-\n-pub const MAIN_SEP_STR: &str = \"/\";\n-pub const MAIN_SEP: char = '/';"}, {"sha": "a18376212af51a32e8044194fa39892aced42b1d", "filename": "library/std/src/sys/vxworks/pipe.rs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpipe.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -1,107 +0,0 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::sync::atomic::AtomicBool;\n-use crate::sys::fd::FileDesc;\n-use crate::sys::{cvt, cvt_r};\n-use libc::{self /*, c_int apparently not used? */};\n-\n-pub struct AnonPipe(FileDesc);\n-\n-pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    static INVALID: AtomicBool = AtomicBool::new(false);\n-\n-    let mut fds = [0; 2];\n-    cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n-\n-    let fd0 = FileDesc::new(fds[0]);\n-    let fd1 = FileDesc::new(fds[1]);\n-    fd0.set_cloexec()?;\n-    fd1.set_cloexec()?;\n-    Ok((AnonPipe(fd0), AnonPipe(fd1)))\n-}\n-\n-impl AnonPipe {\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        self.0.is_read_vectored()\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        self.0.is_write_vectored()\n-    }\n-\n-    pub fn fd(&self) -> &FileDesc {\n-        &self.0\n-    }\n-    pub fn into_fd(self) -> FileDesc {\n-        self.0\n-    }\n-    pub fn diverge(&self) -> ! {\n-        panic!()\n-    }\n-}\n-\n-pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n-    // Set both pipes into nonblocking mode as we're gonna be reading from both\n-    // in the `select` loop below, and we wouldn't want one to block the other!\n-    let p1 = p1.into_fd();\n-    let p2 = p2.into_fd();\n-    p1.set_nonblocking_pipe(true)?;\n-    p2.set_nonblocking_pipe(true)?;\n-\n-    let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n-    fds[0].fd = p1.raw();\n-    fds[0].events = libc::POLLIN;\n-    fds[1].fd = p2.raw();\n-    fds[1].events = libc::POLLIN;\n-    loop {\n-        // wait for either pipe to become readable using `poll`\n-        cvt_r(|| unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) })?;\n-\n-        if fds[0].revents != 0 && read(&p1, v1)? {\n-            p2.set_nonblocking_pipe(false)?;\n-            return p2.read_to_end(v2).map(drop);\n-        }\n-        if fds[1].revents != 0 && read(&p2, v2)? {\n-            p1.set_nonblocking_pipe(false)?;\n-            return p1.read_to_end(v1).map(drop);\n-        }\n-    }\n-\n-    // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n-    // EAGAIN. If we hit EOF, then this will happen because the underlying\n-    // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n-    // this case we flip the other fd back into blocking mode and read\n-    // whatever's leftover on that file descriptor.\n-    fn read(fd: &FileDesc, dst: &mut Vec<u8>) -> Result<bool, io::Error> {\n-        match fd.read_to_end(dst) {\n-            Ok(_) => Ok(true),\n-            Err(e) => {\n-                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n-                    || e.raw_os_error() == Some(libc::EAGAIN)\n-                {\n-                    Ok(false)\n-                } else {\n-                    Err(e)\n-                }\n-            }\n-        }\n-    }\n-}"}]}