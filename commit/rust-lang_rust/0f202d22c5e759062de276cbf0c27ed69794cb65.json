{"sha": "0f202d22c5e759062de276cbf0c27ed69794cb65", "node_id": "C_kwDOAAsO6NoAKDBmMjAyZDIyYzVlNzU5MDYyZGUyNzZjYmYwYzI3ZWQ2OTc5NGNiNjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-15T16:27:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-15T16:27:43Z"}, "message": "Auto merge of #96895 - SparrowLii:interval, r=Mark-Simulacrum\n\noptimize `insert_range` method of `IntervalSet`\n\nThis PR fixes the FIXME in the `insert_range` method that avoids recurse calculations when overlaping", "tree": {"sha": "1b96fbd907ac91eac41f54cfb125900a1cc51722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b96fbd907ac91eac41f54cfb125900a1cc51722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f202d22c5e759062de276cbf0c27ed69794cb65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f202d22c5e759062de276cbf0c27ed69794cb65", "html_url": "https://github.com/rust-lang/rust/commit/0f202d22c5e759062de276cbf0c27ed69794cb65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f202d22c5e759062de276cbf0c27ed69794cb65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a170f2b3d2aa95e51040163e801123b17d38c24f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a170f2b3d2aa95e51040163e801123b17d38c24f", "html_url": "https://github.com/rust-lang/rust/commit/a170f2b3d2aa95e51040163e801123b17d38c24f"}, {"sha": "eead168dd71d38f44358815112a54d8e5d786231", "url": "https://api.github.com/repos/rust-lang/rust/commits/eead168dd71d38f44358815112a54d8e5d786231", "html_url": "https://github.com/rust-lang/rust/commit/eead168dd71d38f44358815112a54d8e5d786231"}], "stats": {"total": 93, "additions": 45, "deletions": 48}, "files": [{"sha": "347c88560225609908f377032cf9d1853eb8ccce", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/0f202d22c5e759062de276cbf0c27ed69794cb65/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f202d22c5e759062de276cbf0c27ed69794cb65/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=0f202d22c5e759062de276cbf0c27ed69794cb65", "patch": "@@ -70,67 +70,64 @@ impl<I: Idx> IntervalSet<I> {\n     /// Returns true if we increased the number of elements present.\n     pub fn insert_range(&mut self, range: impl RangeBounds<I> + Clone) -> bool {\n         let start = inclusive_start(range.clone());\n-        let Some(mut end) = inclusive_end(self.domain, range) else {\n+        let Some(end) = inclusive_end(self.domain, range) else {\n             // empty range\n             return false;\n         };\n         if start > end {\n             return false;\n         }\n \n-        loop {\n-            // This condition looks a bit weird, but actually makes sense.\n-            //\n-            // if r.0 == end + 1, then we're actually adjacent, so we want to\n-            // continue to the next range. We're looking here for the first\n-            // range which starts *non-adjacently* to our end.\n-            let next = self.map.partition_point(|r| r.0 <= end + 1);\n-            if let Some(last) = next.checked_sub(1) {\n-                let (prev_start, prev_end) = &mut self.map[last];\n-                if *prev_end + 1 >= start {\n-                    // If the start for the inserted range is adjacent to the\n-                    // end of the previous, we can extend the previous range.\n-                    if start < *prev_start {\n-                        // Our range starts before the one we found. We'll need\n-                        // to *remove* it, and then try again.\n-                        //\n-                        // FIXME: This is not so efficient; we may need to\n-                        // recurse a bunch of times here. Instead, it's probably\n-                        // better to do something like drain_filter(...) on the\n-                        // map to be able to delete or modify all the ranges in\n-                        // start..=end and then potentially re-insert a new\n-                        // range.\n-                        end = std::cmp::max(end, *prev_end);\n-                        self.map.remove(last);\n-                    } else {\n-                        // We overlap with the previous range, increase it to\n-                        // include us.\n-                        //\n-                        // Make sure we're actually going to *increase* it though --\n-                        // it may be that end is just inside the previously existing\n-                        // set.\n-                        return if end > *prev_end {\n-                            *prev_end = end;\n-                            true\n-                        } else {\n-                            false\n-                        };\n+        // This condition looks a bit weird, but actually makes sense.\n+        //\n+        // if r.0 == end + 1, then we're actually adjacent, so we want to\n+        // continue to the next range. We're looking here for the first\n+        // range which starts *non-adjacently* to our end.\n+        let next = self.map.partition_point(|r| r.0 <= end + 1);\n+        if let Some(right) = next.checked_sub(1) {\n+            let (prev_start, prev_end) = self.map[right];\n+            if prev_end + 1 >= start {\n+                // If the start for the inserted range is adjacent to the\n+                // end of the previous, we can extend the previous range.\n+                if start < prev_start {\n+                    // The first range which ends *non-adjacently* to our start.\n+                    // And we can ensure that left <= right.\n+                    let left = self.map.partition_point(|l| l.1 + 1 < start);\n+                    let min = std::cmp::min(self.map[left].0, start);\n+                    let max = std::cmp::max(prev_end, end);\n+                    self.map[right] = (min, max);\n+                    if left != right {\n+                        self.map.drain(left..right);\n                     }\n-                } else {\n-                    // Otherwise, we don't overlap, so just insert\n-                    self.map.insert(last + 1, (start, end));\n                     return true;\n-                }\n-            } else {\n-                if self.map.is_empty() {\n-                    // Quite common in practice, and expensive to call memcpy\n-                    // with length zero.\n-                    self.map.push((start, end));\n                 } else {\n-                    self.map.insert(next, (start, end));\n+                    // We overlap with the previous range, increase it to\n+                    // include us.\n+                    //\n+                    // Make sure we're actually going to *increase* it though --\n+                    // it may be that end is just inside the previously existing\n+                    // set.\n+                    return if end > prev_end {\n+                        self.map[right].1 = end;\n+                        true\n+                    } else {\n+                        false\n+                    };\n                 }\n+            } else {\n+                // Otherwise, we don't overlap, so just insert\n+                self.map.insert(right + 1, (start, end));\n                 return true;\n             }\n+        } else {\n+            if self.map.is_empty() {\n+                // Quite common in practice, and expensive to call memcpy\n+                // with length zero.\n+                self.map.push((start, end));\n+            } else {\n+                self.map.insert(next, (start, end));\n+            }\n+            return true;\n         }\n     }\n "}]}