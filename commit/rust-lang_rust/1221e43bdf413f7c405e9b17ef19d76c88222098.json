{"sha": "1221e43bdf413f7c405e9b17ef19d76c88222098", "node_id": "C_kwDOAAsO6NoAKDEyMjFlNDNiZGY0MTNmN2M0MDVlOWIxN2VmMTlkNzZjODgyMjIwOTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T08:58:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T08:58:40Z"}, "message": "Auto merge of #111984 - matthiaskrgr:rollup-6u7ynyv, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #111384 (Fix linking Mac Catalyst by including LC_BUILD_VERSION in object files)\n - #111899 (CGU cleanups)\n - #111940 (Clarify safety concern of `io::Read::read` is only relevant in unsafe code)\n - #111947 (Add test for RPIT defined with different hidden types with different substs)\n - #111951 (Correct comment on privately uninhabited pattern.)\n\nFailed merges:\n\n - #111954 (improve error message for calling a method on a raw pointer with an unknown pointee)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "af1691ddb6f44e2c69fe9c6cac9baa487e5d4db9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af1691ddb6f44e2c69fe9c6cac9baa487e5d4db9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1221e43bdf413f7c405e9b17ef19d76c88222098", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1221e43bdf413f7c405e9b17ef19d76c88222098", "html_url": "https://github.com/rust-lang/rust/commit/1221e43bdf413f7c405e9b17ef19d76c88222098", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1221e43bdf413f7c405e9b17ef19d76c88222098/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be72f2587c91579406117f99fa332383d66b7dcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/be72f2587c91579406117f99fa332383d66b7dcd", "html_url": "https://github.com/rust-lang/rust/commit/be72f2587c91579406117f99fa332383d66b7dcd"}, {"sha": "dd74ae09297556c38964a26d817c9af384e707ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd74ae09297556c38964a26d817c9af384e707ed", "html_url": "https://github.com/rust-lang/rust/commit/dd74ae09297556c38964a26d817c9af384e707ed"}], "stats": {"total": 713, "additions": 424, "deletions": 289}, "files": [{"sha": "ad27b854d59a2553f240cc1ed00b3a93d5162a99", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -188,6 +188,11 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n     };\n \n     let mut file = write::Object::new(binary_format, architecture, endianness);\n+    if sess.target.is_like_osx {\n+        if let Some(build_version) = macho_object_build_version_for_target(&sess.target) {\n+            file.set_macho_build_version(build_version)\n+        }\n+    }\n     let e_flags = match architecture {\n         Architecture::Mips => {\n             let arch = match sess.target.options.cpu.as_ref() {\n@@ -258,6 +263,33 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n     Some(file)\n }\n \n+/// Apple's LD, when linking for Mac Catalyst, requires object files to\n+/// contain information about what they were built for (LC_BUILD_VERSION):\n+/// the platform (macOS/watchOS etc), minimum OS version, and SDK version.\n+/// This returns a `MachOBuildVersion` if necessary for the target.\n+fn macho_object_build_version_for_target(\n+    target: &Target,\n+) -> Option<object::write::MachOBuildVersion> {\n+    if !target.llvm_target.ends_with(\"-macabi\") {\n+        return None;\n+    }\n+    /// The `object` crate demands \"X.Y.Z encoded in nibbles as xxxx.yy.zz\"\n+    /// e.g. minOS 14.0 = 0x000E0000, or SDK 16.2 = 0x00100200\n+    fn pack_version((major, minor): (u32, u32)) -> u32 {\n+        (major << 16) | (minor << 8)\n+    }\n+\n+    let platform = object::macho::PLATFORM_MACCATALYST;\n+    let min_os = (14, 0);\n+    let sdk = (16, 2);\n+\n+    let mut build_version = object::write::MachOBuildVersion::default();\n+    build_version.platform = platform;\n+    build_version.minos = pack_version(min_os);\n+    build_version.sdk = pack_version(sdk);\n+    Some(build_version)\n+}\n+\n pub enum MetadataPosition {\n     First,\n     Last,"}, {"sha": "f31b343c94704bc2ba3bbf22483d1209eb67c29c", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -334,10 +334,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn modify_size_estimate(&mut self, delta: usize) {\n-        assert!(self.size_estimate.is_some());\n-        if let Some(size_estimate) = self.size_estimate {\n-            self.size_estimate = Some(size_estimate + delta);\n-        }\n+        *self.size_estimate.as_mut().unwrap() += delta;\n     }\n \n     pub fn contains_item(&self, item: &MonoItem<'tcx>) -> bool {"}, {"sha": "1e51cb9aa96e7360b8a992dfb728c34b48e83c2e", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -491,8 +491,8 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             AdtDefinedHere { adt_def_span, ty, variants }\n         };\n \n-        // Emit an extra note if the first uncovered witness is\n-        // visibly uninhabited anywhere in the current crate.\n+        // Emit an extra note if the first uncovered witness would be uninhabited\n+        // if we disregard visibility.\n         let witness_1_is_privately_uninhabited =\n             if cx.tcx.features().exhaustive_patterns\n                 && let Some(witness_1) = witnesses.get(0)"}, {"sha": "603b3ddc106e931ea2864506243a43b35fd9e819", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 113, "deletions": 37, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -1,3 +1,4 @@\n+use std::cmp;\n use std::collections::hash_map::Entry;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -14,10 +15,7 @@ use rustc_span::symbol::Symbol;\n \n use super::PartitioningCx;\n use crate::collector::InliningMap;\n-use crate::partitioning::merging;\n-use crate::partitioning::{\n-    MonoItemPlacement, Partition, PostInliningPartitioning, PreInliningPartitioning,\n-};\n+use crate::partitioning::{MonoItemPlacement, Partition, PlacedRootMonoItems};\n \n pub struct DefaultPartitioning;\n \n@@ -26,7 +24,7 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> PlacedRootMonoItems<'tcx>\n     where\n         I: Iterator<Item = MonoItem<'tcx>>,\n     {\n@@ -91,38 +89,120 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n             codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n         }\n \n-        PreInliningPartitioning {\n-            codegen_units: codegen_units.into_values().collect(),\n-            roots,\n-            internalization_candidates,\n-        }\n+        let codegen_units = codegen_units.into_values().collect();\n+        PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n     }\n \n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     ) {\n-        merging::merge_codegen_units(cx, initial_partitioning);\n+        assert!(cx.target_cgu_count >= 1);\n+\n+        // Note that at this point in time the `codegen_units` here may not be\n+        // in a deterministic order (but we know they're deterministically the\n+        // same set). We want this merging to produce a deterministic ordering\n+        // of codegen units from the input.\n+        //\n+        // Due to basically how we've implemented the merging below (merge the\n+        // two smallest into each other) we're sure to start off with a\n+        // deterministic order (sorted by name). This'll mean that if two cgus\n+        // have the same size the stable sort below will keep everything nice\n+        // and deterministic.\n+        codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+        // This map keeps track of what got merged into what.\n+        let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+            codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n+\n+        // Merge the two smallest codegen units until the target size is\n+        // reached.\n+        while codegen_units.len() > cx.target_cgu_count {\n+            // Sort small cgus to the back\n+            codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+            let mut smallest = codegen_units.pop().unwrap();\n+            let second_smallest = codegen_units.last_mut().unwrap();\n+\n+            // Move the mono-items from `smallest` to `second_smallest`\n+            second_smallest.modify_size_estimate(smallest.size_estimate());\n+            for (k, v) in smallest.items_mut().drain() {\n+                second_smallest.items_mut().insert(k, v);\n+            }\n+\n+            // Record that `second_smallest` now contains all the stuff that was\n+            // in `smallest` before.\n+            let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+            cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+\n+            debug!(\n+                \"CodegenUnit {} merged into CodegenUnit {}\",\n+                smallest.name(),\n+                second_smallest.name()\n+            );\n+        }\n+\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+\n+        if cx.tcx.sess.opts.incremental.is_some() {\n+            // If we are doing incremental compilation, we want CGU names to\n+            // reflect the path of the source level module they correspond to.\n+            // For CGUs that contain the code of multiple modules because of the\n+            // merging done above, we use a concatenation of the names of all\n+            // contained CGUs.\n+            let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+                .into_iter()\n+                // This `filter` makes sure we only update the name of CGUs that\n+                // were actually modified by merging.\n+                .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+                .map(|(current_cgu_name, cgu_contents)| {\n+                    let mut cgu_contents: Vec<&str> =\n+                        cgu_contents.iter().map(|s| s.as_str()).collect();\n+\n+                    // Sort the names, so things are deterministic and easy to\n+                    // predict. We are sorting primitive `&str`s here so we can\n+                    // use unstable sort.\n+                    cgu_contents.sort_unstable();\n+\n+                    (current_cgu_name, cgu_contents.join(\"--\"))\n+                })\n+                .collect();\n+\n+            for cgu in codegen_units.iter_mut() {\n+                if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                    if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n+                        cgu.set_name(Symbol::intern(&new_cgu_name));\n+                    } else {\n+                        // If we don't require CGU names to be human-readable,\n+                        // we use a fixed length hash of the composite CGU name\n+                        // instead.\n+                        let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                        cgu.set_name(Symbol::intern(&new_cgu_name));\n+                    }\n+                }\n+            }\n+        } else {\n+            // If we are compiling non-incrementally we just generate simple CGU\n+            // names containing an index.\n+            for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+                let numbered_codegen_unit_name =\n+                    cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n+                cgu.set_name(numbered_codegen_unit_name);\n+            }\n+        }\n     }\n \n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx> {\n-        let mut new_partitioning = Vec::new();\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n         let mut mono_item_placements = FxHashMap::default();\n \n-        let PreInliningPartitioning {\n-            codegen_units: initial_cgus,\n-            roots,\n-            internalization_candidates,\n-        } = initial_partitioning;\n-\n-        let single_codegen_unit = initial_cgus.len() == 1;\n+        let single_codegen_unit = codegen_units.len() == 1;\n \n-        for old_codegen_unit in initial_cgus {\n+        for old_codegen_unit in codegen_units.iter_mut() {\n             // Collect all items that need to be available in this codegen unit.\n             let mut reachable = FxHashSet::default();\n             for root in old_codegen_unit.items().keys() {\n@@ -174,14 +254,10 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n                 }\n             }\n \n-            new_partitioning.push(new_codegen_unit);\n+            *old_codegen_unit = new_codegen_unit;\n         }\n \n-        return PostInliningPartitioning {\n-            codegen_units: new_partitioning,\n-            mono_item_placements,\n-            internalization_candidates,\n-        };\n+        return mono_item_placements;\n \n         fn follow_inlining<'tcx>(\n             mono_item: MonoItem<'tcx>,\n@@ -201,14 +277,16 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     ) {\n-        if partitioning.codegen_units.len() == 1 {\n+        if codegen_units.len() == 1 {\n             // Fast path for when there is only one codegen unit. In this case we\n             // can internalize all candidates, since there is nowhere else they\n             // could be accessed from.\n-            for cgu in &mut partitioning.codegen_units {\n-                for candidate in &partitioning.internalization_candidates {\n+            for cgu in codegen_units {\n+                for candidate in &internalization_candidates {\n                     cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n                 }\n             }\n@@ -225,15 +303,13 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n             }\n         });\n \n-        let mono_item_placements = &partitioning.mono_item_placements;\n-\n         // For each internalization candidates in each codegen unit, check if it is\n         // accessed from outside its defining codegen unit.\n-        for cgu in &mut partitioning.codegen_units {\n+        for cgu in codegen_units {\n             let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n \n             for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-                if !partitioning.internalization_candidates.contains(accessee) {\n+                if !internalization_candidates.contains(accessee) {\n                     // This item is no candidate for internalizing, so skip it.\n                     continue;\n                 }"}, {"sha": "5c524a18454ec515026c68537cf84d1b0cccd5c8", "filename": "compiler/rustc_monomorphize/src/partitioning/merging.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/be72f2587c91579406117f99fa332383d66b7dcd/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72f2587c91579406117f99fa332383d66b7dcd/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs?ref=be72f2587c91579406117f99fa332383d66b7dcd", "patch": "@@ -1,111 +0,0 @@\n-use std::cmp;\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder};\n-use rustc_span::symbol::Symbol;\n-\n-use super::PartitioningCx;\n-use crate::partitioning::PreInliningPartitioning;\n-\n-pub fn merge_codegen_units<'tcx>(\n-    cx: &PartitioningCx<'_, 'tcx>,\n-    initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-) {\n-    assert!(cx.target_cgu_count >= 1);\n-    let codegen_units = &mut initial_partitioning.codegen_units;\n-\n-    // Note that at this point in time the `codegen_units` here may not be in a\n-    // deterministic order (but we know they're deterministically the same set).\n-    // We want this merging to produce a deterministic ordering of codegen units\n-    // from the input.\n-    //\n-    // Due to basically how we've implemented the merging below (merge the two\n-    // smallest into each other) we're sure to start off with a deterministic\n-    // order (sorted by name). This'll mean that if two cgus have the same size\n-    // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-    // This map keeps track of what got merged into what.\n-    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n-        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n-\n-    // Merge the two smallest codegen units until the target size is reached.\n-    while codegen_units.len() > cx.target_cgu_count {\n-        // Sort small cgus to the back\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        let mut smallest = codegen_units.pop().unwrap();\n-        let second_smallest = codegen_units.last_mut().unwrap();\n-\n-        // Move the mono-items from `smallest` to `second_smallest`\n-        second_smallest.modify_size_estimate(smallest.size_estimate());\n-        for (k, v) in smallest.items_mut().drain() {\n-            second_smallest.items_mut().insert(k, v);\n-        }\n-\n-        // Record that `second_smallest` now contains all the stuff that was in\n-        // `smallest` before.\n-        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n-\n-        debug!(\n-            \"CodegenUnit {} merged into CodegenUnit {}\",\n-            smallest.name(),\n-            second_smallest.name()\n-        );\n-    }\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-\n-    if cx.tcx.sess.opts.incremental.is_some() {\n-        // If we are doing incremental compilation, we want CGU names to\n-        // reflect the path of the source level module they correspond to.\n-        // For CGUs that contain the code of multiple modules because of the\n-        // merging done above, we use a concatenation of the names of\n-        // all contained CGUs.\n-        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-            .into_iter()\n-            // This `filter` makes sure we only update the name of CGUs that\n-            // were actually modified by merging.\n-            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-            .map(|(current_cgu_name, cgu_contents)| {\n-                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n-\n-                // Sort the names, so things are deterministic and easy to\n-                // predict.\n-\n-                // We are sorting primitive &strs here so we can use unstable sort\n-                cgu_contents.sort_unstable();\n-\n-                (current_cgu_name, cgu_contents.join(\"--\"))\n-            })\n-            .collect();\n-\n-        for cgu in codegen_units.iter_mut() {\n-            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                } else {\n-                    // If we don't require CGU names to be human-readable, we\n-                    // use a fixed length hash of the composite CGU name\n-                    // instead.\n-                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                }\n-            }\n-        }\n-    } else {\n-        // If we are compiling non-incrementally we just generate simple CGU\n-        // names containing an index.\n-        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-            cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n-        }\n-    }\n-}\n-\n-fn numbered_codegen_unit_name(\n-    name_builder: &mut CodegenUnitNameBuilder<'_>,\n-    index: usize,\n-) -> Symbol {\n-    name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n-}"}, {"sha": "d0b23ca9ea44494dcc9dbe891f998bda48a31dc4", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -93,7 +93,6 @@\n //! inlining, even when they are not marked `#[inline]`.\n \n mod default;\n-mod merging;\n \n use std::cmp;\n use std::fs::{self, File};\n@@ -129,7 +128,7 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> PlacedRootMonoItems<'tcx>\n     where\n         I: Iterator<Item = MonoItem<'tcx>>,\n     {\n@@ -142,24 +141,23 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     ) {\n         match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.merge_codegen_units(cx, initial_partitioning)\n-            }\n+            Partitioner::Default(partitioner) => partitioner.merge_codegen_units(cx, codegen_units),\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n     }\n \n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx> {\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n         match self {\n             Partitioner::Default(partitioner) => {\n-                partitioner.place_inlined_mono_items(cx, initial_partitioning)\n+                partitioner.place_inlined_mono_items(cx, codegen_units, roots)\n             }\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n@@ -168,48 +166,62 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        post_inlining_partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     ) {\n         match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.internalize_symbols(cx, post_inlining_partitioning)\n-            }\n+            Partitioner::Default(partitioner) => partitioner.internalize_symbols(\n+                cx,\n+                codegen_units,\n+                mono_item_placements,\n+                internalization_candidates,\n+            ),\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n     }\n }\n \n-pub struct PartitioningCx<'a, 'tcx> {\n+struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     target_cgu_count: usize,\n     inlining_map: &'a InliningMap<'tcx>,\n }\n \n+pub struct PlacedRootMonoItems<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+}\n+\n trait Partition<'tcx> {\n     fn place_root_mono_items<I>(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> PlacedRootMonoItems<'tcx>\n     where\n         I: Iterator<Item = MonoItem<'tcx>>;\n \n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     );\n \n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx>;\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement>;\n \n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     );\n }\n \n@@ -225,7 +237,7 @@ fn get_partitioner(tcx: TyCtxt<'_>) -> Partitioner {\n     }\n }\n \n-pub fn partition<'tcx, I>(\n+fn partition<'tcx, I>(\n     tcx: TyCtxt<'tcx>,\n     mono_items: &mut I,\n     max_cgu_count: usize,\n@@ -241,52 +253,59 @@ where\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = {\n+    let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n         partitioner.place_root_mono_items(cx, mono_items)\n     };\n \n-    for cgu in &mut initial_partitioning.codegen_units {\n+    for cgu in &mut codegen_units {\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"INITIAL PARTITIONING\", &initial_partitioning.codegen_units);\n+    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n \n     // Merge until we have at most `max_cgu_count` codegen units.\n+    // `merge_codegen_units` is responsible for updating the CGU size\n+    // estimates.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(cx, &mut initial_partitioning);\n-        debug_dump(tcx, \"POST MERGING\", &initial_partitioning.codegen_units);\n+        partitioner.merge_codegen_units(cx, &mut codegen_units);\n+        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n     }\n \n     // In the next step, we use the inlining map to determine which additional\n     // monomorphizations have to go into each codegen unit. These additional\n     // monomorphizations can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with `#[inline]`.\n-    let mut post_inlining = {\n+    let mono_item_placements = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(cx, initial_partitioning)\n+        partitioner.place_inlined_mono_items(cx, &mut codegen_units, roots)\n     };\n \n-    for cgu in &mut post_inlining.codegen_units {\n+    for cgu in &mut codegen_units {\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"POST INLINING\", &post_inlining.codegen_units);\n+    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(cx, &mut post_inlining);\n+        partitioner.internalize_symbols(\n+            cx,\n+            &mut codegen_units,\n+            mono_item_placements,\n+            internalization_candidates,\n+        );\n     }\n \n     let instrument_dead_code =\n         tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n \n     if instrument_dead_code {\n         assert!(\n-            post_inlining.codegen_units.len() > 0,\n+            codegen_units.len() > 0,\n             \"There must be at least one CGU that code coverage data can be generated in.\"\n         );\n \n@@ -297,7 +316,7 @@ where\n         // the object file (CGU) containing the dead function stubs is included\n         // in the final binary. This will probably require forcing these\n         // function symbols to be included via `-u` or `/include` linker args.\n-        let mut cgus: Vec<_> = post_inlining.codegen_units.iter_mut().collect();\n+        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n         cgus.sort_by_key(|cgu| cgu.size_estimate());\n \n         let dead_code_cgu =\n@@ -308,29 +327,17 @@ where\n             } else {\n                 // If there are no CGUs that have externally linked items,\n                 // then we just pick the first CGU as a fallback.\n-                &mut post_inlining.codegen_units[0]\n+                &mut codegen_units[0]\n             };\n         dead_code_cgu.make_code_coverage_dead_code_cgu();\n     }\n \n     // Finally, sort by codegen unit name, so that we get deterministic results.\n-    let PostInliningPartitioning {\n-        codegen_units: mut result,\n-        mono_item_placements: _,\n-        internalization_candidates: _,\n-    } = post_inlining;\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n \n-    result.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+    debug_dump(tcx, \"FINAL\", &codegen_units);\n \n-    debug_dump(tcx, \"FINAL\", &result);\n-\n-    result\n-}\n-\n-pub struct PreInliningPartitioning<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<MonoItem<'tcx>>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+    codegen_units\n }\n \n /// For symbol internalization, we need to know whether a symbol/mono-item is\n@@ -342,12 +349,6 @@ enum MonoItemPlacement {\n     MultipleCgus,\n }\n \n-struct PostInliningPartitioning<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-}\n-\n fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n     let dump = move || {\n         use std::fmt::Write;"}, {"sha": "e2df7e0bdcc790c7776eb04397a3714fde16c8f3", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_macabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -2,7 +2,7 @@ use super::apple_base::{opts, Arch};\n use crate::spec::{Cc, FramePointer, LinkerFlavor, Lld, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let llvm_target = \"arm64-apple-ios-macabi\";\n+    let llvm_target = \"arm64-apple-ios14.0-macabi\";\n \n     let arch = Arch::Arm64_macabi;\n     let mut base = opts(\"ios\", arch);"}, {"sha": "9f3b0fab697e6718c6518c61b66044d170ed71b2", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios_macabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -2,7 +2,7 @@ use super::apple_base::{opts, Arch};\n use crate::spec::{Cc, LinkerFlavor, Lld, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let llvm_target = \"x86_64-apple-ios-macabi\";\n+    let llvm_target = \"x86_64-apple-ios14.0-macabi\";\n \n     let arch = Arch::X86_64_macabi;\n     let mut base = opts(\"ios\", arch);"}, {"sha": "8a007d095d5e3a8f42474c0c4530d06f451c04af", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -593,7 +593,8 @@ pub trait Read {\n     /// This may happen for example because fewer bytes are actually available right now\n     /// (e. g. being close to end-of-file) or because read() was interrupted by a signal.\n     ///\n-    /// As this trait is safe to implement, callers cannot rely on `n <= buf.len()` for safety.\n+    /// As this trait is safe to implement, callers in unsafe code cannot rely on\n+    /// `n <= buf.len()` for safety.\n     /// Extra care needs to be taken when `unsafe` functions are used to access the read bytes.\n     /// Callers have to ensure that no unchecked out-of-bounds accesses are possible even if\n     /// `n > buf.len()`.\n@@ -603,8 +604,8 @@ pub trait Read {\n     /// contents of `buf` being true. It is recommended that *implementations*\n     /// only write data to `buf` instead of reading its contents.\n     ///\n-    /// Correspondingly, however, *callers* of this method must not assume any guarantees\n-    /// about how the implementation uses `buf`. The trait is safe to implement,\n+    /// Correspondingly, however, *callers* of this method in unsafe code must not assume\n+    /// any guarantees about how the implementation uses `buf`. The trait is safe to implement,\n     /// so it is possible that the code that's supposed to write to the buffer might also read\n     /// from it. It is your responsibility to make sure that `buf` is initialized\n     /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one"}, {"sha": "c3a6f09f86d9324153f85e859a5ecb79b255ed2e", "filename": "tests/ui/impl-trait/multiple-defining-usages-in-body.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -0,0 +1,12 @@\n+trait Trait {}\n+impl Trait for () {}\n+\n+fn foo<T: Trait, U: Trait>() -> impl Trait {\n+    //~^ WARN function cannot return without recursing [unconditional_recursion]\n+    let a: T = foo::<T, U>();\n+    //~^ ERROR concrete type differs from previous defining opaque type use\n+    loop {}\n+    let _: T = foo::<U, T>();\n+}\n+\n+fn main() {}"}, {"sha": "06991749bfad1ec96ce6827da64001536102c197", "filename": "tests/ui/impl-trait/multiple-defining-usages-in-body.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -0,0 +1,26 @@\n+warning: function cannot return without recursing\n+  --> $DIR/multiple-defining-usages-in-body.rs:4:1\n+   |\n+LL | fn foo<T: Trait, U: Trait>() -> impl Trait {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+LL |\n+LL |     let a: T = foo::<T, U>();\n+   |                ------------- recursive call site\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+   = note: `#[warn(unconditional_recursion)]` on by default\n+\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/multiple-defining-usages-in-body.rs:6:16\n+   |\n+LL |     let a: T = foo::<T, U>();\n+   |                ^^^^^^^^^^^^^ expected `U`, got `T`\n+   |\n+note: previous use here\n+  --> $DIR/multiple-defining-usages-in-body.rs:9:16\n+   |\n+LL |     let _: T = foo::<U, T>();\n+   |                ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "49b6dfca62e5d2193f8e19b4187654b1440365b8", "filename": "tests/ui/pattern/usefulness/empty-match.exhaustive_patterns.stderr", "status": "modified", "additions": 56, "deletions": 38, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -1,5 +1,5 @@\n error: unreachable pattern\n-  --> $DIR/empty-match.rs:37:9\n+  --> $DIR/empty-match.rs:58:9\n    |\n LL |         _ => {},\n    |         ^\n@@ -11,37 +11,52 @@ LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:40:9\n+  --> $DIR/empty-match.rs:61:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:47:9\n+  --> $DIR/empty-match.rs:68:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:50:9\n+  --> $DIR/empty-match.rs:71:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/empty-match.rs:76:9\n+   |\n+LL |     let None = x;\n+   |         ^^^^ pattern `Some(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: pattern `Some(_)` is currently uninhabited, but this variant contains private fields which may become inhabited in the future\n+   = note: the matched value is of type `Option<SecretlyUninhabitedForeignStruct>`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let None = x { todo!() };\n+   |     ++              +++++++++++\n+\n error: unreachable pattern\n-  --> $DIR/empty-match.rs:57:9\n+  --> $DIR/empty-match.rs:88:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:60:9\n+  --> $DIR/empty-match.rs:91:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/empty-match.rs:78:20\n+  --> $DIR/empty-match.rs:109:20\n    |\n LL |     match_no_arms!(0u8);\n    |                    ^^^\n@@ -50,69 +65,69 @@ LL |     match_no_arms!(0u8);\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n-  --> $DIR/empty-match.rs:79:20\n+  --> $DIR/empty-match.rs:111:20\n    |\n LL |     match_no_arms!(NonEmptyStruct1);\n    |                    ^^^^^^^^^^^^^^^\n    |\n note: `NonEmptyStruct1` defined here\n-  --> $DIR/empty-match.rs:14:8\n+  --> $DIR/empty-match.rs:15:8\n    |\n LL | struct NonEmptyStruct1;\n    |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n-  --> $DIR/empty-match.rs:80:20\n+  --> $DIR/empty-match.rs:113:20\n    |\n LL |     match_no_arms!(NonEmptyStruct2(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `NonEmptyStruct2` defined here\n-  --> $DIR/empty-match.rs:15:8\n+  --> $DIR/empty-match.rs:18:8\n    |\n LL | struct NonEmptyStruct2(bool);\n    |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/empty-match.rs:81:20\n+  --> $DIR/empty-match.rs:115:20\n    |\n LL |     match_no_arms!((NonEmptyUnion1 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `NonEmptyUnion1` defined here\n-  --> $DIR/empty-match.rs:16:7\n+  --> $DIR/empty-match.rs:21:7\n    |\n LL | union NonEmptyUnion1 {\n    |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/empty-match.rs:82:20\n+  --> $DIR/empty-match.rs:117:20\n    |\n LL |     match_no_arms!((NonEmptyUnion2 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `NonEmptyUnion2` defined here\n-  --> $DIR/empty-match.rs:19:7\n+  --> $DIR/empty-match.rs:26:7\n    |\n LL | union NonEmptyUnion2 {\n    |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum1::Foo(_)` not covered\n-  --> $DIR/empty-match.rs:83:20\n+  --> $DIR/empty-match.rs:119:20\n    |\n LL |     match_no_arms!(NonEmptyEnum1::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyEnum1::Foo(_)` not covered\n    |\n note: `NonEmptyEnum1` defined here\n-  --> $DIR/empty-match.rs:24:5\n+  --> $DIR/empty-match.rs:33:5\n    |\n LL | enum NonEmptyEnum1 {\n    |      -------------\n@@ -122,39 +137,40 @@ LL |     Foo(bool),\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n-  --> $DIR/empty-match.rs:84:20\n+  --> $DIR/empty-match.rs:122:20\n    |\n LL |     match_no_arms!(NonEmptyEnum2::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n    |\n note: `NonEmptyEnum2` defined here\n-  --> $DIR/empty-match.rs:27:5\n+  --> $DIR/empty-match.rs:40:5\n    |\n LL | enum NonEmptyEnum2 {\n    |      -------------\n LL |     Foo(bool),\n    |     ^^^ not covered\n+...\n LL |     Bar,\n    |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n-  --> $DIR/empty-match.rs:85:20\n+  --> $DIR/empty-match.rs:125:20\n    |\n LL |     match_no_arms!(NonEmptyEnum5::V1);\n    |                    ^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n    |\n note: `NonEmptyEnum5` defined here\n-  --> $DIR/empty-match.rs:30:6\n+  --> $DIR/empty-match.rs:49:6\n    |\n LL | enum NonEmptyEnum5 {\n    |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/empty-match.rs:87:24\n+  --> $DIR/empty-match.rs:129:24\n    |\n LL |     match_guarded_arm!(0u8);\n    |                        ^^^ pattern `_` not covered\n@@ -167,13 +183,13 @@ LL +             _ => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n-  --> $DIR/empty-match.rs:88:24\n+  --> $DIR/empty-match.rs:133:24\n    |\n LL |     match_guarded_arm!(NonEmptyStruct1);\n    |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n    |\n note: `NonEmptyStruct1` defined here\n-  --> $DIR/empty-match.rs:14:8\n+  --> $DIR/empty-match.rs:15:8\n    |\n LL | struct NonEmptyStruct1;\n    |        ^^^^^^^^^^^^^^^\n@@ -185,13 +201,13 @@ LL +             NonEmptyStruct1 => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n-  --> $DIR/empty-match.rs:89:24\n+  --> $DIR/empty-match.rs:137:24\n    |\n LL |     match_guarded_arm!(NonEmptyStruct2(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n note: `NonEmptyStruct2` defined here\n-  --> $DIR/empty-match.rs:15:8\n+  --> $DIR/empty-match.rs:18:8\n    |\n LL | struct NonEmptyStruct2(bool);\n    |        ^^^^^^^^^^^^^^^\n@@ -203,13 +219,13 @@ LL +             NonEmptyStruct2(_) => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/empty-match.rs:90:24\n+  --> $DIR/empty-match.rs:141:24\n    |\n LL |     match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n note: `NonEmptyUnion1` defined here\n-  --> $DIR/empty-match.rs:16:7\n+  --> $DIR/empty-match.rs:21:7\n    |\n LL | union NonEmptyUnion1 {\n    |       ^^^^^^^^^^^^^^\n@@ -221,13 +237,13 @@ LL +             NonEmptyUnion1 { .. } => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/empty-match.rs:91:24\n+  --> $DIR/empty-match.rs:145:24\n    |\n LL |     match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n    |\n note: `NonEmptyUnion2` defined here\n-  --> $DIR/empty-match.rs:19:7\n+  --> $DIR/empty-match.rs:26:7\n    |\n LL | union NonEmptyUnion2 {\n    |       ^^^^^^^^^^^^^^\n@@ -239,13 +255,13 @@ LL +             NonEmptyUnion2 { .. } => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum1::Foo(_)` not covered\n-  --> $DIR/empty-match.rs:92:24\n+  --> $DIR/empty-match.rs:149:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum1::Foo(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyEnum1::Foo(_)` not covered\n    |\n note: `NonEmptyEnum1` defined here\n-  --> $DIR/empty-match.rs:24:5\n+  --> $DIR/empty-match.rs:33:5\n    |\n LL | enum NonEmptyEnum1 {\n    |      -------------\n@@ -259,18 +275,19 @@ LL +             NonEmptyEnum1::Foo(_) => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n-  --> $DIR/empty-match.rs:93:24\n+  --> $DIR/empty-match.rs:153:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum2::Foo(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n    |\n note: `NonEmptyEnum2` defined here\n-  --> $DIR/empty-match.rs:27:5\n+  --> $DIR/empty-match.rs:40:5\n    |\n LL | enum NonEmptyEnum2 {\n    |      -------------\n LL |     Foo(bool),\n    |     ^^^ not covered\n+...\n LL |     Bar,\n    |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n@@ -281,13 +298,13 @@ LL +             NonEmptyEnum2::Foo(_) | NonEmptyEnum2::Bar => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n-  --> $DIR/empty-match.rs:94:24\n+  --> $DIR/empty-match.rs:157:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum5::V1);\n    |                        ^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n    |\n note: `NonEmptyEnum5` defined here\n-  --> $DIR/empty-match.rs:30:6\n+  --> $DIR/empty-match.rs:49:6\n    |\n LL | enum NonEmptyEnum5 {\n    |      ^^^^^^^^^^^^^\n@@ -298,6 +315,7 @@ LL ~             _ if false => {},\n LL +             _ => todo!()\n    |\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 23 previous errors\n \n-For more information about this error, try `rustc --explain E0004`.\n+Some errors have detailed explanations: E0004, E0005.\n+For more information about an error, try `rustc --explain E0004`."}, {"sha": "f54a3f3364ff960954e8e8878c1033678cd8d575", "filename": "tests/ui/pattern/usefulness/empty-match.normal.stderr", "status": "modified", "additions": 55, "deletions": 38, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -1,5 +1,5 @@\n error: unreachable pattern\n-  --> $DIR/empty-match.rs:37:9\n+  --> $DIR/empty-match.rs:58:9\n    |\n LL |         _ => {},\n    |         ^\n@@ -11,37 +11,51 @@ LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:40:9\n+  --> $DIR/empty-match.rs:61:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:47:9\n+  --> $DIR/empty-match.rs:68:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:50:9\n+  --> $DIR/empty-match.rs:71:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/empty-match.rs:76:9\n+   |\n+LL |     let None = x;\n+   |         ^^^^ pattern `Some(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `Option<SecretlyUninhabitedForeignStruct>`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let None = x { todo!() };\n+   |     ++              +++++++++++\n+\n error: unreachable pattern\n-  --> $DIR/empty-match.rs:57:9\n+  --> $DIR/empty-match.rs:88:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:60:9\n+  --> $DIR/empty-match.rs:91:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/empty-match.rs:78:20\n+  --> $DIR/empty-match.rs:109:20\n    |\n LL |     match_no_arms!(0u8);\n    |                    ^^^\n@@ -50,69 +64,69 @@ LL |     match_no_arms!(0u8);\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n-  --> $DIR/empty-match.rs:79:20\n+  --> $DIR/empty-match.rs:111:20\n    |\n LL |     match_no_arms!(NonEmptyStruct1);\n    |                    ^^^^^^^^^^^^^^^\n    |\n note: `NonEmptyStruct1` defined here\n-  --> $DIR/empty-match.rs:14:8\n+  --> $DIR/empty-match.rs:15:8\n    |\n LL | struct NonEmptyStruct1;\n    |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n-  --> $DIR/empty-match.rs:80:20\n+  --> $DIR/empty-match.rs:113:20\n    |\n LL |     match_no_arms!(NonEmptyStruct2(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `NonEmptyStruct2` defined here\n-  --> $DIR/empty-match.rs:15:8\n+  --> $DIR/empty-match.rs:18:8\n    |\n LL | struct NonEmptyStruct2(bool);\n    |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/empty-match.rs:81:20\n+  --> $DIR/empty-match.rs:115:20\n    |\n LL |     match_no_arms!((NonEmptyUnion1 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `NonEmptyUnion1` defined here\n-  --> $DIR/empty-match.rs:16:7\n+  --> $DIR/empty-match.rs:21:7\n    |\n LL | union NonEmptyUnion1 {\n    |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/empty-match.rs:82:20\n+  --> $DIR/empty-match.rs:117:20\n    |\n LL |     match_no_arms!((NonEmptyUnion2 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `NonEmptyUnion2` defined here\n-  --> $DIR/empty-match.rs:19:7\n+  --> $DIR/empty-match.rs:26:7\n    |\n LL | union NonEmptyUnion2 {\n    |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum1::Foo(_)` not covered\n-  --> $DIR/empty-match.rs:83:20\n+  --> $DIR/empty-match.rs:119:20\n    |\n LL |     match_no_arms!(NonEmptyEnum1::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyEnum1::Foo(_)` not covered\n    |\n note: `NonEmptyEnum1` defined here\n-  --> $DIR/empty-match.rs:24:5\n+  --> $DIR/empty-match.rs:33:5\n    |\n LL | enum NonEmptyEnum1 {\n    |      -------------\n@@ -122,39 +136,40 @@ LL |     Foo(bool),\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n-  --> $DIR/empty-match.rs:84:20\n+  --> $DIR/empty-match.rs:122:20\n    |\n LL |     match_no_arms!(NonEmptyEnum2::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n    |\n note: `NonEmptyEnum2` defined here\n-  --> $DIR/empty-match.rs:27:5\n+  --> $DIR/empty-match.rs:40:5\n    |\n LL | enum NonEmptyEnum2 {\n    |      -------------\n LL |     Foo(bool),\n    |     ^^^ not covered\n+...\n LL |     Bar,\n    |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n-  --> $DIR/empty-match.rs:85:20\n+  --> $DIR/empty-match.rs:125:20\n    |\n LL |     match_no_arms!(NonEmptyEnum5::V1);\n    |                    ^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n    |\n note: `NonEmptyEnum5` defined here\n-  --> $DIR/empty-match.rs:30:6\n+  --> $DIR/empty-match.rs:49:6\n    |\n LL | enum NonEmptyEnum5 {\n    |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/empty-match.rs:87:24\n+  --> $DIR/empty-match.rs:129:24\n    |\n LL |     match_guarded_arm!(0u8);\n    |                        ^^^ pattern `_` not covered\n@@ -167,13 +182,13 @@ LL +             _ => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n-  --> $DIR/empty-match.rs:88:24\n+  --> $DIR/empty-match.rs:133:24\n    |\n LL |     match_guarded_arm!(NonEmptyStruct1);\n    |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n    |\n note: `NonEmptyStruct1` defined here\n-  --> $DIR/empty-match.rs:14:8\n+  --> $DIR/empty-match.rs:15:8\n    |\n LL | struct NonEmptyStruct1;\n    |        ^^^^^^^^^^^^^^^\n@@ -185,13 +200,13 @@ LL +             NonEmptyStruct1 => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n-  --> $DIR/empty-match.rs:89:24\n+  --> $DIR/empty-match.rs:137:24\n    |\n LL |     match_guarded_arm!(NonEmptyStruct2(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n note: `NonEmptyStruct2` defined here\n-  --> $DIR/empty-match.rs:15:8\n+  --> $DIR/empty-match.rs:18:8\n    |\n LL | struct NonEmptyStruct2(bool);\n    |        ^^^^^^^^^^^^^^^\n@@ -203,13 +218,13 @@ LL +             NonEmptyStruct2(_) => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/empty-match.rs:90:24\n+  --> $DIR/empty-match.rs:141:24\n    |\n LL |     match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n note: `NonEmptyUnion1` defined here\n-  --> $DIR/empty-match.rs:16:7\n+  --> $DIR/empty-match.rs:21:7\n    |\n LL | union NonEmptyUnion1 {\n    |       ^^^^^^^^^^^^^^\n@@ -221,13 +236,13 @@ LL +             NonEmptyUnion1 { .. } => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/empty-match.rs:91:24\n+  --> $DIR/empty-match.rs:145:24\n    |\n LL |     match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n    |\n note: `NonEmptyUnion2` defined here\n-  --> $DIR/empty-match.rs:19:7\n+  --> $DIR/empty-match.rs:26:7\n    |\n LL | union NonEmptyUnion2 {\n    |       ^^^^^^^^^^^^^^\n@@ -239,13 +254,13 @@ LL +             NonEmptyUnion2 { .. } => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum1::Foo(_)` not covered\n-  --> $DIR/empty-match.rs:92:24\n+  --> $DIR/empty-match.rs:149:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum1::Foo(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyEnum1::Foo(_)` not covered\n    |\n note: `NonEmptyEnum1` defined here\n-  --> $DIR/empty-match.rs:24:5\n+  --> $DIR/empty-match.rs:33:5\n    |\n LL | enum NonEmptyEnum1 {\n    |      -------------\n@@ -259,18 +274,19 @@ LL +             NonEmptyEnum1::Foo(_) => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n-  --> $DIR/empty-match.rs:93:24\n+  --> $DIR/empty-match.rs:153:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum2::Foo(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n    |\n note: `NonEmptyEnum2` defined here\n-  --> $DIR/empty-match.rs:27:5\n+  --> $DIR/empty-match.rs:40:5\n    |\n LL | enum NonEmptyEnum2 {\n    |      -------------\n LL |     Foo(bool),\n    |     ^^^ not covered\n+...\n LL |     Bar,\n    |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n@@ -281,13 +297,13 @@ LL +             NonEmptyEnum2::Foo(_) | NonEmptyEnum2::Bar => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n-  --> $DIR/empty-match.rs:94:24\n+  --> $DIR/empty-match.rs:157:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum5::V1);\n    |                        ^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n    |\n note: `NonEmptyEnum5` defined here\n-  --> $DIR/empty-match.rs:30:6\n+  --> $DIR/empty-match.rs:49:6\n    |\n LL | enum NonEmptyEnum5 {\n    |      ^^^^^^^^^^^^^\n@@ -298,6 +314,7 @@ LL ~             _ if false => {},\n LL +             _ => todo!()\n    |\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 23 previous errors\n \n-For more information about this error, try `rustc --explain E0004`.\n+Some errors have detailed explanations: E0004, E0005.\n+For more information about an error, try `rustc --explain E0004`."}, {"sha": "062241faa4cf22cfe9c70e6aee0175b259d4e52b", "filename": "tests/ui/pattern/usefulness/empty-match.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1221e43bdf413f7c405e9b17ef19d76c88222098/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs?ref=1221e43bdf413f7c405e9b17ef19d76c88222098", "patch": "@@ -6,28 +6,49 @@\n #![feature(never_type_fallback)]\n #![cfg_attr(exhaustive_patterns, feature(exhaustive_patterns))]\n #![deny(unreachable_patterns)]\n+//~^ NOTE the lint level is defined here\n \n extern crate empty;\n \n enum EmptyEnum {}\n \n struct NonEmptyStruct1;\n+//~^ NOTE `NonEmptyStruct1` defined here\n+//~| NOTE `NonEmptyStruct1` defined here\n struct NonEmptyStruct2(bool);\n+//~^ NOTE `NonEmptyStruct2` defined here\n+//~| NOTE `NonEmptyStruct2` defined here\n union NonEmptyUnion1 {\n+    //~^ NOTE `NonEmptyUnion1` defined here\n+    //~| NOTE `NonEmptyUnion1` defined here\n     foo: (),\n }\n union NonEmptyUnion2 {\n+    //~^ NOTE `NonEmptyUnion2` defined here\n+    //~| NOTE `NonEmptyUnion2` defined here\n     foo: (),\n     bar: (),\n }\n enum NonEmptyEnum1 {\n     Foo(bool),\n+    //~^ NOTE `NonEmptyEnum1` defined here\n+    //~| NOTE `NonEmptyEnum1` defined here\n+    //~| NOTE not covered\n+    //~| NOTE not covered\n }\n enum NonEmptyEnum2 {\n     Foo(bool),\n+    //~^ NOTE `NonEmptyEnum2` defined here\n+    //~| NOTE `NonEmptyEnum2` defined here\n+    //~| NOTE not covered\n+    //~| NOTE not covered\n     Bar,\n+    //~^ NOTE not covered\n+    //~| NOTE not covered\n }\n enum NonEmptyEnum5 {\n+    //~^ NOTE `NonEmptyEnum5` defined here\n+    //~| NOTE `NonEmptyEnum5` defined here\n     V1, V2, V3, V4, V5,\n }\n \n@@ -51,6 +72,16 @@ fn empty_foreign_enum(x: empty::EmptyForeignEnum) {\n     }\n }\n \n+fn empty_foreign_enum_private(x: Option<empty::SecretlyUninhabitedForeignStruct>) {\n+    let None = x;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\"\n+    //~| NOTE for more information, visit\n+    //~| NOTE the matched value is of type\n+    //~| NOTE pattern `Some(_)` not covered\n+    //[exhaustive_patterns]~| NOTE currently uninhabited, but this variant contains private fields\n+}\n+\n fn never(x: !) {\n     match x {} // ok\n     match x {\n@@ -76,20 +107,55 @@ macro_rules! match_guarded_arm {\n \n fn main() {\n     match_no_arms!(0u8); //~ ERROR type `u8` is non-empty\n+                         //~| NOTE the matched value is of type\n     match_no_arms!(NonEmptyStruct1); //~ ERROR type `NonEmptyStruct1` is non-empty\n+                                     //~| NOTE the matched value is of type\n     match_no_arms!(NonEmptyStruct2(true)); //~ ERROR type `NonEmptyStruct2` is non-empty\n+                                           //~| NOTE the matched value is of type\n     match_no_arms!((NonEmptyUnion1 { foo: () })); //~ ERROR type `NonEmptyUnion1` is non-empty\n+                                                  //~| NOTE the matched value is of type\n     match_no_arms!((NonEmptyUnion2 { foo: () })); //~ ERROR type `NonEmptyUnion2` is non-empty\n+                                                  //~| NOTE the matched value is of type\n     match_no_arms!(NonEmptyEnum1::Foo(true)); //~ ERROR `NonEmptyEnum1::Foo(_)` not covered\n+                                              //~| NOTE pattern `NonEmptyEnum1::Foo(_)` not covered\n+                                              //~| NOTE the matched value is of type\n     match_no_arms!(NonEmptyEnum2::Foo(true)); //~ ERROR `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n+                                              //~| NOTE patterns `NonEmptyEnum2::Foo(_)` and\n+                                              //~| NOTE the matched value is of type\n     match_no_arms!(NonEmptyEnum5::V1); //~ ERROR `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n+                                       //~| NOTE patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`\n+                                       //~| NOTE the matched value is of type\n \n     match_guarded_arm!(0u8); //~ ERROR `_` not covered\n+                             //~| NOTE the matched value is of type\n+                             //~| NOTE pattern `_` not covered\n+                             //~| NOTE in this expansion of match_guarded_arm!\n     match_guarded_arm!(NonEmptyStruct1); //~ ERROR `NonEmptyStruct1` not covered\n+                                         //~| NOTE pattern `NonEmptyStruct1` not covered\n+                                         //~| NOTE the matched value is of type\n+                                         //~| NOTE in this expansion of match_guarded_arm!\n     match_guarded_arm!(NonEmptyStruct2(true)); //~ ERROR `NonEmptyStruct2(_)` not covered\n+                                               //~| NOTE the matched value is of type\n+                                               //~| NOTE pattern `NonEmptyStruct2(_)` not covered\n+                                               //~| NOTE in this expansion of match_guarded_arm!\n     match_guarded_arm!((NonEmptyUnion1 { foo: () })); //~ ERROR `NonEmptyUnion1 { .. }` not covered\n+                                                      //~| NOTE the matched value is of type\n+                                                      //~| NOTE pattern `NonEmptyUnion1 { .. }` not covered\n+                                                      //~| NOTE in this expansion of match_guarded_arm!\n     match_guarded_arm!((NonEmptyUnion2 { foo: () })); //~ ERROR `NonEmptyUnion2 { .. }` not covered\n+                                                      //~| NOTE the matched value is of type\n+                                                      //~| NOTE pattern `NonEmptyUnion2 { .. }` not covered\n+                                                      //~| NOTE in this expansion of match_guarded_arm!\n     match_guarded_arm!(NonEmptyEnum1::Foo(true)); //~ ERROR `NonEmptyEnum1::Foo(_)` not covered\n+                                                  //~| NOTE the matched value is of type\n+                                                  //~| NOTE pattern `NonEmptyEnum1::Foo(_)` not covered\n+                                                  //~| NOTE in this expansion of match_guarded_arm!\n     match_guarded_arm!(NonEmptyEnum2::Foo(true)); //~ ERROR `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n+                                                  //~| NOTE the matched value is of type\n+                                                  //~| NOTE patterns `NonEmptyEnum2::Foo(_)` and\n+                                                  //~| NOTE in this expansion of match_guarded_arm!\n     match_guarded_arm!(NonEmptyEnum5::V1); //~ ERROR `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n+                                           //~| NOTE the matched value is of type\n+                                           //~| NOTE patterns `NonEmptyEnum5::V1`,\n+                                           //~| NOTE in this expansion of match_guarded_arm!\n }"}]}