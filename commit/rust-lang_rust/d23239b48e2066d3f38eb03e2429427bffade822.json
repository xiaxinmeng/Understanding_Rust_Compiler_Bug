{"sha": "d23239b48e2066d3f38eb03e2429427bffade822", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMzIzOWI0OGUyMDY2ZDNmMzhlYjAzZTI0Mjk0MjdiZmZhZGU4MjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-07T01:21:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-08T03:07:20Z"}, "message": "msvc: Get codegen-units working\n\nThis commit alters the implementation of multiple codegen units slightly to be\ncompatible with the MSVC linker. Currently the implementation will take the N\nobject files created by each codegen unit and will run `ld -r` to create a new\nobject file which is then passed along. The MSVC linker, however, is not able to\ndo this operation.\n\nThe compiler will now no longer attempt to assemble object files together but\nwill instead just pass through all the object files as usual. This implies that\nrlibs may not contain more than one object file (if the library is compiled with\nmore than one codegen unit) and the output of `-C save-temps` will have changed\nslightly as object files with the extension `0.o` will not be renamed to `o`\nunless requested otherwise.", "tree": {"sha": "84500a1b8710ce20e06e86ea4c9b6903ba38458f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84500a1b8710ce20e06e86ea4c9b6903ba38458f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d23239b48e2066d3f38eb03e2429427bffade822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d23239b48e2066d3f38eb03e2429427bffade822", "html_url": "https://github.com/rust-lang/rust/commit/d23239b48e2066d3f38eb03e2429427bffade822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d23239b48e2066d3f38eb03e2429427bffade822/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6a9be10bc1b178dc0b23c505fc8f17e925cabb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a9be10bc1b178dc0b23c505fc8f17e925cabb2", "html_url": "https://github.com/rust-lang/rust/commit/e6a9be10bc1b178dc0b23c505fc8f17e925cabb2"}], "stats": {"total": 183, "additions": 60, "deletions": 123}, "files": [{"sha": "9d5dcdd855d71475b748ddc51fc802467dc52841", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 45, "deletions": 41, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d23239b48e2066d3f38eb03e2429427bffade822/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d23239b48e2066d3f38eb03e2429427bffade822/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=d23239b48e2066d3f38eb03e2429427bffade822", "patch": "@@ -417,11 +417,10 @@ pub fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        let obj_filename = outputs.temp_path(OutputTypeObject);\n-        if !sess.opts.output_types.contains(&OutputTypeObject) {\n-            remove(sess, &obj_filename);\n+        for obj in object_filenames(sess, outputs) {\n+            remove(sess, &obj);\n         }\n-        remove(sess, &obj_filename.with_extension(\"metadata.o\"));\n+        remove(sess, &outputs.with_extension(\"metadata.o\"));\n     }\n \n     out_filenames\n@@ -499,7 +498,7 @@ fn link_binary_output(sess: &Session,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n                       crate_name: &str) -> PathBuf {\n-    let obj_filename = outputs.temp_path(OutputTypeObject);\n+    let objects = object_filenames(sess, outputs);\n     let out_filename = match outputs.single_output_file {\n         Some(ref file) => file.clone(),\n         None => {\n@@ -508,41 +507,41 @@ fn link_binary_output(sess: &Session,\n         }\n     };\n \n-    // Make sure the output and obj_filename are both writeable.\n-    // Mac, FreeBSD, and Windows system linkers check this already --\n-    // however, the Linux linker will happily overwrite a read-only file.\n-    // We should be consistent.\n-    let obj_is_writeable = is_writeable(&obj_filename);\n-    let out_is_writeable = is_writeable(&out_filename);\n-    if !out_is_writeable {\n-        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n-                            permissions.\",\n-                           out_filename.display()));\n-    }\n-    else if !obj_is_writeable {\n-        sess.fatal(&format!(\"object file {} is not writeable -- check its \\\n-                            permissions.\",\n-                           obj_filename.display()));\n+    // Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n+    // check this already -- however, the Linux linker will happily overwrite a\n+    // read-only file.  We should be consistent.\n+    for file in objects.iter().chain(Some(&out_filename)) {\n+        if !is_writeable(file) {\n+            sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n+                                permissions\", file.display()));\n+        }\n     }\n \n     match crate_type {\n         config::CrateTypeRlib => {\n-            link_rlib(sess, Some(trans), &obj_filename, &out_filename).build();\n+            link_rlib(sess, Some(trans), &objects, &out_filename).build();\n         }\n         config::CrateTypeStaticlib => {\n-            link_staticlib(sess, &obj_filename, &out_filename);\n+            link_staticlib(sess, &objects, &out_filename);\n         }\n         config::CrateTypeExecutable => {\n-            link_natively(sess, trans, false, &obj_filename, &out_filename);\n+            link_natively(sess, trans, false, &objects, &out_filename, outputs);\n         }\n         config::CrateTypeDylib => {\n-            link_natively(sess, trans, true, &obj_filename, &out_filename);\n+            link_natively(sess, trans, true, &objects, &out_filename, outputs);\n         }\n     }\n \n     out_filename\n }\n \n+fn object_filenames(sess: &Session, outputs: &OutputFilenames) -> Vec<PathBuf> {\n+    (0..sess.opts.cg.codegen_units).map(|i| {\n+        let ext = format!(\"{}.o\", i);\n+        outputs.temp_path(OutputTypeObject).with_extension(&ext)\n+    }).collect()\n+}\n+\n fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     let mut search = Vec::new();\n     sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n@@ -560,9 +559,9 @@ fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n // native libraries and inserting all of the contents into this archive.\n fn link_rlib<'a>(sess: &'a Session,\n                  trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n-                 obj_filename: &Path,\n+                 objects: &[PathBuf],\n                  out_filename: &Path) -> ArchiveBuilder<'a> {\n-    info!(\"preparing rlib from {:?} to {:?}\", obj_filename, out_filename);\n+    info!(\"preparing rlib from {:?} to {:?}\", objects, out_filename);\n     let handler = &sess.diagnostic().handler;\n     let config = ArchiveConfig {\n         handler: handler,\n@@ -574,7 +573,9 @@ fn link_rlib<'a>(sess: &'a Session,\n         command_path: command_path(sess),\n     };\n     let mut ab = ArchiveBuilder::create(config);\n-    ab.add_file(obj_filename).unwrap();\n+    for obj in objects {\n+        ab.add_file(obj).unwrap();\n+    }\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n@@ -600,7 +601,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     // this is as follows:\n     //\n     // * When performing LTO, this archive will be modified to remove\n-    //   obj_filename from above. The reason for this is described below.\n+    //   objects from above. The reason for this is described below.\n     //\n     // * When the system linker looks at an archive, it will attempt to\n     //   determine the architecture of the archive in order to see whether its\n@@ -639,15 +640,14 @@ fn link_rlib<'a>(sess: &'a Session,\n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.  If codegen_units > 1, we insert each of the\n             // bitcode files.\n-            for i in 0..sess.opts.cg.codegen_units {\n+            for obj in objects {\n                 // Note that we make sure that the bytecode filename in the\n                 // archive is never exactly 16 bytes long by adding a 16 byte\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(&format!(\"{}.bc\", i));\n-                let bc_deflated_filename = obj_filename.with_extension(\n-                    &format!(\"{}.bytecode.deflate\", i));\n+                let bc_filename = obj.with_extension(\"bc\");\n+                let bc_deflated_filename = obj.with_extension(\"bytecode.deflate\");\n \n                 let mut bc_data = Vec::new();\n                 match fs::File::open(&bc_filename).and_then(|mut f| {\n@@ -750,8 +750,8 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n // There's no need to include metadata in a static archive, so ensure to not\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n-fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n-    let ab = link_rlib(sess, None, obj_filename, out_filename);\n+fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path) {\n+    let ab = link_rlib(sess, None, objects, out_filename);\n     let mut ab = match sess.target.target.options.is_like_osx {\n         true => ab.build().extend(),\n         false => ab,\n@@ -806,8 +806,9 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n // This will invoke the system linker/cc to create the resulting file. This\n // links to all upstream files as well.\n fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n-                 obj_filename: &Path, out_filename: &Path) {\n-    info!(\"preparing dylib? ({}) from {:?} to {:?}\", dylib, obj_filename,\n+                 objects: &[PathBuf], out_filename: &Path,\n+                 outputs: &OutputFilenames) {\n+    info!(\"preparing dylib? ({}) from {:?} to {:?}\", dylib, objects,\n           out_filename);\n     let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n \n@@ -828,7 +829,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             Box::new(GnuLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n         };\n         link_args(&mut *linker, sess, dylib, tmpdir.path(),\n-                  trans, obj_filename, out_filename);\n+                  trans, objects, out_filename, outputs);\n         if !sess.target.target.options.no_compiler_rt {\n             linker.link_staticlib(\"compiler-rt\");\n         }\n@@ -884,8 +885,9 @@ fn link_args(cmd: &mut Linker,\n              dylib: bool,\n              tmpdir: &Path,\n              trans: &CrateTranslation,\n-             obj_filename: &Path,\n-             out_filename: &Path) {\n+             objects: &[PathBuf],\n+             out_filename: &Path,\n+             outputs: &OutputFilenames) {\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n@@ -895,7 +897,9 @@ fn link_args(cmd: &mut Linker,\n     let t = &sess.target.target;\n \n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    cmd.add_object(obj_filename);\n+    for obj in objects {\n+        cmd.add_object(obj);\n+    }\n     cmd.output_filename(out_filename);\n \n     // Stack growth requires statically linking a __morestack function. Note\n@@ -922,7 +926,7 @@ fn link_args(cmd: &mut Linker,\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if dylib {\n-        cmd.add_object(&obj_filename.with_extension(\"metadata.o\"));\n+        cmd.add_object(&outputs.with_extension(\"metadata.o\"));\n     }\n \n     // Try to strip as much out of the generated object by removing unused"}, {"sha": "0a9db8a651e65d0ab1d37ec6e211c6c995d2aafc", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 14, "deletions": 81, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d23239b48e2066d3f38eb03e2429427bffade822/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d23239b48e2066d3f38eb03e2429427bffade822/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=d23239b48e2066d3f38eb03e2429427bffade822", "patch": "@@ -27,7 +27,6 @@ use std::ffi::{CStr, CString};\n use std::fs;\n use std::mem;\n use std::path::Path;\n-use std::process::Stdio;\n use std::ptr;\n use std::str;\n use std::sync::{Arc, Mutex};\n@@ -619,6 +618,8 @@ pub fn run_passes(sess: &Session,\n     let needs_crate_bitcode =\n             sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n             sess.opts.output_types.contains(&config::OutputTypeExe);\n+    let needs_crate_object =\n+            sess.opts.output_types.contains(&config::OutputTypeExe);\n     if needs_crate_bitcode {\n         modules_config.emit_bc = true;\n     }\n@@ -696,7 +697,8 @@ pub fn run_passes(sess: &Session,\n         if sess.opts.cg.codegen_units == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n-            copy_gracefully(&crate_output.with_extension(ext), &crate_output.path(output_type));\n+            copy_gracefully(&crate_output.with_extension(ext),\n+                            &crate_output.path(output_type));\n             if !sess.opts.cg.save_temps && !keep_numbered {\n                 // The user just wants `foo.x`, not `foo.0.x`.\n                 remove(sess, &crate_output.with_extension(ext));\n@@ -715,76 +717,11 @@ pub fn run_passes(sess: &Session,\n         }\n     };\n \n-    let link_obj = |output_path: &Path| {\n-        // Running `ld -r` on a single input is kind of pointless.\n-        if sess.opts.cg.codegen_units == 1 {\n-            copy_gracefully(&crate_output.with_extension(\"0.o\"), output_path);\n-            // Leave the .0.o file around, to mimic the behavior of the normal\n-            // code path.\n-            return;\n-        }\n-\n-        // Some builds of MinGW GCC will pass --force-exe-suffix to ld, which\n-        // will automatically add a .exe extension if the extension is not\n-        // already .exe or .dll.  To ensure consistent behavior on Windows, we\n-        // add the .exe suffix explicitly and then rename the output file to\n-        // the desired path.  This will give the correct behavior whether or\n-        // not GCC adds --force-exe-suffix.\n-        let windows_output_path =\n-            if sess.target.target.options.is_like_windows {\n-                Some(output_path.with_extension(\"o.exe\"))\n-            } else {\n-                None\n-            };\n-\n-        let (pname, mut cmd) = get_linker(sess);\n-\n-        cmd.args(&sess.target.target.options.pre_link_args);\n-        cmd.arg(\"-nostdlib\");\n-\n-        for index in 0..trans.modules.len() {\n-            cmd.arg(&crate_output.with_extension(&format!(\"{}.o\", index)));\n-        }\n-\n-        cmd.arg(\"-r\").arg(\"-o\")\n-           .arg(windows_output_path.as_ref().map(|s| &**s).unwrap_or(output_path));\n-\n-        cmd.args(&sess.target.target.options.post_link_args);\n-\n-        if sess.opts.debugging_opts.print_link_args {\n-            println!(\"{:?}\", &cmd);\n-        }\n-\n-        cmd.stdin(Stdio::null());\n-        match cmd.status() {\n-            Ok(status) => {\n-                if !status.success() {\n-                    sess.err(&format!(\"linking of {} with `{:?}` failed\",\n-                                     output_path.display(), cmd));\n-                    sess.abort_if_errors();\n-                }\n-            },\n-            Err(e) => {\n-                sess.err(&format!(\"could not exec the linker `{}`: {}\",\n-                                 pname, e));\n-                sess.abort_if_errors();\n-            },\n-        }\n-\n-        match windows_output_path {\n-            Some(ref windows_path) => {\n-                fs::rename(windows_path, output_path).unwrap();\n-            },\n-            None => {\n-                // The file is already named according to `output_path`.\n-            }\n-        }\n-    };\n-\n     // Flag to indicate whether the user explicitly requested bitcode.\n     // Otherwise, we produced it only as a temporary output, and will need\n     // to get rid of it.\n     let mut user_wants_bitcode = false;\n+    let mut user_wants_objects = false;\n     for output_type in output_types {\n         match *output_type {\n             config::OutputTypeBitcode => {\n@@ -801,17 +738,10 @@ pub fn run_passes(sess: &Session,\n                 copy_if_one_unit(\"0.s\", config::OutputTypeAssembly, false);\n             }\n             config::OutputTypeObject => {\n-                link_obj(&crate_output.path(config::OutputTypeObject));\n-            }\n-            config::OutputTypeExe => {\n-                // If config::OutputTypeObject is already in the list, then\n-                // `crate.o` will be handled by the config::OutputTypeObject case.\n-                // Otherwise, we need to create the temporary object so we\n-                // can run the linker.\n-                if !sess.opts.output_types.contains(&config::OutputTypeObject) {\n-                    link_obj(&crate_output.temp_path(config::OutputTypeObject));\n-                }\n+                user_wants_objects = true;\n+                copy_if_one_unit(\"0.o\", config::OutputTypeObject, true);\n             }\n+            config::OutputTypeExe |\n             config::OutputTypeDepInfo => {}\n         }\n     }\n@@ -848,15 +778,18 @@ pub fn run_passes(sess: &Session,\n         let keep_numbered_bitcode = needs_crate_bitcode ||\n                 (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n \n+        let keep_numbered_objects = needs_crate_object ||\n+                (user_wants_objects && sess.opts.cg.codegen_units > 1);\n+\n         for i in 0..trans.modules.len() {\n-            if modules_config.emit_obj {\n+            if modules_config.emit_obj && !keep_numbered_objects {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(&ext[..]));\n+                remove(sess, &crate_output.with_extension(&ext));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(&ext[..]));\n+                remove(sess, &crate_output.with_extension(&ext));\n             }\n         }\n "}, {"sha": "d33c18a6f3c2c8159045b935a85a59c0a06354b7", "filename": "src/test/run-make/extra-filename-with-temp-outputs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d23239b48e2066d3f38eb03e2429427bffade822/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d23239b48e2066d3f38eb03e2429427bffade822/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextra-filename-with-temp-outputs%2FMakefile?ref=d23239b48e2066d3f38eb03e2429427bffade822", "patch": "@@ -2,5 +2,5 @@\n \n all:\n \t$(RUSTC) -C extra-filename=bar foo.rs -C save-temps\n-\trm $(TMPDIR)/foobar.o\n+\trm $(TMPDIR)/foobar.0.o\n \trm $(TMPDIR)/$(call BIN,foobar)"}]}