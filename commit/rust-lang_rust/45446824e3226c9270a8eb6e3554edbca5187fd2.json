{"sha": "45446824e3226c9270a8eb6e3554edbca5187fd2", "node_id": "C_kwDOAAsO6NoAKDQ1NDQ2ODI0ZTMyMjZjOTI3MGE4ZWI2ZTM1NTRlZGJjYTUxODdmZDI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-29T19:03:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-29T19:03:37Z"}, "message": "Rollup merge of #107006 - b-naber:thir-tree, r=jackh726\n\nOutput tree representation on thir-tree\n\nThe current output of `-Zunpretty=thir-tree` is really cumbersome to work with, using an actual tree representation should make it easier to see what the thir looks like.", "tree": {"sha": "55839c7a93c0e92fd53b0ca8413fe5501bda0dbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55839c7a93c0e92fd53b0ca8413fe5501bda0dbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45446824e3226c9270a8eb6e3554edbca5187fd2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj1sMJCRBK7hj4Ov3rIwAAUVEIAJJ74UyJUEZnStDysLQDUu7P\nb6tlIc3Eb0SBXvSWM6pjn74wx21gbEMJAFTb8maDXOx/jnxJpAYolYV+TrrXjHNG\nrfLc+GPkZrFwKE5rTIT45pZkg5DSomgBws8igMpbsq+brTvDTdnMs1iNgHhpcjI1\nhy2Cdpyk2a5y8J/3QgwXXdgU2AdNAYTF1pyshgGmR4P56d5tdjAoo1oS86yGNz29\n9u8AZ6OlDC3ukkzbmCekwQrJpHQ3spmhdbyH65/Z508hwj8us2wkltGSA1HUOV1r\ndU0bsvdEhP23baM+KqKJH6zBkF31iDpyaIUuEYNG/oPdBu6IyQCUolG4N3IiFGc=\n=AOSM\n-----END PGP SIGNATURE-----\n", "payload": "tree 55839c7a93c0e92fd53b0ca8413fe5501bda0dbf\nparent 782da867c801441212a00f20bf75bc312c815460\nparent 92f2d27d1b5ec6b81299edf0e55bb1f0fc45ae9b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1675019017 +0100\ncommitter GitHub <noreply@github.com> 1675019017 +0100\n\nRollup merge of #107006 - b-naber:thir-tree, r=jackh726\n\nOutput tree representation on thir-tree\n\nThe current output of `-Zunpretty=thir-tree` is really cumbersome to work with, using an actual tree representation should make it easier to see what the thir looks like.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45446824e3226c9270a8eb6e3554edbca5187fd2", "html_url": "https://github.com/rust-lang/rust/commit/45446824e3226c9270a8eb6e3554edbca5187fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45446824e3226c9270a8eb6e3554edbca5187fd2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "782da867c801441212a00f20bf75bc312c815460", "url": "https://api.github.com/repos/rust-lang/rust/commits/782da867c801441212a00f20bf75bc312c815460", "html_url": "https://github.com/rust-lang/rust/commit/782da867c801441212a00f20bf75bc312c815460"}, {"sha": "92f2d27d1b5ec6b81299edf0e55bb1f0fc45ae9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/92f2d27d1b5ec6b81299edf0e55bb1f0fc45ae9b", "html_url": "https://github.com/rust-lang/rust/commit/92f2d27d1b5ec6b81299edf0e55bb1f0fc45ae9b"}], "stats": {"total": 1354, "additions": 1345, "deletions": 9}, "files": [{"sha": "446c6832cb7b607657a23a63e4c628d0123867cc", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -498,6 +498,21 @@ fn print_with_analysis(tcx: TyCtxt<'_>, ppm: PpMode) -> Result<(), ErrorGuarante\n             out\n         }\n \n+        ThirFlat => {\n+            let mut out = String::new();\n+            abort_on_err(rustc_hir_analysis::check_crate(tcx), tcx.sess);\n+            debug!(\"pretty printing THIR flat\");\n+            for did in tcx.hir().body_owners() {\n+                let _ = writeln!(\n+                    out,\n+                    \"{:?}:\\n{}\\n\",\n+                    did,\n+                    tcx.thir_flat(ty::WithOptConstParam::unknown(did))\n+                );\n+            }\n+            out\n+        }\n+\n         _ => unreachable!(),\n     };\n "}, {"sha": "1f1f4fc95b59aa666e791ef48a970466978d5a07", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -361,6 +361,13 @@ rustc_queries! {\n         desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n     }\n \n+    /// Create a list-like THIR representation for debugging.\n+    query thir_flat(key: ty::WithOptConstParam<LocalDefId>) -> String {\n+        no_hash\n+        arena_cache\n+        desc { |tcx| \"constructing flat THIR representation for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n+    }\n+\n     /// Set of all the `DefId`s in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors."}, {"sha": "6f2dac467532cdfb50e2b54b24276ff7278719ee", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -29,6 +29,7 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n+pub mod print;\n pub mod visit;\n \n macro_rules! thir_with_elements {"}, {"sha": "60b903e99066b6d4ef8b5127f2dec7d768c05583", "filename": "compiler/rustc_middle/src/thir/print.rs", "status": "added", "additions": 881, "deletions": 0, "changes": 881, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -0,0 +1,881 @@\n+use crate::thir::*;\n+use crate::ty::{self, TyCtxt};\n+\n+use std::fmt::{self, Write};\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub fn thir_tree_representation<'a>(self, thir: &'a Thir<'tcx>) -> String {\n+        let mut printer = ThirPrinter::new(thir);\n+        printer.print();\n+        printer.into_buffer()\n+    }\n+}\n+\n+struct ThirPrinter<'a, 'tcx> {\n+    thir: &'a Thir<'tcx>,\n+    fmt: String,\n+}\n+\n+const INDENT: &str = \"    \";\n+\n+macro_rules! print_indented {\n+    ($writer:ident, $s:expr, $indent_lvl:expr) => {\n+        let indent = (0..$indent_lvl).map(|_| INDENT).collect::<Vec<_>>().concat();\n+        writeln!($writer, \"{}{}\", indent, $s).expect(\"unable to write to ThirPrinter\");\n+    };\n+}\n+\n+impl<'a, 'tcx> Write for ThirPrinter<'a, 'tcx> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.fmt.push_str(s);\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, 'tcx> ThirPrinter<'a, 'tcx> {\n+    fn new(thir: &'a Thir<'tcx>) -> Self {\n+        Self { thir, fmt: String::new() }\n+    }\n+\n+    fn print(&mut self) {\n+        print_indented!(self, \"params: [\", 0);\n+        for param in self.thir.params.iter() {\n+            self.print_param(param, 1);\n+        }\n+        print_indented!(self, \"]\", 0);\n+\n+        print_indented!(self, \"body:\", 0);\n+        let expr = ExprId::from_usize(self.thir.exprs.len() - 1);\n+        self.print_expr(expr, 1);\n+    }\n+\n+    fn into_buffer(self) -> String {\n+        self.fmt\n+    }\n+\n+    fn print_param(&mut self, param: &Param<'tcx>, depth_lvl: usize) {\n+        let Param { pat, ty, ty_span, self_kind, hir_id } = param;\n+\n+        print_indented!(self, \"Param {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"ty_span: {:?}\", ty_span), depth_lvl + 1);\n+        print_indented!(self, format!(\"self_kind: {:?}\", self_kind), depth_lvl + 1);\n+        print_indented!(self, format!(\"hir_id: {:?}\", hir_id), depth_lvl + 1);\n+\n+        if let Some(pat) = pat {\n+            print_indented!(self, \"param: Some( \", depth_lvl + 1);\n+            self.print_pat(pat, depth_lvl + 2);\n+            print_indented!(self, \")\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"param: None\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_block(&mut self, block_id: BlockId, depth_lvl: usize) {\n+        let Block {\n+            targeted_by_break,\n+            opt_destruction_scope,\n+            span,\n+            region_scope,\n+            stmts,\n+            expr,\n+            safety_mode,\n+        } = &self.thir.blocks[block_id];\n+\n+        print_indented!(self, \"Block {\", depth_lvl);\n+        print_indented!(self, format!(\"targeted_by_break: {}\", targeted_by_break), depth_lvl + 1);\n+        print_indented!(\n+            self,\n+            format!(\"opt_destruction_scope: {:?}\", opt_destruction_scope),\n+            depth_lvl + 1\n+        );\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, format!(\"region_scope: {:?}\", region_scope), depth_lvl + 1);\n+        print_indented!(self, format!(\"safety_mode: {:?}\", safety_mode), depth_lvl + 1);\n+\n+        if stmts.len() > 0 {\n+            print_indented!(self, \"stmts: [\", depth_lvl + 1);\n+            for stmt in stmts.iter() {\n+                self.print_stmt(*stmt, depth_lvl + 2);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"stmts: []\", depth_lvl + 1);\n+        }\n+\n+        if let Some(expr_id) = expr {\n+            print_indented!(self, \"expr:\", depth_lvl + 1);\n+            self.print_expr(*expr_id, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"expr: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_stmt(&mut self, stmt_id: StmtId, depth_lvl: usize) {\n+        let Stmt { kind, opt_destruction_scope } = &self.thir.stmts[stmt_id];\n+\n+        print_indented!(self, \"Stmt {\", depth_lvl);\n+        print_indented!(\n+            self,\n+            format!(\"opt_destruction_scope: {:?}\", opt_destruction_scope),\n+            depth_lvl + 1\n+        );\n+\n+        match kind {\n+            StmtKind::Expr { scope, expr } => {\n+                print_indented!(self, \"kind: Expr {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"scope: {:?}\", scope), depth_lvl + 2);\n+                print_indented!(self, \"expr:\", depth_lvl + 2);\n+                self.print_expr(*expr, depth_lvl + 3);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            StmtKind::Let {\n+                remainder_scope,\n+                init_scope,\n+                pattern,\n+                initializer,\n+                else_block,\n+                lint_level,\n+            } => {\n+                print_indented!(self, \"kind: Let {\", depth_lvl + 1);\n+                print_indented!(\n+                    self,\n+                    format!(\"remainder_scope: {:?}\", remainder_scope),\n+                    depth_lvl + 2\n+                );\n+                print_indented!(self, format!(\"init_scope: {:?}\", init_scope), depth_lvl + 2);\n+\n+                print_indented!(self, \"pattern: \", depth_lvl + 2);\n+                self.print_pat(pattern, depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+\n+                if let Some(init) = initializer {\n+                    print_indented!(self, \"initializer: Some(\", depth_lvl + 2);\n+                    self.print_expr(*init, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"initializer: None\", depth_lvl + 2);\n+                }\n+\n+                if let Some(else_block) = else_block {\n+                    print_indented!(self, \"else_block: Some(\", depth_lvl + 2);\n+                    self.print_block(*else_block, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"else_block: None\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_expr(&mut self, expr: ExprId, depth_lvl: usize) {\n+        let Expr { ty, temp_lifetime, span, kind } = &self.thir[expr];\n+        print_indented!(self, \"Expr {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"temp_lifetime: {:?}\", temp_lifetime), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, \"kind: \", depth_lvl + 1);\n+        self.print_expr_kind(kind, depth_lvl + 2);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_expr_kind(&mut self, expr_kind: &ExprKind<'tcx>, depth_lvl: usize) {\n+        use rustc_middle::thir::ExprKind::*;\n+\n+        match expr_kind {\n+            Scope { region_scope, value, lint_level } => {\n+                print_indented!(self, \"Scope {\", depth_lvl);\n+                print_indented!(self, format!(\"region_scope: {:?}\", region_scope), depth_lvl + 1);\n+                print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 1);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Box { value } => {\n+                print_indented!(self, \"Box {\", depth_lvl);\n+                self.print_expr(*value, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            If { if_then_scope, cond, then, else_opt } => {\n+                print_indented!(self, \"If {\", depth_lvl);\n+                print_indented!(self, format!(\"if_then_scope: {:?}\", if_then_scope), depth_lvl + 1);\n+                print_indented!(self, \"cond:\", depth_lvl + 1);\n+                self.print_expr(*cond, depth_lvl + 2);\n+                print_indented!(self, \"then:\", depth_lvl + 1);\n+                self.print_expr(*then, depth_lvl + 2);\n+\n+                if let Some(else_expr) = else_opt {\n+                    print_indented!(self, \"else:\", depth_lvl + 1);\n+                    self.print_expr(*else_expr, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Call { fun, args, ty, from_hir_call, fn_span } => {\n+                print_indented!(self, \"Call {\", depth_lvl);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"from_hir_call: {}\", from_hir_call), depth_lvl + 1);\n+                print_indented!(self, format!(\"fn_span: {:?}\", fn_span), depth_lvl + 1);\n+                print_indented!(self, \"fun:\", depth_lvl + 1);\n+                self.print_expr(*fun, depth_lvl + 2);\n+\n+                if args.len() > 0 {\n+                    print_indented!(self, \"args: [\", depth_lvl + 1);\n+                    for arg in args.iter() {\n+                        self.print_expr(*arg, depth_lvl + 2);\n+                    }\n+                    print_indented!(self, \"]\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"args: []\", depth_lvl + 1);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Deref { arg } => {\n+                print_indented!(self, \"Deref {\", depth_lvl);\n+                self.print_expr(*arg, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Binary { op, lhs, rhs } => {\n+                print_indented!(self, \"Binary {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            LogicalOp { op, lhs, rhs } => {\n+                print_indented!(self, \"LogicalOp {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Unary { op, arg } => {\n+                print_indented!(self, \"Unary {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Cast { source } => {\n+                print_indented!(self, \"Cast {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Use { source } => {\n+                print_indented!(self, \"Use {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            NeverToAny { source } => {\n+                print_indented!(self, \"NeverToAny {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Pointer { cast, source } => {\n+                print_indented!(self, \"Pointer {\", depth_lvl);\n+                print_indented!(self, format!(\"cast: {:?}\", cast), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Loop { body } => {\n+                print_indented!(self, \"Loop (\", depth_lvl);\n+                print_indented!(self, \"body:\", depth_lvl + 1);\n+                self.print_expr(*body, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            Let { expr, pat } => {\n+                print_indented!(self, \"Let {\", depth_lvl);\n+                print_indented!(self, \"expr:\", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, format!(\"pat: {:?}\", pat), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Match { scrutinee, arms } => {\n+                print_indented!(self, \"Match {\", depth_lvl);\n+                print_indented!(self, \"scrutinee:\", depth_lvl + 1);\n+                self.print_expr(*scrutinee, depth_lvl + 2);\n+\n+                print_indented!(self, \"arms: [\", depth_lvl + 1);\n+                for arm_id in arms.iter() {\n+                    self.print_arm(*arm_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Block { block } => self.print_block(*block, depth_lvl),\n+            Assign { lhs, rhs } => {\n+                print_indented!(self, \"Assign {\", depth_lvl);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            AssignOp { op, lhs, rhs } => {\n+                print_indented!(self, \"AssignOp {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Field { lhs, variant_index, name } => {\n+                print_indented!(self, \"Field {\", depth_lvl);\n+                print_indented!(self, format!(\"variant_index: {:?}\", variant_index), depth_lvl + 1);\n+                print_indented!(self, format!(\"name: {:?}\", name), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Index { lhs, index } => {\n+                print_indented!(self, \"Index {\", depth_lvl);\n+                print_indented!(self, format!(\"index: {:?}\", index), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            VarRef { id } => {\n+                print_indented!(self, \"VarRef {\", depth_lvl);\n+                print_indented!(self, format!(\"id: {:?}\", id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            UpvarRef { closure_def_id, var_hir_id } => {\n+                print_indented!(self, \"UpvarRef {\", depth_lvl);\n+                print_indented!(\n+                    self,\n+                    format!(\"closure_def_id: {:?}\", closure_def_id),\n+                    depth_lvl + 1\n+                );\n+                print_indented!(self, format!(\"var_hir_id: {:?}\", var_hir_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Borrow { borrow_kind, arg } => {\n+                print_indented!(self, \"Borrow (\", depth_lvl);\n+                print_indented!(self, format!(\"borrow_kind: {:?}\", borrow_kind), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            AddressOf { mutability, arg } => {\n+                print_indented!(self, \"AddressOf {\", depth_lvl);\n+                print_indented!(self, format!(\"mutability: {:?}\", mutability), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Break { label, value } => {\n+                print_indented!(self, \"Break (\", depth_lvl);\n+                print_indented!(self, format!(\"label: {:?}\", label), depth_lvl + 1);\n+\n+                if let Some(value) = value {\n+                    print_indented!(self, \"value:\", depth_lvl + 1);\n+                    self.print_expr(*value, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            Continue { label } => {\n+                print_indented!(self, \"Continue {\", depth_lvl);\n+                print_indented!(self, format!(\"label: {:?}\", label), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Return { value } => {\n+                print_indented!(self, \"Return {\", depth_lvl);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+\n+                if let Some(value) = value {\n+                    self.print_expr(*value, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ConstBlock { did, substs } => {\n+                print_indented!(self, \"ConstBlock {\", depth_lvl);\n+                print_indented!(self, format!(\"did: {:?}\", did), depth_lvl + 1);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Repeat { value, count } => {\n+                print_indented!(self, \"Repeat {\", depth_lvl);\n+                print_indented!(self, format!(\"count: {:?}\", count), depth_lvl + 1);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Array { fields } => {\n+                print_indented!(self, \"Array {\", depth_lvl);\n+                print_indented!(self, \"fields: [\", depth_lvl + 1);\n+                for field_id in fields.iter() {\n+                    self.print_expr(*field_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Tuple { fields } => {\n+                print_indented!(self, \"Tuple {\", depth_lvl);\n+                print_indented!(self, \"fields: [\", depth_lvl + 1);\n+                for field_id in fields.iter() {\n+                    self.print_expr(*field_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Adt(adt_expr) => {\n+                print_indented!(self, \"Adt {\", depth_lvl);\n+                self.print_adt_expr(&**adt_expr, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            PlaceTypeAscription { source, user_ty } => {\n+                print_indented!(self, \"PlaceTypeAscription {\", depth_lvl);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ValueTypeAscription { source, user_ty } => {\n+                print_indented!(self, \"ValueTypeAscription {\", depth_lvl);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Closure(closure_expr) => {\n+                print_indented!(self, \"Closure {\", depth_lvl);\n+                print_indented!(self, \"closure_expr:\", depth_lvl + 1);\n+                self.print_closure_expr(&**closure_expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Literal { lit, neg } => {\n+                print_indented!(\n+                    self,\n+                    format!(\"Literal( lit: {:?}, neg: {:?})\\n\", lit, neg),\n+                    depth_lvl\n+                );\n+            }\n+            NonHirLiteral { lit, user_ty } => {\n+                print_indented!(self, \"NonHirLiteral {\", depth_lvl);\n+                print_indented!(self, format!(\"lit: {:?}\", lit), depth_lvl + 1);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ZstLiteral { user_ty } => {\n+                print_indented!(self, format!(\"ZstLiteral(user_ty: {:?})\", user_ty), depth_lvl);\n+            }\n+            NamedConst { def_id, substs, user_ty } => {\n+                print_indented!(self, \"NamedConst {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ConstParam { param, def_id } => {\n+                print_indented!(self, \"ConstParam {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"param: {:?}\", param), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            StaticRef { alloc_id, ty, def_id } => {\n+                print_indented!(self, \"StaticRef {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"alloc_id: {:?}\", alloc_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            InlineAsm(expr) => {\n+                print_indented!(self, \"InlineAsm {\", depth_lvl);\n+                print_indented!(self, \"expr:\", depth_lvl + 1);\n+                self.print_inline_asm_expr(&**expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ThreadLocalRef(def_id) => {\n+                print_indented!(self, \"ThreadLocalRef {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Yield { value } => {\n+                print_indented!(self, \"Yield {\", depth_lvl);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+        }\n+    }\n+\n+    fn print_adt_expr(&mut self, adt_expr: &AdtExpr<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"adt_def:\", depth_lvl);\n+        self.print_adt_def(adt_expr.adt_def, depth_lvl + 1);\n+        print_indented!(\n+            self,\n+            format!(\"variant_index: {:?}\", adt_expr.variant_index),\n+            depth_lvl + 1\n+        );\n+        print_indented!(self, format!(\"substs: {:?}\", adt_expr.substs), depth_lvl + 1);\n+        print_indented!(self, format!(\"user_ty: {:?}\", adt_expr.user_ty), depth_lvl + 1);\n+\n+        for (i, field_expr) in adt_expr.fields.iter().enumerate() {\n+            print_indented!(self, format!(\"field {}:\", i), depth_lvl + 1);\n+            self.print_expr(field_expr.expr, depth_lvl + 2);\n+        }\n+\n+        if let Some(ref base) = adt_expr.base {\n+            print_indented!(self, \"base:\", depth_lvl + 1);\n+            self.print_fru_info(base, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"base: None\", depth_lvl + 1);\n+        }\n+    }\n+\n+    fn print_adt_def(&mut self, adt_def: ty::AdtDef<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"AdtDef {\", depth_lvl);\n+        print_indented!(self, format!(\"did: {:?}\", adt_def.did()), depth_lvl + 1);\n+        print_indented!(self, format!(\"variants: {:?}\", adt_def.variants()), depth_lvl + 1);\n+        print_indented!(self, format!(\"flags: {:?}\", adt_def.flags()), depth_lvl + 1);\n+        print_indented!(self, format!(\"repr: {:?}\", adt_def.repr()), depth_lvl + 1);\n+    }\n+\n+    fn print_fru_info(&mut self, fru_info: &FruInfo<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"FruInfo {\", depth_lvl);\n+        print_indented!(self, \"base: \", depth_lvl + 1);\n+        self.print_expr(fru_info.base, depth_lvl + 2);\n+        print_indented!(self, \"field_types: [\", depth_lvl + 1);\n+        for ty in fru_info.field_types.iter() {\n+            print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 2);\n+        }\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_arm(&mut self, arm_id: ArmId, depth_lvl: usize) {\n+        print_indented!(self, \"Arm {\", depth_lvl);\n+\n+        let arm = &self.thir.arms[arm_id];\n+        let Arm { pattern, guard, body, lint_level, scope, span } = arm;\n+\n+        print_indented!(self, \"pattern: \", depth_lvl + 1);\n+        self.print_pat(pattern, depth_lvl + 2);\n+\n+        if let Some(guard) = guard {\n+            print_indented!(self, \"guard: \", depth_lvl + 1);\n+            self.print_guard(guard, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"guard: None\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"body: \", depth_lvl + 1);\n+        self.print_expr(*body, depth_lvl + 2);\n+        print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 1);\n+        print_indented!(self, format!(\"scope: {:?}\", scope), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_pat(&mut self, pat: &Box<Pat<'tcx>>, depth_lvl: usize) {\n+        let Pat { ty, span, kind } = &**pat;\n+\n+        print_indented!(self, \"Pat: {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        self.print_pat_kind(kind, depth_lvl + 1);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_pat_kind(&mut self, pat_kind: &PatKind<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"kind: PatKind {\", depth_lvl);\n+\n+        match pat_kind {\n+            PatKind::Wild => {\n+                print_indented!(self, \"Wild\", depth_lvl + 1);\n+            }\n+            PatKind::AscribeUserType { ascription, subpattern } => {\n+                print_indented!(self, \"AscribeUserType: {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"ascription: {:?}\", ascription), depth_lvl + 2);\n+                print_indented!(self, \"subpattern: \", depth_lvl + 2);\n+                self.print_pat(subpattern, depth_lvl + 3);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Binding { mutability, name, mode, var, ty, subpattern, is_primary } => {\n+                print_indented!(self, \"Binding {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"mutability: {:?}\", mutability), depth_lvl + 2);\n+                print_indented!(self, format!(\"name: {:?}\", name), depth_lvl + 2);\n+                print_indented!(self, format!(\"mode: {:?}\", mode), depth_lvl + 2);\n+                print_indented!(self, format!(\"var: {:?}\", var), depth_lvl + 2);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 2);\n+                print_indented!(self, format!(\"is_primary: {:?}\", is_primary), depth_lvl + 2);\n+\n+                if let Some(subpattern) = subpattern {\n+                    print_indented!(self, \"subpattern: Some( \", depth_lvl + 2);\n+                    self.print_pat(subpattern, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"subpattern: None\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Variant { adt_def, substs, variant_index, subpatterns } => {\n+                print_indented!(self, \"Variant {\", depth_lvl + 1);\n+                print_indented!(self, \"adt_def: \", depth_lvl + 2);\n+                self.print_adt_def(*adt_def, depth_lvl + 3);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 2);\n+                print_indented!(self, format!(\"variant_index: {:?}\", variant_index), depth_lvl + 2);\n+\n+                if subpatterns.len() > 0 {\n+                    print_indented!(self, \"subpatterns: [\", depth_lvl + 2);\n+                    for field_pat in subpatterns.iter() {\n+                        self.print_pat(&field_pat.pattern, depth_lvl + 3);\n+                    }\n+                    print_indented!(self, \"]\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"subpatterns: []\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Leaf { subpatterns } => {\n+                print_indented!(self, \"Leaf { \", depth_lvl + 1);\n+                print_indented!(self, \"subpatterns: [\", depth_lvl + 2);\n+                for field_pat in subpatterns.iter() {\n+                    self.print_pat(&field_pat.pattern, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Deref { subpattern } => {\n+                print_indented!(self, \"Deref { \", depth_lvl + 1);\n+                print_indented!(self, \"subpattern: \", depth_lvl + 2);\n+                self.print_pat(subpattern, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Constant { value } => {\n+                print_indented!(self, \"Constant {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"value: {:?}\", value), depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Range(pat_range) => {\n+                print_indented!(self, format!(\"Range ( {:?} )\", pat_range), depth_lvl + 1);\n+            }\n+            PatKind::Slice { prefix, slice, suffix } => {\n+                print_indented!(self, \"Slice {\", depth_lvl + 1);\n+\n+                print_indented!(self, \"prefix: [\", depth_lvl + 2);\n+                for prefix_pat in prefix.iter() {\n+                    self.print_pat(prefix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                if let Some(slice) = slice {\n+                    print_indented!(self, \"slice: \", depth_lvl + 2);\n+                    self.print_pat(slice, depth_lvl + 3);\n+                }\n+\n+                print_indented!(self, \"suffix: [\", depth_lvl + 2);\n+                for suffix_pat in suffix.iter() {\n+                    self.print_pat(suffix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Array { prefix, slice, suffix } => {\n+                print_indented!(self, \"Array {\", depth_lvl + 1);\n+\n+                print_indented!(self, \"prefix: [\", depth_lvl + 2);\n+                for prefix_pat in prefix.iter() {\n+                    self.print_pat(prefix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                if let Some(slice) = slice {\n+                    print_indented!(self, \"slice: \", depth_lvl + 2);\n+                    self.print_pat(slice, depth_lvl + 3);\n+                }\n+\n+                print_indented!(self, \"suffix: [\", depth_lvl + 2);\n+                for suffix_pat in suffix.iter() {\n+                    self.print_pat(suffix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Or { pats } => {\n+                print_indented!(self, \"Or {\", depth_lvl + 1);\n+                print_indented!(self, \"pats: [\", depth_lvl + 2);\n+                for pat in pats.iter() {\n+                    self.print_pat(pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_guard(&mut self, guard: &Guard<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"Guard {\", depth_lvl);\n+\n+        match guard {\n+            Guard::If(expr_id) => {\n+                print_indented!(self, \"If (\", depth_lvl + 1);\n+                self.print_expr(*expr_id, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl + 1);\n+            }\n+            Guard::IfLet(pat, expr_id) => {\n+                print_indented!(self, \"IfLet (\", depth_lvl + 1);\n+                self.print_pat(pat, depth_lvl + 2);\n+                print_indented!(self, \",\", depth_lvl + 1);\n+                self.print_expr(*expr_id, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_closure_expr(&mut self, expr: &ClosureExpr<'tcx>, depth_lvl: usize) {\n+        let ClosureExpr { closure_id, substs, upvars, movability, fake_reads } = expr;\n+\n+        print_indented!(self, \"ClosureExpr {\", depth_lvl);\n+        print_indented!(self, format!(\"closure_id: {:?}\", closure_id), depth_lvl + 1);\n+        print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+\n+        if upvars.len() > 0 {\n+            print_indented!(self, \"upvars: [\", depth_lvl + 1);\n+            for upvar in upvars.iter() {\n+                self.print_expr(*upvar, depth_lvl + 2);\n+                print_indented!(self, \",\", depth_lvl + 1);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"upvars: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, format!(\"movability: {:?}\", movability), depth_lvl + 1);\n+\n+        if fake_reads.len() > 0 {\n+            print_indented!(self, \"fake_reads: [\", depth_lvl + 1);\n+            for (fake_read_expr, cause, hir_id) in fake_reads.iter() {\n+                print_indented!(self, \"(\", depth_lvl + 2);\n+                self.print_expr(*fake_read_expr, depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+                print_indented!(self, format!(\"cause: {:?}\", cause), depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+                print_indented!(self, format!(\"hir_id: {:?}\", hir_id), depth_lvl + 3);\n+                print_indented!(self, \"),\", depth_lvl + 2);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"fake_reads: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_inline_asm_expr(&mut self, expr: &InlineAsmExpr<'tcx>, depth_lvl: usize) {\n+        let InlineAsmExpr { template, operands, options, line_spans } = expr;\n+\n+        print_indented!(self, \"InlineAsmExpr {\", depth_lvl);\n+\n+        print_indented!(self, \"template: [\", depth_lvl + 1);\n+        for template_piece in template.iter() {\n+            print_indented!(self, format!(\"{:?}\", template_piece), depth_lvl + 2);\n+        }\n+        print_indented!(self, \"]\", depth_lvl + 1);\n+\n+        print_indented!(self, \"operands: [\", depth_lvl + 1);\n+        for operand in operands.iter() {\n+            self.print_inline_operand(operand, depth_lvl + 2);\n+        }\n+        print_indented!(self, \"]\", depth_lvl + 1);\n+\n+        print_indented!(self, format!(\"options: {:?}\", options), depth_lvl + 1);\n+        print_indented!(self, format!(\"line_spans: {:?}\", line_spans), depth_lvl + 1);\n+    }\n+\n+    fn print_inline_operand(&mut self, operand: &InlineAsmOperand<'tcx>, depth_lvl: usize) {\n+        match operand {\n+            InlineAsmOperand::In { reg, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::In {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, \"expr: \", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::Out { reg, late, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::Out {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+\n+                if let Some(out) = expr {\n+                    print_indented!(self, \"place: Some( \", depth_lvl + 1);\n+                    self.print_expr(*out, depth_lvl + 2);\n+                    print_indented!(self, \")\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"place: None\", depth_lvl + 1);\n+                }\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::InOut { reg, late, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::InOut {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+                print_indented!(self, \"expr: \", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                print_indented!(self, \"InlineAsmOperand::SplitInOut {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+                print_indented!(self, \"in_expr: \", depth_lvl + 1);\n+                self.print_expr(*in_expr, depth_lvl + 2);\n+\n+                if let Some(out_expr) = out_expr {\n+                    print_indented!(self, \"out_expr: Some( \", depth_lvl + 1);\n+                    self.print_expr(*out_expr, depth_lvl + 2);\n+                    print_indented!(self, \")\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"out_expr: None\", depth_lvl + 1);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::Const { value, span } => {\n+                print_indented!(self, \"InlineAsmOperand::Const {\", depth_lvl);\n+                print_indented!(self, format!(\"value: {:?}\", value), depth_lvl + 1);\n+                print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SymFn { value, span } => {\n+                print_indented!(self, \"InlineAsmOperand::SymFn {\", depth_lvl);\n+                print_indented!(self, format!(\"value: {:?}\", *value), depth_lvl + 1);\n+                print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SymStatic { def_id } => {\n+                print_indented!(self, \"InlineAsmOperand::SymStatic {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+    }\n+}"}, {"sha": "1655e224ddbb5b68f16f9710bdf509f18607d922", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -439,6 +439,10 @@ fn construct_fn<'tcx>(\n     let fn_id = tcx.hir().local_def_id_to_hir_id(fn_def.did);\n     let generator_kind = tcx.generator_kind(fn_def.did);\n \n+    // The representation of thir for `-Zunpretty=thir-tree` relies on\n+    // the entry expression being the last element of `thir.exprs`.\n+    assert_eq!(expr.as_usize(), thir.exprs.len() - 1);\n+\n     // Figure out what primary body this item has.\n     let body_id = tcx.hir().body_owned_by(fn_def.did);\n     let span_with_body = tcx.hir().span_with_body(fn_id);"}, {"sha": "94dae36154c26181757616366db754e6412999b6", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -34,4 +34,5 @@ pub fn provide(providers: &mut Providers) {\n     providers.thir_check_unsafety_for_const_arg = check_unsafety::thir_check_unsafety_for_const_arg;\n     providers.thir_body = thir::cx::thir_body;\n     providers.thir_tree = thir::cx::thir_tree;\n+    providers.thir_flat = thir::cx::thir_flat;\n }"}, {"sha": "10df4b229520f3bd1f8f572353b994cb14ae273e", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -53,6 +53,16 @@ pub(crate) fn thir_body(\n }\n \n pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n+    match thir_body(tcx, owner_def) {\n+        Ok((thir, _)) => {\n+            let thir = thir.steal();\n+            tcx.thir_tree_representation(&thir)\n+        }\n+        Err(_) => \"error\".into(),\n+    }\n+}\n+\n+pub(crate) fn thir_flat(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n     match thir_body(tcx, owner_def) {\n         Ok((thir, _)) => format!(\"{:#?}\", thir.steal()),\n         Err(_) => \"error\".into(),"}, {"sha": "c49c5fa990413d1aa3a109612c2773f3b646b65f", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -2573,6 +2573,7 @@ fn parse_pretty(unstable_opts: &UnstableOptions, efmt: ErrorOutputType) -> Optio\n         \"hir,typed\" => Hir(PpHirMode::Typed),\n         \"hir-tree\" => HirTree,\n         \"thir-tree\" => ThirTree,\n+        \"thir-flat\" => ThirFlat,\n         \"mir\" => Mir,\n         \"mir-cfg\" => MirCFG,\n         name => early_error(\n@@ -2581,7 +2582,8 @@ fn parse_pretty(unstable_opts: &UnstableOptions, efmt: ErrorOutputType) -> Optio\n                 \"argument to `unpretty` must be one of `normal`, `identified`, \\\n                             `expanded`, `expanded,identified`, `expanded,hygiene`, \\\n                             `ast-tree`, `ast-tree,expanded`, `hir`, `hir,identified`, \\\n-                            `hir,typed`, `hir-tree`, `thir-tree`, `mir` or `mir-cfg`; got {name}\"\n+                            `hir,typed`, `hir-tree`, `thir-tree`, `thir-flat`, `mir` or \\\n+                            `mir-cfg`; got {name}\"\n             ),\n         ),\n     };\n@@ -2736,6 +2738,8 @@ pub enum PpMode {\n     HirTree,\n     /// `-Zunpretty=thir-tree`\n     ThirTree,\n+    /// `-Zunpretty=`thir-flat`\n+    ThirFlat,\n     /// `-Zunpretty=mir`\n     Mir,\n     /// `-Zunpretty=mir-cfg`\n@@ -2754,6 +2758,7 @@ impl PpMode {\n             | Hir(_)\n             | HirTree\n             | ThirTree\n+            | ThirFlat\n             | Mir\n             | MirCFG => true,\n         }\n@@ -2763,13 +2768,13 @@ impl PpMode {\n         match *self {\n             Source(_) | AstTree(_) => false,\n \n-            Hir(_) | HirTree | ThirTree | Mir | MirCFG => true,\n+            Hir(_) | HirTree | ThirTree | ThirFlat | Mir | MirCFG => true,\n         }\n     }\n \n     pub fn needs_analysis(&self) -> bool {\n         use PpMode::*;\n-        matches!(*self, Mir | MirCFG | ThirTree)\n+        matches!(*self, Mir | MirCFG | ThirTree | ThirFlat)\n     }\n }\n "}, {"sha": "8fa95ce62b5efb017e2644d317568e51b993b8de", "filename": "tests/ui/thir-print/thir-flat.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-flat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-flat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthir-print%2Fthir-flat.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: -Z unpretty=thir-flat\n+// check-pass\n+\n+pub fn main() {}"}, {"sha": "c399fa66b6a03fe331d20adbce3689fa2b0ae967", "filename": "tests/ui/thir-print/thir-flat.stdout", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-flat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-flat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthir-print%2Fthir-flat.stdout?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -1,12 +1,12 @@\n-DefId(0:3 ~ thir_tree[8f1d]::main):\n+DefId(0:3 ~ thir_flat[45a6]::main):\n Thir {\n     arms: [],\n     blocks: [\n         Block {\n             targeted_by_break: false,\n             region_scope: Node(1),\n             opt_destruction_scope: None,\n-            span: $DIR/thir-tree.rs:4:15: 4:17 (#0),\n+            span: $DIR/thir-flat.rs:4:15: 4:17 (#0),\n             stmts: [],\n             expr: None,\n             safety_mode: Safe,\n@@ -18,7 +18,7 @@ Thir {\n             temp_lifetime: Some(\n                 Node(2),\n             ),\n-            span: $DIR/thir-tree.rs:4:15: 4:17 (#0),\n+            span: $DIR/thir-flat.rs:4:15: 4:17 (#0),\n             kind: Block {\n                 block: b0,\n             },\n@@ -28,11 +28,11 @@ Thir {\n             temp_lifetime: Some(\n                 Node(2),\n             ),\n-            span: $DIR/thir-tree.rs:4:15: 4:17 (#0),\n+            span: $DIR/thir-flat.rs:4:15: 4:17 (#0),\n             kind: Scope {\n                 region_scope: Node(2),\n                 lint_level: Explicit(\n-                    HirId(DefId(0:3 ~ thir_tree[8f1d]::main).2),\n+                    HirId(DefId(0:3 ~ thir_flat[45a6]::main).2),\n                 ),\n                 value: e0,\n             },\n@@ -42,7 +42,7 @@ Thir {\n             temp_lifetime: Some(\n                 Node(2),\n             ),\n-            span: $DIR/thir-tree.rs:4:15: 4:17 (#0),\n+            span: $DIR/thir-flat.rs:4:15: 4:17 (#0),\n             kind: Scope {\n                 region_scope: Destruction(2),\n                 lint_level: Inherited,", "previous_filename": "tests/ui/thir-tree.stdout"}, {"sha": "a5511ec95437f64ccb751337fc820065fff7e7bc", "filename": "tests/ui/thir-print/thir-tree-match.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-tree-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-tree-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthir-print%2Fthir-tree-match.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+// compile-flags: -Zunpretty=thir-tree\n+\n+enum Bar {\n+    First,\n+    Second,\n+    Third,\n+}\n+\n+enum Foo {\n+    FooOne(Bar),\n+    FooTwo,\n+}\n+\n+fn has_match(foo: Foo) -> bool {\n+    match foo {\n+        Foo::FooOne(Bar::First) => true,\n+        Foo::FooOne(_) => false,\n+        Foo::FooTwo => true,\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d6174ec262a445847e5b29aef59a1de0b74095c6", "filename": "tests/ui/thir-print/thir-tree-match.stdout", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-tree-match.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-tree-match.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthir-print%2Fthir-tree-match.stdout?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -0,0 +1,342 @@\n+DefId(0:16 ~ thir_tree_match[3c9a]::has_match):\n+params: [\n+    Param {\n+        ty: Foo\n+        ty_span: Some($DIR/thir-tree-match.rs:15:19: 15:22 (#0))\n+        self_kind: None\n+        hir_id: Some(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).1))\n+        param: Some( \n+            Pat: {\n+                ty: Foo\n+                span: $DIR/thir-tree-match.rs:15:14: 15:17 (#0)\n+                kind: PatKind {\n+                    Binding {\n+                        mutability: Not\n+                        name: \"foo\"\n+                        mode: ByValue\n+                        var: LocalVarId(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).2))\n+                        ty: Foo\n+                        is_primary: true\n+                        subpattern: None\n+                    }\n+                }\n+            }\n+        )\n+    }\n+]\n+body:\n+    Expr {\n+        ty: bool\n+        temp_lifetime: Some(Node(26))\n+        span: $DIR/thir-tree-match.rs:15:32: 21:2 (#0)\n+        kind: \n+            Scope {\n+                region_scope: Destruction(26)\n+                lint_level: Inherited\n+                value:\n+                    Expr {\n+                        ty: bool\n+                        temp_lifetime: Some(Node(26))\n+                        span: $DIR/thir-tree-match.rs:15:32: 21:2 (#0)\n+                        kind: \n+                            Scope {\n+                                region_scope: Node(26)\n+                                lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).26))\n+                                value:\n+                                    Expr {\n+                                        ty: bool\n+                                        temp_lifetime: Some(Node(26))\n+                                        span: $DIR/thir-tree-match.rs:15:32: 21:2 (#0)\n+                                        kind: \n+                                            Block {\n+                                                targeted_by_break: false\n+                                                opt_destruction_scope: None\n+                                                span: $DIR/thir-tree-match.rs:15:32: 21:2 (#0)\n+                                                region_scope: Node(25)\n+                                                safety_mode: Safe\n+                                                stmts: []\n+                                                expr:\n+                                                    Expr {\n+                                                        ty: bool\n+                                                        temp_lifetime: Some(Node(26))\n+                                                        span: $DIR/thir-tree-match.rs:16:5: 20:6 (#0)\n+                                                        kind: \n+                                                            Scope {\n+                                                                region_scope: Node(3)\n+                                                                lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).3))\n+                                                                value:\n+                                                                    Expr {\n+                                                                        ty: bool\n+                                                                        temp_lifetime: Some(Node(26))\n+                                                                        span: $DIR/thir-tree-match.rs:16:5: 20:6 (#0)\n+                                                                        kind: \n+                                                                            Match {\n+                                                                                scrutinee:\n+                                                                                    Expr {\n+                                                                                        ty: Foo\n+                                                                                        temp_lifetime: Some(Node(26))\n+                                                                                        span: $DIR/thir-tree-match.rs:16:11: 16:14 (#0)\n+                                                                                        kind: \n+                                                                                            Scope {\n+                                                                                                region_scope: Node(4)\n+                                                                                                lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).4))\n+                                                                                                value:\n+                                                                                                    Expr {\n+                                                                                                        ty: Foo\n+                                                                                                        temp_lifetime: Some(Node(26))\n+                                                                                                        span: $DIR/thir-tree-match.rs:16:11: 16:14 (#0)\n+                                                                                                        kind: \n+                                                                                                            VarRef {\n+                                                                                                                id: LocalVarId(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).2))\n+                                                                                                            }\n+                                                                                                    }\n+                                                                                            }\n+                                                                                    }\n+                                                                                arms: [\n+                                                                                    Arm {\n+                                                                                        pattern: \n+                                                                                            Pat: {\n+                                                                                                ty: Foo\n+                                                                                                span: $DIR/thir-tree-match.rs:17:9: 17:32 (#0)\n+                                                                                                kind: PatKind {\n+                                                                                                    Variant {\n+                                                                                                        adt_def: \n+                                                                                                            AdtDef {\n+                                                                                                                did: DefId(0:10 ~ thir_tree_match[3c9a]::Foo)\n+                                                                                                                variants: [VariantDef { def_id: DefId(0:11 ~ thir_tree_match[3c9a]::Foo::FooOne), ctor: Some((Fn, DefId(0:12 ~ thir_tree_match[3c9a]::Foo::FooOne::{constructor#0}))), name: \"FooOne\", discr: Relative(0), fields: [FieldDef { did: DefId(0:13 ~ thir_tree_match[3c9a]::Foo::FooOne::0), name: \"0\", vis: Restricted(DefId(0:0 ~ thir_tree_match[3c9a])) }], flags: NO_VARIANT_FLAGS }, VariantDef { def_id: DefId(0:14 ~ thir_tree_match[3c9a]::Foo::FooTwo), ctor: Some((Const, DefId(0:15 ~ thir_tree_match[3c9a]::Foo::FooTwo::{constructor#0}))), name: \"FooTwo\", discr: Relative(1), fields: [], flags: NO_VARIANT_FLAGS }]\n+                                                                                                                flags: IS_ENUM\n+                                                                                                                repr: ReprOptions { int: None, align: None, pack: None, flags: (empty), field_shuffle_seed: 11573694388057581 }\n+                                                                                                        substs: []\n+                                                                                                        variant_index: 0\n+                                                                                                        subpatterns: [\n+                                                                                                            Pat: {\n+                                                                                                                ty: Bar\n+                                                                                                                span: $DIR/thir-tree-match.rs:17:21: 17:31 (#0)\n+                                                                                                                kind: PatKind {\n+                                                                                                                    Variant {\n+                                                                                                                        adt_def: \n+                                                                                                                            AdtDef {\n+                                                                                                                                did: DefId(0:3 ~ thir_tree_match[3c9a]::Bar)\n+                                                                                                                                variants: [VariantDef { def_id: DefId(0:4 ~ thir_tree_match[3c9a]::Bar::First), ctor: Some((Const, DefId(0:5 ~ thir_tree_match[3c9a]::Bar::First::{constructor#0}))), name: \"First\", discr: Relative(0), fields: [], flags: NO_VARIANT_FLAGS }, VariantDef { def_id: DefId(0:6 ~ thir_tree_match[3c9a]::Bar::Second), ctor: Some((Const, DefId(0:7 ~ thir_tree_match[3c9a]::Bar::Second::{constructor#0}))), name: \"Second\", discr: Relative(1), fields: [], flags: NO_VARIANT_FLAGS }, VariantDef { def_id: DefId(0:8 ~ thir_tree_match[3c9a]::Bar::Third), ctor: Some((Const, DefId(0:9 ~ thir_tree_match[3c9a]::Bar::Third::{constructor#0}))), name: \"Third\", discr: Relative(2), fields: [], flags: NO_VARIANT_FLAGS }]\n+                                                                                                                                flags: IS_ENUM\n+                                                                                                                                repr: ReprOptions { int: None, align: None, pack: None, flags: (empty), field_shuffle_seed: 3125160937860410723 }\n+                                                                                                                        substs: []\n+                                                                                                                        variant_index: 0\n+                                                                                                                        subpatterns: []\n+                                                                                                                    }\n+                                                                                                                }\n+                                                                                                            }\n+                                                                                                        ]\n+                                                                                                    }\n+                                                                                                }\n+                                                                                            }\n+                                                                                        guard: None\n+                                                                                        body: \n+                                                                                            Expr {\n+                                                                                                ty: bool\n+                                                                                                temp_lifetime: Some(Node(13))\n+                                                                                                span: $DIR/thir-tree-match.rs:17:36: 17:40 (#0)\n+                                                                                                kind: \n+                                                                                                    Scope {\n+                                                                                                        region_scope: Destruction(13)\n+                                                                                                        lint_level: Inherited\n+                                                                                                        value:\n+                                                                                                            Expr {\n+                                                                                                                ty: bool\n+                                                                                                                temp_lifetime: Some(Node(13))\n+                                                                                                                span: $DIR/thir-tree-match.rs:17:36: 17:40 (#0)\n+                                                                                                                kind: \n+                                                                                                                    Scope {\n+                                                                                                                        region_scope: Node(13)\n+                                                                                                                        lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).13))\n+                                                                                                                        value:\n+                                                                                                                            Expr {\n+                                                                                                                                ty: bool\n+                                                                                                                                temp_lifetime: Some(Node(13))\n+                                                                                                                                span: $DIR/thir-tree-match.rs:17:36: 17:40 (#0)\n+                                                                                                                                kind: \n+                                                                                                                                    Literal( lit: Spanned { node: Bool(true), span: $DIR/thir-tree-match.rs:17:36: 17:40 (#0) }, neg: false)\n+\n+                                                                                                                            }\n+                                                                                                                    }\n+                                                                                                            }\n+                                                                                                    }\n+                                                                                            }\n+                                                                                        lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).12))\n+                                                                                        scope: Node(12)\n+                                                                                        span: $DIR/thir-tree-match.rs:17:9: 17:40 (#0)\n+                                                                                    }\n+                                                                                    Arm {\n+                                                                                        pattern: \n+                                                                                            Pat: {\n+                                                                                                ty: Foo\n+                                                                                                span: $DIR/thir-tree-match.rs:18:9: 18:23 (#0)\n+                                                                                                kind: PatKind {\n+                                                                                                    Variant {\n+                                                                                                        adt_def: \n+                                                                                                            AdtDef {\n+                                                                                                                did: DefId(0:10 ~ thir_tree_match[3c9a]::Foo)\n+                                                                                                                variants: [VariantDef { def_id: DefId(0:11 ~ thir_tree_match[3c9a]::Foo::FooOne), ctor: Some((Fn, DefId(0:12 ~ thir_tree_match[3c9a]::Foo::FooOne::{constructor#0}))), name: \"FooOne\", discr: Relative(0), fields: [FieldDef { did: DefId(0:13 ~ thir_tree_match[3c9a]::Foo::FooOne::0), name: \"0\", vis: Restricted(DefId(0:0 ~ thir_tree_match[3c9a])) }], flags: NO_VARIANT_FLAGS }, VariantDef { def_id: DefId(0:14 ~ thir_tree_match[3c9a]::Foo::FooTwo), ctor: Some((Const, DefId(0:15 ~ thir_tree_match[3c9a]::Foo::FooTwo::{constructor#0}))), name: \"FooTwo\", discr: Relative(1), fields: [], flags: NO_VARIANT_FLAGS }]\n+                                                                                                                flags: IS_ENUM\n+                                                                                                                repr: ReprOptions { int: None, align: None, pack: None, flags: (empty), field_shuffle_seed: 11573694388057581 }\n+                                                                                                        substs: []\n+                                                                                                        variant_index: 0\n+                                                                                                        subpatterns: [\n+                                                                                                            Pat: {\n+                                                                                                                ty: Bar\n+                                                                                                                span: $DIR/thir-tree-match.rs:18:21: 18:22 (#0)\n+                                                                                                                kind: PatKind {\n+                                                                                                                    Wild\n+                                                                                                                }\n+                                                                                                            }\n+                                                                                                        ]\n+                                                                                                    }\n+                                                                                                }\n+                                                                                            }\n+                                                                                        guard: None\n+                                                                                        body: \n+                                                                                            Expr {\n+                                                                                                ty: bool\n+                                                                                                temp_lifetime: Some(Node(19))\n+                                                                                                span: $DIR/thir-tree-match.rs:18:27: 18:32 (#0)\n+                                                                                                kind: \n+                                                                                                    Scope {\n+                                                                                                        region_scope: Destruction(19)\n+                                                                                                        lint_level: Inherited\n+                                                                                                        value:\n+                                                                                                            Expr {\n+                                                                                                                ty: bool\n+                                                                                                                temp_lifetime: Some(Node(19))\n+                                                                                                                span: $DIR/thir-tree-match.rs:18:27: 18:32 (#0)\n+                                                                                                                kind: \n+                                                                                                                    Scope {\n+                                                                                                                        region_scope: Node(19)\n+                                                                                                                        lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).19))\n+                                                                                                                        value:\n+                                                                                                                            Expr {\n+                                                                                                                                ty: bool\n+                                                                                                                                temp_lifetime: Some(Node(19))\n+                                                                                                                                span: $DIR/thir-tree-match.rs:18:27: 18:32 (#0)\n+                                                                                                                                kind: \n+                                                                                                                                    Literal( lit: Spanned { node: Bool(false), span: $DIR/thir-tree-match.rs:18:27: 18:32 (#0) }, neg: false)\n+\n+                                                                                                                            }\n+                                                                                                                    }\n+                                                                                                            }\n+                                                                                                    }\n+                                                                                            }\n+                                                                                        lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).18))\n+                                                                                        scope: Node(18)\n+                                                                                        span: $DIR/thir-tree-match.rs:18:9: 18:32 (#0)\n+                                                                                    }\n+                                                                                    Arm {\n+                                                                                        pattern: \n+                                                                                            Pat: {\n+                                                                                                ty: Foo\n+                                                                                                span: $DIR/thir-tree-match.rs:19:9: 19:20 (#0)\n+                                                                                                kind: PatKind {\n+                                                                                                    Variant {\n+                                                                                                        adt_def: \n+                                                                                                            AdtDef {\n+                                                                                                                did: DefId(0:10 ~ thir_tree_match[3c9a]::Foo)\n+                                                                                                                variants: [VariantDef { def_id: DefId(0:11 ~ thir_tree_match[3c9a]::Foo::FooOne), ctor: Some((Fn, DefId(0:12 ~ thir_tree_match[3c9a]::Foo::FooOne::{constructor#0}))), name: \"FooOne\", discr: Relative(0), fields: [FieldDef { did: DefId(0:13 ~ thir_tree_match[3c9a]::Foo::FooOne::0), name: \"0\", vis: Restricted(DefId(0:0 ~ thir_tree_match[3c9a])) }], flags: NO_VARIANT_FLAGS }, VariantDef { def_id: DefId(0:14 ~ thir_tree_match[3c9a]::Foo::FooTwo), ctor: Some((Const, DefId(0:15 ~ thir_tree_match[3c9a]::Foo::FooTwo::{constructor#0}))), name: \"FooTwo\", discr: Relative(1), fields: [], flags: NO_VARIANT_FLAGS }]\n+                                                                                                                flags: IS_ENUM\n+                                                                                                                repr: ReprOptions { int: None, align: None, pack: None, flags: (empty), field_shuffle_seed: 11573694388057581 }\n+                                                                                                        substs: []\n+                                                                                                        variant_index: 1\n+                                                                                                        subpatterns: []\n+                                                                                                    }\n+                                                                                                }\n+                                                                                            }\n+                                                                                        guard: None\n+                                                                                        body: \n+                                                                                            Expr {\n+                                                                                                ty: bool\n+                                                                                                temp_lifetime: Some(Node(24))\n+                                                                                                span: $DIR/thir-tree-match.rs:19:24: 19:28 (#0)\n+                                                                                                kind: \n+                                                                                                    Scope {\n+                                                                                                        region_scope: Destruction(24)\n+                                                                                                        lint_level: Inherited\n+                                                                                                        value:\n+                                                                                                            Expr {\n+                                                                                                                ty: bool\n+                                                                                                                temp_lifetime: Some(Node(24))\n+                                                                                                                span: $DIR/thir-tree-match.rs:19:24: 19:28 (#0)\n+                                                                                                                kind: \n+                                                                                                                    Scope {\n+                                                                                                                        region_scope: Node(24)\n+                                                                                                                        lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).24))\n+                                                                                                                        value:\n+                                                                                                                            Expr {\n+                                                                                                                                ty: bool\n+                                                                                                                                temp_lifetime: Some(Node(24))\n+                                                                                                                                span: $DIR/thir-tree-match.rs:19:24: 19:28 (#0)\n+                                                                                                                                kind: \n+                                                                                                                                    Literal( lit: Spanned { node: Bool(true), span: $DIR/thir-tree-match.rs:19:24: 19:28 (#0) }, neg: false)\n+\n+                                                                                                                            }\n+                                                                                                                    }\n+                                                                                                            }\n+                                                                                                    }\n+                                                                                            }\n+                                                                                        lint_level: Explicit(HirId(DefId(0:16 ~ thir_tree_match[3c9a]::has_match).23))\n+                                                                                        scope: Node(23)\n+                                                                                        span: $DIR/thir-tree-match.rs:19:9: 19:28 (#0)\n+                                                                                    }\n+                                                                                ]\n+                                                                            }\n+                                                                    }\n+                                                            }\n+                                                    }\n+                                            }\n+                                    }\n+                            }\n+                    }\n+            }\n+    }\n+\n+\n+DefId(0:17 ~ thir_tree_match[3c9a]::main):\n+params: [\n+]\n+body:\n+    Expr {\n+        ty: ()\n+        temp_lifetime: Some(Node(2))\n+        span: $DIR/thir-tree-match.rs:23:11: 23:13 (#0)\n+        kind: \n+            Scope {\n+                region_scope: Destruction(2)\n+                lint_level: Inherited\n+                value:\n+                    Expr {\n+                        ty: ()\n+                        temp_lifetime: Some(Node(2))\n+                        span: $DIR/thir-tree-match.rs:23:11: 23:13 (#0)\n+                        kind: \n+                            Scope {\n+                                region_scope: Node(2)\n+                                lint_level: Explicit(HirId(DefId(0:17 ~ thir_tree_match[3c9a]::main).2))\n+                                value:\n+                                    Expr {\n+                                        ty: ()\n+                                        temp_lifetime: Some(Node(2))\n+                                        span: $DIR/thir-tree-match.rs:23:11: 23:13 (#0)\n+                                        kind: \n+                                            Block {\n+                                                targeted_by_break: false\n+                                                opt_destruction_scope: None\n+                                                span: $DIR/thir-tree-match.rs:23:11: 23:13 (#0)\n+                                                region_scope: Node(1)\n+                                                safety_mode: Safe\n+                                                stmts: []\n+                                                expr: []\n+                                            }\n+                                    }\n+                            }\n+                    }\n+            }\n+    }\n+\n+"}, {"sha": "32df7905adbade83afcff774a16942cbbaff7873", "filename": "tests/ui/thir-print/thir-tree.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthir-print%2Fthir-tree.rs?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "previous_filename": "tests/ui/thir-tree.rs"}, {"sha": "0a35d9fb78ca28dd5f044e5dfd60ec7080d01cf8", "filename": "tests/ui/thir-print/thir-tree.stdout", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-tree.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/45446824e3226c9270a8eb6e3554edbca5187fd2/tests%2Fui%2Fthir-print%2Fthir-tree.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthir-print%2Fthir-tree.stdout?ref=45446824e3226c9270a8eb6e3554edbca5187fd2", "patch": "@@ -0,0 +1,43 @@\n+DefId(0:3 ~ thir_tree[8f1d]::main):\n+params: [\n+]\n+body:\n+    Expr {\n+        ty: ()\n+        temp_lifetime: Some(Node(2))\n+        span: $DIR/thir-tree.rs:4:15: 4:17 (#0)\n+        kind: \n+            Scope {\n+                region_scope: Destruction(2)\n+                lint_level: Inherited\n+                value:\n+                    Expr {\n+                        ty: ()\n+                        temp_lifetime: Some(Node(2))\n+                        span: $DIR/thir-tree.rs:4:15: 4:17 (#0)\n+                        kind: \n+                            Scope {\n+                                region_scope: Node(2)\n+                                lint_level: Explicit(HirId(DefId(0:3 ~ thir_tree[8f1d]::main).2))\n+                                value:\n+                                    Expr {\n+                                        ty: ()\n+                                        temp_lifetime: Some(Node(2))\n+                                        span: $DIR/thir-tree.rs:4:15: 4:17 (#0)\n+                                        kind: \n+                                            Block {\n+                                                targeted_by_break: false\n+                                                opt_destruction_scope: None\n+                                                span: $DIR/thir-tree.rs:4:15: 4:17 (#0)\n+                                                region_scope: Node(1)\n+                                                safety_mode: Safe\n+                                                stmts: []\n+                                                expr: []\n+                                            }\n+                                    }\n+                            }\n+                    }\n+            }\n+    }\n+\n+"}]}