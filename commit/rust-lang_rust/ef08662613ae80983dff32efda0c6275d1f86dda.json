{"sha": "ef08662613ae80983dff32efda0c6275d1f86dda", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMDg2NjI2MTNhZTgwOTgzZGZmMzJlZmRhMGM2Mjc1ZDFmODZkZGE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-02T04:18:45Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-04T18:03:27Z"}, "message": "hir::{hir,def,itemlikevisit,pat_util,print} -> rustc_hir\n\nAlso fix fallout wrt. HashStable.", "tree": {"sha": "97ec199befa56a62a5a7da732cd22e2aea264193", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97ec199befa56a62a5a7da732cd22e2aea264193"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef08662613ae80983dff32efda0c6275d1f86dda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef08662613ae80983dff32efda0c6275d1f86dda", "html_url": "https://github.com/rust-lang/rust/commit/ef08662613ae80983dff32efda0c6275d1f86dda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef08662613ae80983dff32efda0c6275d1f86dda/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f7b4e9a59ccb3e5d819900f45de81882e959c72", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7b4e9a59ccb3e5d819900f45de81882e959c72", "html_url": "https://github.com/rust-lang/rust/commit/1f7b4e9a59ccb3e5d819900f45de81882e959c72"}], "stats": {"total": 731, "additions": 420, "deletions": 311}, "files": [{"sha": "62160fed1bc6653be6f32ce038d309530f2abe2d", "filename": "src/librustc/hir.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -3,24 +3,23 @@\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n pub mod check_attr;\n-pub mod def;\n+pub use rustc_hir::def;\n pub mod exports;\n pub use rustc_hir::def_id;\n pub use rustc_hir::hir_id::*;\n pub mod intravisit;\n-pub mod itemlikevisit;\n+pub use rustc_hir::itemlikevisit;\n pub mod map;\n-pub mod pat_util;\n-pub mod print;\n+pub use rustc_hir::pat_util;\n+pub use rustc_hir::print;\n pub mod upvars;\n \n-mod hir;\n-pub use hir::BlockCheckMode::*;\n-pub use hir::FunctionRetTy::*;\n-pub use hir::PrimTy::*;\n-pub use hir::UnOp::*;\n-pub use hir::UnsafeSource::*;\n-pub use hir::*;\n+pub use rustc_hir::BlockCheckMode::*;\n+pub use rustc_hir::FunctionRetTy::*;\n+pub use rustc_hir::PrimTy::*;\n+pub use rustc_hir::UnOp::*;\n+pub use rustc_hir::UnsafeSource::*;\n+pub use rustc_hir::*;\n \n use crate::ty::query::Providers;\n "}, {"sha": "b499ba20b8cf1499f93effbe6633958088127d38", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -1266,45 +1266,6 @@ impl<'hir> print::PpAnn for Map<'hir> {\n     }\n }\n \n-impl<'a> print::State<'a> {\n-    pub fn print_node(&mut self, node: Node<'_>) {\n-        match node {\n-            Node::Param(a) => self.print_param(&a),\n-            Node::Item(a) => self.print_item(&a),\n-            Node::ForeignItem(a) => self.print_foreign_item(&a),\n-            Node::TraitItem(a) => self.print_trait_item(a),\n-            Node::ImplItem(a) => self.print_impl_item(a),\n-            Node::Variant(a) => self.print_variant(&a),\n-            Node::AnonConst(a) => self.print_anon_const(&a),\n-            Node::Expr(a) => self.print_expr(&a),\n-            Node::Stmt(a) => self.print_stmt(&a),\n-            Node::PathSegment(a) => self.print_path_segment(&a),\n-            Node::Ty(a) => self.print_type(&a),\n-            Node::TraitRef(a) => self.print_trait_ref(&a),\n-            Node::Binding(a) | Node::Pat(a) => self.print_pat(&a),\n-            Node::Arm(a) => self.print_arm(&a),\n-            Node::Block(a) => {\n-                // Containing cbox, will be closed by print-block at `}`.\n-                self.cbox(print::INDENT_UNIT);\n-                // Head-ibox, will be closed by print-block after `{`.\n-                self.ibox(0);\n-                self.print_block(&a)\n-            }\n-            Node::Lifetime(a) => self.print_lifetime(&a),\n-            Node::Visibility(a) => self.print_visibility(&a),\n-            Node::GenericParam(_) => bug!(\"cannot print Node::GenericParam\"),\n-            Node::Field(_) => bug!(\"cannot print StructField\"),\n-            // These cases do not carry enough information in the\n-            // `hir_map` to reconstruct their full structure for pretty\n-            // printing.\n-            Node::Ctor(..) => bug!(\"cannot print isolated Ctor\"),\n-            Node::Local(a) => self.print_local_decl(&a),\n-            Node::MacroDef(_) => bug!(\"cannot print MacroDef\"),\n-            Node::Crate => bug!(\"cannot print Crate\"),\n-        }\n-    }\n-}\n-\n fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n     let id_str = format!(\" (hir_id={})\", id);\n     let id_str = if include_id { &id_str[..] } else { \"\" };"}, {"sha": "86cad00af17a8d547c9f12b7187e9db248560987", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -33,10 +33,10 @@ pub struct StableHashingContext<'a> {\n     sess: &'a Session,\n     definitions: &'a Definitions,\n     cstore: &'a dyn CrateStore,\n-    body_resolver: BodyResolver<'a>,\n+    pub(super) body_resolver: BodyResolver<'a>,\n     hash_spans: bool,\n     hash_bodies: bool,\n-    node_id_hashing_mode: NodeIdHashingMode,\n+    pub(super) node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n     // `CachingSourceMapView`, so we initialize it lazily.\n@@ -54,12 +54,12 @@ pub enum NodeIdHashingMode {\n /// We could also just store a plain reference to the `hir::Crate` but we want\n /// to avoid that the crate is used to get untracked access to all of the HIR.\n #[derive(Clone, Copy)]\n-struct BodyResolver<'tcx>(&'tcx hir::Crate<'tcx>);\n+pub(super) struct BodyResolver<'tcx>(&'tcx hir::Crate<'tcx>);\n \n impl<'tcx> BodyResolver<'tcx> {\n     /// Returns a reference to the `hir::Body` with the given `BodyId`.\n     /// **Does not do any tracking**; use carefully.\n-    fn body(self, id: hir::BodyId) -> &'tcx hir::Body<'tcx> {\n+    pub(super) fn body(self, id: hir::BodyId) -> &'tcx hir::Body<'tcx> {\n         self.0.body(id)\n     }\n }\n@@ -207,31 +207,6 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n \n impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {}\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        if hcx.hash_bodies() {\n-            hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::HirId {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        match hcx.node_id_hashing_mode {\n-            NodeIdHashingMode::Ignore => {\n-                // Don't do anything.\n-            }\n-            NodeIdHashingMode::HashDefPath => {\n-                let hir::HirId { owner, local_id } = *self;\n-\n-                hcx.local_def_path_hash(owner).hash_stable(hcx, hasher);\n-                local_id.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::HirId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n "}, {"sha": "f69051fd85dd2270db17a29247ab418f15779d8d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 125, "deletions": 106, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -11,10 +11,132 @@ use smallvec::SmallVec;\n use std::mem;\n use syntax::attr;\n \n-impl<'a> HashStable<StableHashingContext<'a>> for DefId {\n+impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n     #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n+    fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n+    }\n+\n+    #[inline]\n+    fn hash_hir_id(&mut self, hir_id: hir::HirId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        match hcx.node_id_hashing_mode {\n+            NodeIdHashingMode::Ignore => {\n+                // Don't do anything.\n+            }\n+            NodeIdHashingMode::HashDefPath => {\n+                let hir::HirId { owner, local_id } = hir_id;\n+\n+                hcx.local_def_path_hash(owner).hash_stable(hcx, hasher);\n+                local_id.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+\n+    fn hash_body_id(&mut self, id: hir::BodyId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        if hcx.hash_bodies() {\n+            hcx.body_resolver.body(id).hash_stable(hcx, hasher);\n+        }\n+    }\n+\n+    // The following implementations of HashStable for `ItemId`, `TraitItemId`, and\n+    // `ImplItemId` deserve special attention. Normally we do not hash `NodeId`s within\n+    // the HIR, since they just signify a HIR nodes own path. But `ItemId` et al\n+    // are used when another item in the HIR is *referenced* and we certainly\n+    // want to pick up on a reference changing its target, so we hash the NodeIds\n+    // in \"DefPath Mode\".\n+\n+    fn hash_item_id(&mut self, id: hir::ItemId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        let hir::ItemId { id } = id;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            id.hash_stable(hcx, hasher);\n+        })\n+    }\n+\n+    fn hash_impl_item_id(&mut self, id: hir::ImplItemId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        let hir::ImplItemId { hir_id } = id;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            hir_id.hash_stable(hcx, hasher);\n+        })\n+    }\n+\n+    fn hash_trait_item_id(&mut self, id: hir::TraitItemId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        let hir::TraitItemId { hir_id } = id;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            hir_id.hash_stable(hcx, hasher);\n+        })\n+    }\n+\n+    fn hash_hir_mod(&mut self, module: &hir::Mod<'_>, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        let hir::Mod { inner: ref inner_span, ref item_ids } = *module;\n+\n+        inner_span.hash_stable(hcx, hasher);\n+\n+        // Combining the `DefPathHash`s directly is faster than feeding them\n+        // into the hasher. Because we use a commutative combine, we also don't\n+        // have to sort the array.\n+        let item_ids_hash = item_ids\n+            .iter()\n+            .map(|id| {\n+                let (def_path_hash, local_id) = id.id.to_stable_hash_key(hcx);\n+                debug_assert_eq!(local_id, hir::ItemLocalId::from_u32(0));\n+                def_path_hash.0\n+            })\n+            .fold(Fingerprint::ZERO, |a, b| a.combine_commutative(b));\n+\n+        item_ids.len().hash_stable(hcx, hasher);\n+        item_ids_hash.hash_stable(hcx, hasher);\n+    }\n+\n+    fn hash_hir_expr(&mut self, expr: &hir::Expr<'_>, hasher: &mut StableHasher) {\n+        self.while_hashing_hir_bodies(true, |hcx| {\n+            let hir::Expr { hir_id: _, ref span, ref kind, ref attrs } = *expr;\n+\n+            span.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+        })\n+    }\n+\n+    fn hash_hir_ty(&mut self, ty: &hir::Ty<'_>, hasher: &mut StableHasher) {\n+        self.while_hashing_hir_bodies(true, |hcx| {\n+            let hir::Ty { hir_id: _, ref kind, ref span } = *ty;\n+\n+            kind.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        })\n+    }\n+\n+    fn hash_hir_visibility_kind(\n+        &mut self,\n+        vis: &hir::VisibilityKind<'_>,\n+        hasher: &mut StableHasher,\n+    ) {\n+        let hcx = self;\n+        mem::discriminant(vis).hash_stable(hcx, hasher);\n+        match *vis {\n+            hir::VisibilityKind::Public | hir::VisibilityKind::Inherited => {\n+                // No fields to hash.\n+            }\n+            hir::VisibilityKind::Crate(sugar) => {\n+                sugar.hash_stable(hcx, hasher);\n+            }\n+            hir::VisibilityKind::Restricted { ref path, hir_id } => {\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                    hir_id.hash_stable(hcx, hasher);\n+                });\n+                path.hash_stable(hcx, hasher);\n+            }\n+        }\n     }\n }\n \n@@ -69,66 +191,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::ItemLocalId {\n     }\n }\n \n-// The following implementations of HashStable for `ItemId`, `TraitItemId`, and\n-// `ImplItemId` deserve special attention. Normally we do not hash `NodeId`s within\n-// the HIR, since they just signify a HIR nodes own path. But `ItemId` et al\n-// are used when another item in the HIR is *referenced* and we certainly\n-// want to pick up on a reference changing its target, so we hash the NodeIds\n-// in \"DefPath Mode\".\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemId {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let hir::ItemId { id } = *self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            id.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let hir::TraitItemId { hir_id } = *self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            hir_id.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let hir::ImplItemId { hir_id } = *self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            hir_id.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty<'_> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        hcx.while_hashing_hir_bodies(true, |hcx| {\n-            let hir::Ty { hir_id: _, ref kind, ref span } = *self;\n-\n-            kind.hash_stable(hcx, hasher);\n-            span.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr<'_> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        hcx.while_hashing_hir_bodies(true, |hcx| {\n-            let hir::Expr { hir_id: _, ref span, ref kind, ref attrs } = *self;\n-\n-            span.hash_stable(hcx, hasher);\n-            kind.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::TraitItem { hir_id: _, ident, ref attrs, ref generics, ref kind, span } = *self;\n@@ -168,49 +230,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem<'_> {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind<'_> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            hir::VisibilityKind::Public | hir::VisibilityKind::Inherited => {\n-                // No fields to hash.\n-            }\n-            hir::VisibilityKind::Crate(sugar) => {\n-                sugar.hash_stable(hcx, hasher);\n-            }\n-            hir::VisibilityKind::Restricted { ref path, hir_id } => {\n-                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    hir_id.hash_stable(hcx, hasher);\n-                });\n-                path.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod<'_> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let hir::Mod { inner: ref inner_span, ref item_ids } = *self;\n-\n-        inner_span.hash_stable(hcx, hasher);\n-\n-        // Combining the `DefPathHash`s directly is faster than feeding them\n-        // into the hasher. Because we use a commutative combine, we also don't\n-        // have to sort the array.\n-        let item_ids_hash = item_ids\n-            .iter()\n-            .map(|id| {\n-                let (def_path_hash, local_id) = id.id.to_stable_hash_key(hcx);\n-                debug_assert_eq!(local_id, hir::ItemLocalId::from_u32(0));\n-                def_path_hash.0\n-            })\n-            .fold(Fingerprint::ZERO, |a, b| a.combine_commutative(b));\n-\n-        item_ids.len().hash_stable(hcx, hasher);\n-        item_ids_hash.hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Item { ident, ref attrs, hir_id: _, ref kind, ref vis, span } = *self;"}, {"sha": "e72a5241fadb174b7f19ec4123011bf3646a3e8c", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -43,25 +43,23 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+impl<'ctx> syntax::HashStableContext for StableHashingContext<'ctx> {\n+    fn hash_attr(&mut self, attr: &ast::Attribute, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n-        debug_assert!(!self.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name)));\n-        debug_assert!(!self.is_doc_comment());\n+        debug_assert!(!attr.ident().map_or(false, |ident| self.is_ignored_attr(ident.name)));\n+        debug_assert!(!attr.is_doc_comment());\n \n-        let ast::Attribute { kind, id: _, style, span } = self;\n+        let ast::Attribute { kind, id: _, style, span } = attr;\n         if let ast::AttrKind::Normal(item) = kind {\n-            item.hash_stable(hcx, hasher);\n-            style.hash_stable(hcx, hasher);\n-            span.hash_stable(hcx, hasher);\n+            item.hash_stable(self, hasher);\n+            style.hash_stable(self, hasher);\n+            span.hash_stable(self, hasher);\n         } else {\n             unreachable!();\n         }\n     }\n }\n \n-impl<'ctx> syntax::HashStableContext for StableHashingContext<'ctx> {}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let SourceFile {"}, {"sha": "83e30d85c5a675d95e973ea3cbab273db93dadce", "filename": "src/librustc_hir/def.rs", "status": "renamed", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -1,23 +1,25 @@\n+use crate::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::hir;\n-use crate::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n-use rustc_macros::HashStable;\n+use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n use syntax::ast;\n use syntax::ast::NodeId;\n \n use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum CtorOf {\n     /// This `DefKind::Ctor` is a synthesized constructor of a tuple or unit struct.\n     Struct,\n     /// This `DefKind::Ctor` is a synthesized constructor of a tuple or unit variant.\n     Variant,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum CtorKind {\n     /// Constructor function automatically created by a tuple struct/variant.\n     Fn,\n@@ -27,7 +29,8 @@ pub enum CtorKind {\n     Fictive,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum NonMacroAttrKind {\n     /// Single-segment attribute defined by the language (`#[inline]`)\n     Builtin,\n@@ -39,7 +42,8 @@ pub enum NonMacroAttrKind {\n     Registered,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum DefKind {\n     // Type namespace\n     Mod,\n@@ -93,7 +97,7 @@ impl DefKind {\n             DefKind::Ctor(CtorOf::Struct, CtorKind::Fn) => \"tuple struct\",\n             DefKind::Ctor(CtorOf::Struct, CtorKind::Const) => \"unit struct\",\n             DefKind::Ctor(CtorOf::Struct, CtorKind::Fictive) => {\n-                bug!(\"impossible struct constructor\")\n+                panic!(\"impossible struct constructor\")\n             }\n             DefKind::OpaqueTy => \"opaque type\",\n             DefKind::TyAlias => \"type alias\",\n@@ -154,7 +158,8 @@ impl DefKind {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum Res<Id = hir::HirId> {\n     Def(DefKind, DefId),\n \n@@ -341,7 +346,8 @@ impl<Id> Res<Id> {\n     where\n         Id: Debug,\n     {\n-        self.opt_def_id().unwrap_or_else(|| bug!(\"attempted .def_id() on invalid res: {:?}\", self))\n+        self.opt_def_id()\n+            .unwrap_or_else(|| panic!(\"attempted .def_id() on invalid res: {:?}\", self))\n     }\n \n     /// Return `Some(..)` with the `DefId` of this `Res` if it has a ID, else `None`.", "previous_filename": "src/librustc/hir/def.rs"}, {"sha": "1fea05306b6d5d8136aabe7786a1b352a3ea0b85", "filename": "src/librustc_hir/hir.rs", "status": "renamed", "additions": 105, "deletions": 99, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -1,17 +1,17 @@\n-//! HIR datatypes. See the [rustc guide] for more info.\n-//!\n-//! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n+use crate::def::{DefKind, Res};\n+use crate::def_id::DefId;\n+crate use crate::hir_id::HirId;\n+use crate::itemlikevisit;\n+use crate::print;\n \n-use crate::hir::def::{DefKind, Res};\n-use crate::hir::def_id::DefId;\n-use crate::hir::itemlikevisit;\n-use crate::hir::print;\n-use rustc_hir::hir_id::HirId;\n+crate use BlockCheckMode::*;\n+crate use FunctionRetTy::*;\n+crate use UnsafeSource::*;\n \n use errors::FatalError;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n-use rustc_macros::HashStable;\n+use rustc_macros::HashStable_Generic;\n use rustc_session::node_id::NodeMap;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -27,7 +27,7 @@ pub use syntax::ast::{CaptureBy, Constness, Movability, Mutability, Unsafety};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -41,7 +41,8 @@ pub struct Lifetime {\n     pub name: LifetimeName,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, HashStable)]\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(HashStable_Generic)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n@@ -86,7 +87,8 @@ impl ParamName {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, HashStable)]\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(ParamName),\n@@ -187,7 +189,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct Path<'hir> {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -216,7 +218,7 @@ impl fmt::Display for Path<'_> {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct PathSegment<'hir> {\n     /// The identifier portion of this path segment.\n     #[stable_hasher(project(name))]\n@@ -259,13 +261,13 @@ impl<'hir> PathSegment<'hir> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum GenericArg<'hir> {\n     Lifetime(Lifetime),\n     Type(Ty<'hir>),\n@@ -297,7 +299,7 @@ impl GenericArg<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct GenericArgs<'hir> {\n     /// The generic arguments for this path segment.\n     pub args: &'hir [GenericArg<'hir>],\n@@ -334,7 +336,7 @@ impl GenericArgs<'_> {\n                 }\n             }\n         }\n-        bug!(\"GenericArgs::inputs: not a `Fn(T) -> U`\");\n+        panic!(\"GenericArgs::inputs: not a `Fn(T) -> U`\");\n     }\n \n     pub fn own_counts(&self) -> GenericParamCount {\n@@ -357,7 +359,8 @@ impl GenericArgs<'_> {\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n@@ -367,7 +370,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -384,7 +387,7 @@ impl GenericBound<'_> {\n \n pub type GenericBounds<'hir> = &'hir [GenericBound<'hir>];\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum LifetimeParamKind {\n     // Indicates that the lifetime definition was explicitly declared (e.g., in\n     // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n@@ -403,7 +406,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum GenericParamKind<'hir> {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -418,7 +421,7 @@ pub enum GenericParamKind<'hir> {\n     },\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n@@ -438,7 +441,7 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n     pub where_clause: WhereClause<'hir>,\n@@ -491,13 +494,14 @@ impl Generics<'hir> {\n \n /// Synthetic type parameters are converted to another form during lowering; this allows\n /// us to track the original form they had, and is useful for error messages.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum SyntheticTyParamKind {\n     ImplTrait,\n }\n \n /// A where-clause in a definition.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct WhereClause<'hir> {\n     pub predicates: &'hir [WherePredicate<'hir>],\n     // Only valid if predicates isn't empty.\n@@ -517,7 +521,7 @@ impl WhereClause<'_> {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum WherePredicate<'hir> {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate<'hir>),\n@@ -538,7 +542,7 @@ impl WherePredicate<'_> {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct WhereBoundPredicate<'hir> {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -550,15 +554,15 @@ pub struct WhereBoundPredicate<'hir> {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds<'hir>,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct WhereEqPredicate<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -663,7 +667,7 @@ impl Crate<'_> {\n     where\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n-        parallel!(\n+        rustc_data_structures::parallel!(\n             {\n                 par_for_each_in(&self.items, |(_, item)| {\n                     visitor.visit_item(item);\n@@ -686,7 +690,7 @@ impl Crate<'_> {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct MacroDef<'hir> {\n     pub name: Name,\n     pub vis: Visibility<'hir>,\n@@ -700,7 +704,7 @@ pub struct MacroDef<'hir> {\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Block<'hir> {\n     /// Statements in a block.\n     pub stmts: &'hir [Stmt<'hir>],\n@@ -718,7 +722,7 @@ pub struct Block<'hir> {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -807,7 +811,7 @@ impl Pat<'_> {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct FieldPat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -823,7 +827,7 @@ pub struct FieldPat<'hir> {\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum BindingAnnotation {\n     /// No binding annotation given: this means that the final binding mode\n     /// will depend on whether we have skipped through a `&` reference\n@@ -844,7 +848,7 @@ pub enum BindingAnnotation {\n     RefMut,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n@@ -859,7 +863,7 @@ impl fmt::Display for RangeEnd {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum PatKind<'hir> {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n@@ -915,7 +919,7 @@ pub enum PatKind<'hir> {\n     Slice(&'hir [&'hir Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [&'hir Pat<'hir>]),\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1049,7 +1053,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1078,7 +1082,7 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n     pub kind: StmtKind<'hir>,\n@@ -1097,7 +1101,7 @@ impl fmt::Debug for Stmt<'_> {\n }\n \n /// The contents of a statement.\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n     Local(&'hir Local<'hir>),\n@@ -1123,7 +1127,7 @@ impl StmtKind<'hir> {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Local<'hir> {\n     pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n@@ -1140,7 +1144,7 @@ pub struct Local<'hir> {\n \n /// Represents a single arm of a `match` expression, e.g.\n /// `<pat> (if <guard>) => <body>`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1154,12 +1158,12 @@ pub struct Arm<'hir> {\n     pub body: &'hir Expr<'hir>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum Guard<'hir> {\n     If(&'hir Expr<'hir>),\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Field<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1169,15 +1173,15 @@ pub struct Field<'hir> {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1227,7 +1231,7 @@ impl Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable_Generic, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n     Async(AsyncGeneratorKind),\n@@ -1250,7 +1254,7 @@ impl fmt::Display for GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable_Generic, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,\n@@ -1304,7 +1308,7 @@ pub type Lit = Spanned<LitKind>;\n /// These are usually found nested inside types (e.g., array lengths)\n /// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct AnonConst {\n     pub hir_id: HirId,\n     pub body: BodyId,\n@@ -1321,7 +1325,7 @@ pub struct Expr<'hir> {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Expr<'static>, 64);\n+rustc_data_structures::static_assert_size!(Expr<'static>, 64);\n \n impl Expr<'_> {\n     pub fn precedence(&self) -> ExprPrecedence {\n@@ -1505,7 +1509,7 @@ pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n     false\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum ExprKind<'hir> {\n     /// A `box x` expression.\n     Box(&'hir Expr<'hir>),\n@@ -1618,7 +1622,7 @@ pub enum ExprKind<'hir> {\n /// To resolve the path to a `DefId`, call [`qpath_res`].\n ///\n /// [`qpath_res`]: ../ty/struct.TypeckTables.html#method.qpath_res\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum QPath<'hir> {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -1638,7 +1642,7 @@ pub enum QPath<'hir> {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1660,7 +1664,8 @@ pub enum LocalSource {\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1696,7 +1701,7 @@ impl MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -1718,7 +1723,7 @@ impl LoopSource {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -1737,7 +1742,7 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub label: Option<Label>,\n@@ -1748,7 +1753,7 @@ pub struct Destination {\n }\n \n /// The yield kind that caused an `ExprKind::Yield`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n     Await,\n@@ -1777,15 +1782,15 @@ impl From<GeneratorKind> for YieldSource {\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct MutTy<'hir> {\n     pub ty: &'hir Ty<'hir>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or a free function.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct FnSig<'hir> {\n     pub header: FnHeader,\n     pub decl: &'hir FnDecl<'hir>,\n@@ -1814,7 +1819,7 @@ pub struct TraitItem<'hir> {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TraitMethod<'hir> {\n     /// No default body in the trait, just a signature.\n     Required(&'hir [Ident]),\n@@ -1824,7 +1829,7 @@ pub enum TraitMethod<'hir> {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(&'hir Ty<'hir>, Option<BodyId>),\n@@ -1857,7 +1862,7 @@ pub struct ImplItem<'hir> {\n }\n \n /// Represents various kinds of content within an `impl`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n@@ -1885,7 +1890,7 @@ pub enum ImplItemKind<'hir> {\n ///    Binding(...),\n /// }\n /// ```\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct TypeBinding<'hir> {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n@@ -1895,7 +1900,7 @@ pub struct TypeBinding<'hir> {\n }\n \n // Represents the two kinds of type bindings.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TypeBindingKind<'hir> {\n     /// E.g., `Foo<Bar: Send>`.\n     Constraint { bounds: &'hir [GenericBound<'hir>] },\n@@ -1907,7 +1912,7 @@ impl TypeBinding<'_> {\n     pub fn ty(&self) -> &Ty<'_> {\n         match self.kind {\n             TypeBindingKind::Equality { ref ty } => ty,\n-            _ => bug!(\"expected equality type binding for parenthesized generic args\"),\n+            _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n         }\n     }\n }\n@@ -1926,7 +1931,8 @@ impl fmt::Debug for Ty<'_> {\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n pub enum PrimTy {\n     Int(IntTy),\n     Uint(UintTy),\n@@ -1936,7 +1942,7 @@ pub enum PrimTy {\n     Char,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -1945,7 +1951,7 @@ pub struct BareFnTy<'hir> {\n     pub param_names: &'hir [Ident],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct OpaqueTy<'hir> {\n     pub generics: Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n@@ -1954,7 +1960,7 @@ pub struct OpaqueTy<'hir> {\n }\n \n /// From whence the opaque type came.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n     /// `type Foo = impl Trait;`\n     TypeAlias,\n@@ -1965,7 +1971,7 @@ pub enum OpaqueTyOrigin {\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TyKind<'hir> {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(&'hir Ty<'hir>),\n@@ -2004,7 +2010,7 @@ pub enum TyKind<'hir> {\n     Err,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable, PartialEq)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n@@ -2014,7 +2020,7 @@ pub struct InlineAsmOutput {\n \n // NOTE(eddyb) This is used within MIR as well, so unlike the rest of the HIR,\n // it needs to be `Clone` and use plain `Vec<T>` instead of arena-allocated slice.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]\n pub struct InlineAsmInner {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -2026,15 +2032,15 @@ pub struct InlineAsmInner {\n     pub dialect: AsmDialect,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct InlineAsm<'hir> {\n     pub inner: InlineAsmInner,\n     pub outputs_exprs: &'hir [Expr<'hir>],\n     pub inputs_exprs: &'hir [Expr<'hir>],\n }\n \n /// Represents a parameter in a function header.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Param<'hir> {\n     pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n@@ -2043,7 +2049,7 @@ pub struct Param<'hir> {\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct FnDecl<'hir> {\n     /// The types of the function's parameters.\n     ///\n@@ -2056,7 +2062,7 @@ pub struct FnDecl<'hir> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -2087,7 +2093,7 @@ impl ImplicitSelfKind {\n     PartialEq,\n     Eq,\n     PartialOrd,\n-    HashStable,\n+    HashStable_Generic,\n     Ord,\n     RustcEncodable,\n     RustcDecodable,\n@@ -2098,7 +2104,7 @@ pub enum IsAsync {\n     NotAsync,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -2124,7 +2130,7 @@ impl Defaultness {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum FunctionRetTy<'hir> {\n     /// Return type is not specified.\n     ///\n@@ -2163,23 +2169,23 @@ pub struct Mod<'hir> {\n     pub item_ids: &'hir [ItemId],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct ForeignMod<'hir> {\n     pub abi: Abi,\n     pub items: &'hir [ForeignItem<'hir>],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct EnumDef<'hir> {\n     pub variants: &'hir [Variant<'hir>],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Variant<'hir> {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n@@ -2196,7 +2202,7 @@ pub struct Variant<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -2218,7 +2224,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct TraitRef<'hir> {\n     pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n@@ -2240,7 +2246,7 @@ impl TraitRef<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n@@ -2286,7 +2292,7 @@ impl VisibilityKind<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct StructField<'hir> {\n     pub span: Span,\n     #[stable_hasher(project(name))]\n@@ -2306,7 +2312,7 @@ impl StructField<'_> {\n }\n \n /// Fields and constructor IDs of enum variants and structs.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum VariantData<'hir> {\n     /// A struct variant.\n     ///\n@@ -2361,7 +2367,7 @@ pub struct Item<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n@@ -2378,7 +2384,7 @@ impl FnHeader {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum ItemKind<'hir> {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2474,7 +2480,7 @@ impl ItemKind<'_> {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     #[stable_hasher(project(name))]\n@@ -2490,7 +2496,7 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct ImplItemRef<'hir> {\n     pub id: ImplItemId,\n     #[stable_hasher(project(name))]\n@@ -2501,15 +2507,15 @@ pub struct ImplItemRef<'hir> {\n     pub defaultness: Defaultness,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum AssocItemKind {\n     Const,\n     Method { has_self: bool },\n     Type,\n     OpaqueTy,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct ForeignItem<'hir> {\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -2521,7 +2527,7 @@ pub struct ForeignItem<'hir> {\n }\n \n /// An item within an `extern` block.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n     Fn(&'hir FnDecl<'hir>, &'hir [Ident], Generics<'hir>),\n@@ -2542,7 +2548,7 @@ impl ForeignItemKind<'hir> {\n }\n \n /// A variable captured by a closure.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct Upvar {\n     // First span where it is accessed (there can be multiple).\n     pub span: Span,", "previous_filename": "src/librustc/hir/hir.rs"}, {"sha": "369cd49621b2dcb63687584d3f480c57b58d26a5", "filename": "src/librustc_hir/itemlikevisit.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fitemlikevisit.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "previous_filename": "src/librustc/hir/itemlikevisit.rs"}, {"sha": "4bd1934fac4933ae9686feaf777f25f17d2ca212", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -1,5 +1,20 @@\n+//! HIR datatypes. See the [rustc guide] for more info.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n+\n+#![feature(crate_visibility_modifier)]\n+#![feature(const_fn)]\n+#![feature(in_band_lifetimes)]\n #![feature(specialization)]\n \n+pub mod def;\n pub mod def_id;\n+mod hir;\n pub mod hir_id;\n+pub mod itemlikevisit;\n+pub mod pat_util;\n+pub mod print;\n+mod stable_hash_impls;\n+pub use hir::*;\n pub use hir_id::*;\n+pub use stable_hash_impls::HashStableContext;"}, {"sha": "6bca45b4f8397d6ea8d8b8ddd1f6f16dae3bc43f", "filename": "src/librustc_hir/pat_util.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fpat_util.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -1,5 +1,5 @@\n-use crate::hir::def::{CtorOf, DefKind, Res};\n-use crate::hir::def_id::DefId;\n+use crate::def::{CtorOf, DefKind, Res};\n+use crate::def_id::DefId;\n use crate::hir::{self, HirId, PatKind};\n use rustc_span::Span;\n use syntax::ast;", "previous_filename": "src/librustc/hir/pat_util.rs"}, {"sha": "571bab2cb83f288869707bbfc7c80cfc2c3b156a", "filename": "src/librustc_hir/print.rs", "status": "renamed", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -10,7 +10,7 @@ use syntax::sess::ParseSess;\n use syntax::util::parser::{self, AssocOp, Fixity};\n \n use crate::hir;\n-use crate::hir::{GenericArg, GenericParam, GenericParamKind};\n+use crate::hir::{GenericArg, GenericParam, GenericParamKind, Node};\n use crate::hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n \n use std::borrow::Cow;\n@@ -69,6 +69,45 @@ pub struct State<'a> {\n     ann: &'a (dyn PpAnn + 'a),\n }\n \n+impl<'a> State<'a> {\n+    pub fn print_node(&mut self, node: Node<'_>) {\n+        match node {\n+            Node::Param(a) => self.print_param(&a),\n+            Node::Item(a) => self.print_item(&a),\n+            Node::ForeignItem(a) => self.print_foreign_item(&a),\n+            Node::TraitItem(a) => self.print_trait_item(a),\n+            Node::ImplItem(a) => self.print_impl_item(a),\n+            Node::Variant(a) => self.print_variant(&a),\n+            Node::AnonConst(a) => self.print_anon_const(&a),\n+            Node::Expr(a) => self.print_expr(&a),\n+            Node::Stmt(a) => self.print_stmt(&a),\n+            Node::PathSegment(a) => self.print_path_segment(&a),\n+            Node::Ty(a) => self.print_type(&a),\n+            Node::TraitRef(a) => self.print_trait_ref(&a),\n+            Node::Binding(a) | Node::Pat(a) => self.print_pat(&a),\n+            Node::Arm(a) => self.print_arm(&a),\n+            Node::Block(a) => {\n+                // Containing cbox, will be closed by print-block at `}`.\n+                self.cbox(INDENT_UNIT);\n+                // Head-ibox, will be closed by print-block after `{`.\n+                self.ibox(0);\n+                self.print_block(&a)\n+            }\n+            Node::Lifetime(a) => self.print_lifetime(&a),\n+            Node::Visibility(a) => self.print_visibility(&a),\n+            Node::GenericParam(_) => panic!(\"cannot print Node::GenericParam\"),\n+            Node::Field(_) => panic!(\"cannot print StructField\"),\n+            // These cases do not carry enough information in the\n+            // `hir_map` to reconstruct their full structure for pretty\n+            // printing.\n+            Node::Ctor(..) => panic!(\"cannot print isolated Ctor\"),\n+            Node::Local(a) => self.print_local_decl(&a),\n+            Node::MacroDef(_) => panic!(\"cannot print MacroDef\"),\n+            Node::Crate => panic!(\"cannot print Crate\"),\n+        }\n+    }\n+}\n+\n impl std::ops::Deref for State<'_> {\n     type Target = pp::Printer;\n     fn deref(&self) -> &Self::Target {\n@@ -92,8 +131,8 @@ impl<'a> PrintState<'a> for State<'a> {\n         self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n \n-    fn print_generic_args(&mut self, args: &ast::GenericArgs, _colons_before_params: bool) {\n-        span_bug!(args.span(), \"AST generic args printed by HIR pretty-printer\");\n+    fn print_generic_args(&mut self, _: &ast::GenericArgs, _colons_before_params: bool) {\n+        panic!(\"AST generic args printed by HIR pretty-printer\");\n     }\n }\n \n@@ -1960,7 +1999,7 @@ impl<'a> State<'a> {\n                             self.print_lifetime(lt);\n                             sep = \"+\";\n                         }\n-                        _ => bug!(),\n+                        _ => panic!(),\n                     }\n                 }\n             }\n@@ -2023,7 +2062,7 @@ impl<'a> State<'a> {\n                             GenericBound::Outlives(lt) => {\n                                 self.print_lifetime(lt);\n                             }\n-                            _ => bug!(),\n+                            _ => panic!(),\n                         }\n \n                         if i != 0 {", "previous_filename": "src/librustc/hir/print.rs"}, {"sha": "696a350ebdd15e7d97ba5ed1fe37850c9a51d307", "filename": "src/librustc_hir/stable_hash_impls.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fstable_hash_impls.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -0,0 +1,81 @@\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+\n+use crate::def_id::DefId;\n+use crate::hir::{BodyId, Expr, ImplItemId, ItemId, Mod, TraitItemId, Ty, VisibilityKind};\n+use crate::hir_id::HirId;\n+\n+/// Requirements for a `StableHashingContext` to be used in this crate.\n+/// This is a hack to allow using the `HashStable_Generic` derive macro\n+/// instead of implementing everything in librustc.\n+pub trait HashStableContext: syntax::HashStableContext + rustc_target::HashStableContext {\n+    fn hash_def_id(&mut self, _: DefId, hasher: &mut StableHasher);\n+    fn hash_hir_id(&mut self, _: HirId, hasher: &mut StableHasher);\n+    fn hash_body_id(&mut self, _: BodyId, hasher: &mut StableHasher);\n+    fn hash_item_id(&mut self, _: ItemId, hasher: &mut StableHasher);\n+    fn hash_impl_item_id(&mut self, _: ImplItemId, hasher: &mut StableHasher);\n+    fn hash_trait_item_id(&mut self, _: TraitItemId, hasher: &mut StableHasher);\n+    fn hash_hir_mod(&mut self, _: &Mod<'_>, hasher: &mut StableHasher);\n+    fn hash_hir_expr(&mut self, _: &Expr<'_>, hasher: &mut StableHasher);\n+    fn hash_hir_ty(&mut self, _: &Ty<'_>, hasher: &mut StableHasher);\n+    fn hash_hir_visibility_kind(&mut self, _: &VisibilityKind<'_>, hasher: &mut StableHasher);\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for HirId {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_hir_id(*self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for DefId {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_def_id(*self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for BodyId {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_body_id(*self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ItemId {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_item_id(*self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItemId {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_impl_item_id(*self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItemId {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_trait_item_id(*self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Mod<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_hir_mod(self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Expr<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_hir_expr(self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Ty<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_hir_ty(self, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for VisibilityKind<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_hir_visibility_kind(self, hasher)\n+    }\n+}"}, {"sha": "72beddf7bb516202e8dbf3153c0a68fec20a1300", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef08662613ae80983dff32efda0c6275d1f86dda/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ef08662613ae80983dff32efda0c6275d1f86dda", "patch": "@@ -102,7 +102,17 @@ pub mod print {\n \n pub mod early_buffered_lints;\n \n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+\n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n /// instead of implementing everything in librustc.\n-pub trait HashStableContext: rustc_span::HashStableContext {}\n+pub trait HashStableContext: rustc_span::HashStableContext {\n+    fn hash_attr(&mut self, _: &ast::Attribute, hasher: &mut StableHasher);\n+}\n+\n+impl<AstCtx: crate::HashStableContext> HashStable<AstCtx> for ast::Attribute {\n+    fn hash_stable(&self, hcx: &mut AstCtx, hasher: &mut StableHasher) {\n+        hcx.hash_attr(self, hasher)\n+    }\n+}"}]}