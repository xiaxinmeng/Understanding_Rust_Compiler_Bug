{"sha": "790d9c47081c9ddffaad096239e0dfee2f2d10a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MGQ5YzQ3MDgxYzlkZGZmYWFkMDk2MjM5ZTBkZmVlMmYyZDEwYTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-07-22T11:15:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-08-28T18:37:35Z"}, "message": "Refactor and cleanup inference code: s/get_ref()/fields/, use try! macro rather than if_ok!", "tree": {"sha": "7a3247f96cd7ece18e34d9d42e573b5ccfe9457d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a3247f96cd7ece18e34d9d42e573b5ccfe9457d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/790d9c47081c9ddffaad096239e0dfee2f2d10a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/790d9c47081c9ddffaad096239e0dfee2f2d10a6", "html_url": "https://github.com/rust-lang/rust/commit/790d9c47081c9ddffaad096239e0dfee2f2d10a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/790d9c47081c9ddffaad096239e0dfee2f2d10a6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae314512e381f5a7ae5a798fd613125720214829", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae314512e381f5a7ae5a798fd613125720214829", "html_url": "https://github.com/rust-lang/rust/commit/ae314512e381f5a7ae5a798fd613125720214829"}], "stats": {"total": 274, "additions": 143, "deletions": 131}, "files": [{"sha": "6f2dd6e099235ebe290814c5c8c9aabc737d4b19", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=790d9c47081c9ddffaad096239e0dfee2f2d10a6", "patch": "@@ -30,7 +30,6 @@ use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::subst;\n use middle::ty;\n use middle::typeck;\n-use middle::typeck::MethodCall;\n use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable,TypeFolder};\n use middle;"}, {"sha": "9013b468d3f89742e8bc0485b151aad91ab0af01", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=790d9c47081c9ddffaad096239e0dfee2f2d10a6", "patch": "@@ -247,7 +247,7 @@ impl<'f> Coerce<'f> {\n         let a_borrowed = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                      r_borrow,\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n-        if_ok!(sub.tys(a_borrowed, b));\n+        try!(sub.tys(a_borrowed, b));\n \n         Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n@@ -273,7 +273,7 @@ impl<'f> Coerce<'f> {\n                 let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n                 let unsized_ty = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n                                               mt {ty: t_a, mutbl: mutbl_b});\n-                if_ok!(self.get_ref().infcx.try(|| sub.tys(unsized_ty, b)));\n+                try!(self.get_ref().infcx.try(|| sub.tys(unsized_ty, b)));\n                 Ok(Some(AutoDerefRef(AutoDerefRef {\n                     autoderefs: 0,\n                     autoref: Some(ty::AutoPtr(r_borrow,\n@@ -316,7 +316,7 @@ impl<'f> Coerce<'f> {\n                             let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                                  r_borrow,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            if_ok!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AutoDerefRef(AutoDerefRef {\n@@ -334,7 +334,7 @@ impl<'f> Coerce<'f> {\n                     match self.unsize_ty(sty_a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n-                            if_ok!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({:?}))\", kind);\n                             Ok(Some(AutoDerefRef(AutoDerefRef {\n@@ -458,7 +458,7 @@ impl<'f> Coerce<'f> {\n             }\n         };\n \n-        if_ok!(self.subtype(a_borrowed, b));\n+        try!(self.subtype(a_borrowed, b));\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(AutoPtr(r_a, b_mutbl, None))\n@@ -512,7 +512,7 @@ impl<'f> Coerce<'f> {\n                                                 sig: fn_ty_a.sig.clone(),\n                                                 .. *fn_ty_b\n                                            });\n-            if_ok!(self.subtype(a_closure, b));\n+            try!(self.subtype(a_closure, b));\n             Ok(Some(adj))\n         })\n     }\n@@ -536,7 +536,7 @@ impl<'f> Coerce<'f> {\n \n         // check that the types which they point at are compatible\n         let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, mt_a);\n-        if_ok!(self.subtype(a_unsafe, b));\n+        try!(self.subtype(a_unsafe, b));\n \n         // although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that"}, {"sha": "c6506b145214f66c065662d8978ba319a738d31c", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=790d9c47081c9ddffaad096239e0dfee2f2d10a6", "patch": "@@ -121,7 +121,7 @@ pub trait Combine {\n         for &space in subst::ParamSpace::all().iter() {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n-            let tps = if_ok!(self.tps(space, a_tps, b_tps));\n+            let tps = try!(self.tps(space, a_tps, b_tps));\n \n             let a_regions = a_subst.regions().get_slice(space);\n             let b_regions = b_subst.regions().get_slice(space);\n@@ -137,11 +137,11 @@ pub trait Combine {\n                 }\n             };\n \n-            let regions = if_ok!(relate_region_params(self,\n-                                                      item_def_id,\n-                                                      r_variances,\n-                                                      a_regions,\n-                                                      b_regions));\n+            let regions = try!(relate_region_params(self,\n+                                                    item_def_id,\n+                                                    r_variances,\n+                                                    a_regions,\n+                                                    b_regions));\n \n             substs.types.replace(space, tps);\n             substs.mut_regions().replace(space, regions);\n@@ -185,17 +185,17 @@ pub trait Combine {\n                     ty::Contravariant => this.contraregions(a_r, b_r),\n                     ty::Bivariant => Ok(a_r),\n                 };\n-                rs.push(if_ok!(r));\n+                rs.push(try!(r));\n             }\n             Ok(rs)\n         }\n     }\n \n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n-        let abi = if_ok!(self.abi(a.abi, b.abi));\n-        let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n+        let fn_style = try!(self.fn_styles(a.fn_style, b.fn_style));\n+        let abi = try!(self.abi(a.abi, b.abi));\n+        let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n         Ok(ty::BareFnTy {fn_style: fn_style,\n                 abi: abi,\n                 sig: sig})\n@@ -207,7 +207,7 @@ pub trait Combine {\n         let store = match (a.store, b.store) {\n             (ty::RegionTraitStore(a_r, a_m),\n              ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n-                let r = if_ok!(self.contraregions(a_r, b_r));\n+                let r = try!(self.contraregions(a_r, b_r));\n                 ty::RegionTraitStore(r, a_m)\n             }\n \n@@ -219,11 +219,11 @@ pub trait Combine {\n                 return Err(ty::terr_sigil_mismatch(expected_found(self, a.store, b.store)))\n             }\n         };\n-        let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n-        let onceness = if_ok!(self.oncenesses(a.onceness, b.onceness));\n-        let bounds = if_ok!(self.existential_bounds(a.bounds, b.bounds));\n-        let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n-        let abi = if_ok!(self.abi(a.abi, b.abi));\n+        let fn_style = try!(self.fn_styles(a.fn_style, b.fn_style));\n+        let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n+        let bounds = try!(self.existential_bounds(a.bounds, b.bounds));\n+        let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n+        let abi = try!(self.abi(a.abi, b.abi));\n         Ok(ty::ClosureTy {\n             fn_style: fn_style,\n             onceness: onceness,\n@@ -311,7 +311,7 @@ pub trait Combine {\n             Err(ty::terr_traits(\n                                 expected_found(self, a.def_id, b.def_id)))\n         } else {\n-            let substs = if_ok!(self.substs(a.def_id, &a.substs, &b.substs));\n+            let substs = try!(self.substs(a.def_id, &a.substs, &b.substs));\n             Ok(ty::TraitRef { def_id: a.def_id,\n                               substs: substs })\n         }\n@@ -377,10 +377,10 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n         return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n     }\n \n-    let inputs = if_ok!(argvecs(this,\n+    let inputs = try!(argvecs(this,\n                                 a.inputs.as_slice(),\n                                 b.inputs.as_slice()));\n-    let output = if_ok!(this.tys(a.output, b.output));\n+    let output = try!(this.tys(a.output, b.output));\n     Ok(FnSig {binder_id: a.binder_id,\n               inputs: inputs,\n               output: output,\n@@ -430,7 +430,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n         // Relate integral variables to other types\n         (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n-            if_ok!(this.infcx().simple_vars(this.a_is_expected(),\n+            try!(this.infcx().simple_vars(this.a_is_expected(),\n                                             a_id, b_id));\n             Ok(a)\n         }\n@@ -453,7 +453,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n         // Relate floating-point variables to other types\n         (&ty::ty_infer(FloatVar(a_id)), &ty::ty_infer(FloatVar(b_id))) => {\n-            if_ok!(this.infcx().simple_vars(this.a_is_expected(),\n+            try!(this.infcx().simple_vars(this.a_is_expected(),\n                                             a_id, b_id));\n             Ok(a)\n         }\n@@ -485,7 +485,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       (&ty::ty_enum(a_id, ref a_substs),\n        &ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n-          let substs = if_ok!(this.substs(a_id,\n+          let substs = try!(this.substs(a_id,\n                                           a_substs,\n                                           b_substs));\n           Ok(ty::mk_enum(tcx, a_id, substs))\n@@ -495,8 +495,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n        &ty::ty_trait(ref b_))\n       if a_.def_id == b_.def_id => {\n           debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n-          let substs = if_ok!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n-          let bounds = if_ok!(this.existential_bounds(a_.bounds, b_.bounds));\n+          let substs = try!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n+          let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx,\n                           a_.def_id,\n                           substs.clone(),\n@@ -505,7 +505,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n       (&ty::ty_struct(a_id, ref a_substs), &ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n-            let substs = if_ok!(this.substs(a_id, a_substs, b_substs));\n+            let substs = try!(this.substs(a_id, a_substs, b_substs));\n             Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n@@ -521,27 +521,27 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-            let typ = if_ok!(this.tys(a_inner, b_inner));\n+            let typ = try!(this.tys(a_inner, b_inner));\n             check_ptr_to_unsized(this, a, b, a_inner, b_inner, ty::mk_uniq(tcx, typ))\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-            let mt = if_ok!(this.mts(a_mt, b_mt));\n+            let mt = try!(this.mts(a_mt, b_mt));\n             check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_ptr(tcx, mt))\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = if_ok!(this.contraregions(a_r, b_r));\n+            let r = try!(this.contraregions(a_r, b_r));\n             // FIXME(14985)  If we have mutable references to trait objects, we\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n             // path which would require invariance.\n             let mt = match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n                 (&ty::ty_trait(..), &ty::ty_trait(..)) if a_mt.mutbl == b_mt.mutbl => {\n-                    let ty = if_ok!(this.tys(a_mt.ty, b_mt.ty));\n+                    let ty = try!(this.tys(a_mt.ty, b_mt.ty));\n                     ty::mt { ty: ty, mutbl: a_mt.mutbl }\n                 }\n-                _ => if_ok!(this.mts(a_mt, b_mt))\n+                _ => try!(this.mts(a_mt, b_mt))\n             };\n             check_ptr_to_unsized(this, a, b, a_mt.ty, b_mt.ty, ty::mk_rptr(tcx, r, mt))\n       }\n@@ -592,7 +592,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         vid: ty::IntVid,\n         val: ty::IntVarValue) -> cres<ty::t>\n     {\n-        if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n+        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n             IntType(v) => Ok(ty::mk_mach_int(v)),\n             UintType(v) => Ok(ty::mk_mach_uint(v))\n@@ -605,7 +605,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         vid: ty::FloatVid,\n         val: ast::FloatTy) -> cres<ty::t>\n     {\n-        if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n+        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(val))\n     }\n }"}, {"sha": "0b89e7274e7277e28bf4d1668a882242dd646eb6", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=790d9c47081c9ddffaad096239e0dfee2f2d10a6", "patch": "@@ -29,24 +29,28 @@ use util::common::{indenter};\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n-pub struct Glb<'f>(pub CombineFields<'f>);  // \"greatest lower bound\" (common subtype)\n+/// \"Greatest lower bound\" (common subtype)\n+pub struct Glb<'f> {\n+    pub fields: CombineFields<'f>\n+}\n \n-impl<'f> Glb<'f> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Glb(ref v) = *self; v }\n+#[allow(non_snake_case_functions)]\n+pub fn Glb<'f>(cf: CombineFields<'f>) -> Glb<'f> {\n+    Glb { fields: cf }\n }\n \n impl<'f> Combine for Glb<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n     fn tag(&self) -> String { \"glb\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.fields.infcx.tcx;\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n@@ -108,10 +112,10 @@ impl<'f> Combine for Glb<'f> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n \n-        Ok(self.get_ref().infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n+        Ok(self.fields.infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n@@ -128,33 +132,33 @@ impl<'f> Combine for Glb<'f> {\n         // please see the large comment in `region_inference.rs`.\n \n         debug!(\"{}.fn_sigs({:?}, {:?})\",\n-               self.tag(), a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n+               self.tag(), a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         let _indenter = indenter();\n \n         // Make a mark so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.get_ref().infcx.region_vars.mark();\n+        let mark = self.fields.infcx.region_vars.mark();\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), a);\n         let a_vars = var_ids(self, &a_map);\n         let (b_with_fresh, b_map) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), b);\n         let b_vars = var_ids(self, &b_map);\n \n         // Collect constraints.\n-        let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.repr(self.get_ref().infcx.tcx));\n+        let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"sig0 = {}\", sig0.repr(self.fields.infcx.tcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n+            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n         let sig1 =\n             fold_regions_in_sig(\n-                self.get_ref().infcx.tcx,\n+                self.fields.infcx.tcx,\n                 &sig0,\n                 |r| {\n                 generalize_region(self,\n@@ -166,7 +170,7 @@ impl<'f> Combine for Glb<'f> {\n                                   b_vars.as_slice(),\n                                   r)\n             });\n-        debug!(\"sig1 = {}\", sig1.repr(self.get_ref().infcx.tcx));\n+        debug!(\"sig1 = {}\", sig1.repr(self.fields.infcx.tcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,\n@@ -182,7 +186,7 @@ impl<'f> Combine for Glb<'f> {\n                 return r0;\n             }\n \n-            let tainted = this.get_ref().infcx.region_vars.tainted(mark, r0);\n+            let tainted = this.fields.infcx.region_vars.tainted(mark, r0);\n \n             let mut a_r = None;\n             let mut b_r = None;\n@@ -249,14 +253,14 @@ impl<'f> Combine for Glb<'f> {\n                     return ty::ReLateBound(new_binder_id, *a_br);\n                 }\n             }\n-            this.get_ref().infcx.tcx.sess.span_bug(\n-                this.get_ref().trace.origin.span(),\n+            this.fields.infcx.tcx.sess.span_bug(\n+                this.fields.trace.origin.span(),\n                 format!(\"could not find original bound region for {:?}\",\n                         r).as_slice())\n         }\n \n         fn fresh_bound_variable(this: &Glb, binder_id: NodeId) -> ty::Region {\n-            this.get_ref().infcx.region_vars.new_bound(binder_id)\n+            this.fields.infcx.region_vars.new_bound(binder_id)\n         }\n     }\n }"}, {"sha": "8a40021ea96760c66b7bfad86f61b8bef4dfb906", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=790d9c47081c9ddffaad096239e0dfee2f2d10a6", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n /*!\n- *\n  * # Lattice Variables\n  *\n  * This file contains generic code for operating on inference variables\n@@ -343,7 +342,7 @@ pub trait TyLatticeDir {\n }\n \n impl<'f> LatticeDir for Lub<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.get_ref().clone() }\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.fields.clone() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.ub.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..(*b).clone() }\n@@ -357,7 +356,7 @@ impl<'f> TyLatticeDir for Lub<'f> {\n }\n \n impl<'f> LatticeDir for Glb<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.get_ref().clone() }\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.fields.clone() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.lb.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..(*b).clone() }"}, {"sha": "650987612accf0f1367dcf142ba54a60fe873a85", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=790d9c47081c9ddffaad096239e0dfee2f2d10a6", "patch": "@@ -28,24 +28,28 @@ use syntax::ast::{MutMutable, MutImmutable};\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n-pub struct Lub<'f>(pub CombineFields<'f>);  // least-upper-bound: common supertype\n+/// \"Least upper bound\" (common supertype)\n+pub struct Lub<'f> {\n+    pub fields: CombineFields<'f>\n+}\n \n-impl<'f> Lub<'f> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Lub(ref v) = *self; v }\n+#[allow(non_snake_case_functions)]\n+pub fn Lub<'f>(cf: CombineFields<'f>) -> Lub<'f> {\n+    Lub { fields: cf }\n }\n \n impl<'f> Combine for Lub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n     fn tag(&self) -> String { \"lub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.fields.infcx.tcx;\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n@@ -63,7 +67,7 @@ impl<'f> Combine for Lub<'f> {\n           }\n \n           MutMutable => {\n-            self.get_ref().infcx.try(|| {\n+            self.fields.infcx.try(|| {\n                 eq_tys(self, a.ty, b.ty).then(|| {\n                     Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n@@ -107,10 +111,10 @@ impl<'f> Combine for Lub<'f> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n \n-        Ok(self.get_ref().infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n+        Ok(self.fields.infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n@@ -119,26 +123,26 @@ impl<'f> Combine for Lub<'f> {\n \n         // Make a mark so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.get_ref().infcx.region_vars.mark();\n+        let mark = self.fields.infcx.region_vars.mark();\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), a);\n         let (b_with_fresh, _) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), b);\n \n         // Collect constraints.\n-        let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.repr(self.get_ref().infcx.tcx));\n+        let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"sig0 = {}\", sig0.repr(self.fields.infcx.tcx));\n \n         // Generalize the regions appearing in sig0 if possible\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n+            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n         let sig1 =\n             fold_regions_in_sig(\n-                self.get_ref().infcx.tcx,\n+                self.fields.infcx.tcx,\n                 &sig0,\n                 |r| generalize_region(self, mark, new_vars.as_slice(),\n                                       sig0.binder_id, &a_map, r));\n@@ -158,7 +162,7 @@ impl<'f> Combine for Lub<'f> {\n                 return r0;\n             }\n \n-            let tainted = this.get_ref().infcx.region_vars.tainted(mark, r0);\n+            let tainted = this.fields.infcx.region_vars.tainted(mark, r0);\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n@@ -185,8 +189,8 @@ impl<'f> Combine for Lub<'f> {\n                 }\n             }\n \n-            this.get_ref().infcx.tcx.sess.span_bug(\n-                this.get_ref().trace.origin.span(),\n+            this.fields.infcx.tcx.sess.span_bug(\n+                this.fields.trace.origin.span(),\n                 format!(\"region {:?} is not associated with \\\n                          any bound region from A!\",\n                         r0).as_slice())"}, {"sha": "ff42dd817fb9404b3d843177258ec1afe361906a", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=790d9c47081c9ddffaad096239e0dfee2f2d10a6", "patch": "@@ -253,7 +253,7 @@ impl<'a> RegionVarBindings<'a> {\n     }\n \n     pub fn commit(&self, snapshot: RegionSnapshot) {\n-        debug!(\"RegionVarBindings: commit()\");\n+        debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n         assert!(self.undo_log.borrow().len() > snapshot.length);\n         assert!(*self.undo_log.borrow().get(snapshot.length) == OpenSnapshot);\n "}, {"sha": "1b83ee299bc7cad36610bb44d54d71bb9d4daf92", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9c47081c9ddffaad096239e0dfee2f2d10a6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=790d9c47081c9ddffaad096239e0dfee2f2d10a6", "patch": "@@ -26,52 +26,58 @@ use util::ppaux::{bound_region_to_string, Repr};\n \n use syntax::ast::{Onceness, FnStyle, MutImmutable, MutMutable};\n \n-pub struct Sub<'f>(pub CombineFields<'f>);  // \"subtype\", \"subregion\" etc\n \n-impl<'f> Sub<'f> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Sub(ref v) = *self; v }\n+/// \"Greatest lower bound\" (common subtype)\n+pub struct Sub<'f> {\n+    fields: CombineFields<'f>\n+}\n+\n+#[allow(non_snake_case_functions)]\n+pub fn Sub<'f>(cf: CombineFields<'f>) -> Sub<'f> {\n+    Sub { fields: cf }\n }\n \n impl<'f> Combine for Sub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n     fn tag(&self) -> String { \"sub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         let opp = CombineFields {\n-            a_is_expected: !self.get_ref().a_is_expected,\n-            ..self.get_ref().clone()\n+            a_is_expected: !self.fields.a_is_expected,\n+            ..self.fields.clone()\n         };\n         Sub(opp).tys(b, a)\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<ty::Region> {\n+                     -> cres<ty::Region>\n+    {\n         let opp = CombineFields {\n-            a_is_expected: !self.get_ref().a_is_expected,\n-            ..self.get_ref().clone()\n+            a_is_expected: !self.fields.a_is_expected,\n+            ..self.fields.clone()\n         };\n         Sub(opp).regions(b, a)\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n-        self.get_ref().infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+        self.fields.infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n         Ok(a)\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         debug!(\"mts({} <: {})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n@@ -118,7 +124,7 @@ impl<'f> Combine for Sub<'f> {\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n         let _indenter = indenter();\n         match (&ty::get(a).sty, &ty::get(b).sty) {\n@@ -127,7 +133,7 @@ impl<'f> Combine for Sub<'f> {\n             }\n \n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n-                if_ok!(self.get_ref().var_sub_var(a_id, b_id));\n+                if_ok!(self.fields.var_sub_var(a_id, b_id));\n                 Ok(a)\n             }\n             // The vec/str check here and below is so that we don't unify\n@@ -139,7 +145,7 @@ impl<'f> Combine for Sub<'f> {\n                 Err(ty::terr_sorts(expected_found(self, a, b)))\n             }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n-                if_ok!(self.get_ref().var_sub_t(a_id, b));\n+                if_ok!(self.fields.var_sub_t(a_id, b));\n                 Ok(a)\n             }\n \n@@ -148,7 +154,7 @@ impl<'f> Combine for Sub<'f> {\n                 Err(ty::terr_sorts(expected_found(self, a, b)))\n             }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n-                if_ok!(self.get_ref().t_sub_var(a, b_id));\n+                if_ok!(self.fields.t_sub_var(a, b_id));\n                 Ok(a)\n             }\n \n@@ -164,7 +170,7 @@ impl<'f> Combine for Sub<'f> {\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         debug!(\"fn_sigs(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         let _indenter = indenter();\n \n         // Rather than checking the subtype relationship between `a` and `b`\n@@ -176,38 +182,38 @@ impl<'f> Combine for Sub<'f> {\n \n         // Make a mark so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.get_ref().infcx.region_vars.mark();\n+        let mark = self.fields.infcx.region_vars.mark();\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n         let (a_sig, _) =\n-            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.trace(), a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let (skol_map, b_sig) = {\n-            replace_late_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, b, |br| {\n-                let skol = self.get_ref().infcx.region_vars.new_skolemized(br);\n+            replace_late_bound_regions_in_fn_sig(self.fields.infcx.tcx, b, |br| {\n+                let skol = self.fields.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n-                       bound_region_to_string(self.get_ref().infcx.tcx, \"\", false, br),\n+                       bound_region_to_string(self.fields.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n             })\n         };\n \n-        debug!(\"a_sig={}\", a_sig.repr(self.get_ref().infcx.tcx));\n-        debug!(\"b_sig={}\", b_sig.repr(self.get_ref().infcx.tcx));\n+        debug!(\"a_sig={}\", a_sig.repr(self.fields.infcx.tcx));\n+        debug!(\"b_sig={}\", b_sig.repr(self.fields.infcx.tcx));\n \n         // Compare types now that bound regions have been replaced.\n-        let sig = if_ok!(super_fn_sigs(self, &a_sig, &b_sig));\n+        let sig = try!(super_fn_sigs(self, &a_sig, &b_sig));\n \n         // Presuming type comparison succeeds, we need to check\n         // that the skolemized regions do not \"leak\".\n         let new_vars =\n-            self.get_ref().infcx.region_vars.vars_created_since_mark(mark);\n+            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n         for (&skol_br, &skol) in skol_map.iter() {\n-            let tainted = self.get_ref().infcx.region_vars.tainted(mark, skol);\n+            let tainted = self.fields.infcx.region_vars.tainted(mark, skol);\n             for tainted_region in tainted.iter() {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n@@ -224,16 +230,16 @@ impl<'f> Combine for Sub<'f> {\n                 if self.a_is_expected() {\n                     debug!(\"Not as polymorphic!\");\n                     return Err(ty::terr_regions_insufficiently_polymorphic(\n-                            skol_br, *tainted_region));\n+                        skol_br, *tainted_region));\n                 } else {\n                     debug!(\"Overly polymorphic!\");\n                     return Err(ty::terr_regions_overly_polymorphic(\n-                            skol_br, *tainted_region));\n+                        skol_br, *tainted_region));\n                 }\n             }\n         }\n \n         return Ok(sig);\n     }\n-\n }\n+"}]}