{"sha": "c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZGJkZmVlMDZjNzMzZjM2NDIwYTY1MWNkOTY4MmUwZWU0Zjk1YzM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-07-15T14:00:58Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-07-20T19:01:11Z"}, "message": "MIR changes to improve NLL cannot mutate errors\n\nAlway use unique instead of mutable borrows immutable upvars.\nMark variables that are references for a match guard", "tree": {"sha": "adcab5028bf29de0fdbd3870d3b5b4e11d653c04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adcab5028bf29de0fdbd3870d3b5b4e11d653c04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "html_url": "https://github.com/rust-lang/rust/commit/c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "509cbf3e8ecf1cf92b7051fa54e9360ad7b7449f", "url": "https://api.github.com/repos/rust-lang/rust/commits/509cbf3e8ecf1cf92b7051fa54e9360ad7b7449f", "html_url": "https://github.com/rust-lang/rust/commit/509cbf3e8ecf1cf92b7051fa54e9360ad7b7449f"}], "stats": {"total": 240, "additions": 190, "deletions": 50}, "files": [{"sha": "458c2f3885f9477fb0272a5a6412528ebd2ed35e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "patch": "@@ -531,6 +531,8 @@ pub enum BindingForm<'tcx> {\n     Var(VarBindingForm<'tcx>),\n     /// Binding for a `self`/`&self`/`&mut self` binding where the type is implicit.\n     ImplicitSelf,\n+    /// Reference used in a guard expression to ensure immutability.\n+    RefForGuard,\n }\n \n CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n@@ -555,6 +557,7 @@ mod binding_form_impl {\n             match self {\n                 Var(binding) => binding.hash_stable(hcx, hasher),\n                 ImplicitSelf => (),\n+                RefForGuard => (),\n             }\n         }\n     }"}, {"sha": "20eae289e5fba5facc132456177de945edd14a8c", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "patch": "@@ -742,6 +742,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n+                            } else if let Place::Local(local) = proj.base {\n+                                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n+                                    = self.mir.local_decls[local].is_user_variable {\n+                                    self.append_place_to_string(\n+                                        &proj.base,\n+                                        buf,\n+                                        autoderef,\n+                                        &including_downcast,\n+                                    )?;\n+                                } else {\n+                                    buf.push_str(&\"*\");\n+                                    self.append_place_to_string(\n+                                        &proj.base,\n+                                        buf,\n+                                        autoderef,\n+                                        &including_downcast,\n+                                    )?;\n+                                }\n                             } else {\n                                 buf.push_str(&\"*\");\n                                 self.append_place_to_string("}, {"sha": "384eb1db04ff7642740a88bb8375cdfdbd383703", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "patch": "@@ -206,7 +206,27 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 this.consume_by_copy_or_move(place)\n                             }\n                             _ => {\n-                                unpack!(block = this.as_operand(block, scope, upvar))\n+                                // Turn mutable borrow captures into unique\n+                                // borrow captures when capturing an immutable\n+                                // variable. This is sound because the mutation\n+                                // that caused the capture will cause an error.\n+                                match upvar.kind {\n+                                    ExprKind::Borrow {\n+                                        borrow_kind: BorrowKind::Mut {\n+                                            allow_two_phase_borrow: false\n+                                        },\n+                                        region,\n+                                        arg,\n+                                    } => unpack!(block = this.limit_capture_mutability(\n+                                        upvar.span,\n+                                        upvar.ty,\n+                                        scope,\n+                                        block,\n+                                        arg,\n+                                        region,\n+                                    )),\n+                                    _ => unpack!(block = this.as_operand(block, scope, upvar)),\n+                                }\n                             }\n                         }\n                     })\n@@ -393,6 +413,101 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn limit_capture_mutability(\n+        &mut self,\n+        upvar_span: Span,\n+        upvar_ty: Ty<'tcx>,\n+        temp_lifetime: Option<region::Scope>,\n+        mut block: BasicBlock,\n+        arg: ExprRef<'tcx>,\n+        region: &'tcx ty::RegionKind,\n+    ) -> BlockAnd<Operand<'tcx>> {\n+        let this = self;\n+\n+        let source_info = this.source_info(upvar_span);\n+        let temp = this.local_decls.push(LocalDecl::new_temp(upvar_ty, upvar_span));\n+\n+        this.cfg.push(block, Statement {\n+            source_info,\n+            kind: StatementKind::StorageLive(temp)\n+        });\n+\n+        let arg_place = unpack!(block = this.as_place(block, arg));\n+\n+        let mutability = match arg_place {\n+            Place::Local(local) => this.local_decls[local].mutability,\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) => {\n+                debug_assert!(\n+                    if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n+                        = this.local_decls[local].is_user_variable {\n+                        true\n+                    } else {\n+                        false\n+                    },\n+                    \"Unexpected capture place\",\n+                );\n+                this.local_decls[local].mutability\n+            }\n+            Place::Projection(box Projection {\n+                ref base,\n+                elem: ProjectionElem::Field(upvar_index, _),\n+            })\n+            | Place::Projection(box Projection {\n+                base: Place::Projection(box Projection {\n+                    ref base,\n+                    elem: ProjectionElem::Field(upvar_index, _),\n+                }),\n+                elem: ProjectionElem::Deref,\n+            }) => {\n+                // Not projected from the implicit `self` in a closure.\n+                debug_assert!(\n+                    match *base {\n+                        Place::Local(local) => local == Local::new(1),\n+                        Place::Projection(box Projection {\n+                            ref base,\n+                            elem: ProjectionElem::Deref,\n+                        }) => *base == Place::Local(Local::new(1)),\n+                        _ => false,\n+                    },\n+                    \"Unexpected capture place\"\n+                );\n+                // Not in a closure\n+                debug_assert!(\n+                    this.upvar_decls.len() > upvar_index.index(),\n+                    \"Unexpected capture place\"\n+                );\n+                this.upvar_decls[upvar_index.index()].mutability\n+            }\n+            _ => bug!(\"Unexpected capture place\"),\n+        };\n+\n+        let borrow_kind = match mutability {\n+            Mutability::Not => BorrowKind::Unique,\n+            Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+        };\n+\n+        this.cfg.push_assign(\n+            block,\n+            source_info,\n+            &Place::Local(temp),\n+            Rvalue::Ref(region, borrow_kind, arg_place),\n+        );\n+\n+        // In constants, temp_lifetime is None. We should not need to drop\n+        // anything because no values with a destructor can be created in\n+        // a constant at this time, even if the type may need dropping.\n+        if let Some(temp_lifetime) = temp_lifetime {\n+            this.schedule_drop_storage_and_value(\n+                upvar_span, temp_lifetime, &Place::Local(temp), upvar_ty,\n+            );\n+        }\n+\n+        block.and(Operand::Move(Place::Local(temp)))\n+    }\n+\n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());"}, {"sha": "d75b8d506e77b44292f1d4e78ade8ac5ebcc6c27", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "patch": "@@ -1198,7 +1198,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 visibility_scope,\n                 // FIXME: should these secretly injected ref_for_guard's be marked as `internal`?\n                 internal: false,\n-                is_user_variable: None,\n+                is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n             LocalsForNode::Three { val_for_guard, ref_for_guard, for_arm_body }\n         } else {"}, {"sha": "24228389fbfbb1182d4db4ac3e3c8fa8d69a3ff1", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3dbdfee06c733f36420a651cd9682e0ee4f95c3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c3dbdfee06c733f36420a651cd9682e0ee4f95c3", "patch": "@@ -286,6 +286,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n     var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    upvar_decls: Vec<UpvarDecl>,\n     unit_temp: Option<Place<'tcx>>,\n \n     /// cached block with the RESUME terminator; this is created\n@@ -472,11 +473,52 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let tcx = hir.tcx();\n     let span = tcx.hir.span(fn_id);\n+\n+    // Gather the upvars of a closure, if any.\n+    let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n+        freevars.iter().map(|fv| {\n+            let var_id = fv.var_id();\n+            let var_hir_id = tcx.hir.node_to_hir_id(var_id);\n+            let closure_expr_id = tcx.hir.local_def_id(fn_id);\n+            let capture = hir.tables().upvar_capture(ty::UpvarId {\n+                var_id: var_hir_id,\n+                closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n+            });\n+            let by_ref = match capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => true\n+            };\n+            let mut decl = UpvarDecl {\n+                debug_name: keywords::Invalid.name(),\n+                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n+                by_ref,\n+                mutability: Mutability::Not,\n+            };\n+            if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n+                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                    decl.debug_name = ident.name;\n+\n+                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n+                        if bm == ty::BindByValue(hir::MutMutable) {\n+                            decl.mutability = Mutability::Mut;\n+                        } else {\n+                            decl.mutability = Mutability::Not;\n+                        }\n+                    } else {\n+                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+                    }\n+                }\n+            }\n+            decl\n+        }).collect()\n+    });\n+\n     let mut builder = Builder::new(hir.clone(),\n         span,\n         arguments.len(),\n         safety,\n-        return_ty);\n+        return_ty,\n+        upvar_decls);\n \n     let fn_def_id = tcx.hir.local_def_id(fn_id);\n     let call_site_scope = region::Scope::CallSite(body.value.hir_id.local_id);\n@@ -519,46 +561,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     info!(\"fn_id {:?} has attrs {:?}\", closure_expr_id,\n           tcx.get_attrs(closure_expr_id));\n \n-    // Gather the upvars of a closure, if any.\n-    let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n-        freevars.iter().map(|fv| {\n-            let var_id = fv.var_id();\n-            let var_hir_id = tcx.hir.node_to_hir_id(var_id);\n-            let closure_expr_id = tcx.hir.local_def_id(fn_id);\n-            let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_id: var_hir_id,\n-                closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n-            });\n-            let by_ref = match capture {\n-                ty::UpvarCapture::ByValue => false,\n-                ty::UpvarCapture::ByRef(..) => true\n-            };\n-            let mut decl = UpvarDecl {\n-                debug_name: keywords::Invalid.name(),\n-                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n-                by_ref,\n-                mutability: Mutability::Not,\n-            };\n-            if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n-                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n-                    decl.debug_name = ident.name;\n-\n-                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n-                        if bm == ty::BindByValue(hir::MutMutable) {\n-                            decl.mutability = Mutability::Mut;\n-                        } else {\n-                            decl.mutability = Mutability::Not;\n-                        }\n-                    } else {\n-                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n-                    }\n-                }\n-            }\n-            decl\n-        }).collect()\n-    });\n-\n-    let mut mir = builder.finish(upvar_decls, yield_ty);\n+    let mut mir = builder.finish(yield_ty);\n     mir.spread_arg = spread_arg;\n     mir\n }\n@@ -571,7 +574,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir.body_owner(body_id);\n     let span = tcx.hir.span(owner_id);\n-    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty);\n+    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty, vec![]);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -590,7 +593,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                               TerminatorKind::Unreachable);\n     }\n \n-    builder.finish(vec![], None)\n+    builder.finish(None)\n }\n \n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n@@ -599,18 +602,19 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let owner_id = hir.tcx().hir.body_owner(body_id);\n     let span = hir.tcx().hir.span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, vec![]);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n-    builder.finish(vec![], None)\n+    builder.finish(None)\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>,\n            span: Span,\n            arg_count: usize,\n            safety: Safety,\n-           return_ty: Ty<'tcx>)\n+           return_ty: Ty<'tcx>,\n+           upvar_decls: Vec<UpvarDecl>)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n@@ -628,6 +632,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             breakable_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(LocalDecl::new_return_place(return_ty,\n                                                                              span), 1),\n+            upvar_decls,\n             var_indices: NodeMap(),\n             unit_temp: None,\n             cached_resume_block: None,\n@@ -645,7 +650,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     fn finish(self,\n-              upvar_decls: Vec<UpvarDecl>,\n               yield_ty: Option<Ty<'tcx>>)\n               -> Mir<'tcx> {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n@@ -661,7 +665,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                  yield_ty,\n                  self.local_decls,\n                  self.arg_count,\n-                 upvar_decls,\n+                 self.upvar_decls,\n                  self.fn_span\n         )\n     }"}]}