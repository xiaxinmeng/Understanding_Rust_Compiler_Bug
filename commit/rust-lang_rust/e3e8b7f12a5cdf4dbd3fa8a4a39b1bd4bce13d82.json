{"sha": "e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZThiN2YxMmE1Y2RmNGRiZDNmYThhNGEzOWIxYmQ0YmNlMTNkODI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-20T17:42:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-20T17:42:21Z"}, "message": "Rollup merge of #63750 - eddyb:lazy-seq, r=Zoxc\n\nrustc_metadata: replace LazySeq<T> with Lazy<[T]>.\n\nPart of #59953, split out for separate landing (see https://github.com/rust-lang/rust/pull/59953#issuecomment-502460092).\n\nr? @Zoxc", "tree": {"sha": "0577960769a9302066da1d41aec0cf220b8b50ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0577960769a9302066da1d41aec0cf220b8b50ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdXDD9CRBK7hj4Ov3rIwAAdHIIAEwMjujOPm3QQRd7H9zybFZ2\nmCva3MQ5jFsZllf/XtnLxa+/7/W1CGKVJ753V3JCVnuclvRSPrgXIfRO54jfc4z4\nJHNvrIk7E43Ov+sHlZIuau3Dpe+9GOIt/zeVZOF0YjFlQZyNFx0XnlUlq/65xNXE\nCuFL5Iyl+Gp4eigWf4M1ekLok6Om6nWNVB5iseXol4gml4yd8al1v5LJzaC7bYbm\nG7tPmUxwuimzPe74MaTUC+ZDGFX8uFI0GqwTysKdxWX255xFKk6QEHukvnQfC286\n2gvkdRtojx+cJj5i0KPlhMap/XKFXIkVho9zyl+aBT/yND2gtPJ8DdOoxESp1KM=\n=30n6\n-----END PGP SIGNATURE-----\n", "payload": "tree 0577960769a9302066da1d41aec0cf220b8b50ec\nparent 234614a70504f3820ffa65483ca043f05b65cb49\nparent e7ceaa97480b4292b56edb4fac37547dd4f2a30f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1566322941 +0200\ncommitter GitHub <noreply@github.com> 1566322941 +0200\n\nRollup merge of #63750 - eddyb:lazy-seq, r=Zoxc\n\nrustc_metadata: replace LazySeq<T> with Lazy<[T]>.\n\nPart of #59953, split out for separate landing (see https://github.com/rust-lang/rust/pull/59953#issuecomment-502460092).\n\nr? @Zoxc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "html_url": "https://github.com/rust-lang/rust/commit/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "234614a70504f3820ffa65483ca043f05b65cb49", "url": "https://api.github.com/repos/rust-lang/rust/commits/234614a70504f3820ffa65483ca043f05b65cb49", "html_url": "https://github.com/rust-lang/rust/commit/234614a70504f3820ffa65483ca043f05b65cb49"}, {"sha": "e7ceaa97480b4292b56edb4fac37547dd4f2a30f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ceaa97480b4292b56edb4fac37547dd4f2a30f", "html_url": "https://github.com/rust-lang/rust/commit/e7ceaa97480b4292b56edb4fac37547dd4f2a30f"}], "stats": {"total": 597, "additions": 301, "deletions": 296}, "files": [{"sha": "efc77699313e054ba278dd70eaa0f45a8157b2ee", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "patch": "@@ -68,9 +68,9 @@ pub struct CrateMetadata {\n     pub alloc_decoding_state: AllocDecodingState,\n \n     // NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    // lifetime is only used behind `Lazy` / `LazySeq`, and therefore\n-    // acts like an universal (`for<'tcx>`), that is paired up with\n-    // whichever `TyCtxt` is being used to decode those values.\n+    // lifetime is only used behind `Lazy`, and therefore acts like an\n+    // universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    // is being used to decode those values.\n     pub root: schema::CrateRoot<'static>,\n \n     /// For each definition in this crate, we encode a key. When the\n@@ -80,7 +80,7 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: Lrc<DefPathTable>,\n \n-    pub trait_impls: FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>,\n+    pub trait_impls: FxHashMap<(u32, DefIndex), schema::Lazy<[DefIndex]>>,\n \n     pub dep_kind: Lock<DepKind>,\n     pub source: CrateSource,"}, {"sha": "da96728d2dec9c316a671b76805024dfc8a7d7b2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "patch": "@@ -134,14 +134,14 @@ impl<'a, 'tcx, T: Decodable> Lazy<T> {\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> LazySeq<T> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n-        (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n+        (0..self.meta).map(move |_| T::decode(&mut dcx).unwrap())\n     }\n }\n \n@@ -154,18 +154,22 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n-    fn read_lazy_distance(&mut self, min_size: usize) -> Result<usize, <Self as Decoder>::Error> {\n+    fn read_lazy_with_meta<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        meta: T::Meta,\n+    ) -> Result<Lazy<T>, <Self as Decoder>::Error> {\n+        let min_size = T::min_size(meta);\n         let distance = self.read_usize()?;\n         let position = match self.lazy_state {\n-            LazyState::NoNode => bug!(\"read_lazy_distance: outside of a metadata node\"),\n+            LazyState::NoNode => bug!(\"read_lazy_with_meta: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n                 assert!(distance + min_size <= start);\n                 start - distance - min_size\n             }\n             LazyState::Previous(last_min_end) => last_min_end + distance,\n         };\n         self.lazy_state = LazyState::Previous(position + min_size);\n-        Ok(position)\n+        Ok(Lazy::from_position_and_meta(position, meta))\n     }\n }\n \n@@ -230,19 +234,18 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n-        Ok(Lazy::with_position(self.read_lazy_distance(Lazy::<T>::min_size())?))\n+        self.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<LazySeq<T>, Self::Error> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n         let len = self.read_usize()?;\n-        let position = if len == 0 {\n-            0\n+        if len == 0 {\n+            Ok(Lazy::empty())\n         } else {\n-            self.read_lazy_distance(LazySeq::<T>::min_size(len))?\n-        };\n-        Ok(LazySeq::with_position_and_length(position, len))\n+            self.read_lazy_with_meta(len)\n+        }\n     }\n }\n \n@@ -378,7 +381,7 @@ impl<'tcx> MetadataBlob {\n     }\n \n     pub fn get_rustc_version(&self) -> String {\n-        Lazy::with_position(METADATA_HEADER.len() + 4).decode(self)\n+        Lazy::<String>::from_position(METADATA_HEADER.len() + 4).decode(self)\n     }\n \n     pub fn get_root(&self) -> CrateRoot<'tcx> {\n@@ -387,7 +390,7 @@ impl<'tcx> MetadataBlob {\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n                    ((slice[offset + 2] as u32) << 8) |\n                    ((slice[offset + 3] as u32) << 0)) as usize;\n-        Lazy::with_position(pos).decode(self)\n+        Lazy::<CrateRoot<'tcx>>::from_position(pos).decode(self)\n     }\n \n     pub fn list_crate_metadata(&self,\n@@ -1140,7 +1143,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n             EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n-            _ => LazySeq::empty(),\n+            _ => Lazy::empty(),\n         };\n         arg_names.decode(self).collect()\n     }"}, {"sha": "df3320c64a96085263713355780a129d6775b417", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 195, "deletions": 196, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "patch": "@@ -98,17 +98,17 @@ impl<'tcx> Encoder for EncodeContext<'tcx> {\n \n impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n-        self.emit_lazy_distance(lazy.position, Lazy::<T>::min_size())\n+        self.emit_lazy_distance(*lazy)\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'tcx> {\n-    fn specialized_encode(&mut self, seq: &LazySeq<T>) -> Result<(), Self::Error> {\n-        self.emit_usize(seq.len)?;\n-        if seq.len == 0 {\n+impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n+    fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n+        self.emit_usize(lazy.meta)?;\n+        if lazy.meta == 0 {\n             return Ok(());\n         }\n-        self.emit_lazy_distance(seq.position, LazySeq::<T>::min_size(seq.len))\n+        self.emit_lazy_distance(*lazy)\n     }\n }\n \n@@ -239,21 +239,38 @@ impl<'tcx> TyEncoder for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx> EncodeContext<'tcx> {\n-    fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n-        assert_eq!(self.lazy_state, LazyState::NoNode);\n-        let pos = self.position();\n-        self.lazy_state = LazyState::NodeStart(pos);\n-        let r = f(self, pos);\n-        self.lazy_state = LazyState::NoNode;\n-        r\n+/// Helper trait to allow overloading `EncodeContext::lazy` for iterators.\n+trait EncodeContentsForLazy<T: ?Sized + LazyMeta> {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) -> T::Meta;\n+}\n+\n+impl<T: Encodable> EncodeContentsForLazy<T> for &T {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) {\n+        self.encode(ecx).unwrap()\n+    }\n+}\n+\n+impl<T: Encodable> EncodeContentsForLazy<T> for T {\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) {\n+        self.encode(ecx).unwrap()\n+    }\n+}\n+\n+impl<I, T> EncodeContentsForLazy<[T]> for I\n+    where I: IntoIterator,\n+          I::Item: EncodeContentsForLazy<T>,\n+{\n+    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'tcx>) -> usize {\n+        self.into_iter().map(|value| value.encode_contents_for_lazy(ecx)).count()\n     }\n+}\n \n-    fn emit_lazy_distance(&mut self,\n-                          position: usize,\n-                          min_size: usize)\n-                          -> Result<(), <Self as Encoder>::Error> {\n-        let min_end = position + min_size;\n+impl<'tcx> EncodeContext<'tcx> {\n+    fn emit_lazy_distance<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        lazy: Lazy<T>,\n+    ) -> Result<(), <Self as Encoder>::Error> {\n+        let min_end = lazy.position + T::min_size(lazy.meta);\n         let distance = match self.lazy_state {\n             LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n@@ -262,48 +279,31 @@ impl<'tcx> EncodeContext<'tcx> {\n             }\n             LazyState::Previous(last_min_end) => {\n                 assert!(\n-                    last_min_end <= position,\n+                    last_min_end <= lazy.position,\n                     \"make sure that the calls to `lazy*` \\\n                     are in the same order as the metadata fields\",\n                 );\n-                position - last_min_end\n+                lazy.position - last_min_end\n             }\n         };\n         self.lazy_state = LazyState::Previous(min_end);\n         self.emit_usize(distance)\n     }\n \n-    pub fn lazy<T: Encodable>(&mut self, value: &T) -> Lazy<T> {\n-        self.emit_node(|ecx, pos| {\n-            value.encode(ecx).unwrap();\n-\n-            assert!(pos + Lazy::<T>::min_size() <= ecx.position());\n-            Lazy::with_position(pos)\n-        })\n-    }\n-\n-    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = T>,\n-              T: Encodable\n-    {\n-        self.emit_node(|ecx, pos| {\n-            let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n+    fn lazy<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        value: impl EncodeContentsForLazy<T>,\n+    ) -> Lazy<T> {\n+        let pos = self.position();\n \n-            assert!(pos + LazySeq::<T>::min_size(len) <= ecx.position());\n-            LazySeq::with_position_and_length(pos, len)\n-        })\n-    }\n+        assert_eq!(self.lazy_state, LazyState::NoNode);\n+        self.lazy_state = LazyState::NodeStart(pos);\n+        let meta = value.encode_contents_for_lazy(self);\n+        self.lazy_state = LazyState::NoNode;\n \n-    pub fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = &'b T>,\n-              T: 'b + Encodable\n-    {\n-        self.emit_node(|ecx, pos| {\n-            let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n+        assert!(pos + <T>::min_size(meta) <= self.position());\n \n-            assert!(pos + LazySeq::<T>::min_size(len) <= ecx.position());\n-            LazySeq::with_position_and_length(pos, len)\n-        })\n+        Lazy::from_position_and_meta(pos, meta)\n     }\n \n     /// Emit the data for a `DefId` to the metadata. The function to\n@@ -320,7 +320,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         assert!(id.is_local());\n \n         let entry = op(self, data);\n-        let entry = self.lazy(&entry);\n+        let entry = self.lazy(entry);\n         self.entries_index.record(id, entry);\n     }\n \n@@ -341,7 +341,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         self.lazy(definitions.def_path_table())\n     }\n \n-    fn encode_source_map(&mut self) -> LazySeq<syntax_pos::SourceFile> {\n+    fn encode_source_map(&mut self) -> Lazy<[syntax_pos::SourceFile]> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -380,7 +380,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             })\n             .collect::<Vec<_>>();\n \n-        self.lazy_seq_ref(adapted.iter().map(|rc| &**rc))\n+        self.lazy(adapted.iter().map(|rc| &**rc))\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n@@ -463,7 +463,7 @@ impl<'tcx> EncodeContext<'tcx> {\n                 }\n                 n = new_n;\n             }\n-            self.lazy_seq(interpret_alloc_index)\n+            self.lazy(interpret_alloc_index)\n         };\n \n \n@@ -482,8 +482,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n-\n-        let root = self.lazy(&CrateRoot {\n+        let root = self.lazy(CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n             triple: tcx.sess.opts.target_triple.clone(),\n@@ -562,17 +561,17 @@ impl<'tcx> EncodeContext<'tcx> {\n }\n \n impl EncodeContext<'tcx> {\n-    fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n+    fn encode_variances_of(&mut self, def_id: DefId) -> Lazy<[ty::Variance]> {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy_seq_ref(&tcx.variances_of(def_id)[..])\n+        self.lazy(&tcx.variances_of(def_id)[..])\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let ty = tcx.type_of(def_id);\n         debug!(\"EncodeContext::encode_item_type({:?}) => {:?}\", def_id, ty);\n-        self.lazy(&ty)\n+        self.lazy(ty)\n     }\n \n     fn encode_enum_variant_info(\n@@ -601,23 +600,23 @@ impl EncodeContext<'tcx> {\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         Entry {\n-            kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: self.lazy(&ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            kind: EntryKind::Variant(self.lazy(data)),\n+            visibility: self.lazy(ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: self.lazy_seq(variant.fields.iter().map(|f| {\n+            children: self.lazy(variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n                 f.did.index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -642,7 +641,7 @@ impl EncodeContext<'tcx> {\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n             ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(&tcx.fn_sig(def_id)))\n+                Some(self.lazy(tcx.fn_sig(def_id)))\n             } else {\n                 None\n             }\n@@ -658,20 +657,20 @@ impl EncodeContext<'tcx> {\n         }\n \n         Entry {\n-            kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: self.lazy(&ctor_vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            kind: EntryKind::Variant(self.lazy(data)),\n+            visibility: self.lazy(ctor_vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -691,25 +690,25 @@ impl EncodeContext<'tcx> {\n \n         let data = ModData {\n             reexports: match tcx.module_exports(def_id) {\n-                Some(exports) => self.lazy_seq_ref(exports),\n-                _ => LazySeq::empty(),\n+                Some(exports) => self.lazy(exports),\n+                _ => Lazy::empty(),\n             },\n         };\n \n         Entry {\n-            kind: EntryKind::Mod(self.lazy(&data)),\n-            visibility: self.lazy(&ty::Visibility::from_hir(vis, id, tcx)),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            kind: EntryKind::Mod(self.lazy(data)),\n+            visibility: self.lazy(ty::Visibility::from_hir(vis, id, tcx)),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(attrs),\n-            children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n+            children: self.lazy(md.item_ids.iter().map(|item_id| {\n                 tcx.hir().local_def_id(item_id.id).index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: None,\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -734,16 +733,16 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind: EntryKind::Field,\n-            visibility: self.lazy(&field.vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            visibility: self.lazy(field.vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n             predicates_defined_on: None,\n@@ -763,7 +762,7 @@ impl EncodeContext<'tcx> {\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n             ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(&tcx.fn_sig(def_id)))\n+                Some(self.lazy(tcx.fn_sig(def_id)))\n             } else {\n                 None\n             }\n@@ -789,20 +788,20 @@ impl EncodeContext<'tcx> {\n         let repr_options = get_repr_options(tcx, adt_def_id);\n \n         Entry {\n-            kind: EntryKind::Struct(self.lazy(&data), repr_options),\n-            visibility: self.lazy(&ctor_vis),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            kind: EntryKind::Struct(self.lazy(data), repr_options),\n+            visibility: self.lazy(ctor_vis),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if variant.ctor_kind == CtorKind::Fn {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -821,13 +820,13 @@ impl EncodeContext<'tcx> {\n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy(&tcx.predicates_of(def_id))\n+        self.lazy(&*tcx.predicates_of(def_id))\n     }\n \n     fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy(&tcx.predicates_defined_on(def_id))\n+        self.lazy(&*tcx.predicates_defined_on(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n@@ -858,7 +857,7 @@ impl EncodeContext<'tcx> {\n \n                 let rendered =\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n-                let rendered_const = self.lazy(&RenderedConst(rendered));\n+                let rendered_const = self.lazy(RenderedConst(rendered));\n \n                 EntryKind::AssocConst(container, const_qualif, rendered_const)\n             }\n@@ -875,12 +874,12 @@ impl EncodeContext<'tcx> {\n                     FnData {\n                         constness: hir::Constness::NotConst,\n                         arg_names,\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::Method(self.lazy(&MethodData {\n+                EntryKind::Method(self.lazy(MethodData {\n                     fn_data,\n                     container,\n                     has_self: trait_item.method_has_self_argument,\n@@ -892,10 +891,10 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&trait_item.vis),\n-            span: self.lazy(&ast_item.span),\n+            visibility: self.lazy(trait_item.vis),\n+            span: self.lazy(ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n@@ -913,11 +912,11 @@ impl EncodeContext<'tcx> {\n                 }\n                 ty::AssocKind::OpaqueTy => unreachable!(),\n             },\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if trait_item.kind == ty::AssocKind::Method {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -971,12 +970,12 @@ impl EncodeContext<'tcx> {\n                     FnData {\n                         constness: sig.header.constness,\n                         arg_names: self.encode_fn_arg_names_for_body(body),\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::Method(self.lazy(&MethodData {\n+                EntryKind::Method(self.lazy(MethodData {\n                     fn_data,\n                     container,\n                     has_self: impl_item.method_has_self_argument,\n@@ -1004,19 +1003,19 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&impl_item.vis),\n-            span: self.lazy(&ast_item.span),\n+            visibility: self.lazy(impl_item.vis),\n+            span: self.lazy(ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: if impl_item.kind == ty::AssocKind::Method {\n                 self.encode_variances_of(def_id)\n             } else {\n-                LazySeq::empty()\n+                Lazy::empty()\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n@@ -1027,10 +1026,10 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n-                                    -> LazySeq<ast::Name> {\n+                                    -> Lazy<[ast::Name]> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n-            self.lazy_seq(body.arguments.iter().map(|arg| {\n+            self.lazy(body.arguments.iter().map(|arg| {\n                 match arg.pat.node {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => kw::Invalid,\n@@ -1039,28 +1038,28 @@ impl EncodeContext<'tcx> {\n         })\n     }\n \n-    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> LazySeq<ast::Name> {\n-        self.lazy_seq(param_names.iter().map(|ident| ident.name))\n+    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> Lazy<[ast::Name]> {\n+        self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n     fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Body<'tcx>>> {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n             let mir = self.tcx.optimized_mir(def_id);\n-            Some(self.lazy(&mir))\n+            Some(self.lazy(mir))\n         } else {\n             None\n         }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n-    fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n+    fn encode_inherent_implementations(&mut self, def_id: DefId) -> Lazy<[DefIndex]> {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if implementations.is_empty() {\n-            LazySeq::empty()\n+            Lazy::empty()\n         } else {\n-            self.lazy_seq(implementations.iter().map(|&def_id| {\n+            self.lazy(implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }))\n@@ -1074,7 +1073,7 @@ impl EncodeContext<'tcx> {\n \n     fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n-        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n+        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(depr))\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n@@ -1103,10 +1102,10 @@ impl EncodeContext<'tcx> {\n                 let data = FnData {\n                     constness: header.constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n-                    sig: self.lazy(&tcx.fn_sig(def_id)),\n+                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n-                EntryKind::Fn(self.lazy(&data))\n+                EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod((item.hir_id, m, &item.attrs, &item.vis));\n@@ -1127,7 +1126,7 @@ impl EncodeContext<'tcx> {\n \n                 let repr_options = get_repr_options(tcx, def_id);\n \n-                EntryKind::Struct(self.lazy(&VariantData {\n+                EntryKind::Struct(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n@@ -1138,7 +1137,7 @@ impl EncodeContext<'tcx> {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n                 let repr_options = get_repr_options(tcx, def_id);\n \n-                EntryKind::Union(self.lazy(&VariantData {\n+                EntryKind::Union(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n@@ -1175,10 +1174,10 @@ impl EncodeContext<'tcx> {\n                     defaultness,\n                     parent_impl: parent,\n                     coerce_unsized_info,\n-                    trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref)),\n+                    trait_ref: trait_ref.map(|trait_ref| self.lazy(trait_ref)),\n                 };\n \n-                EntryKind::Impl(self.lazy(&data))\n+                EntryKind::Impl(self.lazy(data))\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = tcx.trait_def(def_id);\n@@ -1187,57 +1186,57 @@ impl EncodeContext<'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_auto_impl: tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n-                    super_predicates: self.lazy(&tcx.super_predicates_of(def_id)),\n+                    super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n                 };\n \n-                EntryKind::Trait(self.lazy(&data))\n+                EntryKind::Trait(self.lazy(data))\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 let data = TraitAliasData {\n-                    super_predicates: self.lazy(&tcx.super_predicates_of(def_id)),\n+                    super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n                 };\n \n-                EntryKind::TraitAlias(self.lazy(&data))\n+                EntryKind::TraitAlias(self.lazy(data))\n             }\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n-            span: self.lazy(&item.span),\n+            visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n+            span: self.lazy(item.span),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemKind::ForeignMod(ref fm) => {\n-                    self.lazy_seq(fm.items\n+                    self.lazy(fm.items\n                         .iter()\n                         .map(|foreign_item| tcx.hir().local_def_id(\n                             foreign_item.hir_id).index))\n                 }\n                 hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n-                    self.lazy_seq(def.variants.iter().map(|v| {\n+                    self.lazy(def.variants.iter().map(|v| {\n                         assert!(v.def_id.is_local());\n                         v.def_id.index\n                     }))\n                 }\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) => {\n                     let def = self.tcx.adt_def(def_id);\n-                    self.lazy_seq(def.non_enum_variant().fields.iter().map(|f| {\n+                    self.lazy(def.non_enum_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n                     }))\n                 }\n                 hir::ItemKind::Impl(..) |\n                 hir::ItemKind::Trait(..) => {\n-                    self.lazy_seq(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n+                    self.lazy(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n                     }))\n                 }\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -1260,7 +1259,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             generics: match item.node {\n                 hir::ItemKind::Static(..) |\n@@ -1333,20 +1332,20 @@ impl EncodeContext<'tcx> {\n         use syntax::print::pprust;\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         Entry {\n-            kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n+            kind: EntryKind::MacroDef(self.lazy(MacroDef {\n                 body: pprust::tokens_to_string(macro_def.body.clone()),\n                 legacy: macro_def.legacy,\n             })),\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&macro_def.span),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(macro_def.span),\n             attributes: self.encode_attributes(&macro_def.attrs),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             ty: None,\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1363,15 +1362,15 @@ impl EncodeContext<'tcx> {\n         let tcx = self.tcx;\n         Entry {\n             kind: entry_kind,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n             ty: if encode_type { Some(self.encode_item_type(def_id)) } else { None },\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: None,\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1408,30 +1407,30 @@ impl EncodeContext<'tcx> {\n                 let data = GeneratorData {\n                     layout: layout.clone(),\n                 };\n-                EntryKind::Generator(self.lazy(&data))\n+                EntryKind::Generator(self.lazy(data))\n             }\n \n             ty::Closure(def_id, substs) => {\n                 let sig = substs.closure_sig(def_id, self.tcx);\n-                let data = ClosureData { sig: self.lazy(&sig) };\n-                EntryKind::Closure(self.lazy(&data))\n+                let data = ClosureData { sig: self.lazy(sig) };\n+                EntryKind::Closure(self.lazy(data))\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\")\n         };\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: None,\n             predicates_defined_on: None,\n@@ -1450,16 +1449,16 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind: EntryKind::Const(self.const_qualif(mir, body_id), const_data),\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n+            visibility: self.lazy(ty::Visibility::Public),\n+            span: self.lazy(tcx.def_span(def_id)),\n+            attributes: Lazy::empty(),\n+            children: Lazy::empty(),\n             stability: None,\n             deprecation: None,\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n+            variances: Lazy::empty(),\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n             predicates_defined_on: None,\n@@ -1468,37 +1467,37 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n-        self.lazy_seq_ref(attrs)\n+    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> Lazy<[ast::Attribute]> {\n+        self.lazy(attrs)\n     }\n \n-    fn encode_native_libraries(&mut self) -> LazySeq<NativeLibrary> {\n+    fn encode_native_libraries(&mut self) -> Lazy<[NativeLibrary]> {\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n-        self.lazy_seq(used_libraries.iter().cloned())\n+        self.lazy(used_libraries.iter().cloned())\n     }\n \n-    fn encode_foreign_modules(&mut self) -> LazySeq<ForeignModule> {\n+    fn encode_foreign_modules(&mut self) -> Lazy<[ForeignModule]> {\n         let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n-        self.lazy_seq(foreign_modules.iter().cloned())\n+        self.lazy(foreign_modules.iter().cloned())\n     }\n \n-    fn encode_proc_macros(&mut self) -> Option<LazySeq<DefIndex>> {\n+    fn encode_proc_macros(&mut self) -> Option<Lazy<[DefIndex]>> {\n         let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n         if is_proc_macro {\n-            let proc_macros: Vec<_> = self.tcx.hir().krate().items.values().filter_map(|item| {\n+            let tcx = self.tcx;\n+            Some(self.lazy(tcx.hir().krate().items.values().filter_map(|item| {\n                 if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n                     Some(item.hir_id.owner)\n                 } else {\n                     None\n                 }\n-            }).collect();\n-            Some(self.lazy_seq(proc_macros))\n+            })))\n         } else {\n             None\n         }\n     }\n \n-    fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n+    fn encode_crate_deps(&mut self) -> Lazy<[CrateDep]> {\n         let crates = self.tcx.crates();\n \n         let mut deps = crates\n@@ -1529,20 +1528,20 @@ impl EncodeContext<'tcx> {\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        self.lazy_seq_ref(deps.iter().map(|&(_, ref dep)| dep))\n+        self.lazy(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lib_features(&mut self) -> LazySeq<(ast::Name, Option<ast::Name>)> {\n+    fn encode_lib_features(&mut self) -> Lazy<[(ast::Name, Option<ast::Name>)]> {\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features();\n-        self.lazy_seq(lib_features.to_vec())\n+        self.lazy(lib_features.to_vec())\n     }\n \n-    fn encode_lang_items(&mut self) -> LazySeq<(DefIndex, usize)> {\n+    fn encode_lang_items(&mut self) -> Lazy<[(DefIndex, usize)]> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n         let lang_items = lang_items.items().iter();\n-        self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n+        self.lazy(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n             if let Some(def_id) = opt_def_id {\n                 if def_id.is_local() {\n                     return Some((def_id.index, i));\n@@ -1552,13 +1551,13 @@ impl EncodeContext<'tcx> {\n         }))\n     }\n \n-    fn encode_lang_items_missing(&mut self) -> LazySeq<lang_items::LangItem> {\n+    fn encode_lang_items_missing(&mut self) -> Lazy<[lang_items::LangItem]> {\n         let tcx = self.tcx;\n-        self.lazy_seq_ref(&tcx.lang_items().missing)\n+        self.lazy(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n+    fn encode_impls(&mut self) -> Lazy<[TraitImpls]> {\n         debug!(\"EncodeContext::encode_impls()\");\n         let tcx = self.tcx;\n         let mut visitor = ImplVisitor {\n@@ -1584,12 +1583,12 @@ impl EncodeContext<'tcx> {\n \n                 TraitImpls {\n                     trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                    impls: self.lazy_seq_ref(&impls),\n+                    impls: self.lazy(&impls),\n                 }\n             })\n             .collect();\n \n-        self.lazy_seq_ref(&all_impls)\n+        self.lazy(&all_impls)\n     }\n \n     // Encodes all symbols exported from this crate into the metadata.\n@@ -1600,12 +1599,12 @@ impl EncodeContext<'tcx> {\n     // definition (as that's not defined in this crate).\n     fn encode_exported_symbols(&mut self,\n                                exported_symbols: &[(ExportedSymbol<'tcx>, SymbolExportLevel)])\n-                               -> LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n+                               -> Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]> {\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(&metadata_symbol_name(self.tcx));\n \n-        self.lazy_seq(exported_symbols\n+        self.lazy(exported_symbols\n             .iter()\n             .filter(|&&(ref exported_symbol, _)| {\n                 match *exported_symbol {\n@@ -1618,10 +1617,10 @@ impl EncodeContext<'tcx> {\n             .cloned())\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n+    fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n         match self.tcx.sess.dependency_formats.borrow().get(&config::CrateType::Dylib) {\n             Some(arr) => {\n-                self.lazy_seq(arr.iter().map(|slot| {\n+                self.lazy(arr.iter().map(|slot| {\n                     match *slot {\n                         Linkage::NotLinked |\n                         Linkage::IncludedFromDylib => None,\n@@ -1631,7 +1630,7 @@ impl EncodeContext<'tcx> {\n                     }\n                 }))\n             }\n-            None => LazySeq::empty(),\n+            None => Lazy::empty(),\n         }\n     }\n \n@@ -1647,9 +1646,9 @@ impl EncodeContext<'tcx> {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n                     arg_names: self.encode_fn_arg_names(names),\n-                    sig: self.lazy(&tcx.fn_sig(def_id)),\n+                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n-                EntryKind::ForeignFn(self.lazy(&data))\n+                EntryKind::ForeignFn(self.lazy(data))\n             }\n             hir::ForeignItemKind::Static(_, hir::MutMutable) => EntryKind::ForeignMutStatic,\n             hir::ForeignItemKind::Static(_, hir::MutImmutable) => EntryKind::ForeignImmStatic,\n@@ -1658,18 +1657,18 @@ impl EncodeContext<'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n-            span: self.lazy(&nitem.span),\n+            visibility: self.lazy(ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n+            span: self.lazy(nitem.span),\n             attributes: self.encode_attributes(&nitem.attrs),\n-            children: LazySeq::empty(),\n+            children: Lazy::empty(),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n+            inherent_impls: Lazy::empty(),\n             variances: match nitem.node {\n                 hir::ForeignItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => LazySeq::empty(),\n+                _ => Lazy::empty(),\n             },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),"}, {"sha": "6f248f22cf2527502e3b60bbd39c9ea38788f810", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "patch": "@@ -108,34 +108,34 @@ impl Index<'tcx> {\n         position.write_to_bytes_at(positions, array_index)\n     }\n \n-    pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Self> {\n+    pub fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n         buf.emit_raw_bytes(&(self.positions.len() as u32 / 4).to_le_bytes());\n         // ... then the values.\n         buf.emit_raw_bytes(&self.positions);\n-        LazySeq::with_position_and_length(pos as usize, self.positions.len() / 4 + 1)\n+        Lazy::from_position_and_meta(pos as usize, self.positions.len() / 4 + 1)\n     }\n }\n \n-impl LazySeq<Index<'tcx>> {\n+impl Lazy<[Index<'tcx>]> {\n     /// Given the metadata, extract out the offset of a particular\n     /// DefIndex (if any).\n     #[inline(never)]\n     pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n         let bytes = &bytes[self.position..];\n         debug!(\"Index::lookup: index={:?} len={:?}\",\n                def_index,\n-               self.len);\n+               self.meta);\n \n         let position = u32::read_from_bytes_at(bytes, 1 + def_index.index());\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None\n         } else {\n             debug!(\"Index::lookup: position={:?}\", position);\n-            Some(Lazy::with_position(position as usize))\n+            Some(Lazy::from_position(position as usize))\n         }\n     }\n }"}, {"sha": "f37877b437e157582b7e5d0938ad91a1844d96e5", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 78, "deletions": 75, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e3e8b7f12a5cdf4dbd3fa8a4a39b1bd4bce13d82", "patch": "@@ -41,6 +41,33 @@ pub const METADATA_VERSION: u8 = 4;\n pub const METADATA_HEADER: &[u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n+/// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n+/// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n+pub trait LazyMeta {\n+    type Meta: Copy + 'static;\n+\n+    /// Returns the minimum encoded size.\n+    // FIXME(eddyb) Give better estimates for certain types.\n+    fn min_size(meta: Self::Meta) -> usize;\n+}\n+\n+impl<T> LazyMeta for T {\n+    type Meta = ();\n+\n+    fn min_size(_: ()) -> usize {\n+        assert_ne!(std::mem::size_of::<T>(), 0);\n+        1\n+    }\n+}\n+\n+impl<T> LazyMeta for [T] {\n+    type Meta = usize;\n+\n+    fn min_size(len: usize) -> usize {\n+        len * T::min_size(())\n+    }\n+}\n+\n /// A value of type T referred to by its absolute position\n /// in the metadata, and which can be decoded lazily.\n ///\n@@ -56,40 +83,8 @@ pub const METADATA_HEADER: &[u8; 12] =\n /// Distances start at 1, as 0-byte nodes are invalid.\n /// Also invalid are nodes being referred in a different\n /// order than they were encoded in.\n-#[must_use]\n-pub struct Lazy<T> {\n-    pub position: usize,\n-    _marker: PhantomData<T>,\n-}\n-\n-impl<T> Lazy<T> {\n-    pub fn with_position(position: usize) -> Lazy<T> {\n-        Lazy {\n-            position,\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    /// Returns the minimum encoded size of a value of type `T`.\n-    // FIXME(eddyb) Give better estimates for certain types.\n-    pub fn min_size() -> usize {\n-        1\n-    }\n-}\n-\n-impl<T> Copy for Lazy<T> {}\n-impl<T> Clone for Lazy<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-impl<T> rustc_serialize::UseSpecializedEncodable for Lazy<T> {}\n-impl<T> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n-\n-/// A sequence of type T referred to by its absolute position\n-/// in the metadata and length, and which can be decoded lazily.\n-/// The sequence is a single node for the purposes of `Lazy`.\n+///\n+/// # Sequences (`Lazy<[T]>`)\n ///\n /// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n /// position, not at the position, which means that the length\n@@ -100,54 +95,62 @@ impl<T> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n /// the minimal distance the length of the sequence, i.e.\n /// it's assumed there's no 0-byte element in the sequence.\n #[must_use]\n-pub struct LazySeq<T> {\n-    pub len: usize,\n+// FIXME(#59875) the `Meta` parameter only exists to dodge\n+// invariance wrt `T` (coming from the `meta: T::Meta` field).\n+pub struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n+    where T: ?Sized + LazyMeta<Meta = Meta>,\n+          Meta: 'static + Copy,\n+{\n     pub position: usize,\n+    pub meta: Meta,\n     _marker: PhantomData<T>,\n }\n \n-impl<T> LazySeq<T> {\n-    pub fn empty() -> LazySeq<T> {\n-        LazySeq::with_position_and_length(0, 0)\n-    }\n-\n-    pub fn with_position_and_length(position: usize, len: usize) -> LazySeq<T> {\n-        LazySeq {\n-            len,\n+impl<T: ?Sized + LazyMeta> Lazy<T> {\n+    pub fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n+        Lazy {\n             position,\n+            meta,\n             _marker: PhantomData,\n         }\n     }\n+}\n+\n+impl<T> Lazy<T> {\n+    pub fn from_position(position: usize) -> Lazy<T> {\n+        Lazy::from_position_and_meta(position, ())\n+    }\n+}\n \n-    /// Returns the minimum encoded size of `length` values of type `T`.\n-    pub fn min_size(length: usize) -> usize {\n-        length\n+impl<T> Lazy<[T]> {\n+    pub fn empty() -> Lazy<[T]> {\n+        Lazy::from_position_and_meta(0, 0)\n     }\n }\n \n-impl<T> Copy for LazySeq<T> {}\n-impl<T> Clone for LazySeq<T> {\n+impl<T: ?Sized + LazyMeta> Copy for Lazy<T> {}\n+impl<T: ?Sized + LazyMeta> Clone for Lazy<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<T> rustc_serialize::UseSpecializedEncodable for LazySeq<T> {}\n-impl<T> rustc_serialize::UseSpecializedDecodable for LazySeq<T> {}\n+impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedEncodable for Lazy<T> {}\n+impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n \n-/// Encoding / decoding state for `Lazy` and `LazySeq`.\n+/// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n-    /// Inside a metadata node, and before any `Lazy` or `LazySeq`.\n+    /// Inside a metadata node, and before any `Lazy`.\n     /// The position is that of the node itself.\n     NodeStart(usize),\n \n-    /// Inside a metadata node, with a previous `Lazy` or `LazySeq`.\n+    /// Inside a metadata node, with a previous `Lazy`.\n     /// The position is a conservative estimate of where that\n-    /// previous `Lazy` / `LazySeq` would end (see their comments).\n+    /// previous `Lazy` would end (see their comments).\n     Previous(usize),\n }\n \n@@ -167,24 +170,24 @@ pub struct CrateRoot<'tcx> {\n     pub proc_macro_decls_static: Option<DefIndex>,\n     pub proc_macro_stability: Option<attr::Stability>,\n \n-    pub crate_deps: LazySeq<CrateDep>,\n-    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n-    pub lib_features: LazySeq<(Symbol, Option<Symbol>)>,\n-    pub lang_items: LazySeq<(DefIndex, usize)>,\n-    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n-    pub native_libraries: LazySeq<NativeLibrary>,\n-    pub foreign_modules: LazySeq<ForeignModule>,\n-    pub source_map: LazySeq<syntax_pos::SourceFile>,\n+    pub crate_deps: Lazy<[CrateDep]>,\n+    pub dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n+    pub lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n+    pub lang_items: Lazy<[(DefIndex, usize)]>,\n+    pub lang_items_missing: Lazy<[lang_items::LangItem]>,\n+    pub native_libraries: Lazy<[NativeLibrary]>,\n+    pub foreign_modules: Lazy<[ForeignModule]>,\n+    pub source_map: Lazy<[syntax_pos::SourceFile]>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: LazySeq<(ExportedSymbol<'tcx>, SymbolExportLevel)>,\n-    pub interpret_alloc_index: LazySeq<u32>,\n+    pub impls: Lazy<[TraitImpls]>,\n+    pub exported_symbols: Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]>,\n+    pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub entries_index: LazySeq<index::Index<'tcx>>,\n+    pub entries_index: Lazy<[index::Index<'tcx>]>,\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate\n-    pub proc_macro_data: Option<LazySeq<DefIndex>>,\n+    pub proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n     pub compiler_builtins: bool,\n     pub needs_allocator: bool,\n@@ -207,22 +210,22 @@ pub struct CrateDep {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n-    pub impls: LazySeq<DefIndex>,\n+    pub impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: Lazy<ty::Visibility>,\n     pub span: Lazy<Span>,\n-    pub attributes: LazySeq<ast::Attribute>,\n-    pub children: LazySeq<DefIndex>,\n+    pub attributes: Lazy<[ast::Attribute]>,\n+    pub children: Lazy<[DefIndex]>,\n     pub stability: Option<Lazy<attr::Stability>>,\n     pub deprecation: Option<Lazy<attr::Deprecation>>,\n \n     pub ty: Option<Lazy<Ty<'tcx>>>,\n-    pub inherent_impls: LazySeq<DefIndex>,\n-    pub variances: LazySeq<ty::Variance>,\n+    pub inherent_impls: Lazy<[DefIndex]>,\n+    pub variances: Lazy<[ty::Variance]>,\n     pub generics: Option<Lazy<ty::Generics>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n     pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n@@ -278,7 +281,7 @@ pub struct RenderedConst(pub String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n-    pub reexports: LazySeq<def::Export<hir::HirId>>,\n+    pub reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -290,7 +293,7 @@ pub struct MacroDef {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData<'tcx> {\n     pub constness: hir::Constness,\n-    pub arg_names: LazySeq<ast::Name>,\n+    pub arg_names: Lazy<[ast::Name]>,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n "}]}