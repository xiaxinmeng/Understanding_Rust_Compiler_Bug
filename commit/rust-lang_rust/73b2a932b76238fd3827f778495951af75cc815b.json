{"sha": "73b2a932b76238fd3827f778495951af75cc815b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYjJhOTMyYjc2MjM4ZmQzODI3Zjc3ODQ5NTk1MWFmNzVjYzgxNWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-03T03:28:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-03T03:29:00Z"}, "message": "doc: Minor tutorial improvements", "tree": {"sha": "59ece6535041d792f60e8ed7f3c07bc0f7858f4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59ece6535041d792f60e8ed7f3c07bc0f7858f4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73b2a932b76238fd3827f778495951af75cc815b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73b2a932b76238fd3827f778495951af75cc815b", "html_url": "https://github.com/rust-lang/rust/commit/73b2a932b76238fd3827f778495951af75cc815b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73b2a932b76238fd3827f778495951af75cc815b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f451a7bd7d856daad1e487f7bc7a14c40840c2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f451a7bd7d856daad1e487f7bc7a14c40840c2d", "html_url": "https://github.com/rust-lang/rust/commit/2f451a7bd7d856daad1e487f7bc7a14c40840c2d"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "7f60492e06ff36173702da40e80f920a6ebc2e21", "filename": "doc/tutorial.md", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/73b2a932b76238fd3827f778495951af75cc815b/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/73b2a932b76238fd3827f778495951af75cc815b/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=73b2a932b76238fd3827f778495951af75cc815b", "patch": "@@ -213,8 +213,8 @@ fn main() {\n }\n ~~~~\n \n-The `let` keyword, introduces a local variable. By default, variables\n-are immutable. `let mut` can be used to introduce a local variable\n+The `let` keyword introduces a local variable. Variables are immutable\n+by default, so `let mut` can be used to introduce a local variable\n that can be reassigned.\n \n ~~~~\n@@ -229,14 +229,17 @@ while count < 10 {\n \n Although Rust can almost always infer the types of local variables, it\n can help readability to specify a variable's type by following it with\n-a colon, then the type name. Local variables may shadow earlier\n-declarations, making the earlier variables inaccessible.\n+a colon, then the type name. \n \n ~~~~\n let my_favorite_value: float = 57.8;\n let my_favorite_value: int = my_favorite_value as int;\n ~~~~\n \n+Local variables may shadow earlier declarations, as in the previous\n+example in which `my_favorite_value` is first declared as a `float`\n+then a second `my_favorite_value` is declared as an int.\n+\n Rust identifiers follow the same rules as C; they start with an alphabetic\n character or an underscore, and after that may contain any sequence of\n alphabetic characters, numbers, or underscores. The preferred style is to\n@@ -1632,8 +1635,9 @@ fn contains(v: &[int], elt: int) -> bool {\n # Generics\n \n Throughout this tutorial, we've been defining functions that act only on\n-single data types. With type parameters we can also define functions that\n-may be invoked on multiple types.\n+specific data types. With type parameters we can also define functions whose\n+arguments represent generic types, and which can be invoked with a variety\n+of types. Consider a generic `map` function.\n \n ~~~~\n fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n@@ -1653,7 +1657,7 @@ each other.\n Inside a generic function, the names of the type parameters\n (capitalized by convention) stand for opaque types. You can't look\n inside them, but you can pass them around.  Note that instances of\n-generic types are almost always passed by pointer.  For example, the\n+generic types are often passed by pointer.  For example, the\n parameter `function()` is supplied with a pointer to a value of type\n `T` and not a value of type `T` itself.  This ensures that the\n function works with the broadest set of types possible, since some\n@@ -1679,11 +1683,11 @@ These declarations produce valid types like `Set<int>`, `Stack<int>`\n and `Maybe<int>`.\n \n Generic functions in Rust are compiled to very efficient runtime code\n-through a process called _monomorphisation_. This big word just means\n-that, for each generic function you call, the compiler generates a\n-specialized version that is optimized specifically for the argument\n-types. In this respect Rust's generics have similar performance\n-characteristics to C++ templates.\n+through a process called _monomorphisation_. This is a fancy way of\n+saying that, for each generic function you call, the compiler\n+generates a specialized version that is optimized specifically for the\n+argument types. In this respect Rust's generics have similar\n+performance characteristics to C++ templates.\n \n ## Traits\n \n@@ -1748,23 +1752,23 @@ types by the compiler, and may not be overridden:\n \n ## Declaring and implementing traits\n \n-A trait consists of a set of methods, or may be empty, as is the case\n-with `Copy`, `Send`, and `Const`. A method is a function that\n-can be applied to a `self` value and a number of arguments, using the\n-dot notation: `self.foo(arg1, arg2)`.\n-\n-For example, we could declare the trait `Printable` for things that\n-can be printed to the console, with a single method:\n+A trait consists of a set of methods, without bodies, or may be empty,\n+as is the case with `Copy`, `Send`, and `Const`. For example, we could\n+declare the trait `Printable` for things that can be printed to the\n+console, with a single method:\n \n ~~~~\n trait Printable {\n     fn print();\n }\n ~~~~\n \n-To actually implement a trait for a given type, the `impl` form is\n-used. This defines implementations of `Printable` for the `int` and\n-`~str` types.\n+Traits may be implemented for specific types with [impls]. An impl\n+that implements a trait includes the name of the trait at the start of \n+the definition, as in the following impls of `Printable` for `int`\n+and `~str`.\n+\n+[impls]: #functions-and-methods\n \n ~~~~\n # trait Printable { fn print(); }\n@@ -1780,14 +1784,10 @@ impl ~str: Printable {\n # (~\"foo\").print();\n ~~~~\n \n-Given these, we may call `1.print()` to print `\"1\"`, or\n-`(~\"foo\").print()` to print `\"foo\"` again, as with . This is basically a form of\n-static overloading\u2014when the Rust compiler sees the `print` method\n-call, it looks for an implementation that matches the type with a\n-method that matches the name, and simply calls that.\n-\n-Traits may themselves contain type parameters. A trait for\n-generalized sequence types might look like the following:\n+Methods defined in an implementation of a trait may be called just as\n+any other method, using dot notation, as in `1.print()`. Traits may\n+themselves contain type parameters. A trait for generalized sequence\n+types might look like the following:\n \n ~~~~\n trait Seq<T> {"}]}