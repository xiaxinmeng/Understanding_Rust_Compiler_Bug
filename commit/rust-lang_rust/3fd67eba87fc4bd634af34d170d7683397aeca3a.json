{"sha": "3fd67eba87fc4bd634af34d170d7683397aeca3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZDY3ZWJhODdmYzRiZDYzNGFmMzRkMTcwZDc2ODMzOTdhZWNhM2E=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-04T22:20:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-16T18:57:43Z"}, "message": "fallout from separating impl-items from impls\n\nBasically adding `visit_impl_item` in various places and so forth.", "tree": {"sha": "010101b416cf9342a6aac147c7cf8fb30c30a640", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/010101b416cf9342a6aac147c7cf8fb30c30a640"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fd67eba87fc4bd634af34d170d7683397aeca3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd67eba87fc4bd634af34d170d7683397aeca3a", "html_url": "https://github.com/rust-lang/rust/commit/3fd67eba87fc4bd634af34d170d7683397aeca3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fd67eba87fc4bd634af34d170d7683397aeca3a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b889259e2b42479584343eb3674b7a3de1870e5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b889259e2b42479584343eb3674b7a3de1870e5b", "html_url": "https://github.com/rust-lang/rust/commit/b889259e2b42479584343eb3674b7a3de1870e5b"}], "stats": {"total": 303, "additions": 233, "deletions": 70}, "files": [{"sha": "1e373441e9e85251d1ca4c4aa97a1b343f83c6da", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -56,6 +56,7 @@ use super::intravisit::Visitor;\n /// needed.\n pub trait ItemLikeVisitor<'hir> {\n     fn visit_item(&mut self, item: &'hir Item);\n+    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem);\n }\n \n pub struct DeepVisitor<'v, V: 'v> {\n@@ -76,4 +77,8 @@ impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n     fn visit_item(&mut self, item: &'hir Item) {\n         self.visitor.visit_item(item);\n     }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem) {\n+        self.visitor.visit_impl_item(impl_item);\n+    }\n }"}, {"sha": "eafb7949da387478128cb6fba73771fd49886058", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -99,6 +99,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         }\n     }\n \n+    fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n+        self.visit_impl_item(self.krate.impl_item(item_id))\n+    }\n+\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "78049663afeb5df6140080c698bd89b238962b9d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -797,8 +797,13 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+        let item = self.tcx.map.expect_item(item.id);\n+        self.visit_item(item)\n+    }\n+\n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        let impl_item = self.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n     }\n \n     fn visit_item(&mut self, it: &hir::Item) {"}, {"sha": "57abf0bdc427dcccbe74d3a49d5aef8ba3d52186", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -330,11 +330,12 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   or\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n-struct LifeSeeder {\n-    worklist: Vec<ast::NodeId>\n+struct LifeSeeder<'k> {\n+    worklist: Vec<ast::NodeId>,\n+    krate: &'k hir::Crate,\n }\n \n-impl<'v> ItemLikeVisitor<'v> for LifeSeeder {\n+impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(&item.attrs);\n         if allow_dead_code {\n@@ -358,17 +359,22 @@ impl<'v> ItemLikeVisitor<'v> for LifeSeeder {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., ref opt_trait, _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., ref opt_trait, _, ref impl_item_ids) => {\n+                for &impl_item_id in impl_item_ids {\n+                    let impl_item = self.krate.impl_item(impl_item_id);\n                     if opt_trait.is_some() ||\n                             has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n-                        self.worklist.push(impl_item.id);\n+                        self.worklist.push(impl_item_id.id);\n                     }\n                 }\n             }\n             _ => ()\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _item: &hir::ImplItem) {\n+        // ignore: we are handling this in `visit_item` above\n+    }\n }\n \n fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -387,7 +393,8 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Seed implemented trait items\n     let mut life_seeder = LifeSeeder {\n-        worklist: worklist\n+        worklist: worklist,\n+        krate: krate,\n     };\n     krate.visit_all_item_likes(&mut life_seeder);\n \n@@ -510,8 +517,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+        let item = self.tcx.map.expect_item(item.id);\n+        self.visit_item(item)\n+    }\n+\n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        let impl_item = self.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {"}, {"sha": "9dd54457a3499b442952af6a82939692b10b9584", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -17,7 +17,7 @@ use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use hir::{Item, ItemFn};\n+use hir::{Item, ItemFn, ImplItem};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n struct EntryContext<'a, 'tcx: 'a> {\n@@ -46,6 +46,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n+        // entry fn is never an impl item\n+    }\n }\n \n pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {"}, {"sha": "9b4b1396669a3a6ab5242977b2bed3d74bddc788", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -164,6 +164,10 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+        // at present, lang items are always items, not impl items\n+    }\n }\n \n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {"}, {"sha": "0a45f895d7dfc86462d0cfcd7f8d809a10010431", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -336,6 +336,10 @@ impl<'a, 'v> ItemLikeVisitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+        // processed in visit_item above\n+    }\n }\n \n pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "68d2cceda847a9c1d84b644f5f735d623150692b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -141,6 +141,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         self.visit_item(item)\n     }\n \n+    fn visit_nested_impl_item(&mut self, id: hir::ImplItemId) {\n+        let impl_item = self.hir_map.impl_item(id);\n+        self.visit_impl_item(impl_item)\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         // Save labels for nested items.\n         let saved_labels_in_fn = replace(&mut self.labels_in_fn, vec![]);"}, {"sha": "f8d58c5f2d914819c975f02e229b3d9bf28dee3c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -239,8 +239,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+        let item = self.tcx.map.expect_item(item.id);\n+        self.visit_item(item)\n+    }\n+\n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        let impl_item = self.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n     }\n \n     fn visit_item(&mut self, i: &Item) {\n@@ -449,8 +454,13 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+        let item = self.tcx.map.expect_item(item.id);\n+        self.visit_item(item)\n+    }\n+\n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        let impl_item = self.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -527,9 +537,10 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // For implementations of traits, check the stability of each item\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n-        hir::ItemImpl(.., Some(ref t), _, ref impl_items) => {\n+        hir::ItemImpl(.., Some(ref t), _, ref impl_item_ids) => {\n             let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            for impl_item in impl_items {\n+            for &impl_item_id in impl_item_ids {\n+                let impl_item = tcx.map.impl_item(impl_item_id);\n                 let item = tcx.associated_items(trait_did)\n                     .find(|item| item.name == impl_item.name).unwrap();\n                 if warn_about_defns {"}, {"sha": "4db620b2bec3b1ec507be9519bcf13e70ae1a09f", "filename": "src/librustc_driver/derive_registrar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_driver%2Fderive_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_driver%2Fderive_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fderive_registrar.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -34,4 +34,8 @@ impl<'v> ItemLikeVisitor<'v> for Finder {\n             self.registrar = Some(item.id);\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n+"}, {"sha": "d66e0f6aba352a4efa14ad87d31c4f43425d46e7", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -171,6 +171,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.id, &item.attrs);\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {\n+        // handled in `visit_item` above\n+    }\n }\n \n fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "3060e237fc13b2ffbc3c327cf80509c6f784a1ea", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -503,6 +503,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         // Each item is hashed independently; ignore nested items.\n     }\n \n+    fn visit_nested_impl_item(&mut self, impl_item_id: ImplItemId) {\n+        // For now, we hash impl items as part of the containing impl.\n+        let impl_item = self.tcx.map.impl_item(impl_item_id);\n+        self.visit_impl_item(impl_item);\n+    }\n+\n     fn visit_variant_data(&mut self,\n                           s: &'tcx VariantData,\n                           name: Name,"}, {"sha": "0cd1c88fb877bb7e007444b2e63cd0d3c4da0344", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -184,6 +184,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -225,6 +228,9 @@ impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx,\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {"}, {"sha": "2d96eeb8f201b1e0e89526135b41734c2e51057b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -1177,6 +1177,10 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+        // handled in `visit_item` above\n+    }\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {"}, {"sha": "21bebb2562a1b0cdebdd4fc89f2959a22ac68179", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -277,8 +277,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                             .and_then(|impl_node_id| self.tcx.map.find(impl_node_id))\n                             .map(|node| {\n                                 if let hir_map::NodeItem(item) = node {\n-                                    if let hir::ItemImpl(_, _, _, _, _, ref methods) = item.node {\n-                                        span = methods.first().map(|method| method.span);\n+                                    if let hir::ItemImpl(_, _, _, _, _, ref impl_item_ids) = item.node {\n+                                        span = impl_item_ids.first()\n+                                                            .map(|&impl_item_id| {\n+                                                                self.tcx.map.impl_item(impl_item_id)\n+                                                                            .span\n+                                                            });\n                                     }\n                                 }\n                             });"}, {"sha": "724100e02237f74304c0f79ab1188df519e37b58", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -44,6 +44,10 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n         self.with_context(Normal, |v| intravisit::walk_item(v, i));\n     }\n \n+    fn visit_impl_item(&mut self, i: &hir::ImplItem) {\n+        self.with_context(Normal, |v| intravisit::walk_impl_item(v, i));\n+    }\n+\n     fn visit_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {"}, {"sha": "75046f6aeb8742fd581b3f669bcdb30ffeb98126", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -32,6 +32,9 @@ impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n /// Find the function marked with `#[plugin_registrar]`, if any."}, {"sha": "3fd1ed935165817ff17a0e4265ec39ca773223f5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 59, "deletions": 25, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -124,6 +124,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        let impl_item = self.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n@@ -159,15 +164,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., None, _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., None, _, ref impl_item_ids) => {\n+                for &impl_item_id in impl_item_ids {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_id);\n                     if impl_item.vis == hir::Public {\n                         self.update(impl_item.id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., Some(_), _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., Some(_), _, ref impl_item_ids) => {\n+                for &impl_item_id in impl_item_ids {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_id);\n                     self.update(impl_item.id, item_level);\n                 }\n             }\n@@ -250,11 +257,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref generics, None, _, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, None, _, ref impl_item_ids) => {\n                 if item_level.is_some() {\n                     self.reach().visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        if self.get(impl_item.id).is_some() {\n+                    for &impl_item_id in impl_item_ids {\n+                        if self.get(impl_item_id.id).is_some() {\n+                            let impl_item = self.tcx.map.impl_item(impl_item_id);\n                             self.reach().visit_impl_item(impl_item);\n                         }\n                     }\n@@ -319,6 +327,12 @@ impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n }\n \n impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        // when we visit an impl, its methods and items are part of its \"interface\"\n+        let impl_item = self.ev.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n+    }\n+\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.ev.tcx.expect_def(ty.id);\n@@ -421,6 +435,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        let impl_item = self.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         intravisit::walk_item(self, item);\n@@ -625,6 +644,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        let impl_item = self.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n+    }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need\n@@ -650,7 +674,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_items) => {\n+            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_item_ids) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -695,16 +719,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                 // are private (because `T` won't be visible externally).\n                 let trait_or_some_public_method =\n                     trait_ref.is_some() ||\n-                    impl_items.iter()\n-                              .any(|impl_item| {\n-                                  match impl_item.node {\n-                                      hir::ImplItemKind::Const(..) |\n-                                      hir::ImplItemKind::Method(..) => {\n-                                          self.access_levels.is_reachable(impl_item.id)\n-                                      }\n-                                      hir::ImplItemKind::Type(_) => false,\n-                                  }\n-                              });\n+                    impl_item_ids.iter()\n+                                 .any(|&impl_item_id| {\n+                                     let impl_item = self.tcx.map.impl_item(impl_item_id);\n+                                     match impl_item.node {\n+                                         hir::ImplItemKind::Const(..) |\n+                                         hir::ImplItemKind::Method(..) => {\n+                                             self.access_levels.is_reachable(impl_item.id)\n+                                         }\n+                                         hir::ImplItemKind::Type(_) => false,\n+                                     }\n+                                 });\n \n                 if !self_contains_private &&\n                         not_private_trait &&\n@@ -714,12 +739,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n \n                     match *trait_ref {\n                         None => {\n-                            for impl_item in impl_items {\n+                            for &impl_item_id in impl_item_ids {\n                                 // This is where we choose whether to walk down\n                                 // further into the impl to check its items. We\n                                 // should only walk into public items so that we\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n+                                let impl_item = self.tcx.map.impl_item(impl_item_id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n@@ -751,7 +777,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                             intravisit::walk_path(self, &tr.path);\n \n                             // Those in 3. are warned with this call.\n-                            for impl_item in impl_items {\n+                            for &impl_item_id in impl_item_ids {\n+                                let impl_item = self.tcx.map.impl_item(impl_item_id);\n                                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n                                     self.visit_ty(ty);\n                                 }\n@@ -762,7 +789,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                     // impl Public<Private> { ... }. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for impl_item in impl_items {\n+                    for &impl_item_id in impl_item_ids {\n+                        let impl_item = self.tcx.map.impl_item(impl_item_id);\n                         match impl_item.node {\n                             hir::ImplItemKind::Const(..) => {\n                                 if self.item_is_public(&impl_item.id, &impl_item.vis) {\n@@ -1086,12 +1114,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n-            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_item_ids) => {\n                 let ty_vis = self.ty_visibility(ty);\n                 check.required_visibility = ty_vis;\n                 check.visit_generics(generics);\n \n-                for impl_item in impl_items {\n+                for &impl_item_id in impl_item_ids {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_id);\n                     let impl_item_vis =\n                         ty::Visibility::from_hir(&impl_item.vis, item.id, self.tcx);\n                     check.required_visibility = min(impl_item_vis, ty_vis);\n@@ -1100,16 +1129,21 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n-            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_item_ids) => {\n                 let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n                 check.required_visibility = vis;\n                 check.visit_generics(generics);\n-                for impl_item in impl_items {\n+                for &impl_item_id in impl_item_ids {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_id);\n                     check.visit_impl_item(impl_item);\n                 }\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+        // handled in `visit_item` above\n+    }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "8245b0cf7f53cfed4d1174e666e98a210f210af1", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -189,7 +189,7 @@\n //! regardless of whether it is actually needed or not.\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n@@ -308,7 +308,7 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             output: &mut roots,\n         };\n \n-        scx.tcx().map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        scx.tcx().map.krate().visit_all_item_likes(&mut visitor);\n     }\n \n     roots\n@@ -1031,7 +1031,7 @@ struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n     output: &'b mut Vec<TransItem<'tcx>>,\n }\n \n-impl<'b, 'a, 'v> Visitor<'v> for RootCollector<'b, 'a, 'v> {\n+impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemExternCrate(..) |\n@@ -1089,8 +1089,6 @@ impl<'b, 'a, 'v> Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 }\n             }\n         }\n-\n-        intravisit::walk_item(self, item)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n@@ -1125,8 +1123,6 @@ impl<'b, 'a, 'v> Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             }\n             _ => { /* Nothing to do here */ }\n         }\n-\n-        intravisit::walk_impl_item(self, ii)\n     }\n }\n \n@@ -1151,9 +1147,11 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n-                let overridden_methods: FxHashSet<_> = items.iter()\n-                                                            .map(|item| item.name)\n-                                                            .collect();\n+                let overridden_methods: FxHashSet<_> =\n+                    items.iter()\n+                         .map(|&id| tcx.map.impl_item(id))\n+                         .map(|item| item.name)\n+                         .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.name) {\n                         continue;"}, {"sha": "6093e45e5a21ec304f434f9ed7099428f7557cfa", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -460,6 +460,9 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                     _ => {}\n                 }\n             }\n+\n+            fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+            }\n         }\n         ccx.tcx.map.krate().visit_all_item_likes(&mut Visitor {\n             map: &ccx.tcx.map,"}, {"sha": "e8ebc2eee63dc9a1964cd03b9f4abfd6b18fecc9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -530,6 +530,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_body(self.ccx, i);\n     }\n+\n+    fn visit_impl_item(&mut self, _item: &'tcx hir::ImplItem) {\n+        // done as part of `visit_item` above\n+    }\n }\n \n pub fn check_wf_new(ccx: &CrateCtxt) -> CompileResult {\n@@ -811,15 +815,15 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                             it.id);\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n-      hir::ItemImpl(.., ref impl_items) => {\n+      hir::ItemImpl(.., ref impl_item_ids) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n           if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n               check_impl_items_against_trait(ccx,\n                                              it.span,\n                                              impl_def_id,\n                                              impl_trait_ref,\n-                                             impl_items);\n+                                             impl_item_ids);\n               let trait_def_id = impl_trait_ref.def_id;\n               check_on_unimplemented(ccx, trait_def_id, it);\n           }\n@@ -881,10 +885,11 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(ref decl, .., ref body) => {\n         check_bare_fn(ccx, &decl, &body, it.id, it.span);\n       }\n-      hir::ItemImpl(.., ref impl_items) => {\n+      hir::ItemImpl(.., ref impl_item_ids) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n-        for impl_item in impl_items {\n+        for &impl_item_id in impl_item_ids {\n+            let impl_item = ccx.tcx.map.impl_item(impl_item_id);\n             match impl_item.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n                     check_const(ccx, &expr, impl_item.id)\n@@ -1021,7 +1026,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n-                                            impl_items: &[hir::ImplItem]) {\n+                                            impl_item_ids: &[hir::ImplItemId]) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n     // isn't populated for such impls.\n@@ -1032,9 +1037,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n+    let impl_items = || impl_item_ids.iter().map(|&id| ccx.tcx.map.impl_item(id));\n+\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n-    for impl_item in impl_items {\n+    for impl_item in impl_items() {\n         let ty_impl_item = tcx.associated_item(tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| ac.name == ty_impl_item.name);"}, {"sha": "b4a10c52270e2f9f5560ec8e02e1a1668dcfa1d0", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -58,6 +58,9 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "31bd7b0f19b3ca44d56ff59e9993d1a1527c89fb", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -57,6 +57,9 @@ impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx,\n             self.cc.check_implementation(item)\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {"}, {"sha": "a507077bef77e21eb27b11619cc8d5d40ee625a3", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -384,4 +384,8 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.check_item(item);\n     }\n+\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "c66a76ebba0226599444f5c3fca0e211db864dcb", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -199,4 +199,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n             _ => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "6d5de8f250655e614603578355481a5ed210bc34", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -106,4 +106,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n             _ => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "658a655c2deccc0276b440ef1892a8454b33bf7d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -149,6 +149,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_ty(self, ty);\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+        // handled in `visit_item` above; we may want to break this out later\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -727,7 +731,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                       ref generics,\n                       ref opt_trait_ref,\n                       ref selfty,\n-                      ref impl_items) => {\n+                      ref impl_item_ids) => {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n@@ -757,7 +761,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let mut seen_type_items = FxHashMap();\n             let mut seen_value_items = FxHashMap();\n \n-            for impl_item in impl_items {\n+            for &impl_item_id in impl_item_ids {\n+                let impl_item = tcx.map.impl_item(impl_item_id);\n                 let seen_items = match impl_item.node {\n                     hir::ImplItemKind::Type(_) => &mut seen_type_items,\n                     _                    => &mut seen_value_items,\n@@ -790,7 +795,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             }\n \n             // Convert all the associated types.\n-            for impl_item in impl_items {\n+            for &impl_item_id in impl_item_ids {\n+                let impl_item = tcx.map.impl_item(impl_item_id);\n                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n                     let type_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n                     generics_of_def_id(ccx, type_def_id);\n@@ -806,15 +812,16 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             }\n \n-            for impl_item in impl_items {\n+            for &impl_item_id in impl_item_ids {\n+                let impl_item = tcx.map.impl_item(impl_item_id);\n                 if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.id, sig, selfty,\n                                    &ty_predicates);\n                 }\n             }\n \n-            enforce_impl_lifetimes_are_constrained(ccx, generics, def_id, impl_items);\n+            enforce_impl_lifetimes_are_constrained(ccx, generics, def_id, impl_item_ids);\n         },\n         hir::ItemTrait(.., ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n@@ -2103,7 +2110,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     ast_generics: &hir::Generics,\n                                                     impl_def_id: DefId,\n-                                                    impl_items: &[hir::ImplItem])\n+                                                    impl_item_ids: &[hir::ImplItemId])\n {\n     // Every lifetime used in an associated type must be constrained.\n     let impl_ty = ccx.tcx.item_type(impl_def_id);\n@@ -2118,8 +2125,8 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ctp::identify_constrained_type_params(\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n-    let lifetimes_in_associated_types: FxHashSet<_> = impl_items.iter()\n-        .map(|item|  ccx.tcx.map.local_def_id(item.id))\n+    let lifetimes_in_associated_types: FxHashSet<_> = impl_item_ids.iter()\n+        .map(|item_id|  ccx.tcx.map.local_def_id(item_id.id))\n         .filter(|&def_id| {\n             let item = ccx.tcx.associated_item(def_id);\n             item.kind == ty::AssociatedKind::Type && item.has_value"}, {"sha": "8a0c1c68322d078c9b135610d7898745c0a1756b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -115,6 +115,9 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemDefaultImpl(..) => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n /// Is `param_id` a lifetime according to `map`?"}, {"sha": "0a3238480d9080efaf2821bf4623890f5140d448", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -257,4 +257,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemTy(..) => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "6587392e18ff3f31dfef5ed1dbae6e3a75ff5fb3", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd67eba87fc4bd634af34d170d7683397aeca3a/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3fd67eba87fc4bd634af34d170d7683397aeca3a", "patch": "@@ -502,10 +502,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.traits.push(t);\n             },\n \n-            hir::ItemImpl(unsafety, polarity, ref gen, ref tr, ref ty, ref items) => {\n+            hir::ItemImpl(unsafety, polarity, ref gen, ref tr, ref ty, ref item_ids) => {\n                 // Don't duplicate impls when inlining, we'll pick them up\n                 // regardless of where they're located.\n                 if !self.inlining {\n+                    let items = item_ids.iter()\n+                                        .map(|&id| self.cx.map.impl_item(id).clone())\n+                                        .collect();\n                     let i = Impl {\n                         unsafety: unsafety,\n                         polarity: polarity,"}]}