{"sha": "5b1b65b876b500e15de45155a04d055ff3cd126f", "node_id": "C_kwDOAAsO6NoAKDViMWI2NWI4NzZiNTAwZTE1ZGU0NTE1NWEwNGQwNTVmZjNjZDEyNmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-16T03:12:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-16T03:12:30Z"}, "message": "Auto merge of #7639 - Jarcho:whitelist_cheap_functions, r=camsteffen\n\nImprove heuristic for eagerness suggestion\n\nStill to be done:\n\n* a more complete list of cheap functions\n* a way to limit the complexity of cheap expressions\n\nchangelog: Improve heuristics for `or_fun_call` and `unnecessary_lazy_evaluations`", "tree": {"sha": "a0b6b3a4c7f0175c962cf9733cdf7b1ba67e29ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0b6b3a4c7f0175c962cf9733cdf7b1ba67e29ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b1b65b876b500e15de45155a04d055ff3cd126f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1b65b876b500e15de45155a04d055ff3cd126f", "html_url": "https://github.com/rust-lang/rust/commit/5b1b65b876b500e15de45155a04d055ff3cd126f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b1b65b876b500e15de45155a04d055ff3cd126f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0def42fd7b508edcd199859d59a8d0ffaab69607", "url": "https://api.github.com/repos/rust-lang/rust/commits/0def42fd7b508edcd199859d59a8d0ffaab69607", "html_url": "https://github.com/rust-lang/rust/commit/0def42fd7b508edcd199859d59a8d0ffaab69607"}, {"sha": "2938ffd0d94d93893ca32202cb3b6a6b69559bfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2938ffd0d94d93893ca32202cb3b6a6b69559bfb", "html_url": "https://github.com/rust-lang/rust/commit/2938ffd0d94d93893ca32202cb3b6a6b69559bfb"}], "stats": {"total": 648, "additions": 408, "deletions": 240}, "files": [{"sha": "65efbbab41a460f0ab4f9b2c84a400cbe22efeee", "filename": "clippy_lints/src/functions/too_many_lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -56,8 +56,8 @@ pub(super) fn check_fn(\n                     continue;\n                 }\n             } else {\n-                let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n-                let single_idx = line.find(\"//\").unwrap_or_else(|| line.len());\n+                let multi_idx = line.find(\"/*\").unwrap_or(line.len());\n+                let single_idx = line.find(\"//\").unwrap_or(line.len());\n                 code_in_line |= multi_idx > 0 && single_idx > 0;\n                 // Implies multi_idx is below line.len()\n                 if multi_idx < single_idx {"}, {"sha": "8ea9312c0f7075557211e94575f30d946a4fe040", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -69,7 +69,7 @@ fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -\n                         // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n                         let ty_str = ty.to_string();\n                         let start = ty_str.find('<').unwrap_or(0);\n-                        let end = ty_str.find('>').unwrap_or_else(|| ty_str.len());\n+                        let end = ty_str.find('>').unwrap_or(ty_str.len());\n                         let nb_wildcard = ty_str[start..end].split(',').count();\n                         let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n                         format!(\"{}<{}>\", elements.join(\"::\"), wildcards)"}, {"sha": "4e4653dadcafcdc1bfe926c2c9cda0a58eea697b", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -1,16 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::eager_or_lazy::is_lazyness_candidate;\n-use clippy_utils::is_trait_item;\n+use clippy_utils::eager_or_lazy::switch_to_lazy_eval;\n use clippy_utils::source::{snippet, snippet_with_applicability, snippet_with_macro_callsite};\n-use clippy_utils::ty::implements_trait;\n-use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n-use clippy_utils::{contains_return, last_path_segment, paths};\n+use clippy_utils::ty::{implements_trait, match_type};\n+use clippy_utils::{contains_return, is_trait_item, last_path_segment, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{BlockCheckMode, UnsafeSource};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym};\n use std::borrow::Cow;\n@@ -96,25 +92,10 @@ pub(super) fn check<'tcx>(\n             (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n-        if let hir::ExprKind::MethodCall(path, _, [self_arg, ..], _) = &arg.kind {\n-            if path.ident.name == sym::len {\n-                let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-\n-                match ty.kind() {\n-                    ty::Slice(_) | ty::Array(_, _) | ty::Str => return,\n-                    _ => (),\n-                }\n-\n-                if is_type_diagnostic_item(cx, ty, sym::Vec) {\n-                    return;\n-                }\n-            }\n-        }\n-\n         if_chain! {\n             if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n \n-            if is_lazyness_candidate(cx, arg);\n+            if switch_to_lazy_eval(cx, arg);\n             if !contains_return(arg);\n \n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n@@ -166,26 +147,30 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if args.len() == 2 {\n-        match args[1].kind {\n+    if let [self_arg, arg] = args {\n+        let inner_arg = if let hir::ExprKind::Block(\n+            hir::Block {\n+                stmts: [],\n+                expr: Some(expr),\n+                ..\n+            },\n+            _,\n+        ) = arg.kind\n+        {\n+            expr\n+        } else {\n+            arg\n+        };\n+        match inner_arg.kind {\n             hir::ExprKind::Call(fun, or_args) => {\n                 let or_has_args = !or_args.is_empty();\n-                if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n+                if !check_unwrap_or_default(cx, name, fun, self_arg, arg, or_has_args, expr.span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };\n-                    check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, fun_span);\n+                    check_general_case(cx, name, method_span, self_arg, arg, expr.span, fun_span);\n                 }\n             },\n             hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n-                check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n-            },\n-            hir::ExprKind::Block(block, _)\n-                if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) =>\n-            {\n-                if let Some(block_expr) = block.expr {\n-                    if let hir::ExprKind::MethodCall(..) = block_expr.kind {\n-                        check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n-                    }\n-                }\n+                check_general_case(cx, name, method_span, self_arg, arg, expr.span, None);\n             },\n             _ => (),\n         }"}, {"sha": "1e2765263c87ddb0ed920c8da8a71b74394ee0b3", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n                 return;\n             }\n \n-            if eager_or_lazy::is_eagerness_candidate(cx, body_expr) {\n+            if eager_or_lazy::switch_to_eager_eval(cx, body_expr) {\n                 let msg = if is_option {\n                     \"unnecessary closure used to substitute value for `Option::None`\"\n                 } else {"}, {"sha": "262be17f61751d495d862f8d628e13c0a0c1ae79", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -147,11 +147,7 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_expr(if_then)?;\n             let none_body = extract_body_from_expr(if_else)?;\n-            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) {\n-                \"map_or\"\n-            } else {\n-                \"map_or_else\"\n-            };\n+            let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &let_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),"}, {"sha": "c2645ac730a44322423b24e07a80930c695d50a4", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 203, "deletions": 104, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -9,128 +9,227 @@\n //!  - or-fun-call\n //!  - option-if-let-else\n \n-use crate::is_ctor_or_promotable_const_function;\n-use crate::ty::is_type_diagnostic_item;\n+use crate::ty::{all_predicates_of, is_copy};\n+use crate::visitors::is_const_evaluatable;\n use rustc_hir::def::{DefKind, Res};\n-\n-use rustc_hir::intravisit;\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-\n-use rustc_hir::{Block, Expr, ExprKind, Path, QPath};\n+use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::{def_id::DefId, Block, Expr, ExprKind, QPath, UnOp};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n-use rustc_span::sym;\n-\n-/// Is the expr pure (is it free from side-effects)?\n-/// This function is named so to stress that it isn't exhaustive and returns FNs.\n-fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Lit(..) | ExprKind::ConstBlock(..) | ExprKind::Path(..) | ExprKind::Field(..) => true,\n-        ExprKind::AddrOf(_, _, addr_of_expr) => identify_some_pure_patterns(addr_of_expr),\n-        ExprKind::Tup(tup_exprs) => tup_exprs.iter().all(identify_some_pure_patterns),\n-        ExprKind::Struct(_, fields, expr) => {\n-            fields.iter().all(|f| identify_some_pure_patterns(f.expr)) && expr.map_or(true, identify_some_pure_patterns)\n-        },\n-        ExprKind::Call(\n-            &Expr {\n-                kind:\n-                    ExprKind::Path(QPath::Resolved(\n-                        _,\n-                        Path {\n-                            res: Res::Def(DefKind::Ctor(..) | DefKind::Variant, ..),\n-                            ..\n-                        },\n-                    )),\n-                ..\n-            },\n-            args,\n-        ) => args.iter().all(identify_some_pure_patterns),\n-        ExprKind::Block(\n-            &Block {\n-                stmts,\n-                expr: Some(expr),\n-                ..\n-            },\n-            _,\n-        ) => stmts.is_empty() && identify_some_pure_patterns(expr),\n-        ExprKind::Box(..)\n-        | ExprKind::Array(..)\n-        | ExprKind::Call(..)\n-        | ExprKind::MethodCall(..)\n-        | ExprKind::Binary(..)\n-        | ExprKind::Unary(..)\n-        | ExprKind::Let(..)\n-        | ExprKind::Cast(..)\n-        | ExprKind::Type(..)\n-        | ExprKind::DropTemps(..)\n-        | ExprKind::Loop(..)\n-        | ExprKind::If(..)\n-        | ExprKind::Match(..)\n-        | ExprKind::Closure(..)\n-        | ExprKind::Block(..)\n-        | ExprKind::Assign(..)\n-        | ExprKind::AssignOp(..)\n-        | ExprKind::Index(..)\n-        | ExprKind::Break(..)\n-        | ExprKind::Continue(..)\n-        | ExprKind::Ret(..)\n-        | ExprKind::InlineAsm(..)\n-        | ExprKind::LlvmInlineAsm(..)\n-        | ExprKind::Repeat(..)\n-        | ExprKind::Yield(..)\n-        | ExprKind::Err => false,\n+use rustc_middle::ty::{self, PredicateKind};\n+use rustc_span::{sym, Symbol};\n+use std::cmp;\n+use std::ops;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+enum EagernessSuggestion {\n+    // The expression is cheap and should be evaluated eagerly\n+    Eager,\n+    // The expression may be cheap, so don't suggested lazy evaluation; or the expression may not be safe to switch to\n+    // eager evaluation.\n+    NoChange,\n+    // The expression is likely expensive and should be evaluated lazily.\n+    Lazy,\n+    // The expression cannot be placed into a closure.\n+    ForceNoChange,\n+}\n+impl ops::BitOr for EagernessSuggestion {\n+    type Output = Self;\n+    fn bitor(self, rhs: Self) -> Self {\n+        cmp::max(self, rhs)\n     }\n }\n-\n-/// Identify some potentially computationally expensive patterns.\n-/// This function is named so to stress that its implementation is non-exhaustive.\n-/// It returns FNs and FPs.\n-fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    // Searches an expression for method calls or function calls that aren't ctors\n-    struct FunCallFinder<'a, 'tcx> {\n-        cx: &'a LateContext<'tcx>,\n-        found: bool,\n+impl ops::BitOrAssign for EagernessSuggestion {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n     }\n+}\n \n-    impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-            let call_found = match &expr.kind {\n-                // ignore enum and struct constructors\n-                ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n-                ExprKind::Index(obj, _) => {\n-                    let ty = self.cx.typeck_results().expr_ty(obj);\n-                    is_type_diagnostic_item(self.cx, ty, sym::HashMap)\n-                        || is_type_diagnostic_item(self.cx, ty, sym::BTreeMap)\n-                },\n-                ExprKind::MethodCall(..) => true,\n-                _ => false,\n-            };\n+/// Determine the eagerness of the given function call.\n+fn fn_eagerness(cx: &LateContext<'tcx>, fn_id: DefId, name: Symbol, args: &'tcx [Expr<'_>]) -> EagernessSuggestion {\n+    use EagernessSuggestion::{Eager, Lazy, NoChange};\n+    let name = &*name.as_str();\n \n-            if call_found {\n-                self.found |= true;\n-            }\n+    let ty = match cx.tcx.impl_of_method(fn_id) {\n+        Some(id) => cx.tcx.type_of(id),\n+        None => return Lazy,\n+    };\n \n-            if !self.found {\n-                intravisit::walk_expr(self, expr);\n+    if (name.starts_with(\"as_\") || name == \"len\" || name == \"is_empty\") && args.len() == 1 {\n+        if matches!(\n+            cx.tcx.crate_name(fn_id.krate),\n+            sym::std | sym::core | sym::alloc | sym::proc_macro\n+        ) {\n+            Eager\n+        } else {\n+            NoChange\n+        }\n+    } else if let ty::Adt(def, subs) = ty.kind() {\n+        // Types where the only fields are generic types (or references to) with no trait bounds other\n+        // than marker traits.\n+        // Due to the limited operations on these types functions should be fairly cheap.\n+        if def\n+            .variants\n+            .iter()\n+            .flat_map(|v| v.fields.iter())\n+            .any(|x| matches!(cx.tcx.type_of(x.did).peel_refs().kind(), ty::Param(_)))\n+            && all_predicates_of(cx.tcx, fn_id).all(|(pred, _)| match pred.kind().skip_binder() {\n+                PredicateKind::Trait(pred) => cx.tcx.trait_def(pred.trait_ref.def_id).is_marker,\n+                _ => true,\n+            })\n+            && subs.types().all(|x| matches!(x.peel_refs().kind(), ty::Param(_)))\n+        {\n+            // Limit the function to either `(self) -> bool` or `(&self) -> bool`\n+            match &**cx.tcx.fn_sig(fn_id).skip_binder().inputs_and_output {\n+                [arg, res] if !arg.is_mutable_ptr() && arg.peel_refs() == ty && res.is_bool() => NoChange,\n+                _ => Lazy,\n             }\n+        } else {\n+            Lazy\n         }\n+    } else {\n+        Lazy\n+    }\n+}\n \n+#[allow(clippy::too_many_lines)]\n+fn expr_eagerness(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessSuggestion {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        eagerness: EagernessSuggestion,\n+    }\n+\n+    impl<'cx, 'tcx> Visitor<'tcx> for V<'cx, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n             NestedVisitorMap::None\n         }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            use EagernessSuggestion::{ForceNoChange, Lazy, NoChange};\n+            if self.eagerness == ForceNoChange {\n+                return;\n+            }\n+            match e.kind {\n+                ExprKind::Call(\n+                    &Expr {\n+                        kind: ExprKind::Path(ref path),\n+                        hir_id,\n+                        ..\n+                    },\n+                    args,\n+                ) => match self.cx.qpath_res(path, hir_id) {\n+                    Res::Def(DefKind::Ctor(..) | DefKind::Variant, _) | Res::SelfCtor(_) => (),\n+                    Res::Def(_, id) if self.cx.tcx.is_promotable_const_fn(id) => (),\n+                    // No need to walk the arguments here, `is_const_evaluatable` already did\n+                    Res::Def(..) if is_const_evaluatable(self.cx, e) => {\n+                        self.eagerness |= NoChange;\n+                        return;\n+                    },\n+                    Res::Def(_, id) => match path {\n+                        QPath::Resolved(_, p) => {\n+                            self.eagerness |= fn_eagerness(self.cx, id, p.segments.last().unwrap().ident.name, args);\n+                        },\n+                        QPath::TypeRelative(_, name) => {\n+                            self.eagerness |= fn_eagerness(self.cx, id, name.ident.name, args);\n+                        },\n+                        QPath::LangItem(..) => self.eagerness = Lazy,\n+                    },\n+                    _ => self.eagerness = Lazy,\n+                },\n+                // No need to walk the arguments here, `is_const_evaluatable` already did\n+                ExprKind::MethodCall(..) if is_const_evaluatable(self.cx, e) => {\n+                    self.eagerness |= NoChange;\n+                    return;\n+                },\n+                ExprKind::MethodCall(name, _, args, _) => {\n+                    self.eagerness |= self\n+                        .cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(Lazy, |id| fn_eagerness(self.cx, id, name.ident.name, args));\n+                },\n+                ExprKind::Index(_, e) => {\n+                    let ty = self.cx.typeck_results().expr_ty_adjusted(e);\n+                    if is_copy(self.cx, ty) && !ty.is_ref() {\n+                        self.eagerness |= NoChange;\n+                    } else {\n+                        self.eagerness = Lazy;\n+                    }\n+                },\n+\n+                // Dereferences should be cheap, but dereferencing a raw pointer earlier may not be safe.\n+                ExprKind::Unary(UnOp::Deref, e) if !self.cx.typeck_results().expr_ty(e).is_unsafe_ptr() => (),\n+                ExprKind::Unary(UnOp::Deref, _) => self.eagerness |= NoChange,\n+\n+                ExprKind::Unary(_, e)\n+                    if matches!(\n+                        self.cx.typeck_results().expr_ty(e).kind(),\n+                        ty::Bool | ty::Int(_) | ty::Uint(_),\n+                    ) => {},\n+                ExprKind::Binary(_, lhs, rhs)\n+                    if self.cx.typeck_results().expr_ty(lhs).is_primitive()\n+                        && self.cx.typeck_results().expr_ty(rhs).is_primitive() => {},\n+\n+                // Can't be moved into a closure\n+                ExprKind::Break(..)\n+                | ExprKind::Continue(_)\n+                | ExprKind::Ret(_)\n+                | ExprKind::InlineAsm(_)\n+                | ExprKind::LlvmInlineAsm(_)\n+                | ExprKind::Yield(..)\n+                | ExprKind::Err => {\n+                    self.eagerness = ForceNoChange;\n+                    return;\n+                },\n+\n+                // Memory allocation, custom operator, loop, or call to an unknown function\n+                ExprKind::Box(_)\n+                | ExprKind::Unary(..)\n+                | ExprKind::Binary(..)\n+                | ExprKind::Loop(..)\n+                | ExprKind::Call(..) => self.eagerness = Lazy,\n+\n+                ExprKind::ConstBlock(_)\n+                | ExprKind::Array(_)\n+                | ExprKind::Tup(_)\n+                | ExprKind::Lit(_)\n+                | ExprKind::Cast(..)\n+                | ExprKind::Type(..)\n+                | ExprKind::DropTemps(_)\n+                | ExprKind::Let(..)\n+                | ExprKind::If(..)\n+                | ExprKind::Match(..)\n+                | ExprKind::Closure(..)\n+                | ExprKind::Field(..)\n+                | ExprKind::Path(_)\n+                | ExprKind::AddrOf(..)\n+                | ExprKind::Struct(..)\n+                | ExprKind::Repeat(..)\n+                | ExprKind::Block(Block { stmts: [], .. }, _) => (),\n+\n+                // Assignment might be to a local defined earlier, so don't eagerly evaluate.\n+                // Blocks with multiple statements might be expensive, so don't eagerly evaluate.\n+                // TODO: Actually check if either of these are true here.\n+                ExprKind::Assign(..) | ExprKind::AssignOp(..) | ExprKind::Block(..) => self.eagerness |= NoChange,\n+            }\n+            walk_expr(self, e);\n+        }\n     }\n \n-    let mut finder = FunCallFinder { cx, found: false };\n-    finder.visit_expr(expr);\n-    finder.found\n+    let mut v = V {\n+        cx,\n+        eagerness: EagernessSuggestion::Eager,\n+    };\n+    v.visit_expr(e);\n+    v.eagerness\n }\n \n-pub fn is_eagerness_candidate<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    !identify_some_potentially_expensive_patterns(cx, expr) && identify_some_pure_patterns(expr)\n+/// Whether the given expression should be changed to evaluate eagerly\n+pub fn switch_to_eager_eval(cx: &'_ LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    expr_eagerness(cx, expr) == EagernessSuggestion::Eager\n }\n \n-pub fn is_lazyness_candidate<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    identify_some_potentially_expensive_patterns(cx, expr)\n+/// Whether the given expression should be changed to evaluate lazily\n+pub fn switch_to_lazy_eval(cx: &'_ LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    expr_eagerness(cx, expr) == EagernessSuggestion::Lazy\n }"}, {"sha": "b04d17364264a032041b2208b7225c4bd4107f0f", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -28,6 +28,7 @@ pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n /// Preferably use the diagnostic item `sym::Borrow` where possible\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n+pub const BORROW_MUT_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"BorrowMut\"];\n pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];"}, {"sha": "438c39bea0a0ea6d4648bf81ed8ffa7b615638b8", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -10,12 +10,12 @@ use rustc_hir::{TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n-use rustc_span::sym;\n-use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::DUMMY_SP;\n+use rustc_middle::ty::{self, AdtDef, IntTy, Predicate, Ty, TyCtxt, TypeFoldable, UintTy};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n+use std::iter;\n \n use crate::{match_def_path, must_use_attr};\n \n@@ -391,3 +391,16 @@ pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n         _ => false,\n     }\n }\n+\n+/// Gets an iterator over all predicates which apply to the given item.\n+pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(Predicate<'_>, Span)> {\n+    let mut next_id = Some(id);\n+    iter::from_fn(move || {\n+        next_id.take().map(|id| {\n+            let preds = tcx.predicates_of(id);\n+            next_id = preds.parent;\n+            preds.predicates.iter()\n+        })\n+    })\n+    .flatten()\n+}"}, {"sha": "823df5cb7517eaeb641da7100dce261df64544df", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -1,9 +1,11 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Expr, ExprKind, HirId, Stmt};\n+use rustc_hir::{Arm, Block, Body, BodyId, Expr, ExprKind, HirId, Stmt, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n \n /// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n /// bodies (i.e. closures) are visited.\n@@ -225,3 +227,93 @@ pub fn is_local_used(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id\n     drop(visitor);\n     is_used\n }\n+\n+/// Checks if the given expression is a constant.\n+pub fn is_const_evaluatable(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        is_const: bool,\n+    }\n+    impl<'tcx> Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if !self.is_const {\n+                return;\n+            }\n+            match e.kind {\n+                ExprKind::ConstBlock(_) => return,\n+                ExprKind::Call(\n+                    &Expr {\n+                        kind: ExprKind::Path(ref p),\n+                        hir_id,\n+                        ..\n+                    },\n+                    _,\n+                ) if self\n+                    .cx\n+                    .qpath_res(p, hir_id)\n+                    .opt_def_id()\n+                    .map_or(false, |id| self.cx.tcx.is_const_fn_raw(id)) => {},\n+                ExprKind::MethodCall(..)\n+                    if self\n+                        .cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(false, |id| self.cx.tcx.is_const_fn_raw(id)) => {},\n+                ExprKind::Binary(_, lhs, rhs)\n+                    if self.cx.typeck_results().expr_ty(lhs).peel_refs().is_primitive_ty()\n+                        && self.cx.typeck_results().expr_ty(rhs).peel_refs().is_primitive_ty() => {},\n+                ExprKind::Unary(UnOp::Deref, e) if self.cx.typeck_results().expr_ty(e).is_ref() => (),\n+                ExprKind::Unary(_, e) if self.cx.typeck_results().expr_ty(e).peel_refs().is_primitive_ty() => (),\n+                ExprKind::Index(base, _)\n+                    if matches!(\n+                        self.cx.typeck_results().expr_ty(base).peel_refs().kind(),\n+                        ty::Slice(_) | ty::Array(..)\n+                    ) => {},\n+                ExprKind::Path(ref p)\n+                    if matches!(\n+                        self.cx.qpath_res(p, e.hir_id),\n+                        Res::Def(\n+                            DefKind::Const\n+                                | DefKind::AssocConst\n+                                | DefKind::AnonConst\n+                                | DefKind::ConstParam\n+                                | DefKind::Ctor(..)\n+                                | DefKind::Fn\n+                                | DefKind::AssocFn,\n+                            _\n+                        ) | Res::SelfCtor(_)\n+                    ) => {},\n+\n+                ExprKind::AddrOf(..)\n+                | ExprKind::Array(_)\n+                | ExprKind::Block(..)\n+                | ExprKind::Cast(..)\n+                | ExprKind::DropTemps(_)\n+                | ExprKind::Field(..)\n+                | ExprKind::If(..)\n+                | ExprKind::Let(..)\n+                | ExprKind::Lit(_)\n+                | ExprKind::Match(..)\n+                | ExprKind::Repeat(..)\n+                | ExprKind::Struct(..)\n+                | ExprKind::Tup(_)\n+                | ExprKind::Type(..) => (),\n+\n+                _ => {\n+                    self.is_const = false;\n+                    return;\n+                },\n+            }\n+            walk_expr(self, e);\n+        }\n+    }\n+\n+    let mut v = V { cx, is_const: true };\n+    v.visit_expr(e);\n+    v.is_const\n+}"}, {"sha": "83f467c84002621244adf95dc5e8f848b6efb755", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -108,6 +108,7 @@ fn test_return_in_macro() {\n }\n \n mod issue6501 {\n+    #[allow(clippy::unnecessary_lazy_evaluations)]\n     fn foo(bar: Result<(), ()>) {\n         bar.unwrap_or_else(|_| {})\n     }"}, {"sha": "341caf18bd60c83f73b41ddf81bc99b9f36fd83f", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -108,6 +108,7 @@ fn test_return_in_macro() {\n }\n \n mod issue6501 {\n+    #[allow(clippy::unnecessary_lazy_evaluations)]\n     fn foo(bar: Result<(), ()>) {\n         bar.unwrap_or_else(|_| return)\n     }"}, {"sha": "c0abc2c63dde1fb33c409476a3ab4ebdaac8823d", "filename": "tests/ui/needless_return.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.stderr?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -85,109 +85,109 @@ LL |         return String::new();\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:112:32\n+  --> $DIR/needless_return.rs:113:32\n    |\n LL |         bar.unwrap_or_else(|_| return)\n    |                                ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:117:13\n+  --> $DIR/needless_return.rs:118:13\n    |\n LL |             return;\n    |             ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:119:20\n+  --> $DIR/needless_return.rs:120:20\n    |\n LL |         let _ = || return;\n    |                    ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:125:32\n+  --> $DIR/needless_return.rs:126:32\n    |\n LL |         res.unwrap_or_else(|_| return Foo)\n    |                                ^^^^^^^^^^ help: remove `return`: `Foo`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:134:5\n+  --> $DIR/needless_return.rs:135:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:138:5\n+  --> $DIR/needless_return.rs:139:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:143:9\n+  --> $DIR/needless_return.rs:144:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:145:9\n+  --> $DIR/needless_return.rs:146:9\n    |\n LL |         return false;\n    |         ^^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:151:17\n+  --> $DIR/needless_return.rs:152:17\n    |\n LL |         true => return false,\n    |                 ^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:153:13\n+  --> $DIR/needless_return.rs:154:13\n    |\n LL |             return true;\n    |             ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:160:9\n+  --> $DIR/needless_return.rs:161:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:162:16\n+  --> $DIR/needless_return.rs:163:16\n    |\n LL |     let _ = || return true;\n    |                ^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:170:5\n+  --> $DIR/needless_return.rs:171:5\n    |\n LL |     return;\n    |     ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:175:9\n+  --> $DIR/needless_return.rs:176:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:177:9\n+  --> $DIR/needless_return.rs:178:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:184:14\n+  --> $DIR/needless_return.rs:185:14\n    |\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:199:9\n+  --> $DIR/needless_return.rs:200:9\n    |\n LL |         return String::from(\"test\");\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:201:9\n+  --> $DIR/needless_return.rs:202:9\n    |\n LL |         return String::new();\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`"}, {"sha": "ce3093c542ae0b7bfad86c1c10e665db25761cfa", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -121,7 +121,7 @@ fn main() {\n \n     let s = String::new();\n     // Lint, both branches immutably borrow `s`.\n-    let _ = Some(0).map_or_else(|| s.len(), |x| s.len() + x);\n+    let _ = Some(0).map_or(s.len(), |x| s.len() + x);\n \n     let s = String::new();\n     // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`."}, {"sha": "4e64cd7cdb1d649a73edfaedf1a97bce0ac0b742", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -180,11 +180,11 @@ LL +             }\n LL ~         });\n    |\n \n-error: use Option::map_or_else instead of an if let/else\n+error: use Option::map_or instead of an if let/else\n   --> $DIR/option_if_let_else.rs:151:13\n    |\n LL |     let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or_else(|| s.len(), |x| s.len() + x)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or(s.len(), |x| s.len() + x)`\n \n error: use Option::map_or instead of an if let/else\n   --> $DIR/option_if_let_else.rs:155:13"}, {"sha": "d6d6ab49734e782ba7887824e86d41a8f29bcc22", "filename": "tests/ui/or_fun_call.fixed", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.fixed?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -43,7 +43,7 @@ fn or_fun_call() {\n     with_enum.unwrap_or(Enum::A(5));\n \n     let with_const_fn = Some(Duration::from_secs(1));\n-    with_const_fn.unwrap_or_else(|| Duration::from_secs(5));\n+    with_const_fn.unwrap_or(Duration::from_secs(5));\n \n     let with_constructor = Some(vec![1]);\n     with_constructor.unwrap_or_else(make);\n@@ -79,16 +79,16 @@ fn or_fun_call() {\n     without_default.unwrap_or_else(Foo::new);\n \n     let mut map = HashMap::<u64, String>::new();\n-    map.entry(42).or_insert_with(String::new);\n+    map.entry(42).or_insert(String::new());\n \n     let mut map_vec = HashMap::<u64, Vec<i32>>::new();\n-    map_vec.entry(42).or_insert_with(Vec::new);\n+    map_vec.entry(42).or_insert(vec![]);\n \n     let mut btree = BTreeMap::<u64, String>::new();\n-    btree.entry(42).or_insert_with(String::new);\n+    btree.entry(42).or_insert(String::new());\n \n     let mut btree_vec = BTreeMap::<u64, Vec<i32>>::new();\n-    btree_vec.entry(42).or_insert_with(Vec::new);\n+    btree_vec.entry(42).or_insert(vec![]);\n \n     let stringy = Some(String::from(\"\"));\n     let _ = stringy.unwrap_or_else(|| \"\".to_owned());\n@@ -129,7 +129,7 @@ fn test_or_with_ctors() {\n \n     let b = \"b\".to_string();\n     let _ = Some(Bar(\"a\".to_string(), Duration::from_secs(1)))\n-        .or_else(|| Some(Bar(b, Duration::from_secs(2))));\n+        .or(Some(Bar(b, Duration::from_secs(2))));\n \n     let vec = vec![\"foo\"];\n     let _ = opt.ok_or(vec.len());\n@@ -155,16 +155,24 @@ fn f() -> Option<()> {\n }\n \n mod issue6675 {\n+    unsafe fn ptr_to_ref<'a, T>(p: *const T) -> &'a T {\n+        #[allow(unused)]\n+        let x = vec![0; 1000]; // future-proofing, make this function expensive.\n+        &*p\n+    }\n+\n     unsafe fn foo() {\n-        let mut s = \"test\".to_owned();\n-        None.unwrap_or_else(|| s.as_mut_vec());\n+        let s = \"test\".to_owned();\n+        let s = &s as *const _;\n+        None.unwrap_or_else(|| ptr_to_ref(s));\n     }\n \n     fn bar() {\n-        let mut s = \"test\".to_owned();\n-        None.unwrap_or_else(|| unsafe { s.as_mut_vec() });\n+        let s = \"test\".to_owned();\n+        let s = &s as *const _;\n+        None.unwrap_or_else(|| unsafe { ptr_to_ref(s) });\n         #[rustfmt::skip]\n-        None.unwrap_or_else(|| unsafe { s.as_mut_vec() });\n+        None.unwrap_or_else(|| unsafe { ptr_to_ref(s) });\n     }\n }\n "}, {"sha": "8eadc6ce3b47acace2c3fcf4cea29fd2db831b92", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -155,16 +155,24 @@ fn f() -> Option<()> {\n }\n \n mod issue6675 {\n+    unsafe fn ptr_to_ref<'a, T>(p: *const T) -> &'a T {\n+        #[allow(unused)]\n+        let x = vec![0; 1000]; // future-proofing, make this function expensive.\n+        &*p\n+    }\n+\n     unsafe fn foo() {\n-        let mut s = \"test\".to_owned();\n-        None.unwrap_or(s.as_mut_vec());\n+        let s = \"test\".to_owned();\n+        let s = &s as *const _;\n+        None.unwrap_or(ptr_to_ref(s));\n     }\n \n     fn bar() {\n-        let mut s = \"test\".to_owned();\n-        None.unwrap_or(unsafe { s.as_mut_vec() });\n+        let s = \"test\".to_owned();\n+        let s = &s as *const _;\n+        None.unwrap_or(unsafe { ptr_to_ref(s) });\n         #[rustfmt::skip]\n-        None.unwrap_or( unsafe { s.as_mut_vec() }    );\n+        None.unwrap_or( unsafe { ptr_to_ref(s) }    );\n     }\n }\n "}, {"sha": "9d0c42b10c27f500eaa0469e43d1d1bcbfb0ae65", "filename": "tests/ui/or_fun_call.stderr", "status": "modified", "additions": 12, "deletions": 48, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b1b65b876b500e15de45155a04d055ff3cd126f/tests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.stderr?ref=5b1b65b876b500e15de45155a04d055ff3cd126f", "patch": "@@ -1,16 +1,10 @@\n-error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:46:19\n-   |\n-LL |     with_const_fn.unwrap_or(Duration::from_secs(5));\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Duration::from_secs(5))`\n-   |\n-   = note: `-D clippy::or-fun-call` implied by `-D warnings`\n-\n error: use of `unwrap_or` followed by a function call\n   --> $DIR/or_fun_call.rs:49:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n+   |\n+   = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n   --> $DIR/or_fun_call.rs:52:5\n@@ -72,30 +66,6 @@ error: use of `unwrap_or` followed by a function call\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n-error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:82:19\n-   |\n-LL |     map.entry(42).or_insert(String::new());\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n-\n-error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:85:23\n-   |\n-LL |     map_vec.entry(42).or_insert(vec![]);\n-   |                       ^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(Vec::new)`\n-\n-error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:88:21\n-   |\n-LL |     btree.entry(42).or_insert(String::new());\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n-\n-error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:91:25\n-   |\n-LL |     btree_vec.entry(42).or_insert(vec![]);\n-   |                         ^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(Vec::new)`\n-\n error: use of `unwrap_or` followed by a function call\n   --> $DIR/or_fun_call.rs:94:21\n    |\n@@ -120,29 +90,23 @@ error: use of `or` followed by a function call\n LL |     let _ = Some(\"a\".to_string()).or(Some(\"b\".to_string()));\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(\"b\".to_string()))`\n \n-error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:132:10\n-   |\n-LL |         .or(Some(Bar(b, Duration::from_secs(2))));\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(Bar(b, Duration::from_secs(2))))`\n-\n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:160:14\n+  --> $DIR/or_fun_call.rs:167:14\n    |\n-LL |         None.unwrap_or(s.as_mut_vec());\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| s.as_mut_vec())`\n+LL |         None.unwrap_or(ptr_to_ref(s));\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| ptr_to_ref(s))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:165:14\n+  --> $DIR/or_fun_call.rs:173:14\n    |\n-LL |         None.unwrap_or(unsafe { s.as_mut_vec() });\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| unsafe { s.as_mut_vec() })`\n+LL |         None.unwrap_or(unsafe { ptr_to_ref(s) });\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| unsafe { ptr_to_ref(s) })`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:167:14\n+  --> $DIR/or_fun_call.rs:175:14\n    |\n-LL |         None.unwrap_or( unsafe { s.as_mut_vec() }    );\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| unsafe { s.as_mut_vec() })`\n+LL |         None.unwrap_or( unsafe { ptr_to_ref(s) }    );\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| unsafe { ptr_to_ref(s) })`\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 18 previous errors\n "}]}