{"sha": "dfdb72dbbec1a26010b9222db1607e323bb33699", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZGI3MmRiYmVjMWEyNjAxMGI5MjIyZGIxNjA3ZTMyM2JiMzM2OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-23T10:04:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-23T10:04:39Z"}, "message": "auto merge of #7934 : sfackler/rust/smallintset, r=alexcrichton\n\nSmallIntSet is equivalent to BitvSet but with 64 times the memory\r\noverhead. There's no reason for it to exist.\r\n\r\nSmallIntSet's overhead should really only be 8 times, but for some\r\nreason, `sys::size_of::<Option<()>>() == 8`, not 1.", "tree": {"sha": "86c4ef5befd3b9015c7b1d0273e8bc6f7c208f02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86c4ef5befd3b9015c7b1d0273e8bc6f7c208f02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfdb72dbbec1a26010b9222db1607e323bb33699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfdb72dbbec1a26010b9222db1607e323bb33699", "html_url": "https://github.com/rust-lang/rust/commit/dfdb72dbbec1a26010b9222db1607e323bb33699", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfdb72dbbec1a26010b9222db1607e323bb33699/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a5d1a1b81ccb839b44c9251d9ffad2838179f1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a5d1a1b81ccb839b44c9251d9ffad2838179f1f", "html_url": "https://github.com/rust-lang/rust/commit/0a5d1a1b81ccb839b44c9251d9ffad2838179f1f"}, {"sha": "8eb6d2d8296fb91b91c50c2e1d127a69a57be714", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb6d2d8296fb91b91c50c2e1d127a69a57be714", "html_url": "https://github.com/rust-lang/rust/commit/8eb6d2d8296fb91b91c50c2e1d127a69a57be714"}], "stats": {"total": 369, "additions": 0, "deletions": 369}, "files": [{"sha": "bd78f41ddf51337ce1cb07cb187716e5ec7915ad", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/dfdb72dbbec1a26010b9222db1607e323bb33699/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfdb72dbbec1a26010b9222db1607e323bb33699/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=dfdb72dbbec1a26010b9222db1607e323bb33699", "patch": "@@ -15,8 +15,6 @@\n \n #[allow(missing_doc)];\n \n-\n-use std::cmp;\n use std::iterator::{Iterator, IteratorUtil, EnumerateIterator, FilterMapIterator, InvertIterator};\n use std::uint;\n use std::util::replace;\n@@ -309,155 +307,6 @@ double_ended_iterator!(impl SmallIntMapMutIterator -> (uint, &'self mut T), get_\n pub type SmallIntMapMutRevIterator<'self, T> = InvertIterator<(uint, &'self mut T),\n                                                               SmallIntMapMutIterator<'self, T>>;\n \n-\n-/// A set implemented on top of the SmallIntMap type. This set is always a set\n-/// of integers, and the space requirements are on the order of the highest\n-/// valued integer in the set.\n-pub struct SmallIntSet {\n-    priv map: SmallIntMap<()>\n-}\n-\n-impl Container for SmallIntSet {\n-    /// Return the number of elements in the map\n-    fn len(&self) -> uint {\n-        self.map.len()\n-    }\n-\n-    /// Return true if the map contains no elements\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-impl Mutable for SmallIntSet {\n-    /// Clear the map, removing all key-value pairs.\n-    fn clear(&mut self) { self.map.clear() }\n-}\n-\n-impl Set<uint> for SmallIntSet {\n-    /// Return true if the set contains a value\n-    fn contains(&self, value: &uint) -> bool { self.map.contains_key(value) }\n-\n-    /// Return true if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty uintersection.\n-    fn is_disjoint(&self, other: &SmallIntSet) -> bool {\n-        for self.each |v| { if other.contains(v) { return false } }\n-        true\n-    }\n-\n-    /// Return true if the set is a subset of another\n-    fn is_subset(&self, other: &SmallIntSet) -> bool {\n-        for self.each |v| { if !other.contains(v) { return false } }\n-        true\n-    }\n-\n-    /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &SmallIntSet) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Visit the values representing the difference\n-    fn difference(&self, other: &SmallIntSet, f: &fn(&uint) -> bool) -> bool {\n-        self.each(|v| other.contains(v) || f(v))\n-    }\n-\n-    /// Visit the values representing the symmetric difference\n-    fn symmetric_difference(&self,\n-                            other: &SmallIntSet,\n-                            f: &fn(&uint) -> bool) -> bool {\n-        let len = cmp::max(self.map.v.len() ,other.map.v.len());\n-\n-        for uint::range(0, len) |i| {\n-            if self.contains(&i) ^ other.contains(&i) {\n-                if !f(&i) { return false; }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /// Visit the values representing the uintersection\n-    fn intersection(&self, other: &SmallIntSet, f: &fn(&uint) -> bool) -> bool {\n-        self.each(|v| !other.contains(v) || f(v))\n-    }\n-\n-    /// Visit the values representing the union\n-    fn union(&self, other: &SmallIntSet, f: &fn(&uint) -> bool) -> bool {\n-        let len = cmp::max(self.map.v.len() ,other.map.v.len());\n-\n-        for uint::range(0, len) |i| {\n-            if self.contains(&i) || other.contains(&i) {\n-                if !f(&i) { return false; }\n-            }\n-        }\n-        return true;\n-    }\n-}\n-\n-impl MutableSet<uint> for SmallIntSet {\n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    fn insert(&mut self, value: uint) -> bool { self.map.insert(value, ()) }\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    fn remove(&mut self, value: &uint) -> bool { self.map.remove(value) }\n-}\n-\n-impl SmallIntSet {\n-    /// Create an empty SmallIntSet\n-    pub fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }\n-\n-    /// Visit all values in order\n-    pub fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n-\n-    /// An iterator visiting all set members in ascending order.\n-    /// Iterator element type is uint\n-    pub fn iter<'r>(&'r self) -> SmallIntSetIterator<'r> {\n-        SmallIntSetIterator {\n-            iter: self.map.iter()\n-        }\n-    }\n-\n-    /// An iterator visiting all set members in descending order.\n-    /// Iterator element type is uint\n-    pub fn rev_iter<'r>(&'r mut self) -> SmallIntSetRevIterator<'r> {\n-        self.iter().invert()\n-    }\n-\n-}\n-\n-pub struct SmallIntSetIterator<'self> {\n-    priv iter: SmallIntMapIterator<'self, ()>\n-}\n-\n-impl<'self> Iterator<uint> for SmallIntSetIterator<'self> {\n-    #[inline]\n-    fn next(&mut self) -> Option<uint> {\n-        let next_opt = self.iter.next();\n-        match next_opt {\n-            None => { None }\n-            Some((idx, _)) => { Some(idx) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<'self> DoubleEndedIterator<uint> for SmallIntSetIterator<'self> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<uint> {\n-        let next_opt = self.iter.next_back();\n-        match next_opt {\n-            None => { None }\n-            Some((idx, _)) => { Some(idx) }\n-        }\n-    }\n-}\n-\n-pub type SmallIntSetRevIterator<'self> = InvertIterator<uint, SmallIntSetIterator<'self>>;\n-\n-\n #[cfg(test)]\n mod test_map {\n \n@@ -732,221 +581,3 @@ mod bench {\n         find_seq_n(10_000, &mut m, bh);\n     }\n }\n-\n-#[cfg(test)]\n-mod test_set {\n-\n-    use super::SmallIntSet;\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = SmallIntSet::new();\n-        let mut ys = SmallIntSet::new();\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5));\n-        assert!(ys.insert(11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(7));\n-        assert!(xs.insert(19));\n-        assert!(xs.insert(4));\n-        assert!(ys.insert(2));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(ys.insert(7));\n-        assert!(!xs.is_disjoint(&ys));\n-        assert!(!ys.is_disjoint(&xs));\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = SmallIntSet::new();\n-        assert!(a.insert(0));\n-        assert!(a.insert(5));\n-        assert!(a.insert(11));\n-        assert!(a.insert(7));\n-\n-        let mut b = SmallIntSet::new();\n-        assert!(b.insert(0));\n-        assert!(b.insert(7));\n-        assert!(b.insert(19));\n-        assert!(b.insert(250));\n-        assert!(b.insert(11));\n-        assert!(b.insert(200));\n-\n-        assert!(!a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(!b.is_superset(&a));\n-\n-        assert!(b.insert(5));\n-\n-        assert!(a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(b.is_superset(&a));\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        let mut a = SmallIntSet::new();\n-        let mut b = SmallIntSet::new();\n-\n-        assert!(a.insert(11));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(77));\n-        assert!(a.insert(103));\n-        assert!(a.insert(5));\n-\n-        assert!(b.insert(2));\n-        assert!(b.insert(11));\n-        assert!(b.insert(77));\n-        assert!(b.insert(5));\n-        assert!(b.insert(3));\n-\n-        let mut i = 0;\n-        let expected = [3, 5, 11, 77];\n-        for a.intersection(&b) |x| {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        let mut a = SmallIntSet::new();\n-        let mut b = SmallIntSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-\n-        let mut i = 0;\n-        let expected = [1, 5, 11];\n-        for a.difference(&b) |x| {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        let mut a = SmallIntSet::new();\n-        let mut b = SmallIntSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-        assert!(b.insert(14));\n-        assert!(b.insert(22));\n-\n-        let mut i = 0;\n-        let expected = [1, 5, 11, 14, 22];\n-        for a.symmetric_difference(&b) |x| {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        let mut a = SmallIntSet::new();\n-        let mut b = SmallIntSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-        assert!(a.insert(16));\n-        assert!(a.insert(19));\n-        assert!(a.insert(24));\n-\n-        assert!(b.insert(1));\n-        assert!(b.insert(5));\n-        assert!(b.insert(9));\n-        assert!(b.insert(13));\n-        assert!(b.insert(19));\n-\n-        let mut i = 0;\n-        let expected = [1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        for a.union(&b) |x| {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let mut a = SmallIntSet::new();\n-\n-        assert!(a.insert(0));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(6));\n-        assert!(a.insert(10));\n-\n-        let mut it = a.iter();\n-        assert_eq!(it.size_hint(), (0, Some(11)));\n-        assert_eq!(it.next().unwrap(), 0);\n-        assert_eq!(it.size_hint(), (0, Some(10)));\n-        assert_eq!(it.next().unwrap(), 1);\n-        assert_eq!(it.size_hint(), (0, Some(9)));\n-        assert_eq!(it.next().unwrap(), 3);\n-        assert_eq!(it.size_hint(), (0, Some(7)));\n-        assert_eq!(it.next().unwrap(), 6);\n-        assert_eq!(it.size_hint(), (0, Some(4)));\n-        assert_eq!(it.next().unwrap(), 10);\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_iterator_size_hints() {\n-        let mut a = SmallIntSet::new();\n-\n-        assert!(a.insert(0));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(6));\n-        assert!(a.insert(10));\n-\n-        assert_eq!(a.iter().size_hint(), (0, Some(11)));\n-        assert_eq!(a.rev_iter().size_hint(), (0, Some(11)));\n-    }\n-\n-    #[test]\n-    fn test_rev_iterator() {\n-       let mut a = SmallIntSet::new();\n-\n-        assert!(a.insert(0));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(6));\n-        assert!(a.insert(10));\n-\n-        let mut it = a.rev_iter();\n-        assert_eq!(it.next().unwrap(), 10);\n-        assert_eq!(it.next().unwrap(), 6);\n-        assert_eq!(it.next().unwrap(), 3);\n-        assert_eq!(it.next().unwrap(), 1);\n-        assert_eq!(it.next().unwrap(), 0);\n-        assert!(it.next().is_none());\n-    }\n-}"}]}