{"sha": "c3618c8b2e87d58fc5e8f18f5a2f8801e29c01e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNjE4YzhiMmU4N2Q1OGZjNWU4ZjE4ZjVhMmY4ODAxZTI5YzAxZTc=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-07-26T20:29:50Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-08-01T15:41:32Z"}, "message": "Special-case `Box` in `rustc_mir::borrow_check`.\n\nThis should address issue 45696.\n\nSince we know dropping a box will not access any `&mut` or `&`\nreferences, it is safe to model its destructor as only touching the\ncontents *owned* by the box.\n\nNote: At some point we may want to generalize this machinery to other\nreference and collection types that are \"pure\" in the same sense as\nbox. If we add a `&move` reference type, it would probably also fall\ninto this branch of code. But for the short term, we will be\nconservative and restrict this change to `Box<T>` alone.\n\nThe code works by recursively descending a deref of the `Box`. We\nprevent `visit_terminator_drop` infinite-loop (which can arise in a\nvery obscure scenario) via a linked-list of seen types.\n\nNote: A similar style stack-only linked-list definition can be found\nin `rustc_mir::borrow_check::places_conflict`. It might be good at\nsome point in the future to unify the two types and put the resulting\ndefinition into `librustc_data_structures/`.\n\n----\n\nOne final note: Review feedback led to significant simplification of\nlogic here.\n\nDuring review, eddyb RalfJung and I uncovered the heart of why I\nneeded a so-called \"step 2\" aka the Shallow Write to the Deref of the\nbox. It was because the `visit_terminator_drop`, in its base case,\nwill not emit any write at all (shallow or deep) to a place unless\nthat place has a need_drop.\n\nSo I was encoding a Shallow Write by hand for a `Box<T>`, as a\nseparate step from recursively descending through `*a_box` (which was\nat the time known as \"step 1\"; it is now the *only* step, apart from\nthe change to the base case for `visit_terminator_drop` that this\ncommit now has encoded).\n\neddyb aruged that *something* should be emitting some sort of write in\nthe base case here (even a shallow one), of the dropped place, since\nby analogy we also emit a write when you *move* a place. That led\nto the revision here in this commit.\n\n * (Its possible that this desired write should be attached in some\n   manner to StorageDead instead of Drop. But in this PR, I tried to\n   leave the StorageDead logic alone and focus my attention solely on\n   how Drop(x) is modelled in MIR-borrowck.)", "tree": {"sha": "e23dfb306c5069d26b4c3719a177472293fc01aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e23dfb306c5069d26b4c3719a177472293fc01aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3618c8b2e87d58fc5e8f18f5a2f8801e29c01e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3618c8b2e87d58fc5e8f18f5a2f8801e29c01e7", "html_url": "https://github.com/rust-lang/rust/commit/c3618c8b2e87d58fc5e8f18f5a2f8801e29c01e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3618c8b2e87d58fc5e8f18f5a2f8801e29c01e7/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11f812aa7d1df09724f94c2b095f6dbfd367da17", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f812aa7d1df09724f94c2b095f6dbfd367da17", "html_url": "https://github.com/rust-lang/rust/commit/11f812aa7d1df09724f94c2b095f6dbfd367da17"}], "stats": {"total": 151, "additions": 146, "deletions": 5}, "files": [{"sha": "4596c7be1c557b728402a4e23b4420225220f4a6", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 146, "deletions": 5, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c3618c8b2e87d58fc5e8f18f5a2f8801e29c01e7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3618c8b2e87d58fc5e8f18f5a2f8801e29c01e7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c3618c8b2e87d58fc5e8f18f5a2f8801e29c01e7", "patch": "@@ -22,7 +22,7 @@ use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Pla\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, ParamEnv, TyCtxt};\n+use rustc::ty::{self, ParamEnv, TyCtxt, Ty};\n \n use rustc_errors::{Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::graph::dominators::Dominators;\n@@ -598,7 +598,12 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // that is useful later.\n                 let drop_place_ty = gcx.lift(&drop_place_ty).unwrap();\n \n-                self.visit_terminator_drop(loc, term, flow_state, drop_place, drop_place_ty, span);\n+                debug!(\"visit_terminator_drop \\\n+                        loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n+                       loc, term, drop_place, drop_place_ty, span);\n+\n+                self.visit_terminator_drop(\n+                    loc, term, flow_state, drop_place, drop_place_ty, span, SeenTy(None));\n             }\n             TerminatorKind::DropAndReplace {\n                 location: ref drop_place,\n@@ -832,6 +837,35 @@ impl InitializationRequiringAction {\n     }\n }\n \n+/// A simple linked-list threaded up the stack of recursive calls in `visit_terminator_drop`.\n+#[derive(Copy, Clone, Debug)]\n+struct SeenTy<'a, 'gcx: 'a>(Option<(Ty<'gcx>, &'a SeenTy<'a, 'gcx>)>);\n+\n+impl<'a, 'gcx> SeenTy<'a, 'gcx> {\n+    /// Return a new list with `ty` prepended to the front of `self`.\n+    fn cons(&'a self, ty: Ty<'gcx>) -> Self {\n+        SeenTy(Some((ty, self)))\n+    }\n+\n+    /// True if and only if `ty` occurs on the linked list `self`.\n+    fn have_seen(self, ty: Ty) -> bool {\n+        let mut this = self.0;\n+        loop {\n+            match this {\n+                None => return false,\n+                Some((seen_ty, recur)) => {\n+                    if seen_ty == ty {\n+                        return true;\n+                    } else {\n+                        this = recur.0;\n+                        continue;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Invokes `access_place` as appropriate for dropping the value\n     /// at `drop_place`. Note that the *actual* `Drop` in the MIR is\n@@ -847,14 +881,57 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_place: &Place<'tcx>,\n         erased_drop_place_ty: ty::Ty<'gcx>,\n         span: Span,\n+        prev_seen: SeenTy<'_, 'gcx>,\n     ) {\n+        if prev_seen.have_seen(erased_drop_place_ty) {\n+            // if we have directly seen the input ty `T`, then we must\n+            // have had some *direct* ownership loop between `T` and\n+            // some directly-owned (as in, actually traversed by\n+            // recursive calls below) part that is also of type `T`.\n+            //\n+            // Note: in *all* such cases, the data in question cannot\n+            // be constructed (nor destructed) in finite time/space.\n+            //\n+            // Proper examples, some of which are statically rejected:\n+            //\n+            // * `struct A { field: A, ... }`:\n+            //   statically rejected as infinite size\n+            //\n+            // * `type B = (B, ...);`:\n+            //   statically rejected as cyclic\n+            //\n+            // * `struct C { field: Box<C>, ... }`\n+            // * `struct D { field: Box<(D, D)>, ... }`:\n+            //   *accepted*, though impossible to construct\n+            //\n+            // Here is *NOT* an example:\n+            // * `struct Z { field: Option<Box<Z>>, ... }`:\n+            //   Here, the type is both representable in finite space (due to the boxed indirection)\n+            //   and constructable in finite time (since the recursion can bottom out with `None`).\n+            //   This is an obvious instance of something the compiler must accept.\n+            //\n+            // Since some of the above impossible cases like `C` and\n+            // `D` are accepted by the compiler, we must take care not\n+            // to infinite-loop while processing them. But since such\n+            // cases cannot actually arise, it is sound for us to just\n+            // skip them during drop. If the developer uses unsafe\n+            // code to construct them, they should not be surprised by\n+            // weird drop behavior in their resulting code.\n+            debug!(\"visit_terminator_drop previously seen \\\n+                    erased_drop_place_ty: {:?} on prev_seen: {:?}; returning early.\",\n+                   erased_drop_place_ty, prev_seen);\n+            return;\n+        }\n+\n         let gcx = self.tcx.global_tcx();\n         let drop_field = |mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n                           (index, field): (usize, ty::Ty<'gcx>)| {\n             let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n             let place = drop_place.clone().field(Field::new(index), field_ty);\n \n-            mir.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span);\n+            debug!(\"visit_terminator_drop drop_field place: {:?} field_ty: {:?}\", place, field_ty);\n+            let seen = prev_seen.cons(erased_drop_place_ty);\n+            mir.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span, seen);\n         };\n \n         match erased_drop_place_ty.sty {\n@@ -899,20 +976,84 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n+\n+            // #45696: special-case Box<T> by treating its dtor as\n+            // only deep *across owned content*. Namely, we know\n+            // dropping a box does not touch data behind any\n+            // references it holds; if we were to instead fall into\n+            // the base case below, we would have a Deep Write due to\n+            // the box being `needs_drop`, and that Deep Write would\n+            // touch `&mut` data in the box.\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                // When/if we add a `&own T` type, this action would\n+                // be like running the destructor of the `&own T`.\n+                // (And the owner of backing storage referenced by the\n+                // `&own T` would be responsible for deallocating that\n+                // backing storage.)\n+\n+                // we model dropping any content owned by the box by\n+                // recurring on box contents. This catches cases like\n+                // `Box<Box<ScribbleWhenDropped<&mut T>>>`, while\n+                // still restricting Write to *owned* content.\n+                let ty = erased_drop_place_ty.boxed_ty();\n+                let deref_place = drop_place.clone().deref();\n+                debug!(\"visit_terminator_drop drop-box-content deref_place: {:?} ty: {:?}\",\n+                       deref_place, ty);\n+                let seen = prev_seen.cons(erased_drop_place_ty);\n+                self.visit_terminator_drop(\n+                    loc, term, flow_state, &deref_place, ty, span, seen);\n+            }\n+\n             _ => {\n                 // We have now refined the type of the value being\n                 // dropped (potentially) to just the type of a\n                 // subfield; so check whether that field's type still\n-                // \"needs drop\". If so, we assume that the destructor\n-                // may access any data it likes (i.e., a Deep Write).\n+                // \"needs drop\".\n                 if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n+                    // If so, we assume that the destructor may access\n+                    // any data it likes (i.e., a Deep Write).\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n                         (drop_place, span),\n                         (Deep, Write(WriteKind::StorageDeadOrDrop)),\n                         LocalMutationIsAllowed::Yes,\n                         flow_state,\n                     );\n+                } else {\n+                    // If there is no destructor, we still include a\n+                    // *shallow* write.  This essentially ensures that\n+                    // borrows of the memory directly at `drop_place`\n+                    // cannot continue to be borrowed across the drop.\n+                    //\n+                    // If we were to use a Deep Write here, then any\n+                    // `&mut T` that is reachable from `drop_place`\n+                    // would get invalidated; fixing that is the\n+                    // essence of resolving issue #45696.\n+                    //\n+                    // * Note: In the compiler today, doing a Deep\n+                    //   Write here would not actually break\n+                    //   anything beyond #45696; for example it does not\n+                    //   break this example:\n+                    //\n+                    //   ```rust\n+                    //   fn reborrow(x: &mut i32) -> &mut i32 { &mut *x }\n+                    //   ```\n+                    //\n+                    //   Why? Because we do not schedule/emit\n+                    //   `Drop(x)` in the MIR unless `x` needs drop in\n+                    //   the first place.\n+                    //\n+                    // FIXME: Its possible this logic actually should\n+                    // be attached to the `StorageDead` statement\n+                    // rather than the `Drop`. See discussion on PR\n+                    // #52782.\n+                    self.access_place(\n+                        ContextKind::Drop.new(loc),\n+                        (drop_place, span),\n+                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                        LocalMutationIsAllowed::Yes,\n+                        flow_state,\n+                    );\n                 }\n             }\n         }"}]}