{"sha": "37647d1733c368dfb4a81f368cefa09adf6bf20d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NjQ3ZDE3MzNjMzY4ZGZiNGE4MWYzNjhjZWZhMDlhZGY2YmYyMGQ=", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-06-06T01:08:09Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-06-06T01:54:51Z"}, "message": "Move `flt2dec::{Formatted, Part}` to dedicated module\n\nThey are used by integer formatting as well and is not exclusive to float.", "tree": {"sha": "cad03235c8538c9bcd80edbfb1125a086864847c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cad03235c8538c9bcd80edbfb1125a086864847c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37647d1733c368dfb4a81f368cefa09adf6bf20d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37647d1733c368dfb4a81f368cefa09adf6bf20d", "html_url": "https://github.com/rust-lang/rust/commit/37647d1733c368dfb4a81f368cefa09adf6bf20d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37647d1733c368dfb4a81f368cefa09adf6bf20d/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac3e680193a3e11e60b07840ffb1db12793de110", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac3e680193a3e11e60b07840ffb1db12793de110", "html_url": "https://github.com/rust-lang/rust/commit/ac3e680193a3e11e60b07840ffb1db12793de110"}], "stats": {"total": 254, "additions": 133, "deletions": 121}, "files": [{"sha": "ba65f0fadbd9d88a38ff35fb8c4fa2e1d5154b74", "filename": "library/core/src/fmt/float.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Ffloat.rs?ref=37647d1733c368dfb4a81f368cefa09adf6bf20d", "patch": "@@ -1,6 +1,7 @@\n use crate::fmt::{Debug, Display, Formatter, LowerExp, Result, UpperExp};\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n+use crate::num::fmt as numfmt;\n \n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n@@ -15,7 +16,7 @@ where\n     T: flt2dec::DecodableFloat,\n {\n     let mut buf: [MaybeUninit<u8>; 1024] = MaybeUninit::uninit_array(); // enough for f32 and f64\n-    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 4] = MaybeUninit::uninit_array();\n+    let mut parts: [MaybeUninit<numfmt::Part<'_>>; 4] = MaybeUninit::uninit_array();\n     let formatted = flt2dec::to_exact_fixed_str(\n         flt2dec::strategy::grisu::format_exact,\n         *num,\n@@ -41,7 +42,7 @@ where\n {\n     // enough for f32 and f64\n     let mut buf: [MaybeUninit<u8>; flt2dec::MAX_SIG_DIGITS] = MaybeUninit::uninit_array();\n-    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 4] = MaybeUninit::uninit_array();\n+    let mut parts: [MaybeUninit<numfmt::Part<'_>>; 4] = MaybeUninit::uninit_array();\n     let formatted = flt2dec::to_shortest_str(\n         flt2dec::strategy::grisu::format_shortest,\n         *num,\n@@ -85,7 +86,7 @@ where\n     T: flt2dec::DecodableFloat,\n {\n     let mut buf: [MaybeUninit<u8>; 1024] = MaybeUninit::uninit_array(); // enough for f32 and f64\n-    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 6] = MaybeUninit::uninit_array();\n+    let mut parts: [MaybeUninit<numfmt::Part<'_>>; 6] = MaybeUninit::uninit_array();\n     let formatted = flt2dec::to_exact_exp_str(\n         flt2dec::strategy::grisu::format_exact,\n         *num,\n@@ -112,7 +113,7 @@ where\n {\n     // enough for f32 and f64\n     let mut buf: [MaybeUninit<u8>; flt2dec::MAX_SIG_DIGITS] = MaybeUninit::uninit_array();\n-    let mut parts: [MaybeUninit<flt2dec::Part<'_>>; 6] = MaybeUninit::uninit_array();\n+    let mut parts: [MaybeUninit<numfmt::Part<'_>>; 6] = MaybeUninit::uninit_array();\n     let formatted = flt2dec::to_shortest_exp_str(\n         flt2dec::strategy::grisu::format_shortest,\n         *num,"}, {"sha": "1adfb73ced04d48699e27310f0cb8bf5bedc7202", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=37647d1733c368dfb4a81f368cefa09adf6bf20d", "patch": "@@ -7,7 +7,7 @@ use crate::char::EscapeDebugExtArgs;\n use crate::iter;\n use crate::marker::PhantomData;\n use crate::mem;\n-use crate::num::flt2dec;\n+use crate::num::fmt as numfmt;\n use crate::ops::Deref;\n use crate::result;\n use crate::str;\n@@ -1421,7 +1421,7 @@ impl<'a> Formatter<'a> {\n     /// Takes the formatted parts and applies the padding.\n     /// Assumes that the caller already has rendered the parts with required precision,\n     /// so that `self.precision` can be ignored.\n-    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted<'_>) -> Result {\n+    fn pad_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n         if let Some(mut width) = self.width {\n             // for the sign-aware zero padding, we render the sign first and\n             // behave as if we had no sign from the beginning.\n@@ -1461,14 +1461,14 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n-    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted<'_>) -> Result {\n+    fn write_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n         fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n-            // SAFETY: This is used for `flt2dec::Part::Num` and `flt2dec::Part::Copy`.\n-            // It's safe to use for `flt2dec::Part::Num` since every char `c` is between\n+            // SAFETY: This is used for `numfmt::Part::Num` and `numfmt::Part::Copy`.\n+            // It's safe to use for `numfmt::Part::Num` since every char `c` is between\n             // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n-            // It's also probably safe in practice to use for `flt2dec::Part::Copy(buf)`\n+            // It's also probably safe in practice to use for `numfmt::Part::Copy(buf)`\n             // since `buf` should be plain ASCII, but it's possible for someone to pass\n-            // in a bad value for `buf` into `flt2dec::to_shortest_str` since it is a\n+            // in a bad value for `buf` into `numfmt::to_shortest_str` since it is a\n             // public function.\n             // FIXME: Determine whether this could result in UB.\n             buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n@@ -1479,7 +1479,7 @@ impl<'a> Formatter<'a> {\n         }\n         for part in formatted.parts {\n             match *part {\n-                flt2dec::Part::Zero(mut nzeroes) => {\n+                numfmt::Part::Zero(mut nzeroes) => {\n                     const ZEROES: &str = // 64 zeroes\n                         \"0000000000000000000000000000000000000000000000000000000000000000\";\n                     while nzeroes > ZEROES.len() {\n@@ -1490,7 +1490,7 @@ impl<'a> Formatter<'a> {\n                         self.buf.write_str(&ZEROES[..nzeroes])?;\n                     }\n                 }\n-                flt2dec::Part::Num(mut v) => {\n+                numfmt::Part::Num(mut v) => {\n                     let mut s = [0; 5];\n                     let len = part.len();\n                     for c in s[..len].iter_mut().rev() {\n@@ -1499,7 +1499,7 @@ impl<'a> Formatter<'a> {\n                     }\n                     write_bytes(self.buf, &s[..len])?;\n                 }\n-                flt2dec::Part::Copy(buf) => {\n+                numfmt::Part::Copy(buf) => {\n                     write_bytes(self.buf, buf)?;\n                 }\n             }"}, {"sha": "db45640df48d6b49cba7d88a2a513b89a3325f5f", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=37647d1733c368dfb4a81f368cefa09adf6bf20d", "patch": "@@ -2,7 +2,7 @@\n \n use crate::fmt;\n use crate::mem::MaybeUninit;\n-use crate::num::flt2dec;\n+use crate::num::fmt as numfmt;\n use crate::ops::{Div, Rem, Sub};\n use crate::ptr;\n use crate::slice;\n@@ -406,9 +406,9 @@ macro_rules! impl_Exp {\n             };\n \n             let parts = &[\n-                flt2dec::Part::Copy(buf_slice),\n-                flt2dec::Part::Zero(added_precision),\n-                flt2dec::Part::Copy(exp_slice)\n+                numfmt::Part::Copy(buf_slice),\n+                numfmt::Part::Zero(added_precision),\n+                numfmt::Part::Copy(exp_slice)\n             ];\n             let sign = if !is_nonnegative {\n                 \"-\"\n@@ -417,7 +417,7 @@ macro_rules! impl_Exp {\n             } else {\n                 \"\"\n             };\n-            let formatted = flt2dec::Formatted{sign, parts};\n+            let formatted = numfmt::Formatted{sign, parts};\n             f.pad_formatted_parts(&formatted)\n         }\n "}, {"sha": "62ae30e9ad38663ff75265588486a623832929b4", "filename": "library/core/src/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 101, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs?ref=37647d1733c368dfb4a81f368cefa09adf6bf20d", "patch": "@@ -124,6 +124,7 @@ functions.\n \n pub use self::decoder::{decode, DecodableFloat, Decoded, FullDecoded};\n \n+use super::fmt::{Formatted, Part};\n use crate::mem::MaybeUninit;\n \n pub mod decoder;\n@@ -170,107 +171,6 @@ pub fn round_up(d: &mut [u8]) -> Option<u8> {\n     }\n }\n \n-/// Formatted parts.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum Part<'a> {\n-    /// Given number of zero digits.\n-    Zero(usize),\n-    /// A literal number up to 5 digits.\n-    Num(u16),\n-    /// A verbatim copy of given bytes.\n-    Copy(&'a [u8]),\n-}\n-\n-impl<'a> Part<'a> {\n-    /// Returns the exact byte length of given part.\n-    pub fn len(&self) -> usize {\n-        match *self {\n-            Part::Zero(nzeroes) => nzeroes,\n-            Part::Num(v) => {\n-                if v < 1_000 {\n-                    if v < 10 {\n-                        1\n-                    } else if v < 100 {\n-                        2\n-                    } else {\n-                        3\n-                    }\n-                } else {\n-                    if v < 10_000 { 4 } else { 5 }\n-                }\n-            }\n-            Part::Copy(buf) => buf.len(),\n-        }\n-    }\n-\n-    /// Writes a part into the supplied buffer.\n-    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n-    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n-    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n-        let len = self.len();\n-        if out.len() >= len {\n-            match *self {\n-                Part::Zero(nzeroes) => {\n-                    for c in &mut out[..nzeroes] {\n-                        *c = b'0';\n-                    }\n-                }\n-                Part::Num(mut v) => {\n-                    for c in out[..len].iter_mut().rev() {\n-                        *c = b'0' + (v % 10) as u8;\n-                        v /= 10;\n-                    }\n-                }\n-                Part::Copy(buf) => {\n-                    out[..buf.len()].copy_from_slice(buf);\n-                }\n-            }\n-            Some(len)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Formatted result containing one or more parts.\n-/// This can be written to the byte buffer or converted to the allocated string.\n-#[allow(missing_debug_implementations)]\n-#[derive(Clone)]\n-pub struct Formatted<'a> {\n-    /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n-    pub sign: &'static str,\n-    /// Formatted parts to be rendered after a sign and optional zero padding.\n-    pub parts: &'a [Part<'a>],\n-}\n-\n-impl<'a> Formatted<'a> {\n-    /// Returns the exact byte length of combined formatted result.\n-    pub fn len(&self) -> usize {\n-        let mut len = self.sign.len();\n-        for part in self.parts {\n-            len += part.len();\n-        }\n-        len\n-    }\n-\n-    /// Writes all formatted parts into the supplied buffer.\n-    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n-    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n-    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n-        if out.len() < self.sign.len() {\n-            return None;\n-        }\n-        out[..self.sign.len()].copy_from_slice(self.sign.as_bytes());\n-\n-        let mut written = self.sign.len();\n-        for part in self.parts {\n-            let len = part.write(&mut out[written..])?;\n-            written += len;\n-        }\n-        Some(written)\n-    }\n-}\n-\n /// Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form\n /// with at least given number of fractional digits. The result is stored to\n /// the supplied parts array and a slice of written parts is returned."}, {"sha": "578288bda259545d199e7586609855d232ff997d", "filename": "library/core/src/num/fmt.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Fnum%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Fnum%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ffmt.rs?ref=37647d1733c368dfb4a81f368cefa09adf6bf20d", "patch": "@@ -0,0 +1,108 @@\n+//! Shared utilties used by both float and integer formatting.\n+#![doc(hidden)]\n+#![unstable(\n+    feature = \"numfmt\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"none\"\n+)]\n+\n+/// Formatted parts.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Part<'a> {\n+    /// Given number of zero digits.\n+    Zero(usize),\n+    /// A literal number up to 5 digits.\n+    Num(u16),\n+    /// A verbatim copy of given bytes.\n+    Copy(&'a [u8]),\n+}\n+\n+impl<'a> Part<'a> {\n+    /// Returns the exact byte length of given part.\n+    pub fn len(&self) -> usize {\n+        match *self {\n+            Part::Zero(nzeroes) => nzeroes,\n+            Part::Num(v) => {\n+                if v < 1_000 {\n+                    if v < 10 {\n+                        1\n+                    } else if v < 100 {\n+                        2\n+                    } else {\n+                        3\n+                    }\n+                } else {\n+                    if v < 10_000 { 4 } else { 5 }\n+                }\n+            }\n+            Part::Copy(buf) => buf.len(),\n+        }\n+    }\n+\n+    /// Writes a part into the supplied buffer.\n+    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n+    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n+    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n+        let len = self.len();\n+        if out.len() >= len {\n+            match *self {\n+                Part::Zero(nzeroes) => {\n+                    for c in &mut out[..nzeroes] {\n+                        *c = b'0';\n+                    }\n+                }\n+                Part::Num(mut v) => {\n+                    for c in out[..len].iter_mut().rev() {\n+                        *c = b'0' + (v % 10) as u8;\n+                        v /= 10;\n+                    }\n+                }\n+                Part::Copy(buf) => {\n+                    out[..buf.len()].copy_from_slice(buf);\n+                }\n+            }\n+            Some(len)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Formatted result containing one or more parts.\n+/// This can be written to the byte buffer or converted to the allocated string.\n+#[allow(missing_debug_implementations)]\n+#[derive(Clone)]\n+pub struct Formatted<'a> {\n+    /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n+    pub sign: &'static str,\n+    /// Formatted parts to be rendered after a sign and optional zero padding.\n+    pub parts: &'a [Part<'a>],\n+}\n+\n+impl<'a> Formatted<'a> {\n+    /// Returns the exact byte length of combined formatted result.\n+    pub fn len(&self) -> usize {\n+        let mut len = self.sign.len();\n+        for part in self.parts {\n+            len += part.len();\n+        }\n+        len\n+    }\n+\n+    /// Writes all formatted parts into the supplied buffer.\n+    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n+    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n+    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n+        if out.len() < self.sign.len() {\n+            return None;\n+        }\n+        out[..self.sign.len()].copy_from_slice(self.sign.as_bytes());\n+\n+        let mut written = self.sign.len();\n+        for part in self.parts {\n+            let len = part.write(&mut out[written..])?;\n+            written += len;\n+        }\n+        Some(written)\n+    }\n+}"}, {"sha": "0825abc17ed723a9b85ad19ef2ea257120267a65", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=37647d1733c368dfb4a81f368cefa09adf6bf20d", "patch": "@@ -29,6 +29,7 @@ pub mod bignum;\n pub mod dec2flt;\n pub mod diy_float;\n pub mod flt2dec;\n+pub mod fmt;\n \n #[macro_use]\n mod int_macros; // import int_impl!"}, {"sha": "d990c48af710ac91c6cdbf9d03986ea513322e5c", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=37647d1733c368dfb4a81f368cefa09adf6bf20d", "patch": "@@ -39,6 +39,7 @@\n #![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_write_slice)]\n #![feature(min_specialization)]\n+#![feature(numfmt)]\n #![feature(step_trait)]\n #![feature(str_internals)]\n #![feature(test)]"}, {"sha": "4874e8ec09f8cfa4910f334158b431baa735f1c4", "filename": "library/core/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37647d1733c368dfb4a81f368cefa09adf6bf20d/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=37647d1733c368dfb4a81f368cefa09adf6bf20d", "patch": "@@ -2,10 +2,11 @@ use std::mem::MaybeUninit;\n use std::{fmt, str};\n \n use core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\n-use core::num::flt2dec::{round_up, Formatted, Part, Sign, MAX_SIG_DIGITS};\n+use core::num::flt2dec::{round_up, Sign, MAX_SIG_DIGITS};\n use core::num::flt2dec::{\n     to_exact_exp_str, to_exact_fixed_str, to_shortest_exp_str, to_shortest_str,\n };\n+use core::num::fmt::{Formatted, Part};\n \n pub use test::Bencher;\n "}]}