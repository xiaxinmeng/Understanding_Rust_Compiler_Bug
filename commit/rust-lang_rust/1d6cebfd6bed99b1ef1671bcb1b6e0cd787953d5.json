{"sha": "1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5", "node_id": "C_kwDOAAsO6NoAKDFkNmNlYmZkNmJlZDk5YjFlZjE2NzFiY2IxYjZlMGNkNzg3OTUzZDU", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-08-02T23:01:40Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-08-04T14:26:57Z"}, "message": "Implement def_id based remapping", "tree": {"sha": "37c3ec9666fe36d3b73cd43ef87c139593b6241a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37c3ec9666fe36d3b73cd43ef87c139593b6241a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmLr1zEACgkQgTGiTgx5\n768Quw//Wr7Oq3Ov8E6EOm3RjxfUR0e7hOdGB/oeZKO2kYGnwGrdpYGHauFWR99R\nwZ3MGhRKgOnZ0o5y95K1sTy90t2iy4ysYkyob5yU49sKbw/tuKwBCZEWDPhYzpsN\nfboG4LN+IB15NPuGqnFimOxse9tAqPeKHVwO83dSp4bjBiAhnlj92isa6dLP3eOs\nuju8LH0wFoRlHRsdAQtYc36sykzW2gRYbnb3I+Hxv4fXn+Zg6IbfDi6hBaFAOINn\nxJyQcOBS56l72T5M/t5EqrK5T+IaosvIMoqg0hAQ3+sYnYsoU6XLT4NxfhaEyhUP\npZAg+IvTeaGiJ20kP+vSnH5ohoD8M6BUd4VN6wFQQjwI37vDDYaThjeSykw98CgX\n+wb0ruDZKzGj6VaDIU52k5or5+NliLQPqFJeBsbfoCr7rhSdFS6dJJHxQ516tG/7\nXcj9xzC6PmHvUIzaEwQ3vzbj33tgLgyB8nt4m3N7uwt/FeKx5R927btStj5ojpAx\nYzxlojnZK+Ffmmp3PNhxh7CDldMDVzIHdI2OVh+xb9UYeKc9Nucb2ggK5dKb9zow\n8zs9fEsw7D4FNVGpq1FUZsYulMHfJSa8BKXdgipjby+I8jddvOwoTERB1mUyrhaP\nVn27cd0jI73/hX64w0bR8U6zeLe4eq2QOoy+BYKBbk078ATo0n8=\n=01LY\n-----END PGP SIGNATURE-----", "payload": "tree 37c3ec9666fe36d3b73cd43ef87c139593b6241a\nparent f0db1d68e6fd0fe393a3c6b4c49167f9706a5479\nauthor Santiago Pastorino <spastorino@gmail.com> 1659481300 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1659623217 -0300\n\nImplement def_id based remapping\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5", "html_url": "https://github.com/rust-lang/rust/commit/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0db1d68e6fd0fe393a3c6b4c49167f9706a5479", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0db1d68e6fd0fe393a3c6b4c49167f9706a5479", "html_url": "https://github.com/rust-lang/rust/commit/f0db1d68e6fd0fe393a3c6b4c49167f9706a5479"}], "stats": {"total": 247, "additions": 140, "deletions": 107}, "files": [{"sha": "7c1bd6b4b199ac505cb364ecddb502d89e541e83", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 133, "deletions": 107, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5", "patch": "@@ -151,6 +151,8 @@ trait ResolverAstLoweringExt {\n     fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n+    fn record_def_id_remap(&mut self, from: LocalDefId, to: LocalDefId);\n+    fn get_remapped_def_id(&self, local_def_id: LocalDefId) -> LocalDefId;\n }\n \n impl ResolverAstLoweringExt for ResolverAstLowering {\n@@ -218,6 +220,25 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n     fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n         self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n     }\n+\n+    /// Push a remapping into the top-most map. Panics if no map has been pushed.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn record_def_id_remap(&mut self, from: LocalDefId, to: LocalDefId) {\n+        self.generics_def_id_map.last_mut().expect(\"no map pushed\").insert(from, to);\n+    }\n+\n+    fn get_remapped_def_id(&self, mut local_def_id: LocalDefId) -> LocalDefId {\n+        for map in &self.generics_def_id_map {\n+            if let Some(r) = map.get(&local_def_id) {\n+                debug!(\"def_id_remapper: remapping from `{local_def_id:?}` to `{r:?}`\");\n+                local_def_id = *r;\n+            } else {\n+                debug!(\"def_id_remapper: no remapping for `{local_def_id:?}` found in map\");\n+            }\n+        }\n+\n+        local_def_id\n+    }\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -474,7 +495,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n-        self.resolver.node_id_to_def_id.get(&node).copied()\n+        self.resolver\n+            .node_id_to_def_id\n+            .get(&node)\n+            .map(|local_def_id| self.resolver.get_remapped_def_id(*local_def_id))\n     }\n \n     fn local_def_id(&self, node: NodeId) -> LocalDefId {\n@@ -534,6 +558,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug_assert!(_old.is_none())\n     }\n \n+    fn with_remapping<R>(\n+        &mut self,\n+        remap: FxHashMap<LocalDefId, LocalDefId>,\n+        f: impl FnOnce(&mut Self) -> R,\n+    ) -> R {\n+        self.resolver.generics_def_id_map.push(remap);\n+        let res = f(self);\n+        self.resolver.generics_def_id_map.pop();\n+        res\n+    }\n+\n     fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> &'hir hir::OwnerInfo<'hir> {\n         let attrs = std::mem::take(&mut self.attrs);\n         let mut bodies = std::mem::take(&mut self.bodies);\n@@ -1325,9 +1360,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut new_remapping = FxHashMap::default();\n \n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n-            let hir_bounds = if origin == hir::OpaqueTyOrigin::TyAlias {\n-                lctx.lower_param_bounds(bounds, itctx)\n-            } else {\n+            if origin != hir::OpaqueTyOrigin::TyAlias {\n                 debug!(?lctx.captured_lifetimes);\n \n                 let lifetime_stash = std::mem::replace(\n@@ -1347,53 +1380,57 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     &mut new_remapping,\n                 );\n \n-                let ret = lctx.lower_param_bounds(bounds, itctx);\n-\n                 let ctxt = std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap();\n \n                 collected_lifetimes = ctxt.captures;\n-\n-                ret\n             };\n+            debug!(?new_remapping);\n             debug!(?collected_lifetimes);\n \n-            let lifetime_defs =\n-                lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(|&(lifetime, _)| {\n-                    let hir_id = lctx.lower_node_id(lifetime.id);\n-                    debug_assert_ne!(lctx.opt_local_def_id(lifetime.id), None);\n+            lctx.with_remapping(new_remapping, |lctx| {\n+                let hir_bounds = lctx.lower_param_bounds(bounds, itctx);\n+\n+                let lifetime_defs =\n+                    lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(|&(lifetime, _)| {\n+                        let hir_id = lctx.lower_node_id(lifetime.id);\n+                        debug_assert_ne!(lctx.opt_local_def_id(lifetime.id), None);\n+\n+                        let (name, kind) = if lifetime.ident.name == kw::UnderscoreLifetime {\n+                            (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided)\n+                        } else {\n+                            (\n+                                hir::ParamName::Plain(lifetime.ident),\n+                                hir::LifetimeParamKind::Explicit,\n+                            )\n+                        };\n \n-                    let (name, kind) = if lifetime.ident.name == kw::UnderscoreLifetime {\n-                        (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided)\n-                    } else {\n-                        (hir::ParamName::Plain(lifetime.ident), hir::LifetimeParamKind::Explicit)\n-                    };\n+                        hir::GenericParam {\n+                            hir_id,\n+                            name,\n+                            span: lifetime.ident.span,\n+                            pure_wrt_drop: false,\n+                            kind: hir::GenericParamKind::Lifetime { kind },\n+                            colon_span: None,\n+                        }\n+                    }));\n \n-                    hir::GenericParam {\n-                        hir_id,\n-                        name,\n-                        span: lifetime.ident.span,\n-                        pure_wrt_drop: false,\n-                        kind: hir::GenericParamKind::Lifetime { kind },\n-                        colon_span: None,\n-                    }\n-                }));\n-\n-            debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n-\n-            let opaque_ty_item = hir::OpaqueTy {\n-                generics: self.arena.alloc(hir::Generics {\n-                    params: lifetime_defs,\n-                    predicates: &[],\n-                    has_where_clause_predicates: false,\n-                    where_clause_span: lctx.lower_span(span),\n-                    span: lctx.lower_span(span),\n-                }),\n-                bounds: hir_bounds,\n-                origin,\n-            };\n+                debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n+\n+                let opaque_ty_item = hir::OpaqueTy {\n+                    generics: self.arena.alloc(hir::Generics {\n+                        params: lifetime_defs,\n+                        predicates: &[],\n+                        has_where_clause_predicates: false,\n+                        where_clause_span: lctx.lower_span(span),\n+                        span: lctx.lower_span(span),\n+                    }),\n+                    bounds: hir_bounds,\n+                    origin,\n+                };\n \n-            trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n-            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n+                trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n+                lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n+            })\n         });\n \n         let lifetimes =\n@@ -1746,58 +1783,62 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 &mut new_remapping,\n             );\n \n-            // We have to be careful to get elision right here. The\n-            // idea is that we create a lifetime parameter for each\n-            // lifetime in the return type.  So, given a return type\n-            // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n-            // Future<Output = &'1 [ &'2 u32 ]>`.\n-            //\n-            // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n-            // hence the elision takes place at the fn site.\n-            let ret = this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span);\n-\n             let ctxt = std::mem::replace(&mut this.captured_lifetimes, lifetime_stash).unwrap();\n \n             captures = ctxt.captures;\n \n-            let future_bound = ret;\n-\n-            let generic_params =\n-                this.arena.alloc_from_iter(captures.iter().map(|&(lifetime, _)| {\n-                    let hir_id = this.lower_node_id(lifetime.id);\n-                    debug_assert_ne!(this.opt_local_def_id(lifetime.id), None);\n-\n-                    let (name, kind) = if lifetime.ident.name == kw::UnderscoreLifetime {\n-                        (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided)\n-                    } else {\n-                        (hir::ParamName::Plain(lifetime.ident), hir::LifetimeParamKind::Explicit)\n-                    };\n+            this.with_remapping(new_remapping, |this| {\n+                // We have to be careful to get elision right here. The\n+                // idea is that we create a lifetime parameter for each\n+                // lifetime in the return type.  So, given a return type\n+                // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n+                // Future<Output = &'1 [ &'2 u32 ]>`.\n+                //\n+                // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n+                // hence the elision takes place at the fn site.\n+                let future_bound =\n+                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span);\n+\n+                let generic_params =\n+                    this.arena.alloc_from_iter(captures.iter().map(|&(lifetime, _)| {\n+                        let hir_id = this.lower_node_id(lifetime.id);\n+                        debug_assert_ne!(this.opt_local_def_id(lifetime.id), None);\n+\n+                        let (name, kind) = if lifetime.ident.name == kw::UnderscoreLifetime {\n+                            (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided)\n+                        } else {\n+                            (\n+                                hir::ParamName::Plain(lifetime.ident),\n+                                hir::LifetimeParamKind::Explicit,\n+                            )\n+                        };\n \n-                    hir::GenericParam {\n-                        hir_id,\n-                        name,\n-                        span: lifetime.ident.span,\n-                        pure_wrt_drop: false,\n-                        kind: hir::GenericParamKind::Lifetime { kind },\n-                        colon_span: None,\n-                    }\n-                }));\n-            debug!(\"lower_async_fn_ret_ty: generic_params={:#?}\", generic_params);\n-\n-            let opaque_ty_item = hir::OpaqueTy {\n-                generics: this.arena.alloc(hir::Generics {\n-                    params: generic_params,\n-                    predicates: &[],\n-                    has_where_clause_predicates: false,\n-                    where_clause_span: this.lower_span(span),\n-                    span: this.lower_span(span),\n-                }),\n-                bounds: arena_vec![this; future_bound],\n-                origin: hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n-            };\n+                        hir::GenericParam {\n+                            hir_id,\n+                            name,\n+                            span: lifetime.ident.span,\n+                            pure_wrt_drop: false,\n+                            kind: hir::GenericParamKind::Lifetime { kind },\n+                            colon_span: None,\n+                        }\n+                    }));\n+                debug!(\"lower_async_fn_ret_ty: generic_params={:#?}\", generic_params);\n+\n+                let opaque_ty_item = hir::OpaqueTy {\n+                    generics: this.arena.alloc(hir::Generics {\n+                        params: generic_params,\n+                        predicates: &[],\n+                        has_where_clause_predicates: false,\n+                        where_clause_span: this.lower_span(span),\n+                        span: this.lower_span(span),\n+                    }),\n+                    bounds: arena_vec![this; future_bound],\n+                    origin: hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n+                };\n \n-            trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n-            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n+                trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n+                this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n+            })\n         });\n \n         // As documented above, we need to create the lifetime\n@@ -1910,40 +1951,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ident: Ident,\n         res: LifetimeRes,\n     ) -> hir::Lifetime {\n-        debug!(?self.captured_lifetimes);\n-\n         let name = match res {\n-            LifetimeRes::Param { mut param, .. } => {\n+            LifetimeRes::Param { param, .. } => {\n                 let p_name = ParamName::Plain(ident);\n-                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n-                    if let Entry::Occupied(o) = captured_lifetimes.captures.entry(param) {\n-                        param = self.local_def_id(o.get().0.id);\n-                    }\n-\n-                    self.captured_lifetimes = Some(captured_lifetimes);\n-                }\n+                let param = self.resolver.get_remapped_def_id(param);\n \n                 hir::LifetimeName::Param(param, p_name)\n             }\n             LifetimeRes::Fresh { param, .. } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n+                let param = self.local_def_id(param);\n \n-                let mut param = self.local_def_id(param);\n-                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n-                    if let Entry::Occupied(o) = captured_lifetimes.captures.entry(param) {\n-                        param = self.local_def_id(o.get().0.id);\n-                    }\n-\n-                    self.captured_lifetimes = Some(captured_lifetimes);\n-                }\n                 hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n             LifetimeRes::Infer => hir::LifetimeName::Infer,\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n             res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),\n         };\n-        debug!(?self.captured_lifetimes);\n+\n         debug!(?name);\n         hir::Lifetime { hir_id: self.lower_node_id(id), span: self.lower_span(span), name }\n     }"}, {"sha": "dfe0a4fd3644895b154c4c4bdb0e98eb26267051", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5", "patch": "@@ -177,6 +177,8 @@ pub struct ResolverAstLowering {\n     pub label_res_map: NodeMap<ast::NodeId>,\n     /// Resolutions for lifetimes.\n     pub lifetimes_res_map: NodeMap<LifetimeRes>,\n+    /// Mapping from generics def-id to RPIT copied generic def-id\n+    pub generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n     /// Lifetime parameters that lowering will have to introduce.\n     pub extra_lifetime_params_map: NodeMap<Vec<(Ident, ast::NodeId, LifetimeRes)>>,\n "}, {"sha": "3e3c16f5100005f09735927084ed33a649e3eb9b", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=1d6cebfd6bed99b1ef1671bcb1b6e0cd787953d5", "patch": "@@ -913,6 +913,8 @@ pub struct Resolver<'a> {\n     label_res_map: NodeMap<NodeId>,\n     /// Resolutions for lifetimes.\n     lifetimes_res_map: NodeMap<LifetimeRes>,\n+    /// Mapping from generics def-id to RPIT copied generic def-id\n+    generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n     /// Lifetime parameters that lowering will have to introduce.\n     extra_lifetime_params_map: NodeMap<Vec<(Ident, NodeId, LifetimeRes)>>,\n \n@@ -1277,6 +1279,7 @@ impl<'a> Resolver<'a> {\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n             lifetimes_res_map: Default::default(),\n+            generics_def_id_map: Vec::new(),\n             extra_lifetime_params_map: Default::default(),\n             extern_crate_map: Default::default(),\n             reexport_map: FxHashMap::default(),\n@@ -1444,6 +1447,7 @@ impl<'a> Resolver<'a> {\n             import_res_map: self.import_res_map,\n             label_res_map: self.label_res_map,\n             lifetimes_res_map: self.lifetimes_res_map,\n+            generics_def_id_map: self.generics_def_id_map,\n             extra_lifetime_params_map: self.extra_lifetime_params_map,\n             next_node_id: self.next_node_id,\n             node_id_to_def_id: self.node_id_to_def_id,\n@@ -1488,6 +1492,7 @@ impl<'a> Resolver<'a> {\n             import_res_map: self.import_res_map.clone(),\n             label_res_map: self.label_res_map.clone(),\n             lifetimes_res_map: self.lifetimes_res_map.clone(),\n+            generics_def_id_map: self.generics_def_id_map.clone(),\n             extra_lifetime_params_map: self.extra_lifetime_params_map.clone(),\n             next_node_id: self.next_node_id.clone(),\n             node_id_to_def_id: self.node_id_to_def_id.clone(),"}]}