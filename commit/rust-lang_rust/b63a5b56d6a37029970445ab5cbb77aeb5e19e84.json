{"sha": "b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2M2E1YjU2ZDZhMzcwMjk5NzA0NDVhYjVjYmI3N2FlYjVlMTllODQ=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-25T13:36:38Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-15T12:19:59Z"}, "message": "`map_entry` improvements\nLint `if _.[!]contains_key(&_) { .. } else { .. }` so long as one of the branches contains an insertion.", "tree": {"sha": "301027048eeec150540f4b49cc6595d73280a635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/301027048eeec150540f4b49cc6595d73280a635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmB4L3QACgkQ2lnoZDo37QaPkQD+OTpMPm6p5radoLeb60DFQNmB\n8kZVu1BkFley27pw/psBAPIX/RLOnnykHaWHmbLOXjMlMvRAIUuqNrp1LPrXG8sN\n=I4Io\n-----END PGP SIGNATURE-----", "payload": "tree 301027048eeec150540f4b49cc6595d73280a635\nparent ce5e927713ddd32096f4e73f7a2c339cc8163d82\nauthor Jason Newcomb <jsnewcomb@pm.me> 1616679398 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1618489199 -0400\n\n`map_entry` improvements\nLint `if _.[!]contains_key(&_) { .. } else { .. }` so long as one of the branches contains an insertion.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "html_url": "https://github.com/rust-lang/rust/commit/b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce5e927713ddd32096f4e73f7a2c339cc8163d82", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce5e927713ddd32096f4e73f7a2c339cc8163d82", "html_url": "https://github.com/rust-lang/rust/commit/ce5e927713ddd32096f4e73f7a2c339cc8163d82"}], "stats": {"total": 356, "additions": 354, "deletions": 2}, "files": [{"sha": "3e1d70b2e4078ba9e53a5151c89e31c6cc2c2e88", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::{\n     diagnostics::span_lint_and_sugg,\n     is_expr_final_block_expr, is_expr_used_or_unified, match_def_path, paths, peel_hir_expr_while,\n-    source::{snippet_indent, snippet_with_applicability, snippet_with_context},\n+    source::{reindent_multiline, snippet_indent, snippet_with_applicability, snippet_with_context},\n     SpanlessEq,\n };\n use rustc_errors::Applicability;\n@@ -75,7 +75,84 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n         let mut app = Applicability::MachineApplicable;\n         let map_str = snippet_with_context(cx, contains_expr.map.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n         let key_str = snippet_with_context(cx, contains_expr.key.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n-        let sugg = if !contains_expr.negated || else_expr.is_some() || then_search.insertions.is_empty() {\n+        let sugg = if let Some(else_expr) = else_expr {\n+            // if .. { .. } else { .. }\n+            let else_search = match find_insert_calls(cx, &contains_expr, else_expr) {\n+                Some(search) if !(then_search.insertions.is_empty() && search.insertions.is_empty()) => search,\n+                _ => return,\n+            };\n+\n+            if then_search.insertions.is_empty() || else_search.insertions.is_empty() {\n+                // if .. { insert } else { .. } or if .. { .. } else { then } of\n+                let (then_str, else_str, entry_kind) = if else_search.insertions.is_empty() {\n+                    if contains_expr.negated {\n+                        (\n+                            then_search.snippet_vacant(cx, then_expr.span, &mut app),\n+                            snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n+                            \"Vacant(e)\",\n+                        )\n+                    } else {\n+                        (\n+                            then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                            snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n+                            \"Occupied(mut e)\",\n+                        )\n+                    }\n+                } else if contains_expr.negated {\n+                    (\n+                        else_search.snippet_occupied(cx, else_expr.span, &mut app),\n+                        snippet_with_applicability(cx, then_expr.span, \"{ .. }\", &mut app),\n+                        \"Occupied(mut e)\",\n+                    )\n+                } else {\n+                    (\n+                        else_search.snippet_vacant(cx, else_expr.span, &mut app),\n+                        snippet_with_applicability(cx, then_expr.span, \"{ .. }\", &mut app),\n+                        \"Vacant(e)\",\n+                    )\n+                };\n+                format!(\n+                    \"if let {}::{} = {}.entry({}) {} else {}\",\n+                    map_ty.entry_path(),\n+                    entry_kind,\n+                    map_str,\n+                    key_str,\n+                    then_str,\n+                    else_str,\n+                )\n+            } else {\n+                // if .. { insert } else { insert }\n+                let (then_str, else_str, then_entry, else_entry) = if contains_expr.negated {\n+                    (\n+                        then_search.snippet_vacant(cx, then_expr.span, &mut app),\n+                        else_search.snippet_occupied(cx, else_expr.span, &mut app),\n+                        \"Vacant(e)\",\n+                        \"Occupied(mut e)\",\n+                    )\n+                } else {\n+                    (\n+                        then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                        else_search.snippet_vacant(cx, else_expr.span, &mut app),\n+                        \"Occupied(mut e)\",\n+                        \"Vacant(e)\",\n+                    )\n+                };\n+                let indent_str = snippet_indent(cx, expr.span);\n+                let indent_str = indent_str.as_deref().unwrap_or(\"\");\n+                format!(\n+                    \"match {}.entry({}) {{\\n{indent}    {entry}::{} => {}\\n\\\n+                        {indent}    {entry}::{} => {}\\n{indent}}}\",\n+                    map_str,\n+                    key_str,\n+                    then_entry,\n+                    reindent_multiline(then_str.into(), true, Some(4 + indent_str.len())),\n+                    else_entry,\n+                    reindent_multiline(else_str.into(), true, Some(4 + indent_str.len())),\n+                    entry = map_ty.entry_path(),\n+                    indent = indent_str,\n+                )\n+            }\n+        } else if then_search.insertions.is_empty() || !contains_expr.negated {\n             return;\n         } else {\n             // if .. { insert }"}, {"sha": "2332fa6313ff3958dea096892b3ac236cfc16c14", "filename": "tests/ui/entry_with_else.fixed", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/tests%2Fui%2Fentry_with_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/tests%2Fui%2Fentry_with_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.fixed?ref=b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "patch": "@@ -0,0 +1,73 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+fn foo() {}\n+\n+fn insert_if_absent0<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+    } else {\n+        foo();\n+    }\n+\n+    if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+        e.insert(v);\n+    } else {\n+        foo();\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+        }\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            e.insert(v2);\n+        }\n+    }\n+\n+    match m.entry(k) {\n+        std::collections::hash_map::Entry::Occupied(mut e) => {\n+            if true { Some(e.insert(v)) } else { Some(e.insert(v2)) }\n+        }\n+        std::collections::hash_map::Entry::Vacant(e) => {\n+            e.insert(v);\n+            None\n+        }\n+    };\n+\n+    if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+        foo();\n+        Some(e.insert(v))\n+    } else {\n+        None\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "2ff0c038efe27fb3333dc4aea39e2e1da1e16e4f", "filename": "tests/ui/entry_with_else.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/tests%2Fui%2Fentry_with_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/tests%2Fui%2Fentry_with_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.rs?ref=b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "patch": "@@ -0,0 +1,60 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n+#![warn(clippy::map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+macro_rules! m {\n+    ($e:expr) => {{ $e }};\n+}\n+\n+fn foo() {}\n+\n+fn insert_if_absent0<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        foo();\n+    }\n+\n+    if !m.contains_key(&k) {\n+        foo();\n+    } else {\n+        m.insert(k, v);\n+    }\n+\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+    } else {\n+        m.insert(k, v2);\n+    }\n+\n+    if m.contains_key(&k) {\n+        if true { m.insert(k, v) } else { m.insert(k, v2) }\n+    } else {\n+        m.insert(k, v)\n+    };\n+\n+    if m.contains_key(&k) {\n+        foo();\n+        m.insert(k, v)\n+    } else {\n+        None\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "6f62ff8d37457609f72a14510f69e3d661ff9cfe", "filename": "tests/ui/entry_with_else.stderr", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/tests%2Fui%2Fentry_with_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b63a5b56d6a37029970445ab5cbb77aeb5e19e84/tests%2Fui%2Fentry_with_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_with_else.stderr?ref=b63a5b56d6a37029970445ab5cbb77aeb5e19e84", "patch": "@@ -0,0 +1,142 @@\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:16:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:22:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:28:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |     } else {\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:34:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         foo();\n+LL | |     } else {\n+LL | |         m.insert(k, v);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+LL |         e.insert(v);\n+LL |     } else {\n+LL |         foo();\n+LL |     }\n+   |\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:40:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |     } else {\n+LL | |         m.insert(k, v2);\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             e.insert(v2);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:46:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         if true { m.insert(k, v) } else { m.insert(k, v2) }\n+LL | |     } else {\n+LL | |         m.insert(k, v)\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     match m.entry(k) {\n+LL |         std::collections::hash_map::Entry::Occupied(mut e) => {\n+LL |             if true { Some(e.insert(v)) } else { Some(e.insert(v2)) }\n+LL |         }\n+LL |         std::collections::hash_map::Entry::Vacant(e) => {\n+LL |             e.insert(v);\n+ ...\n+\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry_with_else.rs:52:5\n+   |\n+LL | /     if m.contains_key(&k) {\n+LL | |         foo();\n+LL | |         m.insert(k, v)\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let std::collections::hash_map::Entry::Occupied(mut e) = m.entry(k) {\n+LL |         foo();\n+LL |         Some(e.insert(v))\n+LL |     } else {\n+LL |         None\n+LL |     };\n+   |\n+\n+error: aborting due to 7 previous errors\n+"}]}