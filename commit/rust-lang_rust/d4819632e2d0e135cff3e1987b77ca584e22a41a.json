{"sha": "d4819632e2d0e135cff3e1987b77ca584e22a41a", "node_id": "C_kwDOAAsO6NoAKGQ0ODE5NjMyZTJkMGUxMzVjZmYzZTE5ODdiNzdjYTU4NGUyMmE0MWE", "commit": {"author": {"name": "Bruce A. MacNaughton", "email": "bruce.macnaughton@contrastsecurity.com", "date": "2022-07-20T00:35:19Z"}, "committer": {"name": "Bruce A. MacNaughton", "email": "bruce.macnaughton@contrastsecurity.com", "date": "2022-07-20T00:35:19Z"}, "message": "working updates", "tree": {"sha": "849fa1de1102be60350ed2abe8099f323b130e17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/849fa1de1102be60350ed2abe8099f323b130e17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4819632e2d0e135cff3e1987b77ca584e22a41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4819632e2d0e135cff3e1987b77ca584e22a41a", "html_url": "https://github.com/rust-lang/rust/commit/d4819632e2d0e135cff3e1987b77ca584e22a41a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4819632e2d0e135cff3e1987b77ca584e22a41a/comments", "author": {"login": "bmacnaughton", "id": 4171707, "node_id": "MDQ6VXNlcjQxNzE3MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4171707?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bmacnaughton", "html_url": "https://github.com/bmacnaughton", "followers_url": "https://api.github.com/users/bmacnaughton/followers", "following_url": "https://api.github.com/users/bmacnaughton/following{/other_user}", "gists_url": "https://api.github.com/users/bmacnaughton/gists{/gist_id}", "starred_url": "https://api.github.com/users/bmacnaughton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bmacnaughton/subscriptions", "organizations_url": "https://api.github.com/users/bmacnaughton/orgs", "repos_url": "https://api.github.com/users/bmacnaughton/repos", "events_url": "https://api.github.com/users/bmacnaughton/events{/privacy}", "received_events_url": "https://api.github.com/users/bmacnaughton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bmacnaughton", "id": 4171707, "node_id": "MDQ6VXNlcjQxNzE3MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4171707?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bmacnaughton", "html_url": "https://github.com/bmacnaughton", "followers_url": "https://api.github.com/users/bmacnaughton/followers", "following_url": "https://api.github.com/users/bmacnaughton/following{/other_user}", "gists_url": "https://api.github.com/users/bmacnaughton/gists{/gist_id}", "starred_url": "https://api.github.com/users/bmacnaughton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bmacnaughton/subscriptions", "organizations_url": "https://api.github.com/users/bmacnaughton/orgs", "repos_url": "https://api.github.com/users/bmacnaughton/repos", "events_url": "https://api.github.com/users/bmacnaughton/events{/privacy}", "received_events_url": "https://api.github.com/users/bmacnaughton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bd12e8cca3f28f302b9cc0f1f47bb64bd1f98fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bd12e8cca3f28f302b9cc0f1f47bb64bd1f98fd", "html_url": "https://github.com/rust-lang/rust/commit/8bd12e8cca3f28f302b9cc0f1f47bb64bd1f98fd"}], "stats": {"total": 110, "additions": 108, "deletions": 2}, "files": [{"sha": "780d32e969c6d11f5238400a398956a7b77a99e8", "filename": "src/tools/unicode-table-generator/src/cascading_map.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d4819632e2d0e135cff3e1987b77ca584e22a41a/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcascading_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4819632e2d0e135cff3e1987b77ca584e22a41a/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcascading_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcascading_map.rs?ref=d4819632e2d0e135cff3e1987b77ca584e22a41a", "patch": "@@ -0,0 +1,90 @@\n+use crate::fmt_list;\n+use crate::raw_emitter::RawEmitter;\n+use std::collections::HashMap;\n+use std::fmt::Write as _;\n+use std::ops::Range;\n+\n+\n+impl RawEmitter {\n+    pub fn emit_cascading_map(&mut self, ranges: &[Range<u32>]) -> bool {\n+\n+        let mut map: [u8; 256] = [\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        ];\n+\n+        let points = ranges.iter().flat_map(\n+            |r| (r.start..r.end).into_iter().collect::<Vec<u32>>()\n+        ).collect::<Vec<u32>>();\n+\n+        println!(\"there are {} points\", points.len());\n+\n+        // how many distinct ranges need to be counted?\n+        let mut codepoints_by_high_bytes = HashMap::<usize, Vec<u32>>::new();\n+        for point in points {\n+            // assert that there is no whitespace over the 0x3000 range.\n+            assert!(point <= 0x3000, \"the highest unicode whitespace value has changed\");\n+            let high_bytes = point as usize >> 8;\n+            let codepoints = codepoints_by_high_bytes.entry(high_bytes).or_insert_with(Vec::new);\n+            codepoints.push(point);\n+        }\n+\n+        let mut bit_for_high_byte = 1u8;\n+        let mut arms = Vec::<String>::new();\n+\n+        let mut high_bytes: Vec<usize> = codepoints_by_high_bytes.keys().map(|k| k.clone()).collect();\n+        high_bytes.sort();\n+        for high_byte in high_bytes {\n+            let codepoints = codepoints_by_high_bytes.get_mut(&high_byte).unwrap();\n+            if codepoints.len() == 1 {\n+                let ch = codepoints.pop().unwrap();\n+                arms.push(format!(\"{} => c as u32 == {:#04x}\", high_byte, ch));\n+                continue;\n+            }\n+            // more than 1 codepoint in this arm\n+            for codepoint in codepoints {\n+                map[(*codepoint & 0xff) as usize] |= bit_for_high_byte;\n+            }\n+            arms.push(format!(\n+                \"{} => WHITESPACE_MAP[c as usize & 0xff] & {} != 0\",\n+                high_byte,\n+                bit_for_high_byte)\n+            );\n+            bit_for_high_byte <<= 1;\n+        }\n+\n+        writeln!(\n+            &mut self.file,\n+            \"static WHITESPACE_MAP: [u8; 256] = [{}];\",\n+            fmt_list(map.iter())\n+        )\n+        .unwrap();\n+        self.bytes_used += 256;\n+\n+\n+        writeln!(&mut self.file, \"pub fn lookup(c: char) -> bool {{\").unwrap();\n+        writeln!(&mut self.file, \"    match c as u32 >> 8 {{\").unwrap();\n+        for arm in arms {\n+            writeln!(&mut self.file, \"        {},\", arm).unwrap();\n+        }\n+        writeln!(&mut self.file, \"        _ => false,\").unwrap();\n+        writeln!(&mut self.file, \"    }}\").unwrap();\n+        writeln!(&mut self.file, \"}}\").unwrap();\n+\n+        true\n+    }\n+}"}, {"sha": "b40afcf4bf2d49dab0d4baf96e434af6653e5b59", "filename": "src/tools/unicode-table-generator/src/main.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4819632e2d0e135cff3e1987b77ca584e22a41a/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4819632e2d0e135cff3e1987b77ca584e22a41a/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs?ref=d4819632e2d0e135cff3e1987b77ca584e22a41a", "patch": "@@ -78,9 +78,10 @@ use ucd_parse::Codepoints;\n mod case_mapping;\n mod raw_emitter;\n mod skiplist;\n+mod cascading_map;\n mod unicode_download;\n \n-use raw_emitter::{emit_codepoints, RawEmitter};\n+use raw_emitter::{emit_codepoints, emit_whitespace, RawEmitter};\n \n static PROPERTIES: &[&str] = &[\n     \"Alphabetic\",\n@@ -241,8 +242,13 @@ fn main() {\n     let mut modules = Vec::new();\n     for (property, ranges) in ranges_by_property {\n         let datapoints = ranges.iter().map(|r| r.end - r.start).sum::<u32>();\n+\n         let mut emitter = RawEmitter::new();\n-        emit_codepoints(&mut emitter, &ranges);\n+        if property == &\"White_Space\" {\n+            emit_whitespace(&mut emitter, &ranges);\n+        } else {\n+            emit_codepoints(&mut emitter, &ranges);\n+        }\n \n         modules.push((property.to_lowercase().to_string(), emitter.file));\n         println!("}, {"sha": "f5960c459200d6550c6235a4584ba1239a131e02", "filename": "src/tools/unicode-table-generator/src/raw_emitter.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4819632e2d0e135cff3e1987b77ca584e22a41a/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4819632e2d0e135cff3e1987b77ca584e22a41a/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fraw_emitter.rs?ref=d4819632e2d0e135cff3e1987b77ca584e22a41a", "patch": "@@ -170,6 +170,16 @@ pub fn emit_codepoints(emitter: &mut RawEmitter, ranges: &[Range<u32>]) {\n     }\n }\n \n+pub fn emit_whitespace(emitter: &mut RawEmitter, ranges: &[Range<u32>]) {\n+    emitter.blank_line();\n+\n+    let mut cascading = emitter.clone();\n+    cascading.emit_cascading_map(&ranges);\n+    *emitter = cascading;\n+    emitter.desc = String::from(\"cascading\");\n+\n+}\n+\n struct Canonicalized {\n     canonical_words: Vec<u64>,\n     canonicalized_words: Vec<(u8, u8)>,"}]}