{"sha": "b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NWQ3NzI5YzJjYzc0MDE2MDA5MTVlZDRiMTdjMjkxZmUwZGQ4YzI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-26T03:37:21Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-26T08:12:03Z"}, "message": "Rollup merge of #32435 - nrc:fix-err-recover, r=nikomatsakis\n\nSome fixes for error recovery in the compiler", "tree": {"sha": "9461cc106159a529719e826e096059333dfbb0d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9461cc106159a529719e826e096059333dfbb0d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "html_url": "https://github.com/rust-lang/rust/commit/b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8d59e0ca62a47e87bf4b5288b9aaf586ae3c640", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d59e0ca62a47e87bf4b5288b9aaf586ae3c640", "html_url": "https://github.com/rust-lang/rust/commit/a8d59e0ca62a47e87bf4b5288b9aaf586ae3c640"}, {"sha": "180d6b55ca19c63347664f0622b6ccc37fb101f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/180d6b55ca19c63347664f0622b6ccc37fb101f5", "html_url": "https://github.com/rust-lang/rust/commit/180d6b55ca19c63347664f0622b6ccc37fb101f5"}], "stats": {"total": 193, "additions": 162, "deletions": 31}, "files": [{"sha": "82715f263c96db0a58d91ac08447389f3f095841", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "patch": "@@ -268,8 +268,8 @@ pub struct Parser<'a> {\n     /// Used to determine the path to externally loaded source files\n     pub filename: Option<String>,\n     pub mod_path_stack: Vec<InternedString>,\n-    /// Stack of spans of open delimiters. Used for error message.\n-    pub open_braces: Vec<Span>,\n+    /// Stack of open delimiters and their spans. Used for error message.\n+    pub open_braces: Vec<(token::DelimToken, Span)>,\n     /// Flag if this parser \"owns\" the directory that it is currently parsing\n     /// in. This will affect how nested files are looked up.\n     pub owns_directory: bool,\n@@ -895,7 +895,7 @@ impl<'a> Parser<'a> {\n                                          sep: SeqSep,\n                                          f: F)\n                                          -> Vec<T>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>\n     {\n         self.parse_seq_to_before_tokens(&[ket], sep, f, |mut e| e.emit())\n     }\n@@ -2755,8 +2755,8 @@ impl<'a> Parser<'a> {\n                 let mut err: DiagnosticBuilder<'a> =\n                     self.diagnostic().struct_span_err(self.span,\n                                                       \"this file contains an un-closed delimiter\");\n-                for sp in &self.open_braces {\n-                    err.span_help(*sp, \"did you mean to close this delimiter?\");\n+                for &(_, sp) in &self.open_braces {\n+                    err.span_help(sp, \"did you mean to close this delimiter?\");\n                 }\n \n                 Err(err)\n@@ -2766,23 +2766,66 @@ impl<'a> Parser<'a> {\n                 let pre_span = self.span;\n \n                 // Parse the open delimiter.\n-                self.open_braces.push(self.span);\n+                self.open_braces.push((delim, self.span));\n                 let open_span = self.span;\n                 self.bump();\n \n-                // Parse the token trees within the delimiters\n-                let tts = self.parse_seq_to_before_end(&token::CloseDelim(delim),\n-                                                       SeqSep::none(),\n-                                                       |p| p.parse_token_tree());\n+                // Parse the token trees within the delimiters.\n+                // We stop at any delimiter so we can try to recover if the user\n+                // uses an incorrect delimiter.\n+                let tts = self.parse_seq_to_before_tokens(&[&token::CloseDelim(token::Brace),\n+                                                            &token::CloseDelim(token::Paren),\n+                                                            &token::CloseDelim(token::Bracket)],\n+                                                          SeqSep::none(),\n+                                                          |p| p.parse_token_tree(),\n+                                                          |mut e| e.emit());\n \n-                // Parse the close delimiter.\n                 let close_span = self.span;\n-                self.bump();\n-                self.open_braces.pop().unwrap();\n-\n                 // Expand to cover the entire delimited token tree\n                 let span = Span { hi: close_span.hi, ..pre_span };\n \n+                match self.token {\n+                    // Correct delmiter.\n+                    token::CloseDelim(d) if d == delim => {\n+                        self.open_braces.pop().unwrap();\n+\n+                        // Parse the close delimiter.\n+                        self.bump();\n+                    }\n+                    // Incorect delimiter.\n+                    token::CloseDelim(other) => {\n+                        let token_str = self.this_token_to_string();\n+                        let mut err = self.diagnostic().struct_span_err(self.span,\n+                            &format!(\"incorrect close delimiter: `{}`\", token_str));\n+                        // This is a conservative error: only report the last unclosed delimiter.\n+                        // The previous unclosed delimiters could actually be closed! The parser\n+                        // just hasn't gotten to them yet.\n+                        if let Some(&(_, sp)) = self.open_braces.last() {\n+                            err.span_note(sp, \"unclosed delimiter\");\n+                        };\n+                        err.emit();\n+\n+                        self.open_braces.pop().unwrap();\n+\n+                        // If the incorrect delimter matches an earlier opening\n+                        // delimiter, then don't consume it (it can be used to\n+                        // close the earlier one)Otherwise, consume it.\n+                        // E.g., we try to recover from:\n+                        // fn foo() {\n+                        //     bar(baz(\n+                        // }  // Incorrect delimiter but matches the earlier `{`\n+                        if !self.open_braces.iter().any(|&(b, _)| b == other) {\n+                            self.bump();\n+                        }\n+                    }\n+                    token::Eof => {\n+                        // Silently recover, the EOF token will be seen again\n+                        // and an error emitted then. Thus we don't pop from\n+                        // self.open_braces here.\n+                    },\n+                    _ => unreachable!(),\n+                }\n+\n                 Ok(TokenTree::Delimited(span, Rc::new(Delimited {\n                     delim: delim,\n                     open_span: open_span,\n@@ -2798,16 +2841,11 @@ impl<'a> Parser<'a> {\n                 maybe_whole!(deref self, NtTT);\n                 match self.token {\n                     token::CloseDelim(_) => {\n+                        // An unexpected closing delimiter (i.e., there is no\n+                        // matching opening delimiter).\n                         let token_str = self.this_token_to_string();\n-                        let mut err = self.diagnostic().struct_span_err(self.span,\n-                            &format!(\"incorrect close delimiter: `{}`\", token_str));\n-                        // This is a conservative error: only report the last unclosed delimiter.\n-                        // The previous unclosed delimiters could actually be closed! The parser\n-                        // just hasn't gotten to them yet.\n-                        if let Some(&sp) = self.open_braces.last() {\n-                            err.span_note(sp, \"unclosed delimiter\");\n-                        };\n-\n+                        let err = self.diagnostic().struct_span_err(self.span,\n+                            &format!(\"unexpected close delimiter: `{}`\", token_str));\n                         Err(err)\n                     },\n                     /* we ought to allow different depths of unquotation */\n@@ -3825,7 +3863,9 @@ impl<'a> Parser<'a> {\n     fn recover_stmt_(&mut self, break_on_semi: SemiColonMode) {\n         let mut brace_depth = 0;\n         let mut bracket_depth = 0;\n+        debug!(\"recover_stmt_ enter loop\");\n         loop {\n+            debug!(\"recover_stmt_ loop {:?}\", self.token);\n             match self.token {\n                 token::OpenDelim(token::DelimToken::Brace) => {\n                     brace_depth += 1;\n@@ -3837,6 +3877,7 @@ impl<'a> Parser<'a> {\n                 }\n                 token::CloseDelim(token::DelimToken::Brace) => {\n                     if brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n                         return;\n                     }\n                     brace_depth -= 1;\n@@ -3849,12 +3890,16 @@ impl<'a> Parser<'a> {\n                     }\n                     self.bump();\n                 }\n-                token::Eof => return,\n+                token::Eof => {\n+                    debug!(\"recover_stmt_ return - Eof\");\n+                    return;\n+                }\n                 token::Semi => {\n                     self.bump();\n                     if break_on_semi == SemiColonMode::Break &&\n                        brace_depth == 0 &&\n                        bracket_depth == 0 {\n+                        debug!(\"recover_stmt_ return - Semi\");\n                         return;\n                     }\n                 }\n@@ -4043,6 +4088,8 @@ impl<'a> Parser<'a> {\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n             let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n                 s\n+            } else if self.token == token::Eof {\n+                break;\n             } else {\n                 // Found only `;` or `}`.\n                 continue;"}, {"sha": "eaccaf3cdbd27c6e4f51ba747555bd06d5c6b375", "filename": "src/test/compile-fail/issue-10636-2.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs?ref=b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,11 +11,9 @@\n // FIXME(31528) we emit a bunch of silly errors here due to continuing past the\n // first one. This would be easy-ish to address by better recovery in tokenisation.\n \n-// compile-flags: -Z parse-only\n-\n-pub fn trace_option(option: Option<isize>) { //~ HELP did you mean to close this delimiter?\n+pub fn trace_option(option: Option<isize>) {\n     option.map(|some| 42; //~ NOTE: unclosed delimiter\n                           //~^ ERROR: expected one of\n+                          //~^^ ERROR: mismatched types\n } //~ ERROR: incorrect close delimiter\n //~^ ERROR: expected one of\n-//~ ERROR: this file contains an un-closed delimiter", "previous_filename": "src/test/parse-fail/issue-10636-2.rs"}, {"sha": "b6a04bee85d4faada3cd72a60121f4043e3b2474", "filename": "src/test/compile-fail/issue-31804.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs?ref=b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that error recovery in the parser to an EOF does not give an infinite\n+// spew of errors.\n+\n+fn main() {\n+    let\n+} //~ ERROR unexpected token: `}`"}, {"sha": "ab429ab878073c02585aa91f7e87b0f2d56db446", "filename": "src/test/compile-fail/token-error-correct-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-2.rs?ref=b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do some basic error correcton in the tokeniser (and don't ICE).\n+\n+fn main() {\n+    if foo { //~ NOTE: unclosed delimiter\n+    //~^ ERROR: unresolved name `foo`\n+    ) //~ ERROR: incorrect close delimiter: `)`\n+}"}, {"sha": "fe8c9f690139f65a3b72991504f571cc59bd3609", "filename": "src/test/compile-fail/token-error-correct-3.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs?ref=b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do some basic error correcton in the tokeniser (and don't spew\n+// too many bogus errors).\n+\n+pub mod raw {\n+    use std::{io, fs};\n+    use std::path::Path;\n+\n+    pub fn ensure_dir_exists<P: AsRef<Path>, F: FnOnce(&Path)>(path: P,\n+                                                               callback: F)\n+                                                               -> io::Result<bool> {\n+        if !is_directory(path.as_ref()) { //~ ERROR: unresolved name `is_directory`\n+            callback(path.as_ref();  //~ NOTE: unclosed delimiter\n+                     //~^ ERROR: expected one of\n+            fs::create_dir_all(path.as_ref()).map(|()| true) //~ ERROR: expected one of\n+        } else { //~ ERROR: incorrect close delimiter: `}`\n+            Ok(false);\n+        }\n+\n+        panic!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6c54acd7bdbf60827ec5a665ac15d29b0a6ce12f", "filename": "src/test/compile-fail/token-error-correct.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs?ref=b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do some basic error correcton in the tokeniser.\n+\n+fn main() {\n+    foo(bar(; //~ NOTE: unclosed delimiter\n+    //~^ NOTE: unclosed delimiter\n+    //~^^ ERROR: unexpected token: `;`\n+    //~^^^ ERROR: unresolved name `bar`\n+    //~^^^^ ERROR: unresolved name `foo`\n+} //~ ERROR: incorrect close delimiter: `}`\n+//~^ ERROR: incorrect close delimiter: `}`"}, {"sha": "f24c544073578ff07def143413cec0e14cfaf49b", "filename": "src/test/parse-fail/issue-2354-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fparse-fail%2Fissue-2354-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fparse-fail%2Fissue-2354-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-2354-1.rs?ref=b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-static foo: isize = 2; } //~ ERROR incorrect close delimiter:\n+static foo: isize = 2; } //~ ERROR unexpected close delimiter:"}, {"sha": "cbc0ed0ccdb84760bb98e6f69f68d5e15c574806", "filename": "src/test/parse-fail/macro-mismatched-delim-paren-brace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fparse-fail%2Fmacro-mismatched-delim-paren-brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b55d7729c2cc7401600915ed4b17c291fe0dd8c2/src%2Ftest%2Fparse-fail%2Fmacro-mismatched-delim-paren-brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmacro-mismatched-delim-paren-brace.rs?ref=b55d7729c2cc7401600915ed4b17c291fe0dd8c2", "patch": "@@ -14,4 +14,4 @@ fn main() {\n     foo! (\n         bar, \"baz\", 1, 2.0\n     } //~ ERROR incorrect close delimiter\n-}\n+} //~ ERROR unexpected close delimiter: `}`"}]}