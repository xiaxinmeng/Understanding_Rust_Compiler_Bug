{"sha": "b812b77094adf7a6a0daf8495718f44fbcaf5daa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MTJiNzcwOTRhZGY3YTZhMGRhZjg0OTU3MThmNDRmYmNhZjVkYWE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-01T07:33:33Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-01T17:29:41Z"}, "message": "Rollup merge of #48585 - stjepang:stabilize-localkey-try_with, r=alexcrichton\n\nStabilize LocalKey::try_with\n\nThe `LocalKey::try_with` method is now stabilized.\n\n`LocalKey::state` and `LocalKeyState` marked as deprecated. Although, is there any reason to keep them - should we perhaps remove them completely?\n\nCloses #27716\n\nr? @alexcrichton", "tree": {"sha": "0b4603e0384ee0e18b5d4e103693338e88b63445", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b4603e0384ee0e18b5d4e103693338e88b63445"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b812b77094adf7a6a0daf8495718f44fbcaf5daa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b812b77094adf7a6a0daf8495718f44fbcaf5daa", "html_url": "https://github.com/rust-lang/rust/commit/b812b77094adf7a6a0daf8495718f44fbcaf5daa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b812b77094adf7a6a0daf8495718f44fbcaf5daa/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8025e1555c60e5f542ab4541a55ca540495290f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8025e1555c60e5f542ab4541a55ca540495290f7", "html_url": "https://github.com/rust-lang/rust/commit/8025e1555c60e5f542ab4541a55ca540495290f7"}, {"sha": "cb56b2d1522e83c5bb0613abcf78b686e994df9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb56b2d1522e83c5bb0613abcf78b686e994df9e", "html_url": "https://github.com/rust-lang/rust/commit/cb56b2d1522e83c5bb0613abcf78b686e994df9e"}], "stats": {"total": 184, "additions": 43, "deletions": 141}, "files": [{"sha": "1f73054e3beed01f7e93b253a442992b57b66407", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=b812b77094adf7a6a0daf8495718f44fbcaf5daa", "patch": "@@ -17,7 +17,7 @@ use io::{self, Initializer, BufReader, LineWriter};\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n-use thread::{LocalKey, LocalKeyState};\n+use thread::LocalKey;\n \n /// Stdout used by print! and println! macros\n thread_local! {\n@@ -663,29 +663,31 @@ pub fn set_print(sink: Option<Box<Write + Send>>) -> Option<Box<Write + Send>> {\n ///\n /// This function is used to print error messages, so it takes extra\n /// care to avoid causing a panic when `local_stream` is unusable.\n-/// For instance, if the TLS key for the local stream is uninitialized\n-/// or already destroyed, or if the local stream is locked by another\n+/// For instance, if the TLS key for the local stream is\n+/// already destroyed, or if the local stream is locked by another\n /// thread, it will just fall back to the global stream.\n ///\n /// However, if the actual I/O causes an error, this function does panic.\n-fn print_to<T>(args: fmt::Arguments,\n-               local_s: &'static LocalKey<RefCell<Option<Box<Write+Send>>>>,\n-               global_s: fn() -> T,\n-               label: &str) where T: Write {\n-    let result = match local_s.state() {\n-        LocalKeyState::Uninitialized |\n-        LocalKeyState::Destroyed => global_s().write_fmt(args),\n-        LocalKeyState::Valid => {\n-            local_s.with(|s| {\n-                if let Ok(mut borrowed) = s.try_borrow_mut() {\n-                    if let Some(w) = borrowed.as_mut() {\n-                        return w.write_fmt(args);\n-                    }\n-                }\n-                global_s().write_fmt(args)\n-            })\n+fn print_to<T>(\n+    args: fmt::Arguments,\n+    local_s: &'static LocalKey<RefCell<Option<Box<Write+Send>>>>,\n+    global_s: fn() -> T,\n+    label: &str,\n+)\n+where\n+    T: Write,\n+{\n+    let result = local_s.try_with(|s| {\n+        if let Ok(mut borrowed) = s.try_borrow_mut() {\n+            if let Some(w) = borrowed.as_mut() {\n+                return w.write_fmt(args);\n+            }\n         }\n-    };\n+        global_s().write_fmt(args)\n+    }).unwrap_or_else(|_| {\n+        global_s().write_fmt(args)\n+    });\n+\n     if let Err(e) = result {\n         panic!(\"failed printing to {}: {}\", label, e);\n     }"}, {"sha": "99479bc56eff30ed9388c04d14168ed90174f331", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 15, "deletions": 113, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=b812b77094adf7a6a0daf8495718f44fbcaf5daa", "patch": "@@ -195,64 +195,20 @@ macro_rules! __thread_local_inner {\n     }\n }\n \n-/// Indicator of the state of a thread local storage key.\n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n-#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n-pub enum LocalKeyState {\n-    /// All keys are in this state whenever a thread starts. Keys will\n-    /// transition to the `Valid` state once the first call to [`with`] happens\n-    /// and the initialization expression succeeds.\n-    ///\n-    /// Keys in the `Uninitialized` state will yield a reference to the closure\n-    /// passed to [`with`] so long as the initialization routine does not panic.\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Uninitialized,\n-\n-    /// Once a key has been accessed successfully, it will enter the `Valid`\n-    /// state. Keys in the `Valid` state will remain so until the thread exits,\n-    /// at which point the destructor will be run and the key will enter the\n-    /// `Destroyed` state.\n-    ///\n-    /// Keys in the `Valid` state will be guaranteed to yield a reference to the\n-    /// closure passed to [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Valid,\n-\n-    /// When a thread exits, the destructors for keys will be run (if\n-    /// necessary). While a destructor is running, and possibly after a\n-    /// destructor has run, a key is in the `Destroyed` state.\n-    ///\n-    /// Keys in the `Destroyed` states will trigger a panic when accessed via\n-    /// [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Destroyed,\n-}\n-\n /// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n+#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n pub struct AccessError {\n     _private: (),\n }\n \n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n+#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n impl fmt::Debug for AccessError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"AccessError\").finish()\n     }\n }\n \n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n+#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n impl fmt::Display for AccessError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(\"already destroyed\", f)\n@@ -312,64 +268,21 @@ impl<T: 'static> LocalKey<T> {\n         (*ptr).as_ref().unwrap()\n     }\n \n-    /// Query the current state of this key.\n-    ///\n-    /// A key is initially in the `Uninitialized` state whenever a thread\n-    /// starts. It will remain in this state up until the first call to [`with`]\n-    /// within a thread has run the initialization expression successfully.\n-    ///\n-    /// Once the initialization expression succeeds, the key transitions to the\n-    /// `Valid` state which will guarantee that future calls to [`with`] will\n-    /// succeed within the thread. Some keys might skip the `Uninitialized`\n-    /// state altogether and start in the `Valid` state as an optimization\n-    /// (e.g. keys initialized with a constant expression), but no guarantees\n-    /// are made.\n-    ///\n-    /// When a thread exits, each key will be destroyed in turn, and as keys are\n-    /// destroyed they will enter the `Destroyed` state just before the\n-    /// destructor starts to run. Keys may remain in the `Destroyed` state after\n-    /// destruction has completed. Keys without destructors (e.g. with types\n-    /// that are [`Copy`]), may never enter the `Destroyed` state.\n-    ///\n-    /// Keys in the `Uninitialized` state can be accessed so long as the\n-    /// initialization does not panic. Keys in the `Valid` state are guaranteed\n-    /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n-    /// any call to [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    /// [`Copy`]: ../../std/marker/trait.Copy.html\n-    #[unstable(feature = \"thread_local_state\",\n-               reason = \"state querying was recently added\",\n-               issue = \"27716\")]\n-    pub fn state(&'static self) -> LocalKeyState {\n-        unsafe {\n-            match (self.inner)() {\n-                Some(cell) => {\n-                    match *cell.get() {\n-                        Some(..) => LocalKeyState::Valid,\n-                        None => LocalKeyState::Uninitialized,\n-                    }\n-                }\n-                None => LocalKeyState::Destroyed,\n-            }\n-        }\n-    }\n-\n     /// Acquires a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n     /// this key yet. If the key has been destroyed (which may happen if this is called\n-    /// in a destructor), this function will return a ThreadLocalError.\n+    /// in a destructor), this function will return a `ThreadLocalError`.\n     ///\n     /// # Panics\n     ///\n     /// This function will still `panic!()` if the key is uninitialized and the\n     /// key's initializer panics.\n-    #[unstable(feature = \"thread_local_state\",\n-               reason = \"state querying was recently added\",\n-               issue = \"27716\")]\n+    #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n     pub fn try_with<F, R>(&'static self, f: F) -> Result<R, AccessError>\n-                      where F: FnOnce(&T) -> R {\n+    where\n+        F: FnOnce(&T) -> R,\n+    {\n         unsafe {\n             let slot = (self.inner)().ok_or(AccessError {\n                 _private: (),\n@@ -530,7 +443,6 @@ pub mod os {\n mod tests {\n     use sync::mpsc::{channel, Sender};\n     use cell::{Cell, UnsafeCell};\n-    use super::LocalKeyState;\n     use thread;\n \n     struct Foo(Sender<()>);\n@@ -569,21 +481,13 @@ mod tests {\n         struct Foo;\n         impl Drop for Foo {\n             fn drop(&mut self) {\n-                assert!(FOO.state() == LocalKeyState::Destroyed);\n+                assert!(FOO.try_with(|_| ()).is_err());\n             }\n         }\n-        fn foo() -> Foo {\n-            assert!(FOO.state() == LocalKeyState::Uninitialized);\n-            Foo\n-        }\n-        thread_local!(static FOO: Foo = foo());\n+        thread_local!(static FOO: Foo = Foo);\n \n         thread::spawn(|| {\n-            assert!(FOO.state() == LocalKeyState::Uninitialized);\n-            FOO.with(|_| {\n-                assert!(FOO.state() == LocalKeyState::Valid);\n-            });\n-            assert!(FOO.state() == LocalKeyState::Valid);\n+            assert!(FOO.try_with(|_| ()).is_ok());\n         }).join().ok().unwrap();\n     }\n \n@@ -613,7 +517,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    if K2.state() == LocalKeyState::Destroyed {\n+                    if K2.try_with(|_| ()).is_err() {\n                         assert_eq!(HITS, 3);\n                     } else {\n                         if HITS == 1 {\n@@ -629,7 +533,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    assert!(K1.state() != LocalKeyState::Destroyed);\n+                    assert!(K1.try_with(|_| ()).is_ok());\n                     assert_eq!(HITS, 2);\n                     K1.with(|s| *s.get() = Some(S1));\n                 }\n@@ -648,7 +552,7 @@ mod tests {\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n-                assert!(K1.state() == LocalKeyState::Destroyed);\n+                assert!(K1.try_with(|_| ()).is_err());\n             }\n         }\n \n@@ -672,9 +576,7 @@ mod tests {\n             fn drop(&mut self) {\n                 let S1(ref tx) = *self;\n                 unsafe {\n-                    if K2.state() != LocalKeyState::Destroyed {\n-                        K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n-                    }\n+                    let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n                 }\n             }\n         }"}, {"sha": "71aee673cfe3ee57e7893a54c1e1823493713693", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=b812b77094adf7a6a0daf8495718f44fbcaf5daa", "patch": "@@ -191,7 +191,7 @@ use time::Duration;\n #[macro_use] mod local;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::local::{LocalKey, LocalKeyState, AccessError};\n+pub use self::local::{LocalKey, AccessError};\n \n // The types used by the thread_local! macro to access TLS keys. Note that there\n // are two types, the \"OS\" type and the \"fast\" type. The OS thread local key"}, {"sha": "48a0d4a99ecc9e97a5e15d8bd6f55e6b2751ddb3", "filename": "src/test/run-pass/tls-init-on-init.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Ftest%2Frun-pass%2Ftls-init-on-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Ftest%2Frun-pass%2Ftls-init-on-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftls-init-on-init.rs?ref=b812b77094adf7a6a0daf8495718f44fbcaf5daa", "patch": "@@ -10,9 +10,9 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(thread_local_state)]\n+#![feature(thread_local_try_with)]\n \n-use std::thread::{self, LocalKeyState};\n+use std::thread;\n use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n struct Foo { cnt: usize }\n@@ -37,10 +37,8 @@ impl Drop for Foo {\n             FOO.with(|foo| assert_eq!(foo.cnt, 0));\n         } else {\n             assert_eq!(self.cnt, 0);\n-            match FOO.state() {\n-                LocalKeyState::Valid => panic!(\"should not be in valid state\"),\n-                LocalKeyState::Uninitialized |\n-                LocalKeyState::Destroyed => {}\n+            if FOO.try_with(|_| ()).is_ok() {\n+                panic!(\"should not be in valid state\");\n             }\n         }\n     }"}, {"sha": "552f4c5e829e157655c6b4f8b7ba1c6d18239409", "filename": "src/test/run-pass/tls-try-with.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Ftest%2Frun-pass%2Ftls-try-with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b812b77094adf7a6a0daf8495718f44fbcaf5daa/src%2Ftest%2Frun-pass%2Ftls-try-with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftls-try-with.rs?ref=b812b77094adf7a6a0daf8495718f44fbcaf5daa", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(thread_local_state)]\n+#![feature(thread_local_try_with)]\n \n use std::thread;\n "}]}