{"sha": "7abab1efb21617ba6845fa86328dffa16cfcf1dc", "node_id": "C_kwDOAAsO6NoAKDdhYmFiMWVmYjIxNjE3YmE2ODQ1ZmE4NjMyOGRmZmExNmNmY2YxZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-17T19:17:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-17T19:17:29Z"}, "message": "Auto merge of #91838 - scottmcm:array-slice-eq-via-arrays-not-slices, r=dtolnay\n\nDo array-slice equality via array equality, rather than always via slices\n\n~~Draft because it needs a rebase after #91766 eventually gets through bors.~~\n\nThis enables the optimizations from #85828 to be used for array-to-slice comparisons too, not just array-to-array.\n\nFor example, <https://play.rust-lang.org/?version=nightly&mode=release&edition=2021&gist=5f9ba69b3d5825a782f897c830d3a6aa>\n```rust\npub fn demo(x: &[u8], y: [u8; 4]) -> bool {\n    *x == y\n}\n```\nCurrently writes the array to stack for no reason:\n```nasm\n\tsub\trsp, 4\n\tmov\tdword ptr [rsp], edx\n\tcmp\trsi, 4\n\tjne\t.LBB0_1\n\tmov\teax, dword ptr [rdi]\n\tcmp\teax, dword ptr [rsp]\n\tsete\tal\n\tadd\trsp, 4\n\tret\n\n.LBB0_1:\n\txor\teax, eax\n\tadd\trsp, 4\n\tret\n```\nWhereas with the change in this PR it just compares it directly:\n```nasm\n\tcmp\trsi, 4\n\tjne\t.LBB1_1\n\tcmp\tdword ptr [rdi], edx\n\tsete\tal\n\tret\n\n.LBB1_1:\n\txor\teax, eax\n\tret\n```", "tree": {"sha": "ab4bcc70374e8b52eadd3280497a97b5a3598c0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab4bcc70374e8b52eadd3280497a97b5a3598c0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7abab1efb21617ba6845fa86328dffa16cfcf1dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7abab1efb21617ba6845fa86328dffa16cfcf1dc", "html_url": "https://github.com/rust-lang/rust/commit/7abab1efb21617ba6845fa86328dffa16cfcf1dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7abab1efb21617ba6845fa86328dffa16cfcf1dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34dc0d0f249a33fda18755991b4e73ad786d2b19", "url": "https://api.github.com/repos/rust-lang/rust/commits/34dc0d0f249a33fda18755991b4e73ad786d2b19", "html_url": "https://github.com/rust-lang/rust/commit/34dc0d0f249a33fda18755991b4e73ad786d2b19"}, {"sha": "a0b96902e4c622d40c7186fc0c7ba13efc1fc912", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0b96902e4c622d40c7186fc0c7ba13efc1fc912", "html_url": "https://github.com/rust-lang/rust/commit/a0b96902e4c622d40c7186fc0c7ba13efc1fc912"}], "stats": {"total": 104, "additions": 89, "deletions": 15}, "files": [{"sha": "33f7f494e9d8443e46552e2a0dd3ef8f41ee6b03", "filename": "library/core/src/array/equality.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7abab1efb21617ba6845fa86328dffa16cfcf1dc/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abab1efb21617ba6845fa86328dffa16cfcf1dc/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fequality.rs?ref=7abab1efb21617ba6845fa86328dffa16cfcf1dc", "patch": "@@ -1,3 +1,4 @@\n+use crate::convert::TryInto;\n use crate::num::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n use crate::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n \n@@ -23,11 +24,19 @@ where\n {\n     #[inline]\n     fn eq(&self, other: &[B]) -> bool {\n-        self[..] == other[..]\n+        let b: Result<&[B; N], _> = other.try_into();\n+        match b {\n+            Ok(b) => *self == *b,\n+            Err(_) => false,\n+        }\n     }\n     #[inline]\n     fn ne(&self, other: &[B]) -> bool {\n-        self[..] != other[..]\n+        let b: Result<&[B; N], _> = other.try_into();\n+        match b {\n+            Ok(b) => *self != *b,\n+            Err(_) => true,\n+        }\n     }\n }\n \n@@ -38,11 +47,19 @@ where\n {\n     #[inline]\n     fn eq(&self, other: &[A; N]) -> bool {\n-        self[..] == other[..]\n+        let b: Result<&[B; N], _> = self.try_into();\n+        match b {\n+            Ok(b) => *b == *other,\n+            Err(_) => false,\n+        }\n     }\n     #[inline]\n     fn ne(&self, other: &[A; N]) -> bool {\n-        self[..] != other[..]\n+        let b: Result<&[B; N], _> = self.try_into();\n+        match b {\n+            Ok(b) => *b != *other,\n+            Err(_) => true,\n+        }\n     }\n }\n \n@@ -53,11 +70,11 @@ where\n {\n     #[inline]\n     fn eq(&self, other: &&[B]) -> bool {\n-        self[..] == other[..]\n+        *self == **other\n     }\n     #[inline]\n     fn ne(&self, other: &&[B]) -> bool {\n-        self[..] != other[..]\n+        *self != **other\n     }\n }\n \n@@ -68,11 +85,11 @@ where\n {\n     #[inline]\n     fn eq(&self, other: &[A; N]) -> bool {\n-        self[..] == other[..]\n+        **self == *other\n     }\n     #[inline]\n     fn ne(&self, other: &[A; N]) -> bool {\n-        self[..] != other[..]\n+        **self != *other\n     }\n }\n \n@@ -83,11 +100,11 @@ where\n {\n     #[inline]\n     fn eq(&self, other: &&mut [B]) -> bool {\n-        self[..] == other[..]\n+        *self == **other\n     }\n     #[inline]\n     fn ne(&self, other: &&mut [B]) -> bool {\n-        self[..] != other[..]\n+        *self != **other\n     }\n }\n \n@@ -98,11 +115,11 @@ where\n {\n     #[inline]\n     fn eq(&self, other: &[A; N]) -> bool {\n-        self[..] == other[..]\n+        **self == *other\n     }\n     #[inline]\n     fn ne(&self, other: &[A; N]) -> bool {\n-        self[..] != other[..]\n+        **self != *other\n     }\n }\n "}, {"sha": "a778779c0fd88e6b910bba1af853dde9b69928c9", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7abab1efb21617ba6845fa86328dffa16cfcf1dc/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abab1efb21617ba6845fa86328dffa16cfcf1dc/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=7abab1efb21617ba6845fa86328dffa16cfcf1dc", "patch": "@@ -624,3 +624,47 @@ fn array_intoiter_advance_back_by() {\n     assert_eq!(it.len(), 0);\n     assert_eq!(counter.get(), 100);\n }\n+\n+#[test]\n+fn array_mixed_equality_integers() {\n+    let array3: [i32; 3] = [1, 2, 3];\n+    let array3b: [i32; 3] = [3, 2, 1];\n+    let array4: [i32; 4] = [1, 2, 3, 4];\n+\n+    let slice3: &[i32] = &{ array3 };\n+    let slice3b: &[i32] = &{ array3b };\n+    let slice4: &[i32] = &{ array4 };\n+    assert!(array3 == slice3);\n+    assert!(array3 != slice3b);\n+    assert!(array3 != slice4);\n+    assert!(slice3 == array3);\n+    assert!(slice3b != array3);\n+    assert!(slice4 != array3);\n+\n+    let mut3: &mut [i32] = &mut { array3 };\n+    let mut3b: &mut [i32] = &mut { array3b };\n+    let mut4: &mut [i32] = &mut { array4 };\n+    assert!(array3 == mut3);\n+    assert!(array3 != mut3b);\n+    assert!(array3 != mut4);\n+    assert!(mut3 == array3);\n+    assert!(mut3b != array3);\n+    assert!(mut4 != array3);\n+}\n+\n+#[test]\n+fn array_mixed_equality_nans() {\n+    let array3: [f32; 3] = [1.0, std::f32::NAN, 3.0];\n+\n+    let slice3: &[f32] = &{ array3 };\n+    assert!(!(array3 == slice3));\n+    assert!(array3 != slice3);\n+    assert!(!(slice3 == array3));\n+    assert!(slice3 != array3);\n+\n+    let mut3: &mut [f32] = &mut { array3 };\n+    assert!(!(array3 == mut3));\n+    assert!(array3 != mut3);\n+    assert!(!(mut3 == array3));\n+    assert!(mut3 != array3);\n+}"}, {"sha": "c06554ecdec221e7c22d2e7bdfe7979926d21cc7", "filename": "src/test/codegen/slice-ref-equality.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7abab1efb21617ba6845fa86328dffa16cfcf1dc/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abab1efb21617ba6845fa86328dffa16cfcf1dc/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs?ref=7abab1efb21617ba6845fa86328dffa16cfcf1dc", "patch": "@@ -4,18 +4,31 @@\n \n // #71602 reported a simple array comparison just generating a loop.\n // This was originally fixed by ensuring it generates a single bcmp,\n-// but we now generate it as a load instead. `is_zero_slice` was\n+// but we now generate it as a load+icmp instead. `is_zero_slice` was\n // tweaked to still test the case of comparison against a slice,\n // and `is_zero_array` tests the new array-specific behaviour.\n+// The optimization was then extended to short slice-to-array comparisons,\n+// so the first test here now has a long slice to still get the bcmp.\n \n-// CHECK-LABEL: @is_zero_slice\n+// CHECK-LABEL: @is_zero_slice_long\n #[no_mangle]\n-pub fn is_zero_slice(data: &[u8; 4]) -> bool {\n+pub fn is_zero_slice_long(data: &[u8; 456]) -> bool {\n     // CHECK: :\n     // CHECK-NEXT: %{{.+}} = getelementptr {{.+}}\n     // CHECK-NEXT: %[[BCMP:.+]] = tail call i32 @{{bcmp|memcmp}}({{.+}})\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[BCMP]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n+    &data[..] == [0; 456]\n+}\n+\n+// CHECK-LABEL: @is_zero_slice_short\n+#[no_mangle]\n+pub fn is_zero_slice_short(data: &[u8; 4]) -> bool {\n+    // CHECK: :\n+    // CHECK-NEXT: %[[PTR:.+]] = bitcast [4 x i8]* {{.+}} to i32*\n+    // CHECK-NEXT: %[[LOAD:.+]] = load i32, i32* %[[PTR]], align 1\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[LOAD]], 0\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n     &data[..] == [0; 4]\n }\n "}]}