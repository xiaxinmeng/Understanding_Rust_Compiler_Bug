{"sha": "5fd5d524b75d123eda841fbb86af1b5916b6081b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZDVkNTI0Yjc1ZDEyM2VkYTg0MWZiYjg2YWYxYjU5MTZiNjA4MWI=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-10-02T20:01:57Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-30T14:17:27Z"}, "message": "WIP intrinsics", "tree": {"sha": "5c8b0d18308635209e36741d27c36323cb51e9e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c8b0d18308635209e36741d27c36323cb51e9e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fd5d524b75d123eda841fbb86af1b5916b6081b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd5d524b75d123eda841fbb86af1b5916b6081b", "html_url": "https://github.com/rust-lang/rust/commit/5fd5d524b75d123eda841fbb86af1b5916b6081b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fd5d524b75d123eda841fbb86af1b5916b6081b/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a3704c50044a0e9d611a264daeabbf47d398474", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3704c50044a0e9d611a264daeabbf47d398474", "html_url": "https://github.com/rust-lang/rust/commit/7a3704c50044a0e9d611a264daeabbf47d398474"}], "stats": {"total": 623, "additions": 623, "deletions": 0}, "files": [{"sha": "a7345f169c55b0aaf40db6f5ddbdad95ff8354ff", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 623, "deletions": 0, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/5fd5d524b75d123eda841fbb86af1b5916b6081b/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd5d524b75d123eda841fbb86af1b5916b6081b/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=5fd5d524b75d123eda841fbb86af1b5916b6081b", "patch": "@@ -17,3 +17,626 @@\n #![crate_name = \"compiler_builtins\"]\n #![crate_type = \"rlib\"]\n #![feature(staged_api)]\n+#![feature(core_intrinsics)]\n+#![feature(core_float)]\n+#![feature(associated_consts)]\n+#![cfg_attr(not(stage0), feature(i128_type))]\n+\n+#![allow(non_camel_case_types, unused_variables)]\n+\n+\n+#[cfg(any(target_pointer_width=\"32\", target_pointer_width=\"16\"))]\n+pub mod reimpls {\n+    #![allow(unused_comparisons)]\n+    // C API is expected to tolerate some amount of size mismatch in ABI. Hopefully the amount of\n+    // handling is sufficient for bootstrapping.\n+    #[cfg(stage0)]\n+    type u128_ = u64;\n+    #[cfg(stage0)]\n+    type i128_ = i64;\n+    #[cfg(not(stage0))]\n+    type u128_ = u128;\n+    #[cfg(not(stage0))]\n+    type i128_ = i128;\n+\n+    fn unimplemented() -> ! {\n+        unsafe { ::core::intrinsics::abort() }\n+    }\n+\n+    macro_rules! ashl {\n+        ($a:expr, $b:expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits / 2;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts(0, a.low() << (b - half_bits))\n+            } else if b == 0 {\n+                a\n+            } else {\n+                <$ty>::from_parts(a.low() << b, (a.high() << b) | (a.low() >> (half_bits - b)))\n+            }\n+        }}\n+    }\n+\n+    #[export_name=\"__ashlti3\"]\n+    pub extern fn shl(a: u128_, b: u128_) -> u128_ {\n+        ashl!(a, b, u128_)\n+    }\n+\n+    macro_rules! ashr {\n+        ($a: expr, $b: expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits / 2;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts((a.high() >> (b - half_bits)) as <$ty as LargeInt>::LowHalf,\n+                                  a.high() >> (half_bits - 1))\n+            } else if b == 0 {\n+                a\n+            } else {\n+                let high_unsigned = a.high() as <$ty as LargeInt>::LowHalf;\n+                <$ty>::from_parts((high_unsigned << (half_bits - b)) | (a.low() >> b),\n+                                  a.high() >> b)\n+            }\n+        }}\n+    }\n+\n+    #[export_name=\"__ashrti3\"]\n+    pub extern fn shr(a: i128_, b: i128_) -> i128_ {\n+        ashr!(a, b, i128_)\n+    }\n+\n+    macro_rules! lshr {\n+        ($a: expr, $b: expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits / 2;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts(a.high() >> (b - half_bits), 0)\n+            } else if b == 0 {\n+                a\n+            } else {\n+                <$ty>::from_parts((a.high() << (half_bits - b)) | (a.low() >> b), a.high() >> b)\n+            }\n+        }}\n+    }\n+\n+\n+    #[export_name=\"__lshrti3\"]\n+    pub extern fn lshr(a: u128_, b: u128_) -> u128_ {\n+        lshr!(a, b, u128_)\n+    }\n+\n+    #[cfg(stage0)]\n+    #[export_name=\"__udivmodti4\"]\n+    pub extern fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+        unsafe {\n+        if !rem.is_null() {\n+            *rem = n % d;\n+        }\n+        n / d\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    #[export_name=\"__udivmodti4\"]\n+    pub extern fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+        unsafe {\n+        // NOTE X is unknown, K != 0\n+        if n.high() == 0 {\n+            if d.high() == 0 {\n+                // 0 X\n+                // ---\n+                // 0 X\n+                if !rem.is_null() {\n+                    *rem = u128::from(n.low() % d.low());\n+                }\n+                return u128::from(n.low() / d.low());\n+            } else {\n+                // 0 X\n+                // ---\n+                // K X\n+                if !rem.is_null() {\n+                    *rem = n;\n+                }\n+                return 0;\n+            };\n+        }\n+\n+        let mut sr;\n+        let mut q;\n+        let mut r;\n+\n+        if d.low() == 0 {\n+            if d.high() == 0 {\n+                // K X\n+                // ---\n+                // 0 0\n+                unimplemented()\n+            }\n+\n+            if n.low() == 0 {\n+                // K 0\n+                // ---\n+                // K 0\n+                if !rem.is_null() {\n+                    *rem = u128::from_parts(0, n.high() % d.high());\n+                }\n+                return u128::from(n.high() / d.high());\n+            }\n+\n+            // K K\n+            // ---\n+            // K 0\n+\n+            if d.high().is_power_of_two() {\n+                if !rem.is_null() {\n+                    *rem = u128::from_parts(n.low(), n.high() & (d.high() - 1));\n+                }\n+                return u128::from(n.high() >> d.high().trailing_zeros());\n+            }\n+\n+            sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n+\n+            // D > N\n+            if sr > 64 - 2 {\n+                if !rem.is_null() {\n+                    *rem = n;\n+                }\n+                return 0;\n+            }\n+\n+            sr += 1;\n+\n+            // 1 <= sr <= u32::bits() - 1\n+            q = n << (128 - sr);\n+            r = n >> sr;\n+        } else {\n+            if d.high() == 0 {\n+                // K X\n+                // ---\n+                // 0 K\n+                if d.low().is_power_of_two() {\n+                    if !rem.is_null() {\n+                        *rem = u128::from(n.low() & (d.low() - 1));\n+                    }\n+\n+                    if d.low() == 1 {\n+                        return n;\n+                    } else {\n+                        let sr = d.low().trailing_zeros();\n+                        return n >> sr;\n+                    };\n+                }\n+\n+                sr = 1 + 64 + d.low().leading_zeros() - n.high().leading_zeros();\n+\n+                // 2 <= sr <= u64::bits() - 1\n+                q = n << (128 - sr);\n+                r = n >> sr;\n+            } else {\n+                // K X\n+                // ---\n+                // K K\n+                sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n+\n+                // D > N\n+                if sr > 64 - 1 {\n+                    if !rem.is_null() {\n+                        *rem = n;\n+                    }\n+                    return 0;\n+                }\n+\n+                sr += 1;\n+\n+                // 1 <= sr <= u32::bits()\n+                q = n << (128 - sr);\n+                r = n >> sr;\n+            }\n+        }\n+\n+        // Not a special case\n+        // q and r are initialized with\n+        // q = n << (u64::bits() - sr)\n+        // r = n >> sr\n+        // 1 <= sr <= u64::bits() - 1\n+        let mut carry = 0;\n+\n+        for _ in 0..sr {\n+            // r:q = ((r:q) << 1) | carry\n+            r = (r << 1) | (q >> (128 - 1));\n+            q = (q << 1) | carry as u128;\n+\n+            // carry = 0\n+            // if r >= d {\n+            //     r -= d;\n+            //     carry = 1;\n+            // }\n+            let s = (d.wrapping_sub(r).wrapping_sub(1)) as i128 >> (128 - 1);\n+            carry = (s & 1) as u64;\n+            r -= d & s as u128;\n+        }\n+\n+        if !rem.is_null() {\n+            *rem = r;\n+        }\n+        (q << 1) | carry as u128\n+        }\n+    }\n+\n+    #[export_name=\"__umodti3\"]\n+    pub extern fn u128_mod(a: u128_, b: u128_) -> u128_ {\n+        unsafe {\n+            let mut r = ::core::mem::zeroed();\n+            u128_div_mod(a, b, &mut r);\n+            r\n+        }\n+    }\n+\n+    #[export_name=\"__modti3\"]\n+    pub extern fn i128_mod(a: i128_, b: i128_) -> i128_ {\n+        let b = b.abs();\n+        let sa = a.signum();\n+        let a = a.abs();\n+        unsafe {\n+            let mut r = ::core::mem::zeroed();\n+            u128_div_mod(a as u128_, b as u128_, &mut r);\n+            if sa == -1 { -(r as i128_) } else { r as i128_ }\n+        }\n+    }\n+\n+    #[export_name=\"__divti3\"]\n+    pub extern fn i128_div(a: i128_, b: i128_) -> i128_ {\n+        let sa = a.signum();\n+        let sb = b.signum();\n+        let a = a.abs();\n+        let b = b.abs();\n+        let sr = sa ^ sb;\n+        unsafe {\n+            let mut r = ::core::mem::zeroed();\n+            if sa == -1 {\n+                -(u128_div_mod(a as u128_, b as u128_, &mut r) as i128_)\n+            } else {\n+                u128_div_mod(a as u128_, b as u128_, &mut r) as i128_\n+            }\n+        }\n+    }\n+\n+    #[export_name=\"__udivti3\"]\n+    pub extern fn u128_div(a: u128_, b: u128_) -> u128_ {\n+        unsafe {\n+            let mut r = ::core::mem::zeroed();\n+            u128_div_mod(a, b, &mut r)\n+        }\n+    }\n+\n+    macro_rules! mulo {\n+        ($a:expr, $b:expr, $o: expr, $ty: ty) => {{\n+            let (a, b, overflow) = ($a, $b, $o);\n+            *overflow = 0;\n+            let result = a.wrapping_mul(b);\n+            if a == <$ty>::min_value() {\n+                if b != 0 && b != 1 {\n+                    *overflow = 1;\n+                }\n+                return result;\n+            }\n+            if b == <$ty>::min_value() {\n+                if a != 0 && a != 1 {\n+                    *overflow = 1;\n+                }\n+                return result;\n+            }\n+\n+            let bits = ::core::mem::size_of::<$ty>() * 8;\n+            let sa = a >> (bits - 1);\n+            let abs_a = (a ^ sa) - sa;\n+            let sb = b >> (bits - 1);\n+            let abs_b = (b ^ sb) - sb;\n+            if abs_a < 2 || abs_b < 2 {\n+                return result;\n+            }\n+            if sa == sb {\n+                if abs_a > <$ty>::max_value() / abs_b {\n+                    *overflow = 1;\n+                }\n+            } else {\n+                if abs_a > <$ty>::min_value() / -abs_b {\n+                    *overflow = 1;\n+                }\n+            }\n+            result\n+        }}\n+    }\n+\n+    // FIXME: i32 here should be c_int.\n+    #[export_name=\"__muloti4\"]\n+    pub extern fn i128_mul_oflow(a: i128_, b: i128_, o: &mut i32) -> i128_ {\n+        if let Some(v) = (a as i64).checked_mul(b as i64) {\n+            *o = 0;\n+            v as i128_\n+        } else {\n+            *o = 1;\n+            0\n+        }\n+    }\n+\n+    pub trait LargeInt {\n+        type LowHalf;\n+        type HighHalf;\n+\n+        fn low(self) -> Self::LowHalf;\n+        fn high(self) -> Self::HighHalf;\n+        fn from_parts(low: Self::LowHalf, high: Self::HighHalf) -> Self;\n+    }\n+    impl LargeInt for u64 {\n+        type LowHalf = u32;\n+        type HighHalf = u32;\n+\n+        fn low(self) -> u32 {\n+            self as u32\n+        }\n+        fn high(self) -> u32 {\n+            (self >> 32) as u32\n+        }\n+        fn from_parts(low: u32, high: u32) -> u64 {\n+            low as u64 | ((high as u64) << 32)\n+        }\n+    }\n+    impl LargeInt for i64 {\n+        type LowHalf = u32;\n+        type HighHalf = i32;\n+\n+        fn low(self) -> u32 {\n+            self as u32\n+        }\n+        fn high(self) -> i32 {\n+            (self >> 32) as i32\n+        }\n+        fn from_parts(low: u32, high: i32) -> i64 {\n+            low as i64 | ((high as i64) << 32)\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl LargeInt for u128 {\n+        type LowHalf = u64;\n+        type HighHalf = u64;\n+\n+        fn low(self) -> u64 {\n+            self as u64\n+        }\n+        fn high(self) -> u64 {\n+            unsafe { *(&self as *const u128 as *const u64) }\n+        }\n+        fn from_parts(low: u64, high: u64) -> u128 {\n+            #[repr(C, packed)] struct Parts(u64, u64);\n+            unsafe { ::core::mem::transmute(Parts(low, high)) }\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl LargeInt for i128 {\n+        type LowHalf = u64;\n+        type HighHalf = i64;\n+\n+        fn low(self) -> u64 {\n+            self as u64\n+        }\n+        fn high(self) -> i64 {\n+            unsafe { *(&self as *const i128 as *const i64) }\n+        }\n+        fn from_parts(low: u64, high: i64) -> i128 {\n+            u128::from_parts(low, high as u64) as i128\n+        }\n+    }\n+\n+    macro_rules! mul {\n+        ($a:expr, $b:expr, $ty: ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = ::core::mem::size_of::<$ty>() * 8;\n+            let half_bits = bits / 4;\n+            let lower_mask = !0 >> half_bits;\n+            let mut low = (a.low() & lower_mask) * (b.low() & lower_mask);\n+            let mut t = low >> half_bits;\n+            low &= lower_mask;\n+            t += (a.low() >> half_bits) * (b.low() & lower_mask);\n+            low += (t & lower_mask) << half_bits;\n+            let mut high = t >> half_bits;\n+            t = low >> half_bits;\n+            low &= lower_mask;\n+            t += (b.low() >> half_bits) * (a.low() & lower_mask);\n+            low += (t & lower_mask) << half_bits;\n+            high += t >> half_bits;\n+            high += (a.low() >> half_bits) * (b.low() >> half_bits);\n+            high = high.wrapping_add(a.high().wrapping_mul(b.low()).wrapping_add(a.low().wrapping_mul(b.high())));\n+            <$ty>::from_parts(low, high)\n+        }}\n+    }\n+\n+\n+    #[export_name=\"__multi3\"]\n+    pub extern fn u128_mul(a: u128_, b: u128_) -> u128_ {\n+        (a as u64 * b as u64) as u128_\n+        // mul!(a, b, u128_)\n+    }\n+\n+    trait FloatStuff: Sized {\n+        type ToBytes;\n+\n+        const MANTISSA_BITS: u32;\n+        const MAX_EXP: i32;\n+        const EXP_MASK: Self::ToBytes;\n+        const MANTISSA_MASK: Self::ToBytes;\n+\n+        fn to_bytes(self) -> Self::ToBytes;\n+        fn get_exponent(self) -> i32;\n+    }\n+\n+    impl FloatStuff for f32 {\n+        type ToBytes = u32;\n+        const MANTISSA_BITS: u32 = 23;\n+        const MAX_EXP: i32 = 127;\n+        const MANTISSA_MASK: u32 = 0x007F_FFFF;\n+        const EXP_MASK: u32 = 0x7F80_0000;\n+\n+        fn to_bytes(self) -> u32 { unsafe { ::core::mem::transmute(self) } }\n+        fn get_exponent(self) -> i32 {\n+            (((self.to_bytes() & Self::EXP_MASK) >> Self::MANTISSA_BITS) as i32) - Self::MAX_EXP\n+        }\n+    }\n+\n+    impl FloatStuff for f64 {\n+        type ToBytes = u64;\n+        const MANTISSA_BITS: u32 = 52;\n+        const MAX_EXP: i32 = 1023;\n+        const EXP_MASK: u64 = 0x7FF0_0000_0000_0000;\n+        const MANTISSA_MASK: u64 = 0x000F_FFFF_FFFF_FFFF;\n+\n+        fn to_bytes(self) -> u64 { unsafe { ::core::mem::transmute(self) } }\n+        fn get_exponent(self) -> i32 {\n+            (((self.to_bytes() & Self::EXP_MASK) >> Self::MANTISSA_BITS) as i32) - Self::MAX_EXP\n+        }\n+    }\n+\n+    macro_rules! float_as_unsigned {\n+        ($from: expr, $fromty: ty, $outty: ty) => { {\n+            use core::num::Float;\n+            let repr = $from.to_bytes();\n+            let sign = $from.signum();\n+            let exponent = $from.get_exponent();\n+            let mantissa = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            if sign == -1.0 || exponent < 0 { return 0; }\n+            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+                return !0;\n+            }\n+            if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n+                mantissa as $outty >> (<$fromty as FloatStuff>::MANTISSA_BITS as i32 - exponent)\n+            } else {\n+                mantissa as $outty << (exponent - <$fromty as FloatStuff>::MANTISSA_BITS as i32)\n+            }\n+        } }\n+    }\n+\n+    #[export_name=\"__fixunsdfti\"]\n+    pub extern fn f64_as_u128(a: f64) -> u128_ {\n+        float_as_unsigned!(a, f64, u128_)\n+    }\n+\n+    #[export_name=\"__fixunssfti\"]\n+    pub extern fn f32_as_u128(a: f32) -> u128_ {\n+        float_as_unsigned!(a, f32, u128_)\n+    }\n+\n+    macro_rules! float_as_signed {\n+        ($from: expr, $fromty: ty, $outty: ty) => {{\n+            use core::num::Float;\n+            let repr = $from.to_bytes();\n+            let sign = $from.signum();\n+            let exponent = $from.get_exponent();\n+            let mantissa = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+\n+            if exponent < 0 { return 0; }\n+            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+                return if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n+            }\n+            let r = if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n+                mantissa as $outty >> (<$fromty as FloatStuff>::MANTISSA_BITS as i32 - exponent)\n+            } else {\n+                mantissa as $outty << (exponent - <$fromty as FloatStuff>::MANTISSA_BITS as i32)\n+            };\n+            if sign >= 0.0 { r } else { -r }\n+        }}\n+    }\n+\n+    #[export_name=\"__fixdfti\"]\n+    pub extern fn f64_as_i128(a: f64) -> i128_ {\n+        float_as_signed!(a, f64, i128_)\n+    }\n+\n+    #[export_name=\"__fixsfti\"]\n+    pub extern fn f32_as_i128(a: f32) -> i128_ {\n+        float_as_signed!(a, f32, i128_)\n+    }\n+\n+    #[export_name=\"__floattidf\"]\n+    pub extern fn i128_as_f64(a: i128_) -> f64 {\n+        match a.signum() {\n+            1 => u128_as_f64(a.abs() as u128_),\n+            0 => 0.0,\n+            -1 => -u128_as_f64(a.abs() as u128_),\n+            _ => unimplemented()\n+        }\n+    }\n+\n+    #[export_name=\"__floattisf\"]\n+    pub extern fn i128_as_f32(a: i128_) -> f32 {\n+        match a.signum() {\n+            1 => u128_as_f32(a.abs() as u128_),\n+            0 => 0.0,\n+            -1 => -u128_as_f32(a.abs() as u128_),\n+            _ => unimplemented()\n+        }\n+    }\n+\n+    #[export_name=\"__floatuntidf\"]\n+    pub extern fn u128_as_f64(mut a: u128_) -> f64 {\n+        use ::core::f64::MANTISSA_DIGITS;\n+        if a == 0 { return 0.0; }\n+        let sd = 128 - a.leading_zeros();\n+        let mut e = sd - 1;\n+        const MD1 : u32 = MANTISSA_DIGITS + 1;\n+        const MD2 : u32 = MANTISSA_DIGITS + 2;\n+\n+        if sd > MANTISSA_DIGITS {\n+            a = match sd {\n+                MD1 => a << 1,\n+                MD2 => a,\n+                _ => (a >> (sd - (MANTISSA_DIGITS + 2))) |\n+                     (if (a & (!0 >> (128 + MANTISSA_DIGITS + 2) - sd)) == 0 { 0 } else { 1 })\n+            };\n+            a |= if (a & 4) == 0 { 0 } else { 1 };\n+            a += 1;\n+            a >>= 2;\n+            if a & (1 << MANTISSA_DIGITS) != 0 {\n+                a >>= 1;\n+                e += 1;\n+            }\n+        } else {\n+            a <<= MANTISSA_DIGITS - sd;\n+        }\n+        unsafe {\n+            ::core::mem::transmute(((e as u64 + 1023) << 52) | (a as u64 & 0x000f_ffff_ffff_ffff))\n+        }\n+    }\n+\n+    #[export_name=\"__floatuntisf\"]\n+    pub extern fn u128_as_f32(mut a: u128_) -> f32 {\n+        use ::core::f32::MANTISSA_DIGITS;\n+        if a == 0 { return 0.0; }\n+        let sd = 128 - a.leading_zeros();\n+        let mut e = sd - 1;\n+        const MD1 : u32 = MANTISSA_DIGITS + 1;\n+        const MD2 : u32 = MANTISSA_DIGITS + 2;\n+\n+        if sd > MANTISSA_DIGITS {\n+            a = match sd {\n+                MD1 => a << 1,\n+                MD2 => a,\n+                _ => (a >> (sd - (MANTISSA_DIGITS + 2))) |\n+                     (if (a & (!0 >> (128 + MANTISSA_DIGITS + 2) - sd)) == 0 { 0 } else { 1 })\n+            };\n+            a |= if (a & 4) == 0 { 0 } else { 1 };\n+            a += 1;\n+            a >>= 2;\n+            if a & (1 << MANTISSA_DIGITS) != 0 {\n+                a >>= 1;\n+                e += 1;\n+            }\n+        } else {\n+            a <<= MANTISSA_DIGITS - sd;\n+        }\n+        unsafe {\n+            ::core::mem::transmute(((e + 127) << 23) | (a as u32 & 0x007f_ffff))\n+        }\n+    }\n+}"}]}