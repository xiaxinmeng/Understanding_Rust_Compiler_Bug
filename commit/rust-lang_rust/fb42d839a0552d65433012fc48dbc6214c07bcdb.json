{"sha": "fb42d839a0552d65433012fc48dbc6214c07bcdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNDJkODM5YTA1NTJkNjU0MzMwMTJmYzQ4ZGJjNjIxNGMwN2JjZGI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-16T11:46:03Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-16T11:46:03Z"}, "message": "Clean up (and optimize) root-mutability analysis in alias.rs", "tree": {"sha": "b5313a750fc5cdc8fea46052accaf677bfabc5e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5313a750fc5cdc8fea46052accaf677bfabc5e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb42d839a0552d65433012fc48dbc6214c07bcdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb42d839a0552d65433012fc48dbc6214c07bcdb", "html_url": "https://github.com/rust-lang/rust/commit/fb42d839a0552d65433012fc48dbc6214c07bcdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb42d839a0552d65433012fc48dbc6214c07bcdb/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7587c1eda9b46b57b77585638fd775490ff836e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7587c1eda9b46b57b77585638fd775490ff836e", "html_url": "https://github.com/rust-lang/rust/commit/d7587c1eda9b46b57b77585638fd775490ff836e"}], "stats": {"total": 134, "additions": 64, "deletions": 70}, "files": [{"sha": "1c8d15bb74b238b8ce458fa8f27566f966cf956a", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 64, "deletions": 65, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/fb42d839a0552d65433012fc48dbc6214c07bcdb/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb42d839a0552d65433012fc48dbc6214c07bcdb/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=fb42d839a0552d65433012fc48dbc6214c07bcdb", "patch": "@@ -1,7 +1,6 @@\n \n import syntax::{ast, ast_util};\n import ast::{ident, fn_ident, node_id, def_id};\n-import mut::{mut_field, deref, field, index, unbox};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n@@ -15,11 +14,13 @@ import std::option::{some, none, is_none};\n tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n tag copied { not_allowed; copied; not_copied; }\n \n+tag unsafe_ty { contains(ty::t); mut_contains(ty::t); }\n+\n type binding = @{node_id: node_id,\n                  span: span,\n                  root_var: option::t<node_id>,\n                  local_id: uint,\n-                 unsafe_tys: [ty::t],\n+                 unsafe_tys: [unsafe_ty],\n                  mutable ok: valid,\n                  mutable copied: copied};\n \n@@ -28,7 +29,7 @@ tag ret_info { by_ref(bool, node_id); other; }\n type scope = {bs: [binding], ret_info: ret_info};\n \n fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n-              unsafe: [ty::t]) -> binding {\n+              unsafe: [unsafe_ty]) -> binding {\n     ret @{node_id: id, span: span, root_var: root_var,\n           local_id: local_id_of_node(cx, id),\n           unsafe_tys: unsafe, mutable ok: valid,\n@@ -92,7 +93,7 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n         alt val {\n           some(ex) {\n             let root = expr_root(*cx, ex, false);\n-            if mut_field(root.ds) {\n+            if !is_none(root.mut) {\n                 cx.tcx.sess.span_err(ex.span,\n                                      \"result of put must be\" +\n                                          \" immutably rooted\");\n@@ -185,9 +186,9 @@ fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n             cx.tcx.sess.span_err(loc.span, \"a reference binding can't be \\\n                                             rooted in a temporary\");\n         }\n-        for proot in *pattern_roots(cx.tcx, *root.ds, loc.node.pat) {\n+        for proot in pattern_roots(cx.tcx, root.mut, loc.node.pat) {\n             let bnd = mk_binding(cx, proot.id, proot.span, root_var,\n-                                 inner_mut(proot.ds));\n+                                 unsafe_set(proot.mut));\n             // Don't implicitly copy explicit references\n             bnd.copied = not_allowed;\n             bs += [bnd];\n@@ -246,7 +247,7 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n                        span: arg.span,\n                        root_var: root_var,\n                        local_id: 0u,\n-                       unsafe_tys: inner_mut(root.ds),\n+                       unsafe_tys: unsafe_set(root.mut),\n                        mutable ok: valid,\n                        mutable copied: alt arg_t.mode {\n                          ast::by_move. { copied }\n@@ -276,12 +277,13 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n     }\n     let j = 0u;\n     for b in bindings {\n-        for ty in b.unsafe_tys {\n+        for unsafe in b.unsafe_tys {\n             let i = 0u;\n             for arg_t: ty::arg in arg_ts {\n                 let mut_alias = arg_t.mode == ast::by_mut_ref;\n                 if i != j &&\n-                       ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) &&\n+                       ty_can_unsafely_include(cx, unsafe, arg_t.ty,\n+                                               mut_alias) &&\n                        cant_copy(cx, b) {\n                     cx.tcx.sess.span_err\n                         (args[i].span,\n@@ -323,7 +325,7 @@ fn check_ret_ref(cx: ctx, sc: scope, mut: bool, arg_node_id: node_id,\n                  expr: @ast::expr) {\n     let root = expr_root(cx, expr, false);\n     let bad = none;\n-    let mut_field = mut_field(root.ds);\n+    let mut_field = !is_none(root.mut);\n     alt path_def(cx, root.ex) {\n       none. {\n         bad = some(\"a temporary\");\n@@ -388,18 +390,18 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n         let new_bs = sc.bs;\n         let root_var = path_def_id(cx, root.ex);\n         let pat_id_map = ast_util::pat_id_map(a.pats[0]);\n-        type info = {id: node_id, mutable unsafe: [ty::t], span: span};\n+        type info = {id: node_id, mutable unsafe: [unsafe_ty], span: span};\n         let binding_info: [info] = [];\n         for pat in a.pats {\n-            for proot in *pattern_roots(cx.tcx, *root.ds, pat) {\n+            for proot in pattern_roots(cx.tcx, root.mut, pat) {\n                 let canon_id = pat_id_map.get(proot.name);\n                 // FIXME I wanted to use a block here, but that hit bug #913\n                 fn match(x: info, canon: node_id) -> bool { x.id == canon }\n                 alt vec::find(bind match(_, canon_id), binding_info) {\n-                  some(s) { s.unsafe += inner_mut(proot.ds); }\n+                  some(s) { s.unsafe += unsafe_set(proot.mut); }\n                   none. {\n                       binding_info += [{id: canon_id,\n-                                        mutable unsafe: inner_mut(proot.ds),\n+                                        mutable unsafe: unsafe_set(proot.mut),\n                                         span: proot.span}];\n                   }\n                 }\n@@ -419,9 +421,9 @@ fn check_for_each(cx: ctx, local: @ast::local, call: @ast::expr,\n     alt call.node {\n       ast::expr_call(f, args) {\n         let new_bs = sc.bs + check_call(cx, f, args);\n-        for proot in *pattern_roots(cx.tcx, [], local.node.pat) {\n+        for proot in pattern_roots(cx.tcx, none, local.node.pat) {\n             new_bs += [mk_binding(cx, proot.id, proot.span, none,\n-                                  inner_mut(proot.ds))];\n+                                  unsafe_set(proot.mut))];\n         }\n         visit::visit_block(blk, {bs: new_bs with sc}, v);\n       }\n@@ -435,20 +437,20 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n \n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n-    let ext_ds = *root.ds;\n+    let cur_mut = root.mut;\n     alt ty::struct(cx.tcx, seq_t) {\n       ty::ty_vec(mt) {\n         if mt.mut != ast::imm {\n-            ext_ds += [@{mut: true, kind: index, outer_t: seq_t}];\n+            cur_mut = some(contains(seq_t));\n         }\n       }\n       _ {}\n     }\n     let root_var = path_def_id(cx, root.ex);\n     let new_bs = sc.bs;\n-    for proot in *pattern_roots(cx.tcx, ext_ds, local.node.pat) {\n+    for proot in pattern_roots(cx.tcx, cur_mut, local.node.pat) {\n         new_bs += [mk_binding(cx, proot.id, proot.span, root_var,\n-                              inner_mut(proot.ds))];\n+                              unsafe_set(proot.mut))];\n     }\n     visit::visit_block(blk, {bs: new_bs with sc}, v);\n }\n@@ -463,8 +465,8 @@ fn check_var(cx: ctx, ex: @ast::expr, p: ast::path, id: ast::node_id,\n     for b in sc.bs {\n         // excludes variables introduced since the alias was made\n         if my_local_id < b.local_id {\n-            for ty in b.unsafe_tys {\n-                if ty_can_unsafely_include(cx, ty, var_t, assign) {\n+            for unsafe in b.unsafe_tys {\n+                if ty_can_unsafely_include(cx, unsafe, var_t, assign) {\n                     b.ok = val_taken(ex.span, p);\n                 }\n             }\n@@ -539,14 +541,17 @@ fn path_def_id(cx: ctx, ex: @ast::expr) -> option::t<ast::node_id> {\n     }\n }\n \n-fn ty_can_unsafely_include(cx: ctx, needle: ty::t, haystack: ty::t, mut: bool)\n-   -> bool {\n+fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n+                           mut: bool) -> bool {\n     fn get_mut(cur: bool, mt: ty::mt) -> bool {\n         ret cur || mt.mut != ast::imm;\n     }\n-    fn helper(tcx: ty::ctxt, needle: ty::t, haystack: ty::t, mut: bool) ->\n-       bool {\n-        if needle == haystack { ret true; }\n+    fn helper(tcx: ty::ctxt, needle: unsafe_ty, haystack: ty::t, mut: bool)\n+        -> bool {\n+        if alt needle {\n+          contains(ty) { ty == haystack }\n+          mut_contains(ty) { mut && ty == haystack }\n+        } { ret true; }\n         alt ty::struct(tcx, haystack) {\n           ty::ty_tag(_, ts) {\n             for t: ty::t in ts {\n@@ -570,23 +575,13 @@ fn ty_can_unsafely_include(cx: ctx, needle: ty::t, haystack: ty::t, mut: bool)\n             for t in ts { if helper(tcx, needle, t, mut) { ret true; } }\n             ret false;\n           }\n-\n-\n-\n-\n-\n           // These may contain anything.\n-          ty::ty_fn(_, _, _, _, _) {\n-            ret true;\n-          }\n-          ty::ty_obj(_) { ret true; }\n+          ty::ty_fn(_, _, _, _, _) | ty::ty_obj(_) { ret true; }\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be\n           // overwritten.\n-          ty::ty_param(_, _) {\n-            ret mut;\n-          }\n+          ty::ty_param(_, _) { ret mut; }\n           _ { ret false; }\n         }\n     }\n@@ -640,49 +635,53 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n     ret score_ty(tcx, ty) > 8u;\n }\n \n-type pattern_root = {id: node_id, name: ident, ds: @[deref], span: span};\n+type pattern_root = {id: node_id,\n+                     name: ident,\n+                     mut: option::t<unsafe_ty>,\n+                     span: span};\n \n-fn pattern_roots(tcx: ty::ctxt, base: [deref], pat: @ast::pat)\n-    -> @[pattern_root] {\n-    fn walk(tcx: ty::ctxt, base: [deref], pat: @ast::pat,\n+fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n+    -> [pattern_root] {\n+    fn walk(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat,\n             &set: [pattern_root]) {\n         alt pat.node {\n           ast::pat_wild. | ast::pat_lit(_) {}\n           ast::pat_bind(nm) {\n-            set += [{id: pat.id, name: nm, ds: @base, span: pat.span}];\n+            set += [{id: pat.id, name: nm, mut: mut, span: pat.span}];\n           }\n           ast::pat_tag(_, ps) | ast::pat_tup(ps) {\n-            let base = base + [@{mut: false, kind: field,\n-                                 outer_t: ty::node_id_to_type(tcx, pat.id)}];\n-            for p in ps { walk(tcx, base, p, set); }\n+            for p in ps { walk(tcx, mut, p, set); }\n           }\n           ast::pat_rec(fs, _) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             for f in fs {\n-                let mut = ty::get_field(tcx, ty, f.ident).mt.mut != ast::imm;\n-                let base = base + [@{mut: mut, kind: field, outer_t: ty}];\n-                walk(tcx, base, f.pat, set);\n+                let m = ty::get_field(tcx, ty, f.ident).mt.mut != ast::imm;\n+                walk(tcx, m ? some(contains(ty)) : mut, f.pat, set);\n             }\n           }\n           ast::pat_box(p) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n-            let mut = alt ty::struct(tcx, ty) {\n+            let m = alt ty::struct(tcx, ty) {\n               ty::ty_box(mt) { mt.mut != ast::imm }\n             };\n-            walk(tcx, base + [@{mut: mut, kind: unbox, outer_t: ty}], p, set);\n+            walk(tcx, m ? some(contains(ty)) : mut, p, set);\n           }\n         }\n     }\n     let set = [];\n-    walk(tcx, base, pat, set);\n-    ret @set;\n+    walk(tcx, mut, pat, set);\n+    ret set;\n }\n \n // Wraps the expr_root in mut.rs to also handle roots that exist through\n // return-by-reference\n-fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool) ->\n-   {ex: @ast::expr, ds: @[deref]} {\n+fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n+    -> {ex: @ast::expr, mut: option::t<unsafe_ty>} {\n     let base_root = mut::expr_root(cx.tcx, ex, autoderef);\n+    let unsafe = none;\n+    for d in *base_root.ds {\n+        if d.mut { unsafe = some(contains(d.outer_t)); break; }\n+    }\n     if is_none(path_def_id(cx, base_root.ex)) {\n         alt base_root.ex.node {\n           ast::expr_call(f, args) {\n@@ -691,24 +690,24 @@ fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool) ->\n               ast::return_ref(mut, arg_n) {\n                 let arg = args[arg_n - 1u];\n                 let arg_root = expr_root(cx, arg, false);\n-                ret {ex: arg_root.ex,\n-                     ds: @(*arg_root.ds +\n-                           (mut ? [@{mut: true, kind: unbox,\n-                                     outer_t: ty::expr_ty(cx.tcx, arg)}] : [])\n-                           + *base_root.ds)};\n+                if mut {\n+                    let ret_ty = ty::expr_ty(cx.tcx, base_root.ex);\n+                    unsafe = some(mut_contains(ret_ty));\n+                }\n+                if !is_none(arg_root.mut) { unsafe = arg_root.mut; }\n+                ret {ex: arg_root.ex, mut: unsafe};\n               }\n               _ {}\n             }\n           }\n           _ {}\n         }\n     }\n-    ret base_root;\n+    ret {ex: base_root.ex, mut: unsafe};\n }\n \n-fn inner_mut(ds: @[deref]) -> [ty::t] {\n-    for d: deref in *ds { if d.mut { ret [d.outer_t]; } }\n-    ret [];\n+fn unsafe_set(from: option::t<unsafe_ty>) -> [unsafe_ty] {\n+    alt from { some(t) { [t] } _ { [] } }\n }\n \n // Local Variables:"}, {"sha": "2d13af25622c175d0a55634bcc8006b2ae1d8b32", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb42d839a0552d65433012fc48dbc6214c07bcdb/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb42d839a0552d65433012fc48dbc6214c07bcdb/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=fb42d839a0552d65433012fc48dbc6214c07bcdb", "patch": "@@ -105,11 +105,6 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n     ret {ex: ex, ds: @ds};\n }\n \n-fn mut_field(ds: @[deref]) -> bool {\n-    for d: deref in *ds { if d.mut { ret true; } }\n-    ret false;\n-}\n-\n // Actual mut-checking pass\n \n type mut_map = std::map::hashmap<node_id, ()>;"}]}