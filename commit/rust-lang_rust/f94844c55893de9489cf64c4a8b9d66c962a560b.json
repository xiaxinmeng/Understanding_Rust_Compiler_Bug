{"sha": "f94844c55893de9489cf64c4a8b9d66c962a560b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NDg0NGM1NTg5M2RlOTQ4OWNmNjRjNGE4YjlkNjZjOTYyYTU2MGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-30T08:20:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-30T08:20:44Z"}, "message": "auto merge of #8820 : alexcrichton/rust/no-io-writer, r=brson\n\nAt the same time, this updates the TyVisitor to use a mutable self because it's\r\nprobably going to be mutating state as it goes along anyway.", "tree": {"sha": "46cfa3c1990256af769a61a59419531eab92dc39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46cfa3c1990256af769a61a59419531eab92dc39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f94844c55893de9489cf64c4a8b9d66c962a560b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f94844c55893de9489cf64c4a8b9d66c962a560b", "html_url": "https://github.com/rust-lang/rust/commit/f94844c55893de9489cf64c4a8b9d66c962a560b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f94844c55893de9489cf64c4a8b9d66c962a560b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "974f854bb528c9a94af62990965ac62a1aa0dbed", "url": "https://api.github.com/repos/rust-lang/rust/commits/974f854bb528c9a94af62990965ac62a1aa0dbed", "html_url": "https://github.com/rust-lang/rust/commit/974f854bb528c9a94af62990965ac62a1aa0dbed"}, {"sha": "97f61e7bbeca5c9524126ca75670fc45d1b1a951", "url": "https://api.github.com/repos/rust-lang/rust/commits/97f61e7bbeca5c9524126ca75670fc45d1b1a951", "html_url": "https://github.com/rust-lang/rust/commit/97f61e7bbeca5c9524126ca75670fc45d1b1a951"}], "stats": {"total": 2220, "additions": 1717, "deletions": 503}, "files": [{"sha": "a3673928df768c6e9f108100a9d609cfa537c3e7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -4572,7 +4572,7 @@ pub fn visitor_object_ty(tcx: ctxt,\n                  trait_ref.def_id,\n                  trait_ref.substs.clone(),\n                  RegionTraitStore(region),\n-                 ast::m_imm,\n+                 ast::m_mutbl,\n                  EmptyBuiltinBounds())))\n }\n "}, {"sha": "a885a4f722789470cf9a6fe53e8c70b7f1a162ef", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -41,16 +41,10 @@ pub fn console_off() {\n #[lang=\"log_type\"]\n #[allow(missing_doc)]\n pub fn log_type<T>(_level: u32, object: &T) {\n-    use io;\n-    use repr;\n-    use str;\n-\n-    let bytes = do io::with_bytes_writer |writer| {\n-        repr::write_repr(writer, object);\n-    };\n+    use sys;\n \n     // XXX: Bad allocation\n-    let msg = str::from_bytes(bytes);\n+    let msg = sys::log_str(object);\n     newsched_log_str(msg);\n }\n "}, {"sha": "724877db00a1763bebb0518da6ec7693f9e7be9c", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -28,9 +28,9 @@ use unstable::raw;\n  * then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void);\n-    fn push_ptr(&self);\n-    fn pop_ptr(&self);\n+    fn move_ptr(&mut self, adjustment: &fn(*c_void) -> *c_void);\n+    fn push_ptr(&mut self);\n+    fn pop_ptr(&mut self);\n }\n \n /// Helper function for alignment calculation.\n@@ -49,173 +49,173 @@ pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n \n impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     #[inline]\n-    pub fn bump(&self, sz: uint) {\n+    pub fn bump(&mut self, sz: uint) {\n         do self.inner.move_ptr() |p| {\n             ((p as uint) + sz) as *c_void\n         };\n     }\n \n     #[inline]\n-    pub fn align(&self, a: uint) {\n+    pub fn align(&mut self, a: uint) {\n         do self.inner.move_ptr() |p| {\n             align(p as uint, a) as *c_void\n         };\n     }\n \n     #[inline]\n-    pub fn align_to<T>(&self) {\n+    pub fn align_to<T>(&mut self) {\n         self.align(sys::min_align_of::<T>());\n     }\n \n     #[inline]\n-    pub fn bump_past<T>(&self) {\n+    pub fn bump_past<T>(&mut self) {\n         self.bump(sys::size_of::<T>());\n     }\n }\n \n /// Abstract type-directed pointer-movement using the MovePtr trait\n impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n-    fn visit_bot(&self) -> bool {\n+    fn visit_bot(&mut self) -> bool {\n         self.align_to::<()>();\n         if ! self.inner.visit_bot() { return false; }\n         self.bump_past::<()>();\n         true\n     }\n \n-    fn visit_nil(&self) -> bool {\n+    fn visit_nil(&mut self) -> bool {\n         self.align_to::<()>();\n         if ! self.inner.visit_nil() { return false; }\n         self.bump_past::<()>();\n         true\n     }\n \n-    fn visit_bool(&self) -> bool {\n+    fn visit_bool(&mut self) -> bool {\n         self.align_to::<bool>();\n         if ! self.inner.visit_bool() { return false; }\n         self.bump_past::<bool>();\n         true\n     }\n \n-    fn visit_int(&self) -> bool {\n+    fn visit_int(&mut self) -> bool {\n         self.align_to::<int>();\n         if ! self.inner.visit_int() { return false; }\n         self.bump_past::<int>();\n         true\n     }\n \n-    fn visit_i8(&self) -> bool {\n+    fn visit_i8(&mut self) -> bool {\n         self.align_to::<i8>();\n         if ! self.inner.visit_i8() { return false; }\n         self.bump_past::<i8>();\n         true\n     }\n \n-    fn visit_i16(&self) -> bool {\n+    fn visit_i16(&mut self) -> bool {\n         self.align_to::<i16>();\n         if ! self.inner.visit_i16() { return false; }\n         self.bump_past::<i16>();\n         true\n     }\n \n-    fn visit_i32(&self) -> bool {\n+    fn visit_i32(&mut self) -> bool {\n         self.align_to::<i32>();\n         if ! self.inner.visit_i32() { return false; }\n         self.bump_past::<i32>();\n         true\n     }\n \n-    fn visit_i64(&self) -> bool {\n+    fn visit_i64(&mut self) -> bool {\n         self.align_to::<i64>();\n         if ! self.inner.visit_i64() { return false; }\n         self.bump_past::<i64>();\n         true\n     }\n \n-    fn visit_uint(&self) -> bool {\n+    fn visit_uint(&mut self) -> bool {\n         self.align_to::<uint>();\n         if ! self.inner.visit_uint() { return false; }\n         self.bump_past::<uint>();\n         true\n     }\n \n-    fn visit_u8(&self) -> bool {\n+    fn visit_u8(&mut self) -> bool {\n         self.align_to::<u8>();\n         if ! self.inner.visit_u8() { return false; }\n         self.bump_past::<u8>();\n         true\n     }\n \n-    fn visit_u16(&self) -> bool {\n+    fn visit_u16(&mut self) -> bool {\n         self.align_to::<u16>();\n         if ! self.inner.visit_u16() { return false; }\n         self.bump_past::<u16>();\n         true\n     }\n \n-    fn visit_u32(&self) -> bool {\n+    fn visit_u32(&mut self) -> bool {\n         self.align_to::<u32>();\n         if ! self.inner.visit_u32() { return false; }\n         self.bump_past::<u32>();\n         true\n     }\n \n-    fn visit_u64(&self) -> bool {\n+    fn visit_u64(&mut self) -> bool {\n         self.align_to::<u64>();\n         if ! self.inner.visit_u64() { return false; }\n         self.bump_past::<u64>();\n         true\n     }\n \n-    fn visit_float(&self) -> bool {\n+    fn visit_float(&mut self) -> bool {\n         self.align_to::<float>();\n         if ! self.inner.visit_float() { return false; }\n         self.bump_past::<float>();\n         true\n     }\n \n-    fn visit_f32(&self) -> bool {\n+    fn visit_f32(&mut self) -> bool {\n         self.align_to::<f32>();\n         if ! self.inner.visit_f32() { return false; }\n         self.bump_past::<f32>();\n         true\n     }\n \n-    fn visit_f64(&self) -> bool {\n+    fn visit_f64(&mut self) -> bool {\n         self.align_to::<f64>();\n         if ! self.inner.visit_f64() { return false; }\n         self.bump_past::<f64>();\n         true\n     }\n \n-    fn visit_char(&self) -> bool {\n+    fn visit_char(&mut self) -> bool {\n         self.align_to::<char>();\n         if ! self.inner.visit_char() { return false; }\n         self.bump_past::<char>();\n         true\n     }\n \n-    fn visit_estr_box(&self) -> bool {\n+    fn visit_estr_box(&mut self) -> bool {\n         self.align_to::<@str>();\n         if ! self.inner.visit_estr_box() { return false; }\n         self.bump_past::<@str>();\n         true\n     }\n \n-    fn visit_estr_uniq(&self) -> bool {\n+    fn visit_estr_uniq(&mut self) -> bool {\n         self.align_to::<~str>();\n         if ! self.inner.visit_estr_uniq() { return false; }\n         self.bump_past::<~str>();\n         true\n     }\n \n-    fn visit_estr_slice(&self) -> bool {\n+    fn visit_estr_slice(&mut self) -> bool {\n         self.align_to::<&'static str>();\n         if ! self.inner.visit_estr_slice() { return false; }\n         self.bump_past::<&'static str>();\n         true\n     }\n \n-    fn visit_estr_fixed(&self, n: uint,\n+    fn visit_estr_fixed(&mut self, n: uint,\n                         sz: uint,\n                         align: uint) -> bool {\n         self.align(align);\n@@ -224,83 +224,83 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<@u8>();\n         if ! self.inner.visit_box(mtbl, inner) { return false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n-    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n         if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n         self.bump_past::<~u8>();\n         true\n     }\n \n-    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n         if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n         self.bump_past::<~u8>();\n         true\n     }\n \n-    fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n         self.bump_past::<*u8>();\n         true\n     }\n \n-    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static u8>();\n         if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n         self.bump_past::<&'static u8>();\n         true\n     }\n \n-    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<raw::Vec<()>>();\n         if ! self.inner.visit_vec(mtbl, inner) { return false; }\n         true\n     }\n \n-    fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[u8]>();\n         if ! self.inner.visit_vec(mtbl, inner) { return false; }\n         self.bump_past::<~[u8]>();\n         true\n     }\n \n-    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<@[u8]>();\n         if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n         self.bump_past::<@[u8]>();\n         true\n     }\n \n-    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[u8]>();\n         if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n         self.bump_past::<~[u8]>();\n         true\n     }\n \n-    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[@u8]>();\n         if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n         self.bump_past::<~[@u8]>();\n         true\n     }\n \n-    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n         self.bump_past::<&'static [u8]>();\n         true\n     }\n \n-    fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool {\n         self.align(align);\n         if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n@@ -310,13 +310,13 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_enter_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_rec_field(&self, i: uint, name: &str,\n+    fn visit_rec_field(&mut self, i: uint, name: &str,\n                        mtbl: uint, inner: *TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n@@ -326,12 +326,12 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_leave_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_enter_class(&self, n_fields: uint, sz: uint, align: uint)\n+    fn visit_enter_class(&mut self, n_fields: uint, sz: uint, align: uint)\n                       -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_class(n_fields, sz, align) {\n@@ -340,7 +340,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_class_field(&self, i: uint, name: &str,\n+    fn visit_class_field(&mut self, i: uint, name: &str,\n                          mtbl: uint, inner: *TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n@@ -350,59 +350,59 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_leave_class(&self, n_fields: uint, sz: uint, align: uint)\n+    fn visit_leave_class(&mut self, n_fields: uint, sz: uint, align: uint)\n                       -> bool {\n         if ! self.inner.visit_leave_class(n_fields, sz, align) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_enter_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_tup_field(i, inner) { return false; }\n         unsafe { self.bump((*inner).size); }\n         true\n     }\n \n-    fn visit_leave_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_enter_fn(&self, purity: uint, proto: uint,\n+    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n         if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n             return false\n         }\n         true\n     }\n \n-    fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n         true\n     }\n \n-    fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, retstyle: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_fn(&self, purity: uint, proto: uint,\n+    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n         if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_enter_enum(&self, n_variants: uint,\n+    fn visit_enter_enum(&mut self, n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         sz: uint, align: uint)\n                      -> bool {\n@@ -413,7 +413,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_enter_enum_variant(&self, variant: uint,\n+    fn visit_enter_enum_variant(&mut self, variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n@@ -424,15 +424,15 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n+    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n         self.inner.push_ptr();\n         self.bump(offset);\n         if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n         self.inner.pop_ptr();\n         true\n     }\n \n-    fn visit_leave_enum_variant(&self, variant: uint,\n+    fn visit_leave_enum_variant(&mut self, variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n@@ -443,7 +443,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_leave_enum(&self, n_variants: uint,\n+    fn visit_leave_enum(&mut self, n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n@@ -453,38 +453,38 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_trait(&self) -> bool {\n+    fn visit_trait(&mut self) -> bool {\n         self.align_to::<@TyVisitor>();\n         if ! self.inner.visit_trait() { return false; }\n         self.bump_past::<@TyVisitor>();\n         true\n     }\n \n-    fn visit_param(&self, i: uint) -> bool {\n+    fn visit_param(&mut self, i: uint) -> bool {\n         if ! self.inner.visit_param(i) { return false; }\n         true\n     }\n \n-    fn visit_self(&self) -> bool {\n+    fn visit_self(&mut self) -> bool {\n         self.align_to::<&'static u8>();\n         if ! self.inner.visit_self() { return false; }\n         self.align_to::<&'static u8>();\n         true\n     }\n \n-    fn visit_type(&self) -> bool {\n+    fn visit_type(&mut self) -> bool {\n         if ! self.inner.visit_type() { return false; }\n         true\n     }\n \n-    fn visit_opaque_box(&self) -> bool {\n+    fn visit_opaque_box(&mut self) -> bool {\n         self.align_to::<@u8>();\n         if ! self.inner.visit_opaque_box() { return false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n-    fn visit_closure_ptr(&self, ck: uint) -> bool {\n+    fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n         self.align_to::<@fn()>();\n         if ! self.inner.visit_closure_ptr(ck) { return false; }\n         self.bump_past::<@fn()>();"}, {"sha": "56e0f83e05cf0ea722ae87f93a52dd82f474da9a", "filename": "src/libstd/reflect_stage0.rs", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Freflect_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Freflect_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect_stage0.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -0,0 +1,493 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Runtime type reflection\n+\n+*/\n+\n+#[allow(missing_doc)];\n+\n+use unstable::intrinsics::{Opaque, TyDesc, TyVisitor};\n+use libc::c_void;\n+use sys;\n+use unstable::raw;\n+\n+/**\n+ * Trait for visitor that wishes to reflect on data. To use this, create a\n+ * struct that encapsulates the set of pointers you wish to walk through a\n+ * data structure, and implement both `MovePtr` for it as well as `TyVisitor`;\n+ * then build a MovePtrAdaptor wrapped around your struct.\n+ */\n+pub trait MovePtr {\n+    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void);\n+    fn push_ptr(&self);\n+    fn pop_ptr(&self);\n+}\n+\n+/// Helper function for alignment calculation.\n+#[inline]\n+pub fn align(size: uint, align: uint) -> uint {\n+    ((size + align) - 1u) & !(align - 1u)\n+}\n+\n+/// Adaptor to wrap around visitors implementing MovePtr.\n+pub struct MovePtrAdaptor<V> {\n+    inner: V\n+}\n+pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n+    MovePtrAdaptor { inner: v }\n+}\n+\n+impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n+    #[inline]\n+    pub fn bump(&self, sz: uint) {\n+        do self.inner.move_ptr() |p| {\n+            ((p as uint) + sz) as *c_void\n+        };\n+    }\n+\n+    #[inline]\n+    pub fn align(&self, a: uint) {\n+        do self.inner.move_ptr() |p| {\n+            align(p as uint, a) as *c_void\n+        };\n+    }\n+\n+    #[inline]\n+    pub fn align_to<T>(&self) {\n+        self.align(sys::min_align_of::<T>());\n+    }\n+\n+    #[inline]\n+    pub fn bump_past<T>(&self) {\n+        self.bump(sys::size_of::<T>());\n+    }\n+}\n+\n+/// Abstract type-directed pointer-movement using the MovePtr trait\n+impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n+    fn visit_bot(&self) -> bool {\n+        self.align_to::<()>();\n+        if ! self.inner.visit_bot() { return false; }\n+        self.bump_past::<()>();\n+        true\n+    }\n+\n+    fn visit_nil(&self) -> bool {\n+        self.align_to::<()>();\n+        if ! self.inner.visit_nil() { return false; }\n+        self.bump_past::<()>();\n+        true\n+    }\n+\n+    fn visit_bool(&self) -> bool {\n+        self.align_to::<bool>();\n+        if ! self.inner.visit_bool() { return false; }\n+        self.bump_past::<bool>();\n+        true\n+    }\n+\n+    fn visit_int(&self) -> bool {\n+        self.align_to::<int>();\n+        if ! self.inner.visit_int() { return false; }\n+        self.bump_past::<int>();\n+        true\n+    }\n+\n+    fn visit_i8(&self) -> bool {\n+        self.align_to::<i8>();\n+        if ! self.inner.visit_i8() { return false; }\n+        self.bump_past::<i8>();\n+        true\n+    }\n+\n+    fn visit_i16(&self) -> bool {\n+        self.align_to::<i16>();\n+        if ! self.inner.visit_i16() { return false; }\n+        self.bump_past::<i16>();\n+        true\n+    }\n+\n+    fn visit_i32(&self) -> bool {\n+        self.align_to::<i32>();\n+        if ! self.inner.visit_i32() { return false; }\n+        self.bump_past::<i32>();\n+        true\n+    }\n+\n+    fn visit_i64(&self) -> bool {\n+        self.align_to::<i64>();\n+        if ! self.inner.visit_i64() { return false; }\n+        self.bump_past::<i64>();\n+        true\n+    }\n+\n+    fn visit_uint(&self) -> bool {\n+        self.align_to::<uint>();\n+        if ! self.inner.visit_uint() { return false; }\n+        self.bump_past::<uint>();\n+        true\n+    }\n+\n+    fn visit_u8(&self) -> bool {\n+        self.align_to::<u8>();\n+        if ! self.inner.visit_u8() { return false; }\n+        self.bump_past::<u8>();\n+        true\n+    }\n+\n+    fn visit_u16(&self) -> bool {\n+        self.align_to::<u16>();\n+        if ! self.inner.visit_u16() { return false; }\n+        self.bump_past::<u16>();\n+        true\n+    }\n+\n+    fn visit_u32(&self) -> bool {\n+        self.align_to::<u32>();\n+        if ! self.inner.visit_u32() { return false; }\n+        self.bump_past::<u32>();\n+        true\n+    }\n+\n+    fn visit_u64(&self) -> bool {\n+        self.align_to::<u64>();\n+        if ! self.inner.visit_u64() { return false; }\n+        self.bump_past::<u64>();\n+        true\n+    }\n+\n+    fn visit_float(&self) -> bool {\n+        self.align_to::<float>();\n+        if ! self.inner.visit_float() { return false; }\n+        self.bump_past::<float>();\n+        true\n+    }\n+\n+    fn visit_f32(&self) -> bool {\n+        self.align_to::<f32>();\n+        if ! self.inner.visit_f32() { return false; }\n+        self.bump_past::<f32>();\n+        true\n+    }\n+\n+    fn visit_f64(&self) -> bool {\n+        self.align_to::<f64>();\n+        if ! self.inner.visit_f64() { return false; }\n+        self.bump_past::<f64>();\n+        true\n+    }\n+\n+    fn visit_char(&self) -> bool {\n+        self.align_to::<char>();\n+        if ! self.inner.visit_char() { return false; }\n+        self.bump_past::<char>();\n+        true\n+    }\n+\n+    fn visit_estr_box(&self) -> bool {\n+        self.align_to::<@str>();\n+        if ! self.inner.visit_estr_box() { return false; }\n+        self.bump_past::<@str>();\n+        true\n+    }\n+\n+    fn visit_estr_uniq(&self) -> bool {\n+        self.align_to::<~str>();\n+        if ! self.inner.visit_estr_uniq() { return false; }\n+        self.bump_past::<~str>();\n+        true\n+    }\n+\n+    fn visit_estr_slice(&self) -> bool {\n+        self.align_to::<&'static str>();\n+        if ! self.inner.visit_estr_slice() { return false; }\n+        self.bump_past::<&'static str>();\n+        true\n+    }\n+\n+    fn visit_estr_fixed(&self, n: uint,\n+                        sz: uint,\n+                        align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<@u8>();\n+        if ! self.inner.visit_box(mtbl, inner) { return false; }\n+        self.bump_past::<@u8>();\n+        true\n+    }\n+\n+    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n+    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n+    fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<*u8>();\n+        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n+        self.bump_past::<*u8>();\n+        true\n+    }\n+\n+    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<&'static u8>();\n+        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n+        self.bump_past::<&'static u8>();\n+        true\n+    }\n+\n+    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<raw::Vec<()>>();\n+        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[u8]>();\n+        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n+        self.bump_past::<~[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<@[u8]>();\n+        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n+        self.bump_past::<@[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[u8]>();\n+        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n+        self.bump_past::<~[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[@u8]>();\n+        if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n+        self.bump_past::<~[@u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<&'static [u8]>();\n+        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n+        self.bump_past::<&'static [u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n+                        mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n+            return false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_enter_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_rec_field(&self, i: uint, name: &str,\n+                       mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n+            return false;\n+        }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_enter_class(&self, n_fields: uint, sz: uint, align: uint)\n+                      -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_class(n_fields, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_class_field(&self, i: uint, name: &str,\n+                         mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n+            return false;\n+        }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_class(&self, n_fields: uint, sz: uint, align: uint)\n+                      -> bool {\n+        if ! self.inner.visit_leave_class(n_fields, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_tup_field(i, inner) { return false; }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_enter_fn(&self, purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool {\n+        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n+            return false\n+        }\n+        true\n+    }\n+\n+    fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_leave_fn(&self, purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool {\n+        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_enum(&self, n_variants: uint,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        sz: uint, align: uint)\n+                     -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_enum(n_variants, get_disr, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_enum_variant(&self, variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool {\n+        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n+                                                 n_fields, name) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n+        self.inner.push_ptr();\n+        self.bump(offset);\n+        if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n+        self.inner.pop_ptr();\n+        true\n+    }\n+\n+    fn visit_leave_enum_variant(&self, variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool {\n+        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n+                                                 n_fields, name) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum(&self, n_variants: uint,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n+            return false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_trait(&self) -> bool {\n+        self.align_to::<@TyVisitor>();\n+        if ! self.inner.visit_trait() { return false; }\n+        self.bump_past::<@TyVisitor>();\n+        true\n+    }\n+\n+    fn visit_param(&self, i: uint) -> bool {\n+        if ! self.inner.visit_param(i) { return false; }\n+        true\n+    }\n+\n+    fn visit_self(&self) -> bool {\n+        self.align_to::<&'static u8>();\n+        if ! self.inner.visit_self() { return false; }\n+        self.align_to::<&'static u8>();\n+        true\n+    }\n+\n+    fn visit_type(&self) -> bool {\n+        if ! self.inner.visit_type() { return false; }\n+        true\n+    }\n+\n+    fn visit_opaque_box(&self) -> bool {\n+        self.align_to::<@u8>();\n+        if ! self.inner.visit_opaque_box() { return false; }\n+        self.bump_past::<@u8>();\n+        true\n+    }\n+\n+    fn visit_closure_ptr(&self, ck: uint) -> bool {\n+        self.align_to::<@fn()>();\n+        if ! self.inner.visit_closure_ptr(ck) { return false; }\n+        self.bump_past::<@fn()>();\n+        true\n+    }\n+}"}, {"sha": "15f4c24060c0684b45731256436f39b4b887198d", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 217, "deletions": 224, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -19,7 +19,7 @@ More runtime type reflection\n use cast::transmute;\n use char;\n use container::Container;\n-use io::{Writer, WriterUtil};\n+use rt::io;\n use iterator::Iterator;\n use libc::c_void;\n use option::{Some, None};\n@@ -32,59 +32,35 @@ use vec::OwnedVector;\n use unstable::intrinsics::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use unstable::raw;\n \n-#[cfg(test)] use io;\n-\n-/// Helpers\n-\n-trait EscapedCharWriter {\n-    fn write_escaped_char(&self, ch: char);\n-}\n-\n-impl EscapedCharWriter for @Writer {\n-    fn write_escaped_char(&self, ch: char) {\n-        match ch {\n-            '\\t' => self.write_str(\"\\\\t\"),\n-            '\\r' => self.write_str(\"\\\\r\"),\n-            '\\n' => self.write_str(\"\\\\n\"),\n-            '\\\\' => self.write_str(\"\\\\\\\\\"),\n-            '\\'' => self.write_str(\"\\\\'\"),\n-            '\"' => self.write_str(\"\\\\\\\"\"),\n-            '\\x20'..'\\x7e' => self.write_char(ch),\n-            _ => {\n-                do char::escape_unicode(ch) |c| {\n-                    self.write_char(c);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// Representations\n \n trait Repr {\n-    fn write_repr(&self, writer: @Writer);\n+    fn write_repr(&self, writer: &mut io::Writer);\n }\n \n impl Repr for () {\n-    fn write_repr(&self, writer: @Writer) { writer.write_str(\"()\"); }\n+    fn write_repr(&self, writer: &mut io::Writer) {\n+        writer.write(\"()\".as_bytes());\n+    }\n }\n \n impl Repr for bool {\n-    fn write_repr(&self, writer: @Writer) {\n-        writer.write_str(if *self { \"true\" } else { \"false\" })\n+    fn write_repr(&self, writer: &mut io::Writer) {\n+        let s = if *self { \"true\" } else { \"false\" };\n+        writer.write(s.as_bytes())\n     }\n }\n \n impl Repr for int {\n-    fn write_repr(&self, writer: @Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) {\n         do ::int::to_str_bytes(*self, 10u) |bits| {\n             writer.write(bits);\n         }\n     }\n }\n \n macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: @Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) {\n         do ::$ty::to_str_bytes(*self, 10u) |bits| {\n             writer.write(bits);\n             writer.write(bytes!($suffix));\n@@ -103,14 +79,14 @@ int_repr!(u32, \"u32\")\n int_repr!(u64, \"u64\")\n \n impl Repr for float {\n-    fn write_repr(&self, writer: @Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) {\n         let s = self.to_str();\n         writer.write(s.as_bytes());\n     }\n }\n \n macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: @Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) {\n         let s = self.to_str();\n         writer.write(s.as_bytes());\n         writer.write(bytes!($suffix));\n@@ -128,95 +104,105 @@ enum VariantState {\n     AlreadyFound\n }\n \n-pub struct ReprVisitor {\n-    ptr: @mut *c_void,\n-    ptr_stk: @mut ~[*c_void],\n-    var_stk: @mut ~[VariantState],\n-    writer: @Writer\n+pub struct ReprVisitor<'self> {\n+    ptr: *c_void,\n+    ptr_stk: ~[*c_void],\n+    var_stk: ~[VariantState],\n+    writer: &'self mut io::Writer\n }\n-pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n+\n+pub fn ReprVisitor<'a>(ptr: *c_void,\n+                       writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n     ReprVisitor {\n-        ptr: @mut ptr,\n-        ptr_stk: @mut ~[],\n-        var_stk: @mut ~[],\n+        ptr: ptr,\n+        ptr_stk: ~[],\n+        var_stk: ~[],\n         writer: writer,\n     }\n }\n \n-impl MovePtr for ReprVisitor {\n+impl<'self> MovePtr for ReprVisitor<'self> {\n     #[inline]\n-    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n-        *self.ptr = adjustment(*self.ptr);\n+    fn move_ptr(&mut self, adjustment: &fn(*c_void) -> *c_void) {\n+        self.ptr = adjustment(self.ptr);\n     }\n-    fn push_ptr(&self) {\n-        self.ptr_stk.push(*self.ptr);\n+    fn push_ptr(&mut self) {\n+        self.ptr_stk.push(self.ptr);\n     }\n-    fn pop_ptr(&self) {\n-        *self.ptr = self.ptr_stk.pop();\n+    fn pop_ptr(&mut self) {\n+        self.ptr = self.ptr_stk.pop();\n     }\n }\n \n-impl ReprVisitor {\n+impl<'self> ReprVisitor<'self> {\n     // Various helpers for the TyVisitor impl\n \n     #[inline]\n-    pub fn get<T>(&self, f: &fn(&T)) -> bool {\n+    pub fn get<T>(&mut self, f: &fn(&mut ReprVisitor, &T)) -> bool {\n         unsafe {\n-            f(transmute::<*c_void,&T>(*self.ptr));\n+            f(self, transmute::<*c_void,&T>(self.ptr));\n         }\n         true\n     }\n \n     #[inline]\n-    pub fn visit_inner(&self, inner: *TyDesc) -> bool {\n-        self.visit_ptr_inner(*self.ptr, inner)\n+    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n+        self.visit_ptr_inner(self.ptr, inner)\n     }\n \n     #[inline]\n-    pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n+    pub fn visit_ptr_inner(&mut self, ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n-            let u = ReprVisitor(ptr, self.writer);\n-            let v = reflect::MovePtrAdaptor(u);\n-            visit_tydesc(inner, &v as &TyVisitor);\n+            // This should call the constructor up above, but due to limiting\n+            // issues we have to recreate it here.\n+            let u = ReprVisitor {\n+                ptr: ptr,\n+                ptr_stk: ~[],\n+                var_stk: ~[],\n+                writer: ::cast::transmute_copy(&self.writer),\n+            };\n+            let mut v = reflect::MovePtrAdaptor(u);\n+            // Obviously this should not be a thing, but blame #8401 for now\n+            visit_tydesc(inner, &mut v as &mut TyVisitor);\n             true\n         }\n     }\n \n     #[inline]\n-    pub fn write<T:Repr>(&self) -> bool {\n-        do self.get |v:&T| {\n-            v.write_repr(self.writer);\n+    pub fn write<T:Repr>(&mut self) -> bool {\n+        do self.get |this, v:&T| {\n+            v.write_repr(unsafe { ::cast::transmute_copy(&this.writer) });\n         }\n     }\n \n-    pub fn write_escaped_slice(&self, slice: &str) {\n-        self.writer.write_char('\"');\n+    pub fn write_escaped_slice(&mut self, slice: &str) {\n+        self.writer.write(['\"' as u8]);\n         for ch in slice.iter() {\n-            self.writer.write_escaped_char(ch);\n+            self.write_escaped_char(ch);\n         }\n-        self.writer.write_char('\"');\n+        self.writer.write(['\"' as u8]);\n     }\n \n-    pub fn write_mut_qualifier(&self, mtbl: uint) {\n+    pub fn write_mut_qualifier(&mut self, mtbl: uint) {\n         if mtbl == 0 {\n-            self.writer.write_str(\"mut \");\n+            self.writer.write(\"mut \".as_bytes());\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n             assert_eq!(mtbl, 2);\n-            self.writer.write_str(\"const \");\n+            self.writer.write(\"const \".as_bytes());\n         }\n     }\n \n-    pub fn write_vec_range(&self,\n+    pub fn write_vec_range(&mut self,\n                            _mtbl: uint,\n                            ptr: *(),\n                            len: uint,\n                            inner: *TyDesc)\n                            -> bool {\n         let mut p = ptr as *u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        self.writer.write_char('[');\n+        self.writer.write(['[' as u8]);\n         let mut first = true;\n         let mut left = len;\n         // unit structs have 0 size, and don't loop forever.\n@@ -225,257 +211,264 @@ impl ReprVisitor {\n             if first {\n                 first = false;\n             } else {\n-                self.writer.write_str(\", \");\n+                self.writer.write(\", \".as_bytes());\n             }\n             self.visit_ptr_inner(p as *c_void, inner);\n             p = align(unsafe { ptr::offset(p, sz as int) as uint }, al) as *u8;\n             left -= dec;\n         }\n-        self.writer.write_char(']');\n+        self.writer.write([']' as u8]);\n         true\n     }\n \n-    pub fn write_unboxed_vec_repr(&self,\n+    pub fn write_unboxed_vec_repr(&mut self,\n                                   mtbl: uint,\n                                   v: &raw::Vec<()>,\n                                   inner: *TyDesc)\n                                   -> bool {\n         self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n                              v.fill, inner)\n     }\n+\n+    fn write_escaped_char(&mut self, ch: char) {\n+        match ch {\n+            '\\t' => self.writer.write(\"\\\\t\".as_bytes()),\n+            '\\r' => self.writer.write(\"\\\\r\".as_bytes()),\n+            '\\n' => self.writer.write(\"\\\\n\".as_bytes()),\n+            '\\\\' => self.writer.write(\"\\\\\\\\\".as_bytes()),\n+            '\\'' => self.writer.write(\"\\\\'\".as_bytes()),\n+            '\"' => self.writer.write(\"\\\\\\\"\".as_bytes()),\n+            '\\x20'..'\\x7e' => self.writer.write([ch as u8]),\n+            _ => {\n+                do char::escape_unicode(ch) |c| {\n+                    self.writer.write([c as u8]);\n+                }\n+            }\n+        }\n+    }\n }\n \n-impl TyVisitor for ReprVisitor {\n-    fn visit_bot(&self) -> bool {\n-        self.writer.write_str(\"!\");\n+impl<'self> TyVisitor for ReprVisitor<'self> {\n+    fn visit_bot(&mut self) -> bool {\n+        self.writer.write(\"!\".as_bytes());\n         true\n     }\n-    fn visit_nil(&self) -> bool { self.write::<()>() }\n-    fn visit_bool(&self) -> bool { self.write::<bool>() }\n-    fn visit_int(&self) -> bool { self.write::<int>() }\n-    fn visit_i8(&self) -> bool { self.write::<i8>() }\n-    fn visit_i16(&self) -> bool { self.write::<i16>() }\n-    fn visit_i32(&self) -> bool { self.write::<i32>()  }\n-    fn visit_i64(&self) -> bool { self.write::<i64>() }\n+    fn visit_nil(&mut self) -> bool { self.write::<()>() }\n+    fn visit_bool(&mut self) -> bool { self.write::<bool>() }\n+    fn visit_int(&mut self) -> bool { self.write::<int>() }\n+    fn visit_i8(&mut self) -> bool { self.write::<i8>() }\n+    fn visit_i16(&mut self) -> bool { self.write::<i16>() }\n+    fn visit_i32(&mut self) -> bool { self.write::<i32>()  }\n+    fn visit_i64(&mut self) -> bool { self.write::<i64>() }\n \n-    fn visit_uint(&self) -> bool { self.write::<uint>() }\n-    fn visit_u8(&self) -> bool { self.write::<u8>() }\n-    fn visit_u16(&self) -> bool { self.write::<u16>() }\n-    fn visit_u32(&self) -> bool { self.write::<u32>() }\n-    fn visit_u64(&self) -> bool { self.write::<u64>() }\n+    fn visit_uint(&mut self) -> bool { self.write::<uint>() }\n+    fn visit_u8(&mut self) -> bool { self.write::<u8>() }\n+    fn visit_u16(&mut self) -> bool { self.write::<u16>() }\n+    fn visit_u32(&mut self) -> bool { self.write::<u32>() }\n+    fn visit_u64(&mut self) -> bool { self.write::<u64>() }\n \n-    fn visit_float(&self) -> bool { self.write::<float>() }\n-    fn visit_f32(&self) -> bool { self.write::<f32>() }\n-    fn visit_f64(&self) -> bool { self.write::<f64>() }\n+    fn visit_float(&mut self) -> bool { self.write::<float>() }\n+    fn visit_f32(&mut self) -> bool { self.write::<f32>() }\n+    fn visit_f64(&mut self) -> bool { self.write::<f64>() }\n \n-    fn visit_char(&self) -> bool {\n-        do self.get::<char> |&ch| {\n-            self.writer.write_char('\\'');\n-            self.writer.write_escaped_char(ch);\n-            self.writer.write_char('\\'');\n+    fn visit_char(&mut self) -> bool {\n+        do self.get::<char> |this, &ch| {\n+            this.writer.write(['\\'' as u8]);\n+            this.write_escaped_char(ch);\n+            this.writer.write(['\\'' as u8]);\n         }\n     }\n \n-    fn visit_estr_box(&self) -> bool {\n-        do self.get::<@str> |s| {\n-            self.writer.write_char('@');\n-            self.write_escaped_slice(*s);\n+    fn visit_estr_box(&mut self) -> bool {\n+        do self.get::<@str> |this, s| {\n+            this.writer.write(['@' as u8]);\n+            this.write_escaped_slice(*s);\n         }\n     }\n \n-    fn visit_estr_uniq(&self) -> bool {\n-        do self.get::<~str> |s| {\n-            self.writer.write_char('~');\n-            self.write_escaped_slice(*s);\n+    fn visit_estr_uniq(&mut self) -> bool {\n+        do self.get::<~str> |this, s| {\n+            this.writer.write(['~' as u8]);\n+            this.write_escaped_slice(*s);\n         }\n     }\n \n-    fn visit_estr_slice(&self) -> bool {\n-        do self.get::<&str> |s| {\n-            self.write_escaped_slice(*s);\n+    fn visit_estr_slice(&mut self) -> bool {\n+        do self.get::<&str> |this, s| {\n+            this.write_escaped_slice(*s);\n         }\n     }\n \n     // Type no longer exists, vestigial function.\n-    fn visit_estr_fixed(&self, _n: uint, _sz: uint,\n+    fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n                         _align: uint) -> bool { fail!(); }\n \n-    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('@');\n+    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write(['@' as u8]);\n         self.write_mut_qualifier(mtbl);\n-        do self.get::<&raw::Box<()>> |b| {\n+        do self.get::<&raw::Box<()>> |this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, inner);\n+            this.visit_ptr_inner(p, inner);\n         }\n     }\n \n-    fn visit_uniq(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('~');\n-        do self.get::<*c_void> |b| {\n-            self.visit_ptr_inner(*b, inner);\n+    fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write(['~' as u8]);\n+        do self.get::<*c_void> |this, b| {\n+            this.visit_ptr_inner(*b, inner);\n         }\n     }\n \n-    fn visit_uniq_managed(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('~');\n-        do self.get::<&raw::Box<()>> |b| {\n+    fn visit_uniq_managed(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write(['~' as u8]);\n+        do self.get::<&raw::Box<()>> |this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, inner);\n+            this.visit_ptr_inner(p, inner);\n         }\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool {\n-        do self.get::<*c_void> |p| {\n-            self.writer.write_str(fmt!(\"(0x%x as *())\",\n-                                       *p as uint));\n+    fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n+        do self.get::<*c_void> |this, p| {\n+            write!(this.writer, \"({} as *\", *p);\n+            this.write_mut_qualifier(mtbl);\n+            this.writer.write(\"())\".as_bytes());\n         }\n     }\n \n-    #[cfg(not(stage0))]\n-    fn visit_ptr(&self, mtbl: uint, _inner: *TyDesc) -> bool {\n-        do self.get::<*c_void> |p| {\n-            self.writer.write_str(fmt!(\"(0x%x as *\", *p as uint));\n-            self.write_mut_qualifier(mtbl);\n-            self.writer.write_str(\"())\");\n-        }\n-    }\n-\n-    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('&');\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write(['&' as u8]);\n         self.write_mut_qualifier(mtbl);\n-        do self.get::<*c_void> |p| {\n-            self.visit_ptr_inner(*p, inner);\n+        do self.get::<*c_void> |this, p| {\n+            this.visit_ptr_inner(*p, inner);\n         }\n     }\n \n     // Type no longer exists, vestigial function.\n-    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n+    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n \n \n-    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<raw::Vec<()>> |b| {\n-            self.write_unboxed_vec_repr(mtbl, b, inner);\n+    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<raw::Vec<()>> |this, b| {\n+            this.write_unboxed_vec_repr(mtbl, b, inner);\n         }\n     }\n \n-    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Box<raw::Vec<()>>> |b| {\n-            self.writer.write_char('@');\n-            self.write_mut_qualifier(mtbl);\n-            self.write_unboxed_vec_repr(mtbl, &b.data, inner);\n+    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&raw::Box<raw::Vec<()>>> |this, b| {\n+            this.writer.write(['@' as u8]);\n+            this.write_mut_qualifier(mtbl);\n+            this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n         }\n     }\n \n-    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Vec<()>> |b| {\n-            self.writer.write_char('~');\n-            self.write_unboxed_vec_repr(mtbl, *b, inner);\n+    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&raw::Vec<()>> |this, b| {\n+            this.writer.write(['~' as u8]);\n+            this.write_unboxed_vec_repr(mtbl, *b, inner);\n         }\n     }\n \n-    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Box<raw::Vec<()>>> |b| {\n-            self.writer.write_char('~');\n-            self.write_unboxed_vec_repr(mtbl, &b.data, inner);\n+    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&raw::Box<raw::Vec<()>>> |this, b| {\n+            this.writer.write(['~' as u8]);\n+            this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n         }\n     }\n \n-    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<raw::Slice<()>> |s| {\n-            self.writer.write_char('&');\n-            self.write_vec_range(mtbl, s.data, s.len, inner);\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<raw::Slice<()>> |this, s| {\n+            this.writer.write(['&' as u8]);\n+            this.write_vec_range(mtbl, s.data, s.len, inner);\n         }\n     }\n \n-    fn visit_evec_fixed(&self, _n: uint, sz: uint, _align: uint,\n+    fn visit_evec_fixed(&mut self, _n: uint, sz: uint, _align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<()> |b| {\n-            self.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n+        do self.get::<()> |this, b| {\n+            this.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n         }\n     }\n \n-    fn visit_enter_rec(&self, _n_fields: uint,\n+    fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('{');\n+        self.writer.write(['{' as u8]);\n         true\n     }\n \n-    fn visit_rec_field(&self, i: uint, name: &str,\n+    fn visit_rec_field(&mut self, i: uint, name: &str,\n                        mtbl: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write_str(\", \");\n+            self.writer.write(\", \".as_bytes());\n         }\n         self.write_mut_qualifier(mtbl);\n-        self.writer.write_str(name);\n-        self.writer.write_str(\": \");\n+        self.writer.write(name.as_bytes());\n+        self.writer.write(\": \".as_bytes());\n         self.visit_inner(inner);\n         true\n     }\n \n-    fn visit_leave_rec(&self, _n_fields: uint,\n+    fn visit_leave_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('}');\n+        self.writer.write(['}' as u8]);\n         true\n     }\n \n-    fn visit_enter_class(&self, _n_fields: uint,\n+    fn visit_enter_class(&mut self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('{');\n+        self.writer.write(['{' as u8]);\n         true\n     }\n-    fn visit_class_field(&self, i: uint, name: &str,\n+    fn visit_class_field(&mut self, i: uint, name: &str,\n                          mtbl: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write_str(\", \");\n+            self.writer.write(\", \".as_bytes());\n         }\n         self.write_mut_qualifier(mtbl);\n-        self.writer.write_str(name);\n-        self.writer.write_str(\": \");\n+        self.writer.write(name.as_bytes());\n+        self.writer.write(\": \".as_bytes());\n         self.visit_inner(inner);\n         true\n     }\n-    fn visit_leave_class(&self, _n_fields: uint,\n+    fn visit_leave_class(&mut self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('}');\n+        self.writer.write(['}' as u8]);\n         true\n     }\n \n-    fn visit_enter_tup(&self, _n_fields: uint,\n+    fn visit_enter_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('(');\n+        self.writer.write(['(' as u8]);\n         true\n     }\n-    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write_str(\", \");\n+            self.writer.write(\", \".as_bytes());\n         }\n         self.visit_inner(inner);\n         true\n     }\n-    fn visit_leave_tup(&self, _n_fields: uint,\n+    fn visit_leave_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n         if _n_fields == 1 {\n-            self.writer.write_char(',');\n+            self.writer.write([',' as u8]);\n         }\n-        self.writer.write_char(')');\n+        self.writer.write([')' as u8]);\n         true\n     }\n \n-    fn visit_enter_enum(&self,\n+    fn visit_enter_enum(&mut self,\n                         _n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint,\n                         _align: uint) -> bool {\n-        let var_stk: &mut ~[VariantState] = self.var_stk;\n         let disr = unsafe {\n-            get_disr(transmute(*self.ptr))\n+            get_disr(transmute(self.ptr))\n         };\n-        var_stk.push(SearchingFor(disr));\n+        self.var_stk.push(SearchingFor(disr));\n         true\n     }\n \n-    fn visit_enter_enum_variant(&self, _variant: uint,\n+    fn visit_enter_enum_variant(&mut self, _variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n@@ -495,23 +488,23 @@ impl TyVisitor for ReprVisitor {\n         }\n \n         if write {\n-            self.writer.write_str(name);\n+            self.writer.write(name.as_bytes());\n             if n_fields > 0 {\n-                self.writer.write_char('(');\n+                self.writer.write(['(' as u8]);\n             }\n         }\n         true\n     }\n \n-    fn visit_enum_variant_field(&self,\n+    fn visit_enum_variant_field(&mut self,\n                                 i: uint,\n                                 _offset: uint,\n                                 inner: *TyDesc)\n                                 -> bool {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if i != 0 {\n-                    self.writer.write_str(\", \");\n+                    self.writer.write(\", \".as_bytes());\n                 }\n                 if ! self.visit_inner(inner) {\n                     return false;\n@@ -522,69 +515,68 @@ impl TyVisitor for ReprVisitor {\n         true\n     }\n \n-    fn visit_leave_enum_variant(&self, _variant: uint,\n+    fn visit_leave_enum_variant(&mut self, _variant: uint,\n                                 _disr_val: int,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if n_fields > 0 {\n-                    self.writer.write_char(')');\n+                    self.writer.write([')' as u8]);\n                 }\n             }\n             _ => ()\n         }\n         true\n     }\n \n-    fn visit_leave_enum(&self,\n+    fn visit_leave_enum(&mut self,\n                         _n_variants: uint,\n                         _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint,\n                         _align: uint)\n                         -> bool {\n-        let var_stk: &mut ~[VariantState] = self.var_stk;\n-        match var_stk.pop() {\n+        match self.var_stk.pop() {\n             SearchingFor(*) => fail!(\"enum value matched no variant\"),\n             _ => true\n         }\n     }\n \n-    fn visit_enter_fn(&self, _purity: uint, _proto: uint,\n+    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(&self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n         true\n     }\n-    fn visit_fn_output(&self, _retstyle: uint, _inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, _retstyle: uint, _inner: *TyDesc) -> bool {\n         true\n     }\n-    fn visit_leave_fn(&self, _purity: uint, _proto: uint,\n+    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n \n \n-    fn visit_trait(&self) -> bool { true }\n-    fn visit_param(&self, _i: uint) -> bool { true }\n-    fn visit_self(&self) -> bool { true }\n-    fn visit_type(&self) -> bool { true }\n+    fn visit_trait(&mut self) -> bool { true }\n+    fn visit_param(&mut self, _i: uint) -> bool { true }\n+    fn visit_self(&mut self) -> bool { true }\n+    fn visit_type(&mut self) -> bool { true }\n \n-    fn visit_opaque_box(&self) -> bool {\n-        self.writer.write_char('@');\n-        do self.get::<&raw::Box<()>> |b| {\n+    fn visit_opaque_box(&mut self) -> bool {\n+        self.writer.write(['@' as u8]);\n+        do self.get::<&raw::Box<()>> |this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, b.type_desc);\n+            this.visit_ptr_inner(p, b.type_desc);\n         }\n     }\n \n-    fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n+    fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }\n }\n \n-pub fn write_repr<T>(writer: @Writer, object: &T) {\n+pub fn write_repr<T>(writer: &mut io::Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n         let tydesc = get_tydesc::<T>();\n         let u = ReprVisitor(ptr, writer);\n-        let v = reflect::MovePtrAdaptor(u);\n-        visit_tydesc(tydesc, &v as &TyVisitor)\n+        let mut v = reflect::MovePtrAdaptor(u);\n+        visit_tydesc(tydesc, &mut v as &mut TyVisitor);\n     }\n }\n \n@@ -593,14 +585,15 @@ struct P {a: int, b: float}\n \n #[test]\n fn test_repr() {\n+    use str;\n+    use str::Str;\n+    use rt::io::Decorator;\n \n     fn exact_test<T>(t: &T, e:&str) {\n-        let s : &str = io::with_str_writer(|w| write_repr(w, t));\n-        if s != e {\n-            error!(\"expected '%s', got '%s'\",\n-                   e, s);\n-        }\n-        assert_eq!(s, e);\n+        let mut m = io::mem::MemWriter::new();\n+        write_repr(&mut m as &mut io::Writer, t);\n+        let s = str::from_bytes_owned(m.inner());\n+        assert_eq!(s.as_slice(), e);\n     }\n \n     exact_test(&10, \"10\");"}, {"sha": "4e580d91d0c899bb3c6fa91b6a85832c6f497226", "filename": "src/libstd/repr_stage0.rs", "status": "added", "additions": 626, "deletions": 0, "changes": 626, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Frepr_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Frepr_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr_stage0.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -0,0 +1,626 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+More runtime type reflection\n+\n+*/\n+\n+#[allow(missing_doc)];\n+\n+use cast::transmute;\n+use char;\n+use container::Container;\n+use io::{Writer, WriterUtil};\n+use iterator::Iterator;\n+use libc::c_void;\n+use option::{Some, None};\n+use ptr;\n+use reflect;\n+use reflect::{MovePtr, align};\n+use str::StrSlice;\n+use to_str::ToStr;\n+use vec::OwnedVector;\n+use unstable::intrinsics::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n+use unstable::raw;\n+\n+#[cfg(test)] use io;\n+\n+/// Helpers\n+\n+trait EscapedCharWriter {\n+    fn write_escaped_char(&self, ch: char);\n+}\n+\n+impl EscapedCharWriter for @Writer {\n+    fn write_escaped_char(&self, ch: char) {\n+        match ch {\n+            '\\t' => self.write_str(\"\\\\t\"),\n+            '\\r' => self.write_str(\"\\\\r\"),\n+            '\\n' => self.write_str(\"\\\\n\"),\n+            '\\\\' => self.write_str(\"\\\\\\\\\"),\n+            '\\'' => self.write_str(\"\\\\'\"),\n+            '\"' => self.write_str(\"\\\\\\\"\"),\n+            '\\x20'..'\\x7e' => self.write_char(ch),\n+            _ => {\n+                do char::escape_unicode(ch) |c| {\n+                    self.write_char(c);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Representations\n+\n+trait Repr {\n+    fn write_repr(&self, writer: @Writer);\n+}\n+\n+impl Repr for () {\n+    fn write_repr(&self, writer: @Writer) { writer.write_str(\"()\"); }\n+}\n+\n+impl Repr for bool {\n+    fn write_repr(&self, writer: @Writer) {\n+        writer.write_str(if *self { \"true\" } else { \"false\" })\n+    }\n+}\n+\n+macro_rules! int_repr(($ty:ident) => (impl Repr for $ty {\n+    fn write_repr(&self, writer: @Writer) {\n+        do ::$ty::to_str_bytes(*self, 10u) |bits| {\n+            writer.write(bits);\n+        }\n+    }\n+}))\n+\n+int_repr!(int)\n+int_repr!(i8)\n+int_repr!(i16)\n+int_repr!(i32)\n+int_repr!(i64)\n+int_repr!(uint)\n+int_repr!(u8)\n+int_repr!(u16)\n+int_repr!(u32)\n+int_repr!(u64)\n+\n+macro_rules! num_repr(($ty:ident) => (impl Repr for $ty {\n+    fn write_repr(&self, writer: @Writer) {\n+        let s = self.to_str();\n+        writer.write(s.as_bytes());\n+    }\n+}))\n+\n+num_repr!(float)\n+num_repr!(f32)\n+num_repr!(f64)\n+\n+// New implementation using reflect::MovePtr\n+\n+enum VariantState {\n+    SearchingFor(int),\n+    Matched,\n+    AlreadyFound\n+}\n+\n+pub struct ReprVisitor {\n+    ptr: @mut *c_void,\n+    ptr_stk: @mut ~[*c_void],\n+    var_stk: @mut ~[VariantState],\n+    writer: @Writer\n+}\n+pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n+    ReprVisitor {\n+        ptr: @mut ptr,\n+        ptr_stk: @mut ~[],\n+        var_stk: @mut ~[],\n+        writer: writer,\n+    }\n+}\n+\n+impl MovePtr for ReprVisitor {\n+    #[inline]\n+    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n+        *self.ptr = adjustment(*self.ptr);\n+    }\n+    fn push_ptr(&self) {\n+        self.ptr_stk.push(*self.ptr);\n+    }\n+    fn pop_ptr(&self) {\n+        *self.ptr = self.ptr_stk.pop();\n+    }\n+}\n+\n+impl ReprVisitor {\n+    // Various helpers for the TyVisitor impl\n+\n+    #[inline]\n+    pub fn get<T>(&self, f: &fn(&T)) -> bool {\n+        unsafe {\n+            f(transmute::<*c_void,&T>(*self.ptr));\n+        }\n+        true\n+    }\n+\n+    #[inline]\n+    pub fn visit_inner(&self, inner: *TyDesc) -> bool {\n+        self.visit_ptr_inner(*self.ptr, inner)\n+    }\n+\n+    #[inline]\n+    pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n+        unsafe {\n+            let u = ReprVisitor(ptr, self.writer);\n+            let v = reflect::MovePtrAdaptor(u);\n+            visit_tydesc(inner, @v as @TyVisitor);\n+            true\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn write<T:Repr>(&self) -> bool {\n+        do self.get |v:&T| {\n+            v.write_repr(self.writer);\n+        }\n+    }\n+\n+    pub fn write_escaped_slice(&self, slice: &str) {\n+        self.writer.write_char('\"');\n+        for ch in slice.iter() {\n+            self.writer.write_escaped_char(ch);\n+        }\n+        self.writer.write_char('\"');\n+    }\n+\n+    pub fn write_mut_qualifier(&self, mtbl: uint) {\n+        if mtbl == 0 {\n+            self.writer.write_str(\"mut \");\n+        } else if mtbl == 1 {\n+            // skip, this is ast::m_imm\n+        } else {\n+            assert_eq!(mtbl, 2);\n+            self.writer.write_str(\"const \");\n+        }\n+    }\n+\n+    pub fn write_vec_range(&self,\n+                           _mtbl: uint,\n+                           ptr: *(),\n+                           len: uint,\n+                           inner: *TyDesc)\n+                           -> bool {\n+        let mut p = ptr as *u8;\n+        let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n+        self.writer.write_char('[');\n+        let mut first = true;\n+        let mut left = len;\n+        // unit structs have 0 size, and don't loop forever.\n+        let dec = if sz == 0 {1} else {sz};\n+        while left > 0 {\n+            if first {\n+                first = false;\n+            } else {\n+                self.writer.write_str(\", \");\n+            }\n+            self.visit_ptr_inner(p as *c_void, inner);\n+            unsafe {\n+                p = align(ptr::offset(p, sz as int) as uint, al) as *u8;\n+            }\n+            left -= dec;\n+        }\n+        self.writer.write_char(']');\n+        true\n+    }\n+\n+    pub fn write_unboxed_vec_repr(&self,\n+                                  mtbl: uint,\n+                                  v: &raw::Vec<()>,\n+                                  inner: *TyDesc)\n+                                  -> bool {\n+        self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n+                             v.fill, inner)\n+    }\n+}\n+\n+impl TyVisitor for ReprVisitor {\n+    fn visit_bot(&self) -> bool {\n+        self.writer.write_str(\"!\");\n+        true\n+    }\n+    fn visit_nil(&self) -> bool { self.write::<()>() }\n+    fn visit_bool(&self) -> bool { self.write::<bool>() }\n+    fn visit_int(&self) -> bool { self.write::<int>() }\n+    fn visit_i8(&self) -> bool { self.write::<i8>() }\n+    fn visit_i16(&self) -> bool { self.write::<i16>() }\n+    fn visit_i32(&self) -> bool { self.write::<i32>()  }\n+    fn visit_i64(&self) -> bool { self.write::<i64>() }\n+\n+    fn visit_uint(&self) -> bool { self.write::<uint>() }\n+    fn visit_u8(&self) -> bool { self.write::<u8>() }\n+    fn visit_u16(&self) -> bool { self.write::<u16>() }\n+    fn visit_u32(&self) -> bool { self.write::<u32>() }\n+    fn visit_u64(&self) -> bool { self.write::<u64>() }\n+\n+    fn visit_float(&self) -> bool { self.write::<float>() }\n+    fn visit_f32(&self) -> bool { self.write::<f32>() }\n+    fn visit_f64(&self) -> bool { self.write::<f64>() }\n+\n+    fn visit_char(&self) -> bool {\n+        do self.get::<char> |&ch| {\n+            self.writer.write_char('\\'');\n+            self.writer.write_escaped_char(ch);\n+            self.writer.write_char('\\'');\n+        }\n+    }\n+\n+    fn visit_estr_box(&self) -> bool {\n+        do self.get::<@str> |s| {\n+            self.writer.write_char('@');\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+    fn visit_estr_uniq(&self) -> bool {\n+        do self.get::<~str> |s| {\n+            self.writer.write_char('~');\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+    fn visit_estr_slice(&self) -> bool {\n+        do self.get::<&str> |s| {\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_estr_fixed(&self, _n: uint, _sz: uint,\n+                        _align: uint) -> bool { fail!(); }\n+\n+    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('@');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<&raw::Box<()>> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, inner);\n+        }\n+    }\n+\n+    fn visit_uniq(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('~');\n+        do self.get::<*c_void> |b| {\n+            self.visit_ptr_inner(*b, inner);\n+        }\n+    }\n+\n+    fn visit_uniq_managed(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('~');\n+        do self.get::<&raw::Box<()>> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, inner);\n+        }\n+    }\n+\n+    fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool {\n+        do self.get::<*c_void> |p| {\n+            self.writer.write_str(fmt!(\"(0x%x as *())\",\n+                                       *p as uint));\n+        }\n+    }\n+\n+    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('&');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<*c_void> |p| {\n+            self.visit_ptr_inner(*p, inner);\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n+\n+\n+    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<raw::Vec<()>> |b| {\n+            self.write_unboxed_vec_repr(mtbl, b, inner);\n+        }\n+    }\n+\n+    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&raw::Box<raw::Vec<()>>> |b| {\n+            self.writer.write_char('@');\n+            self.write_mut_qualifier(mtbl);\n+            self.write_unboxed_vec_repr(mtbl, &b.data, inner);\n+        }\n+    }\n+\n+    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&raw::Vec<()>> |b| {\n+            self.writer.write_char('~');\n+            self.write_unboxed_vec_repr(mtbl, *b, inner);\n+        }\n+    }\n+\n+    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&raw::Box<raw::Vec<()>>> |b| {\n+            self.writer.write_char('~');\n+            self.write_unboxed_vec_repr(mtbl, &b.data, inner);\n+        }\n+    }\n+\n+    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<raw::Slice<()>> |s| {\n+            self.writer.write_char('&');\n+            self.write_vec_range(mtbl, s.data, s.len, inner);\n+        }\n+    }\n+\n+    fn visit_evec_fixed(&self, _n: uint, sz: uint, _align: uint,\n+                        mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<()> |b| {\n+            self.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n+        }\n+    }\n+\n+    fn visit_enter_rec(&self, _n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('{');\n+        true\n+    }\n+\n+    fn visit_rec_field(&self, i: uint, name: &str,\n+                       mtbl: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.write_mut_qualifier(mtbl);\n+        self.writer.write_str(name);\n+        self.writer.write_str(\": \");\n+        self.visit_inner(inner);\n+        true\n+    }\n+\n+    fn visit_leave_rec(&self, _n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('}');\n+        true\n+    }\n+\n+    fn visit_enter_class(&self, _n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('{');\n+        true\n+    }\n+    fn visit_class_field(&self, i: uint, name: &str,\n+                         mtbl: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.write_mut_qualifier(mtbl);\n+        self.writer.write_str(name);\n+        self.writer.write_str(\": \");\n+        self.visit_inner(inner);\n+        true\n+    }\n+    fn visit_leave_class(&self, _n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('}');\n+        true\n+    }\n+\n+    fn visit_enter_tup(&self, _n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('(');\n+        true\n+    }\n+    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.visit_inner(inner);\n+        true\n+    }\n+    fn visit_leave_tup(&self, _n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        if _n_fields == 1 {\n+            self.writer.write_char(',');\n+        }\n+        self.writer.write_char(')');\n+        true\n+    }\n+\n+    fn visit_enter_enum(&self,\n+                        _n_variants: uint,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        _sz: uint,\n+                        _align: uint) -> bool {\n+        let var_stk: &mut ~[VariantState] = self.var_stk;\n+        let disr = unsafe {\n+            get_disr(transmute(*self.ptr))\n+        };\n+        var_stk.push(SearchingFor(disr));\n+        true\n+    }\n+\n+    fn visit_enter_enum_variant(&self, _variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool {\n+        let mut write = false;\n+        match self.var_stk.pop() {\n+            SearchingFor(sought) => {\n+                if disr_val == sought {\n+                    self.var_stk.push(Matched);\n+                    write = true;\n+                } else {\n+                    self.var_stk.push(SearchingFor(sought));\n+                }\n+            }\n+            Matched | AlreadyFound => {\n+                self.var_stk.push(AlreadyFound);\n+            }\n+        }\n+\n+        if write {\n+            self.writer.write_str(name);\n+            if n_fields > 0 {\n+                self.writer.write_char('(');\n+            }\n+        }\n+        true\n+    }\n+\n+    fn visit_enum_variant_field(&self,\n+                                i: uint,\n+                                _offset: uint,\n+                                inner: *TyDesc)\n+                                -> bool {\n+        match self.var_stk[self.var_stk.len() - 1] {\n+            Matched => {\n+                if i != 0 {\n+                    self.writer.write_str(\", \");\n+                }\n+                if ! self.visit_inner(inner) {\n+                    return false;\n+                }\n+            }\n+            _ => ()\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum_variant(&self, _variant: uint,\n+                                _disr_val: int,\n+                                n_fields: uint,\n+                                _name: &str) -> bool {\n+        match self.var_stk[self.var_stk.len() - 1] {\n+            Matched => {\n+                if n_fields > 0 {\n+                    self.writer.write_char(')');\n+                }\n+            }\n+            _ => ()\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum(&self,\n+                        _n_variants: uint,\n+                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        _sz: uint,\n+                        _align: uint)\n+                        -> bool {\n+        let var_stk: &mut ~[VariantState] = self.var_stk;\n+        match var_stk.pop() {\n+            SearchingFor(*) => fail!(\"enum value matched no variant\"),\n+            _ => true\n+        }\n+    }\n+\n+    fn visit_enter_fn(&self, _purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+    fn visit_fn_input(&self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n+        true\n+    }\n+    fn visit_fn_output(&self, _retstyle: uint, _inner: *TyDesc) -> bool {\n+        true\n+    }\n+    fn visit_leave_fn(&self, _purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+\n+\n+    fn visit_trait(&self) -> bool { true }\n+    fn visit_param(&self, _i: uint) -> bool { true }\n+    fn visit_self(&self) -> bool { true }\n+    fn visit_type(&self) -> bool { true }\n+\n+    fn visit_opaque_box(&self) -> bool {\n+        self.writer.write_char('@');\n+        do self.get::<&raw::Box<()>> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, b.type_desc);\n+        }\n+    }\n+\n+    fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n+}\n+\n+pub fn write_repr<T>(writer: @Writer, object: &T) {\n+    unsafe {\n+        let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n+        let tydesc = get_tydesc::<T>();\n+        let u = ReprVisitor(ptr, writer);\n+        let v = reflect::MovePtrAdaptor(u);\n+        visit_tydesc(tydesc, @v as @TyVisitor)\n+    }\n+}\n+\n+#[cfg(test)]\n+struct P {a: int, b: float}\n+\n+#[test]\n+fn test_repr() {\n+\n+    fn exact_test<T>(t: &T, e:&str) {\n+        let s : &str = io::with_str_writer(|w| write_repr(w, t));\n+        if s != e {\n+            error!(\"expected '%s', got '%s'\",\n+                   e, s);\n+        }\n+        assert_eq!(s, e);\n+    }\n+\n+    exact_test(&10, \"10\");\n+    exact_test(&true, \"true\");\n+    exact_test(&false, \"false\");\n+    exact_test(&1.234, \"1.234\");\n+    exact_test(&(&\"hello\"), \"\\\"hello\\\"\");\n+    exact_test(&(@\"hello\"), \"@\\\"hello\\\"\");\n+    exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n+\n+    exact_test(&(@10), \"@10\");\n+    exact_test(&(@mut 10), \"@10\"); // FIXME: #4210: incorrect\n+    exact_test(&((@mut 10, 2)), \"(@mut 10, 2)\");\n+    exact_test(&(~10), \"~10\");\n+    exact_test(&(&10), \"&10\");\n+    let mut x = 10;\n+    exact_test(&(&mut x), \"&mut 10\");\n+    exact_test(&(@mut [1, 2]), \"@mut [1, 2]\");\n+\n+    exact_test(&(1,), \"(1,)\");\n+    exact_test(&(@[1,2,3,4,5,6,7,8]),\n+               \"@[1, 2, 3, 4, 5, 6, 7, 8]\");\n+    exact_test(&(@[1u8,2u8,3u8,4u8]),\n+               \"@[1, 2, 3, 4]\");\n+    exact_test(&(@[\"hi\", \"there\"]),\n+               \"@[\\\"hi\\\", \\\"there\\\"]\");\n+    exact_test(&(~[\"hi\", \"there\"]),\n+               \"~[\\\"hi\\\", \\\"there\\\"]\");\n+    exact_test(&(&[\"hi\", \"there\"]),\n+               \"&[\\\"hi\\\", \\\"there\\\"]\");\n+    exact_test(&(P{a:10, b:1.234}),\n+               \"{a: 10, b: 1.234}\");\n+    exact_test(&(@P{a:10, b:1.234}),\n+               \"@{a: 10, b: 1.234}\");\n+    exact_test(&(~P{a:10, b:1.234}),\n+               \"~{a: 10, b: 1.234}\");\n+    exact_test(&(10_u8, ~\"hello\"),\n+               \"(10, ~\\\"hello\\\")\");\n+    exact_test(&(10_u16, ~\"hello\"),\n+               \"(10, ~\\\"hello\\\")\");\n+    exact_test(&(10_u32, ~\"hello\"),\n+               \"(10, ~\\\"hello\\\")\");\n+    exact_test(&(10_u64, ~\"hello\"),\n+               \"(10, ~\\\"hello\\\")\");\n+\n+    struct Foo;\n+    exact_test(&(~[Foo, Foo, Foo]), \"~[{}, {}, {}]\");\n+}"}, {"sha": "ce0202ded7eda2ecd890394c07b439a88ae73038", "filename": "src/libstd/std.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -178,8 +178,14 @@ pub mod run;\n pub mod sys;\n pub mod cast;\n pub mod fmt;\n+#[cfg(stage0)] #[path = \"repr_stage0.rs\"]\n+pub mod repr;\n+#[cfg(not(stage0))]\n pub mod repr;\n pub mod cleanup;\n+#[cfg(stage0)] #[path = \"reflect_stage0.rs\"]\n+pub mod reflect;\n+#[cfg(not(stage0))]\n pub mod reflect;\n pub mod condition;\n pub mod logging;"}, {"sha": "cfc285488a90f30c218e3d9dddd474687a62910d", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -14,6 +14,7 @@\n \n use c_str::ToCStr;\n use cast;\n+#[cfg(stage0)]\n use io;\n use libc;\n use libc::{c_char, size_t};\n@@ -91,9 +92,19 @@ pub fn refcount<T>(t: @T) -> uint {\n     }\n }\n \n+#[cfg(not(stage0))]\n pub fn log_str<T>(t: &T) -> ~str {\n-    do io::with_str_writer |wr| {\n-        repr::write_repr(wr, t)\n+    use rt::io;\n+    use rt::io::Decorator;\n+\n+    let mut result = io::mem::MemWriter::new();\n+    repr::write_repr(&mut result as &mut io::Writer, t);\n+    str::from_bytes_owned(result.inner())\n+}\n+#[cfg(stage0)]\n+pub fn log_str<T>(t: &T) -> ~str {\n+    do io::with_str_writer |w| {\n+        repr::write_repr(w, t)\n     }\n }\n "}, {"sha": "018f8532eab7c412615f453d2e644bd3546b2a9a", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 100, "deletions": 1, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -73,7 +73,7 @@ pub struct TyDesc {\n pub enum Opaque { }\n \n #[lang=\"ty_visitor\"]\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n pub trait TyVisitor {\n     fn visit_bot(&self) -> bool;\n     fn visit_nil(&self) -> bool;\n@@ -168,6 +168,102 @@ pub trait TyVisitor {\n     fn visit_closure_ptr(&self, ck: uint) -> bool;\n }\n \n+#[lang=\"ty_visitor\"]\n+#[cfg(not(test), not(stage0))]\n+pub trait TyVisitor {\n+    fn visit_bot(&mut self) -> bool;\n+    fn visit_nil(&mut self) -> bool;\n+    fn visit_bool(&mut self) -> bool;\n+\n+    fn visit_int(&mut self) -> bool;\n+    fn visit_i8(&mut self) -> bool;\n+    fn visit_i16(&mut self) -> bool;\n+    fn visit_i32(&mut self) -> bool;\n+    fn visit_i64(&mut self) -> bool;\n+\n+    fn visit_uint(&mut self) -> bool;\n+    fn visit_u8(&mut self) -> bool;\n+    fn visit_u16(&mut self) -> bool;\n+    fn visit_u32(&mut self) -> bool;\n+    fn visit_u64(&mut self) -> bool;\n+\n+    fn visit_float(&mut self) -> bool;\n+    fn visit_f32(&mut self) -> bool;\n+    fn visit_f64(&mut self) -> bool;\n+\n+    fn visit_char(&mut self) -> bool;\n+\n+    fn visit_estr_box(&mut self) -> bool;\n+    fn visit_estr_uniq(&mut self) -> bool;\n+    fn visit_estr_slice(&mut self) -> bool;\n+    fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;\n+\n+    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+\n+    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n+                        mtbl: uint, inner: *TyDesc) -> bool;\n+\n+    fn visit_enter_rec(&mut self, n_fields: uint,\n+                       sz: uint, align: uint) -> bool;\n+    fn visit_rec_field(&mut self, i: uint, name: &str,\n+                       mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_rec(&mut self, n_fields: uint,\n+                       sz: uint, align: uint) -> bool;\n+\n+    fn visit_enter_class(&mut self, n_fields: uint,\n+                         sz: uint, align: uint) -> bool;\n+    fn visit_class_field(&mut self, i: uint, name: &str,\n+                         mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_class(&mut self, n_fields: uint,\n+                         sz: uint, align: uint) -> bool;\n+\n+    fn visit_enter_tup(&mut self, n_fields: uint,\n+                       sz: uint, align: uint) -> bool;\n+    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_tup(&mut self, n_fields: uint,\n+                       sz: uint, align: uint) -> bool;\n+\n+    fn visit_enter_enum(&mut self, n_variants: uint,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        sz: uint, align: uint) -> bool;\n+    fn visit_enter_enum_variant(&mut self, variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool;\n+    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_enum_variant(&mut self, variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool;\n+    fn visit_leave_enum(&mut self, n_variants: uint,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        sz: uint, align: uint) -> bool;\n+\n+    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool;\n+    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n+    fn visit_fn_output(&mut self, retstyle: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool;\n+\n+    fn visit_trait(&mut self) -> bool;\n+    fn visit_param(&mut self, i: uint) -> bool;\n+    fn visit_self(&mut self) -> bool;\n+    fn visit_type(&mut self) -> bool;\n+    fn visit_opaque_box(&mut self) -> bool;\n+    fn visit_closure_ptr(&mut self, ck: uint) -> bool;\n+}\n+\n #[abi = \"rust-intrinsic\"]\n extern \"rust-intrinsic\" {\n \n@@ -325,7 +421,10 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn contains_managed<T>() -> bool;\n \n+    #[cfg(stage0)]\n     pub fn visit_tydesc(td: *TyDesc, tv: &TyVisitor);\n+    #[cfg(not(stage0))]\n+    pub fn visit_tydesc(td: *TyDesc, tv: &mut TyVisitor);\n \n     pub fn frame_address(f: &once fn(*u8));\n "}, {"sha": "efa3286e94a19b0634700cab9f224a3a8c3913db", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 127, "deletions": 128, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -21,7 +21,7 @@ use std::unstable::raw::Vec;\n \n /// Trait for visitor that wishes to reflect on data.\n trait movable_ptr {\n-    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void);\n+    fn move_ptr(&mut self, adjustment: &fn(*c_void) -> *c_void);\n }\n \n /// Helper function for alignment calculation.\n@@ -35,174 +35,174 @@ struct ptr_visit_adaptor<V>(Inner<V>);\n impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n \n     #[inline(always)]\n-    pub fn bump(&self, sz: uint) {\n+    pub fn bump(&mut self, sz: uint) {\n       do self.inner.move_ptr() |p| {\n             ((p as uint) + sz) as *c_void\n       };\n     }\n \n     #[inline(always)]\n-    pub fn align(&self, a: uint) {\n+    pub fn align(&mut self, a: uint) {\n       do self.inner.move_ptr() |p| {\n             align(p as uint, a) as *c_void\n       };\n     }\n \n     #[inline(always)]\n-    pub fn align_to<T>(&self) {\n+    pub fn align_to<T>(&mut self) {\n         self.align(sys::min_align_of::<T>());\n     }\n \n     #[inline(always)]\n-    pub fn bump_past<T>(&self) {\n+    pub fn bump_past<T>(&mut self) {\n         self.bump(sys::size_of::<T>());\n     }\n \n }\n \n impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n \n-    fn visit_bot(&self) -> bool {\n+    fn visit_bot(&mut self) -> bool {\n         self.align_to::<()>();\n         if ! self.inner.visit_bot() { return false; }\n         self.bump_past::<()>();\n         true\n     }\n \n-    fn visit_nil(&self) -> bool {\n+    fn visit_nil(&mut self) -> bool {\n         self.align_to::<()>();\n         if ! self.inner.visit_nil() { return false; }\n         self.bump_past::<()>();\n         true\n     }\n \n-    fn visit_bool(&self) -> bool {\n+    fn visit_bool(&mut self) -> bool {\n         self.align_to::<bool>();\n         if ! self.inner.visit_bool() { return false; }\n         self.bump_past::<bool>();\n         true\n     }\n \n-    fn visit_int(&self) -> bool {\n+    fn visit_int(&mut self) -> bool {\n         self.align_to::<int>();\n         if ! self.inner.visit_int() { return false; }\n         self.bump_past::<int>();\n         true\n     }\n \n-    fn visit_i8(&self) -> bool {\n+    fn visit_i8(&mut self) -> bool {\n         self.align_to::<i8>();\n         if ! self.inner.visit_i8() { return false; }\n         self.bump_past::<i8>();\n         true\n     }\n \n-    fn visit_i16(&self) -> bool {\n+    fn visit_i16(&mut self) -> bool {\n         self.align_to::<i16>();\n         if ! self.inner.visit_i16() { return false; }\n         self.bump_past::<i16>();\n         true\n     }\n \n-    fn visit_i32(&self) -> bool {\n+    fn visit_i32(&mut self) -> bool {\n         self.align_to::<i32>();\n         if ! self.inner.visit_i32() { return false; }\n         self.bump_past::<i32>();\n         true\n     }\n \n-    fn visit_i64(&self) -> bool {\n+    fn visit_i64(&mut self) -> bool {\n         self.align_to::<i64>();\n         if ! self.inner.visit_i64() { return false; }\n         self.bump_past::<i64>();\n         true\n     }\n \n-    fn visit_uint(&self) -> bool {\n+    fn visit_uint(&mut self) -> bool {\n         self.align_to::<uint>();\n         if ! self.inner.visit_uint() { return false; }\n         self.bump_past::<uint>();\n         true\n     }\n \n-    fn visit_u8(&self) -> bool {\n+    fn visit_u8(&mut self) -> bool {\n         self.align_to::<u8>();\n         if ! self.inner.visit_u8() { return false; }\n         self.bump_past::<u8>();\n         true\n     }\n \n-    fn visit_u16(&self) -> bool {\n+    fn visit_u16(&mut self) -> bool {\n         self.align_to::<u16>();\n         if ! self.inner.visit_u16() { return false; }\n         self.bump_past::<u16>();\n         true\n     }\n \n-    fn visit_u32(&self) -> bool {\n+    fn visit_u32(&mut self) -> bool {\n         self.align_to::<u32>();\n         if ! self.inner.visit_u32() { return false; }\n         self.bump_past::<u32>();\n         true\n     }\n \n-    fn visit_u64(&self) -> bool {\n+    fn visit_u64(&mut self) -> bool {\n         self.align_to::<u64>();\n         if ! self.inner.visit_u64() { return false; }\n         self.bump_past::<u64>();\n         true\n     }\n \n-    fn visit_float(&self) -> bool {\n+    fn visit_float(&mut self) -> bool {\n         self.align_to::<float>();\n         if ! self.inner.visit_float() { return false; }\n         self.bump_past::<float>();\n         true\n     }\n \n-    fn visit_f32(&self) -> bool {\n+    fn visit_f32(&mut self) -> bool {\n         self.align_to::<f32>();\n         if ! self.inner.visit_f32() { return false; }\n         self.bump_past::<f32>();\n         true\n     }\n \n-    fn visit_f64(&self) -> bool {\n+    fn visit_f64(&mut self) -> bool {\n         self.align_to::<f64>();\n         if ! self.inner.visit_f64() { return false; }\n         self.bump_past::<f64>();\n         true\n     }\n \n-    fn visit_char(&self) -> bool {\n+    fn visit_char(&mut self) -> bool {\n         self.align_to::<char>();\n         if ! self.inner.visit_char() { return false; }\n         self.bump_past::<char>();\n         true\n     }\n \n-    fn visit_estr_box(&self) -> bool {\n+    fn visit_estr_box(&mut self) -> bool {\n         self.align_to::<@str>();\n         if ! self.inner.visit_estr_box() { return false; }\n         self.bump_past::<@str>();\n         true\n     }\n \n-    fn visit_estr_uniq(&self) -> bool {\n+    fn visit_estr_uniq(&mut self) -> bool {\n         self.align_to::<~str>();\n         if ! self.inner.visit_estr_uniq() { return false; }\n         self.bump_past::<~str>();\n         true\n     }\n \n-    fn visit_estr_slice(&self) -> bool {\n+    fn visit_estr_slice(&mut self) -> bool {\n         self.align_to::<&'static str>();\n         if ! self.inner.visit_estr_slice() { return false; }\n         self.bump_past::<&'static str>();\n         true\n     }\n \n-    fn visit_estr_fixed(&self, n: uint,\n+    fn visit_estr_fixed(&mut self, n: uint,\n                         sz: uint,\n                         align: uint) -> bool {\n         self.align(align);\n@@ -211,42 +211,42 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<@u8>();\n         if ! self.inner.visit_box(mtbl, inner) { return false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n-    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n         if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n         self.bump_past::<~u8>();\n         true\n     }\n \n-    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n         if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n         self.bump_past::<~u8>();\n         true\n     }\n \n-    fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n         self.bump_past::<*u8>();\n         true\n     }\n \n-    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static u8>();\n         if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n         self.bump_past::<&'static u8>();\n         true\n     }\n \n-    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<Vec<()>>();\n         // FIXME (#3732): Inner really has to move its own pointers on this one.\n         // or else possibly we could have some weird interface wherein we\n@@ -256,42 +256,42 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[u8]>();\n         if ! self.inner.visit_vec(mtbl, inner) { return false; }\n         self.bump_past::<~[u8]>();\n         true\n     }\n \n-    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<@[u8]>();\n         if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n         self.bump_past::<@[u8]>();\n         true\n     }\n \n-    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[u8]>();\n         if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n         self.bump_past::<~[u8]>();\n         true\n     }\n \n-    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[@u8]>();\n         if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n         self.bump_past::<~[@u8]>();\n         true\n     }\n \n-    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n         self.bump_past::<&'static [u8]>();\n         true\n     }\n \n-    fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n+    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool {\n         self.align(align);\n         if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n@@ -301,24 +301,24 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_enter_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_rec_field(&self, i: uint, name: &str,\n+    fn visit_rec_field(&mut self, i: uint, name: &str,\n                        mtbl: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_rec_field(i, name, mtbl, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_enter_class(&self, n_fields: uint, sz: uint, align: uint)\n+    fn visit_enter_class(&mut self, n_fields: uint, sz: uint, align: uint)\n                       -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_class(n_fields, sz, align) {\n@@ -327,65 +327,65 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_class_field(&self, i: uint, name: &str,\n+    fn visit_class_field(&mut self, i: uint, name: &str,\n                          mtbl: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_leave_class(&self, n_fields: uint, sz: uint, align: uint)\n+    fn visit_leave_class(&mut self, n_fields: uint, sz: uint, align: uint)\n                       -> bool {\n         if ! self.inner.visit_leave_class(n_fields, sz, align) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_enter_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_tup_field(i, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_enter_fn(&self, purity: uint, proto: uint,\n+    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n         if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n             return false\n         }\n         true\n     }\n \n-    fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n         true\n     }\n \n-    fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, retstyle: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_fn(&self, purity: uint, proto: uint,\n+    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n         if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_enter_enum(&self, n_variants: uint,\n+    fn visit_enter_enum(&mut self, n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         sz: uint, align: uint)\n                      -> bool {\n@@ -394,7 +394,7 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_enter_enum_variant(&self, variant: uint,\n+    fn visit_enter_enum_variant(&mut self, variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n@@ -405,12 +405,12 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n+    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_enum_variant(&self, variant: uint,\n+    fn visit_leave_enum_variant(&mut self, variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n@@ -421,46 +421,46 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_leave_enum(&self, n_variants: uint,\n+    fn visit_leave_enum(&mut self, n_variants: uint,\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         sz: uint, align: uint)\n                      -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_trait(&self) -> bool {\n+    fn visit_trait(&mut self) -> bool {\n         self.align_to::<@TyVisitor>();\n         if ! self.inner.visit_trait() { return false; }\n         self.bump_past::<@TyVisitor>();\n         true\n     }\n \n-    fn visit_param(&self, i: uint) -> bool {\n+    fn visit_param(&mut self, i: uint) -> bool {\n         if ! self.inner.visit_param(i) { return false; }\n         true\n     }\n \n-    fn visit_self(&self) -> bool {\n+    fn visit_self(&mut self) -> bool {\n         self.align_to::<&'static u8>();\n         if ! self.inner.visit_self() { return false; }\n         self.align_to::<&'static u8>();\n         true\n     }\n \n-    fn visit_type(&self) -> bool {\n+    fn visit_type(&mut self) -> bool {\n         if ! self.inner.visit_type() { return false; }\n         true\n     }\n \n-    fn visit_opaque_box(&self) -> bool {\n+    fn visit_opaque_box(&mut self) -> bool {\n         self.align_to::<@u8>();\n         if ! self.inner.visit_opaque_box() { return false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n-    fn visit_closure_ptr(&self, ck: uint) -> bool {\n+    fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n         self.align_to::<@fn()>();\n         if ! self.inner.visit_closure_ptr(ck) { return false; }\n         self.bump_past::<@fn()>();\n@@ -477,17 +477,17 @@ struct Stuff {\n }\n \n impl my_visitor {\n-    pub fn get<T:Clone>(&self, f: &fn(T)) {\n+    pub fn get<T:Clone>(&mut self, f: &fn(T)) {\n         unsafe {\n             f((*(self.ptr1 as *T)).clone());\n         }\n     }\n \n-    pub fn visit_inner(&self, inner: *TyDesc) -> bool {\n+    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n         unsafe {\n             let u = my_visitor(**self);\n-            let v = ptr_visit_adaptor::<my_visitor>(Inner {inner: u});\n-            visit_tydesc(inner, &v as &TyVisitor);\n+            let mut v = ptr_visit_adaptor::<my_visitor>(Inner {inner: u});\n+            visit_tydesc(inner, &mut v as &mut TyVisitor);\n             true\n         }\n     }\n@@ -496,133 +496,133 @@ impl my_visitor {\n struct Inner<V> { inner: V }\n \n impl movable_ptr for my_visitor {\n-    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n+    fn move_ptr(&mut self, adjustment: &fn(*c_void) -> *c_void) {\n         self.ptr1 = adjustment(self.ptr1);\n         self.ptr2 = adjustment(self.ptr2);\n     }\n }\n \n impl TyVisitor for my_visitor {\n \n-    fn visit_bot(&self) -> bool { true }\n-    fn visit_nil(&self) -> bool { true }\n-    fn visit_bool(&self) -> bool {\n+    fn visit_bot(&mut self) -> bool { true }\n+    fn visit_nil(&mut self) -> bool { true }\n+    fn visit_bool(&mut self) -> bool {\n         do self.get::<bool>() |b| {\n             self.vals.push(b.to_str());\n         };\n         true\n     }\n-    fn visit_int(&self) -> bool {\n+    fn visit_int(&mut self) -> bool {\n         do self.get::<int>() |i| {\n             self.vals.push(i.to_str());\n         };\n         true\n     }\n-    fn visit_i8(&self) -> bool { true }\n-    fn visit_i16(&self) -> bool { true }\n-    fn visit_i32(&self) -> bool { true }\n-    fn visit_i64(&self) -> bool { true }\n+    fn visit_i8(&mut self) -> bool { true }\n+    fn visit_i16(&mut self) -> bool { true }\n+    fn visit_i32(&mut self) -> bool { true }\n+    fn visit_i64(&mut self) -> bool { true }\n \n-    fn visit_uint(&self) -> bool { true }\n-    fn visit_u8(&self) -> bool { true }\n-    fn visit_u16(&self) -> bool { true }\n-    fn visit_u32(&self) -> bool { true }\n-    fn visit_u64(&self) -> bool { true }\n+    fn visit_uint(&mut self) -> bool { true }\n+    fn visit_u8(&mut self) -> bool { true }\n+    fn visit_u16(&mut self) -> bool { true }\n+    fn visit_u32(&mut self) -> bool { true }\n+    fn visit_u64(&mut self) -> bool { true }\n \n-    fn visit_float(&self) -> bool { true }\n-    fn visit_f32(&self) -> bool { true }\n-    fn visit_f64(&self) -> bool { true }\n+    fn visit_float(&mut self) -> bool { true }\n+    fn visit_f32(&mut self) -> bool { true }\n+    fn visit_f64(&mut self) -> bool { true }\n \n-    fn visit_char(&self) -> bool { true }\n+    fn visit_char(&mut self) -> bool { true }\n \n-    fn visit_estr_box(&self) -> bool { true }\n-    fn visit_estr_uniq(&self) -> bool { true }\n-    fn visit_estr_slice(&self) -> bool { true }\n-    fn visit_estr_fixed(&self, _n: uint, _sz: uint,\n+    fn visit_estr_box(&mut self) -> bool { true }\n+    fn visit_estr_uniq(&mut self) -> bool { true }\n+    fn visit_estr_slice(&mut self) -> bool { true }\n+    fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n                         _align: uint) -> bool { true }\n \n-    fn visit_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq_managed(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_rptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-\n-    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_unboxed_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq_managed(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_slice(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_fixed(&self, _n: uint, _sz: uint, _align: uint,\n+    fn visit_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq_managed(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+\n+    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_unboxed_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_uniq_managed(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n-    fn visit_enter_rec(&self, _n_fields: uint,\n+    fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_rec_field(&self, _i: uint, _name: &str,\n+    fn visit_rec_field(&mut self, _i: uint, _name: &str,\n                        _mtbl: uint, inner: *TyDesc) -> bool {\n         error!(\"rec field!\");\n         self.visit_inner(inner)\n     }\n-    fn visit_leave_rec(&self, _n_fields: uint,\n+    fn visit_leave_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_class(&self, _n_fields: uint,\n+    fn visit_enter_class(&mut self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n-    fn visit_class_field(&self, _i: uint, _name: &str,\n+    fn visit_class_field(&mut self, _i: uint, _name: &str,\n                          _mtbl: uint, inner: *TyDesc) -> bool {\n         self.visit_inner(inner)\n     }\n-    fn visit_leave_class(&self, _n_fields: uint,\n+    fn visit_leave_class(&mut self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_tup(&self, _n_fields: uint,\n+    fn visit_enter_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_tup_field(&self, _i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&mut self, _i: uint, inner: *TyDesc) -> bool {\n         error!(\"tup field!\");\n         self.visit_inner(inner)\n     }\n-    fn visit_leave_tup(&self, _n_fields: uint,\n+    fn visit_leave_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_enum(&self, _n_variants: uint,\n+    fn visit_enter_enum(&mut self, _n_variants: uint,\n                         _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool {\n         // FIXME (#3732): this needs to rewind between enum variants, or something.\n         true\n     }\n-    fn visit_enter_enum_variant(&self, _variant: uint,\n+    fn visit_enter_enum_variant(&mut self, _variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_enum_variant_field(&self, _i: uint, _offset: uint, inner: *TyDesc) -> bool {\n+    fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, inner: *TyDesc) -> bool {\n         self.visit_inner(inner)\n     }\n-    fn visit_leave_enum_variant(&self, _variant: uint,\n+    fn visit_leave_enum_variant(&mut self, _variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_leave_enum(&self, _n_variants: uint,\n+    fn visit_leave_enum(&mut self, _n_variants: uint,\n                         _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_fn(&self, _purity: uint, _proto: uint,\n+    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(&self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n         true\n     }\n-    fn visit_fn_output(&self, _retstyle: uint, _inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, _retstyle: uint, _inner: *TyDesc) -> bool {\n         true\n     }\n-    fn visit_leave_fn(&self, _purity: uint, _proto: uint,\n+    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n \n \n-    fn visit_trait(&self) -> bool { true }\n-    fn visit_param(&self, _i: uint) -> bool { true }\n-    fn visit_self(&self) -> bool { true }\n-    fn visit_type(&self) -> bool { true }\n-    fn visit_opaque_box(&self) -> bool { true }\n-    fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n+    fn visit_trait(&mut self) -> bool { true }\n+    fn visit_param(&mut self, _i: uint) -> bool { true }\n+    fn visit_self(&mut self) -> bool { true }\n+    fn visit_type(&mut self) -> bool { true }\n+    fn visit_opaque_box(&mut self) -> bool { true }\n+    fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }\n }\n \n fn get_tydesc_for<T>(_t: T) -> *TyDesc {\n@@ -640,12 +640,11 @@ pub fn main() {\n         let u = my_visitor(@mut Stuff {ptr1: p,\n                                        ptr2: p,\n                                        vals: ~[]});\n-        let v = ptr_visit_adaptor(Inner {inner: u});\n+        let mut v = ptr_visit_adaptor(Inner {inner: u});\n         let td = get_tydesc_for(r);\n         error!(\"tydesc sz: %u, align: %u\",\n                (*td).size, (*td).align);\n-        let v = &v as &TyVisitor;\n-        visit_tydesc(td, v);\n+        visit_tydesc(td, &mut v as &mut TyVisitor);\n \n         let r = u.vals.clone();\n         for s in r.iter() {"}, {"sha": "934d6117647df63c9d947c0070a6130f146cb009", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 68, "deletions": 75, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94844c55893de9489cf64c4a8b9d66c962a560b/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=f94844c55893de9489cf64c4a8b9d66c962a560b", "patch": "@@ -15,157 +15,150 @@ struct MyVisitor {\n }\n \n impl TyVisitor for MyVisitor {\n-    fn visit_bot(&self) -> bool {\n+    fn visit_bot(&mut self) -> bool {\n         self.types.push(~\"bot\");\n         error!(\"visited bot type\");\n         true\n     }\n-    fn visit_nil(&self) -> bool {\n+    fn visit_nil(&mut self) -> bool {\n         self.types.push(~\"nil\");\n         error!(\"visited nil type\");\n         true\n     }\n-    fn visit_bool(&self) -> bool {\n+    fn visit_bool(&mut self) -> bool {\n         self.types.push(~\"bool\");\n         error!(\"visited bool type\");\n         true\n     }\n-    fn visit_int(&self) -> bool {\n+    fn visit_int(&mut self) -> bool {\n         self.types.push(~\"int\");\n         error!(\"visited int type\");\n         true\n     }\n-    fn visit_i8(&self) -> bool {\n+    fn visit_i8(&mut self) -> bool {\n         self.types.push(~\"i8\");\n         error!(\"visited i8 type\");\n         true\n     }\n-    fn visit_i16(&self) -> bool {\n+    fn visit_i16(&mut self) -> bool {\n         self.types.push(~\"i16\");\n         error!(\"visited i16 type\");\n         true\n     }\n-    fn visit_i32(&self) -> bool { true }\n-    fn visit_i64(&self) -> bool { true }\n+    fn visit_i32(&mut self) -> bool { true }\n+    fn visit_i64(&mut self) -> bool { true }\n \n-    fn visit_uint(&self) -> bool { true }\n-    fn visit_u8(&self) -> bool { true }\n-    fn visit_u16(&self) -> bool { true }\n-    fn visit_u32(&self) -> bool { true }\n-    fn visit_u64(&self) -> bool { true }\n+    fn visit_uint(&mut self) -> bool { true }\n+    fn visit_u8(&mut self) -> bool { true }\n+    fn visit_u16(&mut self) -> bool { true }\n+    fn visit_u32(&mut self) -> bool { true }\n+    fn visit_u64(&mut self) -> bool { true }\n \n-    fn visit_float(&self) -> bool { true }\n-    fn visit_f32(&self) -> bool { true }\n-    fn visit_f64(&self) -> bool { true }\n+    fn visit_float(&mut self) -> bool { true }\n+    fn visit_f32(&mut self) -> bool { true }\n+    fn visit_f64(&mut self) -> bool { true }\n \n-    fn visit_char(&self) -> bool { true }\n+    fn visit_char(&mut self) -> bool { true }\n \n-    fn visit_estr_box(&self) -> bool { true }\n-    fn visit_estr_uniq(&self) -> bool { true }\n-    fn visit_estr_slice(&self) -> bool { true }\n-    fn visit_estr_fixed(&self,\n+    fn visit_estr_box(&mut self) -> bool { true }\n+    fn visit_estr_uniq(&mut self) -> bool { true }\n+    fn visit_estr_slice(&mut self) -> bool { true }\n+    fn visit_estr_fixed(&mut self,\n                         _sz: uint, _sz: uint,\n                         _align: uint) -> bool { true }\n \n-    fn visit_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq_managed(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_rptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq_managed(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n-    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_unboxed_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_unboxed_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.types.push(~\"[\");\n-        unsafe {\n-            visit_tydesc(inner, (&*self) as &TyVisitor);\n-        }\n+        unsafe { visit_tydesc(inner, &mut *self as &mut TyVisitor); }\n         self.types.push(~\"]\");\n         true\n     }\n-    fn visit_evec_uniq_managed(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_uniq_managed(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.types.push(~\"[\");\n-        unsafe {\n-            visit_tydesc(inner, (&*self) as &TyVisitor);\n-        }\n+        unsafe { visit_tydesc(inner, &mut *self as &mut TyVisitor) };\n         self.types.push(~\"]\");\n         true\n     }\n-    fn visit_evec_slice(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_fixed(&self, _n: uint, _sz: uint, _align: uint,\n+    fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n-    fn visit_enter_rec(&self, _n_fields: uint,\n+    fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_rec_field(&self, _i: uint, _name: &str,\n+    fn visit_rec_field(&mut self, _i: uint, _name: &str,\n                        _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_rec(&self, _n_fields: uint,\n+    fn visit_leave_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_class(&self, _n_fields: uint,\n+    fn visit_enter_class(&mut self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n-    fn visit_class_field(&self, _i: uint, _name: &str,\n+    fn visit_class_field(&mut self, _i: uint, _name: &str,\n                          _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_class(&self, _n_fields: uint,\n+    fn visit_leave_class(&mut self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_tup(&self, _n_fields: uint,\n+    fn visit_enter_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_tup_field(&self, _i: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_tup(&self, _n_fields: uint,\n+    fn visit_tup_field(&mut self, _i: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_leave_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_enum(&self, _n_variants: uint,\n+    fn visit_enter_enum(&mut self, _n_variants: uint,\n                         _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool { true }\n-    fn visit_enter_enum_variant(&self,\n+    fn visit_enter_enum_variant(&mut self,\n                                 _variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_enum_variant_field(&self, _i: uint, _offset: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_enum_variant(&self,\n+    fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_leave_enum_variant(&mut self,\n                                 _variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_leave_enum(&self,\n+    fn visit_leave_enum(&mut self,\n                         _n_variants: uint,\n                         _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_fn(&self, _purity: uint, _proto: uint,\n+    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(&self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_fn_output(&self, _retstyle: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_fn(&self, _purity: uint, _proto: uint,\n+    fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_fn_output(&mut self, _retstyle: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n \n \n-    fn visit_trait(&self) -> bool { true }\n-    fn visit_param(&self, _i: uint) -> bool { true }\n-    fn visit_self(&self) -> bool { true }\n-    fn visit_type(&self) -> bool { true }\n-    fn visit_opaque_box(&self) -> bool { true }\n-    fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n+    fn visit_trait(&mut self) -> bool { true }\n+    fn visit_param(&mut self, _i: uint) -> bool { true }\n+    fn visit_self(&mut self) -> bool { true }\n+    fn visit_type(&mut self) -> bool { true }\n+    fn visit_opaque_box(&mut self) -> bool { true }\n+    fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }\n }\n \n-fn visit_ty<T>(v: &TyVisitor) {\n-    unsafe {\n-        visit_tydesc(get_tydesc::<T>(), v);\n-    }\n+fn visit_ty<T>(v: &mut MyVisitor) {\n+    unsafe { visit_tydesc(get_tydesc::<T>(), v as &mut TyVisitor) }\n }\n \n pub fn main() {\n-    let v = @MyVisitor {types: @mut ~[]};\n-    let vv = v as @TyVisitor;\n-\n-    visit_ty::<bool>(vv);\n-    visit_ty::<int>(vv);\n-    visit_ty::<i8>(vv);\n-    visit_ty::<i16>(vv);\n-    visit_ty::<~[int]>(vv);\n+    let mut v = MyVisitor {types: @mut ~[]};\n+\n+    visit_ty::<bool>(&mut v);\n+    visit_ty::<int>(&mut v);\n+    visit_ty::<i8>(&mut v);\n+    visit_ty::<i16>(&mut v);\n+    visit_ty::<~[int]>(&mut v);\n \n     for s in v.types.iter() {\n         printfln!(\"type: %s\", (*s).clone());"}]}