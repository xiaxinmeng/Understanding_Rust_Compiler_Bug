{"sha": "7a090fbe02b6b20f0dce8acf07a0328375f91d68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMDkwZmJlMDJiNmIyMGYwZGNlOGFjZjA3YTAzMjgzNzVmOTFkNjg=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-09T02:49:39Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-13T07:16:03Z"}, "message": "Rename some stuff in `StringReader`.\n\n- `source_text` becomes `src`, matching `FileMap::src`.\n\n- `byte_offset()` becomes `src_index()`, which makes it clearer that\n  it's an index into `src`. (Likewise for variables containing\n  `byte_offset` in their name.) This function also now returns a `usize`\n  instead of a `BytePos`, because every callsite immediately converted\n  the `BytePos` to a `usize`.", "tree": {"sha": "b75e60117cb9b618b1cf3eb2f26a23802f87b63b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75e60117cb9b618b1cf3eb2f26a23802f87b63b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a090fbe02b6b20f0dce8acf07a0328375f91d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a090fbe02b6b20f0dce8acf07a0328375f91d68", "html_url": "https://github.com/rust-lang/rust/commit/7a090fbe02b6b20f0dce8acf07a0328375f91d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a090fbe02b6b20f0dce8acf07a0328375f91d68/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1aae607c56d26333589dc45daa20859950bf6e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1aae607c56d26333589dc45daa20859950bf6e1", "html_url": "https://github.com/rust-lang/rust/commit/b1aae607c56d26333589dc45daa20859950bf6e1"}], "stats": {"total": 53, "additions": 24, "deletions": 29}, "files": [{"sha": "e2030ff62c579bcae718da35dbc1a56c2277c1f0", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7a090fbe02b6b20f0dce8acf07a0328375f91d68/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a090fbe02b6b20f0dce8acf07a0328375f91d68/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7a090fbe02b6b20f0dce8acf07a0328375f91d68", "patch": "@@ -61,7 +61,7 @@ pub struct StringReader<'a> {\n     pub fatal_errs: Vec<DiagnosticBuilder<'a>>,\n     // cache a direct reference to the source text, so that we don't have to\n     // retrieve it via `self.filemap.src.as_ref().unwrap()` all the time.\n-    source_text: Lrc<String>,\n+    src: Lrc<String>,\n     /// Stack of open delimiters and their spans. Used for error message.\n     token: token::Token,\n     span: Span,\n@@ -176,7 +176,7 @@ impl<'a> StringReader<'a> {\n                                               filemap.name));\n         }\n \n-        let source_text = (*filemap.src.as_ref().unwrap()).clone();\n+        let src = (*filemap.src.as_ref().unwrap()).clone();\n \n         StringReader {\n             sess,\n@@ -190,7 +190,7 @@ impl<'a> StringReader<'a> {\n             // dummy values; not read\n             peek_tok: token::Eof,\n             peek_span: syntax_pos::DUMMY_SP,\n-            source_text,\n+            src,\n             fatal_errs: Vec::new(),\n             token: token::Eof,\n             span: syntax_pos::DUMMY_SP,\n@@ -326,9 +326,7 @@ impl<'a> StringReader<'a> {\n     /// offending string to the error message\n     fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> FatalError {\n         m.push_str(\": \");\n-        let from = self.byte_offset(from_pos).to_usize();\n-        let to = self.byte_offset(to_pos).to_usize();\n-        m.push_str(&self.source_text[from..to]);\n+        m.push_str(&self.src[self.src_index(from_pos)..self.src_index(to_pos)]);\n         self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n \n@@ -354,8 +352,9 @@ impl<'a> StringReader<'a> {\n         Ok(())\n     }\n \n-    fn byte_offset(&self, pos: BytePos) -> BytePos {\n-        (pos - self.filemap.start_pos)\n+    #[inline]\n+    fn src_index(&self, pos: BytePos) -> usize {\n+        (pos - self.filemap.start_pos).to_usize()\n     }\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -386,7 +385,7 @@ impl<'a> StringReader<'a> {\n     fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T\n         where F: FnOnce(&str) -> T\n     {\n-        f(&self.source_text[self.byte_offset(start).to_usize()..self.byte_offset(end).to_usize()])\n+        f(&self.src[self.src_index(start)..self.src_index(end)])\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n@@ -438,16 +437,13 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-\n     /// Advance the StringReader by one character. If a newline is\n     /// discovered, add it to the FileMap's list of line start offsets.\n     pub fn bump(&mut self) {\n-        let next_byte_offset = self.byte_offset(self.next_pos).to_usize();\n-        let end = self.terminator.map_or(self.source_text.len(), |t| {\n-            self.byte_offset(t).to_usize()\n-        });\n-        if next_byte_offset < end {\n-            let next_ch = char_at(&self.source_text, next_byte_offset);\n+        let next_src_index = self.src_index(self.next_pos);\n+        let end_src_index = self.terminator.map_or(self.src.len(), |t| self.src_index(t));\n+        if next_src_index < end_src_index {\n+            let next_ch = char_at(&self.src, next_src_index);\n             let next_ch_len = next_ch.len_utf8();\n \n             if self.ch.unwrap() == '\\n' {\n@@ -475,9 +471,9 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn nextch(&self) -> Option<char> {\n-        let offset = self.byte_offset(self.next_pos).to_usize();\n-        if offset < self.source_text.len() {\n-            Some(char_at(&self.source_text, offset))\n+        let next_src_index = self.src_index(self.next_pos);\n+        if next_src_index < self.src.len() {\n+            Some(char_at(&self.src, next_src_index))\n         } else {\n             None\n         }\n@@ -488,14 +484,14 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn nextnextch(&self) -> Option<char> {\n-        let offset = self.byte_offset(self.next_pos).to_usize();\n-        let s = &self.source_text[..];\n-        if offset >= s.len() {\n+        let next_src_index = self.src_index(self.next_pos);\n+        let s = &self.src[..];\n+        if next_src_index >= s.len() {\n             return None;\n         }\n-        let next = offset + char_at(s, offset).len_utf8();\n-        if next < s.len() {\n-            Some(char_at(s, next))\n+        let next_next_src_index = next_src_index + char_at(s, next_src_index).len_utf8();\n+        if next_next_src_index < s.len() {\n+            Some(char_at(s, next_next_src_index))\n         } else {\n             None\n         }\n@@ -1358,8 +1354,8 @@ impl<'a> StringReader<'a> {\n                     loop {\n                         self.bump();\n                         if self.ch_is('\\'') {\n-                            let start = self.byte_offset(start).to_usize();\n-                            let end = self.byte_offset(self.pos).to_usize();\n+                            let start = self.src_index(start);\n+                            let end = self.src_index(self.pos);\n                             self.bump();\n                             let span = self.mk_sp(start_with_quote, self.pos);\n                             self.sess.span_diagnostic\n@@ -1368,8 +1364,7 @@ impl<'a> StringReader<'a> {\n                                 .span_suggestion(span,\n                                                  \"if you meant to write a `str` literal, \\\n                                                   use double quotes\",\n-                                                 format!(\"\\\"{}\\\"\",\n-                                                         &self.source_text[start..end]))\n+                                                 format!(\"\\\"{}\\\"\", &self.src[start..end]))\n                                 .emit();\n                             return Ok(token::Literal(token::Str_(Symbol::intern(\"??\")), None))\n                         }"}]}