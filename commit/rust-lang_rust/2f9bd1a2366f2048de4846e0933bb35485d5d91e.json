{"sha": "2f9bd1a2366f2048de4846e0933bb35485d5d91e", "node_id": "C_kwDOAAsO6NoAKDJmOWJkMWEyMzY2ZjIwNDhkZTQ4NDZlMDkzM2JiMzU0ODVkNWQ5MWU", "commit": {"author": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2022-08-30T10:06:22Z"}, "committer": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2022-08-30T10:06:22Z"}, "message": "Avoid zeroing large stack buffers in stdio on Windows", "tree": {"sha": "8a06c8cd9b07de9aedcc6382ad5ef2e62e2de28b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a06c8cd9b07de9aedcc6382ad5ef2e62e2de28b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f9bd1a2366f2048de4846e0933bb35485d5d91e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQQszICQ1r0Zqrp7OLPXcz0dendfCgUCYw3hHgAKCRDXcz0dendf\nCiT5APsEGlDSZwJQ0Hp2R9nrHRGmWGB+31K0V1ZRk98ccV94mwEAspsHr9glvipw\nFeILMenwdOVIXuTgRax083AsHNWTBQ4=\n=aNb4\n-----END PGP SIGNATURE-----", "payload": "tree 8a06c8cd9b07de9aedcc6382ad5ef2e62e2de28b\nparent fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254\nauthor Thom Chiovoloni <thom@shift.click> 1661853982 -0700\ncommitter Thom Chiovoloni <thom@shift.click> 1661853982 -0700\n\nAvoid zeroing large stack buffers in stdio on Windows\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f9bd1a2366f2048de4846e0933bb35485d5d91e", "html_url": "https://github.com/rust-lang/rust/commit/2f9bd1a2366f2048de4846e0933bb35485d5d91e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f9bd1a2366f2048de4846e0933bb35485d5d91e/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254", "html_url": "https://github.com/rust-lang/rust/commit/fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "2b11332714d9cc10f21940832b94e568fbeca2a6", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f9bd1a2366f2048de4846e0933bb35485d5d91e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9bd1a2366f2048de4846e0933bb35485d5d91e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=2f9bd1a2366f2048de4846e0933bb35485d5d91e", "patch": "@@ -3,6 +3,7 @@\n use crate::char::decode_utf16;\n use crate::cmp;\n use crate::io;\n+use crate::mem::MaybeUninit;\n use crate::os::windows::io::{FromRawHandle, IntoRawHandle};\n use crate::ptr;\n use crate::str;\n@@ -169,13 +170,14 @@ fn write(\n }\n \n fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usize> {\n-    let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n+    let mut utf16: [MaybeUninit<u16>; MAX_BUFFER_SIZE / 2] = MaybeUninit::uninit_array();\n     let mut len_utf16 = 0;\n     for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n-        *dest = chr;\n+        *dest = MaybeUninit::new(chr);\n         len_utf16 += 1;\n     }\n-    let utf16 = &utf16[..len_utf16];\n+    // Safety: We've initialized `len_utf16` values.\n+    let utf16: &[u16] = unsafe { MaybeUninit::slice_assume_init_ref(&utf16[..len_utf16]) };\n \n     let mut written = write_u16s(handle, &utf16)?;\n \n@@ -250,27 +252,33 @@ impl io::Read for Stdin {\n             return Ok(bytes_copied);\n         } else if buf.len() - bytes_copied < 4 {\n             // Not enough space to get a UTF-8 byte. We will use the incomplete UTF8.\n-            let mut utf16_buf = [0u16; 1];\n+            let mut utf16_buf = [MaybeUninit::new(1); 1];\n             // Read one u16 character.\n             let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, 1, &mut self.surrogate)?;\n             // Read bytes, using the (now-empty) self.incomplete_utf8 as extra space.\n-            let read_bytes = utf16_to_utf8(&utf16_buf[..read], &mut self.incomplete_utf8.bytes)?;\n+            let read_bytes = utf16_to_utf8(\n+                unsafe { MaybeUninit::slice_assume_init_ref(&utf16_buf[..read]) },\n+                &mut self.incomplete_utf8.bytes,\n+            )?;\n \n             // Read in the bytes from incomplete_utf8 until the buffer is full.\n             self.incomplete_utf8.len = read_bytes as u8;\n             // No-op if no bytes.\n             bytes_copied += self.incomplete_utf8.read(&mut buf[bytes_copied..]);\n             Ok(bytes_copied)\n         } else {\n-            let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n+            let mut utf16_buf: [MaybeUninit<u16>; MAX_BUFFER_SIZE / 2] =\n+                MaybeUninit::uninit_array();\n             // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So\n             // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n             // lost.\n             let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n             let read =\n                 read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n-\n-            match utf16_to_utf8(&utf16_buf[..read], buf) {\n+            // Safety `read_u16s_fixup_surrogates` returns the number of items\n+            // initialized.\n+            let utf16s = unsafe { MaybeUninit::slice_assume_init_ref(&utf16_buf[..read]) };\n+            match utf16_to_utf8(utf16s, buf) {\n                 Ok(value) => return Ok(bytes_copied + value),\n                 Err(e) => return Err(e),\n             }\n@@ -283,14 +291,14 @@ impl io::Read for Stdin {\n // This is a best effort, and might not work if we are not the only reader on Stdin.\n fn read_u16s_fixup_surrogates(\n     handle: c::HANDLE,\n-    buf: &mut [u16],\n+    buf: &mut [MaybeUninit<u16>],\n     mut amount: usize,\n     surrogate: &mut u16,\n ) -> io::Result<usize> {\n     // Insert possibly remaining unpaired surrogate from last read.\n     let mut start = 0;\n     if *surrogate != 0 {\n-        buf[0] = *surrogate;\n+        buf[0] = MaybeUninit::new(*surrogate);\n         *surrogate = 0;\n         start = 1;\n         if amount == 1 {\n@@ -303,7 +311,10 @@ fn read_u16s_fixup_surrogates(\n     let mut amount = read_u16s(handle, &mut buf[start..amount])? + start;\n \n     if amount > 0 {\n-        let last_char = buf[amount - 1];\n+        // Safety: The returned `amount` is the number of values initialized,\n+        // and it is not 0, so we know that `buf[amount - 1]` have been\n+        // initialized.\n+        let last_char = unsafe { buf[amount - 1].assume_init() };\n         if last_char >= 0xD800 && last_char <= 0xDBFF {\n             // high surrogate\n             *surrogate = last_char;\n@@ -313,7 +324,8 @@ fn read_u16s_fixup_surrogates(\n     Ok(amount)\n }\n \n-fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n+// Returns `Ok(n)` if it initialized `n` values in `buf`.\n+fn read_u16s(handle: c::HANDLE, buf: &mut [MaybeUninit<u16>]) -> io::Result<usize> {\n     // Configure the `pInputControl` parameter to not only return on `\\r\\n` but also Ctrl-Z, the\n     // traditional DOS method to indicate end of character stream / user input (SUB).\n     // See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.\n@@ -346,8 +358,9 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n         }\n         break;\n     }\n-\n-    if amount > 0 && buf[amount as usize - 1] == CTRL_Z {\n+    // Safety: if `amount > 0`, then that many bytes were written, so\n+    // `buf[amount as usize - 1]` has been initialized.\n+    if amount > 0 && unsafe { buf[amount as usize - 1].assume_init() } == CTRL_Z {\n         amount -= 1;\n     }\n     Ok(amount as usize)"}]}