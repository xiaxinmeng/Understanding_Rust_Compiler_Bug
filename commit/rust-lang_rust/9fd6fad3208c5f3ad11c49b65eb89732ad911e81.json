{"sha": "9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZDZmYWQzMjA4YzVmM2FkMTFjNDliNjVlYjg5NzMyYWQ5MTFlODE=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-09-28T15:26:10Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-09-29T12:57:39Z"}, "message": "rustc/infer: convert single-branch matches to if-let", "tree": {"sha": "2a53dcff09b8120313bd4f3cdb6aa48ed8de2a1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a53dcff09b8120313bd4f3cdb6aa48ed8de2a1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "html_url": "https://github.com/rust-lang/rust/commit/9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89cb4119434ec8b013b2240073276c9a42460e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/89cb4119434ec8b013b2240073276c9a42460e05", "html_url": "https://github.com/rust-lang/rust/commit/89cb4119434ec8b013b2240073276c9a42460e05"}], "stats": {"total": 192, "additions": 88, "deletions": 104}, "files": [{"sha": "a24eeb328427f64897a88f20532f71f4cd35e67a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "patch": "@@ -455,11 +455,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             TypeError::Sorts(ref exp_found) => {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n-                match (&exp_found.expected.sty, &exp_found.found.sty) {\n-                    (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _)) => {\n-                        report_path_match(err, exp_adt.did, found_adt.did);\n-                    }\n-                    _ => (),\n+                if let (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _))\n+                     = (&exp_found.expected.sty, &exp_found.found.sty)\n+                {\n+                    report_path_match(err, exp_adt.did, found_adt.did);\n                 }\n             }\n             TypeError::Traits(ref exp_found) => {"}, {"sha": "009a823568131fb6b007e44aabd6b58c2ecce3cd", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "patch": "@@ -58,18 +58,17 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                     &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n                 let hir = &self.tcx.hir;\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n-                    match hir.get(node_id) {\n-                        Node::Expr(Expr {\n-                            node: Closure(_, _, _, closure_span, None),\n-                            ..\n-                        }) => {\n-                            let sup_sp = sup_origin.span();\n-                            let origin_sp = origin.span();\n-                            let mut err = self.tcx.sess.struct_span_err(\n-                                sup_sp,\n-                                \"borrowed data cannot be stored outside of its closure\");\n-                            err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n-                            if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n+                    if let Node::Expr(Expr {\n+                        node: Closure(_, _, _, closure_span, None),\n+                        ..\n+                    }) = hir.get(node_id) {\n+                        let sup_sp = sup_origin.span();\n+                        let origin_sp = origin.span();\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            sup_sp,\n+                            \"borrowed data cannot be stored outside of its closure\");\n+                        err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n+                        if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n // // sup_sp == origin.span():\n //\n // let mut x = None;\n@@ -87,11 +86,11 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n //                         ------------ ... because it cannot outlive this closure\n //     f = Some(x);\n //              ^ cannot be stored outside of its closure\n-                                err.span_label(*external_span,\n-                                               \"borrowed data cannot be stored into here...\");\n-                                err.span_label(*closure_span,\n-                                               \"...because it cannot outlive this closure\");\n-                            } else {\n+                            err.span_label(*external_span,\n+                                           \"borrowed data cannot be stored into here...\");\n+                            err.span_label(*closure_span,\n+                                           \"...because it cannot outlive this closure\");\n+                        } else {\n // FIXME: the wording for this case could be much improved\n //\n // let mut lines_to_use: Vec<&CrateId> = Vec::new();\n@@ -102,18 +101,16 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n //     ...so that variable is valid at time of its declaration\n //     lines_to_use.push(installed_id);\n //                       ^^^^^^^^^^^^ cannot be stored outside of its closure\n-                                err.span_label(origin_sp,\n-                                               \"cannot infer an appropriate lifetime...\");\n-                                err.span_label(*external_span,\n-                                               \"...so that variable is valid at time of its \\\n-                                                declaration\");\n-                                err.span_label(*closure_span,\n-                                               \"borrowed data cannot outlive this closure\");\n-                            }\n-                            err.emit();\n-                            return Some(ErrorReported);\n+                            err.span_label(origin_sp,\n+                                           \"cannot infer an appropriate lifetime...\");\n+                            err.span_label(*external_span,\n+                                           \"...so that variable is valid at time of its \\\n+                                            declaration\");\n+                            err.span_label(*closure_span,\n+                                           \"borrowed data cannot outlive this closure\");\n                         }\n-                        _ => {}\n+                        err.emit();\n+                        return Some(ErrorReported);\n                     }\n                 }\n             }"}, {"sha": "766173bf66283d4118d8250137a5e19daaf04381", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "patch": "@@ -20,64 +20,62 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         if let Some(ref error) = self.error {\n-            match error.clone() {\n-                RegionResolutionError::SubSupConflict(\n+            if let RegionResolutionError::SubSupConflict(\n                     var_origin,\n                     sub_origin,\n                     sub_r,\n                     sup_origin,\n                     sup_r,\n-                ) => {\n-                    let anon_reg_sup = self.tcx.is_suitable_region(sup_r)?;\n-                    if sub_r == &RegionKind::ReStatic &&\n-                        self.tcx.return_type_impl_trait(anon_reg_sup.def_id).is_some()\n-                    {\n-                        let sp = var_origin.span();\n-                        let return_sp = sub_origin.span();\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            sp,\n-                            \"cannot infer an appropriate lifetime\",\n+                ) = error.clone()\n+            {\n+                let anon_reg_sup = self.tcx.is_suitable_region(sup_r)?;\n+                if sub_r == &RegionKind::ReStatic &&\n+                    self.tcx.return_type_impl_trait(anon_reg_sup.def_id).is_some()\n+                {\n+                    let sp = var_origin.span();\n+                    let return_sp = sub_origin.span();\n+                    let mut err = self.tcx.sess.struct_span_err(\n+                        sp,\n+                        \"cannot infer an appropriate lifetime\",\n+                    );\n+                    err.span_label(\n+                        return_sp,\n+                        \"this return type evaluates to the `'static` lifetime...\",\n+                    );\n+                    err.span_label(\n+                        sup_origin.span(),\n+                        \"...but this borrow...\",\n+                    );\n+\n+                    let (lifetime, lt_sp_opt) = self.tcx.msg_span_from_free_region(sup_r);\n+                    if let Some(lifetime_sp) = lt_sp_opt {\n+                        err.span_note(\n+                            lifetime_sp,\n+                            &format!(\"...can't outlive {}\", lifetime),\n                         );\n-                        err.span_label(\n+                    }\n+\n+                    let lifetime_name = match sup_r {\n+                        RegionKind::ReFree(FreeRegion {\n+                            bound_region: BoundRegion::BrNamed(_, ref name), ..\n+                        }) => name.to_string(),\n+                        _ => \"'_\".to_owned(),\n+                    };\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n+                        err.span_suggestion_with_applicability(\n                             return_sp,\n-                            \"this return type evaluates to the `'static` lifetime...\",\n+                            &format!(\n+                                \"you can add a constraint to the return type to make it last \\\n+                                 less than `'static` and match {}\",\n+                                lifetime,\n+                            ),\n+                            format!(\"{} + {}\", snippet, lifetime_name),\n+                            Applicability::Unspecified,\n                         );\n-                        err.span_label(\n-                            sup_origin.span(),\n-                            \"...but this borrow...\",\n-                        );\n-\n-                        let (lifetime, lt_sp_opt) = self.tcx.msg_span_from_free_region(sup_r);\n-                        if let Some(lifetime_sp) = lt_sp_opt {\n-                            err.span_note(\n-                                lifetime_sp,\n-                                &format!(\"...can't outlive {}\", lifetime),\n-                            );\n-                        }\n-\n-                        let lifetime_name = match sup_r {\n-                            RegionKind::ReFree(FreeRegion {\n-                                bound_region: BoundRegion::BrNamed(_, ref name), ..\n-                            }) => name.to_string(),\n-                            _ => \"'_\".to_owned(),\n-                        };\n-                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n-                            err.span_suggestion_with_applicability(\n-                                return_sp,\n-                                &format!(\n-                                    \"you can add a constraint to the return type to make it last \\\n-                                     less than `'static` and match {}\",\n-                                    lifetime,\n-                                ),\n-                                format!(\"{} + {}\", snippet, lifetime_name),\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n-                        err.emit();\n-                        return Some(ErrorReported);\n                     }\n+                    err.emit();\n+                    return Some(ErrorReported);\n                 }\n-                _ => {}\n             }\n         }\n         None"}, {"sha": "76a780a5a055af079c8c58bd91dcedfcc01f755f", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "patch": "@@ -119,16 +119,13 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         decl: &hir::FnDecl,\n     ) -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n-        match ret_ty.sty {\n-            ty::FnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(self.tcx);\n-                let late_bound_regions = self.tcx\n-                    .collect_referenced_late_bound_regions(&sig.output());\n-                if late_bound_regions.iter().any(|r| *r == br) {\n-                    return Some(decl.output.span());\n-                }\n+        if let ty::FnDef(_, _) = ret_ty.sty {\n+            let sig = ret_ty.fn_sig(self.tcx);\n+            let late_bound_regions = self.tcx\n+                .collect_referenced_late_bound_regions(&sig.output());\n+            if late_bound_regions.iter().any(|r| *r == br) {\n+                return Some(decl.output.span());\n             }\n-            _ => {}\n         }\n         None\n     }"}, {"sha": "e4705df2eea13fc4fe9a65b459b8fa73c4e550bf", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "patch": "@@ -112,12 +112,9 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         }\n     };\n \n-    match dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n-        Ok(()) => {}\n-        Err(e) => {\n-            let msg = format!(\"io error dumping region constraints: {}\", e);\n-            tcx.sess.err(&msg)\n-        }\n+    if let Err(e) = dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n+        let msg = format!(\"io error dumping region constraints: {}\", e);\n+        tcx.sess.err(&msg)\n     }\n }\n "}, {"sha": "1a79ca211283b8a5d5b8090a66985ec542ceb98b", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "patch": "@@ -661,11 +661,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         debug!(\"RegionConstraintCollector: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n-        match verify.bound {\n-            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => {\n+        if let VerifyBound::AllBounds(ref bs) = verify.bound {\n+            if bs.len() == 0 {\n                 return;\n             }\n-            _ => {}\n         }\n \n         let index = self.data.verifys.len();"}, {"sha": "970b6e096ffe4d04370e482d43e079e29daa214e", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd6fad3208c5f3ad11c49b65eb89732ad911e81/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=9fd6fad3208c5f3ad11c49b65eb89732ad911e81", "patch": "@@ -273,11 +273,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n         debug!(\"rollback_to{:?}\", {\n             for action in self.values.actions_since_snapshot(&s.snapshot) {\n-                match *action {\n-                    sv::UndoLog::NewElem(index) => {\n-                        debug!(\"inference variable _#{}t popped\", index)\n-                    }\n-                    _ => { }\n+                if let sv::UndoLog::NewElem(index) = *action {\n+                    debug!(\"inference variable _#{}t popped\", index)\n                 }\n             }\n         });"}]}