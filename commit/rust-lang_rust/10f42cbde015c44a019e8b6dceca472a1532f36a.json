{"sha": "10f42cbde015c44a019e8b6dceca472a1532f36a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZjQyY2JkZTAxNWM0NGEwMTllOGI2ZGNlY2E0NzJhMTUzMmYzNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-27T00:39:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-27T00:39:11Z"}, "message": "Auto merge of #55274 - pnkfelix:issue-54570-proj-path-into-pats-with-type-take-2, r=nikomatsakis\n\nHandle bindings in substructure of patterns with type ascriptions\n\nThis attempts to follow the outline described by @nikomatsakis [here](https://github.com/rust-lang/rust/issues/47184#issuecomment-420041056). Its a bit more complicated than expected for two reasons:\n\n 1. In general it handles sets of type ascriptions, because such ascriptions can be nested within patterns\n 2.  It has a separate types in the HAIR, `PatternTypeProjections` and `PatternTypeProjection`, which are analogues to the corresponding types in the MIR.\n\nThe main reason I added the new HAIR types was because I am worried that the current implementation is inefficent, and asymptotically so: It makes copies of vectors as it descends the patterns, even when those accumulated vectors are never used.\n\nLonger term, I would like to used a linked tree structure for the `PatternTypeProjections` and `PatternTypeProjection`, and save the construction of standalone vectors for the MIR types. I didn't want to block landing this on that hypoethetical revision; but I figured I could at least make the future change easier by differentiating between the two types now.\n\nOh, one more thing: This doesn't attempt to handle `ref x` (in terms of ensuring that any necessary types are ascribed to `x` in that scenario as well). We should open an issue to investigate supporting that as well. But I didn't want to block this PR on that future work.\n\nFix #54570", "tree": {"sha": "f3be514f7f0d9d31f457bf1643683dc9f5b20c2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3be514f7f0d9d31f457bf1643683dc9f5b20c2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10f42cbde015c44a019e8b6dceca472a1532f36a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10f42cbde015c44a019e8b6dceca472a1532f36a", "html_url": "https://github.com/rust-lang/rust/commit/10f42cbde015c44a019e8b6dceca472a1532f36a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10f42cbde015c44a019e8b6dceca472a1532f36a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa45602b71c59c6315fdb07e925dec61f5827ad9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa45602b71c59c6315fdb07e925dec61f5827ad9", "html_url": "https://github.com/rust-lang/rust/commit/fa45602b71c59c6315fdb07e925dec61f5827ad9"}, {"sha": "639a3ffadcfec5165d434cbbf320678f69b01a5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/639a3ffadcfec5165d434cbbf320678f69b01a5b", "html_url": "https://github.com/rust-lang/rust/commit/639a3ffadcfec5165d434cbbf320678f69b01a5b"}], "stats": {"total": 749, "additions": 622, "deletions": 127}, "files": [{"sha": "274a2df283cbd05aa0eac6e978b84ffb044ba21f", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -606,3 +606,6 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::UserTypeAnnotation<\n         }\n     }\n }\n+\n+impl_stable_hash_for!(struct mir::UserTypeProjection<'tcx> { base, projs });\n+impl_stable_hash_for!(struct mir::UserTypeProjections<'tcx> { contents });"}, {"sha": "952783a91b2ed9d8b94fca79af742126c6b46c72", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 119, "deletions": 4, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -710,7 +710,7 @@ pub struct LocalDecl<'tcx> {\n     /// e.g. via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n-    pub user_ty: Option<(UserTypeAnnotation<'tcx>, Span)>,\n+    pub user_ty: UserTypeProjections<'tcx>,\n \n     /// Name of the local, used in debuginfo and pretty-printing.\n     ///\n@@ -882,7 +882,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         LocalDecl {\n             mutability,\n             ty,\n-            user_ty: None,\n+            user_ty: UserTypeProjections::none(),\n             name: None,\n             source_info: SourceInfo {\n                 span,\n@@ -903,7 +903,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         LocalDecl {\n             mutability: Mutability::Mut,\n             ty: return_ty,\n-            user_ty: None,\n+            user_ty: UserTypeProjections::none(),\n             source_info: SourceInfo {\n                 span,\n                 scope: OUTERMOST_SOURCE_SCOPE,\n@@ -1741,7 +1741,7 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n-    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeAnnotation<'tcx>>),\n+    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection<'tcx>>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -1944,6 +1944,10 @@ pub type PlaceProjection<'tcx> = Projection<'tcx, Place<'tcx>, Local, Ty<'tcx>>;\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n+/// Alias for projections as they appear in `UserTypeProjection`, where we\n+/// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n+pub type ProjectionKind<'tcx> = ProjectionElem<'tcx, (), ()>;\n+\n newtype_index! {\n     pub struct Field {\n         DEBUG_FORMAT = \"field[{}]\"\n@@ -2449,6 +2453,117 @@ EnumLiftImpl! {\n     }\n }\n \n+/// A collection of projections into user types.\n+///\n+/// They are projections because a binding can occur a part of a\n+/// parent pattern that has been ascribed a type.\n+///\n+/// Its a collection because there can be multiple type ascriptions on\n+/// the path from the root of the pattern down to the binding itself.\n+///\n+/// An example:\n+///\n+/// ```rust\n+/// struct S<'a>((i32, &'a str), String);\n+/// let S((_, w): (i32, &'static str), _): S = ...;\n+/// //    ------  ^^^^^^^^^^^^^^^^^^^ (1)\n+/// //  ---------------------------------  ^ (2)\n+/// ```\n+///\n+/// The highlights labelled `(1)` show the subpattern `(_, w)` being\n+/// ascribed the type `(i32, &'static str)`.\n+///\n+/// The highlights labelled `(2)` show the whole pattern being\n+/// ascribed the type `S`.\n+///\n+/// In this example, when we descend to `w`, we will have built up the\n+/// following two projected types:\n+///\n+///   * base: `S`,                   projection: `(base.0).1`\n+///   * base: `(i32, &'static str)`, projection: `base.1`\n+///\n+/// The first will lead to the constraint `w: &'1 str` (for some\n+/// inferred region `'1`). The second will lead to the constraint `w:\n+/// &'static str`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct UserTypeProjections<'tcx> {\n+    pub(crate) contents: Vec<(UserTypeProjection<'tcx>, Span)>,\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for UserTypeProjections<'tcx> {\n+        contents\n+    }\n+}\n+\n+impl<'tcx> UserTypeProjections<'tcx> {\n+    pub fn none() -> Self {\n+        UserTypeProjections { contents: vec![] }\n+    }\n+\n+    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection<'tcx>, Span)>) -> Self {\n+        UserTypeProjections { contents: projs.collect() }\n+    }\n+\n+    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection<'tcx>, Span)> {\n+        self.contents.iter()\n+    }\n+\n+    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection<'tcx>> {\n+        self.contents.iter().map(|&(ref user_type, _span)| user_type)\n+    }\n+}\n+\n+/// Encodes the effect of a user-supplied type annotation on the\n+/// subcomponents of a pattern. The effect is determined by applying the\n+/// given list of proejctions to some underlying base type. Often,\n+/// the projection element list `projs` is empty, in which case this\n+/// directly encodes a type in `base`. But in the case of complex patterns with\n+/// subpatterns and bindings, we want to apply only a *part* of the type to a variable,\n+/// in which case the `projs` vector is used.\n+///\n+/// Examples:\n+///\n+/// * `let x: T = ...` -- here, the `projs` vector is empty.\n+///\n+/// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n+///   `field[0]` (aka `.0`), indicating that the type of `s` is\n+///   determined by finding the type of the `.0` field from `T`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct UserTypeProjection<'tcx> {\n+    pub base: UserTypeAnnotation<'tcx>,\n+    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n+}\n+\n+impl<'tcx> Copy for ProjectionKind<'tcx> { }\n+\n+CloneTypeFoldableAndLiftImpls! { ProjectionKind<'tcx>, }\n+\n+impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use mir::ProjectionElem::*;\n+\n+        let base = self.base.fold_with(folder);\n+        let projs: Vec<_> = self.projs\n+            .iter()\n+            .map(|elem| {\n+                match elem {\n+                    Deref => Deref,\n+                    Field(f, ()) => Field(f.clone(), ()),\n+                    Index(()) => Index(()),\n+                    elem => elem.clone(),\n+                }})\n+            .collect();\n+\n+        UserTypeProjection { base, projs }\n+    }\n+\n+    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n+        self.base.visit_with(visitor)\n+        // Note: there's nothing in `self.proj` to visit.\n+    }\n+}\n+\n newtype_index! {\n     pub struct Promoted {\n         DEBUG_FORMAT = \"promoted[{}]\""}, {"sha": "473730c548990c8005986a903aa8d546bcf951c1", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -44,11 +44,59 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n         }\n     }\n \n+    /// `place_ty.field_ty(tcx, f)` computes the type at a given field\n+    /// of a record or enum-variant. (Most clients of `PlaceTy` can\n+    /// instead just extract the relevant type directly from their\n+    /// `PlaceElem`, but some instances of `ProjectionElem<V, T>` do\n+    /// not carry a `Ty` for `T`.)\n+    ///\n+    /// Note that the resulting type has not been normalized.\n+    pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n+    {\n+        // Pass `0` here so it can be used as a \"default\" variant_index in first arm below\n+        let answer = match (self, 0) {\n+            (PlaceTy::Ty {\n+                ty: &ty::TyS { sty: ty::TyKind::Adt(adt_def, substs), .. } }, variant_index) |\n+            (PlaceTy::Downcast { adt_def, substs, variant_index }, _) => {\n+                let variant_def = &adt_def.variants[variant_index];\n+                let field_def = &variant_def.fields[f.index()];\n+                field_def.ty(tcx, substs)\n+            }\n+            (PlaceTy::Ty { ty }, _) => {\n+                match ty.sty {\n+                    ty::Tuple(ref tys) => tys[f.index()],\n+                    _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n+                }\n+            }\n+        };\n+        debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);\n+        answer\n+    }\n+\n+    /// Convenience wrapper around `projection_ty_core` for\n+    /// `PlaceElem`, where we can just use the `Ty` that is already\n+    /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          elem: &PlaceElem<'tcx>)\n                          -> PlaceTy<'tcx>\n     {\n-        match *elem {\n+        self.projection_ty_core(tcx, elem, |_, _, ty| ty)\n+    }\n+\n+    /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n+    /// projects `place_ty` onto `elem`, returning the appropriate\n+    /// `Ty` or downcast variant corresponding to that projection.\n+    /// The `handle_field` callback must map a `Field` to its `Ty`,\n+    /// (which should be trivial when `T` = `Ty`).\n+    pub fn projection_ty_core<V, T>(self,\n+                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                    elem: &ProjectionElem<'tcx, V, T>,\n+                                    mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n+                                    -> PlaceTy<'tcx>\n+    where\n+        V: ::std::fmt::Debug, T: ::std::fmt::Debug\n+    {\n+        let answer = match *elem {\n             ProjectionElem::Deref => {\n                 let ty = self.to_ty(tcx)\n                              .builtin_deref(true)\n@@ -94,8 +142,10 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                         bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n                     }\n                 },\n-            ProjectionElem::Field(_, fty) => PlaceTy::Ty { ty: fty }\n-        }\n+            ProjectionElem::Field(ref f, ref fty) => PlaceTy::Ty { ty: handle_field(&self, f, fty) }\n+        };\n+        debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n+        answer\n     }\n }\n "}, {"sha": "bfc03923f6011d1138ad2ba7a1a64c785e921315", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -147,7 +147,7 @@ macro_rules! make_mir_visitor {\n             fn visit_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)* Place<'tcx>,\n                                      variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n@@ -175,9 +175,8 @@ macro_rules! make_mir_visitor {\n \n             fn visit_projection_elem(&mut self,\n                                      place: & $($mutability)* PlaceElem<'tcx>,\n-                                     context: PlaceContext<'tcx>,\n                                      location: Location) {\n-                self.super_projection_elem(place, context, location);\n+                self.super_projection_elem(place, location);\n             }\n \n             fn visit_branch(&mut self,\n@@ -214,6 +213,13 @@ macro_rules! make_mir_visitor {\n                 self.super_ty(ty);\n             }\n \n+            fn visit_user_type_projection(\n+                &mut self,\n+                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+            ) {\n+                self.super_user_type_projection(ty);\n+            }\n+\n             fn visit_user_type_annotation(\n                 &mut self,\n                 ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n@@ -640,10 +646,10 @@ macro_rules! make_mir_visitor {\n             fn super_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)* Place<'tcx>,\n                                      _variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.visit_place(place, PlaceContext::Validate, location);\n-                self.visit_user_type_annotation(user_ty);\n+                self.visit_user_type_projection(user_ty);\n             }\n \n             fn super_place(&mut self,\n@@ -692,12 +698,11 @@ macro_rules! make_mir_visitor {\n                     PlaceContext::Projection(Mutability::Not)\n                 };\n                 self.visit_place(base, context, location);\n-                self.visit_projection_elem(elem, context, location);\n+                self.visit_projection_elem(elem, location);\n             }\n \n             fn super_projection_elem(&mut self,\n                                      proj: & $($mutability)* PlaceElem<'tcx>,\n-                                     _context: PlaceContext<'tcx>,\n                                      location: Location) {\n                 match *proj {\n                     ProjectionElem::Deref => {\n@@ -738,8 +743,8 @@ macro_rules! make_mir_visitor {\n                     local,\n                     source_info: *source_info,\n                 });\n-                if let Some((user_ty, _)) = user_ty {\n-                    self.visit_user_type_annotation(user_ty);\n+                for (user_ty, _) in & $($mutability)* user_ty.contents {\n+                    self.visit_user_type_projection(user_ty);\n                 }\n                 self.visit_source_info(source_info);\n                 self.visit_source_scope(visibility_scope);\n@@ -786,6 +791,17 @@ macro_rules! make_mir_visitor {\n                 self.visit_source_scope(scope);\n             }\n \n+            fn super_user_type_projection(\n+                &mut self,\n+                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+            ) {\n+                let UserTypeProjection {\n+                    ref $($mutability)* base,\n+                    projs: _, // Note: Does not visit projection elems!\n+                } = *ty;\n+                self.visit_user_type_annotation(base);\n+            }\n+\n             fn super_user_type_annotation(\n                 &mut self,\n                 _ty: & $($mutability)* UserTypeAnnotation<'tcx>,"}, {"sha": "23445781eb2f3ddf9f252a1ef4ad7a6d240ac5ef", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -11,6 +11,7 @@\n use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n use traits::query::Fallible;\n use hir::def_id::DefId;\n+use mir::ProjectionKind;\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::UserSubsts;\n \n@@ -20,6 +21,7 @@ pub struct AscribeUserType<'tcx> {\n     pub variance: ty::Variance,\n     pub def_id: DefId,\n     pub user_substs: UserSubsts<'tcx>,\n+    pub projs: &'tcx ty::List<ProjectionKind<'tcx>>,\n }\n \n impl<'tcx> AscribeUserType<'tcx> {\n@@ -28,8 +30,9 @@ impl<'tcx> AscribeUserType<'tcx> {\n         variance: ty::Variance,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n+        projs: &'tcx ty::List<ProjectionKind<'tcx>>,\n     ) -> Self {\n-        AscribeUserType { mir_ty, variance, def_id, user_substs }\n+        AscribeUserType { mir_ty, variance, def_id, user_substs, projs }\n     }\n }\n \n@@ -59,19 +62,19 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for AscribeUserType<'tcx>\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for AscribeUserType<'tcx> {\n-        mir_ty, variance, def_id, user_substs\n+        mir_ty, variance, def_id, user_substs, projs\n     }\n }\n \n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for AscribeUserType<'a> {\n         type Lifted = AscribeUserType<'tcx>;\n-        mir_ty, variance, def_id, user_substs\n+        mir_ty, variance, def_id, user_substs, projs\n     }\n }\n \n impl_stable_hash_for! {\n     struct AscribeUserType<'tcx> {\n-        mir_ty, variance, def_id, user_substs\n+        mir_ty, variance, def_id, user_substs, projs\n     }\n }"}, {"sha": "d4b47db608163ed9ee293c46b35c723de274af18", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -31,7 +31,7 @@ use middle::cstore::EncodedMetadata;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n-use mir::{self, Mir, interpret};\n+use mir::{self, Mir, interpret, ProjectionKind};\n use mir::interpret::Allocation;\n use ty::subst::{CanonicalUserSubsts, Kind, Substs, Subst};\n use ty::ReprOptions;\n@@ -132,6 +132,7 @@ pub struct CtxtInterners<'tcx> {\n     clauses: InternedSet<'tcx, List<Clause<'tcx>>>,\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n+    projs: InternedSet<'tcx, List<ProjectionKind<'tcx>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -149,6 +150,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             clauses: Default::default(),\n             goal: Default::default(),\n             goal_list: Default::default(),\n+            projs: Default::default(),\n         }\n     }\n \n@@ -1886,6 +1888,24 @@ impl<'a, 'tcx> Lift<'tcx> for &'a List<CanonicalVarInfo> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a List<ProjectionKind<'a>> {\n+    type Lifted = &'tcx List<ProjectionKind<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        if self.len() == 0 {\n+            return Some(List::empty());\n+        }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub mod tls {\n     use super::{GlobalCtxt, TyCtxt};\n \n@@ -2294,6 +2314,13 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<[ProjectionKind<'lcx>]>\n+    for Interned<'tcx, List<ProjectionKind<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [ProjectionKind<'lcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n     fn borrow<'a>(&'a self) -> &'a RegionKind {\n         &self.0\n@@ -2441,7 +2468,8 @@ slice_interners!(\n     type_list: _intern_type_list(Ty),\n     substs: _intern_substs(Kind),\n     clauses: _intern_clauses(Clause),\n-    goal_list: _intern_goals(Goal)\n+    goal_list: _intern_goals(Goal),\n+    projs: _intern_projs(ProjectionKind)\n );\n \n // This isn't a perfect fit: CanonicalVarInfo slices are always\n@@ -2743,6 +2771,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn intern_projs(self, ps: &[ProjectionKind<'tcx>]) -> &'tcx List<ProjectionKind<'tcx>> {\n+        if ps.len() == 0 {\n+            List::empty()\n+        } else {\n+            self._intern_projs(ps)\n+        }\n+    }\n+\n     pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'gcx> {\n         if ts.len() == 0 {\n             List::empty()"}, {"sha": "62827ea20c31db48a1c168f9e8c41c5e3a159cc5", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -13,6 +13,7 @@\n //! hand, though we've recently added some macros (e.g.,\n //! `BraceStructLiftImpl!`) to help with the tedium.\n \n+use mir::ProjectionKind;\n use mir::interpret::ConstValue;\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -628,6 +629,17 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind<'tcx>> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_projs(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use ty::InstanceDef::*;"}, {"sha": "1602ef3c5b795d5e726e5dbfa6560917712921b0", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -168,7 +168,9 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty.projection_ty(cx.tcx, &proj.elem).to_ty(cx.tcx);\n+                let elem_ty = base_ty\n+                    .projection_ty(cx.tcx, &proj.elem)\n+                    .to_ty(cx.tcx);\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 if cx.layout_of(elem_ty).is_zst() {\n                     return;"}, {"sha": "062f7174680db92a470542e7a6e02877075e54ce", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -517,7 +517,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         let mut subslice = cg_base.project_index(bx,\n                             C_usize(bx.cx, from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n-                            .projection_ty(tcx, &projection.elem).to_ty(bx.tcx());\n+                            .projection_ty(tcx, &projection.elem)\n+                            .to_ty(bx.tcx());\n                         subslice.layout = bx.cx.layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {"}, {"sha": "1d8d028137a5b0c67e8466697ba77d2ecc65f083", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n use rustc::mir::{Statement, Terminator};\n-use rustc::mir::UserTypeAnnotation;\n+use rustc::mir::UserTypeProjection;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid};\n@@ -183,7 +183,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         &mut self,\n         _place: &Place<'tcx>,\n         _variance: &ty::Variance,\n-        _user_ty: &UserTypeAnnotation<'tcx>,\n+        _user_ty: &UserTypeProjection<'tcx>,\n         _location: Location,\n     ) {\n     }"}, {"sha": "953fe0c9521e6753f7ddb64e11b1c52fb458c1b9", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n                 constant.ty,\n                 ty::Variance::Invariant,\n-                user_ty,\n+                &UserTypeProjection { base: user_ty, projs: vec![], },\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n@@ -310,12 +310,12 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.super_local_decl(local, local_decl);\n         self.sanitize_type(local_decl, local_decl.ty);\n \n-        if let Some((user_ty, span)) = local_decl.user_ty {\n+        for (user_ty, span) in local_decl.user_ty.projections_and_spans() {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n                 local_decl.ty,\n                 ty::Variance::Invariant,\n                 user_ty,\n-                Locations::All(span),\n+                Locations::All(*span),\n                 ConstraintCategory::TypeAnnotation,\n             ) {\n                 span_mirbug!(\n@@ -971,7 +971,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         a: Ty<'tcx>,\n         v: ty::Variance,\n-        user_ty: UserTypeAnnotation<'tcx>,\n+        user_ty: &UserTypeProjection<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n@@ -980,7 +980,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        match user_ty {\n+        match user_ty.base {\n             UserTypeAnnotation::Ty(canonical_ty) => {\n                 let (ty, _) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n@@ -990,6 +990,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // ambient variance to get the right relationship.\n                 let v1 = ty::Contravariant.xform(v);\n \n+                let tcx = self.infcx.tcx;\n+                let mut projected_ty = PlaceTy::from_ty(ty);\n+                for proj in &user_ty.projs {\n+                    projected_ty = projected_ty.projection_ty_core(\n+                        tcx, proj, |this, field, &()| {\n+                            let ty = this.field_ty(tcx, field);\n+                            self.normalize(ty, locations)\n+                        });\n+                }\n+                debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n+                       user_ty.base, ty, user_ty.projs, projected_ty);\n+\n+                let ty = projected_ty.to_ty(tcx);\n+\n                 self.relate_types(ty, v1, a, locations, category)?;\n             }\n             UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n@@ -999,11 +1013,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n \n+                let projs = self.infcx.tcx.intern_projs(&user_ty.projs);\n                 self.fully_perform_op(\n                     locations,\n                     category,\n                     self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                        a, v, def_id, user_substs,\n+                        a, v, def_id, user_substs, projs,\n                     )),\n                 )?;\n             }\n@@ -1172,7 +1187,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     if let Err(terr) = self.relate_type_and_user_type(\n                         rv_ty,\n                         ty::Variance::Invariant,\n-                        user_ty,\n+                        &UserTypeProjection { base: user_ty, projs: vec![], },\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n@@ -1225,7 +1240,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::AscribeUserType(ref place, variance, box c_ty) => {\n+            StatementKind::AscribeUserType(ref place, variance, box ref c_ty) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,"}, {"sha": "aa383a123b69ae5501f1d18ed5450be9228a7e87", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -151,10 +151,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             None, remainder_span, lint_level, slice::from_ref(&pattern),\n                             ArmHasGuard(false), None);\n \n-                        this.visit_bindings(&pattern, None, &mut |this, _, _, _, node, span, _, _| {\n-                            this.storage_live_binding(block, node, span, OutsideGuard);\n-                            this.schedule_drop_for_binding(node, span, OutsideGuard);\n-                        })\n+                        this.visit_bindings(\n+                            &pattern,\n+                            &PatternTypeProjections::none(),\n+                            &mut |this, _, _, _, node, span, _, _| {\n+                                this.storage_live_binding(block, node, span, OutsideGuard);\n+                                this.schedule_drop_for_binding(node, span, OutsideGuard);\n+                            })\n                     }\n \n                     // Enter the source scope, after evaluating the initializer."}, {"sha": "77746e5538d65db608fb5ff59118f01e7b1a033f", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             kind: StatementKind::AscribeUserType(\n                                 place.clone(),\n                                 Variance::Invariant,\n-                                box user_ty,\n+                                box UserTypeProjection { base: user_ty, projs: vec![], },\n                             ),\n                         },\n                     );\n@@ -167,7 +167,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             kind: StatementKind::AscribeUserType(\n                                 Place::Local(temp.clone()),\n                                 Variance::Invariant,\n-                                box user_ty,\n+                                box UserTypeProjection { base: user_ty, projs: vec![], },\n                             ),\n                         },\n                     );"}, {"sha": "d2913872fca4589f7949600e12493539b0498133", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let ptr_temp = this.local_decls.push(LocalDecl {\n                         mutability: Mutability::Mut,\n                         ty: ptr_ty,\n-                        user_ty: None,\n+                        user_ty: UserTypeProjections::none(),\n                         name: None,\n                         source_info,\n                         visibility_scope: source_info.scope,"}, {"sha": "b92f270255af4fa23bbe4a00bb1476cc3cb8b208", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 49, "deletions": 36, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -18,6 +18,7 @@ use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use hair::*;\n+use hair::pattern::PatternTypeProjections;\n use rustc::hir;\n use rustc::mir::*;\n use rustc::ty::{self, Ty};\n@@ -31,6 +32,8 @@ mod simplify;\n mod test;\n mod util;\n \n+use std::convert::TryFrom;\n+\n /// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n@@ -240,7 +243,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         end_block.unit()\n     }\n \n-    pub fn expr_into_pattern(\n+    pub(super) fn expr_into_pattern(\n         &mut self,\n         mut block: BasicBlock,\n         irrefutable_pat: Pattern<'tcx>,\n@@ -291,7 +294,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     },\n                     ..\n                 },\n-                user_ty: ascription_user_ty,\n+                user_ty: pat_ascription_ty,\n                 user_ty_span,\n             } => {\n                 let place =\n@@ -316,7 +319,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         kind: StatementKind::AscribeUserType(\n                             place,\n                             ty::Variance::Invariant,\n-                            box ascription_user_ty,\n+                            box pat_ascription_ty.user_ty(),\n                         ),\n                     },\n                 );\n@@ -415,7 +418,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let num_patterns = patterns.len();\n         self.visit_bindings(\n             &patterns[0],\n-            None,\n+            &PatternTypeProjections::none(),\n             &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n                 if visibility_scope.is_none() {\n                     visibility_scope =\n@@ -488,10 +491,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n     }\n \n-    pub fn visit_bindings(\n+    pub(super) fn visit_bindings(\n         &mut self,\n         pattern: &Pattern<'tcx>,\n-        mut pattern_user_ty: Option<(UserTypeAnnotation<'tcx>, Span)>,\n+        pattern_user_ty: &PatternTypeProjections<'tcx>,\n         f: &mut impl FnMut(\n             &mut Self,\n             Mutability,\n@@ -500,7 +503,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             NodeId,\n             Span,\n             Ty<'tcx>,\n-            Option<(UserTypeAnnotation<'tcx>, Span)>,\n+            &PatternTypeProjections<'tcx>,\n         ),\n     ) {\n         match *pattern.kind {\n@@ -513,20 +516,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ref subpattern,\n                 ..\n             } => {\n-                match mode {\n-                    BindingMode::ByValue => { }\n+                let pattern_ref_binding; // sidestep temp lifetime limitations.\n+                let binding_user_ty = match mode {\n+                    BindingMode::ByValue => { pattern_user_ty }\n                     BindingMode::ByRef(..) => {\n                         // If this is a `ref` binding (e.g., `let ref\n                         // x: T = ..`), then the type of `x` is not\n-                        // `T` but rather `&T`, so ignore\n-                        // `pattern_user_ty` for now.\n-                        //\n-                        // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n-                        pattern_user_ty = None;\n+                        // `T` but rather `&T`.\n+                        pattern_ref_binding = pattern_user_ty.ref_binding();\n+                        &pattern_ref_binding\n                     }\n-                }\n+                };\n \n-                f(self, mutability, name, mode, var, pattern.span, ty, pattern_user_ty);\n+                f(self, mutability, name, mode, var, pattern.span, ty, binding_user_ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n                     self.visit_bindings(subpattern, pattern_user_ty, f);\n                 }\n@@ -541,33 +543,44 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ref slice,\n                 ref suffix,\n             } => {\n-                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n-                for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.visit_bindings(subpattern, None, f);\n+                let from = u32::try_from(prefix.len()).unwrap();\n+                let to = u32::try_from(suffix.len()).unwrap();\n+                for subpattern in prefix {\n+                    self.visit_bindings(subpattern, &pattern_user_ty.index(), f);\n+                }\n+                for subpattern in slice {\n+                    self.visit_bindings(subpattern, &pattern_user_ty.subslice(from, to), f);\n+                }\n+                for subpattern in suffix {\n+                    self.visit_bindings(subpattern, &pattern_user_ty.index(), f);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n             PatternKind::Deref { ref subpattern } => {\n-                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n-                self.visit_bindings(subpattern, None, f);\n+                self.visit_bindings(subpattern, &pattern_user_ty.deref(), f);\n             }\n-            PatternKind::AscribeUserType { ref subpattern, user_ty, user_ty_span } => {\n+            PatternKind::AscribeUserType { ref subpattern, ref user_ty, user_ty_span } => {\n                 // This corresponds to something like\n                 //\n                 // ```\n                 // let A::<'a>(_): A<'static> = ...;\n                 // ```\n-                //\n-                // FIXME(#47184): handle `pattern_user_ty` somehow\n-                self.visit_bindings(subpattern, Some((user_ty, user_ty_span)), f)\n+                let subpattern_user_ty = pattern_user_ty.add_user_type(user_ty, user_ty_span);\n+                self.visit_bindings(subpattern, &subpattern_user_ty, f)\n             }\n-            PatternKind::Leaf { ref subpatterns }\n-            | PatternKind::Variant {\n-                ref subpatterns, ..\n-            } => {\n-                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n+\n+            PatternKind::Leaf { ref subpatterns } => {\n+                for subpattern in subpatterns {\n+                    let subpattern_user_ty = pattern_user_ty.leaf(subpattern.field);\n+                    self.visit_bindings(&subpattern.pattern, &subpattern_user_ty, f);\n+                }\n+            }\n+\n+            PatternKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n                 for subpattern in subpatterns {\n-                    self.visit_bindings(&subpattern.pattern, None, f);\n+                    let subpattern_user_ty = pattern_user_ty.variant(\n+                        adt_def, variant_index, subpattern.field);\n+                    self.visit_bindings(&subpattern.pattern, &subpattern_user_ty, f);\n                 }\n             }\n         }\n@@ -626,7 +639,7 @@ struct Binding<'tcx> {\n struct Ascription<'tcx> {\n     span: Span,\n     source: Place<'tcx>,\n-    user_ty: UserTypeAnnotation<'tcx>,\n+    user_ty: PatternTypeProjection<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n@@ -1323,7 +1336,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     kind: StatementKind::AscribeUserType(\n                         ascription.source.clone(),\n                         ty::Variance::Covariant,\n-                        box ascription.user_ty,\n+                        box ascription.user_ty.clone().user_ty(),\n                     ),\n                 },\n             );\n@@ -1470,7 +1483,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         num_patterns: usize,\n         var_id: NodeId,\n         var_ty: Ty<'tcx>,\n-        user_var_ty: Option<(UserTypeAnnotation<'tcx>, Span)>,\n+        user_var_ty: &PatternTypeProjections<'tcx>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,\n@@ -1489,7 +1502,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n-            user_ty: user_var_ty,\n+            user_ty: user_var_ty.clone().user_ty(),\n             name: Some(name),\n             source_info,\n             visibility_scope,\n@@ -1522,7 +1535,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // See previous comment.\n                 mutability: Mutability::Not,\n                 ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n-                user_ty: None,\n+                user_ty: UserTypeProjections::none(),\n                 name: Some(name),\n                 source_info,\n                 visibility_scope,"}, {"sha": "349d877d52474eec8ae1ec1dc37c781c68d4e260", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -63,10 +63,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                  candidate: &mut Candidate<'pat, 'tcx>)\n                                  -> Result<(), MatchPair<'pat, 'tcx>> {\n         match *match_pair.pattern.kind {\n-            PatternKind::AscribeUserType { ref subpattern, user_ty, user_ty_span } => {\n+            PatternKind::AscribeUserType { ref subpattern, ref user_ty, user_ty_span } => {\n                 candidate.ascriptions.push(Ascription {\n                     span: user_ty_span,\n-                    user_ty,\n+                    user_ty: user_ty.clone(),\n                     source: match_pair.place.clone(),\n                 });\n "}, {"sha": "5b4001f0652ad9a0b4857ae53a856559f7eb21a3", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -845,7 +845,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Mut,\n                 ty,\n-                user_ty: None,\n+                user_ty: UserTypeProjections::none(),\n                 source_info,\n                 visibility_scope: source_info.scope,\n                 name,"}, {"sha": "586d6d87fa0dc24f4b119685cca9df4db19aa969", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -91,7 +91,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n                                     kind: Box::new(PatternKind::AscribeUserType {\n-                                        user_ty: UserTypeAnnotation::Ty(user_ty),\n+                                        user_ty: PatternTypeProjection::from_canonical_ty(user_ty),\n                                         user_ty_span: ty.span,\n                                         subpattern: pattern\n                                     })"}, {"sha": "8a24851de8149f2bcb301b9772f76bf5c6e69d6a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -28,6 +28,7 @@ pub mod cx;\n \n pub mod pattern;\n pub use self::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n+pub(crate) use self::pattern::{PatternTypeProjection, PatternTypeProjections};\n \n mod util;\n "}, {"sha": "bff87da9c771d5070906a2e082d512dee935d7de", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 119, "deletions": 5, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -20,7 +20,8 @@ use const_eval::{const_field, const_variant_index};\n \n use hair::util::UserAnnotatedTyHelpers;\n \n-use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability, UserTypeAnnotation};\n+use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n+use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::{Substs, Kind};\n@@ -64,12 +65,123 @@ pub struct Pattern<'tcx> {\n     pub kind: Box<PatternKind<'tcx>>,\n }\n \n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct PatternTypeProjections<'tcx> {\n+    contents: Vec<(PatternTypeProjection<'tcx>, Span)>,\n+}\n+\n+impl<'tcx> PatternTypeProjections<'tcx> {\n+    pub(crate) fn user_ty(self) -> UserTypeProjections<'tcx> {\n+        UserTypeProjections::from_projections(\n+            self.contents.into_iter().map(|(pat_ty_proj, span)| (pat_ty_proj.user_ty(), span)))\n+    }\n+\n+    pub(crate) fn none() -> Self {\n+        PatternTypeProjections { contents: vec![] }\n+    }\n+\n+    pub(crate) fn ref_binding(&self) -> Self {\n+        // FIXME(#47184): ignore for now\n+        PatternTypeProjections { contents: vec![] }\n+    }\n+\n+    fn map_projs(&self,\n+                 mut f: impl FnMut(&PatternTypeProjection<'tcx>) -> PatternTypeProjection<'tcx>)\n+                 -> Self\n+    {\n+        PatternTypeProjections {\n+            contents: self.contents\n+                .iter()\n+                .map(|(proj, span)| (f(proj), *span))\n+                .collect(), }\n+    }\n+\n+    pub(crate) fn index(&self) -> Self { self.map_projs(|pat_ty_proj| pat_ty_proj.index()) }\n+\n+    pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n+        self.map_projs(|pat_ty_proj| pat_ty_proj.subslice(from, to))\n+    }\n+\n+    pub(crate) fn deref(&self) -> Self { self.map_projs(|pat_ty_proj| pat_ty_proj.deref()) }\n+\n+    pub(crate) fn leaf(&self, field: Field) -> Self {\n+        self.map_projs(|pat_ty_proj| pat_ty_proj.leaf(field))\n+    }\n+\n+    pub(crate) fn variant(&self,\n+                          adt_def: &'tcx AdtDef,\n+                          variant_index: usize,\n+                          field: Field) -> Self {\n+        self.map_projs(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n+    }\n+\n+    pub(crate) fn add_user_type(&self, user_ty: &PatternTypeProjection<'tcx>, sp: Span) -> Self {\n+        let mut new = self.clone();\n+        new.contents.push((user_ty.clone(), sp));\n+        new\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct PatternTypeProjection<'tcx>(UserTypeProjection<'tcx>);\n+\n+impl<'tcx> PatternTypeProjection<'tcx> {\n+    pub(crate) fn index(&self) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Index(()));\n+        new\n+    }\n+\n+    pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Subslice { from, to });\n+        new\n+    }\n+\n+    pub(crate) fn deref(&self) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Deref);\n+        new\n+    }\n+\n+    pub(crate) fn leaf(&self, field: Field) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Field(field, ()));\n+        new\n+    }\n+\n+    pub(crate) fn variant(&self,\n+                          adt_def: &'tcx AdtDef,\n+                          variant_index: usize,\n+                          field: Field) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n+        new.0.projs.push(ProjectionElem::Field(field, ()));\n+        new\n+    }\n+\n+    pub(crate) fn from_canonical_ty(c_ty: ty::CanonicalTy<'tcx>) -> Self {\n+        Self::from_user_type(UserTypeAnnotation::Ty(c_ty))\n+    }\n+\n+    pub(crate) fn from_user_type(u_ty: UserTypeAnnotation<'tcx>) -> Self {\n+        Self::from_user_type_proj(UserTypeProjection { base: u_ty, projs: vec![], })\n+    }\n+\n+    pub(crate) fn from_user_type_proj(u_ty: UserTypeProjection<'tcx>) -> Self {\n+        PatternTypeProjection(u_ty)\n+    }\n+\n+    pub(crate) fn user_ty(self) -> UserTypeProjection<'tcx> { self.0 }\n+}\n+\n #[derive(Clone, Debug)]\n pub enum PatternKind<'tcx> {\n     Wild,\n \n     AscribeUserType {\n-        user_ty: UserTypeAnnotation<'tcx>,\n+        user_ty: PatternTypeProjection<'tcx>,\n         subpattern: Pattern<'tcx>,\n         user_ty_span: Span,\n     },\n@@ -690,9 +802,10 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             debug!(\"pattern user_ty = {:?} for pattern at {:?}\", user_ty, span);\n \n+            let pat_ty = PatternTypeProjection::from_user_type(user_ty);\n             kind = PatternKind::AscribeUserType {\n                 subpattern,\n-                user_ty,\n+                user_ty: pat_ty,\n                 user_ty_span: span,\n             };\n         }\n@@ -980,7 +1093,8 @@ macro_rules! CloneImpls {\n CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n-    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, UserTypeAnnotation<'tcx>\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, UserTypeAnnotation<'tcx>,\n+    UserTypeProjection<'tcx>, PatternTypeProjection<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n@@ -1016,7 +1130,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             PatternKind::Wild => PatternKind::Wild,\n             PatternKind::AscribeUserType {\n                 ref subpattern,\n-                user_ty,\n+                ref user_ty,\n                 user_ty_span,\n             } => PatternKind::AscribeUserType {\n                 subpattern: subpattern.fold_with(folder),"}, {"sha": "6c32690cdb3406395143f08a3c14347a3f5054c2", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -142,7 +142,7 @@ fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n     LocalDecl {\n         mutability,\n         ty,\n-        user_ty: None,\n+        user_ty: UserTypeProjections::none(),\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,"}, {"sha": "5889fabee9d6e25423db1b39348ebaeeee36bcef", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -303,7 +303,7 @@ fn replace_result_variable<'tcx>(\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: ret_ty,\n-        user_ty: None,\n+        user_ty: UserTypeProjections::none(),\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,\n@@ -658,7 +658,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     mir.local_decls[RETURN_PLACE] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_unit(),\n-        user_ty: None,\n+        user_ty: UserTypeProjections::none(),\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,\n@@ -676,7 +676,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n             ty: gen_ty,\n             mutbl: hir::Mutability::MutMutable,\n         }),\n-        user_ty: None,\n+        user_ty: UserTypeProjections::none(),\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,"}, {"sha": "c74492fe649361beaed581f8b695a3c8eb743388", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -502,7 +502,7 @@ fn write_scope_tree(\n                 local,\n                 var.ty\n             );\n-            if let Some(user_ty) = var.user_ty {\n+            for user_ty in var.user_ty.projections() {\n                 write!(indented_var, \" as {:?}\", user_ty).unwrap();\n             }\n             indented_var.push_str(\";\");"}, {"sha": "06c8545aacfd84fdb1e6f4ab0c9cb7b7b3810dbd", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -211,7 +211,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n \n     fn visit_projection_elem(&mut self,\n                              place: &PlaceElem<'tcx>,\n-                             context: mir_visit::PlaceContext<'tcx>,\n                              location: Location) {\n         self.record(\"PlaceElem\", place);\n         self.record(match *place {\n@@ -222,7 +221,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             ProjectionElem::ConstantIndex { .. } => \"PlaceElem::ConstantIndex\",\n             ProjectionElem::Downcast(..) => \"PlaceElem::Downcast\",\n         }, place);\n-        self.super_projection_elem(place, context, location);\n+        self.super_projection_elem(place, location);\n     }\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {"}, {"sha": "2ed02a4cdab1e1a71d642439b3cae7c6ee940d56", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -12,6 +12,8 @@ use rustc::infer::at::ToTrace;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::infer::InferCtxt;\n use rustc::hir::def_id::DefId;\n+use rustc::mir::ProjectionKind;\n+use rustc::mir::tcx::PlaceTy;\n use rustc::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc::traits::query::type_op::eq::Eq;\n use rustc::traits::query::type_op::normalize::Normalize;\n@@ -58,22 +60,23 @@ fn type_op_ascribe_user_type<'tcx>(\n                     variance,\n                     def_id,\n                     user_substs,\n+                    projs,\n                 },\n             ) = key.into_parts();\n \n             debug!(\n                 \"type_op_ascribe_user_type(\\\n-                 mir_ty={:?}, variance={:?}, def_id={:?}, user_substs={:?}\\\n+                 mir_ty={:?}, variance={:?}, def_id={:?}, user_substs={:?}, projs={:?}\\\n                  )\",\n-                mir_ty, variance, def_id, user_substs,\n+                mir_ty, variance, def_id, user_substs, projs,\n             );\n \n             let mut cx = AscribeUserTypeCx {\n                 infcx,\n                 param_env,\n                 fulfill_cx,\n             };\n-            cx.relate_mir_and_user_ty(mir_ty, variance, def_id, user_substs)?;\n+            cx.relate_mir_and_user_ty(mir_ty, variance, def_id, user_substs, projs)?;\n \n             Ok(())\n         })\n@@ -134,17 +137,30 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         variance: Variance,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n+        projs: &[ProjectionKind<'tcx>],\n     ) -> Result<(), NoSolution> {\n         let UserSubsts {\n             substs,\n             user_self_ty,\n         } = user_substs;\n \n-        let ty = self.tcx().type_of(def_id);\n+        let tcx = self.tcx();\n+\n+        let ty = tcx.type_of(def_id);\n         let ty = self.subst(ty, substs);\n         debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n         let ty = self.normalize(ty);\n \n+        let mut projected_ty = PlaceTy::from_ty(ty);\n+        for proj in projs {\n+            projected_ty = projected_ty.projection_ty_core(\n+                tcx, proj, |this, field, &()| {\n+                    let ty = this.field_ty(tcx, field);\n+                    self.normalize(ty)\n+                });\n+        }\n+        let ty = projected_ty.to_ty(tcx);\n+\n         self.relate(mir_ty, variance, ty)?;\n \n         if let Some(UserSelfTy {"}, {"sha": "7ca1d01f20b7b2787505df39c8a6dc6c330e11c3", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -56,7 +56,7 @@ fn main() {\n //        StorageLive(_4);\n //        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n-//        AscribeUserType(_4, o, Ty(Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> }));\n+//        AscribeUserType(_4, o, UserTypeProjection { base: Ty(Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> }), projs: [] });\n //        StorageLive(_5);\n //        StorageLive(_6);\n //        _6 = move _4;"}, {"sha": "0a8a6793dc782fcd119599b33edefd0f4b104e78", "filename": "src/test/ui/nll/user-annotations/issue-54570-bootstrapping.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-54570-bootstrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-54570-bootstrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-54570-bootstrapping.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -0,0 +1,31 @@\n+// compile-pass\n+#![feature(nll)]\n+\n+// This test is reduced from a scenario pnkfelix encountered while\n+// bootstrapping the compiler.\n+\n+#[derive(Copy, Clone)]\n+pub struct Spanned<T> {\n+    pub node: T,\n+    pub span: Span,\n+}\n+\n+pub type Variant = Spanned<VariantKind>;\n+// #[derive(Clone)] pub struct Variant { pub node: VariantKind, pub span: Span, }\n+\n+#[derive(Clone)]\n+pub struct VariantKind { }\n+\n+#[derive(Copy, Clone)]\n+pub struct Span;\n+\n+pub fn variant_to_span(variant: Variant) {\n+    match variant {\n+        Variant {\n+            span: _span,\n+            ..\n+        } => { }\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "8c8e61cd6fbeb7ff3e3b547402236860ef9fcb98", "filename": "src/test/ui/nll/user-annotations/patterns.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -9,11 +9,11 @@ fn variable_no_initializer() {\n }\n \n fn tuple_no_initializer() {\n-    // FIXME(#47187): We are not propagating ascribed type through tuples.\n+\n \n     let x = 22;\n     let (y, z): (&'static u32, &'static u32);\n-    y = &x;\n+    y = &x; //~ ERROR\n }\n \n fn ref_with_ascribed_static_type() -> u32 {\n@@ -34,11 +34,23 @@ fn ref_with_ascribed_any_type() -> u32 {\n struct Single<T> { value: T }\n \n fn struct_no_initializer() {\n-    // FIXME(#47187): We are not propagating ascribed type through patterns.\n+\n \n     let x = 22;\n     let Single { value: y }: Single<&'static u32>;\n-    y = &x;\n+    y = &x; //~ ERROR\n+}\n+\n+\n+fn struct_no_initializer_must_normalize() {\n+    trait Indirect { type Assoc; }\n+    struct StaticU32;\n+    impl Indirect for StaticU32 { type Assoc = &'static u32; }\n+    struct Single2<T: Indirect> { value: <T as Indirect>::Assoc }\n+\n+    let x = 22;\n+    let Single2 { value: mut _y }: Single2<StaticU32>;\n+    _y = &x; //~ ERROR\n }\n \n fn variable_with_initializer() {\n@@ -91,26 +103,31 @@ fn struct_double_field_underscore_with_initializer() {\n }\n \n fn static_to_a_to_static_through_variable<'a>(x: &'a u32) -> &'static u32 {\n-    // The error in this test is inconsistency with\n-    // `static_to_a_to_static_through_tuple`, but \"feels right\" to\n-    // me. It occurs because we special case the single binding case\n-    // and force the type of `y` to be `&'a u32`, even though the\n-    // right-hand side has type `&'static u32`.\n+\n+\n+\n+\n+\n \n     let y: &'a u32 = &22;\n     y //~ ERROR\n }\n \n fn static_to_a_to_static_through_tuple<'a>(x: &'a u32) -> &'static u32 {\n-    // FIXME(#47187): The fact that this type-checks is perhaps surprising.\n-    // What happens is that the right-hand side is constrained to have\n-    // type `&'a u32`, which is possible, because it has type\n-    // `&'static u32`. The variable `y` is then forced to have type\n-    // `&'static u32`, but it is constrained only by the right-hand\n-    // side, not the ascribed type, and hence it passes.\n+\n+\n+\n+\n+\n+\n \n     let (y, _z): (&'a u32, u32) = (&22, 44);\n-    y\n+    y //~ ERROR\n+}\n+\n+fn static_to_a_to_static_through_struct<'a>(_x: &'a u32) -> &'static u32 {\n+    let Single { value: y }: Single<&'a u32> = Single { value: &22 };\n+    y //~ ERROR\n }\n \n fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {"}, {"sha": "b0c554e6ca1d47f24ecf2cbb827ee0fd55b2a070", "filename": "src/test/ui/nll/user-annotations/patterns.stderr", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f42cbde015c44a019e8b6dceca472a1532f36a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr?ref=10f42cbde015c44a019e8b6dceca472a1532f36a", "patch": "@@ -8,6 +8,16 @@ LL |     y = &x; //~ ERROR\n LL | }\n    | - `x` dropped here while still borrowed\n \n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:16:9\n+   |\n+LL |     let (y, z): (&'static u32, &'static u32);\n+   |                 ---------------------------- type annotation requires that `x` is borrowed for `'static`\n+LL |     y = &x; //~ ERROR\n+   |         ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n error[E0597]: `x` does not live long enough\n   --> $DIR/patterns.rs:22:13\n    |\n@@ -20,7 +30,27 @@ LL | }\n    | - `x` dropped here while still borrowed\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/patterns.rs:46:27\n+  --> $DIR/patterns.rs:41:9\n+   |\n+LL |     let Single { value: y }: Single<&'static u32>;\n+   |                              -------------------- type annotation requires that `x` is borrowed for `'static`\n+LL |     y = &x; //~ ERROR\n+   |         ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:53:10\n+   |\n+LL |     let Single2 { value: mut _y }: Single2<StaticU32>;\n+   |                                    ------------------ type annotation requires that `x` is borrowed for `'static`\n+LL |     _y = &x; //~ ERROR\n+   |          ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:58:27\n    |\n LL |     let y: &'static u32 = &x; //~ ERROR\n    |            ------------   ^^ borrowed value does not live long enough\n@@ -30,7 +60,7 @@ LL | }\n    | - `x` dropped here while still borrowed\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/patterns.rs:51:27\n+  --> $DIR/patterns.rs:63:27\n    |\n LL |     let _: &'static u32 = &x; //~ ERROR\n    |            ------------   ^^ borrowed value does not live long enough\n@@ -41,7 +71,7 @@ LL | }\n    | - `x` dropped here while still borrowed\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/patterns.rs:53:41\n+  --> $DIR/patterns.rs:65:41\n    |\n LL |     let _: Vec<&'static String> = vec![&String::new()];\n    |            --------------------         ^^^^^^^^^^^^^ - temporary value is freed at the end of this statement\n@@ -50,7 +80,7 @@ LL |     let _: Vec<&'static String> = vec![&String::new()];\n    |            type annotation requires that borrow lasts for `'static`\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/patterns.rs:56:52\n+  --> $DIR/patterns.rs:68:52\n    |\n LL |     let (_, a): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n    |                 -------------------------          ^^^^^^^^^^^^^      - temporary value is freed at the end of this statement\n@@ -59,7 +89,7 @@ LL |     let (_, a): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n    |                 type annotation requires that borrow lasts for `'static`\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/patterns.rs:59:53\n+  --> $DIR/patterns.rs:71:53\n    |\n LL |     let (_a, b): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n    |                  -------------------------          ^^^^^^^^^^^^^      - temporary value is freed at the end of this statement\n@@ -68,7 +98,7 @@ LL |     let (_a, b): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n    |                  type annotation requires that borrow lasts for `'static`\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/patterns.rs:65:40\n+  --> $DIR/patterns.rs:77:40\n    |\n LL |     let (_, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n    |                 -------------------    ^^ borrowed value does not live long enough\n@@ -78,7 +108,7 @@ LL | }\n    | - `x` dropped here while still borrowed\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/patterns.rs:70:40\n+  --> $DIR/patterns.rs:82:40\n    |\n LL |     let (y, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n    |                 -------------------    ^^ borrowed value does not live long enough\n@@ -88,7 +118,7 @@ LL | }\n    | - `x` dropped here while still borrowed\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/patterns.rs:75:69\n+  --> $DIR/patterns.rs:87:69\n    |\n LL |     let Single { value: y }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n    |                              --------------------                   ^^ borrowed value does not live long enough\n@@ -98,7 +128,7 @@ LL | }\n    | - `x` dropped here while still borrowed\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/patterns.rs:80:69\n+  --> $DIR/patterns.rs:92:69\n    |\n LL |     let Single { value: _ }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n    |                              --------------------                   ^^ borrowed value does not live long enough\n@@ -108,7 +138,7 @@ LL | }\n    | - `x` dropped here while still borrowed\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/patterns.rs:88:17\n+  --> $DIR/patterns.rs:100:17\n    |\n LL |     let Double { value1: _, value2: _ }: Double<&'static u32> = Double {\n    |                                          -------------------- type annotation requires that `x` is borrowed for `'static`\n@@ -119,7 +149,7 @@ LL | }\n    | - `x` dropped here while still borrowed\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/patterns.rs:101:5\n+  --> $DIR/patterns.rs:113:5\n    |\n LL | fn static_to_a_to_static_through_variable<'a>(x: &'a u32) -> &'static u32 {\n    |                                           -- lifetime `'a` defined here\n@@ -128,14 +158,32 @@ LL |     y //~ ERROR\n    |     ^ returning this value requires that `'a` must outlive `'static`\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/patterns.rs:117:18\n+  --> $DIR/patterns.rs:125:5\n+   |\n+LL | fn static_to_a_to_static_through_tuple<'a>(x: &'a u32) -> &'static u32 {\n+   |                                        -- lifetime `'a` defined here\n+...\n+LL |     y //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/patterns.rs:130:5\n+   |\n+LL | fn static_to_a_to_static_through_struct<'a>(_x: &'a u32) -> &'static u32 {\n+   |                                         -- lifetime `'a` defined here\n+LL |     let Single { value: y }: Single<&'a u32> = Single { value: &22 };\n+LL |     y //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/patterns.rs:134:18\n    |\n LL | fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {\n    |                            -- lifetime `'a` defined here\n LL |     let (y, _z): (&'static u32, u32) = (x, 44); //~ ERROR\n    |                  ^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 19 previous errors\n \n Some errors occurred: E0597, E0716.\n For more information about an error, try `rustc --explain E0597`."}]}