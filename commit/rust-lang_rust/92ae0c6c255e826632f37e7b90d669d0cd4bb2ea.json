{"sha": "92ae0c6c255e826632f37e7b90d669d0cd4bb2ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYWUwYzZjMjU1ZTgyNjYzMmYzN2U3YjkwZDY2OWQwY2Q0YmIyZWE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-28T15:31:04Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-11-19T04:24:34Z"}, "message": "rustc: middle: ty: replace unsafe pointers with references in Ty.", "tree": {"sha": "de3ec701c8904815d9d90c7d35e2ff5ffcd3ab4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de3ec701c8904815d9d90c7d35e2ff5ffcd3ab4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92ae0c6c255e826632f37e7b90d669d0cd4bb2ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92ae0c6c255e826632f37e7b90d669d0cd4bb2ea", "html_url": "https://github.com/rust-lang/rust/commit/92ae0c6c255e826632f37e7b90d669d0cd4bb2ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92ae0c6c255e826632f37e7b90d669d0cd4bb2ea/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "html_url": "https://github.com/rust-lang/rust/commit/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c"}], "stats": {"total": 127, "additions": 55, "deletions": 72}, "files": [{"sha": "5c356e80c703f8f1ed82f5e290fd35c278622850", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 55, "deletions": 72, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/92ae0c6c255e826632f37e7b90d669d0cd4bb2ea/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ae0c6c255e826632f37e7b90d669d0cd4bb2ea/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=92ae0c6c255e826632f37e7b90d669d0cd4bb2ea", "patch": "@@ -61,6 +61,7 @@ use util::ppaux::{Repr, UserString};\n use util::common::{indenter, memoized};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n+use std::borrow::BorrowFrom;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt::{mod, Show};\n@@ -252,32 +253,6 @@ pub struct creader_cache_key {\n     pub len: uint\n }\n \n-pub struct intern_key {\n-    sty: *const sty,\n-}\n-\n-// NB: Do not replace this with #[deriving(PartialEq)]. The automatically-derived\n-// implementation will not recurse through sty and you will get stack\n-// exhaustion.\n-impl cmp::PartialEq for intern_key {\n-    fn eq(&self, other: &intern_key) -> bool {\n-        unsafe {\n-            *self.sty == *other.sty\n-        }\n-    }\n-    fn ne(&self, other: &intern_key) -> bool {\n-        !self.eq(other)\n-    }\n-}\n-\n-impl Eq for intern_key {}\n-\n-impl<W:Writer> Hash<W> for intern_key {\n-    fn hash(&self, s: &mut W) {\n-        unsafe { (*self.sty).hash(s) }\n-    }\n-}\n-\n pub enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n     atttce_resolved(Ty)  /* resolved to a type, irrespective of region */\n@@ -456,11 +431,13 @@ pub struct TransmuteRestriction {\n /// later on.\n pub struct ctxt<'tcx> {\n     /// The arena that types are allocated from.\n-    type_arena: &'tcx TypedArena<t_box_>,\n+    type_arena: &'tcx TypedArena<TyS>,\n \n     /// Specifically use a speedy hash algorithm for this hash map, it's used\n     /// quite often.\n-    interner: RefCell<FnvHashMap<intern_key, &'tcx t_box_>>,\n+    // TODO(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n+    // queried from a HashSet.\n+    interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n     pub sess: Session,\n     pub def_map: resolve::DefMap,\n \n@@ -621,10 +598,8 @@ bitflags! {\n     }\n }\n \n-pub type t_box = &'static t_box_;\n-\n #[deriving(Show)]\n-pub struct t_box_ {\n+pub struct TyS {\n     pub sty: sty,\n     pub flags: TypeFlags,\n \n@@ -638,32 +613,52 @@ impl fmt::Show for TypeFlags {\n     }\n }\n \n-// To reduce refcounting cost, we're representing types as unsafe pointers\n-// throughout the compiler. These are simply casted t_box values. Use ty::get\n-// to cast them back to a box. (Without the cast, compiler performance suffers\n-// ~15%.) This does mean that a Ty value relies on the ctxt to keep its box\n-// alive, and using ty::get is unsafe when the ctxt is no longer alive.\n-enum t_opaque {}\n+impl PartialEq for TyS {\n+    fn eq(&self, other: &TyS) -> bool {\n+        (self as *const _) == (other as *const _)\n+    }\n+}\n+impl Eq for TyS {}\n \n-#[allow(raw_pointer_deriving)]\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct Ty { inner: *const t_opaque }\n+impl<S: Writer> Hash<S> for TyS {\n+    fn hash(&self, s: &mut S) {\n+        (self as *const _).hash(s)\n+    }\n+}\n \n-impl fmt::Show for Ty {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", get(*self))\n+pub type Ty<'tcx> = &'tcx TyS;\n+\n+/// An entry in the type interner.\n+struct InternedTy<'tcx> {\n+    ty: Ty<'tcx>\n+}\n+\n+// NB: An InternedTy compares and hashes as a sty.\n+impl<'tcx> PartialEq for InternedTy<'tcx> {\n+    fn eq(&self, other: &InternedTy<'tcx>) -> bool {\n+        self.ty.sty == other.ty.sty\n+    }\n+}\n+impl<'tcx> Eq for InternedTy<'tcx> {}\n+\n+impl<'tcx, S: Writer> Hash<S> for InternedTy<'tcx> {\n+    fn hash(&self, s: &mut S) {\n+        self.ty.sty.hash(s)\n     }\n }\n \n-pub fn get(ty: Ty) -> t_box {\n-    unsafe {\n-        let t2: t_box = mem::transmute(ty);\n-        t2\n+impl<'tcx> BorrowFrom<InternedTy<'tcx>> for sty<'tcx> {\n+    fn borrow_from<'a>(ty: &'a InternedTy<'tcx>) -> &'a sty<'tcx> {\n+        &ty.ty.sty\n     }\n }\n \n-fn tbox_has_flag(tb: t_box, flag: TypeFlags) -> bool {\n-    tb.flags.intersects(flag)\n+pub fn get(ty: Ty) -> Ty {\n+    ty\n+}\n+\n+fn tbox_has_flag(ty: Ty, flag: TypeFlags) -> bool {\n+    ty.flags.intersects(flag)\n }\n pub fn type_has_params(ty: Ty) -> bool {\n     tbox_has_flag(get(ty), HAS_PARAMS)\n@@ -1024,13 +1019,13 @@ pub enum BoundRegion {\n }\n \n mod primitives {\n-    use super::t_box_;\n+    use super::TyS;\n \n     use syntax::ast;\n \n     macro_rules! def_prim_ty(\n         ($name:ident, $sty:expr) => (\n-            pub static $name: t_box_ = t_box_ {\n+            pub static $name: TyS = TyS {\n                 sty: $sty,\n                 flags: super::NO_TYPE_FLAGS,\n                 region_depth: 0,\n@@ -1053,7 +1048,7 @@ mod primitives {\n     def_prim_ty!(TY_F32,    super::ty_float(ast::TyF32))\n     def_prim_ty!(TY_F64,    super::ty_float(ast::TyF64))\n \n-    pub static TY_ERR: t_box_ = t_box_ {\n+    pub static TY_ERR: TyS = TyS {\n         sty: super::ty_err,\n         flags: super::HAS_TY_ERR,\n         region_depth: 0,\n@@ -1701,7 +1696,7 @@ impl UnboxedClosureKind {\n }\n \n pub fn mk_ctxt<'tcx>(s: Session,\n-                     type_arena: &'tcx TypedArena<t_box_>,\n+                     type_arena: &'tcx TypedArena<TyS>,\n                      dm: resolve::DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n@@ -1785,32 +1780,22 @@ pub fn mk_t(cx: &ctxt, st: sty) -> Ty {\n         _ => {}\n     };\n \n-    let key = intern_key { sty: &st };\n-\n-    match cx.interner.borrow().get(&key) {\n-        Some(ty) => unsafe { return mem::transmute(&ty.sty); },\n+    match cx.interner.borrow().get(&st) {\n+        Some(ty) => return ty,\n         _ => ()\n     }\n \n     let flags = FlagComputation::for_sty(&st);\n \n-    let ty = cx.type_arena.alloc(t_box_ {\n+    let ty = cx.type_arena.alloc(TyS {\n         sty: st,\n         flags: flags.flags,\n         region_depth: flags.depth,\n     });\n \n-    let sty_ptr = &ty.sty as *const sty;\n-\n-    let key = intern_key {\n-        sty: sty_ptr,\n-    };\n-\n-    cx.interner.borrow_mut().insert(key, ty);\n+    cx.interner.borrow_mut().insert(InternedTy { ty: ty }, ty);\n \n-    unsafe {\n-        mem::transmute::<*const sty, Ty>(sty_ptr)\n-    }\n+    Ty { inner: ty }\n }\n \n struct FlagComputation {\n@@ -1996,10 +1981,8 @@ impl FlagComputation {\n }\n \n #[inline]\n-pub fn mk_prim_t(primitive: &'static t_box_) -> Ty {\n-    unsafe {\n-        mem::transmute::<&'static t_box_, Ty>(primitive)\n-    }\n+pub fn mk_prim_t(primitive: &'static TyS) -> Ty {\n+    Ty { inner: primitive }\n }\n \n #[inline]"}]}