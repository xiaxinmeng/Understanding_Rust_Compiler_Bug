{"sha": "954873055a998a06841ac19b39b1fe18a6641731", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NDg3MzA1NWE5OThhMDY4NDFhYzE5YjM5YjFmZTE4YTY2NDE3MzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-30T14:35:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-30T14:35:04Z"}, "message": "Auto merge of #36823 - durka:discriminant_value, r=nagisa\n\nadd wrapper for discriminant_value, take 2\n\n[This is #34785 reopened, since @bors apparently gave up on that thread.]\n\nadd wrapper for discriminant_value intrinsic\n\nImplementation of [RFC 1696](https://github.com/rust-lang/rfcs/blob/master/text/1696-discriminant.md).\n\nWraps the `discriminant_value` intrinsic under the name `std::mem::discriminant`. In order to avoid prematurely leaking information about the implementation of enums, the return value is an opaque type, generic over the enum type, which implements Copy, Clone, PartialEq, Eq, Hash, and Debug (notably not PartialOrd). There is currently no way to get the value out excepting printing the debug representation.\n\nThe wrapper is safe and can be stabilized soon as per discussion in #24263.\n\ncc @aturon\nr? @nagisa", "tree": {"sha": "7b78cb8140c79594ac582e7c1421ac132a5d2ace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b78cb8140c79594ac582e7c1421ac132a5d2ace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/954873055a998a06841ac19b39b1fe18a6641731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/954873055a998a06841ac19b39b1fe18a6641731", "html_url": "https://github.com/rust-lang/rust/commit/954873055a998a06841ac19b39b1fe18a6641731", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/954873055a998a06841ac19b39b1fe18a6641731/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d64acdceb6f0eebbc5e8774972b86e4cf192a0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d64acdceb6f0eebbc5e8774972b86e4cf192a0f", "html_url": "https://github.com/rust-lang/rust/commit/1d64acdceb6f0eebbc5e8774972b86e4cf192a0f"}, {"sha": "a84b55085e314b243fd536c4e6804a58dfce122a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a84b55085e314b243fd536c4e6804a58dfce122a", "html_url": "https://github.com/rust-lang/rust/commit/a84b55085e314b243fd536c4e6804a58dfce122a"}], "stats": {"total": 110, "additions": 110, "deletions": 0}, "files": [{"sha": "e0aa25724c1f93924ce901139295d840355328af", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/954873055a998a06841ac19b39b1fe18a6641731/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/954873055a998a06841ac19b39b1fe18a6641731/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=954873055a998a06841ac19b39b1fe18a6641731", "patch": "@@ -15,7 +15,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use clone;\n+use cmp;\n+use fmt;\n+use hash;\n use intrinsics;\n+use marker::{Copy, PhantomData, Sized};\n use ptr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -647,3 +652,80 @@ pub fn drop<T>(_x: T) { }\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     ptr::read(src as *const T as *const U)\n }\n+\n+/// Opaque type representing the discriminant of an enum.\n+///\n+/// See the `discriminant` function in this module for more information.\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+pub struct Discriminant<T>(u64, PhantomData<*const T>);\n+\n+// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> Copy for Discriminant<T> {}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> clone::Clone for Discriminant<T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> cmp::PartialEq for Discriminant<T> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.0 == rhs.0\n+    }\n+}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> cmp::Eq for Discriminant<T> {}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> hash::Hash for Discriminant<T> {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> fmt::Debug for Discriminant<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.debug_tuple(\"Discriminant\")\n+           .field(&self.0)\n+           .finish()\n+    }\n+}\n+\n+/// Returns a value uniquely identifying the enum variant in `v`.\n+///\n+/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n+/// return value is unspecified.\n+///\n+/// # Stability\n+///\n+/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n+/// of some variant will not change between compilations with the same compiler.\n+///\n+/// # Examples\n+///\n+/// This can be used to compare enums that carry data, while disregarding\n+/// the actual data:\n+///\n+/// ```\n+/// #![feature(discriminant_value)]\n+/// use std::mem;\n+///\n+/// enum Foo { A(&'static str), B(i32), C(i32) }\n+///\n+/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n+/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n+/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n+/// ```\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n+    unsafe {\n+        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n+    }\n+}\n+"}, {"sha": "2dbda0be18d98a6f813c2762afa7161e0aa460e2", "filename": "src/test/run-pass/discriminant_value-wrapper.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/954873055a998a06841ac19b39b1fe18a6641731/src%2Ftest%2Frun-pass%2Fdiscriminant_value-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/954873055a998a06841ac19b39b1fe18a6641731/src%2Ftest%2Frun-pass%2Fdiscriminant_value-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiscriminant_value-wrapper.rs?ref=954873055a998a06841ac19b39b1fe18a6641731", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(discriminant_value)]\n+\n+use std::mem;\n+\n+enum ADT {\n+    First(u32, u32),\n+    Second(u64)\n+}\n+\n+pub fn main() {\n+    assert!(mem::discriminant(&ADT::First(0,0)) == mem::discriminant(&ADT::First(1,1)));\n+    assert!(mem::discriminant(&ADT::Second(5))  == mem::discriminant(&ADT::Second(6)));\n+    assert!(mem::discriminant(&ADT::First(2,2)) != mem::discriminant(&ADT::Second(2)));\n+\n+    let _ = mem::discriminant(&10);\n+    let _ = mem::discriminant(&\"test\");\n+}\n+"}]}