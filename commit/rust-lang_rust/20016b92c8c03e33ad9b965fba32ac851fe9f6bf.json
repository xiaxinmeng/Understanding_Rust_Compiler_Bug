{"sha": "20016b92c8c03e33ad9b965fba32ac851fe9f6bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMDE2YjkyYzhjMDNlMzNhZDliOTY1ZmJhMzJhYzg1MWZlOWY2YmY=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-07-03T03:59:26Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-07-05T08:56:48Z"}, "message": "Implement .size_hint() on the remaining Iterator adaptors\n\nEvery iterator adaptor now has an implementation of .size_hint() that\nmakes sense, except for when the default of (0, None) is correct.", "tree": {"sha": "0f202a6ef2a051135d01f1fa6e0071d151c665ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f202a6ef2a051135d01f1fa6e0071d151c665ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20016b92c8c03e33ad9b965fba32ac851fe9f6bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20016b92c8c03e33ad9b965fba32ac851fe9f6bf", "html_url": "https://github.com/rust-lang/rust/commit/20016b92c8c03e33ad9b965fba32ac851fe9f6bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20016b92c8c03e33ad9b965fba32ac851fe9f6bf/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc9b3ff1b30c10aaf60d40fd9845d9bf69ae2c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc9b3ff1b30c10aaf60d40fd9845d9bf69ae2c2e", "html_url": "https://github.com/rust-lang/rust/commit/dc9b3ff1b30c10aaf60d40fd9845d9bf69ae2c2e"}], "stats": {"total": 119, "additions": 118, "deletions": 1}, "files": [{"sha": "b164bcbd28b3ceb46762d8442ba4f223c773404a", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/20016b92c8c03e33ad9b965fba32ac851fe9f6bf/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20016b92c8c03e33ad9b965fba32ac851fe9f6bf/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=20016b92c8c03e33ad9b965fba32ac851fe9f6bf", "patch": "@@ -26,6 +26,7 @@ use option::{Option, Some, None};\n use ops::{Add, Mul};\n use cmp::Ord;\n use clone::Clone;\n+use uint;\n \n /// Conversion from an `Iterator`\n pub trait FromIterator<A, T: Iterator<A>> {\n@@ -688,9 +689,14 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<A, T, U> {\n         let (a_lower, a_upper) = self.a.size_hint();\n         let (b_lower, b_upper) = self.b.size_hint();\n \n-        let lower = a_lower + b_lower;\n+        let lower = if uint::max_value - a_lower < b_lower {\n+            uint::max_value\n+        } else {\n+            a_lower + b_lower\n+        };\n \n         let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) if uint::max_value - x < y => Some(uint::max_value),\n             (Some(x), Some(y)) => Some(x + y),\n             _ => None\n         };\n@@ -714,6 +720,23 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<A, T\n             _ => None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = cmp::min(a_lower, b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), None) => Some(x),\n+            (None, Some(y)) => Some(y),\n+            (None, None) => None\n+        };\n+\n+        (lower, upper)\n+    }\n }\n \n /// An iterator which maps the values of `iter` with `f`\n@@ -807,6 +830,11 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for EnumerateIterator<A, T> {\n             _ => None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n }\n \n /// An iterator which rejects elements while `predicate` is true\n@@ -839,6 +867,12 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhileIterator<'self, A, T> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n }\n \n /// An iterator which only accepts elements while `predicate` is true\n@@ -867,6 +901,12 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for TakeWhileIterator<'self, A, T> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n }\n \n /// An iterator which skips over `n` elements of `iter`.\n@@ -900,6 +940,21 @@ impl<A, T: Iterator<A>> Iterator<A> for SkipIterator<A, T> {\n             next\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = if lower >= self.n { lower - self.n } else { 0 };\n+\n+        let upper = match upper {\n+            Some(x) if x >= self.n => Some(x - self.n),\n+            Some(_) => Some(0),\n+            None => None\n+        };\n+\n+        (lower, upper)\n+    }\n }\n \n /// An iterator which only iterates over the first `n` iterations of `iter`.\n@@ -920,6 +975,20 @@ impl<A, T: Iterator<A>> Iterator<A> for TakeIterator<A, T> {\n             None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n)\n+        };\n+\n+        (lower, upper)\n+    }\n }\n \n /// An iterator to maintain state while iterating another iterator\n@@ -936,6 +1005,12 @@ impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for ScanIterator<'self, A, B,\n     fn next(&mut self) -> Option<B> {\n         self.iter.next().chain(|a| (self.f)(&mut self.state, a))\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n }\n \n /// An iterator that maps each element to an iterator,\n@@ -1017,6 +1092,11 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n         self.state = self.state.add(&self.step); // FIXME: #6050\n         Some(result)\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (uint::max_value, None) // Too bad we can't specify an infinite lower bound\n+    }\n }\n \n #[cfg(test)]\n@@ -1232,6 +1312,43 @@ mod tests {\n         assert_eq!(v.slice(0, 0).iter().transform(|&x| x).min(), None);\n     }\n \n+    #[test]\n+    fn test_iterator_size_hint() {\n+        let c = Counter::new(0, 1);\n+        let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+        let v2 = &[10, 11, 12];\n+        let vi = v.iter();\n+\n+        assert_eq!(c.size_hint(), (uint::max_value, None));\n+        assert_eq!(vi.size_hint(), (10, Some(10)));\n+\n+        assert_eq!(c.take_(5).size_hint(), (5, Some(5)));\n+        assert_eq!(c.skip(5).size_hint().second(), None);\n+        assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n+        assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n+        assert_eq!(c.enumerate().size_hint(), (uint::max_value, None));\n+        assert_eq!(c.chain_(vi.transform(|&i| i)).size_hint(), (uint::max_value, None));\n+        assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n+        assert_eq!(c.scan(0, |_,_| Some(0)).size_hint(), (0, None));\n+        assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n+        assert_eq!(c.transform(|_| 0).size_hint(), (uint::max_value, None));\n+        assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n+\n+        assert_eq!(vi.take_(5).size_hint(), (5, Some(5)));\n+        assert_eq!(vi.take_(12).size_hint(), (10, Some(10)));\n+        assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n+        assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n+        assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n+        assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n+        assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n+        assert_eq!(vi.chain_(v2.iter()).size_hint(), (13, Some(13)));\n+        assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n+        assert_eq!(vi.scan(0, |_,_| Some(0)).size_hint(), (0, Some(10)));\n+        assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n+        assert_eq!(vi.transform(|i| i+1).size_hint(), (10, Some(10)));\n+        assert_eq!(vi.filter_map(|_| Some(0)).size_hint(), (0, Some(10)));\n+    }\n+\n     #[test]\n     fn test_collect() {\n         let a = ~[1, 2, 3, 4, 5];"}]}