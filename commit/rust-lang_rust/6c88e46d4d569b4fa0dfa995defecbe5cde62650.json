{"sha": "6c88e46d4d569b4fa0dfa995defecbe5cde62650", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjODhlNDZkNGQ1NjliNGZhMGRmYTk5NWRlZmVjYmU1Y2RlNjI2NTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-22T18:20:40Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-24T13:45:20Z"}, "message": "std:rt: args module is not used by win/mac. #7951", "tree": {"sha": "76c09ad4f88ac8c0903983d19400f3556e920dac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76c09ad4f88ac8c0903983d19400f3556e920dac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c88e46d4d569b4fa0dfa995defecbe5cde62650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c88e46d4d569b4fa0dfa995defecbe5cde62650", "html_url": "https://github.com/rust-lang/rust/commit/6c88e46d4d569b4fa0dfa995defecbe5cde62650", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c88e46d4d569b4fa0dfa995defecbe5cde62650/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "206ae5752e05f3d22fdfb3f86d261a24e6dc2286", "url": "https://api.github.com/repos/rust-lang/rust/commits/206ae5752e05f3d22fdfb3f86d261a24e6dc2286", "html_url": "https://github.com/rust-lang/rust/commit/206ae5752e05f3d22fdfb3f86d261a24e6dc2286"}], "stats": {"total": 192, "additions": 123, "deletions": 69}, "files": [{"sha": "f1a9c6023b9002f41078654206972572fc797133", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 123, "deletions": 69, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6c88e46d4d569b4fa0dfa995defecbe5cde62650/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c88e46d4d569b4fa0dfa995defecbe5cde62650/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=6c88e46d4d569b4fa0dfa995defecbe5cde62650", "patch": "@@ -14,112 +14,166 @@\n //! the processes `argc` and `argv` arguments to be stored\n //! in a globally-accessible location for use by the `os` module.\n //!\n+//! Only valid to call on linux. Mac and Windows use syscalls to\n+//! discover the command line arguments.\n+//!\n //! XXX: Would be nice for this to not exist.\n //! XXX: This has a lot of C glue for lack of globals.\n \n-use libc;\n-use option::{Option, Some, None};\n-use str;\n-use uint;\n-use unstable::finally::Finally;\n-use util;\n+use option::Option;\n \n /// One-time global initialization.\n pub unsafe fn init(argc: int, argv: **u8) {\n-    let args = load_argc_and_argv(argc, argv);\n-    put(args);\n+    imp::init(argc, argv)\n }\n \n /// One-time global cleanup.\n pub fn cleanup() {\n-    rtassert!(take().is_some());\n+    imp::cleanup()\n }\n \n /// Take the global arguments from global storage.\n pub fn take() -> Option<~[~str]> {\n-    with_lock(|| unsafe {\n-        let ptr = get_global_ptr();\n-        let val = util::replace(&mut *ptr, None);\n-        val.map(|s: &~~[~str]| (**s).clone())\n-    })\n+    imp::take()\n }\n \n /// Give the global arguments to global storage.\n ///\n /// It is an error if the arguments already exist.\n pub fn put(args: ~[~str]) {\n-    with_lock(|| unsafe {\n-        let ptr = get_global_ptr();\n-        rtassert!((*ptr).is_none());\n-        (*ptr) = Some(~args.clone());\n-    })\n+    imp::put(args)\n }\n \n /// Make a clone of the global arguments.\n pub fn clone() -> Option<~[~str]> {\n-    with_lock(|| unsafe {\n-        let ptr = get_global_ptr();\n-        (*ptr).map(|s: &~~[~str]| (**s).clone())\n-    })\n+    imp::clone()\n }\n \n-fn with_lock<T>(f: &fn() -> T) -> T {\n-    do (|| {\n-        unsafe {\n-            rust_take_global_args_lock();\n-            f()\n-        }\n-    }).finally {\n-        unsafe {\n-            rust_drop_global_args_lock();\n-        }\n-    }\n-}\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"freebsd\")]\n+mod imp {\n \n-fn get_global_ptr() -> *mut Option<~~[~str]> {\n-    unsafe { rust_get_global_args_ptr() }\n-}\n+    use libc;\n+    use option::{Option, Some, None};\n+    use str;\n+    use uint;\n+    use unstable::finally::Finally;\n+    use util;\n \n-// Copied from `os`.\n-unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~str] {\n-    let mut args = ~[];\n-    for uint::range(0, argc as uint) |i| {\n-        args.push(str::raw::from_c_str(*(argv as **libc::c_char).offset(i)));\n+    pub unsafe fn init(argc: int, argv: **u8) {\n+        let args = load_argc_and_argv(argc, argv);\n+        put(args);\n     }\n-    return args;\n-}\n-\n-extern {\n-    fn rust_take_global_args_lock();\n-    fn rust_drop_global_args_lock();\n-    fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>;\n-}\n \n-#[cfg(test)]\n-mod tests {\n-    use option::{Some, None};\n-    use super::*;\n-    use unstable::finally::Finally;\n+    pub fn cleanup() {\n+        rtassert!(take().is_some());\n+    }\n \n-    #[test]\n-    fn smoke_test() {\n-        // Preserve the actual global state.\n-        let saved_value = take();\n+    pub fn take() -> Option<~[~str]> {\n+        with_lock(|| unsafe {\n+            let ptr = get_global_ptr();\n+            let val = util::replace(&mut *ptr, None);\n+            val.map(|s: &~~[~str]| (**s).clone())\n+        })\n+    }\n \n-        let expected = ~[~\"happy\", ~\"today?\"];\n+    pub fn put(args: ~[~str]) {\n+        with_lock(|| unsafe {\n+            let ptr = get_global_ptr();\n+            rtassert!((*ptr).is_none());\n+            (*ptr) = Some(~args.clone());\n+        })\n+    }\n \n-        put(expected.clone());\n-        assert!(clone() == Some(expected.clone()));\n-        assert!(take() == Some(expected.clone()));\n-        assert!(take() == None);\n+    pub fn clone() -> Option<~[~str]> {\n+        with_lock(|| unsafe {\n+            let ptr = get_global_ptr();\n+            (*ptr).map(|s: &~~[~str]| (**s).clone())\n+        })\n+    }\n \n+    fn with_lock<T>(f: &fn() -> T) -> T {\n         do (|| {\n+            unsafe {\n+                rust_take_global_args_lock();\n+                f()\n+            }\n         }).finally {\n-            // Restore the actual global state.\n-            match saved_value {\n-                Some(ref args) => put(args.clone()),\n-                None => ()\n+            unsafe {\n+                rust_drop_global_args_lock();\n+            }\n+        }\n+    }\n+\n+    fn get_global_ptr() -> *mut Option<~~[~str]> {\n+        unsafe { rust_get_global_args_ptr() }\n+    }\n+\n+    // Copied from `os`.\n+    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~str] {\n+        let mut args = ~[];\n+        for uint::range(0, argc as uint) |i| {\n+            args.push(str::raw::from_c_str(*(argv as **libc::c_char).offset(i)));\n+        }\n+        return args;\n+    }\n+\n+    extern {\n+        fn rust_take_global_args_lock();\n+        fn rust_drop_global_args_lock();\n+        fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>;\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+        use option::{Some, None};\n+        use super::*;\n+        use unstable::finally::Finally;\n+\n+        #[test]\n+        fn smoke_test() {\n+            // Preserve the actual global state.\n+            let saved_value = take();\n+\n+            let expected = ~[~\"happy\", ~\"today?\"];\n+\n+            put(expected.clone());\n+            assert!(clone() == Some(expected.clone()));\n+            assert!(take() == Some(expected.clone()));\n+            assert!(take() == None);\n+\n+            do (|| {\n+            }).finally {\n+                // Restore the actual global state.\n+                match saved_value {\n+                    Some(ref args) => put(args.clone()),\n+                    None => ()\n+                }\n             }\n         }\n     }\n }\n+\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"win32\")]\n+mod imp {\n+\n+    pub unsafe fn init(_argc: int, _argv: **u8) {\n+    }\n+\n+    pub fn cleanup() {\n+    }\n+\n+    pub fn take() -> Option<~[~str]> {\n+        fail!()\n+    }\n+\n+    pub fn put(_args: ~[~str]) {\n+        fail!()\n+    }\n+\n+    pub fn clone() -> Option<~[~str]> {\n+        fail!()\n+    }\n+}\n\\ No newline at end of file"}]}