{"sha": "27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3Y2MwYTM2YjY4OWJjYmM1ODExNzQ1MDMzMGY2ZmE0ZWJkMzVjOWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-11T23:20:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-12T00:15:33Z"}, "message": "Promote 'struct' from a restricted keyword to a strict keyword", "tree": {"sha": "ed332e3b1efbb66981f485ccf75f04d592dd51ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed332e3b1efbb66981f485ccf75f04d592dd51ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "html_url": "https://github.com/rust-lang/rust/commit/27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1203da3b9ddbf6af343fdb826b899b55a7bda053", "url": "https://api.github.com/repos/rust-lang/rust/commits/1203da3b9ddbf6af343fdb826b899b55a7bda053", "html_url": "https://github.com/rust-lang/rust/commit/1203da3b9ddbf6af343fdb826b899b55a7bda053"}], "stats": {"total": 371, "additions": 185, "deletions": 186}, "files": [{"sha": "cd422b03a4b324a5e57c923a6cb8673c50b8d735", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -415,7 +415,6 @@ fn restricted_keyword_table() -> HashMap<~str, ()> {\n         ~\"fail\", ~\"fn\",\n         ~\"impl\",\n         ~\"priv\", ~\"pub\",\n-        ~\"struct\",\n         ~\"unsafe\"\n     ];\n     for keys.each |word| {\n@@ -438,6 +437,7 @@ fn strict_keyword_table() -> HashMap<~str, ()> {\n         ~\"match\", ~\"mod\", ~\"move\", ~\"mut\",\n         ~\"pure\",\n         ~\"ref\", ~\"return\",\n+        ~\"struct\",\n         ~\"true\", ~\"trait\", ~\"type\",\n         ~\"unchecked\", ~\"use\",\n         ~\"while\""}, {"sha": "ed6835b6f8bf91d9244c7c06646fc596fd2ad8a6", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -584,7 +584,7 @@ fn get_enum_variants(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                                 tcx, cdata);\n         let name = item_name(intr, item);\n         let mut arg_tys: ~[ty::t] = ~[];\n-        match ty::get(ctor_ty).struct {\n+        match ty::get(ctor_ty).sty {\n           ty::ty_fn(f) => {\n             for f.sig.inputs.each |a| { vec::push(arg_tys, a.ty); }\n           }\n@@ -696,7 +696,7 @@ fn get_trait_methods(intr: ident_interner, cdata: cmd, id: ast::node_id,\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n-        let fty = match ty::get(ty).struct {\n+        let fty = match ty::get(ty).sty {\n           ty::ty_fn(f) => f,\n           _ => {\n             tcx.diag.handler().bug("}, {"sha": "175691613a7b94aa1d1e71823d64a7be61a0f267", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -47,7 +47,7 @@ fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n           Some(s) => *s,\n           None => {\n             let buf = io::mem_buffer();\n-            enc_sty(io::mem_buffer_writer(buf), cx, ty::get(t).struct);\n+            enc_sty(io::mem_buffer_writer(buf), cx, ty::get(t).sty);\n             cx.tcx.short_names_cache.insert(t, @io::mem_buffer_str(buf));\n             io::mem_buffer_str(buf)\n           }\n@@ -72,7 +72,7 @@ fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n               }\n               _ => {}\n             }\n-            enc_sty(w, cx, ty::get(t).struct);\n+            enc_sty(w, cx, ty::get(t).sty);\n             let end = w.tell();\n             let len = end - pos;\n             fn estimate_sz(u: uint) -> uint {"}, {"sha": "e2cbb68e95a8e0724fb9820fa6525afc2827c4ac", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -224,7 +224,7 @@ impl check_loan_ctxt {\n         }\n \n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n-        match ty::get(callee_ty).struct {\n+        match ty::get(callee_ty).sty {\n           ty::ty_fn(fn_ty) => {\n             match fn_ty.meta.purity {\n               ast::pure_fn => return, // case (c) above"}, {"sha": "79dbcecbec495384a81c8cbefeb2a3afdccbf1b7", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -39,7 +39,7 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n            // If the type *is* empty, it's vacuously exhaustive\n            return;\n        }\n-       match ty::get(pat_ty).struct {\n+       match ty::get(pat_ty).sty {\n           ty_enum(did, _) => {\n               if (*enum_variants(tcx, did)).is_empty() && arms.is_empty() {\n \n@@ -85,7 +85,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n       not_useful => return, // This is good, wildcard pattern isn't reachable\n       useful_ => None,\n       useful(ty, ctor) => {\n-        match ty::get(ty).struct {\n+        match ty::get(ty).sty {\n           ty::ty_bool => {\n             match ctor {\n               val(const_bool(true)) => Some(~\"true\"),\n@@ -167,7 +167,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n       None => {\n         match missing_ctor(tcx, m, left_ty) {\n           None => {\n-            match ty::get(left_ty).struct {\n+            match ty::get(left_ty).sty {\n               ty::ty_bool => {\n                 match is_useful_specialized(tcx, m, v, val(const_bool(true)),\n                                           0u, left_ty){\n@@ -257,7 +257,7 @@ fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n }\n \n fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n-    match ty::get(left_ty).struct {\n+    match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n       ty::ty_rec(_) | ty::ty_class(*) => {\n         for m.each |r| {\n@@ -302,7 +302,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n }\n \n fn ctor_arity(tcx: ty::ctxt, ctor: ctor, ty: ty::t) -> uint {\n-    match ty::get(ty).struct {\n+    match ty::get(ty).sty {\n       ty::ty_tup(fs) => fs.len(),\n       ty::ty_rec(fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n@@ -352,7 +352,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         }\n       }\n       pat_rec(flds, _) => {\n-        let ty_flds = match ty::get(left_ty).struct {\n+        let ty_flds = match ty::get(left_ty).sty {\n             ty::ty_rec(flds) => flds,\n             _ => fail ~\"bad type for pat_rec\"\n         };\n@@ -367,7 +367,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       pat_struct(_, flds, _) => {\n         // Grab the class data that we care about.\n         let class_fields, class_id;\n-        match ty::get(left_ty).struct {\n+        match ty::get(left_ty).sty {\n             ty::ty_class(cid, _) => {\n                 class_id = cid;\n                 class_fields = ty::lookup_class_fields(tcx, class_id);"}, {"sha": "41bfe9ae026388c97bcdfc1ee41a2a9afa9119c8", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -317,7 +317,7 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n       expr_cast(base, _) => {\n         let ety = ty::expr_ty(tcx, e);\n         let base = eval_const_expr(tcx, base);\n-        match ty::get(ety).struct {\n+        match ty::get(ety).sty {\n           ty::ty_float(_) => {\n             match base {\n               const_uint(u) => const_float(u as f64),"}, {"sha": "4e1d67ea365861dc921129d310c27a194719668f", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -300,7 +300,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n           Some(ex) => {\n             // All noncopyable fields must be overridden\n             let t = ty::expr_ty(cx.tcx, ex);\n-            let ty_fields = match ty::get(t).struct {\n+            let ty_fields = match ty::get(t).sty {\n               ty::ty_rec(f) => f,\n               _ => cx.tcx.sess.span_bug(ex.span, ~\"bad expr type in record\")\n             };\n@@ -504,7 +504,7 @@ fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n // note: also used from middle::typeck::regionck!\n fn check_owned(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n     if !ty::kind_is_owned(ty::type_kind(tcx, ty)) {\n-        match ty::get(ty).struct {\n+        match ty::get(ty).sty {\n           ty::ty_param(*) => {\n             tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n                                     pointers; use `owned` bound\");\n@@ -551,7 +551,7 @@ fn check_cast_for_escaping_regions(\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries.\n     let target_ty = ty::expr_ty(cx.tcx, target);\n-    let target_substs = match ty::get(target_ty).struct {\n+    let target_substs = match ty::get(target_ty).sty {\n       ty::ty_trait(_, substs, _) => {substs}\n       _ => { return; /* not a cast to a trait */ }\n     };\n@@ -574,7 +574,7 @@ fn check_cast_for_escaping_regions(\n     let target_params = ty::param_tys_in_type(target_ty);\n     let source_ty = ty::expr_ty(cx.tcx, source);\n     do ty::walk_ty(source_ty) |ty| {\n-        match ty::get(ty).struct {\n+        match ty::get(ty).sty {\n           ty::ty_param(source_param) => {\n             if target_params.contains(source_param) {\n                 /* case (2) */"}, {"sha": "255d7a4dd8a819c72fd1642ab56236e0f5a866a8", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -498,7 +498,7 @@ fn check_item_heap(cx: ty::ctxt, it: @ast::item) {\n             let mut n_box = 0;\n             let mut n_uniq = 0;\n             ty::fold_ty(cx, ty, |t| {\n-                match ty::get(t).struct {\n+                match ty::get(t).sty {\n                   ty::ty_box(_) => n_box += 1,\n                   ty::ty_uniq(_) => n_uniq += 1,\n                   _ => ()\n@@ -658,7 +658,7 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n     }\n \n     let fn_ty = ty::node_id_to_type(tcx, id);\n-    match ty::get(fn_ty).struct {\n+    match ty::get(fn_ty).sty {\n       ty::ty_fn(fn_ty) => {\n         let mut counter = 0;\n         do vec::iter2(fn_ty.sig.inputs, decl.inputs) |arg_ty, arg_ast| {"}, {"sha": "c97431eed2349905f94e5d53831a49e122b2426d", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -290,7 +290,7 @@ enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_uniq(*) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) => {\n@@ -424,7 +424,7 @@ impl &mem_categorization_ctxt {\n         // Any expression can be borrowed (to account for auto-ref on method\n         // receivers), but @, ~, @vec, and ~vec are handled specially.\n         let expr_ty = ty::expr_ty(self.tcx, expr);\n-        match ty::get(expr_ty).struct {\n+        match ty::get(expr_ty).sty {\n           ty::ty_evec(*) | ty::ty_estr(*) => {\n             self.cat_index(expr, expr)\n           }\n@@ -1013,7 +1013,7 @@ impl &mem_categorization_ctxt {\n           cat_comp(_, comp_tuple) => ~\"tuple content\",\n           cat_comp(_, comp_variant(_)) => ~\"enum content\",\n           cat_comp(_, comp_index(t, _)) => {\n-            match ty::get(t).struct {\n+            match ty::get(t).sty {\n               ty::ty_evec(*) => mut_str + ~\" vec content\",\n               ty::ty_estr(*) => mut_str + ~\" str content\",\n               _ => mut_str + ~\" indexed content\"\n@@ -1034,7 +1034,7 @@ fn field_mutbl(tcx: ty::ctxt,\n                base_ty: ty::t,\n                f_name: ast::ident) -> Option<ast::mutability> {\n     // Need to refactor so that records/class fields can be treated uniformly.\n-    match ty::get(base_ty).struct {\n+    match ty::get(base_ty).sty {\n       ty::ty_rec(fields) => {\n         for fields.each |f| {\n             if f.ident == f_name {"}, {"sha": "6b0df4630da2eccf9ff7bb609621022cf1ad074e", "filename": "src/rustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fprivacy.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -154,7 +154,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n         visit_expr: |expr, method_map: &method_map, visitor| {\n             match expr.node {\n                 expr_field(base, ident, _) => {\n-                    match ty::get(ty::expr_ty(tcx, base)).struct {\n+                    match ty::get(ty::expr_ty(tcx, base)).sty {\n                         ty_class(id, _)\n                         if id.crate != local_crate ||\n                            !privileged_items.contains(id.node) => {\n@@ -175,7 +175,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                     }\n                 }\n                 expr_struct(_, fields, _) => {\n-                    match ty::get(ty::expr_ty(tcx, expr)).struct {\n+                    match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_class(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(id.node) {\n@@ -202,7 +202,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n         visit_pat: |pattern, method_map, visitor| {\n             match pattern.node {\n                 pat_struct(_, fields, _) => {\n-                    match ty::get(ty::pat_ty(tcx, pattern)).struct {\n+                    match ty::get(ty::pat_ty(tcx, pattern)).sty {\n                         ty_class(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(id.node) {"}, {"sha": "421d7923234fd962b07c76999a961b9ed3746c70", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -293,8 +293,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n    {vals: ~[ValueRef], bcx: block} {\n     let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n-    let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id))\n-        .struct {\n+    let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n       ty::ty_enum(id, substs) => { assert id == vdefs.enm; substs.tps }\n       _ => bcx.sess().bug(~\"extract_variant_args: pattern has non-enum type\")\n     };\n@@ -436,7 +435,7 @@ fn compare_values(cx: block, lhs: ValueRef, rhs: ValueRef, rhs_t: ty::t) ->\n       return rslt(rs.bcx, rs.val);\n     }\n \n-    match ty::get(rhs_t).struct {\n+    match ty::get(rhs_t).sty {\n         ty::ty_estr(ty::vstore_uniq) => {\n             let scratch_result = scratch_datum(cx, ty::mk_bool(cx.tcx()),\n                                                false);\n@@ -559,7 +558,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n \n     if any_tup_pat(m, col) {\n         let tup_ty = node_id_type(bcx, pat_id);\n-        let n_tup_elts = match ty::get(tup_ty).struct {\n+        let n_tup_elts = match ty::get(tup_ty).sty {\n           ty::ty_tup(elts) => elts.len(),\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };"}, {"sha": "226b76831e69a66d74336e733d6a0420a0c3a3ec", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -422,7 +422,7 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n                         t: ty::t, op: ast::binop) -> Result {\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n         ty::ty_nil => rslt(cx, f(nil_type)),\n         ty::ty_bool | ty::ty_ptr(_) => rslt(cx, f(unsigned_int)),\n         ty::ty_int(_) => rslt(cx, f(signed_int)),\n@@ -528,7 +528,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let fn_ty = variant.ctor_ty;\n         let ccx = cx.ccx();\n         let mut cx = cx;\n-        match ty::get(fn_ty).struct {\n+        match ty::get(fn_ty).sty {\n           ty::ty_fn(ref fn_ty) => {\n             let mut j = 0u;\n             let v_id = variant.id;\n@@ -548,7 +548,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     Typestate constraint that shows the unimpl case doesn't happen?\n     */\n     let mut cx = cx;\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_rec(*) | ty::ty_class(*) => {\n           do expr::with_field_tys(cx.tcx(), t) |_has_dtor, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {\n@@ -655,7 +655,7 @@ fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n     } else {\n         ~\"modulo zero\"\n     };\n-    let is_zero = match ty::get(rhs_t).struct {\n+    let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {\n         let zero = C_integral(T_int_ty(cx.ccx(), t), 0u64, False);\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n@@ -681,7 +681,7 @@ fn null_env_ptr(bcx: block) -> ValueRef {\n fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_fn(_) => {\n         let llty = type_of_fn_from_ty(ccx, t);\n         return get_extern_fn(ccx.externs, ccx.llmod, name,\n@@ -1956,7 +1956,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n     let main_takes_argv =\n         // invariant!\n-        match ty::get(main_node_type).struct {\n+        match ty::get(main_node_type).sty {\n           ty::ty_fn(ref fn_ty) => fn_ty.sig.inputs.len() != 0u,\n           _ => ccx.sess.span_fatal(sp, ~\"main has a non-function type\")\n         };"}, {"sha": "0f8d9495801d03c6450497c25051a75dc062809c", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -620,7 +620,7 @@ fn adapt_borrowed_value(bcx: block,\n            datum.to_str(bcx.ccx()),\n            bcx.expr_to_str(expr));\n \n-    match ty::get(datum.ty).struct {\n+    match ty::get(datum.ty).sty {\n         ty::ty_uniq(_) | ty::ty_box(_) => {\n             let body_datum = datum.box_body(bcx);\n             let rptr_datum = body_datum.to_rptr(bcx);"}, {"sha": "24fd916823a33b44983b88940121cacaaf77d3fb", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -10,7 +10,7 @@ fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n       ast::lit_uint(u, t) => C_integral(T_uint_ty(cx, t), u, False),\n       ast::lit_int_unsuffixed(i) => {\n         let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n-        match ty::get(lit_int_ty).struct {\n+        match ty::get(lit_int_ty).sty {\n           ty::ty_int(t) => {\n             C_integral(T_int_ty(cx, t), i as u64, True)\n           }\n@@ -76,7 +76,7 @@ fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n     let mut v1 = v;\n     loop {\n         // Only rptrs can be autoderef'ed in a const context.\n-        match ty::get(ty).struct {\n+        match ty::get(ty).sty {\n             ty::ty_rptr(_, mt) => {\n                 t1 = mt.ty;\n                 v1 = const_deref(cx, v1);\n@@ -184,7 +184,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n                                     ~\"index is not an integer-constant \\\n                                       expression\")\n           };\n-          let (arr, _len) = match ty::get(bt).struct {\n+          let (arr, _len) = match ty::get(bt).sty {\n               ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n                   match vstore {\n                   ty::vstore_fixed(u) =>\n@@ -236,7 +236,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           // we can get the value (as a number) out of.\n \n           let len = llvm::LLVMGetArrayLength(val_ty(arr)) as u64;\n-          let len = match ty::get(bt).struct {\n+          let len = match ty::get(bt).sty {\n               ty::ty_estr(*) => {assert len > 0; len - 1},\n               _ => len\n           };"}, {"sha": "31db9c96beae3e04705686c735242ed6ce12f909", "filename": "src/rustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -528,7 +528,7 @@ impl Datum {\n          * This datum must represent an @T or ~T box.  Returns a new\n          * by-ref datum of type T, pointing at the contents. */\n \n-        let content_ty = match ty::get(self.ty).struct {\n+        let content_ty = match ty::get(self.ty).sty {\n             ty::ty_box(mt) | ty::ty_uniq(mt) => mt.ty,\n             _ => {\n                 bcx.tcx().sess.bug(fmt!(\n@@ -583,7 +583,7 @@ impl Datum {\n             }\n         }\n \n-        match ty::get(self.ty).struct {\n+        match ty::get(self.ty).sty {\n             ty::ty_box(_) | ty::ty_uniq(_) => {\n                 return Some(self.box_body(bcx));\n             }"}, {"sha": "1bd62b4f88344921ca99a929b554f8603f434df7", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -447,7 +447,7 @@ fn trans_rvalue_dps(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n         }\n         ast::expr_fn_block(decl, body, cap_clause) => {\n             let expr_ty = expr_ty(bcx, expr);\n-            match ty::get(expr_ty).struct {\n+            match ty::get(expr_ty).sty {\n                 ty::ty_fn(ref fn_ty) => {\n                     debug!(\"translating fn_block %s with type %s\",\n                            expr_to_str(expr, tcx.sess.intr()),\n@@ -464,7 +464,7 @@ fn trans_rvalue_dps(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n             }\n         }\n         ast::expr_loop_body(blk) => {\n-            match ty::get(expr_ty(bcx, expr)).struct {\n+            match ty::get(expr_ty(bcx, expr)).sty {\n                 ty::ty_fn(ref fn_ty) => {\n                     match blk.node {\n                         ast::expr_fn_block(decl, body, cap) => {\n@@ -774,7 +774,7 @@ fn fn_data_to_datum(bcx: block,\n \n fn with_field_tys<R>(tcx: ty::ctxt, ty: ty::t,\n                      op: fn(bool, (&[ty::field])) -> R) -> R {\n-    match ty::get(ty).struct {\n+    match ty::get(ty).sty {\n         ty::ty_rec(ref fields) => {\n             op(false, *fields)\n         }\n@@ -1279,7 +1279,7 @@ impl cast_kind : cmp::Eq {\n }\n \n fn cast_type_kind(t: ty::t) -> cast_kind {\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n         ty::ty_float(*)   => cast_float,\n         ty::ty_ptr(*)     => cast_pointer,\n         ty::ty_rptr(*)    => cast_pointer,"}, {"sha": "75ec925a4f8f5ae8554a1772fdcd70b26ff15746", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -440,7 +440,7 @@ type c_stack_tys = {\n \n fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n                        id: ast::node_id) -> (~[TypeRef], TypeRef, ty::t) {\n-    match ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n+    match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n         ty::ty_fn(ref fn_ty) => {\n             let llargtys = type_of_explicit_args(ccx, fn_ty.sig.inputs);\n             let llretty = type_of::type_of(ccx, fn_ty.sig.output);"}, {"sha": "282f890ef2a160c793b7c67ab9ba7506a0495848", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -51,7 +51,7 @@ fn drop_ty_root(bcx: block, v: ValueRef, rooted: bool, t: ty::t) -> block {\n \n fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) => {\n@@ -68,7 +68,7 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n \n fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n     let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_estr(ty::vstore_box) => {\n@@ -97,7 +97,7 @@ fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n \n fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(\"free_ty_immediate\");\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) |\n@@ -268,7 +268,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = bcx.insn_ctxt(\"make_free_glue\");\n     let ccx = bcx.ccx();\n-    let bcx = match ty::get(t).struct {\n+    let bcx = match ty::get(t).sty {\n       ty::ty_box(body_mt) => {\n         let v = Load(bcx, v);\n         let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n@@ -357,7 +357,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n-    let bcx = match ty::get(t).struct {\n+    let bcx = match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n@@ -418,7 +418,7 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n-    let bcx = match ty::get(t).struct {\n+    let bcx = match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx"}, {"sha": "90b913b807ac350e07e241a94fde290a33aae739", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -198,7 +198,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n \n fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> Option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n-    match ty::get(ty).struct {\n+    match ty::get(ty).sty {\n         ty::ty_box(*) => {\n             Some(ty::mk_opaque_box(tcx))\n         }"}, {"sha": "9bf710fcbeb79763803515d748890e438fb955c2", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -114,7 +114,7 @@ impl reflector {\n         debug!(\"reflect::visit_ty %s\",\n                ty_to_str(bcx.ccx().tcx, t));\n \n-        match ty::get(t).struct {\n+        match ty::get(t).sty {\n           ty::ty_bot => self.leaf(~\"bot\"),\n           ty::ty_nil => self.leaf(~\"nil\"),\n           ty::ty_bool => self.leaf(~\"bool\"),"}, {"sha": "f1b6a042053b77cc026399f02c65ae9a065864b2", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -215,7 +215,7 @@ fn add_substr(&dest: ~[u8], src: ~[u8]) {\n }\n \n fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n         ty::ty_bot => ~[shape_u8],\n         ty::ty_int(ast::ty_i) => ~[s_int(ccx.tcx)],\n@@ -719,7 +719,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n // Computes the size of the data part of an enum.\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(t) { return cx.enum_sizes.get(t); }\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_enum(tid, ref substs) => {\n         // Compute max(variant sizes).\n         let mut max_size = 0u;\n@@ -753,7 +753,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n         ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n     }\n     fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n-        match ty::get(typ).struct {\n+        match ty::get(typ).sty {\n           ty::ty_box(_) | ty::ty_opaque_box | ty::ty_uniq(_) |\n           ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n           ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |"}, {"sha": "c0e695cbee125213fcc56b01bd5a43046f3e7831", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -19,7 +19,7 @@ use util::common::indenter;\n fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unit_ty = ty::sequence_element_type(tcx, t);\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) => {\n         ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n       }\n@@ -431,7 +431,7 @@ fn get_base_and_len(bcx: block,\n     let ccx = bcx.ccx();\n     let vt = vec_types(bcx, vec_ty);\n \n-    let vstore = match ty::get(vt.vec_ty).struct {\n+    let vstore = match ty::get(vt.vec_ty).sty {\n       ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n       _ => ty::vstore_uniq\n     };"}, {"sha": "8c4f01701f02c9e8e92f2b643bb92076b3fa71c6", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -55,7 +55,7 @@ fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     if t != t_norm {\n         type_of_non_gc_box(cx, t_norm)\n     } else {\n-        match ty::get(t).struct {\n+        match ty::get(t).sty {\n           ty::ty_box(mt) => {\n             T_ptr(T_box(cx, type_of(cx, mt.ty)))\n           }\n@@ -88,7 +88,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         return llty;\n     }\n \n-    let llty = match ty::get(t).struct {\n+    let llty = match ty::get(t).sty {\n       ty::ty_nil | ty::ty_bot => T_nil(),\n       ty::ty_bool => T_bool(),\n       ty::ty_int(t) => T_int_ty(cx, t),\n@@ -178,7 +178,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     cx.lltypes.insert(t, llty);\n \n     // If this was an enum or class, fill in the type now.\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n       ty::ty_enum(did, _) => {\n         fill_type_of_enum(cx, did, t, llty);\n       }"}, {"sha": "7e101e4796e4b323f8799731ab88c830b411d273", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -45,7 +45,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     ccx.type_use_cache.insert(fn_id, vec::from_elem(n_tps, 3u));\n \n     let cx = {ccx: ccx, uses: vec::to_mut(vec::from_elem(n_tps, 0u))};\n-    match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).struct {\n+    match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n       ty::ty_fn(ref fn_ty) => {\n         for vec::each(fn_ty.sig.inputs) |arg| {\n             if arg.mode == expl(by_val) { type_needs(cx, use_repr, arg.ty); }\n@@ -130,7 +130,7 @@ fn type_needs_inner(cx: ctx, use_: uint, ty: ty::t,\n                     enums_seen: @List<def_id>) {\n     do ty::maybe_walk_ty(ty) |ty| {\n         if ty::type_has_params(ty) {\n-            match ty::get(ty).struct {\n+            match ty::get(ty).sty {\n                 /*\n                  This previously included ty_box -- that was wrong\n                  because if we cast an @T to an trait (for example) and return\n@@ -178,7 +178,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       }\n       expr_cast(base, _) => {\n         let result_t = ty::node_id_to_type(cx.ccx.tcx, e.id);\n-        match ty::get(result_t).struct {\n+        match ty::get(result_t).sty {\n             ty::ty_trait(*) => {\n               // When we're casting to an trait, we need the\n               // tydesc for the expr that's being cast."}, {"sha": "2ad5412e758aef8b2c85820f71c1d2bffdfb2d56", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -247,18 +247,18 @@ impl creader_cache_key : to_bytes::IterBytes {\n     }\n }\n \n-type intern_key = {struct: sty, o_def_id: Option<ast::def_id>};\n+type intern_key = {sty: sty, o_def_id: Option<ast::def_id>};\n \n impl intern_key: cmp::Eq {\n     pure fn eq(&&other: intern_key) -> bool {\n-        self.struct == other.struct && self.o_def_id == other.o_def_id\n+        self.sty == other.sty && self.o_def_id == other.o_def_id\n     }\n     pure fn ne(&&other: intern_key) -> bool { !self.eq(other) }\n }\n \n impl intern_key : to_bytes::IterBytes {\n     fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.struct, &self.o_def_id, lsb0, f);\n+        to_bytes::iter_bytes_2(&self.sty, &self.o_def_id, lsb0, f);\n     }\n }\n \n@@ -356,7 +356,7 @@ enum tbox_flag {\n     needs_subst = 1 | 2 | 8\n }\n \n-type t_box = @{struct: sty,\n+type t_box = @{sty: sty,\n                id: uint,\n                flags: uint,\n                o_def_id: Option<ast::def_id>};\n@@ -854,7 +854,7 @@ fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n-    let key = {struct: st, o_def_id: o_def_id};\n+    let key = {sty: st, o_def_id: o_def_id};\n     match cx.interner.find(key) {\n       Some(t) => unsafe { return unsafe::reinterpret_cast(&t); },\n       _ => ()\n@@ -911,7 +911,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n         flags |= get(f.sig.output).flags;\n       }\n     }\n-    let t = @{struct: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n+    let t = @{sty: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n     cx.interner.insert(key, t);\n     cx.next_id += 1u;\n     unsafe { unsafe::reinterpret_cast(&t) }\n@@ -1046,12 +1046,12 @@ fn mk_opaque_closure_ptr(cx: ctxt, ck: closure_kind) -> t {\n fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n \n fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n-    mk_t_with_id(cx, get(base).struct, Some(def_id))\n+    mk_t_with_id(cx, get(base).sty, Some(def_id))\n }\n \n // Converts s to its machine type equivalent\n pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n-    match get(t).struct {\n+    match get(t).sty {\n       ty_int(ast::ty_i) => ty_int(cfg.int_type),\n       ty_uint(ast::ty_u) => ty_uint(cfg.uint_type),\n       ty_float(ast::ty_f) => ty_float(cfg.float_type),\n@@ -1079,7 +1079,7 @@ fn walk_ty(ty: t, f: fn(t)) {\n \n fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     if !f(ty) { return; }\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) => {\n@@ -1176,7 +1176,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n \n // Folds types from the bottom up.\n fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n-    let sty = fold_sty(&get(t0).struct, |t| fold_ty(cx, fldop(t), fldop));\n+    let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), fldop));\n     fldop(mk_t(cx, sty))\n }\n \n@@ -1213,7 +1213,7 @@ fn fold_regions_and_ty(\n     }\n \n     let tb = ty::get(ty);\n-    match tb.struct {\n+    match tb.sty {\n       ty::ty_rptr(r, mt) => {\n         let m_r = fldr(r);\n         let m_t = fldt(mt.ty);\n@@ -1288,7 +1288,7 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n                fldop: fn(region, bool) -> region) -> t {\n         let tb = get(t0);\n         if !tbox_has_flag(tb, has_regions) { return t0; }\n-        match tb.struct {\n+        match tb.sty {\n           ty_rptr(r, {ty: t1, mutbl: m}) => {\n             let m_r = fldop(r, under_r);\n             let m_t1 = do_fold(cx, t1, true, fldop);\n@@ -1323,7 +1323,7 @@ fn subst_tps(cx: ctxt, tps: &[t], typ: t) -> t {\n     if tps.len() == 0u { return typ; }\n     let tb = ty::get(typ);\n     if !tbox_has_flag(tb, has_params) { return typ; }\n-    match tb.struct {\n+    match tb.sty {\n       ty_param(p) => tps[p.idx],\n       ref sty => fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, t))\n     }\n@@ -1374,7 +1374,7 @@ fn subst(cx: ctxt,\n                 typ: t) -> t {\n         let tb = get(typ);\n         if !tbox_has_flag(tb, needs_subst) { return typ; }\n-        match tb.struct {\n+        match tb.sty {\n           ty_param(p) => substs.tps[p.idx],\n           ty_self => substs.self_ty.get(),\n           _ => {\n@@ -1393,21 +1393,21 @@ fn subst(cx: ctxt,\n \n // Type utilities\n \n-fn type_is_nil(ty: t) -> bool { get(ty).struct == ty_nil }\n+fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n \n-fn type_is_bot(ty: t) -> bool { get(ty).struct == ty_bot }\n+fn type_is_bot(ty: t) -> bool { get(ty).sty == ty_bot }\n \n fn type_is_ty_var(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_infer(TyVar(_)) => true,\n       _ => false\n     }\n }\n \n-fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n+fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n fn type_is_structural(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_rec(_) | ty_class(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n       ty_trait(*) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n@@ -1422,21 +1422,21 @@ fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_is_sequence(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_estr(_) | ty_evec(_, _) => true,\n       _ => false\n     }\n }\n \n fn type_is_str(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_estr(_) => true,\n       _ => false\n     }\n }\n \n fn sequence_element_type(cx: ctxt, ty: t) -> t {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_estr(_) => return mk_mach_uint(cx, ast::ty_u8),\n       ty_evec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n       _ => cx.sess.bug(\n@@ -1445,66 +1445,66 @@ fn sequence_element_type(cx: ctxt, ty: t) -> t {\n }\n \n fn get_element_type(ty: t, i: uint) -> t {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_rec(flds) => return flds[i].mt.ty,\n       ty_tup(ts) => return ts[i],\n       _ => fail ~\"get_element_type called on invalid type\"\n     }\n }\n \n pure fn type_is_box(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_box(_) => return true,\n       _ => return false\n     }\n }\n \n pure fn type_is_boxed(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_box(_) | ty_opaque_box |\n       ty_evec(_, vstore_box) | ty_estr(vstore_box) => true,\n       _ => false\n     }\n }\n \n pure fn type_is_region_ptr(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_rptr(_, _) => true,\n       _ => false\n     }\n }\n \n pure fn type_is_slice(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_)) => true,\n       _ => return false\n     }\n }\n \n pure fn type_is_unique_box(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_uniq(_) => return true,\n       _ => return false\n     }\n }\n \n pure fn type_is_unsafe_ptr(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n pure fn type_is_vec(ty: t) -> bool {\n-    return match get(ty).struct {\n+    return match get(ty).sty {\n           ty_evec(_, _) | ty_unboxed_vec(_) => true,\n           ty_estr(_) => true,\n           _ => false\n         };\n }\n \n pure fn type_is_unique(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_uniq(_) => return true,\n       ty_evec(_, vstore_uniq) => true,\n       ty_estr(vstore_uniq) => true,\n@@ -1518,7 +1518,7 @@ pure fn type_is_unique(ty: t) -> bool {\n  contents are abstract to rustc.)\n */\n pure fn type_is_scalar(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_type | ty_ptr(_) => true,\n       _ => false\n@@ -1537,7 +1537,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     }\n \n     let mut accum = false;\n-    let result = match get(ty).struct {\n+    let result = match get(ty).sty {\n       // scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) | ty_rptr(_, _) |\n@@ -1620,7 +1620,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     let mut needs_unwind_cleanup = false;\n     do maybe_walk_ty(ty) |ty| {\n         let old_encountered_box = encountered_box;\n-        let result = match get(ty).struct {\n+        let result = match get(ty).sty {\n           ty_box(_) | ty_opaque_box => {\n             encountered_box = true;\n             true\n@@ -1873,7 +1873,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     // Insert a default in case we loop back on self recursively.\n     cx.kind_cache.insert(ty, kind_top());\n \n-    let mut result = match get(ty).struct {\n+    let mut result = match get(ty).sty {\n       // Scalar and unique types are sendable, constant, and owned\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) => {\n@@ -2025,7 +2025,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n /// gives a rough estimate of how much space it takes to represent\n /// an instance of `ty`.  Used for the mode transition.\n fn type_size(cx: ctxt, ty: t) -> uint {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) | ty_box(_) | ty_uniq(_) | ty_estr(vstore_uniq) |\n       ty_trait(*) | ty_rptr(*) | ty_evec(_, vstore_uniq) |\n@@ -2093,7 +2093,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                ty_to_str(cx, ty));\n \n         let r = {\n-            get(r_ty).struct == get(ty).struct ||\n+            get(r_ty).sty == get(ty).sty ||\n                 subtypes_require(cx, seen, r_ty, ty)\n         };\n \n@@ -2110,7 +2110,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                ty_to_str(cx, r_ty),\n                ty_to_str(cx, ty));\n \n-        let r = match get(ty).struct {\n+        let r = match get(ty).sty {\n           ty_nil |\n           ty_bot |\n           ty_bool |\n@@ -2197,7 +2197,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n    bool {\n-    let sty = &get(ty).struct;\n+    let sty = &get(ty).sty;\n     debug!(\"type_structurally_contains: %s\", ty_to_str(cx, ty));\n     if test(sty) { return true; }\n     match *sty {\n@@ -2251,14 +2251,14 @@ fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_is_integral(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_infer(IntVar(_)) | ty_int(_) | ty_uint(_) | ty_bool => true,\n       _ => false\n     }\n }\n \n fn type_is_fp(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_float(_) => true,\n       _ => false\n     }\n@@ -2269,7 +2269,7 @@ fn type_is_numeric(ty: t) -> bool {\n }\n \n fn type_is_signed(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_int(_) => true,\n       _ => false\n     }\n@@ -2279,7 +2279,7 @@ fn type_is_signed(ty: t) -> bool {\n // that the cycle collector might care about.\n fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let mut result = true;\n-    match get(ty).struct {\n+    match get(ty).sty {\n       // Scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) => result = true,\n@@ -2334,7 +2334,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_is_enum(ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_enum(_, _) => return true,\n       _ => return false\n     }\n@@ -2343,7 +2343,7 @@ fn type_is_enum(ty: t) -> bool {\n // Whether a type is enum like, that is a enum type with only nullary\n // constructors\n fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_enum(did, _) => {\n         let variants = enum_variants(cx, did);\n         let some_n_ary = vec::any(*variants, |v| vec::len(v.args) > 0u);\n@@ -2354,7 +2354,7 @@ fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_param(ty: t) -> Option<uint> {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_param(p) => return Some(p.idx),\n       _ => {/* fall through */ }\n     }\n@@ -2366,7 +2366,7 @@ fn type_param(ty: t) -> Option<uint> {\n // The parameter `expl` indicates if this is an *explicit* dereference.  Some\n // types---notably unsafe ptrs---can only be dereferenced explicitly.\n fn deref(cx: ctxt, t: t, expl: bool) -> Option<mt> {\n-    deref_sty(cx, &get(t).struct, expl)\n+    deref_sty(cx, &get(t).sty, expl)\n }\n fn deref_sty(cx: ctxt, sty: &sty, expl: bool) -> Option<mt> {\n     match *sty {\n@@ -2404,7 +2404,7 @@ fn type_autoderef(cx: ctxt, t: t) -> t {\n \n // Returns the type and mutability of t[i]\n fn index(cx: ctxt, t: t) -> Option<mt> {\n-    index_sty(cx, &get(t).struct)\n+    index_sty(cx, &get(t).sty)\n }\n \n fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n@@ -2714,49 +2714,49 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n \n // Type accessors for substructures of types\n fn ty_fn_args(fty: t) -> ~[arg] {\n-    match get(fty).struct {\n+    match get(fty).sty {\n       ty_fn(ref f) => f.sig.inputs,\n       _ => fail ~\"ty_fn_args() called on non-fn type\"\n     }\n }\n \n fn ty_fn_proto(fty: t) -> fn_proto {\n-    match get(fty).struct {\n+    match get(fty).sty {\n       ty_fn(ref f) => f.meta.proto,\n       _ => fail ~\"ty_fn_proto() called on non-fn type\"\n     }\n }\n \n fn ty_fn_purity(fty: t) -> ast::purity {\n-    match get(fty).struct {\n+    match get(fty).sty {\n       ty_fn(ref f) => f.meta.purity,\n       _ => fail ~\"ty_fn_purity() called on non-fn type\"\n     }\n }\n \n pure fn ty_fn_ret(fty: t) -> t {\n-    match get(fty).struct {\n+    match get(fty).sty {\n       ty_fn(ref f) => f.sig.output,\n       _ => fail ~\"ty_fn_ret() called on non-fn type\"\n     }\n }\n \n fn ty_fn_ret_style(fty: t) -> ast::ret_style {\n-    match get(fty).struct {\n+    match get(fty).sty {\n       ty_fn(ref f) => f.meta.ret_style,\n       _ => fail ~\"ty_fn_ret_style() called on non-fn type\"\n     }\n }\n \n fn is_fn_ty(fty: t) -> bool {\n-    match get(fty).struct {\n+    match get(fty).sty {\n       ty_fn(_) => true,\n       _ => false\n     }\n }\n \n fn ty_region(ty: t) -> region {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_rptr(r, _) => r,\n       s => fail fmt!(\"ty_region() invoked on non-rptr: %?\", s)\n     }\n@@ -2775,14 +2775,14 @@ fn is_pred_ty(fty: t) -> bool {\n \n /*\n fn ty_var_id(typ: t) -> TyVid {\n-    match get(typ).struct {\n+    match get(typ).sty {\n       ty_infer(TyVar(vid)) => return vid,\n       _ => { error!(\"ty_var_id called on non-var ty\"); fail; }\n     }\n }\n \n fn int_var_id(typ: t) -> IntVid {\n-    match get(typ).struct {\n+    match get(typ).sty {\n       ty_infer(IntVar(vid)) => return vid,\n       _ => { error!(\"ty_var_integral_id called on ty other than \\\n                   ty_var_integral\");\n@@ -3036,7 +3036,7 @@ fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n }\n \n fn get_fields(rec_ty:t) -> ~[field] {\n-    match get(rec_ty).struct {\n+    match get(rec_ty).sty {\n       ty_rec(fields) => fields,\n       // Can we check at the caller?\n       _ => fail ~\"get_fields: not a record type\"\n@@ -3055,7 +3055,7 @@ fn method_idx(id: ast::ident, meths: &[method]) -> Option<uint> {\n fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     let mut rslt = ~[];\n     do walk_ty(ty) |ty| {\n-        match get(ty).struct {\n+        match get(ty).sty {\n           ty_param(p) => {\n             vec::push(rslt, p);\n           }\n@@ -3072,7 +3072,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n     fn vars_in_type(ty: t) -> ~[TyVid] {\n         let mut rslt = ~[];\n         do walk_ty(ty) |ty| {\n-            match get(ty).struct {\n+            match get(ty).sty {\n               ty_infer(TyVar(v)) => vec::push(rslt, v),\n               _ => ()\n             }\n@@ -3170,7 +3170,7 @@ fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n }\n \n fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n-    match get(t).struct {\n+    match get(t).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) |\n       ty_uint(_) | ty_float(_) | ty_estr(_) |\n       ty_type | ty_opaque_box | ty_opaque_closure_ptr(_) => {\n@@ -3405,7 +3405,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n }\n \n fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n-    match get(ty).struct {\n+    match get(ty).sty {\n       ty_trait(id, _, _) | ty_class(id, _) | ty_enum(id, _) => Some(id),\n       _ => None\n     }\n@@ -3512,7 +3512,7 @@ fn enum_is_univariant(cx: ctxt, id: ast::def_id) -> bool {\n }\n \n fn type_is_empty(cx: ctxt, t: t) -> bool {\n-    match ty::get(t).struct {\n+    match ty::get(t).sty {\n        ty_enum(did, _) => (*enum_variants(cx, did)).is_empty(),\n        _ => false\n      }\n@@ -3816,7 +3816,7 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     }\n \n     fn tycat(ty: t) -> int {\n-        match get(ty).struct {\n+        match get(ty).sty {\n           ty_bool => tycat_bool,\n           ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n           ty_float(_) => tycat_float,\n@@ -3866,7 +3866,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n       None => ()\n     }\n \n-    let t = match get(t).struct {\n+    let t = match get(t).sty {\n         ty_evec(mt, vstore) =>\n             // This type has a vstore. Get rid of it\n             mk_evec(cx, normalize_mt(cx, mt), normalize_vstore(vstore)),\n@@ -3917,7 +3917,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n     // types, which isn't necessary after #2187\n     let t = mk_t(cx, mach_sty(cx.sess.targ_cfg, t));\n \n-    let sty = fold_sty(&get(t).struct, |t| { normalize_ty(cx, t) });\n+    let sty = fold_sty(&get(t).sty, |t| { normalize_ty(cx, t) });\n     let t_norm = mk_t(cx, sty);\n     cx.normalized_cache.insert(t, t_norm);\n     return t_norm;"}, {"sha": "439c005225978f430b1075773f7ab99bab610242", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -261,10 +261,10 @@ fn require_same_types(\n }\n \n fn arg_is_argv_ty(_tcx: ty::ctxt, a: ty::arg) -> bool {\n-    match ty::get(a.ty).struct {\n+    match ty::get(a.ty).sty {\n       ty::ty_evec(mt, vstore_uniq) => {\n         if mt.mutbl != ast::m_imm { return false; }\n-        match ty::get(mt.ty).struct {\n+        match ty::get(mt.ty).sty {\n           ty::ty_estr(vstore_uniq) => return true,\n           _ => return false\n         }\n@@ -279,7 +279,7 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n \n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n-    match ty::get(main_t).struct {\n+    match ty::get(main_t).sty {\n         ty::ty_fn(fn_ty) => {\n             match tcx.items.find(main_id) {\n                 Some(ast_map::node_item(it,_)) => {"}, {"sha": "79033156d35dca071505284ff2ec41e6e4d8f038", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -185,7 +185,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n               Some(ast::def_ty(type_def_id)) => {\n                 let result = ast_path_to_substs_and_ty(self, rscope,\n                                                        type_def_id, path);\n-                match ty::get(result.ty).struct {\n+                match ty::get(result.ty).sty {\n                     ty::ty_trait(trait_def_id, substs, _) => {\n                         if vst != ty::vstore_box {\n                             tcx.sess.span_unimpl(path.span,\n@@ -419,7 +419,7 @@ fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Owned>(\n                                     found: a.mode}))\n           }\n           ast::infer(_) => {\n-            match ty::get(ty).struct {\n+            match ty::get(ty).sty {\n               // If the type is not specified, then this must be a fn expr.\n               // Leave the mode as infer(_), it will get inferred based\n               // on constraints elsewhere."}, {"sha": "de803402a13a3452c513f68b22b04d8d7187f235", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -201,7 +201,7 @@ fn check_bare_fn(ccx: @crate_ctxt,\n                  id: ast::node_id,\n                  self_info: Option<self_info>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n-    match ty::get(fty).struct {\n+    match ty::get(fty).sty {\n         ty::ty_fn(ref fn_ty) => {\n             check_fn(ccx, self_info, fn_ty, decl, body, false, None)\n         }\n@@ -763,7 +763,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n         match sty {\n             ty::ty_box(inner) | ty::ty_uniq(inner) |\n             ty::ty_rptr(_, inner) => {\n-                match ty::get(t1).struct {\n+                match ty::get(t1).sty {\n                     ty::ty_infer(ty::TyVar(v1)) => {\n                         ty::occurs_check(fcx.ccx.tcx, sp, v1,\n                                          ty::mk_box(fcx.ccx.tcx, inner));\n@@ -1127,7 +1127,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n \n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n-        return match (op, ty::get(lhs_t).struct) {\n+        return match (op, ty::get(lhs_t).sty) {\n           (_, _) if ty::type_is_integral(lhs_t) &&\n           ast_util::is_shift_binop(op) => {\n             // Shift is a special case: rhs can be any integral type\n@@ -1191,7 +1191,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // If the or operator is used it might be that the user forgot to\n         // supply the do keyword.  Let's be more helpful in that situation.\n         if op == ast::or {\n-          match ty::get(lhs_resolved_t).struct {\n+          match ty::get(lhs_resolved_t).sty {\n             ty::ty_fn(_) => {\n               tcx.sess.span_note(\n                   ex.span, ~\"did you forget the 'do' keyword for the call?\");\n@@ -1227,7 +1227,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match expected {\n             Some(t) => {\n                 match resolve_type(fcx.infcx(), t, force_tvar) {\n-                    Ok(t) => unpack(ty::get(t).struct),\n+                    Ok(t) => unpack(ty::get(t).sty),\n                     _ => None\n                 }\n             }\n@@ -1500,7 +1500,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           ast::not => {\n             oprnd_t = structurally_resolved_type(fcx, oprnd.span, oprnd_t);\n             if !(ty::type_is_integral(oprnd_t) ||\n-                 ty::get(oprnd_t).struct == ty::ty_bool) {\n+                 ty::get(oprnd_t).sty == ty::ty_bool) {\n                 oprnd_t = check_user_unop(fcx, ~\"!\", ~\"not\", expr,\n                                          oprnd, oprnd_t);\n             }\n@@ -1678,7 +1678,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n-        match ty::get(block_ty).struct {\n+        match ty::get(block_ty).sty {\n           ty::ty_fn(fty) => {\n             fcx.write_ty(expr.id, ty::mk_fn(tcx, FnTyBase {\n                 meta: fty.meta,\n@@ -1714,7 +1714,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n-        match ty::get(block_ty).struct {\n+        match ty::get(block_ty).sty {\n           ty::ty_fn(fty) => {\n             fcx.write_ty(expr.id, ty::mk_fn(tcx, fty));\n           }\n@@ -1742,7 +1742,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         debug!(\"t_1=%s\", fcx.infcx().ty_to_str(t_1));\n         debug!(\"t_e=%s\", fcx.infcx().ty_to_str(t_e));\n \n-        match ty::get(t_1).struct {\n+        match ty::get(t_1).sty {\n           // This will be looked up later on\n           ty::ty_trait(*) => (),\n \n@@ -2461,7 +2461,7 @@ fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n \n // Returns the one-level-deep structure of the given type.\n fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n-    ty::get(structurally_resolved_type(fcx, sp, typ)).struct\n+    ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n@@ -2511,7 +2511,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n         ccx.tcx, ty,\n         |_r| {},\n         |t| {\n-            match ty::get(t).struct {\n+            match ty::get(t).sty {\n               ty::ty_param({idx, _}) => { tps_used[idx] = true; }\n               _ => ()\n             }"}, {"sha": "05c182a81bfed2f18f1a598eaabb16b1b57ec5a9", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -114,7 +114,7 @@ impl lookup {\n         debug!(\"method lookup(m_name=%s, self_ty=%s, %?)\",\n                self.fcx.tcx().sess.str_of(self.m_name),\n                self.fcx.infcx().ty_to_str(self.self_ty),\n-               ty::get(self.self_ty).struct);\n+               ty::get(self.self_ty).sty);\n \n         // Determine if there are any inherent methods we can call.\n         // (An inherent method is one that belongs to no trait, but is\n@@ -155,7 +155,7 @@ impl lookup {\n             // autoderef.\n             // Try each of the possible matching semantics in turn.\n             for matching_modes.each |mode| {\n-                match ty::get(self.self_ty).struct {\n+                match ty::get(self.self_ty).sty {\n                   ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_rptr(_, mt) => {\n                     self.add_candidates_from_type(mt.ty, mode);\n                   }\n@@ -260,7 +260,7 @@ impl lookup {\n     }\n \n     fn add_candidates_from_type(inner_ty: ty::t, mode: method_lookup_mode) {\n-        match ty::get(inner_ty).struct {\n+        match ty::get(inner_ty).sty {\n           // First, see whether this is a bounded parameter.\n           ty::ty_param(p) => {\n             self.add_candidates_from_param(inner_ty, mode, p.idx, p.def_id);\n@@ -304,7 +304,7 @@ impl lookup {\n                 loop; /* ok */\n               }\n               ty::bound_trait(bound_t) => {\n-                match ty::get(bound_t).struct {\n+                match ty::get(bound_t).sty {\n                   ty::ty_trait(i, substs, _) => (i, substs),\n                   _ => fail ~\"add_candidates_from_param: non-trait bound\"\n                 }\n@@ -413,7 +413,7 @@ impl lookup {\n     }\n \n     fn ty_from_did(did: ast::def_id) -> ty::t {\n-        match ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n+        match ty::get(ty::lookup_item_type(self.tcx(), did).ty).sty {\n             ty::ty_fn(ref fty) => {\n                 ty::mk_fn(self.tcx(), FnTyBase {\n                     meta: FnMeta {proto: ty::proto_vstore(ty::vstore_box),\n@@ -434,7 +434,7 @@ impl lookup {\n             }\n         } else {\n             match check ty::get(csearch::get_type(self.tcx(), did).ty)\n-              .struct {\n+              .sty {\n \n               ty::ty_fn(fty) {\n                 ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})"}, {"sha": "17c29b704f5f5c847bcc52697d6bc0516a3c4d29", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -189,7 +189,7 @@ fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n         match rcx.resolve_node_type(e.id) {\n           result::Err(_) => { return; /* typeck will fail anyhow */ }\n           result::Ok(target_ty) => {\n-            match ty::get(target_ty).struct {\n+            match ty::get(target_ty).sty {\n               ty::ty_trait(_, substs, _) => {\n                 let trait_region = match substs.self_r {\n                   Some(r) => {r}\n@@ -215,7 +215,7 @@ fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n         match rcx.resolve_node_type(e.id) {\n           result::Err(_) => return,   // Typechecking will fail anyhow.\n           result::Ok(function_type) => {\n-            match ty::get(function_type).struct {\n+            match ty::get(function_type).sty {\n               ty::ty_fn(ref fn_ty) => {\n                   match fn_ty.meta.proto {\n                       proto_vstore(vstore_slice(region)) => {"}, {"sha": "288baec27b53ec347aa6d6cb1cf542668ef6a2bf", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -66,7 +66,7 @@ fn replace_bound_regions_in_fn_ty(\n \n     return {isr: isr,\n          self_info: new_self_info,\n-         fn_ty: match ty::get(t_fn).struct { ty::ty_fn(o) => o,\n+         fn_ty: match ty::get(t_fn).sty { ty::ty_fn(o) => o,\n           _ => tcx.sess.bug(~\"replace_bound_regions_in_fn_ty: impossible\")}};\n \n "}, {"sha": "276b7eef57831bb2732c84eb674f1b60eb8c09e0", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -69,7 +69,7 @@ fn fixup_substs(fcx: @fn_ctxt, expr: @ast::expr,\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n     do fixup_ty(fcx, expr, t, is_early).map |t_f| {\n-        match ty::get(t_f).struct {\n+        match ty::get(t_f).sty {\n           ty::ty_trait(_, substs_f, _) => substs_f,\n           _ => fail ~\"t_f should be a trait\"\n         }\n@@ -99,7 +99,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n-    let (trait_id, trait_substs) = match ty::get(trait_ty).struct {\n+    let (trait_id, trait_substs) = match ty::get(trait_ty).sty {\n         ty::ty_trait(did, substs, _) => (did, substs),\n         _ => tcx.sess.impossible_case(expr.span,\n                                       \"lookup_vtable: \\\n@@ -117,7 +117,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n         }\n     };\n \n-    match ty::get(ty).struct {\n+    match ty::get(ty).sty {\n         ty::ty_param({idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n             for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n@@ -127,7 +127,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                         /* ignore */\n                     }\n                     ty::bound_trait(ity) => {\n-                        match ty::get(ity).struct {\n+                        match ty::get(ity).sty {\n                             ty::ty_trait(idid, _, _) => {\n                                 if trait_id == idid {\n                                     debug!(\"(checking vtable) @0 relating \\\n@@ -214,7 +214,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                         // unify it with trait_ty in order to get all\n                         // the ty vars sorted out.\n                         for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n-                            match ty::get(of_ty).struct {\n+                            match ty::get(of_ty).sty {\n                                 ty::ty_trait(id, _, _) => {\n                                     // Not the trait we're looking for\n                                     if id != trait_id { loop; }\n@@ -389,8 +389,8 @@ fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n     let ity = ty::impl_traits(tcx, impl_did)[0];\n     let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n     debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n-           ty::get(trait_ty).struct, impl_did);\n-    match ty::get(trait_ty).struct {\n+           ty::get(trait_ty).sty, impl_did);\n+    match ty::get(trait_ty).sty {\n      ty::ty_trait(_, substs, _) => {\n         vec::iter2(substs.tps, trait_tys,\n                    |a, b| demand::suptype(fcx, expr.span, a, b));\n@@ -450,7 +450,7 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n       }\n       ast::expr_cast(src, _) => {\n         let target_ty = fcx.expr_ty(ex);\n-        match ty::get(target_ty).struct {\n+        match ty::get(target_ty).sty {\n           ty::ty_trait(*) => {\n             /*\n             Look up vtables for the type we're casting to,"}, {"sha": "1e3e8a3fc1448207012c20697a22f5a6debf8e1b", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -55,7 +55,7 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n         }\n     }\n \n-    match get(resolved_type).struct {\n+    match get(resolved_type).sty {\n         ty_box(base_mutability_and_type) |\n         ty_uniq(base_mutability_and_type) |\n         ty_ptr(base_mutability_and_type) |\n@@ -76,7 +76,7 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n         ty_param(*) | ty_self | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) => {\n             debug!(\"(getting base type) no base type; found %?\",\n-                   get(original_type).struct);\n+                   get(original_type).sty);\n             None\n         }\n     }\n@@ -93,7 +93,7 @@ fn get_base_type_def_id(inference_context: infer_ctxt,\n             return None;\n         }\n         Some(base_type) => {\n-            match get(base_type).struct {\n+            match get(base_type).sty {\n                 ty_enum(def_id, _) |\n                 ty_class(def_id, _) |\n                 ty_trait(def_id, _, _) => {\n@@ -694,7 +694,7 @@ impl CoherenceChecker {\n \n             // Record all the trait methods.\n             for associated_traits.each |trait_type| {\n-                match get(trait_type).struct {\n+                match get(trait_type).sty {\n                     ty_trait(trait_id, _, _) => {\n                         self.add_trait_method(trait_id, implementation);\n                     }"}, {"sha": "cf8ed6315ca38dd2454b328b5c020f8d2a61e9d1", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -603,7 +603,7 @@ fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n       ast::def_ty(t_id) => {\n         let tpt = astconv::ast_path_to_ty(ccx, rscope, t_id, t.path,\n                                           t.ref_id);\n-        match ty::get(tpt.ty).struct {\n+        match ty::get(tpt.ty).sty {\n            ty::ty_trait(*) => {\n               (t_id, tpt)\n            }\n@@ -732,7 +732,7 @@ fn compute_bounds(ccx: @crate_ctxt,\n           ast::bound_owned => ~[ty::bound_owned],\n           ast::bound_trait(t) => {\n             let ity = ast_ty_to_ty(ccx, empty_rscope, t);\n-            match ty::get(ity).struct {\n+            match ty::get(ity).sty {\n               ty::ty_trait(*) => {\n                 ~[ty::bound_trait(ity)]\n               }"}, {"sha": "fdb23c90b10bc72eb23462cf8aba3c4c3559e71d", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -70,7 +70,7 @@ impl Assign {\n                b.to_str(self.infcx));\n         let _r = indenter();\n \n-        match (ty::get(a).struct, ty::get(b).struct) {\n+        match (ty::get(a).sty, ty::get(b).sty) {\n             (ty::ty_bot, _) => {\n                 Ok(None)\n             }\n@@ -130,7 +130,7 @@ priv impl Assign {\n             (Some(a_bnd), Some(b_bnd)) => {\n                 // check for a case where a non-region pointer (@, ~) is\n                 // being assigned to a region pointer:\n-                match (ty::get(a_bnd).struct, ty::get(b_bnd).struct) {\n+                match (ty::get(a_bnd).sty, ty::get(b_bnd).sty) {\n                     (ty::ty_box(_), ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_box(self.infcx.tcx,\n                                               {ty: mt_b.ty, mutbl: m_const});"}, {"sha": "84791b59b329f0160ff9858aebebb9313a88a7ca", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -354,7 +354,7 @@ fn super_tys<C:combine>(\n     self: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     let tcx = self.infcx().tcx;\n-    match (ty::get(a).struct, ty::get(b).struct) {\n+    match (ty::get(a).sty, ty::get(b).sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (ty::ty_bot, _) |\n       (_, ty::ty_bot) |\n@@ -383,8 +383,8 @@ fn super_tys<C:combine>(\n       (ty::ty_int(_), _) |\n       (ty::ty_uint(_), _) |\n       (ty::ty_float(_), _) => {\n-        let as_ = ty::get(a).struct;\n-        let bs = ty::get(b).struct;\n+        let as_ = ty::get(a).sty;\n+        let bs = ty::get(b).sty;\n         if as_ == bs {\n             Ok(a)\n         } else {"}, {"sha": "168709596dc4361d1829d3ca712563567421c2ef", "filename": "src/rustc/middle/typeck/infer/integral.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -55,7 +55,7 @@ fn single_type_contained_in(tcx: ty::ctxt, a: int_ty_set) ->\n fn convert_integral_ty_to_int_ty_set(tcx: ty::ctxt, t: ty::t)\n     -> int_ty_set {\n \n-    match get(t).struct {\n+    match get(t).sty {\n       ty_int(int_ty) => match int_ty {\n         ast::ty_i8   => int_ty_set(INT_TY_SET_i8),\n         ast::ty_i16  => int_ty_set(INT_TY_SET_i16),"}, {"sha": "04133cab9d76cfcd13a1bfe6e8d275de53949c99", "filename": "src/rustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -42,7 +42,7 @@ fn lattice_tys<L:lattice_ops combine>(\n            b.to_str(self.infcx()));\n     if a == b { return Ok(a); }\n     do indent {\n-        match (ty::get(a).struct, ty::get(b).struct) {\n+        match (ty::get(a).sty, ty::get(b).sty) {\n           (ty::ty_bot, _) => self.ty_bot(b),\n           (_, ty::ty_bot) => self.ty_bot(a),\n "}, {"sha": "5d748efc332d61c2c3e76609dc47e8e975efd070", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -112,7 +112,7 @@ impl resolve_state {\n         indent(fn&() -> ty::t {\n             if !ty::type_needs_infer(typ) { return typ; }\n \n-            match ty::get(typ).struct {\n+            match ty::get(typ).sty {\n               ty::ty_infer(TyVar(vid)) => {\n                 self.resolve_ty_var(vid)\n               }"}, {"sha": "359b8eea74169349bad9a29d2bf810da242aa8f6", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -101,7 +101,7 @@ impl Sub: combine {\n                a.to_str(self.infcx), b.to_str(self.infcx));\n         if a == b { return Ok(a); }\n         do indent {\n-            match (ty::get(a).struct, ty::get(b).struct) {\n+            match (ty::get(a).sty, ty::get(b).sty) {\n               (ty::ty_bot, _) => {\n                 Ok(a)\n               }"}, {"sha": "a9363f0f1dabace9962548e89f2193d3f7789ac6", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -284,7 +284,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         for inputs.each |a| { vec::push(strs, fn_input_to_str(cx, a)); }\n         s += str::connect(strs, ~\", \");\n         s += ~\")\";\n-        if ty::get(output).struct != ty_nil {\n+        if ty::get(output).sty != ty_nil {\n             s += ~\" -> \";\n             match cf {\n               ast::noreturn => { s += ~\"!\"; }\n@@ -310,7 +310,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n \n     // pretty print the structural type representation:\n-    return match ty::get(typ).struct {\n+    return match ty::get(typ).sty {\n       ty_nil => ~\"()\",\n       ty_bot => ~\"_|_\",\n       ty_bool => ~\"bool\","}, {"sha": "486321e155c190134dba92b6fdeb0cb082f3c3ac", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cc0a36b689bcbc58117450330f6fa4ebd35c9b/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=27cc0a36b689bcbc58117450330f6fa4ebd35c9b", "patch": "@@ -6,10 +6,10 @@ use option::None;\n \n enum sty { ty_nil, }\n \n-type raw_t = {struct: sty, cname: Option<~str>, hash: uint};\n+type raw_t = {struct_: sty, cname: Option<~str>, hash: uint};\n \n fn mk_raw_ty(st: sty, cname: Option<~str>) -> raw_t {\n-    return {struct: st, cname: cname, hash: 0u};\n+    return {struct_: st, cname: cname, hash: 0u};\n }\n \n fn main() { mk_raw_ty(ty_nil, None::<~str>); }"}]}