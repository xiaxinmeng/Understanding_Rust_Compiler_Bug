{"sha": "b369c8ecbde710ab23977137c71b3c974a94d445", "node_id": "C_kwDOAAsO6NoAKGIzNjljOGVjYmRlNzEwYWIyMzk3NzEzN2M3MWIzYzk3NGE5NGQ0NDU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-10T06:06:01Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-10T06:06:08Z"}, "message": "Do not use ImplDerivedObligationCause for inherent impl method error reporting", "tree": {"sha": "cc0f62d50045c2b7c7f1f8ad259a9cf2d970a90a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc0f62d50045c2b7c7f1f8ad259a9cf2d970a90a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b369c8ecbde710ab23977137c71b3c974a94d445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b369c8ecbde710ab23977137c71b3c974a94d445", "html_url": "https://github.com/rust-lang/rust/commit/b369c8ecbde710ab23977137c71b3c974a94d445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b369c8ecbde710ab23977137c71b3c974a94d445/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39bf7777aab9ac1f6b0802cd52cd91d6e021aa91", "url": "https://api.github.com/repos/rust-lang/rust/commits/39bf7777aab9ac1f6b0802cd52cd91d6e021aa91", "html_url": "https://github.com/rust-lang/rust/commit/39bf7777aab9ac1f6b0802cd52cd91d6e021aa91"}], "stats": {"total": 159, "additions": 124, "deletions": 35}, "files": [{"sha": "badb1a3c1882de41127625a20ea30d19f16ea8d4", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b369c8ecbde710ab23977137c71b3c974a94d445/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b369c8ecbde710ab23977137c71b3c974a94d445/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=b369c8ecbde710ab23977137c71b3c974a94d445", "patch": "@@ -1522,23 +1522,18 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations = traits::predicates_for_generics(\n-                        |_idx, span| {\n-                            let misc = traits::ObligationCause::misc(span, self.body_id);\n-                            let parent_trait_pred = ty::Binder::dummy(ty::TraitPredicate {\n-                                trait_ref: ty::TraitRef::from_method(self.tcx, impl_def_id, substs),\n-                                constness: ty::BoundConstness::NotConst,\n-                                polarity: ty::ImplPolarity::Positive,\n-                            });\n-                            misc.derived_cause(parent_trait_pred, |derived| {\n-                                traits::ImplDerivedObligation(Box::new(\n-                                    traits::ImplDerivedObligationCause {\n-                                        derived,\n-                                        impl_or_alias_def_id: impl_def_id,\n-                                        impl_def_predicate_index: None,\n-                                        span,\n-                                    },\n-                                ))\n-                            })\n+                        |idx, span| {\n+                            let code = if span.is_dummy() {\n+                                traits::ExprItemObligation(impl_def_id, self.scope_expr_id, idx)\n+                            } else {\n+                                traits::ExprBindingObligation(\n+                                    impl_def_id,\n+                                    span,\n+                                    self.scope_expr_id,\n+                                    idx,\n+                                )\n+                            };\n+                            ObligationCause::new(self.span, self.body_id, code)\n                         },\n                         self.param_env,\n                         impl_bounds,"}, {"sha": "6e77c7281074fcb769575f07aeaf135d123d773b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b369c8ecbde710ab23977137c71b3c974a94d445/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b369c8ecbde710ab23977137c71b3c974a94d445/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=b369c8ecbde710ab23977137c71b3c974a94d445", "patch": "@@ -661,19 +661,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Find all the requirements that come from a local `impl` block.\n             let mut skip_list: FxHashSet<_> = Default::default();\n             let mut spanned_predicates = FxHashMap::default();\n-            for (p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n-                .iter()\n-                .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n-                .filter_map(|(p, parent, c)| match c.code() {\n-                    ObligationCauseCode::ImplDerivedObligation(data)\n-                        if matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) =>\n-                    {\n-                        Some((p, parent, data.impl_or_alias_def_id, data))\n+            for (p, parent_p, cause) in unsatisfied_predicates {\n+                // Extract the predicate span and parent def id of the cause,\n+                // if we have one.\n+                let (item_def_id, cause_span) = match cause.as_ref().map(|cause| cause.code()) {\n+                    Some(ObligationCauseCode::ImplDerivedObligation(data)) => {\n+                        (data.impl_or_alias_def_id, data.span)\n                     }\n-                    _ => None,\n-                })\n-            {\n-                match self.tcx.hir().get_if_local(impl_def_id) {\n+                    Some(\n+                        ObligationCauseCode::ExprBindingObligation(def_id, span, _, _)\n+                        | ObligationCauseCode::BindingObligation(def_id, span),\n+                    ) => (*def_id, *span),\n+                    _ => continue,\n+                };\n+\n+                // Don't point out the span of `WellFormed` predicates.\n+                if !matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) {\n+                    continue;\n+                };\n+\n+                match self.tcx.hir().get_if_local(item_def_id) {\n                     // Unmet obligation comes from a `derive` macro, point at it once to\n                     // avoid multiple span labels pointing at the same place.\n                     Some(Node::Item(hir::Item {\n@@ -718,7 +725,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 }\n                             });\n                         for param in generics.params {\n-                            if param.span == cause.span && sized_pred {\n+                            if param.span == cause_span && sized_pred {\n                                 let (sp, sugg) = match param.colon_span {\n                                     Some(sp) => (sp.shrink_to_hi(), \" ?Sized +\"),\n                                     None => (param.span.shrink_to_hi(), \": ?Sized\"),\n@@ -741,9 +748,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             (FxHashSet::default(), FxHashSet::default(), Vec::new())\n                         });\n                         entry.2.push(p);\n-                        if cause.span != *item_span {\n-                            entry.0.insert(cause.span);\n-                            entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n+                        if cause_span != *item_span {\n+                            entry.0.insert(cause_span);\n+                            entry.1.insert((cause_span, \"unsatisfied trait bound introduced here\"));\n                         } else {\n                             if let Some(trait_ref) = of_trait {\n                                 entry.0.insert(trait_ref.path.span);\n@@ -775,9 +782,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let entry = entry.or_insert_with(|| {\n                             (FxHashSet::default(), FxHashSet::default(), Vec::new())\n                         });\n-                        entry.0.insert(cause.span);\n+                        entry.0.insert(cause_span);\n                         entry.1.insert((ident.span, \"\"));\n-                        entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n+                        entry.1.insert((cause_span, \"unsatisfied trait bound introduced here\"));\n                         entry.2.push(p);\n                     }\n                     Some(node) => unreachable!(\"encountered `{node:?}`\"),"}, {"sha": "81a99ca010e5d2e33f677fc0e0a5b305d102fd23", "filename": "tests/ui/methods/inherent-bound-in-probe.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b369c8ecbde710ab23977137c71b3c974a94d445/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b369c8ecbde710ab23977137c71b3c974a94d445/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.rs?ref=b369c8ecbde710ab23977137c71b3c974a94d445", "patch": "@@ -0,0 +1,49 @@\n+// normalize-stderr-test: \"long-type-\\d+\" -> \"long-type-hash\"\n+\n+// Fixes #110131\n+//\n+// The issue is that we were constructing an `ImplDerived` cause code for the\n+// `&'a T: IntoIterator<Item = &'a u8>` obligation for `Helper::new`, which is\n+// incorrect because derived obligations are only expected to come from *traits*.\n+\n+struct SeqBuffer<'a, T>\n+where\n+    &'a T: IntoIterator<Item = &'a u8>,\n+{\n+    iter: <&'a T as IntoIterator>::IntoIter,\n+}\n+\n+struct Helper<'a, T>\n+where\n+    &'a T: IntoIterator<Item = &'a u8>,\n+{\n+    buf: SeqBuffer<'a, T>,\n+}\n+\n+impl<'a, T> Helper<'a, T>\n+where\n+    &'a T: IntoIterator<Item = &'a u8>,\n+{\n+    fn new(sq: &'a T) -> Self {\n+        loop {}\n+    }\n+}\n+\n+struct BitReaderWrapper<T>(T);\n+\n+impl<'a, T> IntoIterator for &'a BitReaderWrapper<T>\n+where\n+    &'a T: IntoIterator<Item = &'a u8>,\n+{\n+    type Item = u32;\n+\n+    type IntoIter = Helper<'a, T>;\n+    //~^ ERROR `Helper<'a, T>` is not an iterator\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        Helper::new(&self.0)\n+        //~^ ERROR overflow evaluating the requirement `&_: IntoIterator`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ff03a7edb05425642d3e4958510501b5fa2607ea", "filename": "tests/ui/methods/inherent-bound-in-probe.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b369c8ecbde710ab23977137c71b3c974a94d445/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b369c8ecbde710ab23977137c71b3c974a94d445/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Finherent-bound-in-probe.stderr?ref=b369c8ecbde710ab23977137c71b3c974a94d445", "patch": "@@ -0,0 +1,38 @@\n+error[E0277]: `Helper<'a, T>` is not an iterator\n+  --> $DIR/inherent-bound-in-probe.rs:40:21\n+   |\n+LL |     type IntoIter = Helper<'a, T>;\n+   |                     ^^^^^^^^^^^^^ `Helper<'a, T>` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `Helper<'a, T>`\n+note: required by a bound in `std::iter::IntoIterator::IntoIter`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+\n+error[E0275]: overflow evaluating the requirement `&_: IntoIterator`\n+  --> $DIR/inherent-bound-in-probe.rs:44:17\n+   |\n+LL |         Helper::new(&self.0)\n+   |                 ^^^\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`inherent_bound_in_probe`)\n+note: required for `&BitReaderWrapper<_>` to implement `IntoIterator`\n+  --> $DIR/inherent-bound-in-probe.rs:34:13\n+   |\n+LL | impl<'a, T> IntoIterator for &'a BitReaderWrapper<T>\n+   |             ^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL | where\n+LL |     &'a T: IntoIterator<Item = &'a u8>,\n+   |                         ------------- unsatisfied trait bound introduced here\n+   = note: 126 redundant requirements hidden\n+   = note: required for `&BitReaderWrapper<BitReaderWrapper<BitReaderWrapper<BitReaderWrapper<BitReaderWrapper<...>>>>>` to implement `IntoIterator`\n+   = note: the full type name has been written to '$TEST_BUILD_DIR/methods/inherent-bound-in-probe/inherent-bound-in-probe.long-type-hash.txt'\n+note: required by a bound in `Helper<'a, T>`\n+  --> $DIR/inherent-bound-in-probe.rs:25:25\n+   |\n+LL |     &'a T: IntoIterator<Item = &'a u8>,\n+   |                         ^^^^^^^^^^^^^ required by this bound in `Helper<'a, T>`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0275, E0277.\n+For more information about an error, try `rustc --explain E0275`."}]}