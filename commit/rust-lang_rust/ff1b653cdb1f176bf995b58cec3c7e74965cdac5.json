{"sha": "ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "node_id": "C_kwDOAAsO6NoAKGZmMWI2NTNjZGIxZjE3NmJmOTk1YjU4Y2VjM2M3ZTc0OTY1Y2RhYzU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-17T05:08:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-17T05:08:13Z"}, "message": "Rollup merge of #92808 - compiler-errors:wrap-struct-shorthand-field-in-variant, r=davidtwco\n\nFix `try wrapping expression in variant` suggestion with struct field shorthand\n\nFixes a broken suggestion: [playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=83fe2dbfe1485f8cfca1aef2a6582e77)\n\nbefore:\n```\nerror[E0308]: mismatched types\n --> src/main.rs:7:19\n  |\n7 |     let x = Foo { bar };\n  |                   ^^^ expected enum `Option`, found integer\n  |\n  = note: expected enum `Option<i32>`\n             found type `{integer}`\nhelp: try wrapping the expression in `Some`\n  |\n7 |     let x = Foo { Some(bar) };\n  |                   +++++   +\n```\n\nafter:\n```\nerror[E0308]: mismatched types\n --> src/main.rs:7:19\n  |\n7 |     let x = Foo { bar };\n  |                   ^^^ expected enum `Option`, found integer\n  |\n  = note: expected enum `Option<i32>`\n             found type `{integer}`\nhelp: try wrapping the expression in `Some`\n  |\n7 |     let x = Foo { bar: Some(bar) };\n  |                   ~~~~~~~~~~~~~~\n```\n\nr? ``@m-ou-se``\nsince you touched the code last in #91080", "tree": {"sha": "50b250aa1fb28a9b693cdbc521baa3a8b1e14f35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50b250aa1fb28a9b693cdbc521baa3a8b1e14f35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh5Pm9CRBK7hj4Ov3rIwAANW4IACJzpD78BiaHenN2Q/euoqoj\nhsKJF/XiEKO41mQUm+8ffABX8Xw8cUnP12w2Y8VSFFR66OTdMV4qbyx2X1t9JnWq\nRY2gFs1CjEB5nHhmBqLH3Ax15f2VVV11esswSOAY3weVLR84+ZfwhFcmC1ma1ix/\nGOaeYAQ0Hm9BbCpO06k6sRqTOd1aT5BnckVyNMPhpsPSK+8YWLGr3Wjax5YCRGAc\nx32eUWpApgQU2nGwTr0jDCKcNaZEXsjL3D7pHQl9uN7zCTa+SHmz1WZkHfqsEivs\nkt22ri3lFP7DamNhyva+34V34WV83umGHI11SYUvkFWQLHnWaQLip5CcQvW2pFY=\n=Jv9G\n-----END PGP SIGNATURE-----\n", "payload": "tree 50b250aa1fb28a9b693cdbc521baa3a8b1e14f35\nparent 3de7276689fd7ff443218fa479de4984acebead6\nparent 272fb2395c0867e2ab8aa8cdb141b616d1e52c62\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642396093 +0100\ncommitter GitHub <noreply@github.com> 1642396093 +0100\n\nRollup merge of #92808 - compiler-errors:wrap-struct-shorthand-field-in-variant, r=davidtwco\n\nFix `try wrapping expression in variant` suggestion with struct field shorthand\n\nFixes a broken suggestion: [playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=83fe2dbfe1485f8cfca1aef2a6582e77)\n\nbefore:\n```\nerror[E0308]: mismatched types\n --> src/main.rs:7:19\n  |\n7 |     let x = Foo { bar };\n  |                   ^^^ expected enum `Option`, found integer\n  |\n  = note: expected enum `Option<i32>`\n             found type `{integer}`\nhelp: try wrapping the expression in `Some`\n  |\n7 |     let x = Foo { Some(bar) };\n  |                   +++++   +\n```\n\nafter:\n```\nerror[E0308]: mismatched types\n --> src/main.rs:7:19\n  |\n7 |     let x = Foo { bar };\n  |                   ^^^ expected enum `Option`, found integer\n  |\n  = note: expected enum `Option<i32>`\n             found type `{integer}`\nhelp: try wrapping the expression in `Some`\n  |\n7 |     let x = Foo { bar: Some(bar) };\n  |                   ~~~~~~~~~~~~~~\n```\n\nr? ``@m-ou-se``\nsince you touched the code last in #91080\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "html_url": "https://github.com/rust-lang/rust/commit/ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3de7276689fd7ff443218fa479de4984acebead6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3de7276689fd7ff443218fa479de4984acebead6", "html_url": "https://github.com/rust-lang/rust/commit/3de7276689fd7ff443218fa479de4984acebead6"}, {"sha": "272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "url": "https://api.github.com/repos/rust-lang/rust/commits/272fb2395c0867e2ab8aa8cdb141b616d1e52c62", "html_url": "https://github.com/rust-lang/rust/commit/272fb2395c0867e2ab8aa8cdb141b616d1e52c62"}], "stats": {"total": 229, "additions": 135, "deletions": 94}, "files": [{"sha": "241dcbc64a676bb35fe307dec5c4ceee2f73784c", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 102, "deletions": 82, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n \n use super::method::probe;\n@@ -24,7 +24,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn demand_coerce(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// will be permitted if the diverges flag is currently \"always\".\n     pub fn demand_coerce_diag(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -338,31 +338,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 })\n                 .collect();\n \n-            if let [variant] = &compatible_variants[..] {\n-                // Just a single matching variant.\n-                err.multipart_suggestion(\n-                    &format!(\"try wrapping the expression in `{}`\", variant),\n-                    vec![\n-                        (expr.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                        (expr.span.shrink_to_hi(), \")\".to_string()),\n-                    ],\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else if compatible_variants.len() > 1 {\n-                // More than one matching variant.\n-                err.multipart_suggestions(\n-                    &format!(\n-                        \"try wrapping the expression in a variant of `{}`\",\n-                        self.tcx.def_path_str(expected_adt.did)\n-                    ),\n-                    compatible_variants.into_iter().map(|variant| {\n+            let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                Some(ident) => format!(\"{}: \", ident),\n+                None => format!(\"\"),\n+            };\n+\n+            match &compatible_variants[..] {\n+                [] => { /* No variants to format */ }\n+                [variant] => {\n+                    // Just a single matching variant.\n+                    err.multipart_suggestion_verbose(\n+                        &format!(\"try wrapping the expression in `{}`\", variant),\n                         vec![\n-                            (expr.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                            (expr.span.shrink_to_lo(), format!(\"{}{}(\", prefix, variant)),\n                             (expr.span.shrink_to_hi(), \")\".to_string()),\n-                        ]\n-                    }),\n-                    Applicability::MaybeIncorrect,\n-                );\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {\n+                    // More than one matching variant.\n+                    err.multipart_suggestions(\n+                        &format!(\n+                            \"try wrapping the expression in a variant of `{}`\",\n+                            self.tcx.def_path_str(expected_adt.did)\n+                        ),\n+                        compatible_variants.into_iter().map(|variant| {\n+                            vec![\n+                                (expr.span.shrink_to_lo(), format!(\"{}{}(\", prefix, variant)),\n+                                (expr.span.shrink_to_hi(), \")\".to_string()),\n+                            ]\n+                        }),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             }\n         }\n     }\n@@ -483,33 +492,45 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn is_hir_id_from_struct_pattern_shorthand_field(\n+    crate fn maybe_get_struct_pattern_shorthand_field(\n         &self,\n-        hir_id: hir::HirId,\n-        sp: Span,\n-    ) -> bool {\n-        let sm = self.sess().source_map();\n-        let parent_id = self.tcx.hir().get_parent_node(hir_id);\n-        if let Some(parent) = self.tcx.hir().find(parent_id) {\n-            // Account for fields\n-            if let Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) = parent\n-            {\n-                if let Ok(src) = sm.span_to_snippet(sp) {\n-                    for field in *fields {\n-                        if field.ident.as_str() == src && field.is_shorthand {\n-                            return true;\n-                        }\n+        expr: &hir::Expr<'_>,\n+    ) -> Option<Symbol> {\n+        let hir = self.tcx.hir();\n+        let local = match expr {\n+            hir::Expr {\n+                kind:\n+                    hir::ExprKind::Path(hir::QPath::Resolved(\n+                        None,\n+                        hir::Path {\n+                            res: hir::def::Res::Local(_),\n+                            segments: [hir::PathSegment { ident, .. }],\n+                            ..\n+                        },\n+                    )),\n+                ..\n+            } => Some(ident),\n+            _ => None,\n+        }?;\n+\n+        match hir.find(hir.get_parent_node(expr.hir_id))? {\n+            Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) => {\n+                for field in *fields {\n+                    if field.ident.name == local.name && field.is_shorthand {\n+                        return Some(local.name);\n                     }\n                 }\n             }\n+            _ => {}\n         }\n-        false\n+\n+        None\n     }\n \n     /// If the given `HirId` corresponds to a block with a trailing expression, return that expression\n-    crate fn maybe_get_block_expr(&self, hir_id: hir::HirId) -> Option<&'tcx hir::Expr<'tcx>> {\n-        match self.tcx.hir().find(hir_id)? {\n-            Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, ..), .. }) => block.expr,\n+    crate fn maybe_get_block_expr(&self, expr: &hir::Expr<'tcx>) -> Option<&'tcx hir::Expr<'tcx>> {\n+        match expr {\n+            hir::Expr { kind: hir::ExprKind::Block(block, ..), .. } => block.expr,\n             _ => None,\n         }\n     }\n@@ -547,7 +568,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// `&mut`!\".\n     pub fn check_ref(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Option<(Span, &'static str, String, Applicability, bool /* verbose */)> {\n@@ -565,9 +586,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             s.strip_prefix(old).map(|stripped| new.to_string() + stripped)\n         };\n \n-        let is_struct_pat_shorthand_field =\n-            self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, sp);\n-\n         // `ExprKind::DropTemps` is semantically irrelevant for these suggestions.\n         let expr = expr.peel_drop_temps();\n \n@@ -661,11 +679,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 false,\n                             ));\n                         }\n-                        let field_name = if is_struct_pat_shorthand_field {\n-                            format!(\"{}: \", sugg_expr)\n-                        } else {\n-                            String::new()\n+\n+                        let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                            Some(ident) => format!(\"{}: \", ident),\n+                            None => format!(\"\"),\n                         };\n+\n                         if let Some(hir::Node::Expr(hir::Expr {\n                             kind: hir::ExprKind::Assign(left_expr, ..),\n                             ..\n@@ -695,14 +714,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             hir::Mutability::Mut => (\n                                 sp,\n                                 \"consider mutably borrowing here\",\n-                                format!(\"{}&mut {}\", field_name, sugg_expr),\n+                                format!(\"{}&mut {}\", prefix, sugg_expr),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\",\n-                                format!(\"{}&{}\", field_name, sugg_expr),\n+                                format!(\"{}&{}\", prefix, sugg_expr),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n@@ -846,32 +865,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n                             || checked_ty.is_box()\n                         {\n-                            if let Ok(code) = sm.span_to_snippet(expr.span) {\n-                                let message = if checked_ty.is_box() {\n-                                    \"consider unboxing the value\"\n-                                } else if checked_ty.is_region_ptr() {\n-                                    \"consider dereferencing the borrow\"\n-                                } else {\n-                                    \"consider dereferencing the type\"\n-                                };\n-                                let (span, suggestion) = if is_struct_pat_shorthand_field {\n-                                    (expr.span, format!(\"{}: *{}\", code, code))\n-                                } else if self.is_else_if_block(expr) {\n-                                    // Don't suggest nonsense like `else *if`\n-                                    return None;\n-                                } else if let Some(expr) = self.maybe_get_block_expr(expr.hir_id) {\n-                                    (expr.span.shrink_to_lo(), \"*\".to_string())\n-                                } else {\n-                                    (expr.span.shrink_to_lo(), \"*\".to_string())\n-                                };\n-                                return Some((\n-                                    span,\n-                                    message,\n-                                    suggestion,\n-                                    Applicability::MachineApplicable,\n-                                    true,\n-                                ));\n-                            }\n+                            let message = if checked_ty.is_box() {\n+                                \"consider unboxing the value\"\n+                            } else if checked_ty.is_region_ptr() {\n+                                \"consider dereferencing the borrow\"\n+                            } else {\n+                                \"consider dereferencing the type\"\n+                            };\n+                            let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                                Some(ident) => format!(\"{}: \", ident),\n+                                None => format!(\"\"),\n+                            };\n+                            let (span, suggestion) = if self.is_else_if_block(expr) {\n+                                // Don't suggest nonsense like `else *if`\n+                                return None;\n+                            } else if let Some(expr) = self.maybe_get_block_expr(expr) {\n+                                // prefix should be empty here..\n+                                (expr.span.shrink_to_lo(), \"*\".to_string())\n+                            } else {\n+                                (expr.span.shrink_to_lo(), format!(\"{}*\", prefix))\n+                            };\n+                            return Some((\n+                                span,\n+                                message,\n+                                suggestion,\n+                                Applicability::MachineApplicable,\n+                                true,\n+                            ));\n                         }\n                     }\n                 }"}, {"sha": "473c848ad8f13eef6272278cd00d12bc9a362c36", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn suggest_deref_ref_or_into(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let is_struct_pat_shorthand_field =\n-                self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n+                self.maybe_get_struct_pattern_shorthand_field(expr).is_some();\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if !methods.is_empty() {\n                 if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {"}, {"sha": "a70dda8386f087ef1ab460614255b8780035228a", "filename": "src/test/ui/did_you_mean/compatible-variants.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs?ref=ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "patch": "@@ -3,6 +3,10 @@ enum Hey<A, B> {\n     B(B),\n }\n \n+struct Foo {\n+    bar: Option<i32>,\n+}\n+\n fn f() {}\n \n fn a() -> Option<()> {\n@@ -40,4 +44,8 @@ fn main() {\n     let _: Hey<i32, bool> = false;\n     //~^ ERROR mismatched types\n     //~| HELP try wrapping\n+    let bar = 1i32;\n+    let _ = Foo { bar };\n+    //~^ ERROR mismatched types\n+    //~| HELP try wrapping\n }"}, {"sha": "0dfd8f5c128f6a0f614b4eb1c9f9da0944a80ed0", "filename": "src/test/ui/did_you_mean/compatible-variants.stderr", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr?ref=ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:9:5\n+  --> $DIR/compatible-variants.rs:13:5\n    |\n LL |   fn a() -> Option<()> {\n    |             ---------- expected `Option<()>` because of return type\n@@ -21,7 +21,7 @@ LL +     Some(())\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:17:5\n+  --> $DIR/compatible-variants.rs:21:5\n    |\n LL | fn b() -> Result<(), ()> {\n    |           -------------- expected `Result<(), ()>` because of return type\n@@ -37,7 +37,7 @@ LL +     Ok(())\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:23:25\n+  --> $DIR/compatible-variants.rs:27:25\n    |\n LL |     let _: Option<()> = while false {};\n    |            ----------   ^^^^^^^^^^^^^^ expected enum `Option`, found `()`\n@@ -52,7 +52,7 @@ LL |     let _: Option<()> = Some(while false {});\n    |                         +++++              +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:27:9\n+  --> $DIR/compatible-variants.rs:31:9\n    |\n LL |         while false {}\n    |         ^^^^^^^^^^^^^^ expected enum `Option`, found `()`\n@@ -69,7 +69,7 @@ LL +         Some(())\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:31:31\n+  --> $DIR/compatible-variants.rs:35:31\n    |\n LL |     let _: Result<i32, i32> = 1;\n    |            ----------------   ^ expected enum `Result`, found integer\n@@ -86,7 +86,7 @@ LL |     let _: Result<i32, i32> = Err(1);\n    |                               ++++ +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:34:26\n+  --> $DIR/compatible-variants.rs:38:26\n    |\n LL |     let _: Option<i32> = 1;\n    |            -----------   ^ expected enum `Option`, found integer\n@@ -101,7 +101,7 @@ LL |     let _: Option<i32> = Some(1);\n    |                          +++++ +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:37:28\n+  --> $DIR/compatible-variants.rs:41:28\n    |\n LL |     let _: Hey<i32, i32> = 1;\n    |            -------------   ^ expected enum `Hey`, found integer\n@@ -118,7 +118,7 @@ LL |     let _: Hey<i32, i32> = Hey::B(1);\n    |                            +++++++ +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:40:29\n+  --> $DIR/compatible-variants.rs:44:29\n    |\n LL |     let _: Hey<i32, bool> = false;\n    |            --------------   ^^^^^ expected enum `Hey`, found `bool`\n@@ -132,6 +132,19 @@ help: try wrapping the expression in `Hey::B`\n LL |     let _: Hey<i32, bool> = Hey::B(false);\n    |                             +++++++     +\n \n-error: aborting due to 8 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/compatible-variants.rs:48:19\n+   |\n+LL |     let _ = Foo { bar };\n+   |                   ^^^ expected enum `Option`, found `i32`\n+   |\n+   = note: expected enum `Option<i32>`\n+              found type `i32`\n+help: try wrapping the expression in `Some`\n+   |\n+LL |     let _ = Foo { bar: Some(bar) };\n+   |                   ++++++++++   +\n+\n+error: aborting due to 9 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "28c9afaa52c2299dbe987b84268e7e12628e5719", "filename": "src/test/ui/inference/deref-suggestion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff1b653cdb1f176bf995b58cec3c7e74965cdac5/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr?ref=ff1b653cdb1f176bf995b58cec3c7e74965cdac5", "patch": "@@ -87,7 +87,7 @@ LL |     let r = R { i };\n help: consider dereferencing the borrow\n    |\n LL |     let r = R { i: *i };\n-   |                 ~~~~~\n+   |                 ++++\n \n error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:46:20"}]}