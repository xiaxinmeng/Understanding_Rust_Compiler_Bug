{"sha": "75307c22f33cb47966466ba1daca08573a3c583e", "node_id": "C_kwDOAAsO6NoAKDc1MzA3YzIyZjMzY2I0Nzk2NjQ2NmJhMWRhY2EwODU3M2EzYzU4M2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-11T01:39:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-11T01:39:43Z"}, "message": "Auto merge of #97648 - lcnr:bound-var-replacer, r=jackh726\n\ncleanup bound variable handling\n\neach commit should be pretty self-contained and hopefully straightforward to review.\n\nI've added 677ec23a8dbf8ff5f1c03ccebd46f8b85e5ec1fc so that we can stop returning the region map from `replace_bound_vars_with_fresh_vars` in the following commit.\n\nr? `@nikomatsakis` or `@jackh726`", "tree": {"sha": "15346679c9789e94a26659d2e7182f354fd2764a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15346679c9789e94a26659d2e7182f354fd2764a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75307c22f33cb47966466ba1daca08573a3c583e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75307c22f33cb47966466ba1daca08573a3c583e", "html_url": "https://github.com/rust-lang/rust/commit/75307c22f33cb47966466ba1daca08573a3c583e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75307c22f33cb47966466ba1daca08573a3c583e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9f3bdf5ce37c50c71dd7cee969a14e15f14130a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9f3bdf5ce37c50c71dd7cee969a14e15f14130a", "html_url": "https://github.com/rust-lang/rust/commit/b9f3bdf5ce37c50c71dd7cee969a14e15f14130a"}, {"sha": "efdf948f43a6416c2104430c53860d4f4032b812", "url": "https://api.github.com/repos/rust-lang/rust/commits/efdf948f43a6416c2104430c53860d4f4032b812", "html_url": "https://github.com/rust-lang/rust/commit/efdf948f43a6416c2104430c53860d4f4032b812"}], "stats": {"total": 377, "additions": 186, "deletions": 191}, "files": [{"sha": "2259a59e1956cb4a4b3700047bd5765af6b9d637", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -60,13 +60,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // Replace the bound items in the fn sig with fresh\n                     // variables, so that they represent the view from\n                     // \"inside\" the closure.\n-                    self.infcx\n-                        .replace_bound_vars_with_fresh_vars(\n-                            body.span,\n-                            LateBoundRegionConversionTime::FnCall,\n-                            poly_sig,\n-                        )\n-                        .0\n+                    self.infcx.replace_bound_vars_with_fresh_vars(\n+                        body.span,\n+                        LateBoundRegionConversionTime::FnCall,\n+                        poly_sig,\n+                    )\n                 },\n             );\n         }"}, {"sha": "e405baf7575dd1c518009555a923df3d7ca387da", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -20,7 +20,7 @@ use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n-    InferCtxt, InferOk, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n+    InferCtxt, InferOk, LateBoundRegion, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n };\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n@@ -1436,11 +1436,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         return;\n                     }\n                 };\n-                let (sig, map) = self.infcx.replace_bound_vars_with_fresh_vars(\n-                    term.source_info.span,\n-                    LateBoundRegionConversionTime::FnCall,\n-                    sig,\n-                );\n+                let (sig, map) = tcx.replace_late_bound_regions(sig, |br| {\n+                    self.infcx.next_region_var(LateBoundRegion(\n+                        term.source_info.span,\n+                        br.kind,\n+                        LateBoundRegionConversionTime::FnCall,\n+                    ))\n+                });\n                 debug!(?sig);\n                 let sig = self.normalize(sig, term_location);\n                 self.check_call_dest(body, term, &sig, *destination, target, term_location);"}, {"sha": "45ed4b63009b4e3f3b53d81ed2b88e8bf2b5ae1a", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -86,6 +86,6 @@ where\n             c => bug!(\"{:?} is a const but value is {:?}\", bound_ct, c),\n         };\n \n-        tcx.replace_escaping_bound_vars(value, fld_r, fld_t, fld_c)\n+        tcx.replace_escaping_bound_vars_uncached(value, fld_r, fld_t, fld_c)\n     }\n }"}, {"sha": "3b1798ca73746cdb4361573527eb45adbfddb879", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -153,12 +153,12 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n     {\n         if a.skip_binder().has_escaping_bound_vars() || b.skip_binder().has_escaping_bound_vars() {\n             self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n-            self.fields.higher_ranked_sub(b, a, self.a_is_expected)\n+            self.fields.higher_ranked_sub(b, a, self.a_is_expected)?;\n         } else {\n             // Fast path for the common case.\n             self.relate(a.skip_binder(), b.skip_binder())?;\n-            Ok(a)\n         }\n+        Ok(a)\n     }\n }\n "}, {"sha": "bb3b410b2bde3258203439f7b0fac269aa29dbf1", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -3,78 +3,85 @@\n \n use super::combine::CombineFields;\n use super::{HigherRankedType, InferCtxt};\n-\n use crate::infer::CombinedSnapshot;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Binder, TypeFoldable};\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n+    /// Checks whether `for<..> sub <: for<..> sup` holds.\n+    ///\n+    /// For this to hold, **all** instantiations of the super type\n+    /// have to be a super type of **at least one** instantiation of\n+    /// the subtype.\n+    ///\n+    /// This is implemented by first entering a new universe.\n+    /// We then replace all bound variables in `sup` with placeholders,\n+    /// and all bound variables in `sup` with inference vars.\n+    /// We can then just relate the two resulting types as normal.\n+    ///\n+    /// Note: this is a subtle algorithm. For a full explanation, please see\n+    /// the [rustc dev guide][rd]\n+    ///\n+    /// [rd]: https://rustc-dev-guide.rust-lang.org/borrow_check/region_inference/placeholders_and_universes.html\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n-        a: Binder<'tcx, T>,\n-        b: Binder<'tcx, T>,\n-        a_is_expected: bool,\n-    ) -> RelateResult<'tcx, Binder<'tcx, T>>\n+        sub: Binder<'tcx, T>,\n+        sup: Binder<'tcx, T>,\n+        sub_is_expected: bool,\n+    ) -> RelateResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n-        // Rather than checking the subtype relationship between `a` and `b`\n-        // as-is, we need to do some extra work here in order to make sure\n-        // that function subtyping works correctly with respect to regions\n-        //\n-        // Note: this is a subtle algorithm.  For a full explanation, please see\n-        // the rustc dev guide:\n-        // <https://rustc-dev-guide.rust-lang.org/borrow_check/region_inference/placeholders_and_universes.html>\n-\n         let span = self.trace.cause.span;\n \n         self.infcx.commit_if_ok(|_| {\n             // First, we instantiate each bound region in the supertype with a\n-            // fresh placeholder region.\n-            let b_prime = self.infcx.replace_bound_vars_with_placeholders(b);\n+            // fresh placeholder region. Note that this automatically creates\n+            // a new universe if needed.\n+            let sup_prime = self.infcx.replace_bound_vars_with_placeholders(sup);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n             // but no other pre-existing region variables -- can name\n             // the placeholders.\n-            let (a_prime, _) =\n-                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, a);\n+            let sub_prime =\n+                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, sub);\n \n-            debug!(\"a_prime={:?}\", a_prime);\n-            debug!(\"b_prime={:?}\", b_prime);\n+            debug!(\"a_prime={:?}\", sub_prime);\n+            debug!(\"b_prime={:?}\", sup_prime);\n \n             // Compare types now that bound regions have been replaced.\n-            let result = self.sub(a_is_expected).relate(a_prime, b_prime)?;\n-\n-            debug!(\"higher_ranked_sub: OK result={:?}\", result);\n+            let result = self.sub(sub_is_expected).relate(sub_prime, sup_prime)?;\n \n-            // We related `a_prime` and `b_prime`, which just had any bound vars\n-            // replaced with placeholders or infer vars, respectively. Relating\n-            // them should not introduce new bound vars.\n-            Ok(ty::Binder::dummy(result))\n+            debug!(\"higher_ranked_sub: OK result={result:?}\");\n+            // NOTE: returning the result here would be dangerous as it contains\n+            // placeholders which **must not** be named afterwards.\n+            Ok(())\n         })\n     }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Replaces all bound variables (lifetimes, types, and constants) bound by\n-    /// `binder` with placeholder variables.\n+    /// `binder` with placeholder variables in a new universe. This means that the\n+    /// new placeholders can only be named by inference variables created after\n+    /// this method has been called.\n     ///\n     /// This is the first step of checking subtyping when higher-ranked things are involved.\n     /// For more details visit the relevant sections of the [rustc dev guide].\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<'tcx> + Copy,\n     {\n-        // Figure out what the next universe will be, but don't actually create\n-        // it until after we've done the substitution (in particular there may\n-        // be no bound variables). This is a performance optimization, since the\n-        // leak check for example can be skipped if no new universes are created\n-        // (i.e., if there are no placeholders).\n-        let next_universe = self.universe().next_universe();\n+        if let Some(inner) = binder.no_bound_vars() {\n+            return inner;\n+        }\n+\n+        let next_universe = self.create_next_universe();\n \n         let fld_r = |br: ty::BoundRegion| {\n             self.tcx.mk_region(ty::RePlaceholder(ty::PlaceholderRegion {\n@@ -100,23 +107,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             })\n         };\n \n-        let (result, map) = self.tcx.replace_bound_vars(binder, fld_r, fld_t, fld_c);\n-\n-        // If there were higher-ranked regions to replace, then actually create\n-        // the next universe (this avoids needlessly creating universes).\n-        if !map.is_empty() {\n-            let n_u = self.create_next_universe();\n-            assert_eq!(n_u, next_universe);\n-        }\n-\n-        debug!(\n-            \"replace_bound_vars_with_placeholders(\\\n-             next_universe={:?}, \\\n-             result={:?}, \\\n-             map={:?})\",\n-            next_universe, result, map,\n-        );\n-\n+        let result = self.tcx.replace_bound_vars_uncached(binder, fld_r, fld_t, fld_c);\n+        debug!(?next_universe, ?result);\n         result\n     }\n "}, {"sha": "0e30b136622a020d2d029a4c1ea2ec0dbad3c1b9", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -33,7 +33,6 @@ use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::BTreeMap;\n use std::fmt;\n \n use self::combine::CombineFields;\n@@ -1524,25 +1523,40 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: ty::Binder<'tcx, T>,\n-    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+    ) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<'tcx> + Copy,\n     {\n-        let fld_r =\n-            |br: ty::BoundRegion| self.next_region_var(LateBoundRegion(span, br.kind, lbrct));\n-        let fld_t = |_| {\n-            self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::MiscVariable,\n-                span,\n+        if let Some(inner) = value.no_bound_vars() {\n+            return inner;\n+        }\n+\n+        let mut region_map = FxHashMap::default();\n+        let fld_r = |br: ty::BoundRegion| {\n+            *region_map\n+                .entry(br)\n+                .or_insert_with(|| self.next_region_var(LateBoundRegion(span, br.kind, lbrct)))\n+        };\n+\n+        let mut ty_map = FxHashMap::default();\n+        let fld_t = |bt: ty::BoundTy| {\n+            *ty_map.entry(bt).or_insert_with(|| {\n+                self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                    span,\n+                })\n             })\n         };\n-        let fld_c = |_, ty| {\n-            self.next_const_var(\n-                ty,\n-                ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span },\n-            )\n+        let mut ct_map = FxHashMap::default();\n+        let fld_c = |bc: ty::BoundVar, ty| {\n+            *ct_map.entry(bc).or_insert_with(|| {\n+                self.next_const_var(\n+                    ty,\n+                    ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span },\n+                )\n+            })\n         };\n-        self.tcx.replace_bound_vars(value, fld_r, fld_t, fld_c)\n+        self.tcx.replace_bound_vars_uncached(value, fld_r, fld_t, fld_c)\n     }\n \n     /// See the [`region_constraints::RegionConstraintCollector::verify_generic_bound`] method."}, {"sha": "d0c6d8d16ebfa44fb3f4145b329b11391e50c945", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -198,7 +198,8 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        self.fields.higher_ranked_sub(a, b, self.a_is_expected)\n+        self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n+        Ok(a)\n     }\n }\n "}, {"sha": "5ccf735f1d2a24012bcdc392836d8551b5d2dfe0", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -656,17 +656,17 @@ struct BoundVarReplacer<'a, 'tcx> {\n     /// the ones we have visited.\n     current_index: ty::DebruijnIndex,\n \n-    fld_r: Option<&'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a)>,\n-    fld_t: Option<&'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a)>,\n-    fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a)>,\n+    fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n+    fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),\n+    fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a),\n }\n \n impl<'a, 'tcx> BoundVarReplacer<'a, 'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        fld_r: Option<&'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a)>,\n-        fld_t: Option<&'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a)>,\n-        fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a)>,\n+        fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n+        fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),\n+        fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a),\n     ) -> Self {\n         BoundVarReplacer { tcx, current_index: ty::INNERMOST, fld_r, fld_t, fld_c }\n     }\n@@ -690,55 +690,42 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n-                if let Some(fld_t) = self.fld_t.as_mut() {\n-                    let ty = fld_t(bound_ty);\n-                    return ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32());\n-                }\n-            }\n-            _ if t.has_vars_bound_at_or_above(self.current_index) => {\n-                return t.super_fold_with(self);\n+                let ty = (self.fld_t)(bound_ty);\n+                ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32())\n             }\n-            _ => {}\n+            _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n+            _ => t,\n         }\n-        t\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n-                if let Some(fld_r) = self.fld_r.as_mut() {\n-                    let region = fld_r(br);\n-                    return if let ty::ReLateBound(debruijn1, br) = *region {\n-                        // If the callback returns a late-bound region,\n-                        // that region should always use the INNERMOST\n-                        // debruijn index. Then we adjust it to the\n-                        // correct depth.\n-                        assert_eq!(debruijn1, ty::INNERMOST);\n-                        self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n-                    } else {\n-                        region\n-                    };\n+                let region = (self.fld_r)(br);\n+                if let ty::ReLateBound(debruijn1, br) = *region {\n+                    // If the callback returns a late-bound region,\n+                    // that region should always use the INNERMOST\n+                    // debruijn index. Then we adjust it to the\n+                    // correct depth.\n+                    assert_eq!(debruijn1, ty::INNERMOST);\n+                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n+                } else {\n+                    region\n                 }\n             }\n-            _ => {}\n+            _ => r,\n         }\n-        r\n     }\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         match ct.val() {\n             ty::ConstKind::Bound(debruijn, bound_const) if debruijn == self.current_index => {\n-                if let Some(fld_c) = self.fld_c.as_mut() {\n-                    let ct = fld_c(bound_const, ct.ty());\n-                    return ty::fold::shift_vars(self.tcx, ct, self.current_index.as_u32());\n-                }\n+                let ct = (self.fld_c)(bound_const, ct.ty());\n+                ty::fold::shift_vars(self.tcx, ct, self.current_index.as_u32())\n             }\n-            _ if ct.has_vars_bound_at_or_above(self.current_index) => {\n-                return ct.super_fold_with(self);\n-            }\n-            _ => {}\n+            _ if ct.has_vars_bound_at_or_above(self.current_index) => ct.super_fold_with(self),\n+            _ => ct,\n         }\n-        ct\n     }\n }\n \n@@ -752,8 +739,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// returned at the end with each bound region and the free region\n     /// that replaced it.\n     ///\n-    /// This method only replaces late bound regions and the result may still\n-    /// contain escaping bound types.\n+    /// # Panics\n+    ///\n+    /// This method only replaces late bound regions. Any types or\n+    /// constants bound by `value` will cause an ICE.\n     pub fn replace_late_bound_regions<T, F>(\n         self,\n         value: Binder<'tcx, T>,\n@@ -764,22 +753,35 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let mut region_map = BTreeMap::new();\n-        let mut real_fld_r =\n-            |br: ty::BoundRegion| *region_map.entry(br).or_insert_with(|| fld_r(br));\n+        let real_fld_r = |br: ty::BoundRegion| *region_map.entry(br).or_insert_with(|| fld_r(br));\n+        let value = self.replace_late_bound_regions_uncached(value, real_fld_r);\n+        (value, region_map)\n+    }\n+\n+    pub fn replace_late_bound_regions_uncached<T, F>(\n+        self,\n+        value: Binder<'tcx, T>,\n+        mut fld_r: F,\n+    ) -> T\n+    where\n+        F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let mut fld_t = |b| bug!(\"unexpected bound ty in binder: {b:?}\");\n+        let mut fld_c = |b, ty| bug!(\"unexpected bound ct in binder: {b:?} {ty}\");\n         let value = value.skip_binder();\n-        let value = if !value.has_escaping_bound_vars() {\n+        if !value.has_escaping_bound_vars() {\n             value\n         } else {\n-            let mut replacer = BoundVarReplacer::new(self, Some(&mut real_fld_r), None, None);\n+            let mut replacer = BoundVarReplacer::new(self, &mut fld_r, &mut fld_t, &mut fld_c);\n             value.fold_with(&mut replacer)\n-        };\n-        (value, region_map)\n+        }\n     }\n \n     /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n     /// bound regions; the `fld_t` closure replaces escaping bound types and the `fld_c`\n     /// closure replaces escaping bound consts.\n-    pub fn replace_escaping_bound_vars<T, F, G, H>(\n+    pub fn replace_escaping_bound_vars_uncached<T, F, G, H>(\n         self,\n         value: T,\n         mut fld_r: F,\n@@ -795,32 +797,28 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !value.has_escaping_bound_vars() {\n             value\n         } else {\n-            let mut replacer =\n-                BoundVarReplacer::new(self, Some(&mut fld_r), Some(&mut fld_t), Some(&mut fld_c));\n+            let mut replacer = BoundVarReplacer::new(self, &mut fld_r, &mut fld_t, &mut fld_c);\n             value.fold_with(&mut replacer)\n         }\n     }\n \n     /// Replaces all types or regions bound by the given `Binder`. The `fld_r`\n-    /// closure replaces bound regions while the `fld_t` closure replaces bound\n-    /// types.\n-    pub fn replace_bound_vars<T, F, G, H>(\n+    /// closure replaces bound regions, the `fld_t` closure replaces bound\n+    /// types, and `fld_c` replaces bound constants.\n+    pub fn replace_bound_vars_uncached<T, F, G, H>(\n         self,\n         value: Binder<'tcx, T>,\n-        mut fld_r: F,\n+        fld_r: F,\n         fld_t: G,\n         fld_c: H,\n-    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+    ) -> T\n     where\n         F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n         G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n         H: FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n-        let mut region_map = BTreeMap::new();\n-        let real_fld_r = |br: ty::BoundRegion| *region_map.entry(br).or_insert_with(|| fld_r(br));\n-        let value = self.replace_escaping_bound_vars(value.skip_binder(), real_fld_r, fld_t, fld_c);\n-        (value, region_map)\n+        self.replace_escaping_bound_vars_uncached(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces any late-bound regions bound in `value` with\n@@ -833,20 +831,19 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.replace_late_bound_regions(value, |br| {\n+        self.replace_late_bound_regions_uncached(value, |br| {\n             self.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: all_outlive_scope,\n                 bound_region: br.kind,\n             }))\n         })\n-        .0\n     }\n \n     pub fn shift_bound_var_indices<T>(self, bound_vars: usize, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.replace_escaping_bound_vars(\n+        self.replace_escaping_bound_vars_uncached(\n             value,\n             |r| {\n                 self.mk_region(ty::ReLateBound("}, {"sha": "2e7067fa71076c4379a2f446aa4472bfa8dcbef6", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -1536,7 +1536,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             let bound_predicate = predicate.kind();\n             if let ty::PredicateKind::Projection(data) = bound_predicate.skip_binder() {\n                 let mut selcx = SelectionContext::new(self);\n-                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n+                let data = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n                     bound_predicate.rebind(data),"}, {"sha": "7341ab0ab124a01d83cd2df2b119202cdc8c8418", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -1920,7 +1920,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n \n-    let (cache_entry, _) = infcx.replace_bound_vars_with_fresh_vars(\n+    let cache_entry = infcx.replace_bound_vars_with_fresh_vars(\n         cause.span,\n         LateBoundRegionConversionTime::HigherRankedType,\n         poly_cache_entry,"}, {"sha": "cbf29af1c554e0c545baee3191fd29ce43490d54", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -421,14 +421,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let object_trait_ref = data.principal().unwrap_or_else(|| {\n             span_bug!(obligation.cause.span, \"object candidate with no principal\")\n         });\n-        let object_trait_ref = self\n-            .infcx\n-            .replace_bound_vars_with_fresh_vars(\n-                obligation.cause.span,\n-                HigherRankedType,\n-                object_trait_ref,\n-            )\n-            .0;\n+        let object_trait_ref = self.infcx.replace_bound_vars_with_fresh_vars(\n+            obligation.cause.span,\n+            HigherRankedType,\n+            object_trait_ref,\n+        );\n         let object_trait_ref = object_trait_ref.with_self_ty(self.tcx(), self_ty);\n \n         let mut nested = vec![];"}, {"sha": "a484b594418c2ff09c1e021604a69a4918c0456c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -1453,7 +1453,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         potentially_unnormalized_candidates: bool,\n     ) -> ProjectionMatchesProjection {\n         let mut nested_obligations = Vec::new();\n-        let (infer_predicate, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n+        let infer_predicate = self.infcx.replace_bound_vars_with_fresh_vars(\n             obligation.cause.span,\n             LateBoundRegionConversionTime::HigherRankedType,\n             env_predicate,"}, {"sha": "af1288b6523be2d13d75af322f8574eba0e63e43", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -152,13 +152,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(substs).is_none() {\n                     let closure_sig = substs.as_closure().sig();\n-                    let closure_sig = self\n-                        .replace_bound_vars_with_fresh_vars(\n-                            call_expr.span,\n-                            infer::FnCall,\n-                            closure_sig,\n-                        )\n-                        .0;\n+                    let closure_sig = self.replace_bound_vars_with_fresh_vars(\n+                        call_expr.span,\n+                        infer::FnCall,\n+                        closure_sig,\n+                    );\n                     let adjustments = self.adjust_steps(autoderef);\n                     self.record_deferred_call_resolution(\n                         def_id,\n@@ -503,8 +501,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // renormalize the associated types at this point, since they\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n-        let fn_sig =\n-            self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, fn_sig).0;\n+        let fn_sig = self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, fn_sig);\n         let fn_sig = self.normalize_associated_types_in(call_expr.span, fn_sig);\n \n         // Call the generic checker."}, {"sha": "05b22e174b845510bfcb4616650b827efd41fc6e", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -550,7 +550,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected_sigs.liberated_sig.inputs(), // `liberated_sig` is E'.\n             ) {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n-                let (supplied_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n+                let supplied_ty = self.infcx.replace_bound_vars_with_fresh_vars(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n                     supplied_sig.inputs().rebind(supplied_ty),\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 all_obligations.extend(obligations);\n             }\n \n-            let (supplied_output_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n+            let supplied_output_ty = self.infcx.replace_bound_vars_with_fresh_vars(\n                 decl.output.span(),\n                 LateBoundRegionConversionTime::FnCall,\n                 supplied_sig.output(),"}, {"sha": "d4e17f27c92bbedf4cd21d801786e72a8f469d95", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -255,7 +255,7 @@ fn compare_predicate_entailment<'tcx>(\n \n         let mut wf_tys = FxHashSet::default();\n \n-        let (impl_sig, _) = infcx.replace_bound_vars_with_fresh_vars(\n+        let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n             impl_m_span,\n             infer::HigherRankedType,\n             tcx.fn_sig(impl_m.def_id),"}, {"sha": "48bbd4d76ea5cbe693c80319074d723c82207bc5", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -561,13 +561,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // placeholder lifetimes with probing, we just replace higher lifetimes\n                     // with fresh vars.\n                     let span = args.get(i).map(|a| a.span).unwrap_or(expr.span);\n-                    let input = self\n-                        .replace_bound_vars_with_fresh_vars(\n-                            span,\n-                            infer::LateBoundRegionConversionTime::FnCall,\n-                            fn_sig.input(i),\n-                        )\n-                        .0;\n+                    let input = self.replace_bound_vars_with_fresh_vars(\n+                        span,\n+                        infer::LateBoundRegionConversionTime::FnCall,\n+                        fn_sig.input(i),\n+                    );\n                     self.require_type_is_sized_deferred(\n                         input,\n                         span,\n@@ -581,13 +579,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Also, as we just want to check sizedness, instead of introducing\n             // placeholder lifetimes with probing, we just replace higher lifetimes\n             // with fresh vars.\n-            let output = self\n-                .replace_bound_vars_with_fresh_vars(\n-                    expr.span,\n-                    infer::LateBoundRegionConversionTime::FnCall,\n-                    fn_sig.output(),\n-                )\n-                .0;\n+            let output = self.replace_bound_vars_with_fresh_vars(\n+                expr.span,\n+                infer::LateBoundRegionConversionTime::FnCall,\n+                fn_sig.output(),\n+            );\n             self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n         }\n "}, {"sha": "fa2416d56de14e0bafce365e1c31de77132422f7", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n-        let (trait_ref, _) = self.replace_bound_vars_with_fresh_vars(\n+        let trait_ref = self.replace_bound_vars_with_fresh_vars(\n             span,\n             infer::LateBoundRegionConversionTime::AssocTypeProjection(item_def_id),\n             poly_trait_ref,"}, {"sha": "ca55a4299eb06653598fe96d75e7ca2f25dbc97d", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return false,\n         };\n \n-        let sig = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, sig).0;\n+        let sig = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, sig);\n         let sig = self.normalize_associated_types_in(expr.span, sig);\n         if self.can_coerce(sig.output(), expected) {\n             let (mut sugg_call, applicability) = if sig.inputs().is_empty() {"}, {"sha": "4061b7cae7c78348384d8050d226ef85162ecbb5", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -572,8 +572,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n     fn replace_bound_vars_with_fresh_vars<T>(&self, value: ty::Binder<'tcx, T>) -> T\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<'tcx> + Copy,\n     {\n-        self.fcx.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, value).0\n+        self.fcx.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, value)\n     }\n }"}, {"sha": "5ca822183556b3c6fb2f931946a5fe6f830f2ccc", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // may reference those regions.\n         let fn_sig = tcx.bound_fn_sig(def_id);\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n-        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig).0;\n+        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig);\n \n         let InferOk { value, obligations: o } = if is_op {\n             self.normalize_op_associated_types_in_as_infer_ok(span, fn_sig, opt_input_expr)"}, {"sha": "87254b211d67b324f66ac9d85de73a932bcbabfc", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -905,7 +905,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n-                    let (fty, _) =\n+                    let fty =\n                         self.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, fty);\n \n                     if let Some(self_ty) = self_ty {"}, {"sha": "de40126e724df96c0cbf4651f023806fbc28fbcf", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75307c22f33cb47966466ba1daca08573a3c583e/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=75307c22f33cb47966466ba1daca08573a3c583e", "patch": "@@ -449,17 +449,18 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                                     format!(\n                                         \"{}::\",\n                                         // Replace the existing lifetimes with a new named lifetime.\n-                                        self.tcx\n-                                            .replace_late_bound_regions(poly_trait_ref, |_| {\n+                                        self.tcx.replace_late_bound_regions_uncached(\n+                                            poly_trait_ref,\n+                                            |_| {\n                                                 self.tcx.mk_region(ty::ReEarlyBound(\n                                                     ty::EarlyBoundRegion {\n                                                         def_id: item_def_id,\n                                                         index: 0,\n                                                         name: Symbol::intern(&lt_name),\n                                                     },\n                                                 ))\n-                                            })\n-                                            .0,\n+                                            }\n+                                        ),\n                                     ),\n                                 ),\n                             ];"}]}