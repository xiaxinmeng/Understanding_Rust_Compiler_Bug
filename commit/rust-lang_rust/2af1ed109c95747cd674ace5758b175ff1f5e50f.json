{"sha": "2af1ed109c95747cd674ace5758b175ff1f5e50f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZjFlZDEwOWM5NTc0N2NkNjc0YWNlNTc1OGIxNzVmZjFmNWU1MGY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T22:33:24Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T02:05:04Z"}, "message": "Refactoring: factor out `format_file` and `FormatHandler`\n\nThis effectively separates out formatting from other handling.", "tree": {"sha": "b407235bcb3f068b1bcf1553d527873c6b0edbf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b407235bcb3f068b1bcf1553d527873c6b0edbf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2af1ed109c95747cd674ace5758b175ff1f5e50f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2af1ed109c95747cd674ace5758b175ff1f5e50f", "html_url": "https://github.com/rust-lang/rust/commit/2af1ed109c95747cd674ace5758b175ff1f5e50f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2af1ed109c95747cd674ace5758b175ff1f5e50f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72", "html_url": "https://github.com/rust-lang/rust/commit/b9c6754d8c0d92f9d205fcc48d23d2f5a2b9fc72"}], "stats": {"total": 234, "additions": 140, "deletions": 94}, "files": [{"sha": "71ebe9d41026756e7ec9a4eb241b8176582ca4a5", "filename": "src/formatting.rs", "status": "modified", "additions": 130, "deletions": 81, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/2af1ed109c95747cd674ace5758b175ff1f5e50f/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af1ed109c95747cd674ace5758b175ff1f5e50f/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=2af1ed109c95747cd674ace5758b175ff1f5e50f", "patch": "@@ -20,7 +20,6 @@ use {filemap, modules, ErrorKind, FormatReport, Input, Session};\n \n // A map of the files of a crate, with their new content\n pub(crate) type FileMap = Vec<FileRecord>;\n-\n pub(crate) type FileRecord = (FileName, String);\n \n pub(crate) struct FormattingError {\n@@ -297,56 +296,72 @@ enum ParseError<'sess> {\n }\n \n impl<'b, T: Write + 'b> Session<'b, T> {\n-    pub(crate) fn format_input_inner(\n-        &mut self,\n-        input: Input,\n-    ) -> Result<(FileMap, FormatReport), ErrorKind> {\n-        syntax_pos::hygiene::set_default_edition(self.config.edition().to_libsyntax_pos_edition());\n-\n-        if self.config.disable_all_formatting() {\n-            // When the input is from stdin, echo back the input.\n-            if let Input::Text(ref buf) = input {\n-                if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n-                    return Err(From::from(e));\n-                }\n-            }\n-            return Ok((FileMap::new(), FormatReport::new()));\n+    pub(crate) fn format_input_inner(&mut self, input: Input) -> Result<FormatReport, ErrorKind> {\n+        if !self.config.version_meets_requirement() {\n+            return Err(ErrorKind::VersionMismatch);\n         }\n \n-        let mut filemap = FileMap::new();\n-        let config = &self.config.clone();\n-        let format_result = format_project(input, config, |path, mut result| {\n-            if let Some(ref mut out) = self.out {\n-                match filemap::write_file(&mut result, &path, out, &self.config) {\n-                    Ok(b) if b => self.summary.add_diff(),\n-                    Err(e) => {\n-                        // Create a new error with path_str to help users see which files failed\n-                        let err_msg = format!(\"{}: {}\", path, e);\n-                        return Err(io::Error::new(e.kind(), err_msg).into());\n+        syntax::with_globals(|| {\n+            syntax_pos::hygiene::set_default_edition(\n+                self.config.edition().to_libsyntax_pos_edition(),\n+            );\n+\n+            if self.config.disable_all_formatting() {\n+                // When the input is from stdin, echo back the input.\n+                if let Input::Text(ref buf) = input {\n+                    if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n+                        return Err(From::from(e));\n                     }\n-                    _ => {}\n                 }\n+                return Ok(FormatReport::new());\n             }\n \n-            filemap.push((path, result));\n-            Ok(())\n-        });\n+            let config = &self.config.clone();\n+            let format_result = format_project(input, config, self);\n \n-        format_result.map(|(result, summary)| {\n-            self.summary.add(summary);\n-            (filemap, result)\n+            format_result.map(|(report, summary)| {\n+                self.summary.add(summary);\n+                report\n+            })\n         })\n     }\n }\n \n-fn format_project<F>(\n+// Handle the results of formatting.\n+trait FormatHandler {\n+    fn handle_formatted_file(&mut self, path: FileName, result: String) -> Result<(), ErrorKind>;\n+}\n+\n+impl<'b, T: Write + 'b> FormatHandler for Session<'b, T> {\n+    // Called for each formatted file.\n+    fn handle_formatted_file(\n+        &mut self,\n+        path: FileName,\n+        mut result: String,\n+    ) -> Result<(), ErrorKind> {\n+        if let Some(ref mut out) = self.out {\n+            match filemap::write_file(&mut result, &path, out, &self.config) {\n+                Ok(b) if b => self.summary.add_diff(),\n+                Err(e) => {\n+                    // Create a new error with path_str to help users see which files failed\n+                    let err_msg = format!(\"{}: {}\", path, e);\n+                    return Err(io::Error::new(e.kind(), err_msg).into());\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        self.filemap.push((path, result));\n+        Ok(())\n+    }\n+}\n+\n+// Format an entire crate (or subset of the module tree).\n+fn format_project<T: FormatHandler>(\n     input: Input,\n     config: &Config,\n-    mut formatted_file: F,\n-) -> Result<(FormatReport, Summary), ErrorKind>\n-where\n-    F: FnMut(FileName, String) -> Result<(), ErrorKind>,\n-{\n+    handler: &mut T,\n+) -> Result<(FormatReport, Summary), ErrorKind> {\n     let mut summary = Summary::default();\n     let mut timer = Timer::Initialized(Instant::now());\n \n@@ -368,7 +383,7 @@ where\n                     // Note that if you see this message and want more information,\n                     // then go to `parse_input` and run the parse function without\n                     // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-                    should_emit_verbose(main_file != FileName::Stdin, config, || {\n+                    should_emit_verbose(!input_is_stdin, config, || {\n                         println!(\"The Rust parser panicked\")\n                     });\n                 }\n@@ -389,28 +404,86 @@ where\n     ));\n     parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n-    let report = FormatReport::new();\n-\n-    let skip_children = config.skip_children();\n-    for (path, module) in modules::list_files(&krate, parse_session.codemap())? {\n-        if (skip_children && path != main_file) || config.ignore().skip_file(&path) {\n+    let mut context = FormatContext::new(\n+        &krate,\n+        FormatReport::new(),\n+        summary,\n+        parse_session,\n+        config,\n+        handler,\n+    );\n+\n+    let files = modules::list_files(&krate, context.parse_session.codemap())?;\n+    for (path, module) in files {\n+        if (config.skip_children() && path != main_file) || config.ignore().skip_file(&path) {\n             continue;\n         }\n-        should_emit_verbose(main_file != FileName::Stdin, config, || {\n-            println!(\"Formatting {}\", path)\n-        });\n-        let filemap = parse_session\n+        should_emit_verbose(!input_is_stdin, config, || println!(\"Formatting {}\", path));\n+        let is_root = path == main_file;\n+        context.format_file(path, module, is_root)?;\n+    }\n+    timer = timer.done_formatting();\n+\n+    should_emit_verbose(!input_is_stdin, config, || {\n+        println!(\n+            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n+            timer.get_parse_time(),\n+            timer.get_format_time(),\n+        )\n+    });\n+\n+    if context.report.has_warnings() {\n+        context.summary.add_formatting_error();\n+    }\n+    {\n+        let report_errs = &context.report.internal.borrow().1;\n+        if report_errs.has_check_errors {\n+            context.summary.add_check_error();\n+        }\n+        if report_errs.has_operational_errors {\n+            context.summary.add_operational_error();\n+        }\n+    }\n+\n+    Ok((context.report, context.summary))\n+}\n+\n+// Used for formatting files.\n+#[derive(new)]\n+struct FormatContext<'a, T: FormatHandler + 'a> {\n+    krate: &'a ast::Crate,\n+    report: FormatReport,\n+    summary: Summary,\n+    parse_session: ParseSess,\n+    config: &'a Config,\n+    handler: &'a mut T,\n+}\n+\n+impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n+    // Formats a single file/module.\n+    fn format_file(\n+        &mut self,\n+        path: FileName,\n+        module: &ast::Mod,\n+        is_root: bool,\n+    ) -> Result<(), ErrorKind> {\n+        let filemap = self\n+            .parse_session\n             .codemap()\n             .lookup_char_pos(module.inner.lo())\n             .file;\n         let big_snippet = filemap.src.as_ref().unwrap();\n         let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n-        let mut visitor =\n-            FmtVisitor::from_codemap(&parse_session, config, &snippet_provider, report.clone());\n+        let mut visitor = FmtVisitor::from_codemap(\n+            &self.parse_session,\n+            &self.config,\n+            &snippet_provider,\n+            self.report.clone(),\n+        );\n         // Format inner attributes if available.\n-        if !krate.attrs.is_empty() && path == main_file {\n+        if !self.krate.attrs.is_empty() && is_root {\n             visitor.skip_empty_lines(filemap.end_pos);\n-            if visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner) {\n+            if visitor.visit_attrs(&self.krate.attrs, ast::AttrStyle::Inner) {\n                 visitor.push_rewrite(module.inner, None);\n             } else {\n                 visitor.format_separate_mod(module, &*filemap);\n@@ -434,41 +507,17 @@ where\n             &mut visitor.buffer,\n             &path,\n             &visitor.skipped_range,\n-            config,\n-            &report,\n+            &self.config,\n+            &self.report,\n         );\n-        replace_with_system_newlines(&mut visitor.buffer, config);\n+        replace_with_system_newlines(&mut visitor.buffer, &self.config);\n \n         if visitor.macro_rewrite_failure {\n-            summary.add_macro_format_failure();\n+            self.summary.add_macro_format_failure();\n         }\n \n-        formatted_file(path, visitor.buffer)?;\n+        self.handler.handle_formatted_file(path, visitor.buffer)\n     }\n-    timer = timer.done_formatting();\n-\n-    should_emit_verbose(input_is_stdin, config, || {\n-        println!(\n-            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n-            timer.get_parse_time(),\n-            timer.get_format_time(),\n-        )\n-    });\n-\n-    if report.has_warnings() {\n-        summary.add_formatting_error();\n-    }\n-    {\n-        let report_errs = &report.internal.borrow().1;\n-        if report_errs.has_check_errors {\n-            summary.add_check_error();\n-        }\n-        if report_errs.has_operational_errors {\n-            summary.add_operational_error();\n-        }\n-    }\n-\n-    Ok((report, summary))\n }\n \n fn make_parse_sess(codemap: Rc<CodeMap>, config: &Config) -> ParseSess {"}, {"sha": "e21bd6c79be89a144a247fc7d5f158646b7d6052", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2af1ed109c95747cd674ace5758b175ff1f5e50f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af1ed109c95747cd674ace5758b175ff1f5e50f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2af1ed109c95747cd674ace5758b175ff1f5e50f", "patch": "@@ -49,7 +49,7 @@ use syntax::ast;\n \n use comment::LineClasses;\n use failure::Fail;\n-use formatting::{FormatErrorMap, FormattingError, ReportedErrors, Summary};\n+use formatting::{FileMap, FormatErrorMap, FormattingError, ReportedErrors, Summary};\n use issues::Issue;\n use shape::Indent;\n \n@@ -444,6 +444,7 @@ pub struct Session<'b, T: Write + 'b> {\n     pub config: Config,\n     pub out: Option<&'b mut T>,\n     pub summary: Summary,\n+    filemap: FileMap,\n }\n \n impl<'b, T: Write + 'b> Session<'b, T> {\n@@ -456,17 +457,14 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             config,\n             out,\n             summary: Summary::default(),\n+            filemap: FileMap::new(),\n         }\n     }\n \n     /// The main entry point for Rustfmt. Formats the given input according to the\n     /// given config. `out` is only necessary if required by the configuration.\n     pub fn format(&mut self, input: Input) -> Result<FormatReport, ErrorKind> {\n-        if !self.config.version_meets_requirement() {\n-            return Err(ErrorKind::VersionMismatch);\n-        }\n-\n-        syntax::with_globals(|| self.format_input_inner(input)).map(|tup| tup.1)\n+        self.format_input_inner(input)\n     }\n \n     pub fn override_config<F, U>(&mut self, mut config: Config, f: F) -> U"}, {"sha": "63b5f244b9067e96f815fd6e2c1ea630088aa8d4", "filename": "src/test/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2af1ed109c95747cd674ace5758b175ff1f5e50f/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af1ed109c95747cd674ace5758b175ff1f5e50f/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=2af1ed109c95747cd674ace5758b175ff1f5e50f", "patch": "@@ -10,13 +10,12 @@\n \n extern crate assert_cli;\n \n-use syntax;\n-\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::fs;\n use std::io::{self, BufRead, BufReader, Read, Write};\n use std::iter::{Enumerate, Peekable};\n+use std::mem;\n use std::path::{Path, PathBuf};\n use std::str::Chars;\n \n@@ -419,11 +418,11 @@ fn format_file<P: Into<PathBuf>>(filepath: P, config: Config) -> (bool, FileMap,\n     let filepath = filepath.into();\n     let input = Input::File(filepath);\n     let mut session = Session::<io::Stdout>::new(config, None);\n-    syntax::with_globals(|| {\n-        let result = session.format_input_inner(input).unwrap();\n-        let parsing_errors = session.summary.has_parsing_errors();\n-        (parsing_errors, result.0, result.1)\n-    })\n+    let result = session.format(input).unwrap();\n+    let parsing_errors = session.summary.has_parsing_errors();\n+    let mut filemap = FileMap::new();\n+    mem::swap(&mut session.filemap, &mut filemap);\n+    (parsing_errors, filemap, result)\n }\n \n enum IdempotentCheckError {"}]}