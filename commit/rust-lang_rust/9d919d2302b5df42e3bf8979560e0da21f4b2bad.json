{"sha": "9d919d2302b5df42e3bf8979560e0da21f4b2bad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkOTE5ZDIzMDJiNWRmNDJlM2JmODk3OTU2MGUwZGEyMWY0YjJiYWQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-17T07:44:43Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-30T20:02:22Z"}, "message": "Second pass stabilization: vec\n\nThis commit takes a second pass through the `vec` module to\nstabilize its API. The changes are as follows:\n\n**Stable**:\n\n* `dedup`\n* `from_raw_parts`\n* `insert`\n* `into_iter`\n* `is_empty`\n* `remove`\n* `reserve_exact`\n* `reserve`\n* `retain`\n* `swap_remove`\n* `truncate`\n\n**Deprecated**:\n\n* `from_fn`, `from_elem`, `grow_fn` and `grow`, all deprecated in\n  favor of iterators. See https://github.com/rust-lang/rfcs/pull/509\n\n* `partition`, `partitioned`, deprecated in favor of a new, more\n  general iterator consumer called `partition`.\n\n* `unzip`, deprecated in favor of a new, more general iterator\n  consumer called `unzip`.\n\nA few remaining methods are left at experimental status.\n\n[breaking-change]", "tree": {"sha": "e67b390951a2acd018bea7b57698571ada7a22cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e67b390951a2acd018bea7b57698571ada7a22cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d919d2302b5df42e3bf8979560e0da21f4b2bad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d919d2302b5df42e3bf8979560e0da21f4b2bad", "html_url": "https://github.com/rust-lang/rust/commit/9d919d2302b5df42e3bf8979560e0da21f4b2bad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d919d2302b5df42e3bf8979560e0da21f4b2bad/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a5057af2e19bea374600669fee49af1ccf89d08", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a5057af2e19bea374600669fee49af1ccf89d08", "html_url": "https://github.com/rust-lang/rust/commit/8a5057af2e19bea374600669fee49af1ccf89d08"}], "stats": {"total": 1703, "additions": 809, "deletions": 894}, "files": [{"sha": "3e0b3b4aa74ae9f6c4fc0ae458e51b100dbce9dd", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 808, "deletions": 894, "changes": 1702, "blob_url": "https://github.com/rust-lang/rust/blob/9d919d2302b5df42e3bf8979560e0da21f4b2bad/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d919d2302b5df42e3bf8979560e0da21f4b2bad/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9d919d2302b5df42e3bf8979560e0da21f4b2bad", "patch": "@@ -142,26 +142,9 @@ pub struct Vec<T> {\n unsafe impl<T: Send> Send for Vec<T> { }\n unsafe impl<T: Sync> Sync for Vec<T> { }\n \n-/// A clone-on-write vector\n-pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n-\n-impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n-    fn from_iter<I: Iterator<T>>(it: I) -> CowVec<'a, T> {\n-        Cow::Owned(FromIterator::from_iter(it))\n-    }\n-}\n-\n-impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n-        Cow::Owned(self)\n-    }\n-}\n-\n-impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n-        Cow::Borrowed(self)\n-    }\n-}\n+////////////////////////////////////////////////////////////////////////////////\n+// Inherent methods\n+////////////////////////////////////////////////////////////////////////////////\n \n impl<T> Vec<T> {\n     /// Constructs a new, empty `Vec<T>`.\n@@ -225,30 +208,11 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Creates and initializes a `Vec<T>`.\n-    ///\n-    /// Creates a `Vec<T>` of size `length` and initializes the elements to the value returned by\n-    /// the closure `op`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = Vec::from_fn(3, |idx| idx * 2);\n-    /// assert_eq!(vec, vec![0, 2, 4]);\n-    /// ```\n+    /// Deprecated: use `iter::range(0, length).map(op).collect()` instead\n     #[inline]\n-    #[unstable = \"the naming is uncertain as well as this migrating to unboxed \\\n-                  closures in the future\"]\n-    pub fn from_fn<F>(length: uint, mut op: F) -> Vec<T> where F: FnMut(uint) -> T {\n-        unsafe {\n-            let mut xs = Vec::with_capacity(length);\n-            while xs.len < length {\n-                let len = xs.len;\n-                ptr::write(xs.unsafe_mut(len), op(len));\n-                xs.len += 1;\n-            }\n-            xs\n-        }\n+    #[deprecated = \"use iter::range(0, length).map(op).collect() instead\"]\n+    pub fn from_fn<F>(length: uint, op: F) -> Vec<T> where F: FnMut(uint) -> T {\n+        range(0, length).map(op).collect()\n     }\n \n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n@@ -285,7 +249,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable = \"needs finalization\"]\n+    #[stable]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n@@ -297,642 +261,251 @@ impl<T> Vec<T> {\n     /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n     /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable = \"just renamed from raw::from_buf\"]\n+    #[stable]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n         dst\n     }\n \n-    /// Consumes the `Vec<T>`, partitioning it based on a predicate.\n-    ///\n-    /// Partitions the `Vec<T>` into two `Vec<T>`s `(A,B)`, where all elements of `A` satisfy `f`\n-    /// and all elements of `B` do not. The order of elements is preserved.\n+    /// Deprecated: use `into_iter().partition(f)` instead.\n+    #[inline]\n+    #[deprecated = \"use into_iter().partition(f) instead\"]\n+    pub fn partition<F>(self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.into_iter().partition(f)\n+    }\n+\n+    /// Returns the number of elements the vector can hold without\n+    /// reallocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2i, 3i, 4i];\n-    /// let (even, odd) = vec.partition(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec![2, 4]);\n-    /// assert_eq!(odd, vec![1, 3]);\n+    /// let vec: Vec<int> = Vec::with_capacity(10);\n+    /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n-    #[experimental]\n-    pub fn partition<F>(self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.into_iter() {\n-            if f(&elt) {\n-                lefts.push(elt);\n-            } else {\n-                rights.push(elt);\n-            }\n-        }\n+    #[stable]\n+    pub fn capacity(&self) -> uint {\n+        self.cap\n+    }\n \n-        (lefts, rights)\n+    /// Deprecated: Renamed to `reserve`.\n+    #[deprecated = \"Renamed to `reserve`\"]\n+    pub fn reserve_additional(&mut self, extra: uint) {\n+        self.reserve(extra)\n     }\n-}\n \n-impl<T: Clone> Vec<T> {\n-    /// Constructs a `Vec<T>` with copies of a value.\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n+    /// `Vec`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n-    /// Creates a `Vec<T>` with `length` copies of `value`.\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = Vec::from_elem(3, \"hi\");\n-    /// println!(\"{}\", vec); // prints [hi, hi, hi]\n+    /// let mut vec: Vec<int> = vec![1];\n+    /// vec.reserve(10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[inline]\n-    #[unstable = \"this functionality may become more generic over all collections\"]\n-    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n-        unsafe {\n-            let mut xs = Vec::with_capacity(length);\n-            while xs.len < length {\n-                let len = xs.len;\n-                ptr::write(xs.unsafe_mut(len),\n-                           value.clone());\n-                xs.len += 1;\n-            }\n-            xs\n+    #[stable]\n+    pub fn reserve(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            let err_msg = \"Vec::reserve: `uint` overflow\";\n+            let new_cap = self.len.checked_add(additional).expect(err_msg)\n+                .checked_next_power_of_two().expect(err_msg);\n+            self.grow_capacity(new_cap);\n         }\n     }\n \n-    /// Appends all elements in a slice to the `Vec<T>`.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `Vec`. Does nothing if the capacity is already\n+    /// sufficient.\n     ///\n-    /// Iterates over the slice `other`, clones each element, and then appends\n-    /// it to this `Vec<T>`. The `other` vector is traversed in-order.\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i];\n-    /// vec.push_all(&[2i, 3, 4]);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n+    /// let mut vec: Vec<int> = vec![1];\n+    /// vec.reserve_exact(10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[inline]\n-    #[experimental]\n-    pub fn push_all(&mut self, other: &[T]) {\n-        self.reserve(other.len());\n-\n-        for i in range(0, other.len()) {\n-            let len = self.len();\n-\n-            // Unsafe code so this can be optimised to a memcpy (or something similarly\n-            // fast) when T is Copy. LLVM is easily confused, so any extra operations\n-            // during the loop can prevent this optimisation.\n-            unsafe {\n-                ptr::write(\n-                    self.unsafe_mut(len),\n-                    other.unsafe_get(i).clone());\n-                self.set_len(len + 1);\n+    #[stable]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            match self.len.checked_add(additional) {\n+                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                Some(new_cap) => self.grow_capacity(new_cap)\n             }\n         }\n     }\n \n-    /// Grows the `Vec<T>` in-place.\n-    ///\n-    /// Adds `n` copies of `value` to the `Vec<T>`.\n+    /// Shrinks the capacity of the vector as much as possible. It will drop\n+    /// down as close as possible to the length but the allocator may still\n+    /// inform the vector that there is space for a few more elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![\"hello\"];\n-    /// vec.grow(2, \"world\");\n-    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n+    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    /// vec.push_all(&[1, 2, 3]);\n+    /// assert_eq!(vec.capacity(), 10);\n+    /// vec.shrink_to_fit();\n+    /// assert!(vec.capacity() >= 3);\n     /// ```\n     #[stable]\n-    pub fn grow(&mut self, n: uint, value: T) {\n-        self.reserve(n);\n-        let mut i: uint = 0u;\n+    pub fn shrink_to_fit(&mut self) {\n+        if mem::size_of::<T>() == 0 { return }\n \n-        while i < n {\n-            self.push(value.clone());\n-            i += 1u;\n+        if self.len == 0 {\n+            if self.cap != 0 {\n+                unsafe {\n+                    dealloc(self.ptr, self.cap)\n+                }\n+                self.cap = 0;\n+            }\n+        } else {\n+            unsafe {\n+                // Overflow check is unnecessary as the vector is already at\n+                // least this large.\n+                self.ptr = reallocate(self.ptr as *mut u8,\n+                                      self.cap * mem::size_of::<T>(),\n+                                      self.len * mem::size_of::<T>(),\n+                                      mem::min_align_of::<T>()) as *mut T;\n+                if self.ptr.is_null() { ::alloc::oom() }\n+            }\n+            self.cap = self.len;\n         }\n     }\n \n-    /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n+    /// Convert the vector into Box<[T]>.\n     ///\n-    /// Calls either `extend()` or `truncate()` depending on whether `new_len`\n-    /// is larger than the current value of `len()` or not.\n+    /// Note that this will drop any excess capacity. Calling this and\n+    /// converting back to a vector with `into_vec()` is equivalent to calling\n+    /// `shrink_to_fit()`.\n+    #[experimental]\n+    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n+        self.shrink_to_fit();\n+        unsafe {\n+            let xs: Box<[T]> = mem::transmute(self.as_mut_slice());\n+            mem::forget(self);\n+            xs\n+        }\n+    }\n+\n+    /// Shorten a vector, dropping excess elements.\n+    ///\n+    /// If `len` is greater than the vector's current length, this has no\n+    /// effect.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![\"hello\"];\n-    /// vec.resize(3, \"world\");\n-    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n-    ///\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.resize(2, 0);\n+    /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n-    pub fn resize(&mut self, new_len: uint, value: T) {\n-        let len = self.len();\n-\n-        if new_len > len {\n-            self.extend(repeat(value).take(new_len - len));\n-        } else {\n-            self.truncate(new_len);\n+    #[stable]\n+    pub fn truncate(&mut self, len: uint) {\n+        unsafe {\n+            // drop any extra elements\n+            while len < self.len {\n+                // decrement len before the read(), so a panic on Drop doesn't\n+                // re-drop the just-failed value.\n+                self.len -= 1;\n+                ptr::read(self.get_unchecked(self.len));\n+            }\n         }\n     }\n \n-    /// Partitions a vector based on a predicate.\n-    ///\n-    /// Clones the elements of the vector, partitioning them into two `Vec<T>`s\n-    /// `(a, b)`, where all elements of `a` satisfy `f` and all elements of `b`\n-    /// do not. The order of elements is preserved.\n+    /// Returns a mutable slice of the elements of `self`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// let (even, odd) = vec.partitioned(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec![2i, 4]);\n-    /// assert_eq!(odd, vec![1i, 3]);\n+    /// fn foo(slice: &mut [int]) {}\n+    ///\n+    /// let mut vec = vec![1i, 2];\n+    /// foo(vec.as_mut_slice());\n     /// ```\n-    #[experimental]\n-    pub fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        let mut lefts = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.iter() {\n-            if f(elt) {\n-                lefts.push(elt.clone());\n-            } else {\n-                rights.push(elt.clone());\n-            }\n-        }\n-\n-        (lefts, rights)\n-    }\n-}\n-\n-#[stable]\n-impl<T:Clone> Clone for Vec<T> {\n-    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n-\n-    fn clone_from(&mut self, other: &Vec<T>) {\n-        // drop anything in self that will not be overwritten\n-        if self.len() > other.len() {\n-            self.truncate(other.len())\n-        }\n-\n-        // reuse the contained values' allocations/resources.\n-        for (place, thing) in self.iter_mut().zip(other.iter()) {\n-            place.clone_from(thing)\n+    #[inline]\n+    #[stable]\n+    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        unsafe {\n+            mem::transmute(RawSlice {\n+                data: self.ptr as *const T,\n+                len: self.len,\n+            })\n         }\n-\n-        // self.len <= other.len due to the truncate above, so the\n-        // slice here is always in-bounds.\n-        let slice = other[self.len()..];\n-        self.push_all(slice);\n     }\n-}\n \n-#[experimental = \"waiting on Index stability\"]\n-impl<T> Index<uint,T> for Vec<T> {\n+    /// Creates a consuming iterator, that is, one that moves each\n+    /// value out of the vector (from start to end). The vector cannot\n+    /// be used after calling this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n+    /// for s in v.into_iter() {\n+    ///     // s has type String, not &String\n+    ///     println!(\"{}\", s);\n+    /// }\n+    /// ```\n     #[inline]\n-    fn index<'a>(&'a self, index: &uint) -> &'a T {\n-        &self.as_slice()[*index]\n+    #[stable]\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        unsafe {\n+            let ptr = self.ptr;\n+            let cap = self.cap;\n+            let begin = self.ptr as *const T;\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as uint + self.len()) as *const T\n+            } else {\n+                ptr.offset(self.len() as int) as *const T\n+            };\n+            mem::forget(self);\n+            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n+        }\n     }\n-}\n \n-impl<T> IndexMut<uint,T> for Vec<T> {\n+    /// Sets the length of a vector.\n+    ///\n+    /// This will explicitly set the size of the vector, without actually modifying its buffers, so\n+    /// it is up to the caller to ensure that the vector is actually the specified size.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = vec![1u, 2, 3, 4];\n+    /// unsafe {\n+    ///     v.set_len(1);\n+    /// }\n+    /// ```\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n-        &mut self.as_mut_slice()[*index]\n-    }\n-}\n-\n-impl<T> ops::Slice<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self.as_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.as_slice().slice_from_or_fail(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_to_or_fail(end)\n-    }\n-    #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_or_fail(start, end)\n-    }\n-}\n-\n-impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self.as_mut_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_or_fail_mut(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_or_fail_mut(end)\n-    }\n-    #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_or_fail_mut(start, end)\n-    }\n-}\n-\n-#[experimental = \"waiting on Deref stability\"]\n-impl<T> ops::Deref<[T]> for Vec<T> {\n-    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n-}\n-\n-#[experimental = \"waiting on DerefMut stability\"]\n-impl<T> ops::DerefMut<[T]> for Vec<T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n-}\n-\n-#[experimental = \"waiting on FromIterator stability\"]\n-impl<T> FromIterator<T> for Vec<T> {\n-    #[inline]\n-    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n-        let (lower, _) = iterator.size_hint();\n-        let mut vector = Vec::with_capacity(lower);\n-        for element in iterator {\n-            vector.push(element)\n-        }\n-        vector\n-    }\n-}\n-\n-#[experimental = \"waiting on Extend stability\"]\n-impl<T> Extend<T> for Vec<T> {\n-    #[inline]\n-    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n-        let (lower, _) = iterator.size_hint();\n-        self.reserve(lower);\n-        for element in iterator {\n-            self.push(element)\n-        }\n-    }\n-}\n-\n-impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq {\n-    ($lhs:ty, $rhs:ty) => {\n-        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-    }\n-}\n-\n-impl_eq! { Vec<A>, &'b [B] }\n-impl_eq! { Vec<A>, &'b mut [B] }\n-\n-impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n-    #[inline]\n-    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n-    #[inline]\n-    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n-    #[inline]\n-    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n-}\n-\n-macro_rules! impl_eq_for_cowvec {\n-    ($rhs:ty) => {\n-        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-\n-        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n-            #[inline]\n-            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n-        }\n-    }\n-}\n-\n-impl_eq_for_cowvec! { &'b [B] }\n-impl_eq_for_cowvec! { &'b mut [B] }\n-\n-#[unstable = \"waiting on PartialOrd stability\"]\n-impl<T: PartialOrd> PartialOrd for Vec<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n-        self.as_slice().partial_cmp(other.as_slice())\n-    }\n-}\n-\n-#[unstable = \"waiting on Eq stability\"]\n-impl<T: Eq> Eq for Vec<T> {}\n-\n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n-    #[inline]\n-    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-}\n-\n-#[unstable = \"waiting on Ord stability\"]\n-impl<T: Ord> Ord for Vec<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Vec<T>) -> Ordering {\n-        self.as_slice().cmp(other.as_slice())\n-    }\n-}\n-\n-impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-\n-// FIXME: #13996: need a way to mark the return value as `noalias`\n-#[inline(never)]\n-unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n-    if old_size == 0 {\n-        allocate(size, mem::min_align_of::<T>()) as *mut T\n-    } else {\n-        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n-    }\n-}\n-\n-#[inline]\n-unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n-    if mem::size_of::<T>() != 0 {\n-        deallocate(ptr as *mut u8,\n-                   len * mem::size_of::<T>(),\n-                   mem::min_align_of::<T>())\n-    }\n-}\n-\n-impl<T> Vec<T> {\n-    /// Returns the number of elements the vector can hold without reallocating.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec: Vec<int> = Vec::with_capacity(10);\n-    /// assert_eq!(vec.capacity(), 10);\n-    /// ```\n-    #[inline]\n-    #[stable]\n-    pub fn capacity(&self) -> uint {\n-        self.cap\n-    }\n-\n-    /// Deprecated: Renamed to `reserve`.\n-    #[deprecated = \"Renamed to `reserve`\"]\n-    pub fn reserve_additional(&mut self, extra: uint) {\n-        self.reserve(extra)\n-    }\n-\n-    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `uint`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec: Vec<int> = vec![1];\n-    /// vec.reserve(10);\n-    /// assert!(vec.capacity() >= 11);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve(&mut self, additional: uint) {\n-        if self.cap - self.len < additional {\n-            let err_msg = \"Vec::reserve: `uint` overflow\";\n-            let new_cap = self.len.checked_add(additional).expect(err_msg)\n-                                  .checked_next_power_of_two().expect(err_msg);\n-            self.grow_capacity(new_cap);\n-        }\n-    }\n-\n-    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `Vec<T>`. Does nothing if the capacity is already sufficient.\n-    ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n-    /// insertions are expected.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `uint`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec: Vec<int> = vec![1];\n-    /// vec.reserve_exact(10);\n-    /// assert!(vec.capacity() >= 11);\n-    /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n-        if self.cap - self.len < additional {\n-            match self.len.checked_add(additional) {\n-                None => panic!(\"Vec::reserve: `uint` overflow\"),\n-                Some(new_cap) => self.grow_capacity(new_cap)\n-            }\n-        }\n-    }\n-\n-    /// Shrinks the capacity of the vector as much as possible.\n-    ///\n-    /// It will drop down as close as possible to the length but the allocator may still inform the\n-    /// vector that there is space for a few more elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n-    ///\n-    /// vec.push_all(&[1, 2, 3]);\n-    /// assert_eq!(vec.capacity(), 10);\n-    ///\n-    /// vec.shrink_to_fit();\n-    /// assert!(vec.capacity() >= 3);\n-    /// ```\n-    #[stable]\n-    pub fn shrink_to_fit(&mut self) {\n-        if mem::size_of::<T>() == 0 { return }\n-\n-        if self.len == 0 {\n-            if self.cap != 0 {\n-                unsafe {\n-                    dealloc(*self.ptr, self.cap)\n-                }\n-                self.cap = 0;\n-            }\n-        } else {\n-            unsafe {\n-                // Overflow check is unnecessary as the vector is already at\n-                // least this large.\n-                let ptr = reallocate(*self.ptr as *mut u8,\n-                                     self.cap * mem::size_of::<T>(),\n-                                     self.len * mem::size_of::<T>(),\n-                                     mem::min_align_of::<T>()) as *mut T;\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n-            }\n-            self.cap = self.len;\n-        }\n-    }\n-\n-    /// Convert the vector into Box<[T]>.\n-    ///\n-    /// Note that this will drop any excess capacity. Calling this and converting back to a vector\n-    /// with `into_vec()` is equivalent to calling `shrink_to_fit()`.\n-    #[experimental]\n-    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n-        self.shrink_to_fit();\n-        unsafe {\n-            let xs: Box<[T]> = mem::transmute(self.as_mut_slice());\n-            mem::forget(self);\n-            xs\n-        }\n-    }\n-\n-    /// Shorten a vector, dropping excess elements.\n-    ///\n-    /// If `len` is greater than the vector's current length, this has no\n-    /// effect.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.truncate(2);\n-    /// assert_eq!(vec, vec![1, 2]);\n-    /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n-    pub fn truncate(&mut self, len: uint) {\n-        unsafe {\n-            // drop any extra elements\n-            while len < self.len {\n-                // decrement len before the read(), so a panic on Drop doesn't\n-                // re-drop the just-failed value.\n-                self.len -= 1;\n-                ptr::read(self.unsafe_get(self.len));\n-            }\n-        }\n-    }\n-\n-    /// Returns a mutable slice of the elements of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// fn foo(slice: &mut [int]) {}\n-    ///\n-    /// let mut vec = vec![1i, 2];\n-    /// foo(vec.as_mut_slice());\n-    /// ```\n-    #[inline]\n-    #[stable]\n-    pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        unsafe {\n-            mem::transmute(RawSlice {\n-                data: *self.ptr as *const T,\n-                len: self.len,\n-            })\n-        }\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each value out of the vector (from\n-    /// start to end). The vector cannot be used after calling this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n-    ///\n-    /// for s in v.into_iter() {\n-    ///     // s has type String, not &String\n-    ///     println!(\"{}\", s);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        unsafe {\n-            let ptr = *self.ptr;\n-            let cap = self.cap;\n-            let begin = ptr as *const T;\n-            let end = if mem::size_of::<T>() == 0 {\n-                (ptr as uint + self.len()) as *const T\n-            } else {\n-                ptr.offset(self.len() as int) as *const T\n-            };\n-            mem::forget(self);\n-            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n-        }\n-    }\n-\n-    /// Sets the length of a vector.\n-    ///\n-    /// This will explicitly set the size of the vector, without actually modifying its buffers, so\n-    /// it is up to the caller to ensure that the vector is actually the specified size.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut v = vec![1u, 2, 3, 4];\n-    /// unsafe {\n-    ///     v.set_len(1);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[stable]\n-    pub unsafe fn set_len(&mut self, len: uint) {\n-        self.len = len;\n+    #[stable]\n+    pub unsafe fn set_len(&mut self, len: uint) {\n+        self.len = len;\n     }\n \n     /// Removes an element from anywhere in the vector and return it, replacing it with the last\n     /// element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n-    /// Returns `None` if `index` is out of bounds.\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is out of bounds.\n     ///\n     /// # Examples\n     ///\n@@ -948,15 +521,11 @@ impl<T> Vec<T> {\n     /// assert_eq!(v.swap_remove(2), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"the naming of this function may be altered\"]\n-    pub fn swap_remove(&mut self, index: uint) -> Option<T> {\n+    #[stable]\n+    pub fn swap_remove(&mut self, index: uint) -> T {\n         let length = self.len();\n-        if length > 0 && index < length - 1 {\n-            self.swap(index, length - 1);\n-        } else if index >= length {\n-            return None\n-        }\n-        self.pop()\n+        self.swap(index, length - 1);\n+        self.pop().unwrap()\n     }\n \n     /// Inserts an element at position `index` within the vector, shifting all elements after\n@@ -975,7 +544,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[unstable = \"panic semantics need settling\"]\n+    #[stable]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -997,9 +566,12 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes and returns the element at position `index` within the vector, shifting all\n-    /// elements after position `index` one position to the left. Returns `None` if `i` is out of\n-    /// bounds.\n+    /// Removes and returns the element at position `index` within the vector,\n+    /// shifting all elements after position `index` one position to the left.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `i` is out of bounds.\n     ///\n     /// # Examples\n     ///\n@@ -1012,27 +584,24 @@ impl<T> Vec<T> {\n     /// // v is unchanged:\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[unstable = \"panic semantics need settling\"]\n-    pub fn remove(&mut self, index: uint) -> Option<T> {\n+    #[stable]\n+    pub fn remove(&mut self, index: uint) -> T {\n         let len = self.len();\n-        if index < len {\n-            unsafe { // infallible\n-                let ret;\n-                {\n-                    // the place we are taking from.\n-                    let ptr = self.as_mut_ptr().offset(index as int);\n-                    // copy it out, unsafely having a copy of the value on\n-                    // the stack and in the vector at the same time.\n-                    ret = Some(ptr::read(ptr as *const T));\n-\n-                    // Shift everything down to fill in that spot.\n-                    ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n-                }\n-                self.set_len(len - 1);\n-                ret\n+        assert!(index < len);\n+        unsafe { // infallible\n+            let ret;\n+            {\n+                // the place we are taking from.\n+                let ptr = self.as_mut_ptr().offset(index as int);\n+                // copy it out, unsafely having a copy of the value on\n+                // the stack and in the vector at the same time.\n+                ret = ptr::read(ptr as *const T);\n+\n+                // Shift everything down to fill in that spot.\n+                ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n             }\n-        } else {\n-            None\n+            self.set_len(len - 1);\n+            ret\n         }\n     }\n \n@@ -1048,7 +617,7 @@ impl<T> Vec<T> {\n     /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n-    #[unstable = \"the closure argument may become an unboxed closure\"]\n+    #[stable]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n         let mut del = 0u;\n@@ -1068,24 +637,10 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Expands a vector in place, initializing the new elements to the result of a function.\n-    ///\n-    /// The vector is grown by `n` elements. The i-th new element are initialized to the value\n-    /// returned by `f(i)` where `i` is in the range [0, n).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec![0u, 1];\n-    /// vec.grow_fn(3, |i| i);\n-    /// assert_eq!(vec, vec![0, 1, 0, 1, 2]);\n-    /// ```\n-    #[unstable = \"this function may be renamed or change to unboxed closures\"]\n-    pub fn grow_fn<F>(&mut self, n: uint, mut f: F) where F: FnMut(uint) -> T {\n-        self.reserve(n);\n-        for i in range(0u, n) {\n-            self.push(f(i));\n-        }\n+    /// Deprecated: use `extend(range(0, n).map(f))` instead.\n+    #[deprecated = \"use extend(range(0, n).map(f)) instead\"]\n+    pub fn grow_fn<F>(&mut self, n: uint, f: F) where F: FnMut(uint) -> T {\n+        self.extend(range(0, n).map(f));\n     }\n \n     /// Appends an element to the back of a collection.\n@@ -1146,7 +701,7 @@ impl<T> Vec<T> {\n         } else {\n             unsafe {\n                 self.len -= 1;\n-                Some(ptr::read(self.unsafe_get(self.len())))\n+                Some(ptr::read(self.get_unchecked(self.len())))\n             }\n         }\n     }\n@@ -1223,27 +778,285 @@ impl<T> Vec<T> {\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n+    /// size and in case they are not zero-sized the same minimal alignment.\n     ///\n-    /// If the capacity for `self` is already equal to or greater than the\n-    /// requested capacity, then no action is taken.\n-    fn grow_capacity(&mut self, capacity: uint) {\n-        if mem::size_of::<T>() == 0 { return }\n+    /// # Panics\n+    ///\n+    /// Panics if `T` and `U` have differing sizes or are not zero-sized and\n+    /// have differing minimal alignments.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![0u, 1, 2];\n+    /// let w = v.map_in_place(|i| i + 3);\n+    /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n+    ///\n+    /// #[deriving(PartialEq, Show)]\n+    /// struct Newtype(u8);\n+    /// let bytes = vec![0x11, 0x22];\n+    /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n+    /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n+    /// ```\n+    #[experimental = \"API may change to provide stronger guarantees\"]\n+    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n+        // FIXME: Assert statically that the types `T` and `U` have the same\n+        // size.\n+        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n \n-        if capacity > self.cap {\n-            let size = capacity.checked_mul(mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n+        let mut vec = self;\n+\n+        if mem::size_of::<T>() != 0 {\n+            // FIXME: Assert statically that the types `T` and `U` have the\n+            // same minimal alignment in case they are not zero-sized.\n+\n+            // These asserts are necessary because the `min_align_of` of the\n+            // types are passed to the allocator by `Vec`.\n+            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n+\n+            // This `as int` cast is safe, because the size of the elements of the\n+            // vector is not 0, and:\n+            //\n+            // 1) If the size of the elements in the vector is 1, the `int` may\n+            //    overflow, but it has the correct bit pattern so that the\n+            //    `.offset()` function will work.\n+            //\n+            //    Example:\n+            //        Address space 0x0-0xF.\n+            //        `u8` array at: 0x1.\n+            //        Size of `u8` array: 0x8.\n+            //        Calculated `offset`: -0x8.\n+            //        After `array.offset(offset)`: 0x9.\n+            //        (0x1 + 0x8 = 0x1 - 0x8)\n+            //\n+            // 2) If the size of the elements in the vector is >1, the `uint` ->\n+            //    `int` conversion can't overflow.\n+            let offset = vec.len() as int;\n+            let start = vec.as_mut_ptr();\n+\n+            let mut pv = PartialVecNonZeroSized {\n+                vec: vec,\n+\n+                start_t: start,\n+                // This points inside the vector, as the vector has length\n+                // `offset`.\n+                end_t: unsafe { start.offset(offset) },\n+                start_u: start as *mut U,\n+                end_u: start as *mut U,\n+            };\n+            //  start_t\n+            //  start_u\n+            //  |\n+            // +-+-+-+-+-+-+\n+            // |T|T|T|...|T|\n+            // +-+-+-+-+-+-+\n+            //  |           |\n+            //  end_u       end_t\n+\n+            while pv.end_u as *mut T != pv.end_t {\n+                unsafe {\n+                    //  start_u start_t\n+                    //  |       |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|T|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+\n+                    let t = ptr::read(pv.start_t as *const T);\n+                    //  start_u start_t\n+                    //  |       |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|X|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We must not panic here, one cell is marked as `T`\n+                    // although it is not `T`.\n+\n+                    pv.start_t = pv.start_t.offset(1);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|X|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We may panic again.\n+\n+                    // The function given by the user might panic.\n+                    let u = f(t);\n+\n+                    ptr::write(pv.end_u, u);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|U|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //          |         |\n+                    //          end_u     end_t\n+                    // We should not panic here, because that would leak the `U`\n+                    // pointed to by `end_u`.\n+\n+                    pv.end_u = pv.end_u.offset(1);\n+                    //  start_u   start_t\n+                    //  |         |\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    // |U|...|U|U|T|...|T|\n+                    // +-+-+-+-+-+-+-+-+-+\n+                    //            |       |\n+                    //            end_u   end_t\n+                    // We may panic again.\n+                }\n+            }\n+\n+            //  start_u     start_t\n+            //  |           |\n+            // +-+-+-+-+-+-+\n+            // |U|...|U|U|U|\n+            // +-+-+-+-+-+-+\n+            //              |\n+            //              end_t\n+            //              end_u\n+            // Extract `vec` and prevent the destructor of\n+            // `PartialVecNonZeroSized` from running. Note that none of the\n+            // function calls can panic, thus no resources can be leaked (as the\n+            // `vec` member of `PartialVec` is the only one which holds\n+            // allocations -- and it is returned from this function. None of\n+            // this can panic.\n+            unsafe {\n+                let vec_len = pv.vec.len();\n+                let vec_cap = pv.vec.capacity();\n+                let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n+                mem::forget(pv);\n+                Vec::from_raw_parts(vec_ptr, vec_len, vec_cap)\n+            }\n+        } else {\n+            // Put the `Vec` into the `PartialVecZeroSized` structure and\n+            // prevent the destructor of the `Vec` from running. Since the\n+            // `Vec` contained zero-sized objects, it did not allocate, so we\n+            // are not leaking memory here.\n+            let mut pv = PartialVecZeroSized::<T,U> {\n+                num_t: vec.len(),\n+                num_u: 0,\n+                marker_t: InvariantType,\n+                marker_u: InvariantType,\n+            };\n+            unsafe { mem::forget(vec); }\n+\n+            while pv.num_t != 0 {\n+                unsafe {\n+                    // Create a `T` out of thin air and decrement `num_t`. This\n+                    // must not panic between these steps, as otherwise a\n+                    // destructor of `T` which doesn't exist runs.\n+                    let t = mem::uninitialized();\n+                    pv.num_t -= 1;\n+\n+                    // The function given by the user might panic.\n+                    let u = f(t);\n+\n+                    // Forget the `U` and increment `num_u`. This increment\n+                    // cannot overflow the `uint` as we only do this for a\n+                    // number of times that fits into a `uint` (and start with\n+                    // `0`). Again, we should not panic between these steps.\n+                    mem::forget(u);\n+                    pv.num_u += 1;\n+                }\n+            }\n+            // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n+            // destructor of the latter will not run. None of this can panic.\n+            let mut result = Vec::new();\n+            unsafe {\n+                result.set_len(pv.num_u);\n+                mem::forget(pv);\n+            }\n+            result\n+        }\n+    }\n+}\n+\n+impl<T: Clone> Vec<T> {\n+    /// Deprecated: use `repeat(value).take(length).collect()` instead.\n+    #[inline]\n+    #[deprecated = \"use repeat(value).take(length).collect() instead\"]\n+    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n+        repeat(value).take(length).collect()\n+    }\n+\n+    /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n+    ///\n+    /// Calls either `extend()` or `truncate()` depending on whether `new_len`\n+    /// is larger than the current value of `len()` or not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut vec = vec![\"hello\"];\n+    /// vec.resize(3, \"world\");\n+    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n+    ///\n+    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// vec.resize(2, 0);\n+    /// assert_eq!(vec, vec![1, 2]);\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n+    pub fn resize(&mut self, new_len: uint, value: T) {\n+        let len = self.len();\n+\n+        if new_len > len {\n+            self.extend(repeat(value).take(new_len - len));\n+        } else {\n+            self.truncate(new_len);\n+        }\n+    }\n+\n+    /// Appends all elements in a slice to the `Vec`.\n+    ///\n+    /// Iterates over the slice `other`, clones each element, and then appends\n+    /// it to this `Vec`. The `other` vector is traversed in-order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut vec = vec![1i];\n+    /// vec.push_all(&[2i, 3, 4]);\n+    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n+    /// ```\n+    #[inline]\n+    #[experimental = \"likely to be replaced by a more optimized extend\"]\n+    pub fn push_all(&mut self, other: &[T]) {\n+        self.reserve(other.len());\n+\n+        for i in range(0, other.len()) {\n+            let len = self.len();\n+\n+            // Unsafe code so this can be optimised to a memcpy (or something similarly\n+            // fast) when T is Copy. LLVM is easily confused, so any extra operations\n+            // during the loop can prevent this optimisation.\n             unsafe {\n-                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+                ptr::write(\n+                    self.get_unchecked_mut(len),\n+                    other.get_unchecked(i).clone());\n+                self.set_len(len + 1);\n             }\n-            self.cap = capacity;\n         }\n     }\n+\n+    /// Deprecated: use `extend(repeat(value).take(n))` instead\n+    #[deprecated = \"use extend(repeat(value).take(n)) instead\"]\n+    pub fn grow(&mut self, n: uint, value: T) {\n+        self.extend(repeat(value).take(n))\n+    }\n+\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    pub fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.iter().cloned().partition(f)\n+    }\n }\n \n impl<T: PartialEq> Vec<T> {\n@@ -1260,7 +1073,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n-    #[unstable = \"this function may be renamed\"]\n+    #[stable]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1341,8 +1154,275 @@ impl<T: PartialEq> Vec<T> {\n                 r += 1;\n             }\n \n-            self.truncate(w);\n-        }\n+            self.truncate(w);\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Public free fns\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Deprecated: use `unzip` directly on the iterator instead.\n+#[deprecated = \"use unzip directly on the iterator instead\"]\n+pub fn unzip<T, U, V: Iterator<(T, U)>>(iter: V) -> (Vec<T>, Vec<U>) {\n+    iter.unzip()\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Internal methods and functions\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl<T> Vec<T> {\n+    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    ///\n+    /// If the capacity for `self` is already equal to or greater than the\n+    /// requested capacity, then no action is taken.\n+    fn grow_capacity(&mut self, capacity: uint) {\n+        if mem::size_of::<T>() == 0 { return }\n+\n+        if capacity > self.cap {\n+            let size = capacity.checked_mul(mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n+            unsafe {\n+                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n+                if self.ptr.is_null() { ::alloc::oom() }\n+            }\n+            self.cap = capacity;\n+        }\n+    }\n+}\n+\n+// FIXME: #13996: need a way to mark the return value as `noalias`\n+#[inline(never)]\n+unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n+    if old_size == 0 {\n+        allocate(size, mem::min_align_of::<T>()) as *mut T\n+    } else {\n+        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n+    }\n+}\n+\n+#[inline]\n+unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n+    if mem::size_of::<T>() != 0 {\n+        deallocate(ptr as *mut u8,\n+                   len * mem::size_of::<T>(),\n+                   mem::min_align_of::<T>())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Common trait implementations for Vec\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[unstable]\n+impl<T:Clone> Clone for Vec<T> {\n+    fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n+\n+    fn clone_from(&mut self, other: &Vec<T>) {\n+        // drop anything in self that will not be overwritten\n+        if self.len() > other.len() {\n+            self.truncate(other.len())\n+        }\n+\n+        // reuse the contained values' allocations/resources.\n+        for (place, thing) in self.iter_mut().zip(other.iter()) {\n+            place.clone_from(thing)\n+        }\n+\n+        // self.len <= other.len due to the truncate above, so the\n+        // slice here is always in-bounds.\n+        let slice = other[self.len()..];\n+        self.push_all(slice);\n+    }\n+}\n+\n+impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n+\n+#[experimental = \"waiting on Index stability\"]\n+impl<T> Index<uint,T> for Vec<T> {\n+    #[inline]\n+    fn index<'a>(&'a self, index: &uint) -> &'a T {\n+        &self.as_slice()[*index]\n+    }\n+}\n+\n+impl<T> IndexMut<uint,T> for Vec<T> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n+        &mut self.as_mut_slice()[*index]\n+    }\n+}\n+\n+impl<T> ops::Slice<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_slice_<'a>(&'a self) -> &'a [T] {\n+        self.as_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.as_slice().slice_from_or_fail(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_to_or_fail(end)\n+    }\n+    #[inline]\n+    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        self.as_slice().slice_or_fail(start, end)\n+    }\n+}\n+\n+impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n+        self.as_mut_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_from_or_fail_mut(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_to_or_fail_mut(end)\n+    }\n+    #[inline]\n+    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_or_fail_mut(start, end)\n+    }\n+}\n+\n+#[experimental = \"waiting on Deref stability\"]\n+impl<T> ops::Deref<[T]> for Vec<T> {\n+    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n+}\n+\n+#[experimental = \"waiting on DerefMut stability\"]\n+impl<T> ops::DerefMut<[T]> for Vec<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n+}\n+\n+#[experimental = \"waiting on FromIterator stability\"]\n+impl<T> FromIterator<T> for Vec<T> {\n+    #[inline]\n+    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n+        let (lower, _) = iterator.size_hint();\n+        let mut vector = Vec::with_capacity(lower);\n+        for element in iterator {\n+            vector.push(element)\n+        }\n+        vector\n+    }\n+}\n+\n+#[experimental = \"waiting on Extend stability\"]\n+impl<T> Extend<T> for Vec<T> {\n+    #[inline]\n+    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n+        let (lower, _) = iterator.size_hint();\n+        self.reserve(lower);\n+        for element in iterator {\n+            self.push(element)\n+        }\n+    }\n+}\n+\n+impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n+    #[inline]\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq {\n+    ($lhs:ty, $rhs:ty) => {\n+        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+    }\n+}\n+\n+impl_eq! { Vec<A>, &'b [B] }\n+impl_eq! { Vec<A>, &'b mut [B] }\n+\n+impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+    #[inline]\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n+    #[inline]\n+    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq_for_cowvec {\n+    ($rhs:ty) => {\n+        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+    }\n+}\n+\n+impl_eq_for_cowvec! { &'b [B] }\n+impl_eq_for_cowvec! { &'b mut [B] }\n+\n+#[unstable = \"waiting on PartialOrd stability\"]\n+impl<T: PartialOrd> PartialOrd for Vec<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(other.as_slice())\n+    }\n+}\n+\n+#[unstable = \"waiting on Eq stability\"]\n+impl<T: Eq> Eq for Vec<T> {}\n+\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n+impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n+    #[inline]\n+    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+}\n+\n+#[unstable = \"waiting on Ord stability\"]\n+impl<T: Ord> Ord for Vec<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Vec<T>) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n     }\n }\n \n@@ -1408,17 +1488,58 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n     }\n }\n \n+impl<'a> fmt::FormatWriter for Vec<u8> {\n+    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+        self.push_all(buf);\n+        Ok(())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Clone-on-write\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[experimental = \"unclear how valuable this alias is\"]\n+/// A clone-on-write vector\n+pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n+\n+impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n+    fn from_iter<I: Iterator<T>>(it: I) -> CowVec<'a, T> {\n+        Cow::Owned(FromIterator::from_iter(it))\n+    }\n+}\n+\n+impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n+    fn into_cow(self) -> CowVec<'a, T> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n+impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n+    fn into_cow(self) -> CowVec<'a, T> {\n+        Cow::Borrowed(self)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Iterators\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// An iterator that moves out of a vector.\n+#[stable]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n     ptr: *const T,\n     end: *const T\n }\n \n+#[deprecated = \"use IntoIter instead\"]\n+pub type MoveItems<T> = IntoIter<T>;\n+\n impl<T> IntoIter<T> {\n-    /// Drops all items that have not yet been moved and returns the empty vector.\n     #[inline]\n+    /// Drops all items that have not yet been moved and returns the empty vector.\n     #[unstable]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n@@ -1508,6 +1629,7 @@ impl<T> Drop for IntoIter<T> {\n \n /// An iterator that drains a vector.\n #[unsafe_no_drop_flag]\n+#[unstable = \"recently added as part of collections reform 2\"]\n pub struct Drain<'a, T> {\n     ptr: *const T,\n     end: *const T,\n@@ -1584,22 +1706,9 @@ impl<'a, T> Drop for Drain<'a, T> {\n     }\n }\n \n-/// Converts an iterator of pairs into a pair of vectors.\n-///\n-/// Returns a tuple containing two vectors where the i-th element of the first vector contains the\n-/// first element of the i-th tuple of the input iterator, and the i-th element of the second\n-/// vector contains the second element of the i-th tuple of the input iterator.\n-#[unstable = \"this functionality may become more generic over time\"]\n-pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n-    let (lo, _) = iter.size_hint();\n-    let mut ts = Vec::with_capacity(lo);\n-    let mut us = Vec::with_capacity(lo);\n-    for (t, u) in iter {\n-        ts.push(t);\n-        us.push(u);\n-    }\n-    (ts, us)\n-}\n+////////////////////////////////////////////////////////////////////////////////\n+// Conversion from &[T] to &Vec<T>\n+////////////////////////////////////////////////////////////////////////////////\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n #[experimental]\n@@ -1608,6 +1717,7 @@ pub struct DerefVec<'a, T> {\n     l: ContravariantLifetime<'a>\n }\n \n+#[experimental]\n impl<'a, T> Deref<Vec<T>> for DerefVec<'a, T> {\n     fn deref<'b>(&'b self) -> &'b Vec<T> {\n         &self.x\n@@ -1616,6 +1726,7 @@ impl<'a, T> Deref<Vec<T>> for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n+#[experimental]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;\n@@ -1634,6 +1745,10 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Raw module (deprecated)\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Unsafe vector operations.\n #[deprecated]\n pub mod raw {\n@@ -1650,6 +1765,10 @@ pub mod raw {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Partial vec, used for map_in_place\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// An owned, partially type-converted vector of elements with non-zero size.\n ///\n /// `T` and `U` must have the same, non-zero size. They must also have the same\n@@ -1721,211 +1840,6 @@ impl<T,U> Drop for PartialVecZeroSized<T,U> {\n     }\n }\n \n-impl<T> Vec<T> {\n-    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n-    /// size and in case they are not zero-sized the same minimal alignment.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `T` and `U` have differing sizes or are not zero-sized and\n-    /// have differing minimal alignments.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = vec![0u, 1, 2];\n-    /// let w = v.map_in_place(|i| i + 3);\n-    /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n-    ///\n-    /// #[deriving(PartialEq, Show)]\n-    /// struct Newtype(u8);\n-    /// let bytes = vec![0x11, 0x22];\n-    /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n-    /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n-    /// ```\n-    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n-        // FIXME: Assert statically that the types `T` and `U` have the same\n-        // size.\n-        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n-\n-        let mut vec = self;\n-\n-        if mem::size_of::<T>() != 0 {\n-            // FIXME: Assert statically that the types `T` and `U` have the\n-            // same minimal alignment in case they are not zero-sized.\n-\n-            // These asserts are necessary because the `min_align_of` of the\n-            // types are passed to the allocator by `Vec`.\n-            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n-\n-            // This `as int` cast is safe, because the size of the elements of the\n-            // vector is not 0, and:\n-            //\n-            // 1) If the size of the elements in the vector is 1, the `int` may\n-            //    overflow, but it has the correct bit pattern so that the\n-            //    `.offset()` function will work.\n-            //\n-            //    Example:\n-            //        Address space 0x0-0xF.\n-            //        `u8` array at: 0x1.\n-            //        Size of `u8` array: 0x8.\n-            //        Calculated `offset`: -0x8.\n-            //        After `array.offset(offset)`: 0x9.\n-            //        (0x1 + 0x8 = 0x1 - 0x8)\n-            //\n-            // 2) If the size of the elements in the vector is >1, the `uint` ->\n-            //    `int` conversion can't overflow.\n-            let offset = vec.len() as int;\n-            let start = vec.as_mut_ptr();\n-\n-            let mut pv = PartialVecNonZeroSized {\n-                vec: vec,\n-\n-                start_t: start,\n-                // This points inside the vector, as the vector has length\n-                // `offset`.\n-                end_t: unsafe { start.offset(offset) },\n-                start_u: start as *mut U,\n-                end_u: start as *mut U,\n-            };\n-            //  start_t\n-            //  start_u\n-            //  |\n-            // +-+-+-+-+-+-+\n-            // |T|T|T|...|T|\n-            // +-+-+-+-+-+-+\n-            //  |           |\n-            //  end_u       end_t\n-\n-            while pv.end_u as *mut T != pv.end_t {\n-                unsafe {\n-                    //  start_u start_t\n-                    //  |       |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|T|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-\n-                    let t = ptr::read(pv.start_t as *const T);\n-                    //  start_u start_t\n-                    //  |       |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|X|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We must not panic here, one cell is marked as `T`\n-                    // although it is not `T`.\n-\n-                    pv.start_t = pv.start_t.offset(1);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|X|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We may panic again.\n-\n-                    // The function given by the user might panic.\n-                    let u = f(t);\n-\n-                    ptr::write(pv.end_u, u);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|U|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We should not panic here, because that would leak the `U`\n-                    // pointed to by `end_u`.\n-\n-                    pv.end_u = pv.end_u.offset(1);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|U|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //            |       |\n-                    //            end_u   end_t\n-                    // We may panic again.\n-                }\n-            }\n-\n-            //  start_u     start_t\n-            //  |           |\n-            // +-+-+-+-+-+-+\n-            // |U|...|U|U|U|\n-            // +-+-+-+-+-+-+\n-            //              |\n-            //              end_t\n-            //              end_u\n-            // Extract `vec` and prevent the destructor of\n-            // `PartialVecNonZeroSized` from running. Note that none of the\n-            // function calls can panic, thus no resources can be leaked (as the\n-            // `vec` member of `PartialVec` is the only one which holds\n-            // allocations -- and it is returned from this function. None of\n-            // this can panic.\n-            unsafe {\n-                let vec_len = pv.vec.len();\n-                let vec_cap = pv.vec.capacity();\n-                let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n-                mem::forget(pv);\n-                Vec::from_raw_parts(vec_ptr, vec_len, vec_cap)\n-            }\n-        } else {\n-            // Put the `Vec` into the `PartialVecZeroSized` structure and\n-            // prevent the destructor of the `Vec` from running. Since the\n-            // `Vec` contained zero-sized objects, it did not allocate, so we\n-            // are not leaking memory here.\n-            let mut pv = PartialVecZeroSized::<T,U> {\n-                num_t: vec.len(),\n-                num_u: 0,\n-                marker_t: InvariantType,\n-                marker_u: InvariantType,\n-            };\n-            unsafe { mem::forget(vec); }\n-\n-            while pv.num_t != 0 {\n-                unsafe {\n-                    // Create a `T` out of thin air and decrement `num_t`. This\n-                    // must not panic between these steps, as otherwise a\n-                    // destructor of `T` which doesn't exist runs.\n-                    let t = mem::uninitialized();\n-                    pv.num_t -= 1;\n-\n-                    // The function given by the user might panic.\n-                    let u = f(t);\n-\n-                    // Forget the `U` and increment `num_u`. This increment\n-                    // cannot overflow the `uint` as we only do this for a\n-                    // number of times that fits into a `uint` (and start with\n-                    // `0`). Again, we should not panic between these steps.\n-                    mem::forget(u);\n-                    pv.num_u += 1;\n-                }\n-            }\n-            // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n-            // destructor of the latter will not run. None of this can panic.\n-            let mut result = Vec::new();\n-            unsafe {\n-                result.set_len(pv.num_u);\n-                mem::forget(pv);\n-            }\n-            result\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::FormatWriter for Vec<u8> {\n-    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-        self.push_all(buf);\n-        Ok(())\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "74c387c5eeaf1aafe95b437b12be97ac58f07ba7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d919d2302b5df42e3bf8979560e0da21f4b2bad/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d919d2302b5df42e3bf8979560e0da21f4b2bad/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9d919d2302b5df42e3bf8979560e0da21f4b2bad", "patch": "@@ -158,6 +158,7 @@ pub use alloc::rc;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n+#[stable]\n pub use core_collections::vec;\n \n pub use unicode::char;"}]}