{"sha": "fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZjg1MGYzNGE0ZGI0YmFhM2NjZGEwZThlMmU1M2VjYTVmYzk5MzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-15T10:03:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-15T10:03:39Z"}, "message": "Auto merge of #59655 - Zoxc:symbols, r=petrochenkov\n\nUse a proc macro to declare preallocated symbols\n\nr? @petrochenkov", "tree": {"sha": "af0d50f530b578150d408cb2e8a95a551829ef17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af0d50f530b578150d408cb2e8a95a551829ef17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "html_url": "https://github.com/rust-lang/rust/commit/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1edb01b7afe758dc79740e72fb8b9909402c9620", "url": "https://api.github.com/repos/rust-lang/rust/commits/1edb01b7afe758dc79740e72fb8b9909402c9620", "html_url": "https://github.com/rust-lang/rust/commit/1edb01b7afe758dc79740e72fb8b9909402c9620"}, {"sha": "f598091c055100daa1dc0d9c3f0f0a10209a0a84", "url": "https://api.github.com/repos/rust-lang/rust/commits/f598091c055100daa1dc0d9c3f0f0a10209a0a84", "html_url": "https://github.com/rust-lang/rust/commit/f598091c055100daa1dc0d9c3f0f0a10209a0a84"}], "stats": {"total": 468, "additions": 327, "deletions": 141}, "files": [{"sha": "80a4029e1aa095b916c8b3b129cf817ed5466f9e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -3387,6 +3387,7 @@ dependencies = [\n  \"arena 0.0.0\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_macros 0.1.0\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "e79ef8bfc6fb43f0a31af6cd8003d4d8140a5318", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -8,7 +8,7 @@ use crate::ty::TyCtxt;\n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use syntax::symbol::Symbol;\n use syntax::ast::{Attribute, MetaItem, MetaItemKind};\n-use syntax_pos::Span;\n+use syntax_pos::{Span, symbols};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_macros::HashStable;\n use errors::DiagnosticId;\n@@ -51,12 +51,12 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n     }\n \n     fn extract(&self, attr: &Attribute) -> Option<(Symbol, Option<Symbol>, Span)> {\n-        let stab_attrs = vec![\"stable\", \"unstable\", \"rustc_const_unstable\"];\n+        let stab_attrs = [symbols::stable, symbols::unstable, symbols::rustc_const_unstable];\n \n         // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n         // `#[rustc_const_unstable (..)]`).\n         if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| {\n-            attr.check_name(stab_attr)\n+            attr.check_name(**stab_attr)\n         }) {\n             let meta_item = attr.meta();\n             if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta_item {"}, {"sha": "6f5b411946c2d8d3408beb1200a29979178c659a", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -599,7 +599,7 @@ impl<'a, 'tcx> FindAllAttrs<'a, 'tcx> {\n \n     fn is_active_attr(&mut self, attr: &Attribute) -> bool {\n         for attr_name in &self.attr_names {\n-            if attr.check_name(attr_name) && check_config(self.tcx, attr) {\n+            if attr.check_name(*attr_name) && check_config(self.tcx, attr) {\n                 return true;\n             }\n         }"}, {"sha": "2aee21abb58e5ba8dda0dac129141c4d243a1b39", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -228,7 +228,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n \n         let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n         for &(ref name, ty) in plugin_attributes.iter() {\n-            if ty == AttributeType::Whitelisted && attr.check_name(&name) {\n+            if ty == AttributeType::Whitelisted && attr.check_name(&**name) {\n                 debug!(\"{:?} (plugin attr) is whitelisted with ty {:?}\", name, ty);\n                 break;\n             }"}, {"sha": "98fba55218f9b10283b2b43998bc9876f269fa27", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -9,10 +9,16 @@ use proc_macro::TokenStream;\n \n mod hash_stable;\n mod query;\n+mod symbols;\n \n #[proc_macro]\n pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     query::rustc_queries(input)\n }\n \n+#[proc_macro]\n+pub fn symbols(input: TokenStream) -> TokenStream {\n+    symbols::symbols(input)\n+}\n+\n decl_derive!([HashStable, attributes(stable_hasher)] => hash_stable::hash_stable_derive);"}, {"sha": "169c5e13718335fac55b758eb6889ba296bb0ef0", "filename": "src/librustc_macros/src/symbols.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -0,0 +1,163 @@\n+use proc_macro::TokenStream;\n+use syn::{\n+    Token, Ident, LitStr,\n+    braced, parse_macro_input,\n+};\n+use syn::parse::{Result, Parse, ParseStream};\n+use syn;\n+use std::collections::HashSet;\n+use quote::quote;\n+\n+#[allow(non_camel_case_types)]\n+mod kw {\n+    syn::custom_keyword!(Keywords);\n+    syn::custom_keyword!(Other);\n+}\n+\n+struct Keyword {\n+    name: Ident,\n+    value: LitStr,\n+}\n+\n+impl Parse for Keyword {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        let name = input.parse()?;\n+        input.parse::<Token![:]>()?;\n+        let value = input.parse()?;\n+        input.parse::<Token![,]>()?;\n+\n+        Ok(Keyword {\n+            name,\n+            value,\n+        })\n+    }\n+}\n+\n+struct Symbol(Ident);\n+\n+impl Parse for Symbol {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        let ident: Ident = input.parse()?;\n+        input.parse::<Token![,]>()?;\n+\n+        Ok(Symbol(ident))\n+    }\n+}\n+\n+/// A type used to greedily parse another type until the input is empty.\n+struct List<T>(Vec<T>);\n+\n+impl<T: Parse> Parse for List<T> {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        let mut list = Vec::new();\n+        while !input.is_empty() {\n+            list.push(input.parse()?);\n+        }\n+        Ok(List(list))\n+    }\n+}\n+\n+struct Input {\n+    keywords: List<Keyword>,\n+    symbols: List<Symbol>,\n+}\n+\n+impl Parse for Input {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        input.parse::<kw::Keywords>()?;\n+        let content;\n+        braced!(content in input);\n+        let keywords = content.parse()?;\n+\n+        input.parse::<kw::Other>()?;\n+        let content;\n+        braced!(content in input);\n+        let symbols = content.parse()?;\n+\n+        Ok(Input {\n+            keywords,\n+            symbols,\n+        })\n+    }\n+}\n+\n+pub fn symbols(input: TokenStream) -> TokenStream {\n+    let input = parse_macro_input!(input as Input);\n+\n+    let mut keyword_stream = quote! {};\n+    let mut symbols_stream = quote! {};\n+    let mut prefill_stream = quote! {};\n+    let mut from_str_stream = quote! {};\n+    let mut counter = 0u32;\n+    let mut keys = HashSet::<String>::new();\n+\n+    let mut check_dup = |str: &str| {\n+        if !keys.insert(str.to_string()) {\n+            panic!(\"Symbol `{}` is duplicated\", str);\n+        }\n+    };\n+\n+    for keyword in &input.keywords.0 {\n+        let name = &keyword.name;\n+        let value = &keyword.value;\n+        check_dup(&value.value());\n+        prefill_stream.extend(quote! {\n+            #value,\n+        });\n+        keyword_stream.extend(quote! {\n+            pub const #name: Keyword = Keyword {\n+                ident: Ident::with_empty_ctxt(super::Symbol::new(#counter))\n+            };\n+        });\n+        from_str_stream.extend(quote! {\n+            #value => Ok(#name),\n+        });\n+        counter += 1;\n+    }\n+\n+    for symbol in &input.symbols.0 {\n+        let value = &symbol.0;\n+        let value_str = value.to_string();\n+        check_dup(&value_str);\n+        prefill_stream.extend(quote! {\n+            #value_str,\n+        });\n+        symbols_stream.extend(quote! {\n+            pub const #value: Symbol = Symbol::new(#counter);\n+        });\n+        counter += 1;\n+    }\n+\n+    TokenStream::from(quote! {\n+        macro_rules! keywords {\n+            () => {\n+                #keyword_stream\n+\n+                impl std::str::FromStr for Keyword {\n+                    type Err = ();\n+\n+                    fn from_str(s: &str) -> Result<Self, ()> {\n+                        match s {\n+                            #from_str_stream\n+                            _ => Err(()),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        macro_rules! symbols {\n+            () => {\n+                #symbols_stream\n+            }\n+        }\n+\n+        impl Interner {\n+            pub fn fresh() -> Self {\n+                Interner::prefill(&[\n+                    #prefill_stream\n+                ])\n+            }\n+        }\n+    })\n+}"}, {"sha": "0668730b3ef01a8f1c2906e3b147914b43c40873", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -68,6 +68,18 @@ pub struct Path {\n     pub segments: Vec<PathSegment>,\n }\n \n+impl PartialEq<Symbol> for Path {\n+    fn eq(&self, symbol: &Symbol) -> bool {\n+        self.segments.len() == 1 && {\n+            let name = self.segments[0].ident.name;\n+            // Make sure these symbols are pure strings\n+            debug_assert!(!symbol.is_gensymed());\n+            debug_assert!(!name.is_gensymed());\n+            name == *symbol\n+        }\n+    }\n+}\n+\n impl<'a> PartialEq<&'a str> for Path {\n     fn eq(&self, string: &&'a str) -> bool {\n         self.segments.len() == 1 && self.segments[0].ident.name == *string"}, {"sha": "e00f91e39528018e898756e2c7bd97f1899ccad4", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -81,7 +81,10 @@ impl NestedMetaItem {\n     }\n \n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n-    pub fn check_name(&self, name: &str) -> bool {\n+    pub fn check_name<T>(&self, name: T) -> bool\n+    where\n+        Path: PartialEq<T>,\n+    {\n         self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n     }\n \n@@ -151,7 +154,10 @@ impl Attribute {\n     /// attribute is marked as used.\n     ///\n     /// To check the attribute name without marking it used, use the `path` field directly.\n-    pub fn check_name(&self, name: &str) -> bool {\n+    pub fn check_name<T>(&self, name: T) -> bool\n+    where\n+        Path: PartialEq<T>,\n+    {\n         let matches = self.path == name;\n         if matches {\n             mark_used(self);\n@@ -244,7 +250,10 @@ impl MetaItem {\n         }\n     }\n \n-    pub fn check_name(&self, name: &str) -> bool {\n+    pub fn check_name<T>(&self, name: T) -> bool\n+    where\n+        Path: PartialEq<T>,\n+    {\n         self.path == name\n     }\n "}, {"sha": "ba4380416fb2a5fc524ef173b08030fd47cee671", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -28,7 +28,7 @@ use crate::tokenstream::TokenTree;\n use errors::{DiagnosticBuilder, Handler};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::abi::Abi;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP, symbols};\n use log::debug;\n \n use std::env;\n@@ -1366,7 +1366,7 @@ impl<'a> Context<'a> {\n                     }\n                 } else if n == \"doc\" {\n                     if let Some(content) = attr.meta_item_list() {\n-                        if content.iter().any(|c| c.check_name(\"include\")) {\n+                        if content.iter().any(|c| c.check_name(symbols::include)) {\n                             gate_feature!(self, external_doc, attr.span,\n                                 \"#[doc(include = \\\"...\\\")] is experimental\"\n                             );\n@@ -1667,33 +1667,33 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         // check for gated attributes\n         self.context.check_attribute(attr, false);\n \n-        if attr.check_name(\"doc\") {\n+        if attr.check_name(symbols::doc) {\n             if let Some(content) = attr.meta_item_list() {\n-                if content.len() == 1 && content[0].check_name(\"cfg\") {\n+                if content.len() == 1 && content[0].check_name(symbols::cfg) {\n                     gate_feature_post!(&self, doc_cfg, attr.span,\n                         \"#[doc(cfg(...))] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(\"masked\")) {\n+                } else if content.iter().any(|c| c.check_name(symbols::masked)) {\n                     gate_feature_post!(&self, doc_masked, attr.span,\n                         \"#[doc(masked)] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(\"spotlight\")) {\n+                } else if content.iter().any(|c| c.check_name(symbols::spotlight)) {\n                     gate_feature_post!(&self, doc_spotlight, attr.span,\n                         \"#[doc(spotlight)] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(\"alias\")) {\n+                } else if content.iter().any(|c| c.check_name(symbols::alias)) {\n                     gate_feature_post!(&self, doc_alias, attr.span,\n                         \"#[doc(alias = \\\"...\\\")] is experimental\"\n                     );\n-                } else if content.iter().any(|c| c.check_name(\"keyword\")) {\n+                } else if content.iter().any(|c| c.check_name(symbols::keyword)) {\n                     gate_feature_post!(&self, doc_keyword, attr.span,\n                         \"#[doc(keyword = \\\"...\\\")] is experimental\"\n                     );\n                 }\n             }\n         }\n \n-        match BUILTIN_ATTRIBUTES.iter().find(|(name, ..)| attr.path == name) {\n+        match BUILTIN_ATTRIBUTES.iter().find(|(name, ..)| attr.path == *name) {\n             Some(&(name, _, template, _)) => self.check_builtin_attribute(attr, name, template),\n             None => if let Some(TokenTree::Token(_, token::Eq)) = attr.tokens.trees().next() {\n                 // All key-value attributes are restricted to meta-item syntax.\n@@ -1748,7 +1748,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ItemKind::Struct(..) => {\n                 for attr in attr::filter_by_name(&i.attrs[..], \"repr\") {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(\"simd\") {\n+                        if item.check_name(symbols::simd) {\n                             gate_feature_post!(&self, repr_simd, attr.span,\n                                                \"SIMD types are experimental and possibly buggy\");\n                         }\n@@ -1759,7 +1759,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ItemKind::Enum(..) => {\n                 for attr in attr::filter_by_name(&i.attrs[..], \"repr\") {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(\"align\") {\n+                        if item.check_name(symbols::align) {\n                             gate_feature_post!(&self, repr_align_enum, attr.span,\n                                                \"`#[repr(align(x))]` on enums is experimental\");\n                         }\n@@ -2083,7 +2083,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     // Process the edition umbrella feature-gates first, to ensure\n     // `edition_enabled_features` is completed before it's queried.\n     for attr in krate_attrs {\n-        if !attr.check_name(\"feature\") {\n+        if !attr.check_name(symbols::feature) {\n             continue\n         }\n \n@@ -2128,7 +2128,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n     }\n \n     for attr in krate_attrs {\n-        if !attr.check_name(\"feature\") {\n+        if !attr.check_name(symbols::feature) {\n             continue\n         }\n \n@@ -2258,7 +2258,7 @@ fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n     };\n     if !allow_features {\n         for attr in &krate.attrs {\n-            if attr.check_name(\"feature\") {\n+            if attr.check_name(symbols::feature) {\n                 let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n                 span_err!(span_handler, attr.span, E0554,\n                           \"#![feature] may not be used on the {} release channel\","}, {"sha": "f0390ba3d40cb0830a3fb2acc517f91a2fc0df4c", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -87,7 +87,7 @@ pub fn modify(sess: &ParseSess,\n }\n \n pub fn is_proc_macro_attr(attr: &ast::Attribute) -> bool {\n-    PROC_MACRO_KINDS.iter().any(|kind| attr.check_name(kind))\n+    PROC_MACRO_KINDS.iter().any(|kind| attr.check_name(*kind))\n }\n \n impl<'a> CollectProcMacros<'a> {"}, {"sha": "af7edc0a6bd3eb08a98ec476533f8c48e672054e", "filename": "src/libsyntax_pos/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax_pos%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax_pos%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2FCargo.toml?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -11,6 +11,7 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n serialize = { path = \"../libserialize\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n arena = { path = \"../libarena\" }\n scoped-tls = \"1.0\""}, {"sha": "1ad556bbcfa5637fe9cab41c574169a36eeb3d6e", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -16,6 +16,7 @@\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n #![feature(rustc_attrs)]\n+#![feature(proc_macro_hygiene)]\n #![feature(specialization)]\n #![feature(step_trait)]\n \n@@ -32,6 +33,7 @@ mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n \n pub mod symbol;\n+pub use symbol::symbols;\n \n mod analyze_source_file;\n "}, {"sha": "c89bccd5afbf8140ae7bcafa007f9466e9e4c784", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 110, "deletions": 118, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=fcf850f34a4db4baa3ccda0e8e2e53eca5fc9936", "patch": "@@ -6,6 +6,7 @@ use arena::DroplessArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::newtype_index;\n+use rustc_macros::symbols;\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use std::fmt;\n@@ -16,6 +17,94 @@ use std::hash::{Hash, Hasher};\n use crate::hygiene::SyntaxContext;\n use crate::{Span, DUMMY_SP, GLOBALS};\n \n+symbols! {\n+    // After modifying this list adjust `is_special`, `is_used_keyword`/`is_unused_keyword`,\n+    // this should be rarely necessary though if the keywords are kept in alphabetic order.\n+    Keywords {\n+        // Special reserved identifiers used internally for elided lifetimes,\n+        // unnamed method parameters, crate root module, error recovery etc.\n+        Invalid:            \"\",\n+        PathRoot:           \"{{root}}\",\n+        DollarCrate:        \"$crate\",\n+        Underscore:         \"_\",\n+\n+        // Keywords that are used in stable Rust.\n+        As:                 \"as\",\n+        Box:                \"box\",\n+        Break:              \"break\",\n+        Const:              \"const\",\n+        Continue:           \"continue\",\n+        Crate:              \"crate\",\n+        Else:               \"else\",\n+        Enum:               \"enum\",\n+        Extern:             \"extern\",\n+        False:              \"false\",\n+        Fn:                 \"fn\",\n+        For:                \"for\",\n+        If:                 \"if\",\n+        Impl:               \"impl\",\n+        In:                 \"in\",\n+        Let:                \"let\",\n+        Loop:               \"loop\",\n+        Match:              \"match\",\n+        Mod:                \"mod\",\n+        Move:               \"move\",\n+        Mut:                \"mut\",\n+        Pub:                \"pub\",\n+        Ref:                \"ref\",\n+        Return:             \"return\",\n+        SelfLower:          \"self\",\n+        SelfUpper:          \"Self\",\n+        Static:             \"static\",\n+        Struct:             \"struct\",\n+        Super:              \"super\",\n+        Trait:              \"trait\",\n+        True:               \"true\",\n+        Type:               \"type\",\n+        Unsafe:             \"unsafe\",\n+        Use:                \"use\",\n+        Where:              \"where\",\n+        While:              \"while\",\n+\n+        // Keywords that are used in unstable Rust or reserved for future use.\n+        Abstract:           \"abstract\",\n+        Become:             \"become\",\n+        Do:                 \"do\",\n+        Final:              \"final\",\n+        Macro:              \"macro\",\n+        Override:           \"override\",\n+        Priv:               \"priv\",\n+        Typeof:             \"typeof\",\n+        Unsized:            \"unsized\",\n+        Virtual:            \"virtual\",\n+        Yield:              \"yield\",\n+\n+        // Edition-specific keywords that are used in stable Rust.\n+        Dyn:                \"dyn\", // >= 2018 Edition only\n+\n+        // Edition-specific keywords that are used in unstable Rust or reserved for future use.\n+        Async:              \"async\", // >= 2018 Edition only\n+        Try:                \"try\", // >= 2018 Edition only\n+\n+        // Special lifetime names\n+        UnderscoreLifetime: \"'_\",\n+        StaticLifetime:     \"'static\",\n+\n+        // Weak keywords, have special meaning only in specific contexts.\n+        Auto:               \"auto\",\n+        Catch:              \"catch\",\n+        Default:            \"default\",\n+        Existential:        \"existential\",\n+        Union:              \"union\",\n+    }\n+\n+    // Other symbols that can be referred to with syntax_pos::symbols::*\n+    Other {\n+        doc, cfg, masked, spotlight, alias, keyword, feature, include, simd, align, stable,\n+        unstable, rustc_const_unstable,\n+    }\n+}\n+\n #[derive(Copy, Clone, Eq)]\n pub struct Ident {\n     pub name: Symbol,\n@@ -317,129 +406,32 @@ impl Interner {\n     }\n }\n \n-// In this macro, there is the requirement that the name (the number) must be monotonically\n-// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n-// except starting from the next number instead of zero.\n-macro_rules! declare_keywords {(\n-    $( ($index: expr, $konst: ident, $string: expr) )*\n-) => {\n-    pub mod keywords {\n-        use super::{Symbol, Ident};\n-        #[derive(Clone, Copy, PartialEq, Eq)]\n-        pub struct Keyword {\n-            ident: Ident,\n-        }\n-        impl Keyword {\n-            #[inline] pub fn ident(self) -> Ident { self.ident }\n-            #[inline] pub fn name(self) -> Symbol { self.ident.name }\n-        }\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $konst: Keyword = Keyword {\n-                ident: Ident::with_empty_ctxt(super::Symbol::new($index))\n-            };\n-        )*\n-\n-        impl std::str::FromStr for Keyword {\n-            type Err = ();\n-\n-            fn from_str(s: &str) -> Result<Self, ()> {\n-                match s {\n-                    $($string => Ok($konst),)*\n-                    _ => Err(()),\n-                }\n-            }\n-        }\n+pub mod keywords {\n+    use super::{Symbol, Ident};\n+\n+    #[derive(Clone, Copy, PartialEq, Eq)]\n+    pub struct Keyword {\n+        ident: Ident,\n     }\n \n-    impl Interner {\n-        pub fn fresh() -> Self {\n-            Interner::prefill(&[$($string,)*])\n+    impl Keyword {\n+        #[inline]\n+        pub fn ident(self) -> Ident {\n+            self.ident\n+        }\n+\n+        #[inline]\n+        pub fn name(self) -> Symbol {\n+            self.ident.name\n         }\n     }\n-}}\n \n-// N.B., leaving holes in the ident table is bad! a different ident will get\n-// interned with the id from the hole, but it will be between the min and max\n-// of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_special`, `is_used_keyword`/`is_unused_keyword`,\n-// this should be rarely necessary though if the keywords are kept in alphabetic order.\n-declare_keywords! {\n-    // Special reserved identifiers used internally for elided lifetimes,\n-    // unnamed method parameters, crate root module, error recovery etc.\n-    (0,  Invalid,            \"\")\n-    (1,  PathRoot,           \"{{root}}\")\n-    (2,  DollarCrate,        \"$crate\")\n-    (3,  Underscore,         \"_\")\n-\n-    // Keywords that are used in stable Rust.\n-    (4,  As,                 \"as\")\n-    (5,  Box,                \"box\")\n-    (6,  Break,              \"break\")\n-    (7,  Const,              \"const\")\n-    (8,  Continue,           \"continue\")\n-    (9,  Crate,              \"crate\")\n-    (10, Else,               \"else\")\n-    (11, Enum,               \"enum\")\n-    (12, Extern,             \"extern\")\n-    (13, False,              \"false\")\n-    (14, Fn,                 \"fn\")\n-    (15, For,                \"for\")\n-    (16, If,                 \"if\")\n-    (17, Impl,               \"impl\")\n-    (18, In,                 \"in\")\n-    (19, Let,                \"let\")\n-    (20, Loop,               \"loop\")\n-    (21, Match,              \"match\")\n-    (22, Mod,                \"mod\")\n-    (23, Move,               \"move\")\n-    (24, Mut,                \"mut\")\n-    (25, Pub,                \"pub\")\n-    (26, Ref,                \"ref\")\n-    (27, Return,             \"return\")\n-    (28, SelfLower,          \"self\")\n-    (29, SelfUpper,          \"Self\")\n-    (30, Static,             \"static\")\n-    (31, Struct,             \"struct\")\n-    (32, Super,              \"super\")\n-    (33, Trait,              \"trait\")\n-    (34, True,               \"true\")\n-    (35, Type,               \"type\")\n-    (36, Unsafe,             \"unsafe\")\n-    (37, Use,                \"use\")\n-    (38, Where,              \"where\")\n-    (39, While,              \"while\")\n-\n-    // Keywords that are used in unstable Rust or reserved for future use.\n-    (40, Abstract,           \"abstract\")\n-    (41, Become,             \"become\")\n-    (42, Do,                 \"do\")\n-    (43, Final,              \"final\")\n-    (44, Macro,              \"macro\")\n-    (45, Override,           \"override\")\n-    (46, Priv,               \"priv\")\n-    (47, Typeof,             \"typeof\")\n-    (48, Unsized,            \"unsized\")\n-    (49, Virtual,            \"virtual\")\n-    (50, Yield,              \"yield\")\n-\n-    // Edition-specific keywords that are used in stable Rust.\n-    (51, Dyn,                \"dyn\") // >= 2018 Edition only\n-\n-    // Edition-specific keywords that are used in unstable Rust or reserved for future use.\n-    (52, Async,              \"async\") // >= 2018 Edition only\n-    (53, Try,                \"try\") // >= 2018 Edition only\n-\n-    // Special lifetime names\n-    (54, UnderscoreLifetime, \"'_\")\n-    (55, StaticLifetime,     \"'static\")\n-\n-    // Weak keywords, have special meaning only in specific contexts.\n-    (56, Auto,               \"auto\")\n-    (57, Catch,              \"catch\")\n-    (58, Default,            \"default\")\n-    (59, Existential,        \"existential\")\n-    (60, Union,              \"union\")\n+    keywords!();\n+}\n+\n+pub mod symbols {\n+    use super::Symbol;\n+    symbols!();\n }\n \n impl Symbol {"}]}