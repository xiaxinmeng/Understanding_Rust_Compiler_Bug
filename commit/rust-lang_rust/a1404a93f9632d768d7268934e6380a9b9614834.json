{"sha": "a1404a93f9632d768d7268934e6380a9b9614834", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNDA0YTkzZjk2MzJkNzY4ZDcyNjg5MzRlNjM4MGE5Yjk2MTQ4MzQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-20T21:44:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-20T21:44:50Z"}, "message": "Rollup merge of #72456 - ldm0:dereftrait, r=estebank\n\nTry to suggest dereferences on trait selection failed\n\nFixes #39029 Fixes #62530\nThis PR consists of two parts:\n1. Decouple `Autoderef` with `FnCtxt` and move `Autoderef` to `librustc_trait_selection`.\n2. Try to suggest dereferences when trait selection failed.\n\nThe first is needed because:\n1. For suggesting dereferences, the struct `Autoderef` should be used. But before this PR, it is placed in `librustc_typeck`, which depends on `librustc_trait_selection`. But trait selection error emitting happens in `librustc_trait_selection`, if we want to use `Autoderef` in it, dependency loop is inevitable. So I moved the `Autoderef` to `librustc_trait_selection`.\n2. Before this PR, `FnCtxt` is coupled to `Autoderef`, and `FnCtxt` only exists in `librustc_typeck`. So decoupling is needed.\n\nAfter this PR, we can get suggestion like this:\n```\nerror[E0277]: the trait bound `&Baz: Happy` is not satisfied\n  --> $DIR/trait-suggest-deferences-multiple.rs:34:9\n   |\nLL | fn foo<T>(_: T) where T: Happy {}\n   |                          ----- required by this bound in `foo`\n...\nLL |     foo(&baz);\n   |         ^^^^\n   |         |\n   |         the trait `Happy` is not implemented for `&Baz`\n   |         help: consider adding dereference here: `&***baz`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n```\n\nr? @estebank", "tree": {"sha": "9532ddbaad645d10a3af580206546e96ce0f14bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9532ddbaad645d10a3af580206546e96ce0f14bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1404a93f9632d768d7268934e6380a9b9614834", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7oNSCRBK7hj4Ov3rIwAAdHIIAH5fjF3c9MdXbe6LbFbzU675\nG/wvaMrUSueiCQfpGg2187UxAUqj++FEmB7wQuG0nxxJBIkGrLhSWHr864kfP81J\nPNUBUD018h8C2oeyY3wY8/V71oely98L+14CO+QIjwQ6jr+mIkUGmVc5cJJYDS5u\nAZ8UXwKXB9/VROSWHED2SFV/qyshc3+wM2Yno40c1nCrjBIzZtfDXHQoYrlnCQXW\nbM20UIer/4zV2uGgySGlZWJhs5hzXDg0+KvU9ptqCIlcIEcmuRiJxmE60n0D0LXB\neATH/Oq9tzSVG28KIiXOUg5jBoyoxAXUpTGBlbBNRaD8IjSzqJqcphtXalrRr2o=\n=ehAT\n-----END PGP SIGNATURE-----\n", "payload": "tree 9532ddbaad645d10a3af580206546e96ce0f14bc\nparent 033013cab3a861224fd55f494c8be1cb0349eb49\nparent f1e07103d3ebac4e820311254e077481d00bed49\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592689490 -0700\ncommitter GitHub <noreply@github.com> 1592689490 -0700\n\nRollup merge of #72456 - ldm0:dereftrait, r=estebank\n\nTry to suggest dereferences on trait selection failed\n\nFixes #39029 Fixes #62530\nThis PR consists of two parts:\n1. Decouple `Autoderef` with `FnCtxt` and move `Autoderef` to `librustc_trait_selection`.\n2. Try to suggest dereferences when trait selection failed.\n\nThe first is needed because:\n1. For suggesting dereferences, the struct `Autoderef` should be used. But before this PR, it is placed in `librustc_typeck`, which depends on `librustc_trait_selection`. But trait selection error emitting happens in `librustc_trait_selection`, if we want to use `Autoderef` in it, dependency loop is inevitable. So I moved the `Autoderef` to `librustc_trait_selection`.\n2. Before this PR, `FnCtxt` is coupled to `Autoderef`, and `FnCtxt` only exists in `librustc_typeck`. So decoupling is needed.\n\nAfter this PR, we can get suggestion like this:\n```\nerror[E0277]: the trait bound `&Baz: Happy` is not satisfied\n  --> $DIR/trait-suggest-deferences-multiple.rs:34:9\n   |\nLL | fn foo<T>(_: T) where T: Happy {}\n   |                          ----- required by this bound in `foo`\n...\nLL |     foo(&baz);\n   |         ^^^^\n   |         |\n   |         the trait `Happy` is not implemented for `&Baz`\n   |         help: consider adding dereference here: `&***baz`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n```\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1404a93f9632d768d7268934e6380a9b9614834", "html_url": "https://github.com/rust-lang/rust/commit/a1404a93f9632d768d7268934e6380a9b9614834", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1404a93f9632d768d7268934e6380a9b9614834/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "033013cab3a861224fd55f494c8be1cb0349eb49", "url": "https://api.github.com/repos/rust-lang/rust/commits/033013cab3a861224fd55f494c8be1cb0349eb49", "html_url": "https://github.com/rust-lang/rust/commit/033013cab3a861224fd55f494c8be1cb0349eb49"}, {"sha": "f1e07103d3ebac4e820311254e077481d00bed49", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e07103d3ebac4e820311254e077481d00bed49", "html_url": "https://github.com/rust-lang/rust/commit/f1e07103d3ebac4e820311254e077481d00bed49"}], "stats": {"total": 844, "additions": 594, "deletions": 250}, "files": [{"sha": "d542e16d83f10e58a32d39ce5b194624dfb36645", "filename": "src/librustc_trait_selection/autoderef.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_trait_selection%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_trait_selection%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fautoderef.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,229 @@\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n+use crate::traits::{self, TraitEngine};\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_infer::infer::InferCtxt;\n+use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{ToPredicate, TypeFoldable};\n+use rustc_session::DiagnosticMessageId;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum AutoderefKind {\n+    Builtin,\n+    Overloaded,\n+}\n+\n+struct AutoderefSnapshot<'tcx> {\n+    at_start: bool,\n+    reached_recursion_limit: bool,\n+    steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n+    cur_ty: Ty<'tcx>,\n+    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+}\n+\n+pub struct Autoderef<'a, 'tcx> {\n+    // Meta infos:\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    span: Span,\n+    body_id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+\n+    // Current state:\n+    state: AutoderefSnapshot<'tcx>,\n+\n+    // Configurations:\n+    include_raw_pointers: bool,\n+    silence_errors: bool,\n+}\n+\n+impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n+    type Item = (Ty<'tcx>, usize);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let tcx = self.infcx.tcx;\n+\n+        debug!(\"autoderef: steps={:?}, cur_ty={:?}\", self.state.steps, self.state.cur_ty);\n+        if self.state.at_start {\n+            self.state.at_start = false;\n+            debug!(\"autoderef stage #0 is {:?}\", self.state.cur_ty);\n+            return Some((self.state.cur_ty, 0));\n+        }\n+\n+        // If we have reached the recursion limit, error gracefully.\n+        if !tcx.sess.recursion_limit().value_within_limit(self.state.steps.len()) {\n+            if !self.silence_errors {\n+                report_autoderef_recursion_limit_error(tcx, self.span, self.state.cur_ty);\n+            }\n+            self.state.reached_recursion_limit = true;\n+            return None;\n+        }\n+\n+        if self.state.cur_ty.is_ty_var() {\n+            return None;\n+        }\n+\n+        // Otherwise, deref if type is derefable:\n+        let (kind, new_ty) =\n+            if let Some(mt) = self.state.cur_ty.builtin_deref(self.include_raw_pointers) {\n+                (AutoderefKind::Builtin, mt.ty)\n+            } else if let Some(ty) = self.overloaded_deref_ty(self.state.cur_ty) {\n+                (AutoderefKind::Overloaded, ty)\n+            } else {\n+                return None;\n+            };\n+\n+        if new_ty.references_error() {\n+            return None;\n+        }\n+\n+        self.state.steps.push((self.state.cur_ty, kind));\n+        debug!(\n+            \"autoderef stage #{:?} is {:?} from {:?}\",\n+            self.step_count(),\n+            new_ty,\n+            (self.state.cur_ty, kind)\n+        );\n+        self.state.cur_ty = new_ty;\n+\n+        Some((self.state.cur_ty, self.step_count()))\n+    }\n+}\n+\n+impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n+    pub fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+        span: Span,\n+        base_ty: Ty<'tcx>,\n+    ) -> Autoderef<'a, 'tcx> {\n+        Autoderef {\n+            infcx,\n+            span,\n+            body_id,\n+            param_env,\n+            state: AutoderefSnapshot {\n+                steps: vec![],\n+                cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n+                obligations: vec![],\n+                at_start: true,\n+                reached_recursion_limit: false,\n+            },\n+            include_raw_pointers: false,\n+            silence_errors: false,\n+        }\n+    }\n+\n+    fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        debug!(\"overloaded_deref_ty({:?})\", ty);\n+\n+        let tcx = self.infcx.tcx;\n+\n+        // <ty as Deref>\n+        let trait_ref = TraitRef {\n+            def_id: tcx.lang_items().deref_trait()?,\n+            substs: tcx.mk_substs_trait(ty, &[]),\n+        };\n+\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+\n+        let obligation = traits::Obligation::new(\n+            cause.clone(),\n+            self.param_env,\n+            trait_ref.without_const().to_predicate(tcx),\n+        );\n+        if !self.infcx.predicate_may_hold(&obligation) {\n+            debug!(\"overloaded_deref_ty: cannot match obligation\");\n+            return None;\n+        }\n+\n+        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n+        let normalized_ty = fulfillcx.normalize_projection_type(\n+            &self.infcx,\n+            self.param_env,\n+            ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, Ident::from_str(\"Target\")),\n+            cause,\n+        );\n+        if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {\n+            // This shouldn't happen, except for evaluate/fulfill mismatches,\n+            // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n+            // by design).\n+            debug!(\"overloaded_deref_ty: encountered errors {:?} while fulfilling\", e);\n+            return None;\n+        }\n+        let obligations = fulfillcx.pending_obligations();\n+        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n+        self.state.obligations.extend(obligations);\n+\n+        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n+    }\n+\n+    /// Returns the final type we ended up with, which may be an inference\n+    /// variable (we will resolve it first, if we want).\n+    pub fn final_ty(&self, resolve: bool) -> Ty<'tcx> {\n+        if resolve {\n+            self.infcx.resolve_vars_if_possible(&self.state.cur_ty)\n+        } else {\n+            self.state.cur_ty\n+        }\n+    }\n+\n+    pub fn step_count(&self) -> usize {\n+        self.state.steps.len()\n+    }\n+\n+    pub fn into_obligations(self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        self.state.obligations\n+    }\n+\n+    pub fn steps(&self) -> &[(Ty<'tcx>, AutoderefKind)] {\n+        &self.state.steps\n+    }\n+\n+    pub fn span(&self) -> Span {\n+        self.span.clone()\n+    }\n+\n+    pub fn reached_recursion_limit(&self) -> bool {\n+        self.state.reached_recursion_limit\n+    }\n+\n+    /// also dereference through raw pointer types\n+    /// e.g., assuming ptr_to_Foo is the type `*const Foo`\n+    /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n+    /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n+    pub fn include_raw_pointers(mut self) -> Self {\n+        self.include_raw_pointers = true;\n+        self\n+    }\n+\n+    pub fn silence_errors(mut self) -> Self {\n+        self.silence_errors = true;\n+        self\n+    }\n+}\n+\n+pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n+    // We've reached the recursion limit, error gracefully.\n+    let suggested_limit = tcx.sess.recursion_limit() * 2;\n+    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\", ty);\n+    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n+    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+    if fresh {\n+        struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0055,\n+            \"reached the recursion limit while auto-dereferencing `{:?}`\",\n+            ty\n+        )\n+        .span_label(span, \"deref recursion limit reached\")\n+        .help(&format!(\n+            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n+            suggested_limit, tcx.crate_name,\n+        ))\n+        .emit();\n+    }\n+}"}, {"sha": "4692fa04ed58718466a0e8d7cf8cc94eb36edacb", "filename": "src/librustc_trait_selection/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -28,6 +28,7 @@ extern crate log;\n #[macro_use]\n extern crate rustc_middle;\n \n+pub mod autoderef;\n pub mod infer;\n pub mod opaque_types;\n pub mod traits;"}, {"sha": "fd0c1a54d27adec8a6fcbca44a7c9f026a025e31", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -402,6 +402,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             err.span_label(enclosing_scope_span, s.as_str());\n                         }\n \n+                        self.suggest_dereferences(&obligation, &mut err, &trait_ref, points_at_arg);\n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n                         self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);"}, {"sha": "176bd90303dddfe93230763329fd14597dd5a59e", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -3,6 +3,7 @@ use super::{\n     SelectionContext,\n };\n \n+use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n use crate::traits::normalize_projection_type;\n \n@@ -13,11 +14,11 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n-use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n     self, suggest_constraining_type_param, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty,\n     TyCtxt, TypeFoldable, WithConstness,\n };\n+use rustc_middle::ty::{TypeAndMut, TypeckTables};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n@@ -48,6 +49,14 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n     );\n \n+    fn suggest_dereferences(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        points_at_arg: bool,\n+    );\n+\n     fn get_closure_name(\n         &self,\n         def_id: DefId,\n@@ -450,6 +459,62 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// When after several dereferencing, the reference satisfies the trait\n+    /// binding. This function provides dereference suggestion for this\n+    /// specific situation.\n+    fn suggest_dereferences(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        points_at_arg: bool,\n+    ) {\n+        // It only make sense when suggesting dereferences for arguments\n+        if !points_at_arg {\n+            return;\n+        }\n+        let param_env = obligation.param_env;\n+        let body_id = obligation.cause.body_id;\n+        let span = obligation.cause.span;\n+        let real_trait_ref = match &obligation.cause.code {\n+            ObligationCauseCode::ImplDerivedObligation(cause)\n+            | ObligationCauseCode::DerivedObligation(cause)\n+            | ObligationCauseCode::BuiltinDerivedObligation(cause) => &cause.parent_trait_ref,\n+            _ => trait_ref,\n+        };\n+        let real_ty = match real_trait_ref.self_ty().no_bound_vars() {\n+            Some(ty) => ty,\n+            None => return,\n+        };\n+\n+        if let ty::Ref(region, base_ty, mutbl) = real_ty.kind {\n+            let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty);\n+            if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n+                // Re-add the `&`\n+                let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n+                let obligation =\n+                    self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_ref, ty);\n+                Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n+            }) {\n+                if steps > 0 {\n+                    if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        // Don't care about `&mut` because `DerefMut` is used less\n+                        // often and user will not expect autoderef happens.\n+                        if src.starts_with(\"&\") && !src.starts_with(\"&mut \") {\n+                            let derefs = \"*\".repeat(steps);\n+                            err.span_suggestion(\n+                                span,\n+                                \"consider adding dereference here\",\n+                                format!(\"&{}{}\", derefs, &src[1..]),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n     fn suggest_borrow_on_unsized_slice("}, {"sha": "97d2b3e5a8e45c8b1e121bb5b5654e36c9685a89", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 19, "deletions": 227, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -1,191 +1,46 @@\n+//! Some helper functions for `AutoDeref`\n use super::method::MethodCallee;\n use super::{FnCtxt, PlaceOp};\n \n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n-use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n-use rustc_middle::ty::{ToPredicate, TypeFoldable};\n-use rustc_session::DiagnosticMessageId;\n-use rustc_span::symbol::Ident;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, TraitEngine};\n+use rustc_trait_selection::autoderef::{Autoderef, AutoderefKind};\n \n use std::iter;\n \n-#[derive(Copy, Clone, Debug)]\n-enum AutoderefKind {\n-    Builtin,\n-    Overloaded,\n-}\n-\n-pub struct Autoderef<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    body_id: hir::HirId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n-    cur_ty: Ty<'tcx>,\n-    obligations: Vec<traits::PredicateObligation<'tcx>>,\n-    at_start: bool,\n-    include_raw_pointers: bool,\n-    span: Span,\n-    silence_errors: bool,\n-    reached_recursion_limit: bool,\n-}\n-\n-impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n-    type Item = (Ty<'tcx>, usize);\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let tcx = self.infcx.tcx;\n-\n-        debug!(\"autoderef: steps={:?}, cur_ty={:?}\", self.steps, self.cur_ty);\n-        if self.at_start {\n-            self.at_start = false;\n-            debug!(\"autoderef stage #0 is {:?}\", self.cur_ty);\n-            return Some((self.cur_ty, 0));\n-        }\n-\n-        if !tcx.sess.recursion_limit().value_within_limit(self.steps.len()) {\n-            if !self.silence_errors {\n-                report_autoderef_recursion_limit_error(tcx, self.span, self.cur_ty);\n-            }\n-            self.reached_recursion_limit = true;\n-            return None;\n-        }\n-\n-        if self.cur_ty.is_ty_var() {\n-            return None;\n-        }\n-\n-        // Otherwise, deref if type is derefable:\n-        let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(self.include_raw_pointers)\n-        {\n-            (AutoderefKind::Builtin, mt.ty)\n-        } else {\n-            let ty = self.overloaded_deref_ty(self.cur_ty)?;\n-            (AutoderefKind::Overloaded, ty)\n-        };\n-\n-        if new_ty.references_error() {\n-            return None;\n-        }\n-\n-        self.steps.push((self.cur_ty, kind));\n-        debug!(\n-            \"autoderef stage #{:?} is {:?} from {:?}\",\n-            self.steps.len(),\n-            new_ty,\n-            (self.cur_ty, kind)\n-        );\n-        self.cur_ty = new_ty;\n-\n-        Some((self.cur_ty, self.steps.len()))\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n     }\n-}\n \n-impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n-    pub fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+    pub fn try_overloaded_deref(\n+        &self,\n         span: Span,\n         base_ty: Ty<'tcx>,\n-    ) -> Autoderef<'a, 'tcx> {\n-        Autoderef {\n-            infcx,\n-            body_id,\n-            param_env,\n-            steps: vec![],\n-            cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n-            obligations: vec![],\n-            at_start: true,\n-            include_raw_pointers: false,\n-            silence_errors: false,\n-            reached_recursion_limit: false,\n-            span,\n-        }\n-    }\n-\n-    fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-        debug!(\"overloaded_deref_ty({:?})\", ty);\n-\n-        let tcx = self.infcx.tcx;\n-\n-        // <ty as Deref>\n-        let trait_ref = TraitRef {\n-            def_id: tcx.lang_items().deref_trait()?,\n-            substs: tcx.mk_substs_trait(ty, &[]),\n-        };\n-\n-        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-\n-        let obligation = traits::Obligation::new(\n-            cause.clone(),\n-            self.param_env,\n-            trait_ref.without_const().to_predicate(tcx),\n-        );\n-        if !self.infcx.predicate_may_hold(&obligation) {\n-            debug!(\"overloaded_deref_ty: cannot match obligation\");\n-            return None;\n-        }\n-\n-        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n-        let normalized_ty = fulfillcx.normalize_projection_type(\n-            &self.infcx,\n-            self.param_env,\n-            ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, Ident::from_str(\"Target\")),\n-            cause,\n-        );\n-        if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {\n-            // This shouldn't happen, except for evaluate/fulfill mismatches,\n-            // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n-            // by design).\n-            debug!(\"overloaded_deref_ty: encountered errors {:?} while fulfilling\", e);\n-            return None;\n-        }\n-        let obligations = fulfillcx.pending_obligations();\n-        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n-        self.obligations.extend(obligations);\n-\n-        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n-    }\n-\n-    /// Returns the final type, generating an error if it is an\n-    /// unresolved inference variable.\n-    pub fn unambiguous_final_ty(&self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {\n-        fcx.structurally_resolved_type(self.span, self.cur_ty)\n-    }\n-\n-    /// Returns the final type we ended up with, which may well be an\n-    /// inference variable (we will resolve it first, if possible).\n-    pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.infcx.resolve_vars_if_possible(&self.cur_ty)\n-    }\n-\n-    pub fn step_count(&self) -> usize {\n-        self.steps.len()\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n-        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx))\n+    pub fn adjust_steps(&self, autoderef: &Autoderef<'a, 'tcx>) -> Vec<Adjustment<'tcx>> {\n+        self.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(autoderef))\n     }\n \n     pub fn adjust_steps_as_infer_ok(\n         &self,\n-        fcx: &FnCtxt<'a, 'tcx>,\n+        autoderef: &Autoderef<'a, 'tcx>,\n     ) -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n-        let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(self.cur_ty));\n-        let steps: Vec<_> = self\n-            .steps\n+        let steps = autoderef.steps();\n+        let targets =\n+            steps.iter().skip(1).map(|&(ty, _)| ty).chain(iter::once(autoderef.final_ty(false)));\n+        let steps: Vec<_> = steps\n             .iter()\n             .map(|&(source, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(self.span, source).and_then(\n+                    self.try_overloaded_deref(autoderef.span(), source).and_then(\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n@@ -205,67 +60,4 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n \n         InferOk { obligations, value: steps }\n     }\n-\n-    /// also dereference through raw pointer types\n-    /// e.g., assuming ptr_to_Foo is the type `*const Foo`\n-    /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n-    /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n-    pub fn include_raw_pointers(mut self) -> Self {\n-        self.include_raw_pointers = true;\n-        self\n-    }\n-\n-    pub fn silence_errors(mut self) -> Self {\n-        self.silence_errors = true;\n-        self\n-    }\n-\n-    pub fn reached_recursion_limit(&self) -> bool {\n-        self.reached_recursion_limit\n-    }\n-\n-    pub fn finalize(self, fcx: &FnCtxt<'a, 'tcx>) {\n-        fcx.register_predicates(self.into_obligations());\n-    }\n-\n-    pub fn into_obligations(self) -> Vec<traits::PredicateObligation<'tcx>> {\n-        self.obligations\n-    }\n-}\n-\n-pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n-    // We've reached the recursion limit, error gracefully.\n-    let suggested_limit = tcx.sess.recursion_limit() * 2;\n-    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\", ty);\n-    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n-    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-    if fresh {\n-        struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0055,\n-            \"reached the recursion limit while auto-dereferencing `{:?}`\",\n-            ty\n-        )\n-        .span_label(span, \"deref recursion limit reached\")\n-        .help(&format!(\n-            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n-            suggested_limit, tcx.crate_name,\n-        ))\n-        .emit();\n-    }\n-}\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n-    }\n-\n-    pub fn try_overloaded_deref(\n-        &self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_place_op(span, base_ty, &[], PlaceOp::Deref)\n-    }\n }"}, {"sha": "308ed5d8402021864d830170422fc7f86a151430", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -1,4 +1,3 @@\n-use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n@@ -17,6 +16,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n+use rustc_trait_selection::autoderef::Autoderef;\n \n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -72,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_overloaded_call_step(call_expr, callee_expr, arg_exprs, &autoderef);\n         }\n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n \n         let output = match result {\n             None => {\n@@ -106,7 +106,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         autoderef: &Autoderef<'a, 'tcx>,\n     ) -> Option<CallStep<'tcx>> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        let adjusted_ty =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n         debug!(\n             \"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n             call_expr, adjusted_ty\n@@ -115,7 +116,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.kind {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(self);\n+                let adjustments = self.adjust_steps(autoderef);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -135,7 +136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             &closure_sig,\n                         )\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(self);\n+                    let adjustments = self.adjust_steps(autoderef);\n                     self.record_deferred_call_resolution(\n                         def_id,\n                         DeferredCallResolution {\n@@ -176,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n             .or_else(|| self.try_overloaded_call_traits(call_expr, adjusted_ty, None))\n             .map(|(autoref, method)| {\n-                let mut adjustments = autoderef.adjust_steps(self);\n+                let mut adjustments = self.adjust_steps(autoderef);\n                 adjustments.extend(autoref);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 CallStep::Overloaded(method)"}, {"sha": "dec53c369bb182c76e62454b2ebfbfd3526d67c6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -409,7 +409,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n \n         let InferOk { value: mut adjustments, obligations: o } =\n-            autoderef.adjust_steps_as_infer_ok(self);\n+            self.adjust_steps_as_infer_ok(&autoderef);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "1eaa5a6c31e20070466b1d4941f1fe1b4bd815b2", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -1447,9 +1447,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self);\n+                            let adjustments = self.adjust_steps(&autoderef);\n                             self.apply_adjustments(base, adjustments);\n-                            autoderef.finalize(self);\n+                            self.register_predicates(autoderef.into_obligations());\n \n                             self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n                             return field_ty;\n@@ -1462,9 +1462,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self);\n+                                let adjustments = self.adjust_steps(&autoderef);\n                                 self.apply_adjustments(base, adjustments);\n-                                autoderef.finalize(self);\n+                                self.register_predicates(autoderef.into_obligations());\n \n                                 self.write_field_index(expr.hir_id, index);\n                                 return field_ty.expect_ty();\n@@ -1475,7 +1475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => {}\n             }\n         }\n-        autoderef.unambiguous_final_ty(self);\n+        self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n         if let Some((did, field_ty)) = private_candidate {\n             self.ban_private_field_access(expr, expr_t, field, did);"}, {"sha": "1c3d23a3a241f4bf751ad6490235491317ad26d2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -144,9 +144,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(self);\n+        let mut adjustments = self.adjust_steps(&autoderef);\n \n-        let mut target = autoderef.unambiguous_final_ty(self);\n+        let mut target =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n         if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n@@ -176,7 +177,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             assert!(pick.unsize.is_none());\n         }\n \n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n \n         // Write out the final adjustments.\n         self.apply_adjustments(self.self_expr, adjustments);"}, {"sha": "8c4ef24b9455ce8d388ffb5d0bd11b7ff3bc5d08", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -3,7 +3,6 @@ use super::MethodError;\n use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n \n-use crate::check::autoderef::{self, Autoderef};\n use crate::check::FnCtxt;\n use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n@@ -30,6 +29,7 @@ use rustc_session::config::nightly_options;\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n+use rustc_trait_selection::autoderef::{self, Autoderef};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{\n@@ -477,7 +477,7 @@ fn method_autoderef_steps<'tcx>(\n             })\n             .collect();\n \n-        let final_ty = autoderef.maybe_ambiguous_final_ty();\n+        let final_ty = autoderef.final_ty(true);\n         let opt_bad_ty = match final_ty.kind {\n             ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n                 reached_raw_pointer,"}, {"sha": "b7c8f310a1414763acb04b1b1b63becfe65704db", "filename": "src/librustc_typeck/check/place_op.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -1,4 +1,3 @@\n-use crate::check::autoderef::Autoderef;\n use crate::check::method::MethodCallee;\n use crate::check::{FnCtxt, PlaceOp};\n use rustc_hir as hir;\n@@ -9,6 +8,7 @@ use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutabili\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n+use rustc_trait_selection::autoderef::Autoderef;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Type-check `*oprnd_expr` with `oprnd_expr` type-checked already.\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_index_step(expr, base_expr, &autoderef, idx_ty);\n         }\n-        autoderef.finalize(self);\n+        self.register_predicates(autoderef.into_obligations());\n         result\n     }\n \n@@ -73,7 +73,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         autoderef: &Autoderef<'a, 'tcx>,\n         index_ty: Ty<'tcx>,\n     ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n+        let adjusted_ty =\n+            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n         debug!(\n             \"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n              index_ty={:?})\",\n@@ -105,7 +106,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n                 let method = self.register_infer_ok_obligations(ok);\n \n-                let mut adjustments = autoderef.adjust_steps(self);\n+                let mut adjustments = self.adjust_steps(autoderef);\n                 if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n                     adjustments.push(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),"}, {"sha": "d1a86a7ee89a8af5f7d3e8a6b3d54cf761bdcae6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -1118,7 +1118,7 @@ fn receiver_is_valid<'fcx, 'tcx>(\n             );\n \n             if can_eq_self(potential_self_ty) {\n-                autoderef.finalize(fcx);\n+                fcx.register_predicates(autoderef.into_obligations());\n \n                 if let Some(mut err) =\n                     fcx.demand_eqtype_with_origin(&cause, self_ty, potential_self_ty)"}, {"sha": "2bb34b0ebee6f342a55c32bfc5da8c211545da6b", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-39029.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.fixed?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+use std::net::TcpListener;\n+\n+struct NoToSocketAddrs(String);\n+\n+impl std::ops::Deref for NoToSocketAddrs {\n+    type Target = String;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let _works = TcpListener::bind(\"some string\");\n+    let bad = NoToSocketAddrs(\"bad\".to_owned());\n+    let _errors = TcpListener::bind(&*bad);\n+    //~^ ERROR the trait bound `NoToSocketAddrs: std::net::ToSocketAddrs` is not satisfied\n+}"}, {"sha": "33d524608a05826f350d50bc10189b52c203e45d", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-39029.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+use std::net::TcpListener;\n+\n+struct NoToSocketAddrs(String);\n+\n+impl std::ops::Deref for NoToSocketAddrs {\n+    type Target = String;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let _works = TcpListener::bind(\"some string\");\n+    let bad = NoToSocketAddrs(\"bad\".to_owned());\n+    let _errors = TcpListener::bind(&bad);\n+    //~^ ERROR the trait bound `NoToSocketAddrs: std::net::ToSocketAddrs` is not satisfied\n+}"}, {"sha": "0bf9794a744c90c71b218fa2fdea6ad79d75e755", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-39029.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-39029.stderr?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `NoToSocketAddrs: std::net::ToSocketAddrs` is not satisfied\n+  --> $DIR/trait-suggest-deferences-issue-39029.rs:16:37\n+   |\n+LL |     let _errors = TcpListener::bind(&bad);\n+   |                                     ^^^^\n+   |                                     |\n+   |                                     the trait `std::net::ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n+   |                                     help: consider adding dereference here: `&*bad`\n+   | \n+  ::: $SRC_DIR/libstd/net/tcp.rs:LL:COL\n+   |\n+LL |     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n+   |                    ------------- required by this bound in `std::net::TcpListener::bind`\n+   |\n+   = note: required because of the requirements on the impl of `std::net::ToSocketAddrs` for `&NoToSocketAddrs`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "fa7b9167d8d7f06650643caff81ae62fa7e65522", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-62530.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.fixed?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+fn takes_str(_x: &str) {}\n+\n+fn takes_type_parameter<T>(_x: T) where T: SomeTrait {}\n+\n+trait SomeTrait {}\n+impl SomeTrait for &'_ str {}\n+impl SomeTrait for char {}\n+\n+fn main() {\n+    let string = String::new();\n+    takes_str(&string);             // Ok\n+    takes_type_parameter(&*string);  // Error\n+    //~^ ERROR the trait bound `&std::string::String: SomeTrait` is not satisfied\n+}"}, {"sha": "e785f01217735b0efc3bf217de9e3ad36e0288a8", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-62530.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+fn takes_str(_x: &str) {}\n+\n+fn takes_type_parameter<T>(_x: T) where T: SomeTrait {}\n+\n+trait SomeTrait {}\n+impl SomeTrait for &'_ str {}\n+impl SomeTrait for char {}\n+\n+fn main() {\n+    let string = String::new();\n+    takes_str(&string);             // Ok\n+    takes_type_parameter(&string);  // Error\n+    //~^ ERROR the trait bound `&std::string::String: SomeTrait` is not satisfied\n+}"}, {"sha": "9c2a582638ecbdd60c745d5467d10f646ba8c11c", "filename": "src/test/ui/traits/trait-suggest-deferences-issue-62530.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-issue-62530.stderr?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&std::string::String: SomeTrait` is not satisfied\n+  --> $DIR/trait-suggest-deferences-issue-62530.rs:13:26\n+   |\n+LL | fn takes_type_parameter<T>(_x: T) where T: SomeTrait {}\n+   |                                            --------- required by this bound in `takes_type_parameter`\n+...\n+LL |     takes_type_parameter(&string);  // Error\n+   |                          ^^^^^^^\n+   |                          |\n+   |                          the trait `SomeTrait` is not implemented for `&std::string::String`\n+   |                          help: consider adding dereference here: `&*string`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "b7160b75c605ed966f4b05dbe97b9bebd15101d7", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-0.fixed", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.fixed?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+use std::ops::Deref;\n+\n+trait Happy {}\n+struct LDM;\n+impl Happy for &LDM {}\n+\n+struct Foo(LDM);\n+struct Bar(Foo);\n+struct Baz(Bar);\n+impl Deref for Foo {\n+    type Target = LDM;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Baz {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn foo<T>(_: T) where T: Happy {}\n+\n+fn main() {\n+    let baz = Baz(Bar(Foo(LDM)));\n+    foo(&***baz);\n+    //~^ ERROR the trait bound `&Baz: Happy` is not satisfied\n+}"}, {"sha": "9ac55177ffadd1d337db6c75cbfc6126b340f92f", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-0.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+use std::ops::Deref;\n+\n+trait Happy {}\n+struct LDM;\n+impl Happy for &LDM {}\n+\n+struct Foo(LDM);\n+struct Bar(Foo);\n+struct Baz(Bar);\n+impl Deref for Foo {\n+    type Target = LDM;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Baz {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn foo<T>(_: T) where T: Happy {}\n+\n+fn main() {\n+    let baz = Baz(Bar(Foo(LDM)));\n+    foo(&baz);\n+    //~^ ERROR the trait bound `&Baz: Happy` is not satisfied\n+}"}, {"sha": "add34a553bc9fbdab247953b48a0c23c7a113ebd", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-0.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-0.stderr?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&Baz: Happy` is not satisfied\n+  --> $DIR/trait-suggest-deferences-multiple-0.rs:34:9\n+   |\n+LL | fn foo<T>(_: T) where T: Happy {}\n+   |                          ----- required by this bound in `foo`\n+...\n+LL |     foo(&baz);\n+   |         ^^^^\n+   |         |\n+   |         the trait `Happy` is not implemented for `&Baz`\n+   |         help: consider adding dereference here: `&***baz`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "91c6c7924a4082d911025bcc264ec1a77124a777", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-1.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.rs?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,54 @@\n+use std::ops::{Deref, DerefMut};\n+\n+trait Happy {}\n+struct LDM;\n+impl Happy for &mut LDM {}\n+\n+struct Foo(LDM);\n+struct Bar(Foo);\n+struct Baz(Bar);\n+impl Deref for Foo {\n+    type Target = LDM;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl Deref for Baz {\n+    type Target = Bar;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Bar {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+impl DerefMut for Baz {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+\n+fn foo<T>(_: T) where T: Happy {}\n+\n+fn main() {\n+    // Currently the compiler doesn't try to suggest dereferences for situations\n+    // where DerefMut involves. So this test is meant to ensure compiler doesn't\n+    // generate incorrect help message.\n+    let mut baz = Baz(Bar(Foo(LDM)));\n+    foo(&mut baz);\n+    //~^ ERROR the trait bound `&mut Baz: Happy` is not satisfied\n+}"}, {"sha": "e90278fa16f0ee2d600958cf85835a17ac25a0c7", "filename": "src/test/ui/traits/trait-suggest-deferences-multiple-1.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1404a93f9632d768d7268934e6380a9b9614834/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-deferences-multiple-1.stderr?ref=a1404a93f9632d768d7268934e6380a9b9614834", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `&mut Baz: Happy` is not satisfied\n+  --> $DIR/trait-suggest-deferences-multiple-1.rs:52:9\n+   |\n+LL | fn foo<T>(_: T) where T: Happy {}\n+   |                          ----- required by this bound in `foo`\n+...\n+LL |     foo(&mut baz);\n+   |         ^^^^^^^^ the trait `Happy` is not implemented for `&mut Baz`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}