{"sha": "93e41d3305c683a4ed19ff3001832f8c84090310", "node_id": "C_kwDOAAsO6NoAKDkzZTQxZDMzMDVjNjgzYTRlZDE5ZmYzMDAxODMyZjhjODQwOTAzMTA", "commit": {"author": {"name": "Evan Typanski", "email": "evan.typanski@microfocus.com", "date": "2022-06-22T17:26:13Z"}, "committer": {"name": "Evan Typanski", "email": "evan.typanski@microfocus.com", "date": "2022-06-22T18:23:04Z"}, "message": "Fix case where rem was considered commutative", "tree": {"sha": "ab4b6227b2d48fd33a357928515d7073ab638885", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab4b6227b2d48fd33a357928515d7073ab638885"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93e41d3305c683a4ed19ff3001832f8c84090310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93e41d3305c683a4ed19ff3001832f8c84090310", "html_url": "https://github.com/rust-lang/rust/commit/93e41d3305c683a4ed19ff3001832f8c84090310", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93e41d3305c683a4ed19ff3001832f8c84090310/comments", "author": null, "committer": null, "parents": [{"sha": "75ed0c9f267c8e65d3bbd45c6e10acd11e702077", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ed0c9f267c8e65d3bbd45c6e10acd11e702077", "html_url": "https://github.com/rust-lang/rust/commit/75ed0c9f267c8e65d3bbd45c6e10acd11e702077"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "9b31e70e3f06ae1c44f01ae1f4ad9abd56d9efaf", "filename": "clippy_lints/src/manual_rem_euclid.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/93e41d3305c683a4ed19ff3001832f8c84090310/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e41d3305c683a4ed19ff3001832f8c84090310/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs?ref=93e41d3305c683a4ed19ff3001832f8c84090310", "patch": "@@ -55,13 +55,13 @@ impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n         if_chain! {\n             if let ExprKind::Binary(op1, ..) = expr.kind;\n             if op1.node == BinOpKind::Rem;\n-            if let Some((const1, expr1)) = check_for_positive_int_constant(cx, expr);\n+            if let Some((const1, expr1)) = check_for_positive_int_constant(cx, expr, false);\n             if let ExprKind::Binary(op2, ..) = expr1.kind;\n             if op2.node == BinOpKind::Add;\n-            if let Some((const2, expr2)) = check_for_positive_int_constant(cx, expr1);\n+            if let Some((const2, expr2)) = check_for_positive_int_constant(cx, expr1, true);\n             if let ExprKind::Binary(op3, ..) = expr2.kind;\n             if op3.node == BinOpKind::Rem;\n-            if let Some((const3, expr3)) = check_for_positive_int_constant(cx, expr2);\n+            if let Some((const3, expr3)) = check_for_positive_int_constant(cx, expr2, false);\n             if const1 == const2 && const2 == const3;\n             // Only apply if we see an explicit type annotation on the local.\n             if let Some(hir_id) = path_to_local(expr3);\n@@ -91,13 +91,18 @@ impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n }\n \n // Takes a binary expression and separates the operands into the int constant and the other\n-// operand. Ensures the int constant is positive.\n-fn check_for_positive_int_constant<'a>(cx: &'a LateContext<'_>, expr: &'a Expr<'_>) -> Option<(u128, &'a Expr<'a>)> {\n+// operand. Ensures the int constant is positive. Operators that are not commutative must have the\n+// constant appear on the right hand side to return a value.\n+fn check_for_positive_int_constant<'a>(\n+    cx: &'a LateContext<'_>,\n+    expr: &'a Expr<'_>,\n+    is_commutative: bool,\n+) -> Option<(u128, &'a Expr<'a>)> {\n     let (int_const, other_op) = if let ExprKind::Binary(_, left, right) = expr.kind {\n-        if let Some(int_const) = constant_full_int(cx, cx.typeck_results(), left) {\n-            (int_const, right)\n-        } else if let Some(int_const) = constant_full_int(cx, cx.typeck_results(), right) {\n+        if let Some(int_const) = constant_full_int(cx, cx.typeck_results(), right) {\n             (int_const, left)\n+        } else if is_commutative && let Some(int_const) = constant_full_int(cx, cx.typeck_results(), left) {\n+            (int_const, right)\n         } else {\n             return None;\n         }"}, {"sha": "d0aa23988116b8aee82802f92635d59ce6cd5f23", "filename": "tests/ui/manual_rem_euclid.fixed", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93e41d3305c683a4ed19ff3001832f8c84090310/tests%2Fui%2Fmanual_rem_euclid.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/93e41d3305c683a4ed19ff3001832f8c84090310/tests%2Fui%2Fmanual_rem_euclid.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_rem_euclid.fixed?ref=93e41d3305c683a4ed19ff3001832f8c84090310", "patch": "@@ -21,4 +21,8 @@ fn main() {\n     let _ = ((not_annotated % 4) + 4) % 4;\n     let inferred: _ = 24;\n     let _ = ((inferred % 4) + 4) % 4;\n+\n+    // For lint to apply the constant must always be on the RHS of the previous value for %\n+    let _: i32 = 4 % ((value % 4) + 4);\n+    let _: i32 = ((4 % value) + 4) % 4;\n }"}, {"sha": "ff87d6fab52c2791548fca91dca92622df8d6c1f", "filename": "tests/ui/manual_rem_euclid.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93e41d3305c683a4ed19ff3001832f8c84090310/tests%2Fui%2Fmanual_rem_euclid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e41d3305c683a4ed19ff3001832f8c84090310/tests%2Fui%2Fmanual_rem_euclid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_rem_euclid.rs?ref=93e41d3305c683a4ed19ff3001832f8c84090310", "patch": "@@ -21,4 +21,8 @@ fn main() {\n     let _ = ((not_annotated % 4) + 4) % 4;\n     let inferred: _ = 24;\n     let _ = ((inferred % 4) + 4) % 4;\n+\n+    // For lint to apply the constant must always be on the RHS of the previous value for %\n+    let _: i32 = 4 % ((value % 4) + 4);\n+    let _: i32 = ((4 % value) + 4) % 4;\n }"}]}