{"sha": "3aa233d3dc0ad43f8693e4638e33e81ddf03b96b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYTIzM2QzZGMwYWQ0M2Y4NjkzZTQ2MzhlMzNlODFkZGYwM2I5NmI=", "commit": {"author": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-07-31T04:14:17Z"}, "committer": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-08-12T19:04:53Z"}, "message": "Rebase the LineWriter refactor to the new stdlib layout", "tree": {"sha": "0e36f5a7c0ce74ef85c39b06995fb87638f19d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e36f5a7c0ce74ef85c39b06995fb87638f19d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aa233d3dc0ad43f8693e4638e33e81ddf03b96b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aa233d3dc0ad43f8693e4638e33e81ddf03b96b", "html_url": "https://github.com/rust-lang/rust/commit/3aa233d3dc0ad43f8693e4638e33e81ddf03b96b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aa233d3dc0ad43f8693e4638e33e81ddf03b96b/comments", "author": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3df25ae186e89c885d9a71cd37fbd7a37e39fc85", "url": "https://api.github.com/repos/rust-lang/rust/commits/3df25ae186e89c885d9a71cd37fbd7a37e39fc85", "html_url": "https://github.com/rust-lang/rust/commit/3df25ae186e89c885d9a71cd37fbd7a37e39fc85"}], "stats": {"total": 912, "additions": 736, "deletions": 176}, "files": [{"sha": "de33c7fe1209ca5c779cad4ae2443703ad8d15ce", "filename": "library/std/src/io/buffered.rs", "status": "modified", "additions": 736, "deletions": 176, "changes": 912, "blob_url": "https://github.com/rust-lang/rust/blob/3aa233d3dc0ad43f8693e4638e33e81ddf03b96b/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aa233d3dc0ad43f8693e4638e33e81ddf03b96b/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs?ref=3aa233d3dc0ad43f8693e4638e33e81ddf03b96b", "patch": "@@ -518,33 +518,80 @@ impl<W: Write> BufWriter<W> {\n         BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n     }\n \n+    /// Send data in our local buffer into the inner writer, looping as\n+    /// necessary until either it's all been sent or an error occurs.\n+    ///\n+    /// Because all the data in the buffer has been reported to our owner as\n+    /// \"successfully written\" (by returning nonzero success values from\n+    /// `write`), any 0-length writes from `inner` must be reported as i/o\n+    /// errors from this method.\n     fn flush_buf(&mut self) -> io::Result<()> {\n-        let mut written = 0;\n-        let len = self.buf.len();\n-        let mut ret = Ok(());\n-        while written < len {\n+        /// Helper struct to ensure the buffer is updated after all the writes\n+        /// are complete\n+        struct BufGuard<'a> {\n+            buffer: &'a mut Vec<u8>,\n+            written: usize,\n+        }\n+\n+        impl<'a> BufGuard<'a> {\n+            fn new(buffer: &'a mut Vec<u8>) -> Self {\n+                Self { buffer, written: 0 }\n+            }\n+\n+            /// The unwritten part of the buffer\n+            fn remaining(&self) -> &[u8] {\n+                &self.buffer[self.written..]\n+            }\n+\n+            /// Flag some bytes as removed from the front of the buffer\n+            fn consume(&mut self, amt: usize) {\n+                self.written += amt;\n+            }\n+\n+            /// true if all of the bytes have been written\n+            fn done(&self) -> bool {\n+                self.written >= self.buffer.len()\n+            }\n+        }\n+\n+        impl Drop for BufGuard<'_> {\n+            fn drop(&mut self) {\n+                if self.written > 0 {\n+                    self.buffer.drain(..self.written);\n+                }\n+            }\n+        }\n+\n+        let mut guard = BufGuard::new(&mut self.buf);\n+        let inner = self.inner.as_mut().unwrap();\n+        while !guard.done() {\n             self.panicked = true;\n-            let r = self.inner.as_mut().unwrap().write(&self.buf[written..]);\n+            let r = inner.write(guard.remaining());\n             self.panicked = false;\n \n             match r {\n                 Ok(0) => {\n-                    ret =\n-                        Err(Error::new(ErrorKind::WriteZero, \"failed to write the buffered data\"));\n-                    break;\n+                    return Err(Error::new(\n+                        ErrorKind::WriteZero,\n+                        \"failed to write the buffered data\",\n+                    ));\n                 }\n-                Ok(n) => written += n,\n+                Ok(n) => guard.consume(n),\n                 Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => {\n-                    ret = Err(e);\n-                    break;\n-                }\n+                Err(e) => return Err(e),\n             }\n         }\n-        if written > 0 {\n-            self.buf.drain(..written);\n-        }\n-        ret\n+        Ok(())\n+    }\n+\n+    /// Buffer some data without flushing it, regardless of the size of the\n+    /// data. Writes as much as possible without exceeding capacity. Returns\n+    /// the number of bytes written.\n+    fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n+        let available = self.buf.capacity() - self.buf.len();\n+        let amt_to_buffer = available.min(buf.len());\n+        self.buf.extend_from_slice(&buf[..amt_to_buffer]);\n+        amt_to_buffer\n     }\n \n     /// Gets a reference to the underlying writer.\n@@ -657,13 +704,35 @@ impl<W: Write> Write for BufWriter<W> {\n         if self.buf.len() + buf.len() > self.buf.capacity() {\n             self.flush_buf()?;\n         }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n         if buf.len() >= self.buf.capacity() {\n             self.panicked = true;\n             let r = self.get_mut().write(buf);\n             self.panicked = false;\n             r\n         } else {\n-            self.buf.write(buf)\n+            self.buf.extend_from_slice(buf);\n+            Ok(buf.len())\n+        }\n+    }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        // Normally, `write_all` just calls `write` in a loop. We can do better\n+        // by calling `self.get_mut().write_all()` directly, which avoids\n+        // round trips through the buffer in the event of a series of partial\n+        // writes in some circumstances.\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write_all(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.extend_from_slice(buf);\n+            Ok(())\n         }\n     }\n \n@@ -672,13 +741,15 @@ impl<W: Write> Write for BufWriter<W> {\n         if self.buf.len() + total_len > self.buf.capacity() {\n             self.flush_buf()?;\n         }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n         if total_len >= self.buf.capacity() {\n             self.panicked = true;\n             let r = self.get_mut().write_vectored(bufs);\n             self.panicked = false;\n             r\n         } else {\n-            self.buf.write_vectored(bufs)\n+            bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n+            Ok(total_len)\n         }\n     }\n \n@@ -710,7 +781,8 @@ impl<W: Write + Seek> Seek for BufWriter<W> {\n     ///\n     /// Seeking always writes out the internal buffer before seeking.\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n-        self.flush_buf().and_then(|_| self.get_mut().seek(pos))\n+        self.flush_buf()?;\n+        self.get_mut().seek(pos)\n     }\n }\n \n@@ -816,6 +888,268 @@ impl<W> fmt::Display for IntoInnerError<W> {\n     }\n }\n \n+/// Private helper struct for implementing the line-buffered writing logic.\n+/// This shim temporarily wraps a BufWriter, and uses its internals to\n+/// implement a line-buffered writer (specifically by using the internal\n+/// methods like write_to_buf and flush_buf). In this way, a more\n+/// efficient abstraction can be created than one that only had access to\n+/// `write` and `flush`, without needlessly duplicating a lot of the\n+/// implementation details of BufWriter. This also allows existing\n+/// `BufWriters` to be temporarily given line-buffering logic; this is what\n+/// enables Stdout to be alternately in line-buffered or block-buffered mode.\n+#[derive(Debug)]\n+pub(super) struct LineWriterShim<'a, W: Write> {\n+    buffer: &'a mut BufWriter<W>,\n+}\n+\n+impl<'a, W: Write> LineWriterShim<'a, W> {\n+    pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n+        Self { buffer }\n+    }\n+\n+    /// Get a mutable reference to the inner writer (that is, the writer\n+    /// wrapped by the BufWriter). Be careful with this writer, as writes to\n+    /// it will bypass the buffer.\n+    fn inner_mut(&mut self) -> &mut W {\n+        self.buffer.get_mut()\n+    }\n+\n+    /// Get the content currently buffered in self.buffer\n+    fn buffered(&self) -> &[u8] {\n+        self.buffer.buffer()\n+    }\n+\n+    /// Flush the buffer iff the last byte is a newline (indicating that an\n+    /// earlier write only succeeded partially, and we want to retry flushing\n+    /// the buffered line before continuing with a subsequent write)\n+    fn flush_if_completed_line(&mut self) -> io::Result<()> {\n+        match self.buffered().last().copied() {\n+            Some(b'\\n') => self.buffer.flush_buf(),\n+            _ => Ok(()),\n+        }\n+    }\n+}\n+\n+impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n+    /// Write some data into this BufReader with line buffering. This means\n+    /// that, if any newlines are present in the data, the data up to the last\n+    /// newline is sent directly to the underlying writer, and data after it\n+    /// is buffered. Returns the number of bytes written.\n+    ///\n+    /// This function operates on a \"best effort basis\"; in keeping with the\n+    /// convention of `Write::write`, it makes at most one attempt to write\n+    /// new data to the underlying writer. If that write only reports a partial\n+    /// success, the remaining data will be buffered.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it contains any\n+    /// newlines, even if the incoming data does not contain any newlines.\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n+            // If there are no new newlines (that is, if this write is less than\n+            // one line), just do a regular buffered write\n+            None => {\n+                self.flush_if_completed_line()?;\n+                return self.buffer.write(buf);\n+            }\n+            // Otherwise, arrange for the lines to be written directly to the\n+            // inner writer.\n+            Some(newline_idx) => newline_idx + 1,\n+        };\n+\n+        // Flush existing content to prepare for our write\n+        self.buffer.flush_buf()?;\n+\n+        // This is what we're going to try to write directly to the inner\n+        // writer. The rest will be buffered, if nothing goes wrong.\n+        let lines = &buf[..newline_idx];\n+\n+        // Write `lines` directly to the inner writer. In keeping with the\n+        // `write` convention, make at most one attempt to add new (unbuffered)\n+        // data. Because this write doesn't touch the BufWriter state directly,\n+        // and the buffer is known to be empty, we don't need to worry about\n+        // self.buffer.panicked here.\n+        let flushed = self.inner_mut().write(lines)?;\n+\n+        // If buffer returns Ok(0), propagate that to the caller without\n+        // doing additional buffering; otherwise we're just guaranteeing\n+        // an \"ErrorKind::WriteZero\" later.\n+        if flushed == 0 {\n+            return Ok(0);\n+        }\n+\n+        // Now that the write has succeeded, buffer the rest (or as much of\n+        // the rest as possible). If there were any unwritten newlines, we\n+        // only buffer out to the last unwritten newline that fits in the\n+        // buffer; this helps prevent flushing partial lines on subsequent\n+        // calls to LineWriterShim::write.\n+\n+        // Handle the cases in order of most-common to least-common, under\n+        // the presumption that most writes succeed in totality, and that most\n+        // writes are smaller than the buffer.\n+        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n+        // - If not, does the data out to the last unwritten newline fit in\n+        //   the buffer?\n+        // - If not, scan for the last newline that *does* fit in the buffer\n+        let tail = if flushed >= newline_idx {\n+            &buf[flushed..]\n+        } else if newline_idx - flushed <= self.buffer.capacity() {\n+            &buf[flushed..newline_idx]\n+        } else {\n+            let scan_area = &buf[flushed..];\n+            let scan_area = &scan_area[..self.buffer.capacity()];\n+            match memchr::memrchr(b'\\n', scan_area) {\n+                Some(newline_idx) => &scan_area[..newline_idx + 1],\n+                None => scan_area,\n+            }\n+        };\n+\n+        let buffered = self.buffer.write_to_buf(tail);\n+        Ok(flushed + buffered)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.buffer.flush()\n+    }\n+\n+    /// Write some vectored data into this BufReader with line buffering. This\n+    /// means that, if any newlines are present in the data, the data up to\n+    /// and including the buffer containing the last newline is sent directly\n+    /// to the inner writer, and the data after it is buffered. Returns the\n+    /// number of bytes written.\n+    ///\n+    /// This function operates on a \"best effort basis\"; in keeping with the\n+    /// convention of `Write::write`, it makes at most one attempt to write\n+    /// new data to the underlying writer.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it contains any\n+    /// newlines.\n+    ///\n+    /// Because sorting through an array of `IoSlice` can be a bit convoluted,\n+    /// This method differs from write in the following ways:\n+    ///\n+    /// - It attempts to write the full content of all the buffers up to and\n+    ///   including the one containing the last newline. This means that it\n+    ///   may attempt to write a partial line, that buffer has data past the\n+    ///   newline.\n+    /// - If the write only reports partial success, it does not attempt to\n+    ///   find the precise location of the written bytes and buffer the rest.\n+    ///\n+    /// If the underlying vector doesn't support vectored writing, we instead\n+    /// simply write the first non-empty buffer with `write`. This way, we\n+    /// get the benefits of more granular partial-line handling without losing\n+    /// anything in efficiency\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        // If there's no specialized behavior for write_vectored, just use\n+        // write. This has the benefit of more granular partial-line handling.\n+        if !self.is_write_vectored() {\n+            return match bufs.iter().find(|buf| !buf.is_empty()) {\n+                Some(buf) => self.write(buf),\n+                None => Ok(0),\n+            };\n+        }\n+\n+        // Find the buffer containing the last newline\n+        let last_newline_buf_idx = bufs\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n+\n+        // If there are no new newlines (that is, if this write is less than\n+        // one line), just do a regular buffered write\n+        let last_newline_buf_idx = match last_newline_buf_idx {\n+            // No newlines; just do a normal buffered write\n+            None => {\n+                self.flush_if_completed_line()?;\n+                return self.buffer.write_vectored(bufs);\n+            }\n+            Some(i) => i,\n+        };\n+\n+        // Flush existing content to prepare for our write\n+        self.buffer.flush_buf()?;\n+\n+        // This is what we're going to try to write directly to the inner\n+        // writer. The rest will be buffered, if nothing goes wrong.\n+        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n+\n+        // Write `lines` directly to the inner writer. In keeping with the\n+        // `write` convention, make at most one attempt to add new (unbuffered)\n+        // data. Because this write doesn't touch the BufWriter state directly,\n+        // and the buffer is known to be empty, we don't need to worry about\n+        // self.panicked here.\n+        let flushed = self.inner_mut().write_vectored(lines)?;\n+\n+        // If inner returns Ok(0), propagate that to the caller without\n+        // doing additional buffering; otherwise we're just guaranteeing\n+        // an \"ErrorKind::WriteZero\" later.\n+        if flushed == 0 {\n+            return Ok(0);\n+        }\n+\n+        // Don't try to reconstruct the exact amount written; just bail\n+        // in the event of a partial write\n+        let lines_len = lines.iter().map(|buf| buf.len()).sum();\n+        if flushed < lines_len {\n+            return Ok(flushed);\n+        }\n+\n+        // Now that the write has succeeded, buffer the rest (or as much of the\n+        // rest as possible)\n+        let buffered: usize = tail\n+            .iter()\n+            .filter(|buf| !buf.is_empty())\n+            .map(|buf| self.buffer.write_to_buf(buf))\n+            .take_while(|&n| n > 0)\n+            .sum();\n+\n+        Ok(flushed + buffered)\n+    }\n+\n+    fn is_write_vectored(&self) -> bool {\n+        self.buffer.is_write_vectored()\n+    }\n+\n+    /// Write some data into this BufReader with line buffering. This means\n+    /// that, if any newlines are present in the data, the data up to the last\n+    /// newline is sent directly to the underlying writer, and data after it\n+    /// is buffered.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it contains any\n+    /// newlines, even if the incoming data does not contain any newlines.\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n+            // If there are no new newlines (that is, if this write is less than\n+            // one line), just do a regular buffered write\n+            None => {\n+                self.flush_if_completed_line()?;\n+                return self.buffer.write_all(buf);\n+            }\n+            // Otherwise, arrange for the lines to be written directly to the\n+            // inner writer.\n+            Some(newline_idx) => newline_idx,\n+        };\n+\n+        // Flush existing content to prepare for our write\n+        self.buffer.flush_buf()?;\n+\n+        // This is what we're going to try to write directly to the inner\n+        // writer. The rest will be buffered, if nothing goes wrong.\n+        let (lines, tail) = buf.split_at(newline_idx + 1);\n+\n+        // Write `lines` directly to the inner writer, bypassing the buffer.\n+        self.inner_mut().write_all(lines)?;\n+\n+        // Now that the write has succeeded, buffer the rest with\n+        // BufWriter::write_all. This will buffer as much as possible, but\n+        // continue flushing as necessary if our tail is huge.\n+        self.buffer.write_all(tail)\n+    }\n+}\n+\n /// Wraps a writer and buffers output to it, flushing whenever a newline\n /// (`0x0a`, `'\\n'`) is detected.\n ///\n@@ -883,7 +1217,6 @@ impl<W> fmt::Display for IntoInnerError<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LineWriter<W: Write> {\n     inner: BufWriter<W>,\n-    need_flush: bool,\n }\n \n impl<W: Write> LineWriter<W> {\n@@ -924,7 +1257,7 @@ impl<W: Write> LineWriter<W> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n-        LineWriter { inner: BufWriter::with_capacity(capacity, inner), need_flush: false }\n+        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n     }\n \n     /// Gets a reference to the underlying writer.\n@@ -998,110 +1331,40 @@ impl<W: Write> LineWriter<W> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n-        self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n-            IntoInnerError(LineWriter { inner: buf, need_flush: false }, e)\n-        })\n+        self.inner\n+            .into_inner()\n+            .map_err(|IntoInnerError(buf, e)| IntoInnerError(LineWriter { inner: buf }, e))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Write for LineWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        if self.need_flush {\n-            self.flush()?;\n-        }\n-\n-        // Find the last newline character in the buffer provided. If found then\n-        // we're going to write all the data up to that point and then flush,\n-        // otherwise we just write the whole block to the underlying writer.\n-        let i = match memchr::memrchr(b'\\n', buf) {\n-            Some(i) => i,\n-            None => return self.inner.write(buf),\n-        };\n-\n-        // Ok, we're going to write a partial amount of the data given first\n-        // followed by flushing the newline. After we've successfully written\n-        // some data then we *must* report that we wrote that data, so future\n-        // errors are ignored. We set our internal `need_flush` flag, though, in\n-        // case flushing fails and we need to try it first next time.\n-        let n = self.inner.write(&buf[..=i])?;\n-        self.need_flush = true;\n-        if self.flush().is_err() || n != i + 1 {\n-            return Ok(n);\n-        }\n+        LineWriterShim::new(&mut self.inner).write(buf)\n+    }\n \n-        // At this point we successfully wrote `i + 1` bytes and flushed it out,\n-        // meaning that the entire line is now flushed out on the screen. While\n-        // we can attempt to finish writing the rest of the data provided.\n-        // Remember though that we ignore errors here as we've successfully\n-        // written data, so we need to report that.\n-        match self.inner.write(&buf[i + 1..]) {\n-            Ok(i) => Ok(n + i),\n-            Err(_) => Ok(n),\n-        }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.flush()\n     }\n \n-    // Vectored writes are very similar to the writes above, but adjusted for\n-    // the list of buffers that we have to write.\n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        if self.need_flush {\n-            self.flush()?;\n-        }\n+        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n+    }\n \n-        // Find the last newline, and failing that write the whole buffer\n-        let last_newline = bufs.iter().enumerate().rev().find_map(|(i, buf)| {\n-            let pos = memchr::memrchr(b'\\n', buf)?;\n-            Some((i, pos))\n-        });\n-        let (i, j) = match last_newline {\n-            Some(pair) => pair,\n-            None => return self.inner.write_vectored(bufs),\n-        };\n-        let (prefix, suffix) = bufs.split_at(i);\n-        let (buf, suffix) = suffix.split_at(1);\n-        let buf = &buf[0];\n-\n-        // Write everything up to the last newline, flushing afterwards. Note\n-        // that only if we finished our entire `write_vectored` do we try the\n-        // subsequent\n-        // `write`\n-        let mut n = 0;\n-        let prefix_amt = prefix.iter().map(|i| i.len()).sum();\n-        if prefix_amt > 0 {\n-            n += self.inner.write_vectored(prefix)?;\n-            self.need_flush = true;\n-        }\n-        if n == prefix_amt {\n-            match self.inner.write(&buf[..=j]) {\n-                Ok(m) => n += m,\n-                Err(e) if n == 0 => return Err(e),\n-                Err(_) => return Ok(n),\n-            }\n-            self.need_flush = true;\n-        }\n-        if self.flush().is_err() || n != j + 1 + prefix_amt {\n-            return Ok(n);\n-        }\n+    fn is_write_vectored(&self) -> bool {\n+        self.inner.is_write_vectored()\n+    }\n \n-        // ... and now write out everything remaining\n-        match self.inner.write(&buf[j + 1..]) {\n-            Ok(i) => n += i,\n-            Err(_) => return Ok(n),\n-        }\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_all(buf)\n+    }\n \n-        if suffix.iter().map(|s| s.len()).sum::<usize>() == 0 {\n-            return Ok(n);\n-        }\n-        match self.inner.write_vectored(suffix) {\n-            Ok(i) => Ok(n + i),\n-            Err(_) => Ok(n),\n-        }\n+    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> {\n-        self.inner.flush()?;\n-        self.need_flush = false;\n-        Ok(())\n+    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n     }\n }\n \n@@ -1124,7 +1387,7 @@ where\n #[cfg(test)]\n mod tests {\n     use crate::io::prelude::*;\n-    use crate::io::{self, BufReader, BufWriter, IoSlice, LineWriter, SeekFrom};\n+    use crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom};\n     use crate::sync::atomic::{AtomicUsize, Ordering};\n     use crate::thread;\n \n@@ -1133,6 +1396,9 @@ mod tests {\n         lengths: Vec<usize>,\n     }\n \n+    // FIXME: rustfmt and tidy disagree about the correct formatting of this\n+    // function. This leads to issues for users with editors configured to\n+    // rustfmt-on-save.\n     impl Read for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n             if self.lengths.is_empty() { Ok(0) } else { Ok(self.lengths.remove(0)) }\n@@ -1408,34 +1674,6 @@ mod tests {\n         assert_eq!(v, []);\n     }\n \n-    #[test]\n-    fn test_line_buffer_fail_flush() {\n-        // Issue #32085\n-        struct FailFlushWriter<'a>(&'a mut Vec<u8>);\n-\n-        impl Write for FailFlushWriter<'_> {\n-            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-                self.0.extend_from_slice(buf);\n-                Ok(buf.len())\n-            }\n-            fn flush(&mut self) -> io::Result<()> {\n-                Err(io::Error::new(io::ErrorKind::Other, \"flush failed\"))\n-            }\n-        }\n-\n-        let mut buf = Vec::new();\n-        {\n-            let mut writer = LineWriter::new(FailFlushWriter(&mut buf));\n-            let to_write = b\"abc\\ndef\";\n-            if let Ok(written) = writer.write(to_write) {\n-                assert!(written < to_write.len(), \"didn't flush on new line\");\n-                // PASS\n-                return;\n-            }\n-        }\n-        assert!(buf.is_empty(), \"write returned an error but wrote data\");\n-    }\n-\n     #[test]\n     fn test_line_buffer() {\n         let mut writer = LineWriter::new(Vec::new());\n@@ -1556,41 +1794,104 @@ mod tests {\n         b.iter(|| BufWriter::new(io::sink()));\n     }\n \n-    struct AcceptOneThenFail {\n-        written: bool,\n-        flushed: bool,\n+    /// A simple `Write` target, designed to be wrapped by `LineWriter` /\n+    /// `BufWriter` / etc, that can have its `write` & `flush` behavior\n+    /// configured\n+    #[derive(Default, Clone)]\n+    struct ProgrammableSink {\n+        // Writes append to this slice\n+        pub buffer: Vec<u8>,\n+\n+        // Flush sets this flag\n+        pub flushed: bool,\n+\n+        // If true, writes will always be an error\n+        pub always_write_error: bool,\n+\n+        // If true, flushes will always be an error\n+        pub always_flush_error: bool,\n+\n+        // If set, only up to this number of bytes will be written in a single\n+        // call to `write`\n+        pub accept_prefix: Option<usize>,\n+\n+        // If set, counts down with each write, and writes return an error\n+        // when it hits 0\n+        pub max_writes: Option<usize>,\n+\n+        // If set, attempting to write when max_writes == Some(0) will be an\n+        // error; otherwise, it will return Ok(0).\n+        pub error_after_max_writes: bool,\n     }\n \n-    impl Write for AcceptOneThenFail {\n+    impl Write for ProgrammableSink {\n         fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            if !self.written {\n-                assert_eq!(data, b\"a\\nb\\n\");\n-                self.written = true;\n-                Ok(data.len())\n-            } else {\n-                Err(io::Error::new(io::ErrorKind::NotFound, \"test\"))\n+            if self.always_write_error {\n+                return Err(io::Error::new(io::ErrorKind::Other, \"test - always_write_error\"));\n+            }\n+\n+            match self.max_writes {\n+                Some(0) if self.error_after_max_writes => {\n+                    return Err(io::Error::new(io::ErrorKind::Other, \"test - max_writes\"));\n+                }\n+                Some(0) => return Ok(0),\n+                Some(ref mut count) => *count -= 1,\n+                None => {}\n             }\n+\n+            let len = match self.accept_prefix {\n+                None => data.len(),\n+                Some(prefix) => data.len().min(prefix),\n+            };\n+\n+            let data = &data[..len];\n+            self.buffer.extend_from_slice(data);\n+\n+            Ok(len)\n         }\n \n         fn flush(&mut self) -> io::Result<()> {\n-            assert!(self.written);\n-            assert!(!self.flushed);\n-            self.flushed = true;\n-            Err(io::Error::new(io::ErrorKind::Other, \"test\"))\n+            if self.always_flush_error {\n+                Err(io::Error::new(io::ErrorKind::Other, \"test - always_flush_error\"))\n+            } else {\n+                self.flushed = true;\n+                Ok(())\n+            }\n         }\n     }\n \n+    /// Previously the `LineWriter` could successfully write some bytes but\n+    /// then fail to report that it has done so. Additionally, an erroneous\n+    /// flush after a successful write was permanently ignored.\n+    ///\n+    /// Test that a line writer correctly reports the number of written bytes,\n+    /// and that it attempts to flush buffered lines from previous writes\n+    /// before processing new data\n+    ///\n+    /// Regression test for #37807\n     #[test]\n     fn erroneous_flush_retried() {\n-        let a = AcceptOneThenFail { written: false, flushed: false };\n+        let writer = ProgrammableSink {\n+            // Only write up to 4 bytes at a time\n+            accept_prefix: Some(4),\n+\n+            // Accept the first two writes, then error the others\n+            max_writes: Some(2),\n+            error_after_max_writes: true,\n \n-        let mut l = LineWriter::new(a);\n-        assert_eq!(l.write(b\"a\\nb\\na\").unwrap(), 4);\n-        assert!(l.get_ref().written);\n-        assert!(l.get_ref().flushed);\n-        l.get_mut().flushed = false;\n+            ..Default::default()\n+        };\n+\n+        // This should write the first 4 bytes. The rest will be buffered, out\n+        // to the last newline.\n+        let mut writer = LineWriter::new(writer);\n+        assert_eq!(writer.write(b\"a\\nb\\nc\\nd\\ne\").unwrap(), 8);\n \n-        assert_eq!(l.write(b\"a\").unwrap_err().kind(), io::ErrorKind::Other)\n+        // This write should attempt to flush \"c\\nd\\n\", then buffer \"e\". No\n+        // errors should happen here because no further writes should be\n+        // attempted against `writer`.\n+        assert_eq!(writer.write(b\"e\").unwrap(), 1);\n+        assert_eq!(&writer.get_ref().buffer, b\"a\\nb\\nc\\nd\\n\");\n     }\n \n     #[test]\n@@ -1635,17 +1936,21 @@ mod tests {\n             0,\n         );\n         assert_eq!(a.write_vectored(&[IoSlice::new(b\"a\\nb\"),]).unwrap(), 3);\n-        assert_eq!(a.get_ref(), b\"\\nabaca\\n\");\n+        assert_eq!(a.get_ref(), b\"\\nabaca\\nb\");\n     }\n \n     #[test]\n     fn line_vectored_partial_and_errors() {\n+        use crate::collections::VecDeque;\n+\n         enum Call {\n             Write { inputs: Vec<&'static [u8]>, output: io::Result<usize> },\n             Flush { output: io::Result<()> },\n         }\n+\n+        #[derive(Default)]\n         struct Writer {\n-            calls: Vec<Call>,\n+            calls: VecDeque<Call>,\n         }\n \n         impl Write for Writer {\n@@ -1654,19 +1959,23 @@ mod tests {\n             }\n \n             fn write_vectored(&mut self, buf: &[IoSlice<'_>]) -> io::Result<usize> {\n-                match self.calls.pop().unwrap() {\n+                match self.calls.pop_front().expect(\"unexpected call to write\") {\n                     Call::Write { inputs, output } => {\n                         assert_eq!(inputs, buf.iter().map(|b| &**b).collect::<Vec<_>>());\n                         output\n                     }\n-                    _ => panic!(\"unexpected call to write\"),\n+                    Call::Flush { .. } => panic!(\"unexpected call to write; expected a flush\"),\n                 }\n             }\n \n+            fn is_write_vectored(&self) -> bool {\n+                true\n+            }\n+\n             fn flush(&mut self) -> io::Result<()> {\n-                match self.calls.pop().unwrap() {\n+                match self.calls.pop_front().expect(\"Unexpected call to flush\") {\n                     Call::Flush { output } => output,\n-                    _ => panic!(\"unexpected call to flush\"),\n+                    Call::Write { .. } => panic!(\"unexpected call to flush; expected a write\"),\n                 }\n             }\n         }\n@@ -1680,24 +1989,275 @@ mod tests {\n         }\n \n         // partial writes keep going\n-        let mut a = LineWriter::new(Writer { calls: Vec::new() });\n+        let mut a = LineWriter::new(Writer::default());\n         a.write_vectored(&[IoSlice::new(&[]), IoSlice::new(b\"abc\")]).unwrap();\n-        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n-        a.get_mut().calls.push(Call::Write { inputs: vec![b\"bcx\\n\"], output: Ok(4) });\n-        a.get_mut().calls.push(Call::Write { inputs: vec![b\"abcx\\n\"], output: Ok(1) });\n+\n+        a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"abc\"], output: Ok(1) });\n+        a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"bc\"], output: Ok(2) });\n+        a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\n\"], output: Ok(2) });\n+\n         a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\n\")]).unwrap();\n-        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n+\n+        a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n         a.flush().unwrap();\n \n         // erroneous writes stop and don't write more\n-        a.get_mut().calls.push(Call::Write { inputs: vec![b\"x\\n\"], output: Err(err()) });\n-        assert_eq!(a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\na\")]).unwrap(), 2);\n-        a.get_mut().calls.push(Call::Flush { output: Ok(()) });\n-        a.get_mut().calls.push(Call::Write { inputs: vec![b\"x\\n\"], output: Ok(2) });\n+        a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\na\"], output: Err(err()) });\n+        a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n+        assert!(a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\na\")]).is_err());\n         a.flush().unwrap();\n \n         fn err() -> io::Error {\n             io::Error::new(io::ErrorKind::Other, \"x\")\n         }\n     }\n+\n+    /// Test that, in cases where vectored writing is not enabled, the\n+    /// LineWriter uses the normal `write` call, which more-corectly handles\n+    /// partial lines\n+    #[test]\n+    fn line_vectored_ignored() {\n+        let writer = ProgrammableSink::default();\n+        let mut writer = LineWriter::new(writer);\n+\n+        let content = [\n+            IoSlice::new(&[]),\n+            IoSlice::new(b\"Line 1\\nLine\"),\n+            IoSlice::new(b\" 2\\nLine 3\\nL\"),\n+            IoSlice::new(&[]),\n+            IoSlice::new(&[]),\n+            IoSlice::new(b\"ine 4\"),\n+            IoSlice::new(b\"\\nLine 5\\n\"),\n+        ];\n+\n+        let count = writer.write_vectored(&content).unwrap();\n+        assert_eq!(count, 11);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+\n+        let count = writer.write_vectored(&content[2..]).unwrap();\n+        assert_eq!(count, 11);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n+\n+        let count = writer.write_vectored(&content[5..]).unwrap();\n+        assert_eq!(count, 5);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n+\n+        let count = writer.write_vectored(&content[6..]).unwrap();\n+        assert_eq!(count, 8);\n+        assert_eq!(\n+            writer.get_ref().buffer.as_slice(),\n+            b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n\".as_ref()\n+        );\n+    }\n+\n+    /// Test that, given this input:\n+    ///\n+    /// Line 1\\n\n+    /// Line 2\\n\n+    /// Line 3\\n\n+    /// Line 4\n+    ///\n+    /// And given a result that only writes to midway through Line 2\n+    ///\n+    /// That only up to the end of Line 3 is buffered\n+    ///\n+    /// This behavior is desirable because it prevents flushing partial lines\n+    #[test]\n+    fn partial_write_buffers_line() {\n+        let writer = ProgrammableSink { accept_prefix: Some(13), ..Default::default() };\n+        let mut writer = LineWriter::new(writer);\n+\n+        assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\\nLine4\").unwrap(), 21);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\");\n+\n+        assert_eq!(writer.write(b\"Line 4\").unwrap(), 6);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n+    }\n+\n+    /// Test that, given this input:\n+    ///\n+    /// Line 1\\n\n+    /// Line 2\\n\n+    /// Line 3\n+    ///\n+    /// And given that the full write of lines 1 and 2 was successful\n+    /// That data up to Line 3 is buffered\n+    #[test]\n+    fn partial_line_buffered_after_line_write() {\n+        let writer = ProgrammableSink::default();\n+        let mut writer = LineWriter::new(writer);\n+\n+        assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\").unwrap(), 20);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\n\");\n+\n+        assert!(writer.flush().is_ok());\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\");\n+    }\n+\n+    /// Test that, given a partial line that exceeds the length of\n+    /// LineBuffer's buffer (that is, without a trailing newline), that that\n+    /// line is written to the inner writer\n+    #[test]\n+    fn long_line_flushed() {\n+        let writer = ProgrammableSink::default();\n+        let mut writer = LineWriter::with_capacity(5, writer);\n+\n+        assert_eq!(writer.write(b\"0123456789\").unwrap(), 10);\n+        assert_eq!(&writer.get_ref().buffer, b\"0123456789\");\n+    }\n+\n+    /// Test that, given a very long partial line *after* successfully\n+    /// flushing a complete line, that that line is buffered unconditionally,\n+    /// and no additional writes take place. This assures the property that\n+    /// `write` should make at-most-one attempt to write new data.\n+    #[test]\n+    fn line_long_tail_not_flushed() {\n+        let writer = ProgrammableSink::default();\n+        let mut writer = LineWriter::with_capacity(5, writer);\n+\n+        // Assert that Line 1\\n is flushed, and 01234 is buffered\n+        assert_eq!(writer.write(b\"Line 1\\n0123456789\").unwrap(), 12);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+\n+        // Because the buffer is full, this subsequent write will flush it\n+        assert_eq!(writer.write(b\"5\").unwrap(), 1);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n01234\");\n+    }\n+\n+    /// Test that, if an attempt to pre-flush buffered data returns Ok(0),\n+    /// this is propagated as an error.\n+    #[test]\n+    fn line_buffer_write0_error() {\n+        let writer = ProgrammableSink {\n+            // Accept one write, then return Ok(0) on subsequent ones\n+            max_writes: Some(1),\n+\n+            ..Default::default()\n+        };\n+        let mut writer = LineWriter::new(writer);\n+\n+        // This should write \"Line 1\\n\" and buffer \"Partial\"\n+        assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+\n+        // This will attempt to flush \"partial\", which will return Ok(0), which\n+        // needs to be an error, because we've already informed the client\n+        // that we accepted the write.\n+        let err = writer.write(b\" Line End\\n\").unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::WriteZero);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+    }\n+\n+    /// Test that, if a write returns Ok(0) after a successful pre-flush, this\n+    /// is propogated as Ok(0)\n+    #[test]\n+    fn line_buffer_write0_normal() {\n+        let writer = ProgrammableSink {\n+            // Accept two writes, then return Ok(0) on subsequent ones\n+            max_writes: Some(2),\n+\n+            ..Default::default()\n+        };\n+        let mut writer = LineWriter::new(writer);\n+\n+        // This should write \"Line 1\\n\" and buffer \"Partial\"\n+        assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+\n+        // This will flush partial, which will succeed, but then return Ok(0)\n+        // when flushing \" Line End\\n\"\n+        assert_eq!(writer.write(b\" Line End\\n\").unwrap(), 0);\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nPartial\");\n+    }\n+\n+    /// LineWriter has a custom `write_all`; make sure it works correctly\n+    #[test]\n+    fn line_write_all() {\n+        let writer = ProgrammableSink {\n+            // Only write 5 bytes at a time\n+            accept_prefix: Some(5),\n+            ..Default::default()\n+        };\n+        let mut writer = LineWriter::new(writer);\n+\n+        writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\").unwrap();\n+        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\n\");\n+        writer.write_all(b\" Line 5\\n\").unwrap();\n+        assert_eq!(\n+            writer.get_ref().buffer.as_slice(),\n+            b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial Line 5\\n\".as_ref(),\n+        );\n+    }\n+\n+    #[test]\n+    fn line_write_all_error() {\n+        let writer = ProgrammableSink {\n+            // Only accept up to 3 writes of up to 5 bytes each\n+            accept_prefix: Some(5),\n+            max_writes: Some(3),\n+            ..Default::default()\n+        };\n+\n+        let mut writer = LineWriter::new(writer);\n+        let res = writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\");\n+        assert!(res.is_err());\n+        // An error from write_all leaves everything in an indeterminate state,\n+        // so there's nothing else to test here\n+    }\n+\n+    /// Under certain circumstances, the old implementation of LineWriter\n+    /// would try to buffer \"to the last newline\" but be forced to buffer\n+    /// less than that, leading to inappropriate partial line writes.\n+    /// Regression test for that issue.\n+    #[test]\n+    fn partial_multiline_buffering() {\n+        let writer = ProgrammableSink {\n+            // Write only up to 5 bytes at a time\n+            accept_prefix: Some(5),\n+            ..Default::default()\n+        };\n+\n+        let mut writer = LineWriter::with_capacity(10, writer);\n+\n+        let content = b\"AAAAABBBBB\\nCCCCDDDDDD\\nEEE\";\n+\n+        // When content is written, LineWriter will try to write blocks A, B,\n+        // C, and D. Only block A will succeed. Under the old behavior, LineWriter\n+        // would then try to buffer B, C and D, but because its capacity is 10,\n+        // it will only be able to buffer B and C. We don't want to buffer\n+        // partial lines concurrent with whole lines, so the correct behavior\n+        // is to buffer only block B (out to the newline)\n+        assert_eq!(writer.write(content).unwrap(), 11);\n+        assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n+\n+        writer.flush().unwrap();\n+        assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\\n\");\n+    }\n+\n+    /// Same as test_partial_multiline_buffering, but in the event NO full lines\n+    /// fit in the buffer, just buffer as much as possible\n+    #[test]\n+    fn partial_multiline_buffering_without_full_line() {\n+        let writer = ProgrammableSink {\n+            // Write only up to 5 bytes at a time\n+            accept_prefix: Some(5),\n+            ..Default::default()\n+        };\n+\n+        let mut writer = LineWriter::with_capacity(5, writer);\n+\n+        let content = b\"AAAAABBBBBBBBBB\\nCCCCC\\nDDDDD\";\n+\n+        // When content is written, LineWriter will try to write blocks A, B,\n+        // and C. Only block A will succeed. Under the old behavior, LineWriter\n+        // would then try to buffer B and C, but because its capacity is 5,\n+        // it will only be able to buffer part of B. Because it's not possible\n+        // for it to buffer any complete lines, it should buffer as much of B as\n+        // possible\n+        assert_eq!(writer.write(content).unwrap(), 10);\n+        assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n+\n+        writer.flush().unwrap();\n+        assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\");\n+    }\n }"}]}