{"sha": "2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMWVmOWVmMTE4MTI5OGQ0NmU3OWQ1ZGRlNmJhZmViNjQ4MzkyNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-05T04:56:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-05T04:56:03Z"}, "message": "Auto merge of #44308 - eddyb:local-index, r=arielb1\n\n[MIR] Restrict ProjectionElem::Index and Storage{Live,Dead} to Local.\n\n(see #44285)\n\nr? @nikomatsakis", "tree": {"sha": "6272a0b66cddf2541dd368c6e8828b2a0ae9ed68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6272a0b66cddf2541dd368c6e8828b2a0ae9ed68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "html_url": "https://github.com/rust-lang/rust/commit/2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f681bf6024b551c2bea777ae6df3e6fafaa985f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f681bf6024b551c2bea777ae6df3e6fafaa985f", "html_url": "https://github.com/rust-lang/rust/commit/2f681bf6024b551c2bea777ae6df3e6fafaa985f"}, {"sha": "e74f96e43fc1611a3abb09457e8ed852af3c167e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e74f96e43fc1611a3abb09457e8ed852af3c167e", "html_url": "https://github.com/rust-lang/rust/commit/e74f96e43fc1611a3abb09457e8ed852af3c167e"}], "stats": {"total": 681, "additions": 319, "deletions": 362}, "files": [{"sha": "cf3d7c3642a5feadafca0ed5ccda504c759158a3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -901,10 +901,10 @@ pub enum StatementKind<'tcx> {\n     SetDiscriminant { lvalue: Lvalue<'tcx>, variant_index: usize },\n \n     /// Start a live range for the storage of the local.\n-    StorageLive(Lvalue<'tcx>),\n+    StorageLive(Local),\n \n     /// End the current live range for the storage of the local.\n-    StorageDead(Lvalue<'tcx>),\n+    StorageDead(Local),\n \n     /// Execute a piece of inline Assembly.\n     InlineAsm {\n@@ -1077,12 +1077,12 @@ pub enum ProjectionElem<'tcx, V, T> {\n }\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n-/// and the index is an operand.\n-pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Operand<'tcx>, Ty<'tcx>>;\n+/// and the index is a local.\n+pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Local, Ty<'tcx>>;\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n-/// and the index is an operand.\n-pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Operand<'tcx>, Ty<'tcx>>;\n+/// and the index is a local.\n+pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n newtype_index!(Field, \"field\");\n \n@@ -1099,7 +1099,7 @@ impl<'tcx> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n     }\n \n-    pub fn index(self, index: Operand<'tcx>) -> Lvalue<'tcx> {\n+    pub fn index(self, index: Local) -> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Index(index))\n     }\n \n@@ -1701,8 +1701,8 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n                 lvalue: lvalue.fold_with(folder),\n                 variant_index,\n             },\n-            StorageLive(ref lval) => StorageLive(lval.fold_with(folder)),\n-            StorageDead(ref lval) => StorageDead(lval.fold_with(folder)),\n+            StorageLive(ref local) => StorageLive(local.fold_with(folder)),\n+            StorageDead(ref local) => StorageDead(local.fold_with(folder)),\n             InlineAsm { ref asm, ref outputs, ref inputs } => InlineAsm {\n                 asm: asm.clone(),\n                 outputs: outputs.fold_with(folder),\n@@ -1732,9 +1732,9 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n \n         match self.kind {\n             Assign(ref lval, ref rval) => { lval.visit_with(visitor) || rval.visit_with(visitor) }\n-            SetDiscriminant { ref lvalue, .. } |\n-            StorageLive(ref lvalue) |\n-            StorageDead(ref lvalue) => lvalue.visit_with(visitor),\n+            SetDiscriminant { ref lvalue, .. } => lvalue.visit_with(visitor),\n+            StorageLive(ref local) |\n+            StorageDead(ref local) => local.visit_with(visitor),\n             InlineAsm { ref outputs, ref inputs, .. } =>\n                 outputs.visit_with(visitor) || inputs.visit_with(visitor),\n "}, {"sha": "f26505c6d0237e9d119cf8e43494e0b095e184b2", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -256,7 +256,9 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_local(&mut self,\n-                                _local: & $($mutability)* Local) {\n+                            _local: & $($mutability)* Local,\n+                            _context: LvalueContext<'tcx>,\n+                            _location: Location) {\n             }\n \n             fn visit_visibility_scope(&mut self,\n@@ -358,11 +360,11 @@ macro_rules! make_mir_visitor {\n                     StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {\n                         self.visit_lvalue(lvalue, LvalueContext::Store, location);\n                     }\n-                    StatementKind::StorageLive(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::StorageLive, location);\n+                    StatementKind::StorageLive(ref $($mutability)* local) => {\n+                        self.visit_local(local, LvalueContext::StorageLive, location);\n                     }\n-                    StatementKind::StorageDead(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::StorageDead, location);\n+                    StatementKind::StorageDead(ref $($mutability)* local) => {\n+                        self.visit_local(local, LvalueContext::StorageDead, location);\n                     }\n                     StatementKind::InlineAsm { ref $($mutability)* outputs,\n                                                ref $($mutability)* inputs,\n@@ -610,7 +612,7 @@ macro_rules! make_mir_visitor {\n                             location: Location) {\n                 match *lvalue {\n                     Lvalue::Local(ref $($mutability)* local) => {\n-                        self.visit_local(local);\n+                        self.visit_local(local, context, location);\n                     }\n                     Lvalue::Static(ref $($mutability)* static_) => {\n                         self.visit_static(static_, context, location);\n@@ -662,8 +664,8 @@ macro_rules! make_mir_visitor {\n                     ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n                         self.visit_ty(ty, Lookup::Loc(location));\n                     }\n-                    ProjectionElem::Index(ref $($mutability)* operand) => {\n-                        self.visit_operand(operand, location);\n+                    ProjectionElem::Index(ref $($mutability)* local) => {\n+                        self.visit_local(local, LvalueContext::Consume, location);\n                     }\n                     ProjectionElem::ConstantIndex { offset: _,\n                                                     min_length: _,"}, {"sha": "44b505e19658f5cf45ecec30a8e51af71cc3707d", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -421,7 +421,7 @@ macro_rules! CopyImpls {\n     }\n }\n \n-CopyImpls! { (), hir::Unsafety, abi::Abi, hir::def_id::DefId }\n+CopyImpls! { (), hir::Unsafety, abi::Abi, hir::def_id::DefId, ::mir::Local }\n \n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {"}, {"sha": "063cbc775591540004de493501a424877bfb7161", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -212,11 +212,11 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                 // ignored by borrowck\n             }\n \n-            StatementKind::StorageDead(ref lvalue) => {\n+            StatementKind::StorageDead(local) => {\n                 // causes non-drop values to be dropped.\n                 self.consume_lvalue(ContextKind::StorageDead.new(location),\n                                     ConsumeKind::Consume,\n-                                    (lvalue, span),\n+                                    (&Lvalue::Local(local), span),\n                                     flow_state)\n             }\n         }\n@@ -710,7 +710,7 @@ mod restrictions {\n \n     use rustc::hir;\n     use rustc::ty::{self, TyCtxt};\n-    use rustc::mir::{Lvalue, Mir, Operand, ProjectionElem};\n+    use rustc::mir::{Lvalue, Mir, ProjectionElem};\n \n     pub(super) struct Restrictions<'c, 'tcx: 'c> {\n         mir: &'c Mir<'tcx>,\n@@ -809,12 +809,7 @@ mod restrictions {\n                         ProjectionElem::Downcast(..) |\n                         ProjectionElem::Subslice { .. } |\n                         ProjectionElem::ConstantIndex { .. } |\n-                        ProjectionElem::Index(Operand::Constant(..)) => {\n-                            cursor = &proj.base;\n-                            continue 'cursor;\n-                        }\n-                        ProjectionElem::Index(Operand::Consume(ref index)) => {\n-                            self.lvalue_stack.push(index); // FIXME: did old borrowck do this?\n+                        ProjectionElem::Index(_) => {\n                             cursor = &proj.base;\n                             continue 'cursor;\n                         }\n@@ -1004,7 +999,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                         (\"\",   format!(\"\"), None), // (dont emit downcast info)\n                     ProjectionElem::Field(field, _ty) =>\n                         (\"\",   format!(\".{}\", field.index()), None),\n-                    ProjectionElem::Index(ref index) =>\n+                    ProjectionElem::Index(index) =>\n                         (\"\",   format!(\"\"), Some(index)),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n                         (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n@@ -1021,23 +1016,11 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                 self.append_lvalue_to_string(&proj.base, buf);\n                 if let Some(index) = index_operand {\n                     buf.push_str(\"[\");\n-                    self.append_operand_to_string(index, buf);\n+                    self.append_lvalue_to_string(&Lvalue::Local(index), buf);\n                     buf.push_str(\"]\");\n                 } else {\n                     buf.push_str(&suffix);\n                 }\n-\n-            }\n-        }\n-    }\n-\n-    fn append_operand_to_string(&self, operand: &Operand, buf: &mut String) {\n-        match *operand {\n-            Operand::Consume(ref lvalue) => {\n-                self.append_lvalue_to_string(lvalue, buf);\n-            }\n-            Operand::Constant(ref constant) => {\n-                buf.push_str(&format!(\"{:?}\", constant));\n             }\n         }\n     }"}, {"sha": "9cbaff2c113b6fb6f9a51753f9d5a30f8635e375", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // region_scope=None so lvalue indexes live forever. They are scalars so they\n                 // do not need storage annotations, and they are often copied between\n                 // places.\n-                let idx = unpack!(block = this.as_operand(block, None, index));\n+                let idx = unpack!(block = this.as_temp(block, None, index));\n \n                 // bounds check:\n                 let (len, lt) = (this.temp(usize_ty.clone(), expr_span),\n@@ -70,12 +70,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      &len, Rvalue::Len(slice.clone()));\n                 this.cfg.push_assign(block, source_info, // lt = idx < len\n                                      &lt, Rvalue::BinaryOp(BinOp::Lt,\n-                                                           idx.clone(),\n+                                                           Operand::Consume(Lvalue::Local(idx)),\n                                                            Operand::Consume(len.clone())));\n \n                 let msg = AssertMessage::BoundsCheck {\n                     len: Operand::Consume(len),\n-                    index: idx.clone()\n+                    index: Operand::Consume(Lvalue::Local(idx))\n                 };\n                 let success = this.assert(block, Operand::Consume(lt), true,\n                                           msg, expr_span);\n@@ -127,7 +127,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some(Category::Lvalue) => false,\n                     _ => true,\n                 });\n-                this.as_temp(block, expr.temp_lifetime, expr)\n+                let temp = unpack!(block = this.as_temp(block, expr.temp_lifetime, expr));\n+                block.and(Lvalue::Local(temp))\n             }\n         }\n     }"}, {"sha": "0a72ce8d05e146055b58f9ed212217cf786abfa9", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Category::Rvalue(..) => {\n                 let operand =\n                     unpack!(block = this.as_temp(block, scope, expr));\n-                block.and(Operand::Consume(operand))\n+                block.and(Operand::Consume(Lvalue::Local(operand)))\n             }\n         }\n     }"}, {"sha": "c83283ee38e1fcd12b25ac130167883eb9addf88", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -96,23 +96,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Box { value } => {\n                 let value = this.hir.mirror(value);\n-                let result = this.temp(expr.ty, expr_span);\n+                let result = this.local_decls.push(LocalDecl::new_temp(expr.ty, expr_span));\n                 this.cfg.push(block, Statement {\n                     source_info,\n-                    kind: StatementKind::StorageLive(result.clone())\n+                    kind: StatementKind::StorageLive(result)\n                 });\n                 if let Some(scope) = scope {\n                     // schedule a shallow free of that memory, lest we unwind:\n-                    this.schedule_drop(expr_span, scope, &result, value.ty);\n+                    this.schedule_drop(expr_span, scope, &Lvalue::Local(result), value.ty);\n                 }\n \n                 // malloc some memory of suitable type (thus far, uninitialized):\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n-                this.cfg.push_assign(block, source_info, &result, box_);\n+                this.cfg.push_assign(block, source_info, &Lvalue::Local(result), box_);\n \n                 // initialize the box contents:\n-                unpack!(block = this.into(&result.clone().deref(), block, value));\n-                block.and(Rvalue::Use(Operand::Consume(result)))\n+                unpack!(block = this.into(&Lvalue::Local(result).deref(), block, value));\n+                block.and(Rvalue::Use(Operand::Consume(Lvalue::Local(result))))\n             }\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);"}, {"sha": "7826769600bfa4294aa999efc401960ff1ba8f00", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       block: BasicBlock,\n                       temp_lifetime: Option<region::Scope>,\n                       expr: M)\n-                      -> BlockAnd<Lvalue<'tcx>>\n+                      -> BlockAnd<Local>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n@@ -34,7 +34,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     mut block: BasicBlock,\n                     temp_lifetime: Option<region::Scope>,\n                     expr: Expr<'tcx>)\n-                    -> BlockAnd<Lvalue<'tcx>> {\n+                    -> BlockAnd<Local> {\n         debug!(\"expr_as_temp(block={:?}, temp_lifetime={:?}, expr={:?})\",\n                block, temp_lifetime, expr);\n         let this = self;\n@@ -47,13 +47,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             });\n         }\n \n-        let expr_ty = expr.ty.clone();\n-        let temp = this.temp(expr_ty.clone(), expr_span);\n+        let expr_ty = expr.ty;\n+        let temp = this.local_decls.push(LocalDecl::new_temp(expr_ty, expr_span));\n \n         if !expr_ty.is_never() {\n             this.cfg.push(block, Statement {\n                 source_info,\n-                kind: StatementKind::StorageLive(temp.clone())\n+                kind: StatementKind::StorageLive(temp)\n             });\n         }\n \n@@ -68,18 +68,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Category::Lvalue => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, expr));\n                 let rvalue = Rvalue::Use(Operand::Consume(lvalue));\n-                this.cfg.push_assign(block, source_info, &temp, rvalue);\n+                this.cfg.push_assign(block, source_info, &Lvalue::Local(temp), rvalue);\n             }\n             _ => {\n-                unpack!(block = this.into(&temp, block, expr));\n+                unpack!(block = this.into(&Lvalue::Local(temp), block, expr));\n             }\n         }\n \n         // In constants, temp_lifetime is None. We should not need to drop\n         // anything because no values with a destructor can be created in\n         // a constant at this time, even if the type may need dropping.\n         if let Some(temp_lifetime) = temp_lifetime {\n-            this.schedule_drop(expr_span, temp_lifetime, &temp, expr_ty);\n+            this.schedule_drop(expr_span, temp_lifetime, &Lvalue::Local(temp), expr_ty);\n         }\n \n         block.and(temp)"}, {"sha": "80a126dc42569c2d0563116237137fe2ddfcda59", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     let topmost_scope = this.topmost_scope();\n                     let ptr = unpack!(block = this.as_temp(block, Some(topmost_scope), ptr));\n-                    this.into(&ptr.deref(), block, val)\n+                    this.into(&Lvalue::Local(ptr).deref(), block, val)\n                 } else {\n                     let args: Vec<_> =\n                         args.into_iter()"}, {"sha": "ec2e487b4e74cf22c7048e82f3792c3a66f4a947", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement {\n             source_info,\n-            kind: StatementKind::StorageLive(Lvalue::Local(local_id))\n+            kind: StatementKind::StorageLive(local_id)\n         });\n         Lvalue::Local(local_id)\n     }"}, {"sha": "ed598c876f3e90628726d1c2ef73cd3455658935", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -822,7 +822,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n             Lvalue::Local(index) if index.index() > arg_count => {\n                 cfg.push(block, Statement {\n                     source_info,\n-                    kind: StatementKind::StorageDead(drop_data.location.clone())\n+                    kind: StatementKind::StorageDead(index)\n                 });\n             }\n             _ => continue"}, {"sha": "00825c7a880e9568d429e8add3bbf2ac30072a27", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -21,8 +21,7 @@\n //! `a[x]` would still overlap them both. But that is not this\n //! representation does today.)\n \n-use rustc::mir::LvalueElem;\n-use rustc::mir::{Operand, ProjectionElem};\n+use rustc::mir::{Local, LvalueElem, Operand, ProjectionElem};\n use rustc::ty::Ty;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -40,6 +39,10 @@ impl<'tcx> Lift for Operand<'tcx> {\n     type Abstract = AbstractOperand;\n     fn lift(&self) -> Self::Abstract { AbstractOperand }\n }\n+impl Lift for Local {\n+    type Abstract = AbstractOperand;\n+    fn lift(&self) -> Self::Abstract { AbstractOperand }\n+}\n impl<'tcx> Lift for Ty<'tcx> {\n     type Abstract = AbstractType;\n     fn lift(&self) -> Self::Abstract { AbstractType }"}, {"sha": "d3c886dab4e86348509aacdc6031d01a2cf7fff6", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -479,9 +479,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n \n     fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: usize) {\n         let tcx = self.tcx;\n+        let span = self.span;\n         let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n \n-        let beg = self.make_lvalue(Mutability::Mut, tcx.types.usize);\n+        let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let end = self.make_lvalue(Mutability::Not, tcx.types.usize);\n         let ret = self.make_lvalue(Mutability::Mut, tcx.mk_array(ty, len));\n \n@@ -492,7 +493,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let inits = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n-                    beg.clone(),\n+                    Lvalue::Local(beg),\n                     Rvalue::Use(Operand::Constant(self.make_usize(0)))\n                 )\n             ),\n@@ -510,19 +511,19 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         //     BB #3;\n         // }\n         // BB #4;\n-        self.loop_header(beg.clone(), end, BasicBlock::new(2), BasicBlock::new(4), false);\n+        self.loop_header(Lvalue::Local(beg), end, BasicBlock::new(2), BasicBlock::new(4), false);\n \n         // BB #2\n         // `let cloned = Clone::clone(rcvr[beg])`;\n         // Goto #3 if ok, #5 if unwinding happens.\n-        let rcvr_field = rcvr.clone().index(Operand::Consume(beg.clone()));\n+        let rcvr_field = rcvr.clone().index(beg);\n         let cloned = self.make_clone_call(ty, rcvr_field, BasicBlock::new(3), BasicBlock::new(5));\n \n         // BB #3\n         // `ret[beg] = cloned;`\n         // `beg = beg + 1;`\n         // `goto #1`;\n-        let ret_field = ret.clone().index(Operand::Consume(beg.clone()));\n+        let ret_field = ret.clone().index(beg);\n         let statements = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n@@ -532,10 +533,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ),\n             self.make_statement(\n                 StatementKind::Assign(\n-                    beg.clone(),\n+                    Lvalue::Local(beg),\n                     Rvalue::BinaryOp(\n                         BinOp::Add,\n-                        Operand::Consume(beg.clone()),\n+                        Operand::Consume(Lvalue::Local(beg)),\n                         Operand::Constant(self.make_usize(1))\n                     )\n                 )\n@@ -558,10 +559,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `let mut beg = 0;`\n         // goto #6;\n         let end = beg;\n-        let beg = self.make_lvalue(Mutability::Mut, tcx.types.usize);\n+        let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let init = self.make_statement(\n             StatementKind::Assign(\n-                beg.clone(),\n+                Lvalue::Local(beg),\n                 Rvalue::Use(Operand::Constant(self.make_usize(0)))\n             )\n         );\n@@ -572,12 +573,13 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         //     BB #8;\n         // }\n         // BB #9;\n-        self.loop_header(beg.clone(), end, BasicBlock::new(7), BasicBlock::new(9), true);\n+        self.loop_header(Lvalue::Local(beg), Lvalue::Local(end),\n+                         BasicBlock::new(7), BasicBlock::new(9), true);\n \n         // BB #7 (cleanup)\n         // `drop(ret[beg])`;\n         self.block(vec![], TerminatorKind::Drop {\n-            location: ret.index(Operand::Consume(beg.clone())),\n+            location: ret.index(beg),\n             target: BasicBlock::new(8),\n             unwind: None,\n         }, true);\n@@ -587,10 +589,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `goto #6;`\n         let statement = self.make_statement(\n             StatementKind::Assign(\n-                beg.clone(),\n+                Lvalue::Local(beg),\n                 Rvalue::BinaryOp(\n                     BinOp::Add,\n-                    Operand::Consume(beg.clone()),\n+                    Operand::Consume(Lvalue::Local(beg)),\n                     Operand::Constant(self.make_usize(1))\n                 )\n             )"}, {"sha": "ac8ebd306d321e844b2beda2cca17d3a7517ac33", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -236,8 +236,7 @@ impl<'tcx> Action<'tcx> {\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n-                let src_lvalue = Lvalue::Local(src_local);\n-                def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_lvalue);\n+                def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_local);\n \n                 // Finally, zap the now-useless assignment instruction.\n                 debug!(\"  Deleting assignment\");"}, {"sha": "d1e0465f5551c098c37ed3b19b6cb532f97350a9", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -88,7 +88,9 @@ struct RenameLocalVisitor {\n \n impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n     fn visit_local(&mut self,\n-                        local: &mut Local) {\n+                   local: &mut Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n         if *local == self.from {\n             *local = self.to;\n         }\n@@ -98,6 +100,13 @@ impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n struct DerefArgVisitor;\n \n impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n+    fn visit_local(&mut self,\n+                   local: &mut Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n+        assert_ne!(*local, self_arg());\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &mut Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n@@ -177,6 +186,13 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n+    fn visit_local(&mut self,\n+                   local: &mut Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n+        assert_eq!(self.remap.get(local), None);\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &mut Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n@@ -197,12 +213,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n         // Remove StorageLive and StorageDead statements for remapped locals\n         data.retain_statements(|s| {\n             match s.kind {\n-                StatementKind::StorageLive(ref l) | StatementKind::StorageDead(ref l) => {\n-                    if let Lvalue::Local(l) = *l {\n-                        !self.remap.contains_key(&l)\n-                    } else {\n-                        true\n-                    }\n+                StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n+                    !self.remap.contains_key(&l)\n                 }\n                 _ => true\n             }"}, {"sha": "3f8070fb3aa31929cb7b577060f64c9095978947", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -589,16 +589,6 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n         new\n     }\n \n-    fn update_local(&self, local: Local) -> Option<Local> {\n-        let idx = local.index();\n-        if idx < (self.args.len() + 1) {\n-            return None;\n-        }\n-        let idx = idx - (self.args.len() + 1);\n-        let local = Local::new(idx);\n-        self.local_map.get(local).cloned()\n-    }\n-\n     fn arg_index(&self, arg: Local) -> Option<usize> {\n         let idx = arg.index();\n         if idx > 0 && idx <= self.args.len() {\n@@ -610,32 +600,35 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n+    fn visit_local(&mut self,\n+                   local: &mut Local,\n+                   _ctxt: LvalueContext<'tcx>,\n+                   _location: Location) {\n+        if *local == RETURN_POINTER {\n+            match self.destination {\n+                Lvalue::Local(l) => *local = l,\n+                ref lval => bug!(\"Return lvalue is {:?}, not local\", lval)\n+            }\n+        }\n+        let idx = local.index() - 1;\n+        if idx < self.args.len() {\n+            match self.args[idx] {\n+                Operand::Consume(Lvalue::Local(l)) => *local = l,\n+                ref op => bug!(\"Arg operand `{:?}` is {:?}, not local\", idx, op)\n+            }\n+        }\n+        *local = self.local_map[Local::new(idx - self.args.len())];\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &mut Lvalue<'tcx>,\n                     _ctxt: LvalueContext<'tcx>,\n                     _location: Location) {\n-        if let Lvalue::Local(ref mut local) = *lvalue {\n-            if let Some(l) = self.update_local(*local) {\n-                // Temp or Var; update the local reference\n-                *local = l;\n-                return;\n-            }\n-        }\n-        if let Lvalue::Local(local) = *lvalue {\n-            if local == RETURN_POINTER {\n-                // Return pointer; update the lvalue itself\n-                *lvalue = self.destination.clone();\n-            } else if local.index() < (self.args.len() + 1) {\n-                // Argument, once again update the the lvalue itself\n-                let idx = local.index() - 1;\n-                if let Operand::Consume(ref lval) = self.args[idx] {\n-                    *lvalue = lval.clone();\n-                } else {\n-                    bug!(\"Arg operand `{:?}` is not an Lvalue use.\", idx)\n-                }\n-            }\n+        if let Lvalue::Local(RETURN_POINTER) = *lvalue {\n+            // Return pointer; update the lvalue itself\n+            *lvalue = self.destination.clone();\n         } else {\n-            self.super_lvalue(lvalue, _ctxt, _location)\n+            self.super_lvalue(lvalue, _ctxt, _location);\n         }\n     }\n "}, {"sha": "ca6eda5c2d716498d0e62b9cd0bc52ad1b32ebe0", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -83,52 +83,49 @@ struct TempCollector<'tcx> {\n }\n \n impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n-                    location: Location) {\n-        self.super_lvalue(lvalue, context, location);\n-        if let Lvalue::Local(index) = *lvalue {\n-            // We're only interested in temporaries\n-            if self.mir.local_kind(index) != LocalKind::Temp {\n-                return;\n-            }\n+    fn visit_local(&mut self,\n+                   &index: &Local,\n+                   context: LvalueContext<'tcx>,\n+                   location: Location) {\n+        // We're only interested in temporaries\n+        if self.mir.local_kind(index) != LocalKind::Temp {\n+            return;\n+        }\n \n-            // Ignore drops, if the temp gets promoted,\n-            // then it's constant and thus drop is noop.\n-            // Storage live ranges are also irrelevant.\n-            if context.is_drop() || context.is_storage_marker() {\n-                return;\n-            }\n+        // Ignore drops, if the temp gets promoted,\n+        // then it's constant and thus drop is noop.\n+        // Storage live ranges are also irrelevant.\n+        if context.is_drop() || context.is_storage_marker() {\n+            return;\n+        }\n \n-            let temp = &mut self.temps[index];\n-            if *temp == TempState::Undefined {\n-                match context {\n-                    LvalueContext::Store |\n-                    LvalueContext::Call => {\n-                        *temp = TempState::Defined {\n-                            location,\n-                            uses: 0\n-                        };\n-                        return;\n-                    }\n-                    _ => { /* mark as unpromotable below */ }\n-                }\n-            } else if let TempState::Defined { ref mut uses, .. } = *temp {\n-                // We always allow borrows, even mutable ones, as we need\n-                // to promote mutable borrows of some ZSTs e.g. `&mut []`.\n-                let allowed_use = match context {\n-                    LvalueContext::Borrow {..} => true,\n-                    _ => context.is_nonmutating_use()\n-                };\n-                if allowed_use {\n-                    *uses += 1;\n+        let temp = &mut self.temps[index];\n+        if *temp == TempState::Undefined {\n+            match context {\n+                LvalueContext::Store |\n+                LvalueContext::Call => {\n+                    *temp = TempState::Defined {\n+                        location,\n+                        uses: 0\n+                    };\n                     return;\n                 }\n-                /* mark as unpromotable below */\n+                _ => { /* mark as unpromotable below */ }\n             }\n-            *temp = TempState::Unpromotable;\n+        } else if let TempState::Defined { ref mut uses, .. } = *temp {\n+            // We always allow borrows, even mutable ones, as we need\n+            // to promote mutable borrows of some ZSTs e.g. `&mut []`.\n+            let allowed_use = match context {\n+                LvalueContext::Borrow {..} => true,\n+                _ => context.is_nonmutating_use()\n+            };\n+            if allowed_use {\n+                *uses += 1;\n+                return;\n+            }\n+            /* mark as unpromotable below */\n         }\n+        *temp = TempState::Unpromotable;\n     }\n \n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n@@ -326,16 +323,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n /// Replaces all temporaries with their promoted counterparts.\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n-                    location: Location) {\n-        if let Lvalue::Local(ref mut temp) = *lvalue {\n-            if self.source.local_kind(*temp) == LocalKind::Temp {\n-                *temp = self.promote_temp(*temp);\n-            }\n+    fn visit_local(&mut self,\n+                   local: &mut Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n+        if self.source.local_kind(*local) == LocalKind::Temp {\n+            *local = self.promote_temp(*local);\n         }\n-        self.super_lvalue(lvalue, context, location);\n     }\n }\n \n@@ -412,8 +406,8 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         block.statements.retain(|statement| {\n             match statement.kind {\n                 StatementKind::Assign(Lvalue::Local(index), _) |\n-                StatementKind::StorageLive(Lvalue::Local(index)) |\n-                StatementKind::StorageDead(Lvalue::Local(index)) => {\n+                StatementKind::StorageLive(index) |\n+                StatementKind::StorageDead(index) => {\n                     !promoted(index)\n                 }\n                 _ => true"}, {"sha": "415421757c5c5087c0ca7d540fa8613bf2e09cf7", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -499,33 +499,40 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n /// For functions (constant or not), it also records\n /// candidates for promotion in promotion_candidates.\n impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n+    fn visit_local(&mut self,\n+                   &local: &Local,\n+                   _: LvalueContext<'tcx>,\n+                   _: Location) {\n+        match self.mir.local_kind(local) {\n+            LocalKind::ReturnPointer => {\n+                self.not_const();\n+            }\n+            LocalKind::Arg => {\n+                self.add(Qualif::FN_ARGUMENT);\n+            }\n+            LocalKind::Var => {\n+                self.add(Qualif::NOT_CONST);\n+            }\n+            LocalKind::Temp => {\n+                if !self.temp_promotion_state[local].is_promotable() {\n+                    self.add(Qualif::NOT_PROMOTABLE);\n+                }\n+\n+                if let Some(qualif) = self.temp_qualif[local] {\n+                    self.add(qualif);\n+                } else {\n+                    self.not_const();\n+                }\n+            }\n+        }\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n         match *lvalue {\n-            Lvalue::Local(local) => match self.mir.local_kind(local) {\n-                LocalKind::ReturnPointer => {\n-                    self.not_const();\n-                }\n-                LocalKind::Arg => {\n-                    self.add(Qualif::FN_ARGUMENT);\n-                }\n-                LocalKind::Var => {\n-                    self.add(Qualif::NOT_CONST);\n-                }\n-                LocalKind::Temp => {\n-                    if !self.temp_promotion_state[local].is_promotable() {\n-                        self.add(Qualif::NOT_PROMOTABLE);\n-                    }\n-\n-                    if let Some(qualif) = self.temp_qualif[local] {\n-                        self.add(qualif);\n-                    } else {\n-                        self.not_const();\n-                    }\n-                }\n-            },\n+            Lvalue::Local(ref local) => self.visit_local(local, context, location),\n             Lvalue::Static(ref global) => {\n                 self.add(Qualif::STATIC);\n \n@@ -1101,7 +1108,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             for block in mir.basic_blocks_mut() {\n                 block.statements.retain(|statement| {\n                     match statement.kind {\n-                        StatementKind::StorageDead(Lvalue::Local(index)) => {\n+                        StatementKind::StorageDead(index) => {\n                             !promoted_temps.contains(&index)\n                         }\n                         _ => true"}, {"sha": "89828cf375aa7554e8053ea00c505d5a8251e5ff", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -352,15 +352,11 @@ struct DeclMarker {\n }\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {\n-    fn visit_lvalue(&mut self, lval: &Lvalue<'tcx>, ctx: LvalueContext<'tcx>, loc: Location) {\n-        if ctx == LvalueContext::StorageLive || ctx == LvalueContext::StorageDead {\n-            // ignore these altogether, they get removed along with their otherwise unused decls.\n-            return;\n+    fn visit_local(&mut self, local: &Local, ctx: LvalueContext<'tcx>, _: Location) {\n+        // ignore these altogether, they get removed along with their otherwise unused decls.\n+        if ctx != LvalueContext::StorageLive && ctx != LvalueContext::StorageDead {\n+            self.locals.insert(local.index());\n         }\n-        if let Lvalue::Local(ref v) = *lval {\n-            self.locals.insert(v.index());\n-        }\n-        self.super_lvalue(lval, ctx, loc);\n     }\n }\n \n@@ -373,22 +369,15 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n         data.statements.retain(|stmt| {\n             match stmt.kind {\n-                StatementKind::StorageLive(ref lval) | StatementKind::StorageDead(ref lval) => {\n-                    match *lval {\n-                        Lvalue::Local(l) => self.map[l.index()] != !0,\n-                        _ => true\n-                    }\n+                StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n+                    self.map[l.index()] != !0\n                 }\n                 _ => true\n             }\n         });\n         self.super_basic_block_data(block, data);\n     }\n-    fn visit_lvalue(&mut self, lval: &mut Lvalue<'tcx>, ctx: LvalueContext<'tcx>, loc: Location) {\n-        match *lval {\n-            Lvalue::Local(ref mut l) => *l = Local::new(self.map[l.index()]),\n-            _ => (),\n-        };\n-        self.super_lvalue(lval, ctx, loc);\n+    fn visit_local(&mut self, l: &mut Local, _: LvalueContext<'tcx>, _: Location) {\n+        *l = Local::new(self.map[l.index()]);\n     }\n }"}, {"sha": "d4da14ea96e72bf316351e21fa0ef629452e6472", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                            base: LvalueTy<'tcx>,\n                            pi: &LvalueElem<'tcx>,\n                            lvalue: &Lvalue<'tcx>,\n-                           location: Location)\n+                           _: Location)\n                            -> LvalueTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n         let tcx = self.tcx();\n@@ -181,9 +181,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n-            ProjectionElem::Index(ref i) => {\n-                self.visit_operand(i, location);\n-                let index_ty = i.ty(self.mir, tcx);\n+            ProjectionElem::Index(i) => {\n+                let index_ty = Lvalue::Local(i).ty(self.mir, tcx).to_ty(tcx);\n                 if index_ty != tcx.types.usize {\n                     LvalueTy::Ty {\n                         ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i)\n@@ -421,15 +420,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                variant_index);\n                 };\n             }\n-            StatementKind::StorageLive(ref lv) |\n-            StatementKind::StorageDead(ref lv) => {\n-                match *lv {\n-                    Lvalue::Local(_) => {}\n-                    _ => {\n-                        span_mirbug!(self, stmt, \"bad lvalue: expected local\");\n-                    }\n-                }\n-            }\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) |\n             StatementKind::InlineAsm { .. } |\n             StatementKind::EndRegion(_) |\n             StatementKind::Validate(..) |"}, {"sha": "bd9fb4bc3cc5f6fd203c4372b3b5a31d1f170803", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -10,7 +10,7 @@\n \n //! Def-use analysis.\n \n-use rustc::mir::{Local, Location, Lvalue, Mir};\n+use rustc::mir::{Local, Location, Mir};\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::marker::PhantomData;\n@@ -51,7 +51,7 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n     }\n \n     fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Mir<'tcx>, mut callback: F)\n-                               where F: for<'a> FnMut(&'a mut Lvalue<'tcx>,\n+                               where F: for<'a> FnMut(&'a mut Local,\n                                                       LvalueContext<'tcx>,\n                                                       Location) {\n         for lvalue_use in &self.info[local].defs_and_uses {\n@@ -65,39 +65,24 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n                                           mir: &mut Mir<'tcx>,\n-                                          new_lvalue: Lvalue<'tcx>) {\n-        self.mutate_defs_and_uses(local, mir, |lvalue, _, _| *lvalue = new_lvalue.clone())\n+                                          new_local: Local) {\n+        self.mutate_defs_and_uses(local, mir, |local, _, _| *local = new_local)\n     }\n }\n \n struct DefUseFinder<'tcx> {\n     info: IndexVec<Local, Info<'tcx>>,\n }\n \n-impl<'tcx> DefUseFinder<'tcx> {\n-    fn lvalue_mut_info(&mut self, lvalue: &Lvalue<'tcx>) -> Option<&mut Info<'tcx>> {\n-        let info = &mut self.info;\n-\n-        if let Lvalue::Local(local) = *lvalue {\n-            Some(&mut info[local])\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for DefUseFinder<'tcx> {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n-                    location: Location) {\n-        if let Some(ref mut info) = self.lvalue_mut_info(lvalue) {\n-            info.defs_and_uses.push(Use {\n-                context,\n-                location,\n-            })\n-        }\n-        self.super_lvalue(lvalue, context, location)\n+    fn visit_local(&mut self,\n+                   &local: &Local,\n+                   context: LvalueContext<'tcx>,\n+                   location: Location) {\n+        self.info[local].defs_and_uses.push(Use {\n+            context,\n+            location,\n+        });\n     }\n }\n \n@@ -134,7 +119,7 @@ struct MutateUseVisitor<'tcx, F> {\n impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n     fn new(query: Local, callback: F, _: &Mir<'tcx>)\n            -> MutateUseVisitor<'tcx, F>\n-           where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n+           where F: for<'a> FnMut(&'a mut Local, LvalueContext<'tcx>, Location) {\n         MutateUseVisitor {\n             query,\n             callback,\n@@ -144,16 +129,13 @@ impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n }\n \n impl<'tcx, F> MutVisitor<'tcx> for MutateUseVisitor<'tcx, F>\n-              where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n+              where F: for<'a> FnMut(&'a mut Local, LvalueContext<'tcx>, Location) {\n+    fn visit_local(&mut self,\n+                    local: &mut Local,\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n-        if let Lvalue::Local(local) = *lvalue {\n-            if local == self.query {\n-                (self.callback)(lvalue, context, location)\n-            }\n+        if *local == self.query {\n+            (self.callback)(local, context, location)\n         }\n-        self.super_lvalue(lvalue, context, location)\n     }\n }"}, {"sha": "f3b121f2eed57856745f4520e79e35d478c8e357", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -565,7 +565,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///    drop(ptr)\n     fn drop_loop(&mut self,\n                  succ: BasicBlock,\n-                 cur: &Lvalue<'tcx>,\n+                 cur: Local,\n                  length_or_end: &Lvalue<'tcx>,\n                  ety: Ty<'tcx>,\n                  unwind: Unwind,\n@@ -584,20 +584,20 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let one = self.constant_usize(1);\n         let (ptr_next, cur_next) = if ptr_based {\n-            (Rvalue::Use(use_(cur)),\n-             Rvalue::BinaryOp(BinOp::Offset, use_(cur), one))\n+            (Rvalue::Use(use_(&Lvalue::Local(cur))),\n+             Rvalue::BinaryOp(BinOp::Offset, use_(&Lvalue::Local(cur)), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.types.re_erased,\n                  BorrowKind::Mut,\n-                 self.lvalue.clone().index(use_(cur))),\n-             Rvalue::BinaryOp(BinOp::Add, use_(cur), one))\n+                 self.lvalue.clone().index(cur)),\n+             Rvalue::BinaryOp(BinOp::Add, use_(&Lvalue::Local(cur)), one))\n         };\n \n         let drop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(ptr, ptr_next),\n-                self.assign(cur, cur_next)\n+                self.assign(&Lvalue::Local(cur), cur_next)\n             ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -611,7 +611,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let loop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(can_go, Rvalue::BinaryOp(BinOp::Eq,\n-                                                     use_(cur),\n+                                                     use_(&Lvalue::Local(cur)),\n                                                      use_(length_or_end)))\n             ],\n             is_cleanup: unwind.is_cleanup(),\n@@ -678,7 +678,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             tcx.types.usize\n         };\n \n-        let cur = Lvalue::Local(self.new_temp(iter_ty));\n+        let cur = self.new_temp(iter_ty);\n         let length = Lvalue::Local(self.new_temp(tcx.types.usize));\n         let length_or_end = if ptr_based {\n             Lvalue::Local(self.new_temp(iter_ty))\n@@ -688,7 +688,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let unwind = self.unwind.map(|unwind| {\n             self.drop_loop(unwind,\n-                           &cur,\n+                           cur,\n                            &length_or_end,\n                            ety,\n                            Unwind::InCleanup,\n@@ -698,12 +698,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let succ = self.succ; // FIXME(#6393)\n         let loop_block = self.drop_loop(\n             succ,\n-            &cur,\n+            cur,\n             &length_or_end,\n             ety,\n             unwind,\n             ptr_based);\n \n+        let cur = Lvalue::Local(cur);\n         let zero = self.constant_usize(0);\n         let mut drop_block_stmts = vec![];\n         drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.lvalue.clone())));"}, {"sha": "e6d3a82ff9b5306509fb8fa6593b38531104ec5d", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -60,49 +60,45 @@ struct BlockInfoVisitor {\n }\n \n impl<'tcx> Visitor<'tcx> for BlockInfoVisitor {\n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    context: LvalueContext<'tcx>,\n-                    location: Location) {\n-        if let Lvalue::Local(local) = *lvalue {\n-            match context {\n-                LvalueContext::Store |\n-\n-                // We let Call defined the result in both the success and unwind cases.\n-                // This may not be right.\n-                LvalueContext::Call |\n-\n-                // Storage live and storage dead aren't proper defines, but we can ignore\n-                // values that come before them.\n-                LvalueContext::StorageLive |\n-                LvalueContext::StorageDead => {\n-                    self.defs.add(&local);\n-                }\n-                LvalueContext::Projection(..) |\n-\n-                // Borrows only consider their local used at the point of the borrow.\n-                // This won't affect the results since we use this analysis for generators\n-                // and we only care about the result at suspension points. Borrows cannot\n-                // cross suspension points so this behavior is unproblematic.\n-                LvalueContext::Borrow { .. } |\n-\n-                LvalueContext::Inspect |\n-                LvalueContext::Consume |\n-                LvalueContext::Validate |\n-\n-                // We consider drops to always be uses of locals.\n-                // Drop eloboration should be run before this analysis otherwise\n-                // the results might be too pessimistic.\n-                LvalueContext::Drop => {\n-                    // Ignore uses which are already defined in this block\n-                    if !self.pre_defs.contains(&local) {\n-                        self.uses.add(&local);\n-                    }\n+    fn visit_local(&mut self,\n+                   &local: &Local,\n+                   context: LvalueContext<'tcx>,\n+                   _: Location) {\n+        match context {\n+            LvalueContext::Store |\n+\n+            // We let Call defined the result in both the success and unwind cases.\n+            // This may not be right.\n+            LvalueContext::Call |\n+\n+            // Storage live and storage dead aren't proper defines, but we can ignore\n+            // values that come before them.\n+            LvalueContext::StorageLive |\n+            LvalueContext::StorageDead => {\n+                self.defs.add(&local);\n+            }\n+            LvalueContext::Projection(..) |\n+\n+            // Borrows only consider their local used at the point of the borrow.\n+            // This won't affect the results since we use this analysis for generators\n+            // and we only care about the result at suspension points. Borrows cannot\n+            // cross suspension points so this behavior is unproblematic.\n+            LvalueContext::Borrow { .. } |\n+\n+            LvalueContext::Inspect |\n+            LvalueContext::Consume |\n+            LvalueContext::Validate |\n+\n+            // We consider drops to always be uses of locals.\n+            // Drop eloboration should be run before this analysis otherwise\n+            // the results might be too pessimistic.\n+            LvalueContext::Drop => {\n+                // Ignore uses which are already defined in this block\n+                if !self.pre_defs.contains(&local) {\n+                    self.uses.add(&local);\n                 }\n             }\n         }\n-\n-        self.super_lvalue(lvalue, context, location)\n     }\n }\n "}, {"sha": "95b76d32bf8484d450b040c15421cd6fb45f1200", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -134,60 +134,61 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     location: Location) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n \n-        // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::Lvalue::Local(_) = proj.base {\n-                let ty = proj.base.ty(self.cx.mir, self.cx.ccx.tcx());\n-\n-                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n-                if common::type_is_imm_pair(self.cx.ccx, ty) {\n+            // Allow uses of projections of immediate pair fields.\n+            if let LvalueContext::Consume = context {\n+                if let mir::Lvalue::Local(_) = proj.base {\n                     if let mir::ProjectionElem::Field(..) = proj.elem {\n-                        if let LvalueContext::Consume = context {\n+                        let ty = proj.base.ty(self.cx.mir, self.cx.ccx.tcx());\n+\n+                        let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+                        if common::type_is_imm_pair(self.cx.ccx, ty) {\n                             return;\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        if let mir::Lvalue::Local(index) = *lvalue {\n-            match context {\n-                LvalueContext::Call => {\n-                    self.mark_assigned(index);\n-                }\n+            // A deref projection only reads the pointer, never needs the lvalue.\n+            if let mir::ProjectionElem::Deref = proj.elem {\n+                return self.visit_lvalue(&proj.base, LvalueContext::Consume, location);\n+            }\n+        }\n \n-                LvalueContext::StorageLive |\n-                LvalueContext::StorageDead |\n-                LvalueContext::Validate |\n-                LvalueContext::Inspect |\n-                LvalueContext::Consume => {}\n+        self.super_lvalue(lvalue, context, location);\n+    }\n \n-                LvalueContext::Store |\n-                LvalueContext::Borrow { .. } |\n-                LvalueContext::Projection(..) => {\n-                    self.mark_as_lvalue(index);\n-                }\n+    fn visit_local(&mut self,\n+                   &index: &mir::Local,\n+                   context: LvalueContext<'tcx>,\n+                   _: Location) {\n+        match context {\n+            LvalueContext::Call => {\n+                self.mark_assigned(index);\n+            }\n \n-                LvalueContext::Drop => {\n-                    let ty = lvalue.ty(self.cx.mir, self.cx.ccx.tcx());\n-                    let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+            LvalueContext::StorageLive |\n+            LvalueContext::StorageDead |\n+            LvalueContext::Validate |\n+            LvalueContext::Inspect |\n+            LvalueContext::Consume => {}\n \n-                    // Only need the lvalue if we're actually dropping it.\n-                    if self.cx.ccx.shared().type_needs_drop(ty) {\n-                        self.mark_as_lvalue(index);\n-                    }\n-                }\n+            LvalueContext::Store |\n+            LvalueContext::Borrow { .. } |\n+            LvalueContext::Projection(..) => {\n+                self.mark_as_lvalue(index);\n             }\n-        }\n \n-        // A deref projection only reads the pointer, never needs the lvalue.\n-        if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_lvalue(&proj.base, LvalueContext::Consume, location);\n+            LvalueContext::Drop => {\n+                let ty = mir::Lvalue::Local(index).ty(self.cx.mir, self.cx.ccx.tcx());\n+                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+\n+                // Only need the lvalue if we're actually dropping it.\n+                if self.cx.ccx.shared().type_needs_drop(ty) {\n+                    self.mark_as_lvalue(index);\n+                }\n             }\n         }\n-\n-        self.super_lvalue(lvalue, context, location);\n     }\n }\n "}, {"sha": "9987c9c33102d30c82c8214d6551523e6dfd2438", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -471,7 +471,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         };\n                         (Base::Value(llprojected), llextra)\n                     }\n-                    mir::ProjectionElem::Index(ref index) => {\n+                    mir::ProjectionElem::Index(index) => {\n+                        let index = &mir::Operand::Consume(mir::Lvalue::Local(index));\n                         let llindex = self.const_operand(index, span)?.llval;\n \n                         let iv = if let Some(iv) = common::const_to_opt_u128(llindex, false) {"}, {"sha": "8155303b0d3fc39ed8c085772e74d5068fff1610", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -333,7 +333,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         };\n                         (tr_base.trans_field_ptr(bcx, field.index()), llextra)\n                     }\n-                    mir::ProjectionElem::Index(ref index) => {\n+                    mir::ProjectionElem::Index(index) => {\n+                        let index = &mir::Operand::Consume(mir::Lvalue::Local(index));\n                         let index = self.trans_operand(bcx, index);\n                         let llindex = self.prepare_index(bcx, index.immediate());\n                         ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())"}, {"sha": "bbf661ae9a735d41c994cbe8ab018334f12386cb", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1ef9ef1181298d46e79d5dde6bafeb6483926f/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "patch": "@@ -67,11 +67,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     variant_index as u64);\n                 bcx\n             }\n-            mir::StatementKind::StorageLive(ref lvalue) => {\n-                self.trans_storage_liveness(bcx, lvalue, base::Lifetime::Start)\n+            mir::StatementKind::StorageLive(local) => {\n+                self.trans_storage_liveness(bcx, local, base::Lifetime::Start)\n             }\n-            mir::StatementKind::StorageDead(ref lvalue) => {\n-                self.trans_storage_liveness(bcx, lvalue, base::Lifetime::End)\n+            mir::StatementKind::StorageDead(local) => {\n+                self.trans_storage_liveness(bcx, local, base::Lifetime::End)\n             }\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n@@ -94,13 +94,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn trans_storage_liveness(&self,\n                               bcx: Builder<'a, 'tcx>,\n-                              lvalue: &mir::Lvalue<'tcx>,\n+                              index: mir::Local,\n                               intrinsic: base::Lifetime)\n                               -> Builder<'a, 'tcx> {\n-        if let mir::Lvalue::Local(index) = *lvalue {\n-            if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n-                intrinsic.call(&bcx, tr_lval.llval);\n-            }\n+        if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n+            intrinsic.call(&bcx, tr_lval.llval);\n         }\n         bcx\n     }"}]}