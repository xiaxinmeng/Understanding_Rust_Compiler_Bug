{"sha": "36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "node_id": "C_kwDOAAsO6NoAKDM2ODMxYjNjY2JjNDEwNGM2YjU1OWNiZDM0MWRiZDdlZTYyNTFlYzc", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-12-08T18:32:43Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2023-02-01T00:16:15Z"}, "message": "BTreeMap: Add Cursor and CursorMut", "tree": {"sha": "59d0dc8899b150cac7865133f17834e27f091499", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59d0dc8899b150cac7865133f17834e27f091499"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "html_url": "https://github.com/rust-lang/rust/commit/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb70c82d297c010123e88986f176eb827f8a3b7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb70c82d297c010123e88986f176eb827f8a3b7c", "html_url": "https://github.com/rust-lang/rust/commit/eb70c82d297c010123e88986f176eb827f8a3b7c"}], "stats": {"total": 844, "additions": 839, "deletions": 5}, "files": [{"sha": "386cd1a1657e26f0dd9934dee92af16020cfe9fa", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 728, "deletions": 2, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "patch": "@@ -6,7 +6,7 @@ use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop};\n-use core::ops::{Index, RangeBounds};\n+use core::ops::{Bound, Index, RangeBounds};\n use core::ptr;\n \n use crate::alloc::{Allocator, Global};\n@@ -15,7 +15,7 @@ use super::borrow::DormantMutRef;\n use super::dedup_sorted_iter::DedupSortedIter;\n use super::navigate::{LazyLeafRange, LeafRange};\n use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n-use super::search::SearchResult::*;\n+use super::search::{SearchBound, SearchResult::*};\n use super::set_val::SetValZST;\n \n mod entry;\n@@ -2422,6 +2422,732 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     pub const fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n+\n+    /// Returns a [`Cursor`] pointing at the first element that is above the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the first\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.lower_bound(Bound::Excluded(&2));\n+    /// assert_eq!(cursor.key(), Some(&3));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn lower_bound<Q>(&self, bound: Bound<&Q>) -> Cursor<'_, K, V>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let root_node = match self.root.as_ref() {\n+            None => return Cursor { current: None, root: None },\n+            Some(root) => root.reborrow(),\n+        };\n+        let edge = root_node.lower_bound(SearchBound::from_range(bound));\n+        Cursor { current: edge.next_kv().ok(), root: self.root.as_ref() }\n+    }\n+\n+    /// Returns a [`CursorMut`] pointing at the first element that is above the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the first\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.lower_bound_mut(Bound::Excluded(&2));\n+    /// assert_eq!(cursor.key(), Some(&3));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn lower_bound_mut<Q>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, K, V, A>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let (root, dormant_root) = DormantMutRef::new(&mut self.root);\n+        let root_node = match root.as_mut() {\n+            None => {\n+                return CursorMut {\n+                    current: None,\n+                    root: dormant_root,\n+                    length: &mut self.length,\n+                    alloc: &mut *self.alloc,\n+                };\n+            }\n+            Some(root) => root.borrow_mut(),\n+        };\n+        let edge = root_node.lower_bound(SearchBound::from_range(bound));\n+        CursorMut {\n+            current: edge.next_kv().ok(),\n+            root: dormant_root,\n+            length: &mut self.length,\n+            alloc: &mut *self.alloc,\n+        }\n+    }\n+\n+    /// Returns a [`Cursor`] pointing at the last element that is below the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the last\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.upper_bound(Bound::Excluded(&3));\n+    /// assert_eq!(cursor.key(), Some(&2));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn upper_bound<Q>(&self, bound: Bound<&Q>) -> Cursor<'_, K, V>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let root_node = match self.root.as_ref() {\n+            None => return Cursor { current: None, root: None },\n+            Some(root) => root.reborrow(),\n+        };\n+        let edge = root_node.upper_bound(SearchBound::from_range(bound));\n+        Cursor { current: edge.next_back_kv().ok(), root: self.root.as_ref() }\n+    }\n+\n+    /// Returns a [`CursorMut`] pointing at the last element that is below the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the last\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.upper_bound_mut(Bound::Excluded(&3));\n+    /// assert_eq!(cursor.key(), Some(&2));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn upper_bound_mut<Q>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, K, V, A>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let (root, dormant_root) = DormantMutRef::new(&mut self.root);\n+        let root_node = match root.as_mut() {\n+            None => {\n+                return CursorMut {\n+                    current: None,\n+                    root: dormant_root,\n+                    length: &mut self.length,\n+                    alloc: &mut *self.alloc,\n+                };\n+            }\n+            Some(root) => root.borrow_mut(),\n+        };\n+        let edge = root_node.upper_bound(SearchBound::from_range(bound));\n+        CursorMut {\n+            current: edge.next_back_kv().ok(),\n+            root: dormant_root,\n+            length: &mut self.length,\n+            alloc: &mut *self.alloc,\n+        }\n+    }\n+}\n+\n+/// A cursor over a `BTreeMap`.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth.\n+///\n+/// Cursors always point to an element in the tree, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the last and\n+/// first elements of the tree.\n+///\n+/// A `Cursor` is created with the [`BTreeMap::lower_bound`] and [`BTreeMap::upper_bound`] methods.\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+pub struct Cursor<'a, K: 'a, V: 'a> {\n+    current: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>, marker::KV>>,\n+    root: Option<&'a node::Root<K, V>>,\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K, V> Clone for Cursor<'_, K, V> {\n+    fn clone(&self) -> Self {\n+        let Cursor { current, root } = *self;\n+        Cursor { current, root }\n+    }\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K: Debug, V: Debug> Debug for Cursor<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Cursor\").field(&self.key_value()).finish()\n+    }\n+}\n+\n+/// A cursor over a `BTreeMap` with editing operations.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n+/// safely mutate the tree during iteration. This is because the lifetime of its yielded\n+/// references is tied to its own lifetime, instead of just the underlying tree. This means\n+/// cursors cannot yield multiple elements at once.\n+///\n+/// Cursors always point to an element in the tree, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the last and\n+/// first elements of the tree.\n+///\n+/// A `Cursor` is created with the [`BTreeMap::lower_bound_mut`] and [`BTreeMap::upper_bound_mut`]\n+/// methods.\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+pub struct CursorMut<\n+    'a,\n+    K: 'a,\n+    V: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A = Global,\n+> {\n+    current: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>>,\n+    root: DormantMutRef<'a, Option<node::Root<K, V>>>,\n+    length: &'a mut usize,\n+    alloc: &'a mut A,\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K: Debug, V: Debug, A> Debug for CursorMut<'_, K, V, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"CursorMut\").field(&self.key_value()).finish()\n+    }\n+}\n+\n+impl<'a, K, V> Cursor<'a, K, V> {\n+    /// Moves the cursor to the next element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                self.current = self.root.and_then(|root| {\n+                    root.reborrow().first_leaf_edge().forget_node_type().right_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_leaf_edge().next_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                self.current = self.root.and_then(|root| {\n+                    root.reborrow().last_leaf_edge().forget_node_type().left_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_back_leaf_edge().next_back_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to the key of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key(&self) -> Option<&'a K> {\n+        self.current.as_ref().map(|current| current.into_kv().0)\n+    }\n+\n+    /// Returns a reference to the value of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value(&self) -> Option<&'a V> {\n+        self.current.as_ref().map(|current| current.into_kv().1)\n+    }\n+\n+    /// Returns a reference to the key and value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value(&self) -> Option<(&'a K, &'a V)> {\n+        self.current.as_ref().map(|current| current.into_kv())\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_next(&self) -> Option<(&'a K, &'a V)> {\n+        let mut next = self.clone();\n+        next.move_next();\n+        next.current.as_ref().map(|current| current.into_kv())\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_prev(&self) -> Option<(&'a K, &'a V)> {\n+        let mut prev = self.clone();\n+        prev.move_prev();\n+        prev.current.as_ref().map(|current| current.into_kv())\n+    }\n+}\n+\n+impl<'a, K, V, A> CursorMut<'a, K, V, A> {\n+    /// Moves the cursor to the next element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                self.current = unsafe { self.root.reborrow() }.as_mut().and_then(|root| {\n+                    root.borrow_mut().first_leaf_edge().forget_node_type().right_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_leaf_edge().next_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                self.current = unsafe { self.root.reborrow() }.as_mut().and_then(|root| {\n+                    root.borrow_mut().last_leaf_edge().forget_node_type().left_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_back_leaf_edge().next_back_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to the key of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key(&self) -> Option<&K> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv().0)\n+    }\n+\n+    /// Returns a reference to the value of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value(&self) -> Option<&V> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv().1)\n+    }\n+\n+    /// Returns a reference to the key and value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value(&self) -> Option<(&K, &V)> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv())\n+    }\n+\n+    /// Returns a mutable reference to the value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value_mut(&mut self) -> Option<&mut V> {\n+        self.current.as_mut().map(|current| current.kv_mut().1)\n+    }\n+\n+    /// Returns a reference to the key and mutable reference to the value of the\n+    /// element that the cursor is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value_mut(&mut self) -> Option<(&K, &mut V)> {\n+        self.current.as_mut().map(|current| {\n+            let (k, v) = current.kv_mut();\n+            (&*k, v)\n+        })\n+    }\n+\n+    /// Returns a mutable reference to the of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This can be used to modify the key, but you must ensure that the\n+    /// `BTreeMap` invariants are maintained. Specifically:\n+    ///\n+    /// * The key must remain unique within the tree.\n+    /// * The key must remain in sorted order with regards to other elements in\n+    ///   the tree.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn key_mut_unchecked(&mut self) -> Option<&mut K> {\n+        self.current.as_mut().map(|current| current.kv_mut().0)\n+    }\n+\n+    /// Returns a reference to the key and value of the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_next(&mut self) -> Option<(&K, &mut V)> {\n+        let (k, v) = match self.current {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                unsafe { self.root.reborrow() }\n+                    .as_mut()?\n+                    .borrow_mut()\n+                    .first_leaf_edge()\n+                    .next_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+            // SAFETY: We're not using this to mutate the tree.\n+            Some(ref mut current) => {\n+                unsafe { current.reborrow_mut() }.next_leaf_edge().next_kv().ok()?.into_kv_valmut()\n+            }\n+        };\n+        Some((k, v))\n+    }\n+\n+    /// Returns a reference to the key and value of the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_prev(&mut self) -> Option<(&K, &mut V)> {\n+        let (k, v) = match self.current.as_mut() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                unsafe { self.root.reborrow() }\n+                    .as_mut()?\n+                    .borrow_mut()\n+                    .first_leaf_edge()\n+                    .next_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+            Some(current) => {\n+                // SAFETY: We're not using this to mutate the tree.\n+                unsafe { current.reborrow_mut() }\n+                    .next_back_leaf_edge()\n+                    .next_back_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+        };\n+        Some((k, v))\n+    }\n+\n+    /// Returns a read-only cursor pointing to the current element.\n+    ///\n+    /// The lifetime of the returned `Cursor` is bound to that of the\n+    /// `CursorMut`, which means it cannot outlive the `CursorMut` and that the\n+    /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn as_cursor(&self) -> Cursor<'_, K, V> {\n+        Cursor {\n+            // SAFETY: The tree is immutable while the cursor exists.\n+            root: unsafe { self.root.reborrow_shared().as_ref() },\n+            current: self.current.as_ref().map(|current| current.reborrow()),\n+        }\n+    }\n+}\n+\n+// Now the tree editing operations\n+impl<'a, K: Ord, V, A: Allocator + Clone> CursorMut<'a, K, V, A> {\n+    /// Inserts a new element into the `BTreeMap` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `BTreeMap`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// You must ensure that the `BTreeMap` invariants are maintained.\n+    /// Specifically:\n+    ///\n+    /// * The key of the newly inserted element must be unique in the tree.\n+    /// * All keys in the tree must remain in sorted order.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn insert_after_unchecked(&mut self, key: K, value: V) {\n+        let edge = match self.current.take() {\n+            None => {\n+                // SAFETY: We have no other reference to the tree.\n+                match unsafe { self.root.reborrow() } {\n+                    root @ None => {\n+                        // Tree is empty, allocate a new root.\n+                        let mut node = NodeRef::new_leaf(self.alloc.clone());\n+                        node.borrow_mut().push(key, value);\n+                        *root = Some(node.forget_type());\n+                        *self.length += 1;\n+                        return;\n+                    }\n+                    Some(root) => root.borrow_mut().first_leaf_edge(),\n+                }\n+            }\n+            Some(current) => current.next_leaf_edge(),\n+        };\n+\n+        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n+            drop(ins.left);\n+            // SAFETY: The handle to the newly inserted value is always on a\n+            // leaf node, so adding a new root node doesn't invalidate it.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n+        });\n+        self.current = handle.left_edge().next_back_kv().ok();\n+        *self.length += 1;\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `BTreeMap`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// You must ensure that the `BTreeMap` invariants are maintained.\n+    /// Specifically:\n+    ///\n+    /// * The key of the newly inserted element must be unique in the tree.\n+    /// * All keys in the tree must remain in sorted order.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn insert_before_unchecked(&mut self, key: K, value: V) {\n+        let edge = match self.current.take() {\n+            None => {\n+                // SAFETY: We have no other reference to the tree.\n+                match unsafe { self.root.reborrow() } {\n+                    root @ None => {\n+                        // Tree is empty, allocate a new root.\n+                        let mut node = NodeRef::new_leaf(self.alloc.clone());\n+                        node.borrow_mut().push(key, value);\n+                        *root = Some(node.forget_type());\n+                        *self.length += 1;\n+                        return;\n+                    }\n+                    Some(root) => root.borrow_mut().last_leaf_edge(),\n+                }\n+            }\n+            Some(current) => current.next_back_leaf_edge(),\n+        };\n+\n+        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n+            drop(ins.left);\n+            // SAFETY: The handle to the newly inserted value is always on a\n+            // leaf node, so adding a new root node doesn't invalidate it.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n+        });\n+        self.current = handle.right_edge().next_kv().ok();\n+        *self.length += 1;\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `BTreeMap`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if:\n+    /// - the given key compares less than or equal to the current element (if\n+    ///   any).\n+    /// - the given key compares greater than or equal to the next element (if\n+    ///   any).\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn insert_after(&mut self, key: K, value: V) {\n+        if let Some(current) = self.key() {\n+            if &key <= current {\n+                panic!(\"key must be ordered above the current element\");\n+            }\n+        }\n+        if let Some((next, _)) = self.peek_prev() {\n+            if &key >= next {\n+                panic!(\"key must be ordered below the next element\");\n+            }\n+        }\n+        unsafe {\n+            self.insert_after_unchecked(key, value);\n+        }\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `BTreeMap`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if:\n+    /// - the given key compares greater than or equal to the current element\n+    ///   (if any).\n+    /// - the given key compares less than or equal to the previous element (if\n+    ///   any).\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn insert_before(&mut self, key: K, value: V) {\n+        if let Some(current) = self.key() {\n+            if &key >= current {\n+                panic!(\"key must be ordered below the current element\");\n+            }\n+        }\n+        if let Some((prev, _)) = self.peek_prev() {\n+            if &key <= prev {\n+                panic!(\"key must be ordered above the previous element\");\n+            }\n+        }\n+        unsafe {\n+            self.insert_before_unchecked(key, value);\n+        }\n+    }\n+\n+    /// Removes the current element from the `BTreeMap`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the next element in the `BTreeMap`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned. The cursor is not moved in this case.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn remove_current(&mut self) -> Option<(K, V)> {\n+        let current = self.current.take()?;\n+        let mut emptied_internal_root = false;\n+        let (kv, pos) =\n+            current.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n+        self.current = pos.next_kv().ok();\n+        *self.length -= 1;\n+        if emptied_internal_root {\n+            // SAFETY: This is safe since current does not point within the now\n+            // empty root node.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.pop_internal_level(self.alloc.clone());\n+        }\n+        Some(kv)\n+    }\n+\n+    /// Removes the current element from the `BTreeMap`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the previous element in the `BTreeMap`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned. The cursor is not moved in this case.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn remove_current_and_move_back(&mut self) -> Option<(K, V)> {\n+        let current = self.current.take()?;\n+        let mut emptied_internal_root = false;\n+        let (kv, pos) =\n+            current.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n+        self.current = pos.next_back_kv().ok();\n+        *self.length -= 1;\n+        if emptied_internal_root {\n+            // SAFETY: This is safe since current does not point within the now\n+            // empty root node.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.pop_internal_level(self.alloc.clone());\n+        }\n+        Some(kv)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "76c2f27b46634a885a663a6ba53595a74f79702c", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "patch": "@@ -2336,3 +2336,52 @@ fn from_array() {\n     let unordered_duplicates = BTreeMap::from([(3, 4), (1, 2), (1, 2)]);\n     assert_eq!(map, unordered_duplicates);\n }\n+\n+#[test]\n+fn test_cursor() {\n+    let map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+\n+    let mut cur = map.lower_bound(Bound::Unbounded);\n+    assert_eq!(cur.key(), Some(&1));\n+    cur.move_next();\n+    assert_eq!(cur.key(), Some(&2));\n+    assert_eq!(cur.peek_next(), Some((&3, &'c')));\n+    cur.move_prev();\n+    assert_eq!(cur.key(), Some(&1));\n+    assert_eq!(cur.peek_prev(), None);\n+\n+    let mut cur = map.upper_bound(Bound::Excluded(&1));\n+    assert_eq!(cur.key(), None);\n+    cur.move_next();\n+    assert_eq!(cur.key(), Some(&1));\n+    cur.move_prev();\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(cur.peek_prev(), Some((&3, &'c')));\n+}\n+\n+#[test]\n+fn test_cursor_mut() {\n+    let mut map = BTreeMap::from([(1, 'a'), (3, 'c'), (5, 'e')]);\n+    let mut cur = map.lower_bound_mut(Bound::Excluded(&3));\n+    assert_eq!(cur.key(), Some(&5));\n+    cur.insert_before(4, 'd');\n+    assert_eq!(cur.key(), Some(&5));\n+    assert_eq!(cur.peek_prev(), Some((&4, &mut 'd')));\n+    cur.move_next();\n+    assert_eq!(cur.key(), None);\n+    cur.insert_before(6, 'f');\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(cur.remove_current(), None);\n+    assert_eq!(cur.key(), None);\n+    cur.insert_after(0, '?');\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(map, BTreeMap::from([(0, '?'), (1, 'a'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f')]));\n+\n+    let mut cur = map.upper_bound_mut(Bound::Included(&5));\n+    assert_eq!(cur.key(), Some(&5));\n+    assert_eq!(cur.remove_current(), Some((5, 'e')));\n+    assert_eq!(cur.key(), Some(&6));\n+    assert_eq!(cur.remove_current_and_move_back(), Some((6, 'f')));\n+    assert_eq!(cur.key(), Some(&4));\n+    assert_eq!(map, BTreeMap::from([(0, '?'), (1, 'a'), (3, 'c'), (4, 'd')]));\n+}"}, {"sha": "b890717e50b2544b62dfbc73312ba9e975db3225", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "patch": "@@ -4,6 +4,7 @@ use core::ops::RangeBounds;\n use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n+use super::search::SearchBound;\n \n use crate::alloc::Allocator;\n // `front` and `back` are always both `None` or both `Some`.\n@@ -386,7 +387,7 @@ impl<BorrowType: marker::BorrowType, K, V>\n     /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n     /// on the left side, which is either in the same leaf node or in an ancestor node.\n     /// If the leaf edge is the first one in the tree, returns [`Result::Err`] with the root node.\n-    fn next_back_kv(\n+    pub fn next_back_kv(\n         self,\n     ) -> Result<\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>,\n@@ -707,7 +708,9 @@ impl<BorrowType: marker::BorrowType, K, V>\n     }\n \n     /// Returns the leaf edge closest to a KV for backward navigation.\n-    fn next_back_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+    pub fn next_back_leaf_edge(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n         match self.force() {\n             Leaf(leaf_kv) => leaf_kv.left_edge(),\n             Internal(internal_kv) => {\n@@ -717,3 +720,51 @@ impl<BorrowType: marker::BorrowType, K, V>\n         }\n     }\n }\n+\n+impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Returns the leaf edge corresponding to the first point at which the\n+    /// given bound is true.\n+    pub fn lower_bound<Q: ?Sized>(\n+        self,\n+        mut bound: SearchBound<&Q>,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        let mut node = self;\n+        loop {\n+            let (edge, new_bound) = node.find_lower_bound_edge(bound);\n+            match edge.force() {\n+                Leaf(edge) => return edge,\n+                Internal(edge) => {\n+                    node = edge.descend();\n+                    bound = new_bound;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Returns the leaf edge corresponding to the last point at which the\n+    /// given bound is true.\n+    pub fn upper_bound<Q: ?Sized>(\n+        self,\n+        mut bound: SearchBound<&Q>,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        let mut node = self;\n+        loop {\n+            let (edge, new_bound) = node.find_upper_bound_edge(bound);\n+            match edge.force() {\n+                Leaf(edge) => return edge,\n+                Internal(edge) => {\n+                    node = edge.descend();\n+                    bound = new_bound;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3233a575ecf254e73fe18c3d55679716d276f96c", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "patch": "@@ -819,7 +819,7 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n \n     /// Returns a dormant copy of this handle which can be reawakened later.\n     ///\n-    /// See [`DormantMutRef`] for more details.\n+    /// See `DormantMutRef` for more details.\n     pub fn dormant(&self) -> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {\n         Handle { node: self.node.dormant(), idx: self.idx, _marker: PhantomData }\n     }\n@@ -1099,6 +1099,14 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         let leaf = self.node.into_leaf_mut();\n         unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() }\n     }\n+\n+    pub fn into_kv_valmut(self) -> (&'a K, &'a mut V) {\n+        debug_assert!(self.idx < self.node.len());\n+        let leaf = self.node.into_leaf_mut();\n+        let k = unsafe { leaf.keys.get_unchecked(self.idx).assume_init_ref() };\n+        let v = unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() };\n+        (k, v)\n+    }\n }\n \n impl<'a, K, V, NodeType> Handle<NodeRef<marker::ValMut<'a>, K, V, NodeType>, marker::KV> {"}]}