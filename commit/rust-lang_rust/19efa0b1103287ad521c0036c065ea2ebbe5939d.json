{"sha": "19efa0b1103287ad521c0036c065ea2ebbe5939d", "node_id": "C_kwDOAAsO6NoAKDE5ZWZhMGIxMTAzMjg3YWQ1MjFjMDAzNmMwNjVlYTJlYmJlNTkzOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-22T15:49:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-22T15:49:00Z"}, "message": "Auto merge of #13463 - lowr:fix/builtin-derive-with-const-generics, r=Veykril\n\nSupport const generics for builtin derive macro\n\nFixes #13121\n\nWe have been treating every generic parameter as type parameter during builtin derive macro expansion. This patch adds support for const generics in such expansions.", "tree": {"sha": "0b1b89352d03cd3b7715d871f2dff0d3fc6fd990", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b1b89352d03cd3b7715d871f2dff0d3fc6fd990"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19efa0b1103287ad521c0036c065ea2ebbe5939d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19efa0b1103287ad521c0036c065ea2ebbe5939d", "html_url": "https://github.com/rust-lang/rust/commit/19efa0b1103287ad521c0036c065ea2ebbe5939d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19efa0b1103287ad521c0036c065ea2ebbe5939d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3b7e94d0a443a4df13eb6aecc724d36ae80a29d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b7e94d0a443a4df13eb6aecc724d36ae80a29d", "html_url": "https://github.com/rust-lang/rust/commit/d3b7e94d0a443a4df13eb6aecc724d36ae80a29d"}, {"sha": "6459d7f817ddb91fa2bdc4de8ff61e7905177686", "url": "https://api.github.com/repos/rust-lang/rust/commits/6459d7f817ddb91fa2bdc4de8ff61e7905177686", "html_url": "https://github.com/rust-lang/rust/commit/6459d7f817ddb91fa2bdc4de8ff61e7905177686"}], "stats": {"total": 122, "additions": 62, "deletions": 60}, "files": [{"sha": "fafcde25ae708549241644a6e50803b98c358ce7", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/19efa0b1103287ad521c0036c065ea2ebbe5939d/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19efa0b1103287ad521c0036c065ea2ebbe5939d/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=19efa0b1103287ad521c0036c065ea2ebbe5939d", "patch": "@@ -12,11 +12,11 @@ fn test_copy_expand_simple() {\n #[derive(Copy)]\n struct Foo;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[derive(Copy)]\n struct Foo;\n \n-impl < > core::marker::Copy for Foo< > {}\"##]],\n+impl < > core::marker::Copy for Foo< > {}\"#]],\n     );\n }\n \n@@ -33,15 +33,15 @@ macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro derive {}\n #[rustc_builtin_macro]\n macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \n-impl < > crate ::marker::Copy for Foo< > {}\"##]],\n+impl < > crate ::marker::Copy for Foo< > {}\"#]],\n     );\n }\n \n@@ -53,11 +53,11 @@ fn test_copy_expand_with_type_params() {\n #[derive(Copy)]\n struct Foo<A, B>;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[derive(Copy)]\n struct Foo<A, B>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy> core::marker::Copy for Foo<T0, T1> {}\"##]],\n+impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n     );\n }\n \n@@ -70,11 +70,11 @@ fn test_copy_expand_with_lifetimes() {\n #[derive(Copy)]\n struct Foo<A, B, 'a, 'b>;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[derive(Copy)]\n struct Foo<A, B, 'a, 'b>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy> core::marker::Copy for Foo<T0, T1> {}\"##]],\n+impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n     );\n }\n \n@@ -86,10 +86,26 @@ fn test_clone_expand() {\n #[derive(Clone)]\n struct Foo<A, B>;\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[derive(Clone)]\n struct Foo<A, B>;\n \n-impl <T0: core::clone::Clone, T1: core::clone::Clone> core::clone::Clone for Foo<T0, T1> {}\"##]],\n+impl <T0: core::clone::Clone, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_clone_expand_with_const_generics() {\n+    check(\n+        r#\"\n+//- minicore: derive, clone\n+#[derive(Clone)]\n+struct Foo<const X: usize, T>(u32);\n+\"#,\n+        expect![[r#\"\n+#[derive(Clone)]\n+struct Foo<const X: usize, T>(u32);\n+\n+impl <const T0: usize, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n     );\n }"}, {"sha": "8966047c9b259d932bc8b618f11497fa5b28f205", "filename": "crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/19efa0b1103287ad521c0036c065ea2ebbe5939d/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19efa0b1103287ad521c0036c065ea2ebbe5939d/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=19efa0b1103287ad521c0036c065ea2ebbe5939d", "patch": "@@ -60,7 +60,8 @@ pub fn find_builtin_derive(ident: &name::Name) -> Option<BuiltinDeriveExpander>\n \n struct BasicAdtInfo {\n     name: tt::Ident,\n-    type_or_const_params: usize,\n+    /// `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n+    param_types: Vec<Option<tt::Subtree>>,\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n@@ -92,65 +93,50 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n     let name_token_id =\n         token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n     let name_token = tt::Ident { id: name_token_id, text: name.text().into() };\n-    let type_or_const_params =\n-        params.map_or(0, |type_param_list| type_param_list.type_or_const_params().count());\n-    Ok(BasicAdtInfo { name: name_token, type_or_const_params })\n-}\n-\n-fn make_type_args(n: usize, bound: Vec<tt::TokenTree>) -> Vec<tt::TokenTree> {\n-    let mut result = Vec::<tt::TokenTree>::with_capacity(n * 2);\n-    result.push(\n-        tt::Leaf::Punct(tt::Punct {\n-            char: '<',\n-            spacing: tt::Spacing::Alone,\n-            id: tt::TokenId::unspecified(),\n-        })\n-        .into(),\n-    );\n-    for i in 0..n {\n-        if i > 0 {\n-            result.push(\n-                tt::Leaf::Punct(tt::Punct {\n-                    char: ',',\n-                    spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n-                })\n-                .into(),\n-            );\n-        }\n-        result.push(\n-            tt::Leaf::Ident(tt::Ident {\n-                id: tt::TokenId::unspecified(),\n-                text: format!(\"T{}\", i).into(),\n-            })\n-            .into(),\n-        );\n-        result.extend(bound.iter().cloned());\n-    }\n-    result.push(\n-        tt::Leaf::Punct(tt::Punct {\n-            char: '>',\n-            spacing: tt::Spacing::Alone,\n-            id: tt::TokenId::unspecified(),\n+    let param_types = params\n+        .into_iter()\n+        .flat_map(|param_list| param_list.type_or_const_params())\n+        .map(|param| {\n+            if let ast::TypeOrConstParam::Const(param) = param {\n+                let ty = param\n+                    .ty()\n+                    .map(|ty| mbe::syntax_node_to_token_tree(ty.syntax()).0)\n+                    .unwrap_or_default();\n+                Some(ty)\n+            } else {\n+                None\n+            }\n         })\n-        .into(),\n-    );\n-    result\n+        .collect();\n+    Ok(BasicAdtInfo { name: name_token, param_types })\n }\n \n fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let info = match parse_adt(tt) {\n         Ok(info) => info,\n         Err(e) => return ExpandResult::only_err(e),\n     };\n+    let (params, args): (Vec<_>, Vec<_>) = info\n+        .param_types\n+        .into_iter()\n+        .enumerate()\n+        .map(|(idx, param_ty)| {\n+            let ident = tt::Leaf::Ident(tt::Ident {\n+                id: tt::TokenId::unspecified(),\n+                text: format!(\"T{idx}\").into(),\n+            });\n+            let ident_ = ident.clone();\n+            if let Some(ty) = param_ty {\n+                (quote! { const #ident : #ty , }, quote! { #ident_ , })\n+            } else {\n+                let bound = trait_path.clone();\n+                (quote! { #ident : #bound , }, quote! { #ident_ , })\n+            }\n+        })\n+        .unzip();\n     let name = info.name;\n-    let trait_path_clone = trait_path.token_trees.clone();\n-    let bound = (quote! { : ##trait_path_clone }).token_trees;\n-    let type_params = make_type_args(info.type_or_const_params, bound);\n-    let type_args = make_type_args(info.type_or_const_params, Vec::new());\n-    let trait_path = trait_path.token_trees;\n     let expanded = quote! {\n-        impl ##type_params ##trait_path for #name ##type_args {}\n+        impl < ##params > #trait_path for #name < ##args > {}\n     };\n     ExpandResult::ok(expanded)\n }"}]}