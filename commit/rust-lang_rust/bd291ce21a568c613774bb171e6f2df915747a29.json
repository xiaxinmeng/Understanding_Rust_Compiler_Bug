{"sha": "bd291ce21a568c613774bb171e6f2df915747a29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMjkxY2UyMWE1NjhjNjEzNzc0YmIxNzFlNmYyZGY5MTU3NDdhMjk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-14T21:51:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-10-04T19:25:25Z"}, "message": "Turn some impossible definitions into ICEs", "tree": {"sha": "60fa88f3f4b596ed7882f9097dbd2a878dc31a67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60fa88f3f4b596ed7882f9097dbd2a878dc31a67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd291ce21a568c613774bb171e6f2df915747a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd291ce21a568c613774bb171e6f2df915747a29", "html_url": "https://github.com/rust-lang/rust/commit/bd291ce21a568c613774bb171e6f2df915747a29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd291ce21a568c613774bb171e6f2df915747a29/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75d6522b9a4992b33b69e8fe76ae9be999dd66d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/75d6522b9a4992b33b69e8fe76ae9be999dd66d3", "html_url": "https://github.com/rust-lang/rust/commit/75d6522b9a4992b33b69e8fe76ae9be999dd66d3"}], "stats": {"total": 399, "additions": 161, "deletions": 238}, "files": [{"sha": "8b9cee1d2f6d6184bfbe61cbdd2011d161852ab7", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -25,29 +25,34 @@ pub enum CtorKind {\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n-    Fn(DefId),\n-    SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n+    // Type namespace\n     Mod(DefId),\n-    Static(DefId, bool /* is_mutbl */),\n-    Const(DefId),\n-    AssociatedConst(DefId),\n-    Local(DefId),\n-    Variant(DefId),\n-    VariantCtor(DefId, CtorKind),\n+    Struct(DefId), // DefId refers to NodeId of the struct itself\n+    Union(DefId),\n     Enum(DefId),\n+    Variant(DefId),\n+    Trait(DefId),\n     TyAlias(DefId),\n     AssociatedTy(DefId),\n-    Trait(DefId),\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n+    SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n+\n+    // Value namespace\n+    Fn(DefId),\n+    Const(DefId),\n+    Static(DefId, bool /* is_mutbl */),\n+    StructCtor(DefId, CtorKind), // DefId refers to NodeId of the struct's constructor\n+    VariantCtor(DefId, CtorKind),\n+    Method(DefId),\n+    AssociatedConst(DefId),\n+    Local(DefId),\n     Upvar(DefId,        // def id of closed over local\n           usize,        // index in the freevars list of the closure\n           ast::NodeId), // expr node that creates the closure\n-    Struct(DefId), // DefId refers to NodeId of the struct itself\n-    StructCtor(DefId, CtorKind), // DefId refers to NodeId of the struct's constructor\n-    Union(DefId),\n     Label(ast::NodeId),\n-    Method(DefId),\n+\n+    // Both namespaces\n     Err,\n }\n "}, {"sha": "f56a27b9ae04a1213463efe6f4f0c06dae80ce02", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -44,8 +44,9 @@ use hir;\n use hir::map::Definitions;\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n-use hir::def::{Def, PathResolution};\n+use hir::def::{Def, CtorKind, PathResolution};\n use session::Session;\n+use lint;\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -855,10 +856,23 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref pth, ref pats, ddpos) => {\n-                    hir::PatKind::TupleStruct(self.lower_path(pth),\n-                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n-                                              ddpos)\n+                PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n+                    match self.resolver.get_resolution(p.id).map(|d| d.base_def) {\n+                        Some(def @ Def::StructCtor(_, CtorKind::Const)) |\n+                        Some(def @ Def::VariantCtor(_, CtorKind::Const)) => {\n+                            // Temporarily lower `UnitVariant(..)` into `UnitVariant`\n+                            // for backward compatibility.\n+                            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n+                                            def.kind_name(), path);\n+                            self.sess.add_lint(\n+                                lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n+                                p.id, p.span, msg\n+                            );\n+                            hir::PatKind::Path(None, self.lower_path(path))\n+                        }\n+                        _ => hir::PatKind::TupleStruct(self.lower_path(path),\n+                                        pats.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+                    }\n                 }\n                 PatKind::Path(ref opt_qself, ref path) => {\n                     let opt_qself = opt_qself.as_ref().map(|qself| {"}, {"sha": "0deea941463617f664141b7a86ff8b2e7bd932fc", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -58,7 +58,7 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n         PatKind::Path(..) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) => true,\n+                Some(Def::Variant(..)) | Some(Def::VariantCtor(..)) => true,\n                 _ => false\n             }\n         }\n@@ -173,11 +173,9 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n             PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n             PatKind::Struct(..) => {\n-                match dm.get(&p.id) {\n-                    Some(&PathResolution { base_def: Def::Variant(id), .. }) |\n-                    Some(&PathResolution { base_def: Def::VariantCtor(id, ..), .. }) => {\n-                        variants.push(id);\n-                    }\n+                match dm.get(&p.id).map(|d| d.full_def()) {\n+                    Some(Def::Variant(id)) |\n+                    Some(Def::VariantCtor(id, ..)) => variants.push(id),\n                     _ => ()\n                 }\n             }"}, {"sha": "dc634b08784a4a266031dab0a7befb94f716896b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -106,8 +106,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 self.check_def_id(def.def_id());\n             }\n             _ if self.ignore_non_const_paths => (),\n-            Def::PrimTy(_) => (),\n-            Def::SelfTy(..) => (),\n+            Def::PrimTy(..) | Def::SelfTy(..) => (),\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n                     self.check_def_id(enum_id);"}, {"sha": "799c02b740310cad9bbd78e66af61b94ad3f6251", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -1021,7 +1021,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n-                _ => {}\n+                None | Some(Def::Local(..)) |\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {}\n+                def => bug!(\"unexpected definition: {:?}\", def)\n             }\n         }));\n     }"}, {"sha": "9214138d2107769abc9c5a72e20f4478b9746f01", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -74,7 +74,7 @@ use hir::def_id::DefId;\n use hir::map as ast_map;\n use infer::InferCtxt;\n use middle::const_qualif::ConstQualif;\n-use hir::def::Def;\n+use hir::def::{Def, CtorKind};\n use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n \n@@ -524,22 +524,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                id, expr_ty, def);\n \n         match def {\n-          Def::StructCtor(..) | Def::Union(..) | Def::VariantCtor(..) | Def::Const(..) |\n+          Def::StructCtor(..) | Def::VariantCtor(..) | Def::Const(..) |\n           Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n \n-          Def::Mod(_) |\n-          Def::Trait(_) | Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(_) |\n-          Def::TyParam(..) |\n-          Def::Label(_) | Def::SelfTy(..) |\n-          Def::Variant(..) |\n-          Def::Struct(..) |\n-          Def::AssociatedTy(..) => {\n-              span_bug!(span, \"Unexpected definition in \\\n-                               memory categorization: {:?}\", def);\n-          }\n-\n           Def::Static(_, mutbl) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n@@ -600,7 +589,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }))\n           }\n \n-          Def::Err => bug!(\"Def::Err in memory categorization\")\n+          def => span_bug!(span, \"unexpected definition in memory categorization: {:?}\", def)\n         }\n     }\n \n@@ -1095,11 +1084,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         match pat.node {\n           PatKind::TupleStruct(_, ref subpats, ddpos) => {\n             let expected_len = match self.tcx().expect_def(pat.id) {\n-                Def::VariantCtor(def_id, ..) => {\n+                Def::VariantCtor(def_id, CtorKind::Fn) => {\n                     let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n                     self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n-                Def::StructCtor(..) => {\n+                Def::StructCtor(_, CtorKind::Fn) => {\n                     match self.pat_ty(&pat)?.sty {\n                         ty::TyAdt(adt_def, _) => {\n                             adt_def.struct_variant().fields.len()"}, {"sha": "5192575972b0200ade1b38ac3a9cedf15b16530c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -617,12 +617,8 @@ pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            &Option<DeprecationEntry>)) {\n     // Paths in import prefixes may have no resolution.\n     match tcx.expect_def_or_none(id) {\n-        Some(Def::PrimTy(..)) => {}\n-        Some(Def::SelfTy(..)) => {}\n-        Some(def) => {\n-            maybe_do_stability_check(tcx, def.def_id(), path.span, cb);\n-        }\n-        None => {}\n+        None | Some(Def::PrimTy(..)) | Some(Def::SelfTy(..)) => {}\n+        Some(def) => maybe_do_stability_check(tcx, def.def_id(), path.span, cb)\n     }\n }\n \n@@ -631,12 +627,7 @@ pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       cb: &mut FnMut(DefId, Span,\n                                                      &Option<&Stability>,\n                                                      &Option<DeprecationEntry>)) {\n-    match tcx.expect_def(item.node.id) {\n-        Def::PrimTy(..) => {}\n-        def => {\n-            maybe_do_stability_check(tcx, def.def_id(), item.span, cb);\n-        }\n-    }\n+    maybe_do_stability_check(tcx, tcx.expect_def(item.node.id).def_id(), item.span, cb);\n }\n \n pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,"}, {"sha": "cf54f5908ca9e3ccbd2ab7b447125aeb3aa273b7", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -913,10 +913,10 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::VariantCtor(id, ..) if *constructor != Variant(id) => None,\n-                Def::VariantCtor(..) | Def::StructCtor(..) => Some(Vec::new()),\n-                def => span_bug!(pat_span, \"specialize: unexpected \\\n-                                          definition {:?}\", def),\n+                Def::VariantCtor(id, CtorKind::Const) if *constructor != Variant(id) => None,\n+                Def::VariantCtor(_, CtorKind::Const) |\n+                Def::StructCtor(_, CtorKind::Const) => Some(Vec::new()),\n+                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def),\n             }\n         }\n \n@@ -925,8 +925,9 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::VariantCtor(id, ..) if *constructor != Variant(id) => None,\n-                Def::VariantCtor(..) | Def::StructCtor(..) => {\n+                Def::VariantCtor(id, CtorKind::Fn) if *constructor != Variant(id) => None,\n+                Def::VariantCtor(_, CtorKind::Fn) |\n+                Def::StructCtor(_, CtorKind::Fn) => {\n                     match ddpos {\n                         Some(ddpos) => {\n                             let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n@@ -939,7 +940,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                         None => Some(args.iter().map(|p| wpat(p)).collect())\n                     }\n                 }\n-                _ => None\n+                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def),\n             }\n         }\n "}, {"sha": "d876b4b6fec2eb1054ddd493ecafbaae614afc07", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::{Def, CtorKind, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -287,8 +287,8 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                entry.insert(PathResolution::new(def));\n             }\n             let path = match def {\n-                Def::StructCtor(def_id, ..) => def_to_path(tcx, def_id),\n-                Def::VariantCtor(variant_did, ..) => def_to_path(tcx, variant_did),\n+                Def::StructCtor(def_id, CtorKind::Fn) |\n+                Def::VariantCtor(def_id, CtorKind::Fn) => def_to_path(tcx, def_id),\n                 Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n                     id: expr.id,\n                     node: PatKind::Lit(P(expr.clone())),\n@@ -326,7 +326,8 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         hir::ExprPath(_, ref path) => {\n             match tcx.expect_def(expr.id) {\n-                Def::StructCtor(..) | Def::VariantCtor(..) => PatKind::Path(None, path.clone()),\n+                Def::StructCtor(_, CtorKind::Const) |\n+                Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();"}, {"sha": "a6c5cd1eeeaa7c2d0bc351cdde3caa51d69c14e7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -271,10 +271,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n                         match cx.tcx.expect_def(fun.id) {\n-                            Def::VariantCtor(variant_id, ..) => {\n+                            Def::VariantCtor(variant_id, CtorKind::Fn) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             },\n-                            Def::StructCtor(..) => {\n+                            Def::StructCtor(_, CtorKind::Fn) => {\n                                 Some((adt_def, 0))\n                             },\n                             _ => None\n@@ -670,38 +670,25 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n-        // A regular function.\n-        Def::Fn(def_id) | Def::Method(def_id) => def_id,\n+        // A regular function, constructor function or a constant.\n+        Def::Fn(def_id) | Def::Method(def_id) |\n         Def::StructCtor(def_id, CtorKind::Fn) |\n-        Def::VariantCtor(def_id, CtorKind::Fn) => def_id,\n-        Def::StructCtor(_, CtorKind::Const) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A unit struct which is used as a value. We return a completely different ExprKind\n-            // here to account for this special case.\n+        Def::VariantCtor(def_id, CtorKind::Fn) |\n+        Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n+\n+        Def::StructCtor(def_id, CtorKind::Const) |\n+        Def::VariantCtor(def_id, CtorKind::Const) => match cx.tcx.node_id_to_type(expr.id).sty {\n+            // A unit struct/variant which is used as a value.\n+            // We return a completely different ExprKind here to account for this special case.\n             ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n                 adt_def: adt_def,\n-                variant_index: 0,\n+                variant_index: adt_def.variant_index_with_id(def_id),\n                 substs: substs,\n                 fields: vec![],\n-                base: None\n-            },\n-            ref sty => bug!(\"unexpected sty: {:?}\", sty)\n-        },\n-        Def::VariantCtor(def_id, CtorKind::Const) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A unit variant, similar special case to the struct case above.\n-            ty::TyAdt(adt_def, substs) => {\n-                let index = adt_def.variant_index_with_id(def_id);\n-                return ExprKind::Adt {\n-                    adt_def: adt_def,\n-                    substs: substs,\n-                    variant_index: index,\n-                    fields: vec![],\n-                    base: None\n-                };\n+                base: None,\n             },\n             ref sty => bug!(\"unexpected sty: {:?}\", sty)\n         },\n-        Def::Const(def_id) |\n-        Def::AssociatedConst(def_id) => def_id,\n \n         Def::Static(node_id, _) => return ExprKind::StaticRef {\n             id: node_id,"}, {"sha": "0e0f8a8456731b7327981c89922356302b1cf8f8", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -14,7 +14,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as ast_map;\n use rustc::session::{CompileResult, Session};\n-use rustc::hir::def::{Def, DefMap};\n+use rustc::hir::def::{Def, CtorKind, DefMap};\n use rustc::util::nodemap::NodeMap;\n \n use syntax::ast;\n@@ -272,7 +272,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(Def::VariantCtor(variant_id, ..)) => {\n+                    Some(Def::VariantCtor(variant_id, CtorKind::Const)) => {\n                         if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n                             let variant = self.ast_map.expect_variant(variant_id);\n                             let enum_id = self.ast_map.get_parent(variant_id);"}, {"sha": "4ffe2fe38566ec5bb96c9e31b16a4255abe4c59a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -28,7 +28,7 @@ extern crate syntax_pos;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n-use rustc::hir::def::{self, Def};\n+use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -454,36 +454,25 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprPath(..) => {\n-                if let Def::StructCtor(..) = self.tcx.expect_def(expr.id) {\n-                    let expr_ty = self.tcx.expr_ty(expr);\n-                    let def = match expr_ty.sty {\n-                        ty::TyFnDef(.., &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-                            output: ty, ..\n-                        }), ..}) => ty,\n-                        _ => expr_ty\n-                    }.ty_adt_def().unwrap();\n-\n-                    let private_indexes : Vec<_> = def.struct_variant().fields.iter().enumerate()\n-                        .filter(|&(_,f)| {\n-                            !f.vis.is_accessible_from(self.curitem, &self.tcx.map)\n-                    }).map(|(n,&_)|n).collect();\n+                if let def @ Def::StructCtor(_, CtorKind::Fn) = self.tcx.expect_def(expr.id) {\n+                    let adt_def = self.tcx.expect_variant_def(def);\n+                    let private_indexes = adt_def.fields.iter().enumerate().filter(|&(_, field)| {\n+                        !field.vis.is_accessible_from(self.curitem, &self.tcx.map)\n+                    }).map(|(i, _)| i).collect::<Vec<_>>();\n \n                     if !private_indexes.is_empty() {\n-\n                         let mut error = struct_span_err!(self.tcx.sess, expr.span, E0450,\n                                                          \"cannot invoke tuple struct constructor \\\n-                                                         with private fields\");\n+                                                          with private fields\");\n                         error.span_label(expr.span,\n                                          &format!(\"cannot construct with a private field\"));\n \n-                        if let Some(def_id) = self.tcx.map.as_local_node_id(def.did) {\n-                            if let Some(hir::map::NodeItem(node)) = self.tcx.map.find(def_id) {\n-                                if let hir::Item_::ItemStruct(ref tuple_data, _) = node.node {\n-\n-                                    for i in private_indexes {\n-                                        error.span_label(tuple_data.fields()[i].span,\n-                                                         &format!(\"private field declared here\"));\n-                                    }\n+                        if let Some(node_id) = self.tcx.map.as_local_node_id(adt_def.did) {\n+                            let node = self.tcx.map.find(node_id);\n+                            if let Some(hir::map::NodeStructCtor(vdata)) = node {\n+                                for i in private_indexes {\n+                                    error.span_label(vdata.fields()[i].span,\n+                                                     &format!(\"private field declared here\"));\n                                 }\n                             }\n                         }"}, {"sha": "4f41dfc8b645551e23dab1db11024aba5e27fdc0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -2786,8 +2786,7 @@ impl<'a> Resolver<'a> {\n             // Look for a field with the same name in the current self_type.\n             if let Some(resolution) = self.def_map.get(&node_id) {\n                 match resolution.base_def {\n-                    Def::Enum(did) | Def::TyAlias(did) | Def::Union(did) |\n-                    Def::Struct(did) | Def::Variant(did) if resolution.depth == 0 => {\n+                    Def::Struct(did) | Def::Union(did) if resolution.depth == 0 => {\n                         if let Some(field_names) = self.field_names.get(&did) {\n                             if field_names.iter().any(|&field_name| name == field_name) {\n                                 return Field;"}, {"sha": "6d9cd88afb17b0bb1784f259f6ccebec727d1c3c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -271,12 +271,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n-    // looks up anything, not just a type\n-    fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n+    fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n         self.tcx.expect_def_or_none(ref_id).and_then(|def| {\n             match def {\n-                Def::PrimTy(..) => None,\n-                Def::SelfTy(..) => None,\n+                Def::PrimTy(..) | Def::SelfTy(..) => None,\n                 def => Some(def.def_id()),\n             }\n         })\n@@ -303,11 +301,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 }.lower(self.tcx));\n             }\n             Def::Struct(..) |\n-            Def::StructCtor(..) |\n+            Def::Variant(..) |\n             Def::Union(..) |\n             Def::Enum(..) |\n             Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n             Def::Trait(_) => {\n                 self.dumper.type_ref(TypeRefData {\n                     span: sub_span.expect(\"No span found for type ref\"),\n@@ -317,12 +314,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 }.lower(self.tcx));\n             }\n             Def::Static(..) |\n-            Def::Const(_) |\n-            Def::AssociatedConst(..) |\n-            Def::Local(..) |\n-            Def::Variant(..) |\n-            Def::VariantCtor(..) |\n-            Def::Upvar(..) => {\n+            Def::Const(..) |\n+            Def::StructCtor(..) |\n+            Def::VariantCtor(..) => {\n                 self.dumper.variable_ref(VariableRefData {\n                     span: sub_span.expect(\"No span found for var ref\"),\n                     ref_id: def_id,\n@@ -337,10 +331,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     scope: scope\n                 }.lower(self.tcx));\n             }\n+            Def::Local(..) |\n+            Def::Upvar(..) |\n             Def::SelfTy(..) |\n             Def::Label(_) |\n             Def::TyParam(..) |\n             Def::Method(..) |\n+            Def::AssociatedTy(..) |\n+            Def::AssociatedConst(..) |\n             Def::PrimTy(_) |\n             Def::Err => {\n                span_bug!(span,\n@@ -424,7 +422,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             None => {\n                                 if let Some(NodeItem(item)) = self.tcx.map.get_if_local(id) {\n                                     if let hir::ItemImpl(_, _, _, _, ref ty, _) = item.node {\n-                                        trait_id = self.lookup_type_ref(ty.id);\n+                                        trait_id = self.lookup_def_id(ty.id);\n                                     }\n                                 }\n                             }\n@@ -807,7 +805,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             };\n \n             let trait_ref = &trait_ref.trait_ref;\n-            if let Some(id) = self.lookup_type_ref(trait_ref.ref_id) {\n+            if let Some(id) = self.lookup_def_id(trait_ref.ref_id) {\n                 let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n                 if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n                     self.dumper.type_ref(TypeRefData {\n@@ -926,15 +924,19 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     }\n                 }\n             }\n-            Def::Local(..) |\n-            Def::Static(..) |\n+            Def::Fn(..) |\n             Def::Const(..) |\n+            Def::Static(..) |\n+            Def::StructCtor(..) |\n+            Def::VariantCtor(..) |\n             Def::AssociatedConst(..) |\n+            Def::Local(..) |\n+            Def::Upvar(..) |\n             Def::Struct(..) |\n-            Def::StructCtor(..) |\n+            Def::Union(..) |\n             Def::Variant(..) |\n-            Def::VariantCtor(..) |\n-            Def::Fn(..) => self.write_sub_paths_truncated(path, false),\n+            Def::TyAlias(..) |\n+            Def::AssociatedTy(..) => self.write_sub_paths_truncated(path, false),\n             _ => {}\n         }\n     }\n@@ -1167,7 +1169,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 match use_item.node {\n                     ast::ViewPathSimple(ident, ref path) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_type_ref(item.id) {\n+                        let mod_id = match self.lookup_def_id(item.id) {\n                             Some(def_id) => {\n                                 let scope = self.cur_scope;\n                                 self.process_def_kind(item.id, path.span, sub_span, def_id, scope);\n@@ -1225,7 +1227,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         for plid in list {\n                             let scope = self.cur_scope;\n                             let id = plid.node.id;\n-                            if let Some(def_id) = self.lookup_type_ref(id) {\n+                            if let Some(def_id) = self.lookup_def_id(id) {\n                                 let span = plid.span;\n                                 self.process_def_kind(id, span, Some(span), def_id, scope);\n                             }\n@@ -1320,7 +1322,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         self.process_macro_use(t.span, t.id);\n         match t.node {\n             ast::TyKind::Path(_, ref path) => {\n-                if let Some(id) = self.lookup_type_ref(t.id) {\n+                if let Some(id) = self.lookup_def_id(t.id) {\n                     let sub_span = self.span.sub_span_for_type_name(t.span);\n                     if !self.span.filter_generated(sub_span, t.span) {\n                         self.dumper.type_ref(TypeRefData {\n@@ -1490,14 +1492,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         }.lower(self.tcx));\n                     }\n                 }\n-                Def::Variant(..) | Def::VariantCtor(..) | Def::Enum(..) |\n-                Def::TyAlias(..) | Def::Struct(..) | Def::StructCtor(..) => {\n+                Def::StructCtor(..) | Def::VariantCtor(..) |\n+                Def::Const(..) | Def::AssociatedConst(..) |\n+                Def::Struct(..) | Def::Variant(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n-                // FIXME(nrc) what are these doing here?\n-                Def::Static(..) |\n-                Def::Const(..) |\n-                Def::AssociatedConst(..) => {}\n                 def => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                               def),\n             }"}, {"sha": "15c74f2ed6ab57411a7d5e49aebd4206d7123891", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -507,7 +507,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n-            Def::Variant(..) |\n+            Def::StructCtor(..) |\n             Def::VariantCtor(..) => {\n                 Some(Data::VariableRefData(VariableRefData {\n                     name: self.span_utils.snippet(sub_span.unwrap()),\n@@ -517,10 +517,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             Def::Struct(def_id) |\n-            Def::StructCtor(def_id, ..) |\n+            Def::Variant(def_id, ..) |\n             Def::Union(def_id) |\n             Def::Enum(def_id) |\n             Def::TyAlias(def_id) |\n+            Def::AssociatedTy(def_id) |\n             Def::Trait(def_id) |\n             Def::TyParam(def_id) => {\n                 Some(Data::TypeRefData(TypeRefData {\n@@ -574,7 +575,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: String::new() // FIXME: generate the real qualname\n                 }))\n             }\n-            _ => None,\n+            Def::PrimTy(..) |\n+            Def::SelfTy(..) |\n+            Def::Label(..) |\n+            Def::Err => None,\n         }\n     }\n "}, {"sha": "87729da773f45fb9bb984db09985e6ad383cbbf4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -14,7 +14,6 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation};\n-use lint;\n use util::nodemap::FnvHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -557,17 +556,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_pat(&pat, tcx.types.err);\n             }\n         };\n-        let report_unexpected_def = |def: Def, is_lint| {\n+        let report_unexpected_def = |def: Def| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n                               def.kind_name(), path);\n-            if is_lint {\n-                tcx.sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n-                                  pat.id, pat.span, msg);\n-            } else {\n-                struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n-                    .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n-                on_error();\n-            }\n+            struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n+                .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n+            on_error();\n         };\n \n         // Resolve the path and check the definition for errors.\n@@ -579,29 +573,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 return tcx.types.err;\n             }\n             Def::AssociatedConst(..) | Def::Method(..) => {\n-                report_unexpected_def(def, false);\n+                report_unexpected_def(def);\n                 return tcx.types.err;\n             }\n-            Def::VariantCtor(_, ctor_kind) | Def::StructCtor(_, ctor_kind) => {\n-                if ctor_kind == CtorKind::Const {\n-                    // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n-                    // is allowed for backward compatibility.\n-                    report_unexpected_def(def, true);\n-                }\n+            Def::VariantCtor(_, CtorKind::Fn) |\n+            Def::StructCtor(_, CtorKind::Fn) => {\n                 tcx.expect_variant_def(def)\n             }\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)\n         };\n \n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n-        let pat_ty = if pat_ty.is_fn() {\n-            // Replace constructor type with constructed type for tuple struct patterns.\n-            tcx.no_late_bound_regions(&pat_ty.fn_ret()).unwrap()\n-        } else {\n-            // Leave the type as is for unit structs (backward compatibility).\n-            pat_ty\n-        };\n+        // Replace constructor type with constructed type for tuple struct patterns.\n+        let pat_ty = tcx.no_late_bound_regions(&pat_ty.fn_ret()).expect(\"expected fn type\");\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns."}, {"sha": "79c1c5fb5e2e11728aa1a3431de0ce8c81752b13", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 53, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -3245,7 +3245,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Struct(type_did) | Def::Union(type_did) => {\n                 Some((type_did, self.tcx.expect_variant_def(def)))\n             }\n-            Def::TyAlias(did) => {\n+            Def::TyAlias(did) | Def::AssociatedTy(did) => {\n                 match self.tcx.opt_lookup_item_type(did).map(|scheme| &scheme.ty.sty) {\n                     Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => {\n                         Some((did, adt.struct_variant()))\n@@ -4064,34 +4064,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // There are basically four cases to consider:\n         //\n-        // 1. Reference to a *type*, such as a struct or enum:\n+        // 1. Reference to a constructor of enum variant or struct:\n         //\n-        //        mod a { struct Foo<T> { ... } }\n-        //\n-        //    Because we don't allow types to be declared within one\n-        //    another, a path that leads to a type will always look like\n-        //    `a::b::Foo<T>` where `a` and `b` are modules. This implies\n-        //    that only the final segment can have type parameters, and\n-        //    they are located in the TypeSpace.\n-        //\n-        //    *Note:* Generally speaking, references to types don't\n-        //    actually pass through this function, but rather the\n-        //    `ast_ty_to_ty` function in `astconv`. However, in the case\n-        //    of struct patterns (and maybe literals) we do invoke\n-        //    `instantiate_value_path` to get the general type of an instance of\n-        //    a struct. (In these cases, there are actually no type\n-        //    parameters permitted at present, but perhaps we will allow\n-        //    them in the future.)\n-        //\n-        // 1b. Reference to an enum variant or tuple-like struct:\n-        //\n-        //        struct foo<T>(...)\n-        //        enum E<T> { foo(...) }\n+        //        struct Foo<T>(...)\n+        //        enum E<T> { Foo(...) }\n         //\n         //    In these cases, the parameters are declared in the type\n         //    space.\n         //\n-        // 2. Reference to a *fn item*:\n+        // 2. Reference to a fn item or a free constant:\n         //\n         //        fn foo<T>() { }\n         //\n@@ -4100,7 +4081,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    type parameters. However, in this case, those parameters are\n         //    declared on a value, and hence are in the `FnSpace`.\n         //\n-        // 3. Reference to a *method*:\n+        // 3. Reference to a method or an associated constant:\n         //\n         //        impl<A> SomeStruct<A> {\n         //            fn foo<B>(...)\n@@ -4112,15 +4093,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n         //    final segment, `foo::<B>` contains parameters in fn space.\n         //\n-        // 4. Reference to an *associated const*:\n-        //\n-        // impl<A> AnotherStruct<A> {\n-        // const FOO: B = BAR;\n-        // }\n+        // 4. Reference to a local variable\n         //\n-        // The path in this case will look like\n-        // `a::b::AnotherStruct::<A>::FOO`, so the penultimate segment\n-        // only will have parameters in TypeSpace.\n+        //    Local variables can't have any type parameters.\n         //\n         // The first step then is to categorize the segments appropriately.\n \n@@ -4130,14 +4105,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut type_segment = None;\n         let mut fn_segment = None;\n         match def {\n-            // Case 1 and 1b. Reference to a *type* or *enum variant*.\n+            // Case 1. Reference to a struct/variant constructor.\n             Def::StructCtor(def_id, ..) |\n-            Def::Union(def_id) |\n-            Def::VariantCtor(def_id, ..) |\n-            Def::Enum(def_id) |\n-            Def::TyAlias(def_id) |\n-            Def::AssociatedTy(def_id) |\n-            Def::Trait(def_id) => {\n+            Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n                 let mut generics = self.tcx.lookup_generics(def_id);\n@@ -4180,19 +4150,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 fn_segment = Some((segments.last().unwrap(), generics));\n             }\n \n-            // Other cases. Various nonsense that really shouldn't show up\n-            // here. If they do, an error will have been reported\n-            // elsewhere. (I hope)\n-            Def::Mod(..) |\n-            Def::PrimTy(..) |\n-            Def::SelfTy(..) |\n-            Def::TyParam(..) |\n-            Def::Local(..) |\n-            Def::Label(..) |\n-            Def::Upvar(..) |\n-            Def::Variant(..) |\n-            Def::Struct(..) |\n-            Def::Err => {}\n+            // Case 4. Local variable, no generics.\n+            Def::Local(..) | Def::Upvar(..) => {}\n+\n+            _ => bug!(\"unexpected definition: {:?}\", def),\n         }\n \n         // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but"}, {"sha": "feca2d328fe3b2432414d955b8395a6ac60866bc", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd291ce21a568c613774bb171e6f2df915747a29/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bd291ce21a568c613774bb171e6f2df915747a29", "patch": "@@ -17,7 +17,6 @@ use rustc::hir;\n \n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::DefPathData;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::FnvHashSet;\n@@ -81,9 +80,7 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             record_extern_fqn(cx, did, clean::TypeKind::Function);\n             clean::FunctionItem(build_external_function(cx, tcx, did))\n         }\n-        Def::Struct(did)\n-                // If this is a struct constructor, we skip it\n-                if tcx.def_key(did).disambiguated_data.data != DefPathData::StructCtor => {\n+        Def::Struct(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::StructItem(build_struct(cx, tcx, did))\n@@ -105,7 +102,10 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n-        Def::Variant(..) => return Some(Vec::new()),\n+        // Similarly, consider that struct type is reexported next to its constructor.\n+        Def::Variant(..) |\n+        Def::VariantCtor(..) |\n+        Def::StructCtor(..) => return Some(Vec::new()),\n         Def::Mod(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Module);\n             clean::ModuleItem(build_module(cx, tcx, did))\n@@ -114,7 +114,7 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             record_extern_fqn(cx, did, clean::TypeKind::Static);\n             clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n-        Def::Const(did) | Def::AssociatedConst(did) => {\n+        Def::Const(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, tcx, did))\n         }\n@@ -501,10 +501,8 @@ fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let def_id = item.def.def_id();\n             if tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n                 if !visited.insert(def_id) { continue }\n-                if let Some(def) = tcx.sess.cstore.describe_def(def_id) {\n-                    if let Some(i) = try_inline_def(cx, tcx, def) {\n-                        items.extend(i)\n-                    }\n+                if let Some(i) = try_inline_def(cx, tcx, item.def) {\n+                    items.extend(i)\n                 }\n             }\n         }"}]}