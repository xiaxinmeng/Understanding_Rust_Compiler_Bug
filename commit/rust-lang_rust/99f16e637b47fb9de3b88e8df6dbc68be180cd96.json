{"sha": "99f16e637b47fb9de3b88e8df6dbc68be180cd96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZjE2ZTYzN2I0N2ZiOWRlM2I4OGU4ZGY2ZGJjNjhiZTE4MGNkOTY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-09T18:06:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-09T18:06:39Z"}, "message": "Rollup merge of #76468 - SNCPlay42:lifetime-names, r=Mark-Simulacrum\n\nImprove lifetime name annotations for closures & async functions\n\n* Don't refer to async functions as \"generators\" in error output\n* Where possible, emit annotations pointing exactly at the `&` in the return type of closures (when they have explicit return types) and async functions, like we do for arguments.\nAddresses #74072, but I wouldn't call that *closed* until annotations are identical for async and non-async functions.\n* Emit a better annotation when the lifetime doesn't appear in the full name type, which currently happens for opaque types like `impl Future`. Addresses #74497, but further improves could probably be made (why *doesn't* it appear in the type as `impl Future + '1`?)\nThis is included in the same PR because the changes to `give_name_if_anonymous_region_appears_in_output` would introduce ICE otherwise (it would return `None` in cases where it didn't previously, which then gets `unwrap`ped)", "tree": {"sha": "2616a6a3e193f700edd985e1d9511bac73fe2eeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2616a6a3e193f700edd985e1d9511bac73fe2eeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99f16e637b47fb9de3b88e8df6dbc68be180cd96", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfqYUwCRBK7hj4Ov3rIwAAdHIIAHdVZOkNT4ujwXjSAbECWTfV\n7f5DU1tbunDl12Hb+jGni+ktfcWXA9utunQk7laQQRnQLrPhhLQBuiVu4uMS6wAO\nourKOmulGrU0lZM0qBsHnhaMQjuQX7CEl7bm6Hkzqo8WhVXZLeia/SEDkWxz0My5\nxVnFe0H/k6Vc8TG0HAdwm7Iqdw/3WtA3CFuP0eXAgRUpi4IIvXnOELwGqFJfkG/Q\nH3dVGkB2ejjA83hmQRcyHm2mYSAUENLYXu9CaMyeDTGuSaeQG/pHMxfGvZ/jO85s\n60r6t3rZzlIDzBOq9egTkfmllowaGsEAMRT0VXlaloJYZKYisZWigSGEXGmZHrI=\n=NuO7\n-----END PGP SIGNATURE-----\n", "payload": "tree 2616a6a3e193f700edd985e1d9511bac73fe2eeb\nparent 46bce9f8efbd4c57a23e822588650250d1e74b26\nparent 61b52a33b3a5a170f7760ba3e3efaac25e5085ef\nauthor Dylan DPC <dylan.dpc@gmail.com> 1604945199 +0100\ncommitter GitHub <noreply@github.com> 1604945199 +0100\n\nRollup merge of #76468 - SNCPlay42:lifetime-names, r=Mark-Simulacrum\n\nImprove lifetime name annotations for closures & async functions\n\n* Don't refer to async functions as \"generators\" in error output\n* Where possible, emit annotations pointing exactly at the `&` in the return type of closures (when they have explicit return types) and async functions, like we do for arguments.\nAddresses #74072, but I wouldn't call that *closed* until annotations are identical for async and non-async functions.\n* Emit a better annotation when the lifetime doesn't appear in the full name type, which currently happens for opaque types like `impl Future`. Addresses #74497, but further improves could probably be made (why *doesn't* it appear in the type as `impl Future + '1`?)\nThis is included in the same PR because the changes to `give_name_if_anonymous_region_appears_in_output` would introduce ICE otherwise (it would return `None` in cases where it didn't previously, which then gets `unwrap`ped)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99f16e637b47fb9de3b88e8df6dbc68be180cd96", "html_url": "https://github.com/rust-lang/rust/commit/99f16e637b47fb9de3b88e8df6dbc68be180cd96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99f16e637b47fb9de3b88e8df6dbc68be180cd96/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46bce9f8efbd4c57a23e822588650250d1e74b26", "url": "https://api.github.com/repos/rust-lang/rust/commits/46bce9f8efbd4c57a23e822588650250d1e74b26", "html_url": "https://github.com/rust-lang/rust/commit/46bce9f8efbd4c57a23e822588650250d1e74b26"}, {"sha": "61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "html_url": "https://github.com/rust-lang/rust/commit/61b52a33b3a5a170f7760ba3e3efaac25e5085ef"}], "stats": {"total": 328, "additions": 282, "deletions": 46}, "files": [{"sha": "2a90fb042dd7183408b0d5d72b73c14c9dff1e89", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 161, "deletions": 43, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/99f16e637b47fb9de3b88e8df6dbc68be180cd96/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f16e637b47fb9de3b88e8df6dbc68be180cd96/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=99f16e637b47fb9de3b88e8df6dbc68be180cd96", "patch": "@@ -6,8 +6,8 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_middle::ty::print::RegionHighlightMode;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::kw;\n-use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n \n use crate::borrow_check::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n \n@@ -39,7 +39,7 @@ crate enum RegionNameSource {\n     /// The region corresponding to a closure upvar.\n     AnonRegionFromUpvar(Span, String),\n     /// The region corresponding to the return type of a closure.\n-    AnonRegionFromOutput(Span, String, String),\n+    AnonRegionFromOutput(RegionNameHighlight, String),\n     /// The region from a type yielded by a generator.\n     AnonRegionFromYieldTy(Span, String),\n     /// An anonymous region from an async fn.\n@@ -57,6 +57,10 @@ crate enum RegionNameHighlight {\n     /// The anonymous region corresponds to a region where the type annotation is completely missing\n     /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n     CannotMatchHirTy(Span, String),\n+    /// The anonymous region corresponds to a region where the type annotation is completely missing\n+    /// from the code, and *even if* we print out the full name of the type, the region name won't\n+    /// be included. This currently occurs for opaque types like `impl Future`.\n+    Occluded(Span, String),\n }\n \n impl RegionName {\n@@ -81,13 +85,14 @@ impl RegionName {\n             | RegionNameSource::NamedFreeRegion(span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(span, _)\n             | RegionNameSource::AnonRegionFromUpvar(span, _)\n-            | RegionNameSource::AnonRegionFromOutput(span, _, _)\n             | RegionNameSource::AnonRegionFromYieldTy(span, _)\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => Some(span),\n-            RegionNameSource::AnonRegionFromArgument(ref highlight) => match *highlight {\n+            RegionNameSource::AnonRegionFromArgument(ref highlight)\n+            | RegionNameSource::AnonRegionFromOutput(ref highlight, _) => match *highlight {\n                 RegionNameHighlight::MatchedHirTy(span)\n                 | RegionNameHighlight::MatchedAdtAndSegment(span)\n-                | RegionNameHighlight::CannotMatchHirTy(span, _) => Some(span),\n+                | RegionNameHighlight::CannotMatchHirTy(span, _)\n+                | RegionNameHighlight::Occluded(span, _) => Some(span),\n             },\n         }\n     }\n@@ -112,6 +117,7 @@ impl RegionName {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::MatchedHirTy(span))\n+            | RegionNameSource::AnonRegionFromOutput(RegionNameHighlight::MatchedHirTy(span), _)\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => {\n                 diag.span_label(\n                     *span,\n@@ -120,16 +126,44 @@ impl RegionName {\n             }\n             RegionNameSource::AnonRegionFromArgument(\n                 RegionNameHighlight::MatchedAdtAndSegment(span),\n+            )\n+            | RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::MatchedAdtAndSegment(span),\n+                _,\n             ) => {\n                 diag.span_label(*span, format!(\"let's call this `{}`\", self));\n             }\n+            RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::Occluded(\n+                span,\n+                type_name,\n+            )) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"lifetime `{}` appears in the type {}\", self, type_name),\n+                );\n+            }\n+            RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::Occluded(span, type_name),\n+                mir_description,\n+            ) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\n+                        \"return type{} `{}` contains a lifetime `{}`\",\n+                        mir_description, type_name, self\n+                    ),\n+                );\n+            }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n                 );\n             }\n-            RegionNameSource::AnonRegionFromOutput(span, mir_description, type_name) => {\n+            RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::CannotMatchHirTy(span, type_name),\n+                mir_description,\n+            ) => {\n                 diag.span_label(*span, format!(\"return type{} is {}\", mir_description, type_name));\n             }\n             RegionNameSource::AnonRegionFromYieldTy(span, type_name) => {\n@@ -349,19 +383,21 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             argument_index,\n         );\n \n-        self.get_argument_hir_ty_for_highlighting(argument_index)\n+        let highlight = self\n+            .get_argument_hir_ty_for_highlighting(argument_index)\n             .and_then(|arg_hir_ty| self.highlight_if_we_can_match_hir_ty(fr, arg_ty, arg_hir_ty))\n-            .or_else(|| {\n+            .unwrap_or_else(|| {\n                 // `highlight_if_we_cannot_match_hir_ty` needs to know the number we will give to\n                 // the anonymous region. If it succeeds, the `synthesize_region_name` call below\n                 // will increment the counter, \"reserving\" the number we just used.\n                 let counter = *self.next_region_name.try_borrow().unwrap();\n                 self.highlight_if_we_cannot_match_hir_ty(fr, arg_ty, span, counter)\n-            })\n-            .map(|highlight| RegionName {\n-                name: self.synthesize_region_name(),\n-                source: RegionNameSource::AnonRegionFromArgument(highlight),\n-            })\n+            });\n+\n+        Some(RegionName {\n+            name: self.synthesize_region_name(),\n+            source: RegionNameSource::AnonRegionFromArgument(highlight),\n+        })\n     }\n \n     fn get_argument_hir_ty_for_highlighting(\n@@ -399,7 +435,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         ty: Ty<'tcx>,\n         span: Span,\n         counter: usize,\n-    ) -> Option<RegionNameHighlight> {\n+    ) -> RegionNameHighlight {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n         let type_name =\n@@ -411,9 +447,9 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         );\n         if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            Some(RegionNameHighlight::CannotMatchHirTy(span, type_name))\n+            RegionNameHighlight::CannotMatchHirTy(span, type_name)\n         } else {\n-            None\n+            RegionNameHighlight::Occluded(span, type_name)\n         }\n     }\n \n@@ -643,49 +679,131 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// or be early bound (named, not in argument).\n     fn give_name_if_anonymous_region_appears_in_output(&self, fr: RegionVid) -> Option<RegionName> {\n         let tcx = self.infcx.tcx;\n+        let hir = tcx.hir();\n \n         let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n-        let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name =\n-            self.infcx.extract_inference_diagnostics_data(return_ty.into(), Some(highlight)).name;\n+        let mir_hir_id = self.mir_hir_id();\n \n-        let (return_span, mir_description) = match tcx.hir().get(self.mir_hir_id()) {\n+        let (return_span, mir_description, hir_ty) = match hir.get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n-                kind: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n-                ..\n-            }) => (\n-                match return_ty.output {\n-                    hir::FnRetTy::DefaultReturn(_) => tcx.sess.source_map().end_point(*span),\n-                    hir::FnRetTy::Return(_) => return_ty.output.span(),\n-                },\n-                if gen_move.is_some() { \" of generator\" } else { \" of closure\" },\n-            ),\n-            hir::Node::ImplItem(hir::ImplItem {\n-                kind: hir::ImplItemKind::Fn(method_sig, _),\n+                kind: hir::ExprKind::Closure(_, return_ty, body_id, span, _),\n                 ..\n-            }) => (method_sig.decl.output.span(), \"\"),\n-            _ => (self.body.span, \"\"),\n+            }) => {\n+                let (mut span, mut hir_ty) = match return_ty.output {\n+                    hir::FnRetTy::DefaultReturn(_) => {\n+                        (tcx.sess.source_map().end_point(*span), None)\n+                    }\n+                    hir::FnRetTy::Return(hir_ty) => (return_ty.output.span(), Some(hir_ty)),\n+                };\n+                let mir_description = match hir.body(*body_id).generator_kind {\n+                    Some(hir::GeneratorKind::Async(gen)) => match gen {\n+                        hir::AsyncGeneratorKind::Block => \" of async block\",\n+                        hir::AsyncGeneratorKind::Closure => \" of async closure\",\n+                        hir::AsyncGeneratorKind::Fn => {\n+                            let parent_item = hir.get(hir.get_parent_item(mir_hir_id));\n+                            let output = &parent_item\n+                                .fn_decl()\n+                                .expect(\"generator lowered from async fn should be in fn\")\n+                                .output;\n+                            span = output.span();\n+                            if let hir::FnRetTy::Return(ret) = output {\n+                                hir_ty = Some(self.get_future_inner_return_ty(*ret));\n+                            }\n+                            \" of async function\"\n+                        }\n+                    },\n+                    Some(hir::GeneratorKind::Gen) => \" of generator\",\n+                    None => \" of closure\",\n+                };\n+                (span, mir_description, hir_ty)\n+            }\n+            node => match node.fn_decl() {\n+                Some(fn_decl) => {\n+                    let hir_ty = match fn_decl.output {\n+                        hir::FnRetTy::DefaultReturn(_) => None,\n+                        hir::FnRetTy::Return(ty) => Some(ty),\n+                    };\n+                    (fn_decl.output.span(), \"\", hir_ty)\n+                }\n+                None => (self.body.span, \"\", None),\n+            },\n         };\n \n+        let highlight = hir_ty\n+            .and_then(|hir_ty| self.highlight_if_we_can_match_hir_ty(fr, return_ty, hir_ty))\n+            .unwrap_or_else(|| {\n+                // `highlight_if_we_cannot_match_hir_ty` needs to know the number we will give to\n+                // the anonymous region. If it succeeds, the `synthesize_region_name` call below\n+                // will increment the counter, \"reserving\" the number we just used.\n+                let counter = *self.next_region_name.try_borrow().unwrap();\n+                self.highlight_if_we_cannot_match_hir_ty(fr, return_ty, return_span, counter)\n+            });\n+\n         Some(RegionName {\n-            // This counter value will already have been used, so this function will increment it\n-            // so the next value will be used next and return the region name that would have been\n-            // used.\n             name: self.synthesize_region_name(),\n-            source: RegionNameSource::AnonRegionFromOutput(\n-                return_span,\n-                mir_description.to_string(),\n-                type_name,\n-            ),\n+            source: RegionNameSource::AnonRegionFromOutput(highlight, mir_description.to_string()),\n         })\n     }\n \n+    /// From the [`hir::Ty`] of an async function's lowered return type,\n+    /// retrieve the `hir::Ty` representing the type the user originally wrote.\n+    ///\n+    /// e.g. given the function:\n+    ///\n+    /// ```\n+    /// async fn foo() -> i32 {}\n+    /// ```\n+    ///\n+    /// this function, given the lowered return type of `foo`, an [`OpaqueDef`] that implements `Future<Output=i32>`,\n+    /// returns the `i32`.\n+    ///\n+    /// [`OpaqueDef`]: hir::TyKind::OpaqueDef\n+    fn get_future_inner_return_ty(&self, hir_ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n+        let hir = self.infcx.tcx.hir();\n+\n+        if let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind {\n+            let opaque_ty = hir.item(id.id);\n+            if let hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                bounds:\n+                    [hir::GenericBound::LangItemTrait(\n+                        hir::LangItem::Future,\n+                        _,\n+                        _,\n+                        hir::GenericArgs {\n+                            bindings:\n+                                [hir::TypeBinding {\n+                                    ident: Ident { name: sym::Output, .. },\n+                                    kind: hir::TypeBindingKind::Equality { ty },\n+                                    ..\n+                                }],\n+                            ..\n+                        },\n+                    )],\n+                ..\n+            }) = opaque_ty.kind\n+            {\n+                ty\n+            } else {\n+                span_bug!(\n+                    hir_ty.span,\n+                    \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n+                    opaque_ty\n+                );\n+            }\n+        } else {\n+            span_bug!(\n+                hir_ty.span,\n+                \"lowered return type of async fn is not OpaqueDef: {:?}\",\n+                hir_ty\n+            );\n+        }\n+    }\n+\n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n         fr: RegionVid,"}, {"sha": "95683241aba26738fb72c501138ccc1956f80d74", "filename": "src/test/ui/async-await/issue-74072-lifetime-name-annotations.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs?ref=99f16e637b47fb9de3b88e8df6dbc68be180cd96", "patch": "@@ -0,0 +1,37 @@\n+// edition:2018\n+#![feature(async_closure)]\n+use std::future::Future;\n+\n+// test the quality of annotations giving lifetimes names (`'1`) when async constructs are involved\n+\n+pub async fn async_fn(x: &mut i32) -> &i32 {\n+    let y = &*x;\n+    *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+    y\n+}\n+\n+pub fn async_closure(x: &mut i32) -> impl Future<Output=&i32> {\n+    (async move || {\n+        let y = &*x;\n+        *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+        y\n+    })()\n+}\n+\n+pub fn async_closure_explicit_return_type(x: &mut i32) -> impl Future<Output=&i32> {\n+    (async move || -> &i32 {\n+        let y = &*x;\n+        *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+        y\n+    })()\n+}\n+\n+pub fn async_block(x: &mut i32) -> impl Future<Output=&i32> {\n+    async move {\n+        let y = &*x;\n+        *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+        y\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "123c3192cffba66552ab8130dbcad9643b32f0ef", "filename": "src/test/ui/async-await/issue-74072-lifetime-name-annotations.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr?ref=99f16e637b47fb9de3b88e8df6dbc68be180cd96", "patch": "@@ -0,0 +1,51 @@\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:9:5\n+   |\n+LL | pub async fn async_fn(x: &mut i32) -> &i32 {\n+   |                                       - let's call the lifetime of this reference `'1`\n+LL |     let y = &*x;\n+   |             --- borrow of `*x` occurs here\n+LL |     *x += 1;\n+   |     ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |     y\n+   |     - returning this value requires that `*x` is borrowed for `'1`\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:16:9\n+   |\n+LL |         let y = &*x;\n+   |                 --- borrow of `*x` occurs here\n+LL |         *x += 1;\n+   |         ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |         y\n+   |         - returning this value requires that `*x` is borrowed for `'1`\n+LL |     })()\n+   |     - return type of async closure is &'1 i32\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:24:9\n+   |\n+LL |     (async move || -> &i32 {\n+   |                       - let's call the lifetime of this reference `'1`\n+LL |         let y = &*x;\n+   |                 --- borrow of `*x` occurs here\n+LL |         *x += 1;\n+   |         ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |         y\n+   |         - returning this value requires that `*x` is borrowed for `'1`\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:32:9\n+   |\n+LL |         let y = &*x;\n+   |                 --- borrow of `*x` occurs here\n+LL |         *x += 1;\n+   |         ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |         y\n+   |         - returning this value requires that `*x` is borrowed for `'1`\n+LL |     }\n+   |     - return type of async block is &'1 i32\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "2d765eb41be07ecca0865d24d74a5250d4c3e489", "filename": "src/test/ui/async-await/issue-74497-lifetime-in-opaque.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs?ref=99f16e637b47fb9de3b88e8df6dbc68be180cd96", "patch": "@@ -0,0 +1,19 @@\n+// edition:2018\n+\n+// test that names give to anonymous lifetimes in opaque types like `impl Future` are correctly\n+// introduced in error messages\n+\n+use std::future::Future;\n+\n+pub async fn foo<F, T>(_: F)\n+where\n+    F: Fn(&u8) -> T,\n+    T: Future<Output = ()>,\n+{\n+}\n+\n+pub async fn bar(_: &u8) {}\n+\n+fn main() {\n+    let _ = foo(|x| bar(x)); //~ ERROR lifetime may not live long enough\n+}"}, {"sha": "89fe1abb3656b5c3e2eda9076c53b0528993fd65", "filename": "src/test/ui/async-await/issue-74497-lifetime-in-opaque.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr?ref=99f16e637b47fb9de3b88e8df6dbc68be180cd96", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-74497-lifetime-in-opaque.rs:18:21\n+   |\n+LL |     let _ = foo(|x| bar(x));\n+   |                  -- ^^^^^^ returning this value requires that `'1` must outlive `'2`\n+   |                  ||\n+   |                  |return type of closure `impl Future` contains a lifetime `'2`\n+   |                  has type `&'1 u8`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a7c3b9eec73c5624cb94f2c1718ae4e81299720a", "filename": "src/test/ui/borrowck/issue-53432-nested-closure-outlives-borrowed-value.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr?ref=99f16e637b47fb9de3b88e8df6dbc68be180cd96", "patch": "@@ -4,7 +4,7 @@ error: lifetime may not live long enough\n LL |     let _action = move || {\n    |                   -------\n    |                   |     |\n-   |                   |     return type of closure is [closure@$DIR/issue-53432-nested-closure-outlives-borrowed-value.rs:4:9: 4:15]\n+   |                   |     return type of closure `[closure@$DIR/issue-53432-nested-closure-outlives-borrowed-value.rs:4:9: 4:15]` contains a lifetime `'2`\n    |                   lifetime `'1` represents this closure's body\n LL |         || f() // The `nested` closure\n    |         ^^^^^^ returning this value requires that `'1` must outlive `'2`"}, {"sha": "e41ee8a89709caf48ed2af2c6b3d953c35c325a4", "filename": "src/test/ui/nll/issue-58053.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99f16e637b47fb9de3b88e8df6dbc68be180cd96/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr?ref=99f16e637b47fb9de3b88e8df6dbc68be180cd96", "patch": "@@ -2,9 +2,9 @@ error: lifetime may not live long enough\n   --> $DIR/issue-58053.rs:6:33\n    |\n LL |     let f = |x: &i32| -> &i32 { x };\n-   |                 -        ----   ^ returning this value requires that `'1` must outlive `'2`\n+   |                 -        -      ^ returning this value requires that `'1` must outlive `'2`\n    |                 |        |\n-   |                 |        return type of closure is &'2 i32\n+   |                 |        let's call the lifetime of this reference `'2`\n    |                 let's call the lifetime of this reference `'1`\n \n error: lifetime may not live long enough"}]}