{"sha": "19193d6390644b5d621934bac6a33caacfb9ad31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MTkzZDYzOTA2NDRiNWQ2MjE5MzRiYWM2YTMzY2FhY2ZiOWFkMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-09T08:03:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-09T08:03:14Z"}, "message": "Auto merge of #42504 - michaelwoerister:hash-dep-nodes-prep, r=nikomatsakis\n\nSome preparatory refactorings for hash-based DepNodes\n\nThis PR collects some changes that turn out to be necessary for implementing `DepNodes` based on stable hashes (see #42294). The commits are self-contained and mostly straightforward.\n\nThe most interesting change here is the introduction of `DefIndices` for things that are not part of the AST: Some pieces of crate metadata now have a `DefIndex` too.\n\ncc @eddyb\nr? @nikomatsakis", "tree": {"sha": "6b82bb51e0e28924687bd173c71aeb3ed2f8c5f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b82bb51e0e28924687bd173c71aeb3ed2f8c5f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19193d6390644b5d621934bac6a33caacfb9ad31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19193d6390644b5d621934bac6a33caacfb9ad31", "html_url": "https://github.com/rust-lang/rust/commit/19193d6390644b5d621934bac6a33caacfb9ad31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19193d6390644b5d621934bac6a33caacfb9ad31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2416e222ecae76a36e958a8f7c4ac8083eb1ca45", "url": "https://api.github.com/repos/rust-lang/rust/commits/2416e222ecae76a36e958a8f7c4ac8083eb1ca45", "html_url": "https://github.com/rust-lang/rust/commit/2416e222ecae76a36e958a8f7c4ac8083eb1ca45"}, {"sha": "8b36d3308effcc013c9c4aea9d83fa1d8bd540c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b36d3308effcc013c9c4aea9d83fa1d8bd540c1", "html_url": "https://github.com/rust-lang/rust/commit/8b36d3308effcc013c9c4aea9d83fa1d8bd540c1"}], "stats": {"total": 812, "additions": 464, "deletions": 348}, "files": [{"sha": "1571cf344ede12ed57c174ac2bc4e0382217ae3a", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n use hir::def_id::CrateNum;\n+use ich::Fingerprint;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use std::fmt::Debug;\n-use std::sync::Arc;\n+use std::hash::Hash;\n \n macro_rules! try_opt {\n     ($e:expr) => (\n@@ -51,12 +53,9 @@ pub enum DepNode<D: Clone + Debug> {\n     /// in an extern crate.\n     MetaData(D),\n \n-    /// Represents some piece of metadata global to its crate.\n-    GlobalMetaData(D, GlobalMetaDataKind),\n-\n     /// Represents some artifact that we save to disk. Note that these\n     /// do not have a def-id as part of their identifier.\n-    WorkProduct(Arc<WorkProductId>),\n+    WorkProduct(WorkProductId),\n \n     // Represents different phases in the compiler.\n     RegionMaps(D),\n@@ -307,7 +306,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemBodyNestedBodies(ref d) => op(d).map(ItemBodyNestedBodies),\n             ConstIsRvaluePromotableToStatic(ref d) => op(d).map(ConstIsRvaluePromotableToStatic),\n             IsMirAvailable(ref d) => op(d).map(IsMirAvailable),\n-            GlobalMetaData(ref d, kind) => op(d).map(|d| GlobalMetaData(d, kind)),\n         }\n     }\n }\n@@ -318,17 +316,13 @@ impl<D: Clone + Debug> DepNode<D> {\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct WorkProductId(pub String);\n+pub struct WorkProductId(pub Fingerprint);\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub enum GlobalMetaDataKind {\n-    Krate,\n-    CrateDeps,\n-    DylibDependencyFormats,\n-    LangItems,\n-    LangItemsMissing,\n-    NativeLibraries,\n-    CodeMap,\n-    Impls,\n-    ExportedSymbols,\n+impl WorkProductId {\n+    pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n+        let mut hasher = StableHasher::new();\n+        cgu_name.len().hash(&mut hasher);\n+        cgu_name.hash(&mut hasher);\n+        WorkProductId(hasher.finish())\n+    }\n }"}, {"sha": "dc482b0d6ac853a2cf731d426857eeb586801416", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -13,7 +13,6 @@ use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n-use std::sync::Arc;\n \n use super::dep_node::{DepNode, WorkProductId};\n use super::query::DepGraphQuery;\n@@ -35,10 +34,10 @@ struct DepGraphData {\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n-    previous_work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    previous_work_products: RefCell<FxHashMap<WorkProductId, WorkProduct>>,\n \n     /// Work-products that we generate in this run.\n-    work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    work_products: RefCell<FxHashMap<WorkProductId, WorkProduct>>,\n }\n \n impl DepGraph {\n@@ -120,7 +119,7 @@ impl DepGraph {\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory).\n-    pub fn insert_previous_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+    pub fn insert_previous_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n         debug!(\"insert_previous_work_product({:?}, {:?})\", v, data);\n         self.data.previous_work_products.borrow_mut()\n                                         .insert(v.clone(), data);\n@@ -129,29 +128,29 @@ impl DepGraph {\n     /// Indicates that we created the given work-product in this run\n     /// for `v`. This record will be preserved and loaded in the next\n     /// run.\n-    pub fn insert_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+    pub fn insert_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n         debug!(\"insert_work_product({:?}, {:?})\", v, data);\n         self.data.work_products.borrow_mut()\n                                .insert(v.clone(), data);\n     }\n \n     /// Check whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n-    pub fn previous_work_product(&self, v: &Arc<WorkProductId>) -> Option<WorkProduct> {\n+    pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {\n         self.data.previous_work_products.borrow()\n                                         .get(v)\n                                         .cloned()\n     }\n \n     /// Access the map of work-products created during this run. Only\n     /// used during saving of the dep-graph.\n-    pub fn work_products(&self) -> Ref<FxHashMap<Arc<WorkProductId>, WorkProduct>> {\n+    pub fn work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n         self.data.work_products.borrow()\n     }\n \n     /// Access the map of work-products created during the cached run. Only\n     /// used during saving of the dep-graph.\n-    pub fn previous_work_products(&self) -> Ref<FxHashMap<Arc<WorkProductId>, WorkProduct>> {\n+    pub fn previous_work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n         self.data.previous_work_products.borrow()\n     }\n }"}, {"sha": "809bed939f54ca4bcb78e102d33077f0ba4499f7", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -22,7 +22,6 @@ mod thread;\n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n pub use self::dep_node::WorkProductId;\n-pub use self::dep_node::GlobalMetaDataKind;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;"}, {"sha": "ae43035f3b2e606eea036d783c43aa6d6f563861", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 106, "deletions": 12, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -15,7 +15,8 @@\n //! expressions) that are mostly just leftovers.\n \n use hir;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace,\n+                  CRATE_DEF_INDEX};\n use ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -396,6 +397,11 @@ pub enum DefPathData {\n     ImplTrait,\n     /// A `typeof` type node.\n     Typeof,\n+\n+    /// GlobalMetaData identifies a piece of crate metadata that is global to\n+    /// a whole crate (as opposed to just one item). GlobalMetaData components\n+    /// are only supposed to show up right below the crate root.\n+    GlobalMetaData(Ident)\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -427,8 +433,8 @@ impl Definitions {\n \n     /// Get the number of definitions.\n     pub fn def_index_counts_lo_hi(&self) -> (usize, usize) {\n-        (self.def_index_to_node[DefIndexAddressSpace::Low.index()].len(),\n-         self.def_index_to_node[DefIndexAddressSpace::High.index()].len())\n+        (self.table.index_to_key[DefIndexAddressSpace::Low.index()].len(),\n+         self.table.index_to_key[DefIndexAddressSpace::High.index()].len())\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n@@ -469,7 +475,12 @@ impl Definitions {\n         if def_id.krate == LOCAL_CRATE {\n             let space_index = def_id.index.address_space().index();\n             let array_index = def_id.index.as_array_index();\n-            Some(self.def_index_to_node[space_index][array_index])\n+            let node_id = self.def_index_to_node[space_index][array_index];\n+            if node_id != ast::DUMMY_NODE_ID {\n+                Some(node_id)\n+            } else {\n+                None\n+            }\n         } else {\n             None\n         }\n@@ -498,12 +509,16 @@ impl Definitions {\n \n         // Create the definition.\n         let address_space = super::ITEM_LIKE_SPACE;\n-        let index = self.table.allocate(key, def_path_hash, address_space);\n+        let root_index = self.table.allocate(key, def_path_hash, address_space);\n+        assert_eq!(root_index, CRATE_DEF_INDEX);\n         assert!(self.def_index_to_node[address_space.index()].is_empty());\n         self.def_index_to_node[address_space.index()].push(ast::CRATE_NODE_ID);\n-        self.node_to_def_index.insert(ast::CRATE_NODE_ID, index);\n+        self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n \n-        index\n+        // Allocate some other DefIndices that always must exist.\n+        GlobalMetaDataKind::allocate_def_indices(self);\n+\n+        root_index\n     }\n \n     /// Add a definition with a parent definition.\n@@ -550,13 +565,19 @@ impl Definitions {\n         assert_eq!(index.as_array_index(),\n                    self.def_index_to_node[address_space.index()].len());\n         self.def_index_to_node[address_space.index()].push(node_id);\n+\n+        // Some things for which we allocate DefIndices don't correspond to\n+        // anything in the AST, so they don't have a NodeId. For these cases\n+        // we don't need a mapping from NodeId to DefIndex.\n+        if node_id != ast::DUMMY_NODE_ID {\n+            debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n+            self.node_to_def_index.insert(node_id, index);\n+        }\n+\n         if expansion.is_modern() {\n             self.expansions.insert(index, expansion);\n         }\n \n-        debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n-        self.node_to_def_index.insert(node_id, index);\n-\n         index\n     }\n \n@@ -594,7 +615,8 @@ impl DefPathData {\n             LifetimeDef(ident) |\n             EnumVariant(ident) |\n             Binding(ident) |\n-            Field(ident) => Some(ident),\n+            Field(ident) |\n+            GlobalMetaData(ident) => Some(ident),\n \n             Impl |\n             CrateRoot |\n@@ -622,7 +644,8 @@ impl DefPathData {\n             LifetimeDef(ident) |\n             EnumVariant(ident) |\n             Binding(ident) |\n-            Field(ident) => {\n+            Field(ident) |\n+            GlobalMetaData(ident) => {\n                 return ident.name.as_str();\n             }\n \n@@ -667,3 +690,74 @@ impl ::std::hash::Hash for DefPathData {\n         }\n     }\n }\n+\n+\n+// We define the GlobalMetaDataKind enum with this macro because we want to\n+// make sure that we exhaustively iterate over all variants when registering\n+// the corresponding DefIndices in the DefTable.\n+macro_rules! define_global_metadata_kind {\n+    (pub enum GlobalMetaDataKind {\n+        $($variant:ident),*\n+    }) => (\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+                 RustcEncodable, RustcDecodable)]\n+        pub enum GlobalMetaDataKind {\n+            $($variant),*\n+        }\n+\n+        impl GlobalMetaDataKind {\n+            fn allocate_def_indices(definitions: &mut Definitions) {\n+                $({\n+                    let instance = GlobalMetaDataKind::$variant;\n+                    definitions.create_def_with_parent(\n+                        CRATE_DEF_INDEX,\n+                        ast::DUMMY_NODE_ID,\n+                        DefPathData::GlobalMetaData(instance.ident()),\n+                        DefIndexAddressSpace::High,\n+                        Mark::root()\n+                    );\n+\n+                    // Make sure calling def_index does not crash.\n+                    instance.def_index(&definitions.table);\n+                })*\n+            }\n+\n+            pub fn def_index(&self, def_path_table: &DefPathTable) -> DefIndex {\n+                let def_key = DefKey {\n+                    parent: Some(CRATE_DEF_INDEX),\n+                    disambiguated_data: DisambiguatedDefPathData {\n+                        data: DefPathData::GlobalMetaData(self.ident()),\n+                        disambiguator: 0,\n+                    }\n+                };\n+\n+                def_path_table.key_to_index[&def_key]\n+            }\n+\n+            fn ident(&self) -> Ident {\n+\n+                let string = match *self {\n+                    $(\n+                        GlobalMetaDataKind::$variant => {\n+                            concat!(\"{{GlobalMetaData::\", stringify!($variant), \"}}\")\n+                        }\n+                    )*\n+                };\n+\n+                Ident::from_str(string)\n+            }\n+        }\n+    )\n+}\n+\n+define_global_metadata_kind!(pub enum GlobalMetaDataKind {\n+    Krate,\n+    CrateDeps,\n+    DylibDependencyFormats,\n+    LangItems,\n+    LangItemsMissing,\n+    NativeLibraries,\n+    CodeMap,\n+    Impls,\n+    ExportedSymbols\n+});"}, {"sha": "bf47b9bb9d43d5e3b800c46e3efcc1cc7ab6ae3b", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -29,8 +29,8 @@ pub struct CachingCodemapView<'tcx> {\n     time_stamp: usize,\n }\n \n-impl<'tcx> CachingCodemapView<'tcx> {\n-    pub fn new<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CachingCodemapView<'tcx> {\n+impl<'gcx> CachingCodemapView<'gcx> {\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> CachingCodemapView<'gcx> {\n         let codemap = tcx.sess.codemap();\n         let files = codemap.files();\n         let first_file = files[0].clone();"}, {"sha": "2784a7bd024f66553512dd5563979f7b424bb54f", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -33,9 +33,9 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n-pub struct StableHashingContext<'a, 'tcx: 'a> {\n-    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    codemap: CachingCodemapView<'tcx>,\n+pub struct StableHashingContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'gcx, 'tcx>,\n+    codemap: CachingCodemapView<'gcx>,\n     hash_spans: bool,\n     hash_bodies: bool,\n     overflow_checks_enabled: bool,\n@@ -51,9 +51,9 @@ pub enum NodeIdHashingMode {\n     HashTraitsInScope,\n }\n \n-impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n \n-    pub fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    pub fn new(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n         let hash_spans_initial = tcx.sess.opts.debuginfo != NoDebugInfo;\n         let check_overflow_initial = tcx.sess.overflow_checks();\n \n@@ -111,7 +111,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> ty::TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -131,7 +131,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn codemap(&mut self) -> &mut CachingCodemapView<'tcx> {\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'gcx> {\n         &mut self.codemap\n     }\n \n@@ -195,9 +195,9 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::NodeId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n     // span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use syntax_pos::Pos;\n \n@@ -305,15 +305,16 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n     }\n }\n \n-pub fn hash_stable_hashmap<'a, 'tcx, K, V, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                        hasher: &mut StableHasher<W>,\n-                                                        map: &HashMap<K, V, R>,\n-                                                        extract_stable_key: F)\n+pub fn hash_stable_hashmap<'a, 'gcx, 'tcx, K, V, R, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &HashMap<K, V, R>,\n+    extract_stable_key: F)\n     where K: Eq + std_hash::Hash,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n           R: std_hash::BuildHasher,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = map.keys()\n@@ -327,14 +328,15 @@ pub fn hash_stable_hashmap<'a, 'tcx, K, V, R, SK, F, W>(hcx: &mut StableHashingC\n     }\n }\n \n-pub fn hash_stable_hashset<'a, 'tcx, K, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                     hasher: &mut StableHasher<W>,\n-                                                     set: &HashSet<K, R>,\n-                                                     extract_stable_key: F)\n+pub fn hash_stable_hashset<'a, 'tcx, 'gcx, K, R, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    set: &HashSet<K, R>,\n+    extract_stable_key: F)\n     where K: Eq + std_hash::Hash,\n           R: std_hash::BuildHasher,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = set.iter()\n@@ -344,10 +346,11 @@ pub fn hash_stable_hashset<'a, 'tcx, K, R, SK, F, W>(hcx: &mut StableHashingCont\n     keys.hash_stable(hcx, hasher);\n }\n \n-pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                           hasher: &mut StableHasher<W>,\n-                                           map: &NodeMap<V>)\n-    where V: HashStable<StableHashingContext<'a, 'tcx>>,\n+pub fn hash_stable_nodemap<'a, 'tcx, 'gcx, V, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &NodeMap<V>)\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n           W: StableHasherResult,\n {\n     hash_stable_hashmap(hcx, hasher, map, |hcx, node_id| {\n@@ -356,14 +359,15 @@ pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 't\n }\n \n \n-pub fn hash_stable_btreemap<'a, 'tcx, K, V, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                      hasher: &mut StableHasher<W>,\n-                                                      map: &BTreeMap<K, V>,\n-                                                      extract_stable_key: F)\n+pub fn hash_stable_btreemap<'a, 'tcx, 'gcx, K, V, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &BTreeMap<K, V>,\n+    extract_stable_key: F)\n     where K: Eq + Ord,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = map.keys()"}, {"sha": "7f7a545df9605da37ab88757eab3ce2eab01557d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 65, "deletions": 49, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -12,7 +12,7 @@\n //! types in no particular order.\n \n use hir;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n use ich::{StableHashingContext, NodeIdHashingMode};\n use std::mem;\n \n@@ -21,20 +21,20 @@ use syntax::ast;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for DefId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::HirId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::HirId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::HirId {\n             owner,\n@@ -46,6 +46,19 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::HirId {\n     }\n }\n \n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for CrateNum {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.def_path_hash(DefId {\n+            krate: *self,\n+            index: CRATE_DEF_INDEX\n+        }).hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n \n // The following implementations of HashStable for ItemId, TraitItemId, and\n@@ -55,9 +68,9 @@ impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ItemId {\n             id\n@@ -69,9 +82,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n             node_id\n@@ -83,9 +96,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n             node_id\n@@ -215,9 +228,9 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Ty {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::TySlice(..)       |\n@@ -299,9 +312,9 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitRef {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitRef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n@@ -338,9 +351,9 @@ impl_stable_hash_for!(struct hir::MacroDef {\n });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Block {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Block {\n             ref stmts,\n@@ -386,9 +399,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Pat {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Pat {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::PatKind::Wild        |\n@@ -529,9 +542,9 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Expr {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n@@ -652,9 +665,9 @@ impl_stable_hash_for!(enum hir::LoopSource {\n     ForLoop\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::MatchSource {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use hir::MatchSource;\n \n@@ -703,9 +716,9 @@ impl_stable_hash_for!(enum hir::ScopeTarget {\n     Loop(loop_id_result)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Ident {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n@@ -716,9 +729,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id,\n@@ -749,9 +762,9 @@ impl_stable_hash_for!(enum hir::TraitItemKind {\n     Type(bounds, rhs)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id,\n@@ -781,9 +794,9 @@ impl_stable_hash_for!(enum hir::ImplItemKind {\n     Type(t)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Visibility {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -802,9 +815,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Defaultness {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -823,9 +836,9 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Mod {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Mod {\n             inner,\n@@ -878,9 +891,9 @@ impl_stable_hash_for!(enum hir::VariantData {\n     Unit(id)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Item {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::ItemExternCrate(..) |\n@@ -961,9 +974,10 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::AssociatedItemKind {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -1008,9 +1022,9 @@ impl_stable_hash_for!(struct hir::Body {\n     value\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::BodyId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         if hcx.hash_bodies() {\n             hcx.tcx().hir.body(*self).hash_stable(hcx, hasher);\n@@ -1024,9 +1038,9 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::GlobalAsm {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::GlobalAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::GlobalAsm {\n             asm,\n@@ -1037,9 +1051,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::GlobalAsm {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::InlineAsm {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::InlineAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::InlineAsm {\n             asm,\n@@ -1114,10 +1128,11 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::def_id::DefIndex {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         DefId::local(*self).hash_stable(hcx, hasher);\n     }\n@@ -1129,9 +1144,10 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::lang_items::LangItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }"}, {"sha": "ae2bea3027d44e977470b868396c27a812d74740", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -32,10 +32,11 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Terminator<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::Terminator<'tcx> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Terminator {\n             ref kind,\n@@ -72,59 +73,61 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Terminator<'t\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Local {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Local {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::BasicBlock {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::BasicBlock {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Field {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Field {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::VisibilityScope {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::VisibilityScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Promoted {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Promoted {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::TerminatorKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -182,9 +185,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKin\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::AssertMessage<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -202,9 +206,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::StatementKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -231,9 +236,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -250,12 +255,13 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx>\n     }\n }\n \n-impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection<'tcx, B, V>\n-    where B: HashStable<StableHashingContext<'a, 'tcx>>,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, B, V> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::Projection<'tcx, B, V>\n+    where B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Projection {\n             ref base,\n@@ -267,11 +273,12 @@ impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Project\n     }\n }\n \n-impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::ProjectionElem<'tcx, V>\n-    where V: HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, V> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::ProjectionElem<'tcx, V>\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -302,9 +309,9 @@ impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection\n \n impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Operand<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -319,9 +326,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx>\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Rvalue<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Rvalue<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -379,9 +386,10 @@ impl_stable_hash_for!(enum mir::CastKind {\n     Unsize\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AggregateKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::AggregateKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -435,9 +443,9 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Literal<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Literal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "995f797df2fbead6a1e2dfcac87eadcc267aa97e", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -27,20 +27,21 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::symbol::InternedString {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::syntax::symbol::InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let s: &str = &**self;\n         s.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Name {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n@@ -82,9 +83,10 @@ impl_stable_hash_for!(enum ::syntax::abi::Abi {\n impl_stable_hash_for!(struct ::syntax::attr::Deprecation { since, note });\n impl_stable_hash_for!(struct ::syntax::attr::Stability { level, feature, rustc_depr });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::attr::StabilityLevel {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::syntax::attr::StabilityLevel {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -135,9 +137,9 @@ impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for [ast::Attribute] {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         // Some attributes are always ignored during hashing.\n         let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n@@ -155,9 +157,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n         debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n@@ -184,9 +186,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenTree {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for tokenstream::TokenTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -205,18 +208,19 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::Token\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenStream {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for tokenstream::TokenStream {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-fn hash_token<'a, 'tcx, W: StableHasherResult>(token: &token::Token,\n-                                               hcx: &mut StableHashingContext<'a, 'tcx>,\n+fn hash_token<'a, 'gcx, 'tcx, W: StableHasherResult>(token: &token::Token,\n+                                               hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                                hasher: &mut StableHasher<W>,\n                                                error_reporting_span: Span) {\n     mem::discriminant(token).hash_stable(hcx, hasher);\n@@ -322,9 +326,9 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for FileMap {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n             ref name,"}, {"sha": "4e78d79ef87378e8d1376a1f4a5b368d7fe7facb", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -19,27 +19,30 @@ use std::mem;\n use syntax_pos::symbol::InternedString;\n use ty;\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for &'tcx ty::Slice<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>> {\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for &'tcx ty::Slice<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::subst::Kind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_type().hash_stable(hcx, hasher);\n         self.as_region().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -72,9 +75,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::AutoBorrow<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::adjustment::AutoBorrow<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -89,9 +93,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Au\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Adjust<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::adjustment::Adjust<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -122,9 +127,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::UpvarCapture<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::UpvarCapture<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -143,11 +149,11 @@ impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     abi\n });\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Binder<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.tcx().anonymize_late_bound_regions(self).0.hash_stable(hcx, hasher);\n     }\n@@ -166,12 +172,13 @@ impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n-impl<'a, 'tcx, A, B> HashStable<StableHashingContext<'a, 'tcx>> for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'a, 'tcx>>,\n-          B: HashStable<StableHashingContext<'a, 'tcx>>,\n+impl<'a, 'gcx, 'tcx, A, B> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::OutlivesPredicate<A, B>\n+    where A: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         a.hash_stable(hcx, hasher);\n@@ -183,9 +190,9 @@ impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty }\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { trait_ref, item_def_id });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Predicate<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -221,9 +228,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::AdtFlags {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         std_hash::Hash::hash(self, hasher);\n     }\n@@ -248,10 +255,10 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n for ::middle::const_val::ConstVal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal;\n \n@@ -324,9 +331,9 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Generics {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n@@ -350,9 +357,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionParameterDef {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::RegionParameterDef {\n             name,\n@@ -379,12 +387,12 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n });\n \n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::resolve_lifetime::Set1;\n \n@@ -427,10 +435,11 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::region::CodeExtent\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::region::CodeExtent;\n \n@@ -472,10 +481,11 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n     BrEnv\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeVariants<'tcx>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::TypeVariants<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::TypeVariants::*;\n \n@@ -563,10 +573,11 @@ impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n     mutbl\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::ExistentialPredicate<'tcx>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::ExistentialPredicate<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -595,9 +606,10 @@ impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::TypeckTables<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n             ref type_dependent_defs,"}, {"sha": "f814f941b06f1aed2dd35a0a18b8c3214e8c3e28", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -73,10 +73,10 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $enum_name {\n+        impl<'a, 'gcx, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'gcx, 'tcx>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'gcx, 'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 use $enum_name::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n@@ -92,10 +92,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+        impl<'a, 'gcx, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'gcx, 'tcx>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'gcx, 'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name {\n                     $(ref $field),*\n@@ -106,10 +106,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (tuple_struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+        impl<'a, 'gcx, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'gcx, 'tcx>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'gcx, 'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name (\n                     $(ref $field),*\n@@ -125,11 +125,11 @@ macro_rules! impl_stable_hash_for {\n macro_rules! impl_stable_hash_for_spanned {\n     ($T:path) => (\n \n-        impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::codemap::Spanned<$T>\n+        impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ::syntax::codemap::Spanned<$T>\n         {\n             #[inline]\n             fn hash_stable<W: StableHasherResult>(&self,\n-                                                  hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                  hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                                   hasher: &mut StableHasher<W>) {\n                 self.node.hash_stable(hcx, hasher);\n                 self.span.hash_stable(hcx, hasher);"}, {"sha": "57b8c7f8c16b1570e9d1479926e88a994434d957", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -23,7 +23,6 @@\n // probably get a better home if someone can find one.\n \n use hir::def;\n-use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData,\n@@ -190,15 +189,14 @@ pub struct EncodedMetadataHash {\n /// upstream crate.\n #[derive(Debug, RustcEncodable, RustcDecodable, Clone)]\n pub struct EncodedMetadataHashes {\n-    pub entry_hashes: Vec<EncodedMetadataHash>,\n-    pub global_hashes: Vec<(DepNode<()>, ich::Fingerprint)>,\n+    // Stable content hashes for things in crate metadata, indexed by DefIndex.\n+    pub hashes: Vec<EncodedMetadataHash>,\n }\n \n impl EncodedMetadataHashes {\n     pub fn new() -> EncodedMetadataHashes {\n         EncodedMetadataHashes {\n-            entry_hashes: Vec::new(),\n-            global_hashes: Vec::new(),\n+            hashes: Vec::new(),\n         }\n     }\n }"}, {"sha": "73c702fedb8169910fa56cef3681d582def84b92", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -35,9 +35,9 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Cache {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           _: &mut StableHasher<W>) {\n         // do nothing\n     }"}, {"sha": "503177e437bef8eede30be36197d74dbd479d636", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -197,7 +197,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::ClosureExpr |\n             data @ DefPathData::Binding(..) |\n             data @ DefPathData::ImplTrait |\n-            data @ DefPathData::Typeof => {\n+            data @ DefPathData::Typeof |\n+            data @ DefPathData::GlobalMetaData(..) => {\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n                 self.push_item_path(buffer, parent_def_id);\n                 buffer.push(&data.as_interned_str());"}, {"sha": "afa2da3d561b776d05461eaee2a218ee6775f1a1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -465,9 +465,9 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TyS<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::TyS<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TyS {\n             ref sty,\n@@ -1318,9 +1318,9 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for AdtDef {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for AdtDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::AdtDef {\n             did,"}, {"sha": "634d3041bf4a7a1832ca385df599769baa5a237d", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -244,6 +244,14 @@ impl<CTX> HashStable<CTX> for f64 {\n     }\n }\n \n+impl<T1: HashStable<CTX>, CTX> HashStable<CTX> for (T1,) {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.0.hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl<T1: HashStable<CTX>, T2: HashStable<CTX>, CTX> HashStable<CTX> for (T1, T2) {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n@@ -273,6 +281,24 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     }\n }\n \n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ::std::rc::Rc<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ::std::sync::Arc<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl<CTX> HashStable<CTX> for str {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "7831ae3092f4e43232859e7d2d5abf30b83317eb", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -94,7 +94,7 @@ impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n }\n \n struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n-    hcx: StableHashingContext<'a, 'tcx>,\n+    hcx: StableHashingContext<'a, 'tcx, 'tcx>,\n     hashes: IncrementalHashesMap,\n }\n \n@@ -103,7 +103,7 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                               dep_node: DepNode<DefId>,\n                                               hash_bodies: bool,\n                                               item_like: T)\n-        where T: HashStable<StableHashingContext<'a, 'tcx>>\n+        where T: HashStable<StableHashingContext<'a, 'tcx, 'tcx>>\n     {\n         if !hash_bodies && !self.hcx.tcx().sess.opts.build_dep_graph() {\n             // If we just need the hashes in order to compute the SVH, we don't"}, {"sha": "96b7de94daf65ba80c23b143b4050fafa862b78b", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -15,7 +15,6 @@ use rustc::hir::def_id::DefIndex;\n use rustc::hir::map::DefPathHash;\n use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHash;\n-use std::sync::Arc;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n@@ -98,7 +97,7 @@ pub struct SerializedHash {\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedWorkProduct {\n     /// node that produced the work-product\n-    pub id: Arc<WorkProductId>,\n+    pub id: WorkProductId,\n \n     /// work-product data itself\n     pub work_product: WorkProduct,\n@@ -127,10 +126,6 @@ pub struct SerializedMetadataHashes {\n     /// (matching the one found in this structure).\n     pub entry_hashes: Vec<EncodedMetadataHash>,\n \n-    /// This map contains fingerprints that are not specific to some DefId but\n-    /// describe something global to the whole crate.\n-    pub global_hashes: Vec<(DepNode<()>, Fingerprint)>,\n-\n     /// For each DefIndex (as it occurs in SerializedMetadataHash), this\n     /// map stores the DefPathIndex (as it occurs in DefIdDirectory), so\n     /// that we can find the new DefId for a SerializedMetadataHash in a"}, {"sha": "4a2dd274aae52c00a87af425ae78529a0c0bb2fb", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::ty::TyCtxt;\n@@ -29,9 +29,8 @@ use std::fmt::Debug;\n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n-    item_metadata_hashes: FxHashMap<DefId, Fingerprint>,\n+    metadata_hashes: FxHashMap<DefId, Fingerprint>,\n     crate_hashes: FxHashMap<CrateNum, Svh>,\n-    global_metadata_hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n@@ -41,9 +40,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         HashContext {\n             tcx: tcx,\n             incremental_hashes_map: incremental_hashes_map,\n-            item_metadata_hashes: FxHashMap(),\n+            metadata_hashes: FxHashMap(),\n             crate_hashes: FxHashMap(),\n-            global_metadata_hashes: FxHashMap(),\n         }\n     }\n \n@@ -53,8 +51,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             DepNode::Hir(_) |\n             DepNode::HirBody(_) =>\n                 true,\n-            DepNode::MetaData(def_id) |\n-            DepNode::GlobalMetaData(def_id, _) => !def_id.is_local(),\n+            DepNode::MetaData(def_id) => !def_id.is_local(),\n             _ => false,\n         }\n     }\n@@ -83,13 +80,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             DepNode::MetaData(def_id) if !def_id.is_local() => {\n                 Some(self.metadata_hash(def_id,\n                                         def_id.krate,\n-                                        |this| &mut this.item_metadata_hashes))\n-            }\n-\n-            DepNode::GlobalMetaData(def_id, kind) => {\n-                Some(self.metadata_hash(DepNode::GlobalMetaData(def_id, kind),\n-                                        def_id.krate,\n-                                        |this| &mut this.global_metadata_hashes))\n+                                        |this| &mut this.metadata_hashes))\n             }\n \n             _ => {\n@@ -217,27 +208,11 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             let def_id = DefId { krate: cnum, index: serialized_hash.def_index };\n \n             // record the hash for this dep-node\n-            let old = self.item_metadata_hashes.insert(def_id, serialized_hash.hash);\n+            let old = self.metadata_hashes.insert(def_id, serialized_hash.hash);\n             debug!(\"load_from_data: def_id={:?} hash={}\", def_id, serialized_hash.hash);\n             assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n         }\n \n-        for (dep_node, fingerprint) in serialized_hashes.global_hashes {\n-            // Here we need to remap the CrateNum in the DepNode.\n-            let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-            let dep_node = match dep_node {\n-                DepNode::GlobalMetaData(_, kind) => DepNode::GlobalMetaData(def_id, kind),\n-                other => {\n-                    bug!(\"unexpected DepNode variant: {:?}\", other)\n-                }\n-            };\n-\n-            // record the hash for this dep-node\n-            debug!(\"load_from_data: def_node={:?} hash={}\", dep_node, fingerprint);\n-            let old = self.global_metadata_hashes.insert(dep_node.clone(), fingerprint);\n-            assert!(old.is_none(), \"already have hash for {:?}\", dep_node);\n-        }\n-\n         Ok(())\n     }\n }"}, {"sha": "f2ecf4c74e78109d53f7d3eccd9f13b9a8515b2f", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -22,7 +22,6 @@ use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::default::Default;\n use std::path::{Path};\n-use std::sync::Arc;\n \n use IncrementalHashesMap;\n use super::data::*;\n@@ -327,7 +326,7 @@ fn transitive_dirty_nodes(edge_map: &FxHashMap<DepNode<DefPathHash>, Vec<DepNode\n /// otherwise no longer applicable.\n fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      work_products: Vec<SerializedWorkProduct>,\n-                                     clean_work_products: &FxHashSet<Arc<WorkProductId>>) {\n+                                     clean_work_products: &FxHashSet<WorkProductId>) {\n     debug!(\"reconcile_work_products({:?})\", work_products);\n     for swp in work_products {\n         if !clean_work_products.contains(&swp.id) {\n@@ -424,8 +423,8 @@ fn process_edges<'a, 'tcx, 'edges>(\n     target: &'edges DepNode<DefPathHash>,\n     edges: &'edges FxHashMap<DepNode<DefPathHash>, Vec<DepNode<DefPathHash>>>,\n     dirty_raw_nodes: &DirtyNodes,\n-    clean_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n-    dirty_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n+    clean_work_products: &mut FxHashSet<WorkProductId>,\n+    dirty_work_products: &mut FxHashSet<WorkProductId>,\n     extra_edges: &mut Vec<(&'edges DepNode<DefPathHash>, &'edges DepNode<DefPathHash>)>)\n {\n     // If the target is dirty, skip the edge. If this is an edge"}, {"sha": "01db756f9de042557c6dee7ee8dbb8717f209646", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -255,9 +255,11 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n+    assert_eq!(metadata_hashes.hashes.len(),\n+        metadata_hashes.hashes.iter().map(|x| (x.def_index, ())).collect::<FxHashMap<_,_>>().len());\n+\n     let mut serialized_hashes = SerializedMetadataHashes {\n-        entry_hashes: metadata_hashes.entry_hashes.to_vec(),\n-        global_hashes: metadata_hashes.global_hashes.to_vec(),\n+        entry_hashes: metadata_hashes.hashes.to_vec(),\n         index_map: FxHashMap()\n     };\n "}, {"sha": "16ab10ab4bbbdfd57e9dab211dccb99c1f428d02", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -16,7 +16,6 @@ use rustc::session::Session;\n use rustc::session::config::OutputType;\n use rustc::util::fs::link_or_copy;\n use std::path::PathBuf;\n-use std::sync::Arc;\n use std::fs as std_fs;\n \n pub fn save_trans_partition(sess: &Session,\n@@ -30,7 +29,7 @@ pub fn save_trans_partition(sess: &Session,\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n-    let work_product_id = Arc::new(WorkProductId(cgu_name.to_string()));\n+    let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n \n     let saved_files: Option<Vec<_>> =\n         files.iter()"}, {"sha": "c1b57a543a40dc69174c9743d53f1d9e9730d9e2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -14,8 +14,7 @@ use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n use schema::{CrateRoot, Tracked};\n \n-use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n-use rustc::hir::def_id::{DefId, CrateNum, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::DepKind;\n use rustc::session::Session;\n@@ -516,14 +515,11 @@ impl<'a> CrateLoader<'a> {\n             return cstore::CrateNumMap::new();\n         }\n \n-        let dep_node = DepNode::GlobalMetaData(DefId { krate, index: CRATE_DEF_INDEX },\n-                                               GlobalMetaDataKind::CrateDeps);\n-\n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n         ::std::iter::once(krate).chain(crate_root.crate_deps\n-                                                 .get(&self.sess.dep_graph, dep_node)\n+                                                 .get_untracked()\n                                                  .decode(metadata)\n                                                  .map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);"}, {"sha": "ed67616e58f64fb8253264e79191eacd6c196f3e", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -13,9 +13,9 @@\n \n use schema::{self, Tracked};\n \n-use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n+use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n-use rustc::hir::map::definitions::DefPathTable;\n+use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n use rustc_back::PanicStrategy;\n@@ -304,12 +304,7 @@ impl CrateMetadata {\n     }\n \n     pub fn panic_strategy(&self, dep_graph: &DepGraph) -> PanicStrategy {\n-        let def_id = DefId {\n-            krate: self.cnum,\n-            index: CRATE_DEF_INDEX,\n-        };\n-        let dep_node = DepNode::GlobalMetaData(def_id, GlobalMetaDataKind::Krate);\n-\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n         self.root\n             .panic_strategy\n             .get(dep_graph, dep_node)"}, {"sha": "60cc03f7b792956b6068596b53f416961fcd5bc3", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -23,9 +23,9 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n-use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n+use rustc::dep_graph::{DepNode};\n use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData, DefPathHash};\n-use rustc::hir::map::definitions::DefPathTable;\n+use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n "}, {"sha": "a095fdd508417423506cc43c117de5e09b2ce424", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -13,8 +13,9 @@\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n-use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n+use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n+use rustc::hir::map::definitions::GlobalMetaDataKind;\n use rustc::hir;\n \n use rustc::middle::cstore::LinkagePreference;\n@@ -993,12 +994,8 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_dylib_dependency_formats(&self,\n                                         dep_graph: &DepGraph)\n                                         -> Vec<(CrateNum, LinkagePreference)> {\n-        let def_id = DefId {\n-            krate: self.cnum,\n-            index: CRATE_DEF_INDEX,\n-        };\n-        let dep_node = DepNode::GlobalMetaData(def_id,\n-                                               GlobalMetaDataKind::DylibDependencyFormats);\n+        let dep_node =\n+            self.metadata_dep_node(GlobalMetaDataKind::DylibDependencyFormats);\n         self.root\n             .dylib_dependency_formats\n             .get(dep_graph, dep_node)\n@@ -1198,11 +1195,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn metadata_dep_node(&self, kind: GlobalMetaDataKind) -> DepNode<DefId> {\n-        let def_id = DefId {\n-            krate: self.cnum,\n-            index: CRATE_DEF_INDEX,\n-        };\n-\n-        DepNode::GlobalMetaData(def_id, kind)\n+        let def_index = kind.def_index(&self.def_path_table);\n+        DepNode::MetaData(self.local_def_id(def_index))\n     }\n }"}, {"sha": "2a504c4c07794ed25114833a5d67895a67befebc", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -14,10 +14,10 @@ use isolated_encoder::IsolatedEncoder;\n use schema::*;\n \n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n-                            EncodedMetadata, EncodedMetadataHashes};\n+                            EncodedMetadata, EncodedMetadataHashes,\n+                            EncodedMetadataHash};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n-use rustc::hir::map::definitions::DefPathTable;\n-use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n+use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::ich::Fingerprint;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n@@ -244,7 +244,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     // Encodes something that corresponds to a single DepNode::GlobalMetaData\n     // and registers the Fingerprint in the `metadata_hashes` map.\n     pub fn tracked<'x, DATA, R>(&'x mut self,\n-                                dep_node: DepNode<()>,\n+                                def_index: DefIndex,\n                                 op: fn(&mut IsolatedEncoder<'x, 'a, 'tcx>, DATA) -> R,\n                                 data: DATA)\n                                 -> Tracked<R> {\n@@ -253,7 +253,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let (fingerprint, this) = entry_builder.finish();\n \n         if let Some(fingerprint) = fingerprint {\n-            this.metadata_hashes.global_hashes.push((dep_node, fingerprint));\n+            this.metadata_hashes.hashes.push(EncodedMetadataHash {\n+                def_index,\n+                hash: fingerprint,\n+            })\n         }\n \n         Tracked::new(ret)\n@@ -322,33 +325,38 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n         let mut i = self.position();\n \n+        let tcx = self.tcx;\n+        let global_metadata_def_index = move |kind: GlobalMetaDataKind| {\n+            kind.def_index(tcx.hir.definitions().def_path_table())\n+        };\n+\n         let crate_deps = self.tracked(\n-            DepNode::GlobalMetaData((), GlobalMetaDataKind::CrateDeps),\n+            global_metadata_def_index(GlobalMetaDataKind::CrateDeps),\n             IsolatedEncoder::encode_crate_deps,\n             ());\n         let dylib_dependency_formats = self.tracked(\n-            DepNode::GlobalMetaData((), GlobalMetaDataKind::DylibDependencyFormats),\n+            global_metadata_def_index(GlobalMetaDataKind::DylibDependencyFormats),\n             IsolatedEncoder::encode_dylib_dependency_formats,\n             ());\n         let dep_bytes = self.position() - i;\n \n         // Encode the language items.\n         i = self.position();\n         let lang_items = self.tracked(\n-            DepNode::GlobalMetaData((), GlobalMetaDataKind::LangItems),\n+            global_metadata_def_index(GlobalMetaDataKind::LangItems),\n             IsolatedEncoder::encode_lang_items,\n             ());\n \n         let lang_items_missing = self.tracked(\n-            DepNode::GlobalMetaData((), GlobalMetaDataKind::LangItemsMissing),\n+            global_metadata_def_index(GlobalMetaDataKind::LangItemsMissing),\n             IsolatedEncoder::encode_lang_items_missing,\n             ());\n         let lang_item_bytes = self.position() - i;\n \n         // Encode the native libraries used\n         i = self.position();\n         let native_libraries = self.tracked(\n-            DepNode::GlobalMetaData((), GlobalMetaDataKind::NativeLibraries),\n+            global_metadata_def_index(GlobalMetaDataKind::NativeLibraries),\n             IsolatedEncoder::encode_native_libraries,\n             ());\n         let native_lib_bytes = self.position() - i;\n@@ -366,15 +374,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n         let impls = self.tracked(\n-            DepNode::GlobalMetaData((), GlobalMetaDataKind::Impls),\n+            global_metadata_def_index(GlobalMetaDataKind::Impls),\n             IsolatedEncoder::encode_impls,\n             ());\n         let impl_bytes = self.position() - i;\n \n         // Encode exported symbols info.\n         i = self.position();\n         let exported_symbols = self.tracked(\n-            DepNode::GlobalMetaData((), GlobalMetaDataKind::ExportedSymbols),\n+            global_metadata_def_index(GlobalMetaDataKind::ExportedSymbols),\n             IsolatedEncoder::encode_exported_symbols,\n             self.exported_symbols);\n         let exported_symbols_bytes = self.position() - i;\n@@ -422,10 +430,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let total_bytes = self.position();\n \n-        self.metadata_hashes.global_hashes.push((\n-            DepNode::GlobalMetaData((), GlobalMetaDataKind::Krate),\n-            Fingerprint::from_smaller_hash(link_meta.crate_hash.as_u64())\n-        ));\n+        self.metadata_hashes.hashes.push(EncodedMetadataHash {\n+            def_index: global_metadata_def_index(GlobalMetaDataKind::Krate),\n+            hash: Fingerprint::from_smaller_hash(link_meta.crate_hash.as_u64())\n+        });\n \n         if self.tcx.sess.meta_stats() {\n             let mut zero_bytes = 0;"}, {"sha": "2db9c6a4ff811f76df11e4c6f23e71cbc8a8245b", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n         let (fingerprint, ecx) = entry_builder.finish();\n         if let Some(hash) = fingerprint {\n-            ecx.metadata_hashes.entry_hashes.push(EncodedMetadataHash {\n+            ecx.metadata_hashes.hashes.push(EncodedMetadataHash {\n                 def_index: id.index,\n                 hash: hash,\n             });"}, {"sha": "c4116489357afde361dba77a63c0861e3a0bc830", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -23,7 +23,7 @@ use rustc_serialize::Encodable;\n pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n     pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    hcx: Option<(StableHashingContext<'b, 'tcx>, StableHasher<Fingerprint>)>,\n+    hcx: Option<(StableHashingContext<'b, 'tcx, 'tcx>, StableHasher<Fingerprint>)>,\n }\n \n impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n@@ -61,7 +61,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             value.hash_stable(hcx, hasher);\n@@ -72,7 +72,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = T>,\n-              T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+              T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             let iter = iter.into_iter();\n@@ -111,7 +111,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = &'x T>,\n-              T: 'x + Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+              T: 'x + Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             let iter = iter.into_iter();\n@@ -149,7 +149,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             slice.hash_stable(hcx, hasher);\n@@ -159,7 +159,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             slice.hash_stable(hcx, hasher);"}, {"sha": "9180f9100ad71428d81ca8640c81cb38e06df764", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -221,11 +221,11 @@ impl<T> Tracked<T> {\n     }\n }\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for Tracked<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Tracked<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let Tracked {\n             ref state\n@@ -277,9 +277,9 @@ pub struct TraitImpls {\n     pub impls: LazySeq<DefIndex>,\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for TraitImpls {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             trait_id: (krate, def_index),\n@@ -359,9 +359,9 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer, u8),\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for EntryKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for EntryKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "df8984e6d2479df7060f0ccfe2d6a3e66963e1df", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19193d6390644b5d621934bac6a33caacfb9ad31/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=19193d6390644b5d621934bac6a33caacfb9ad31", "patch": "@@ -114,7 +114,6 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc_incremental::IchHasher;\n use std::hash::Hash;\n-use std::sync::Arc;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n@@ -164,8 +163,8 @@ impl<'tcx> CodegenUnit<'tcx> {\n         &self.items\n     }\n \n-    pub fn work_product_id(&self) -> Arc<WorkProductId> {\n-        Arc::new(WorkProductId(self.name().to_string()))\n+    pub fn work_product_id(&self) -> WorkProductId {\n+        WorkProductId::from_cgu_name(self.name())\n     }\n \n     pub fn work_product_dep_node(&self) -> DepNode<DefId> {"}]}