{"sha": "1f8ebb6a8ebc5ee490158d3f4264f8aefd509045", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOGViYjZhOGViYzVlZTQ5MDE1OGQzZjQyNjRmOGFlZmQ1MDkwNDU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T20:40:36Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T22:18:49Z"}, "message": "core::rt: Move thread-local scheduler to its own module", "tree": {"sha": "ec18069f89b923ca3f8cb751ef3d25182f407a71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec18069f89b923ca3f8cb751ef3d25182f407a71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045", "html_url": "https://github.com/rust-lang/rust/commit/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f1dd1fd212f51f0a2f4fe20f9ebc7e0dc9081d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1dd1fd212f51f0a2f4fe20f9ebc7e0dc9081d8", "html_url": "https://github.com/rust-lang/rust/commit/4f1dd1fd212f51f0a2f4fe20f9ebc7e0dc9081d8"}], "stats": {"total": 208, "additions": 109, "deletions": 99}, "files": [{"sha": "b1227af5f4c331cf86a33a9c8362da8ebb49f00a", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=1f8ebb6a8ebc5ee490158d3f4264f8aefd509045", "patch": "@@ -32,6 +32,7 @@ macro_rules! rtdebug (\n     ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n )\n \n+#[path = \"sched/mod.rs\"]\n mod sched;\n mod rtio;\n pub mod uvll;"}, {"sha": "1b1a003301768ee363edd872ff84c36b811e05ef", "filename": "src/libcore/rt/sched/local.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045/src%2Flibcore%2Frt%2Fsched%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045/src%2Flibcore%2Frt%2Fsched%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal.rs?ref=1f8ebb6a8ebc5ee490158d3f4264f8aefd509045", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Access to the thread-local Scheduler\n+\n+use ptr::mut_null;\n+use libc::c_void;\n+use cast::transmute;\n+\n+use super::Scheduler;\n+use tls = super::super::thread_local_storage;\n+#[cfg(test)] use super::super::uvio::UvEventLoop;\n+\n+/// Give the Scheduler to thread-local storage\n+pub fn put(sched: ~Scheduler) {\n+    unsafe {\n+        let key = tls_key();\n+        let void_sched: *mut c_void = transmute::<~Scheduler, *mut c_void>(sched);\n+        tls::set(key, void_sched);\n+    }\n+}\n+\n+/// Take ownership of the Scheduler from thread-local storage\n+pub fn take() -> ~Scheduler {\n+    unsafe {\n+        let key = tls_key();\n+        let void_sched: *mut c_void = tls::get(key);\n+        assert!(void_sched.is_not_null());\n+        let sched = transmute::<*mut c_void, ~Scheduler>(void_sched);\n+        tls::set(key, mut_null());\n+        return sched;\n+    }\n+}\n+\n+/// Give the Scheduler to thread-local storage for the duration of the block\n+pub fn install(sched: ~Scheduler, f: &fn()) -> ~Scheduler {\n+    put(sched);\n+    f();\n+    return take();\n+}\n+\n+/// Borrow a mutable reference to the thread-local Scheduler\n+/// # Safety Note\n+/// Because this leaves the Scheduler in thread-local storage it is possible\n+/// For the Scheduler pointer to be aliased\n+pub fn borrow(f: &fn(&mut Scheduler)) {\n+    unsafe {\n+        let key = tls_key();\n+        let mut void_sched: *mut c_void = tls::get(key);\n+        assert!(void_sched.is_not_null());\n+        {\n+            let void_sched_ptr = &mut void_sched;\n+            let sched: &mut ~Scheduler = {\n+                transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n+            };\n+            let sched: &mut Scheduler = &mut **sched;\n+            f(sched);\n+        }\n+    }\n+}\n+\n+fn tls_key() -> tls::Key {\n+    unsafe {\n+        let key: *mut c_void = rust_get_sched_tls_key();\n+        let key: &mut tls::Key = transmute(key);\n+        return *key;\n+    }\n+}\n+\n+extern {\n+    fn rust_get_sched_tls_key() -> *mut c_void;\n+}\n+\n+#[test]\n+fn thread_local_scheduler_smoke_test() {\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    put(scheduler);\n+    let _scheduler = take();\n+}\n+\n+#[test]\n+fn thread_local_scheduler_two_instances() {\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    put(scheduler);\n+    let _scheduler = take();\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    put(scheduler);\n+    let _scheduler = take();\n+}\n+\n+#[test]\n+fn install_borrow_smoke_test() {\n+    let scheduler = ~UvEventLoop::new_scheduler();\n+    let _scheduler = do install(scheduler) {\n+        do borrow |_sched| {\n+        }\n+    };\n+}\n+"}, {"sha": "bc25023d05ff631f875bdc3d94929f75c2700894", "filename": "src/libcore/rt/sched/mod.rs", "status": "renamed", "additions": 2, "deletions": 99, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8ebb6a8ebc5ee490158d3f4264f8aefd509045/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=1f8ebb6a8ebc5ee490158d3f4264f8aefd509045", "patch": "@@ -21,6 +21,8 @@ use super::context::Context;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use int;\n \n+mod local;\n+\n /// The Scheduler is responsible for coordinating execution of Tasks\n /// on a single thread. When the scheduler is running it is owned by\n /// thread local storage and the running task is owned by the\n@@ -350,105 +352,6 @@ pub impl Task {\n     }\n }\n \n-mod local {\n-\n-    //! Access to the thread-local Scheduler\n-\n-    use ptr::mut_null;\n-    use libc::c_void;\n-    use cast::transmute;\n-\n-    use super::Scheduler;\n-    use tls = super::super::thread_local_storage;\n-    #[cfg(test)] use super::super::uvio::UvEventLoop;\n-\n-    /// Give the Scheduler to thread-local storage\n-    pub fn put(sched: ~Scheduler) {\n-        unsafe {\n-            let key = tls_key();\n-            let void_sched: *mut c_void = transmute::<~Scheduler, *mut c_void>(sched);\n-            tls::set(key, void_sched);\n-        }\n-    }\n-\n-    /// Take ownership of the Scheduler from thread-local storage\n-    pub fn take() -> ~Scheduler {\n-        unsafe {\n-            let key = tls_key();\n-            let void_sched: *mut c_void = tls::get(key);\n-            assert!(void_sched.is_not_null());\n-            let sched = transmute::<*mut c_void, ~Scheduler>(void_sched);\n-            tls::set(key, mut_null());\n-            return sched;\n-        }\n-    }\n-\n-    /// Give the Scheduler to thread-local storage for the duration of the block\n-    pub fn install(sched: ~Scheduler, f: &fn()) -> ~Scheduler {\n-        put(sched);\n-        f();\n-        return take();\n-    }\n-\n-    /// Borrow a mutable reference to the thread-local Scheduler\n-    /// # Safety Note\n-    /// Because this leaves the Scheduler in thread-local storage it is possible\n-    /// For the Scheduler pointer to be aliased\n-    pub fn borrow(f: &fn(&mut Scheduler)) {\n-        unsafe {\n-            let key = tls_key();\n-            let mut void_sched: *mut c_void = tls::get(key);\n-            assert!(void_sched.is_not_null());\n-            {\n-                let void_sched_ptr = &mut void_sched;\n-                let sched: &mut ~Scheduler = {\n-                    transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n-                };\n-                let sched: &mut Scheduler = &mut **sched;\n-                f(sched);\n-            }\n-        }\n-    }\n-\n-    fn tls_key() -> tls::Key {\n-        unsafe {\n-            let key: *mut c_void = rust_get_sched_tls_key();\n-            let key: &mut tls::Key = transmute(key);\n-            return *key;\n-        }\n-    }\n-\n-    extern {\n-        fn rust_get_sched_tls_key() -> *mut c_void;\n-    }\n-\n-    #[test]\n-    fn thread_local_scheduler_smoke_test() {\n-        let scheduler = ~UvEventLoop::new_scheduler();\n-        put(scheduler);\n-        let _scheduler = take();\n-    }\n-\n-    #[test]\n-    fn thread_local_scheduler_two_instances() {\n-        let scheduler = ~UvEventLoop::new_scheduler();\n-        put(scheduler);\n-        let _scheduler = take();\n-        let scheduler = ~UvEventLoop::new_scheduler();\n-        put(scheduler);\n-        let _scheduler = take();\n-    }\n-\n-    #[test]\n-    fn install_borrow_smoke_test() {\n-        let scheduler = ~UvEventLoop::new_scheduler();\n-        let _scheduler = do install(scheduler) {\n-            do borrow |_sched| {\n-            }\n-        };\n-    }\n-}\n-\n #[test]\n fn test_simple_scheduling() {\n     do run_in_bare_thread {", "previous_filename": "src/libcore/rt/sched.rs"}]}