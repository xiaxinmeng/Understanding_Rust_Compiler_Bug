{"sha": "365b90c6373336365e5464e22862ede0831117ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NWI5MGM2MzczMzM2MzY1ZTU0NjRlMjI4NjJlZGUwODMxMTE3YWU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-28T15:49:24Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T06:44:37Z"}, "message": "refactor memory access methods a bit", "tree": {"sha": "389dc3455e1ce4f7e4a3797f5c7106703265c2e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/389dc3455e1ce4f7e4a3797f5c7106703265c2e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/365b90c6373336365e5464e22862ede0831117ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/365b90c6373336365e5464e22862ede0831117ae", "html_url": "https://github.com/rust-lang/rust/commit/365b90c6373336365e5464e22862ede0831117ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/365b90c6373336365e5464e22862ede0831117ae/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d498d5a4311524fe89a2a0cc8056839a049b28c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d498d5a4311524fe89a2a0cc8056839a049b28c", "html_url": "https://github.com/rust-lang/rust/commit/1d498d5a4311524fe89a2a0cc8056839a049b28c"}], "stats": {"total": 87, "additions": 47, "deletions": 40}, "files": [{"sha": "7d2310244ce5f067bf155f0e9995898ab649d035", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/365b90c6373336365e5464e22862ede0831117ae/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/365b90c6373336365e5464e22862ede0831117ae/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=365b90c6373336365e5464e22862ede0831117ae", "patch": "@@ -287,7 +287,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.\n+    /// in-bounds!  This follows C's/LLVM's rules.  The `access` boolean is just used\n+    /// for the error message.\n+    /// If you want to check bounds before doing a memory access, be sure to\n+    /// check the pointer one past the end of your access, then everything will\n+    /// work out exactly.\n     pub fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n@@ -498,70 +502,71 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Byte accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    /// This checks alignment!\n-    fn get_bytes_unchecked(\n+    /// The last argument controls whether we error out when there are undefined\n+    /// or pointer bytes.  You should never call this, call `get_bytes` or\n+    /// `get_bytes_unchecked` instead,\n+    fn get_bytes_internal(\n         &self,\n         ptr: Pointer,\n         size: Size,\n         align: Align,\n+        check_defined_and_ptr: bool,\n     ) -> EvalResult<'tcx, &[u8]> {\n-        // Zero-sized accesses can use dangling pointers,\n-        // but they still have to be aligned and non-NULL\n+        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        if size.bytes() == 0 {\n-            return Ok(&[]);\n-        }\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds(ptr.offset(size, self)?, true)?;\n+        self.check_bounds(ptr.offset(size, &*self)?, true)?;\n+\n+        if check_defined_and_ptr {\n+            self.check_defined(ptr, size)?;\n+            if self.relocations(ptr, size)?.len() != 0 {\n+                return err!(ReadPointerAsBytes);\n+            }\n+        }\n+\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n         Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n \n-    /// This checks alignment!\n-    fn get_bytes_unchecked_mut(\n+    #[inline]\n+    fn get_bytes(&self, ptr: Pointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(ptr, size, align, true)\n+    }\n+\n+    /// It is the caller's responsibility to handle undefined and pointer bytes.\n+    #[inline]\n+    fn get_bytes_with_undef_and_ptr(\n+        &self,\n+        ptr: Pointer,\n+        size: Size,\n+        align: Align\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(ptr, size, align, false)\n+    }\n+\n+    fn get_bytes_mut(\n         &mut self,\n         ptr: Pointer,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n-        // Zero-sized accesses can use dangling pointers,\n-        // but they still have to be aligned and non-NULL\n+        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        if size.bytes() == 0 {\n-            return Ok(&mut []);\n-        }\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds(ptr.offset(size, &*self)?, true)?;\n+        self.check_bounds(ptr.offset(size, &self)?, true)?;\n+\n+        self.mark_definedness(ptr, size, true)?;\n+        self.clear_relocations(ptr, size)?;\n+\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n         Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n-\n-    fn get_bytes(&self, ptr: Pointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n-        assert_ne!(size.bytes(), 0);\n-        if self.relocations(ptr, size)?.len() != 0 {\n-            return err!(ReadPointerAsBytes);\n-        }\n-        self.check_defined(ptr, size)?;\n-        self.get_bytes_unchecked(ptr, size, align)\n-    }\n-\n-    fn get_bytes_mut(\n-        &mut self,\n-        ptr: Pointer,\n-        size: Size,\n-        align: Align,\n-    ) -> EvalResult<'tcx, &mut [u8]> {\n-        assert_ne!(size.bytes(), 0);\n-        self.clear_relocations(ptr, size)?;\n-        self.mark_definedness(ptr, size, true)?;\n-        self.get_bytes_unchecked_mut(ptr, size, align)\n-    }\n }\n \n /// Reading and writing\n@@ -672,7 +677,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         };\n \n         // This also checks alignment.\n-        let src_bytes = self.get_bytes_unchecked(src, size, src_align)?.as_ptr();\n+        let src_bytes = self.get_bytes_with_undef_and_ptr(src, size, src_align)?.as_ptr();\n         let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n@@ -775,7 +780,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // Make sure we don't read part of a pointer as a pointer\n         self.check_relocation_edges(ptr, size)?;\n         // get_bytes_unchecked tests alignment\n-        let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n+        let bytes = self.get_bytes_with_undef_and_ptr(\n+            ptr, size, ptr_align.min(self.int_align(size))\n+        )?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if !self.is_defined(ptr, size)? {"}]}