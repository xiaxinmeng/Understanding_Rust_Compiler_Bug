{"sha": "cefcadbe9278cf30175e93309cdd5f1da6714869", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZmNhZGJlOTI3OGNmMzAxNzVlOTMzMDljZGQ1ZjFkYTY3MTQ4Njk=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-17T01:56:22Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-18T16:21:39Z"}, "message": "Unify the two kinds of usefulness merging\n\nThis is elegant but a bit of a perf gamble. That said, or-patterns\nrarely have many branches and it's easy to optimize or revert if we ever\nneed to. In the meantime simpler code is worth it.", "tree": {"sha": "6cf4dda981ffb3d9cbc154268dc20c2a44ae047b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cf4dda981ffb3d9cbc154268dc20c2a44ae047b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cefcadbe9278cf30175e93309cdd5f1da6714869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cefcadbe9278cf30175e93309cdd5f1da6714869", "html_url": "https://github.com/rust-lang/rust/commit/cefcadbe9278cf30175e93309cdd5f1da6714869", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cefcadbe9278cf30175e93309cdd5f1da6714869/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6319d737e07d732aa044864933b69a39fdbeec0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6319d737e07d732aa044864933b69a39fdbeec0a", "html_url": "https://github.com/rust-lang/rust/commit/6319d737e07d732aa044864933b69a39fdbeec0a"}], "stats": {"total": 98, "additions": 35, "deletions": 63}, "files": [{"sha": "0ecc034ac0ba9336c7fd23ec7c75172e33faf9b8", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 35, "deletions": 63, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cefcadbe9278cf30175e93309cdd5f1da6714869/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefcadbe9278cf30175e93309cdd5f1da6714869/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=cefcadbe9278cf30175e93309cdd5f1da6714869", "patch": "@@ -632,7 +632,8 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n /// empty intersection.\n /// It is assumed that two spans don't overlap without one being contained in the other; in other\n /// words, that the inclusion structure forms a tree and not a DAG.\n-/// Operations on this do not need to be fast since it's only nonempty in the diagnostic path.\n+/// Intersection is not very efficient. It compares everything pairwise. If needed it could be made\n+/// faster by sorting the `Span`s and merging cleverly.\n #[derive(Debug, Clone, Default)]\n pub(crate) struct SpanSet {\n     /// The minimal set of `Span`s required to represent the whole set. If A and B are `Span`s in\n@@ -715,7 +716,7 @@ impl<'tcx> Usefulness<'tcx> {\n \n     /// When trying several branches and each returns a `Usefulness`, we need to combine the\n     /// results together.\n-    fn merge_or_patterns(usefulnesses: impl Iterator<Item = (Self, Span)>) -> Self {\n+    fn merge(usefulnesses: impl Iterator<Item = Self>) -> Self {\n         // If we have detected some unreachable sub-branches, we only want to keep them when they\n         // were unreachable in _all_ branches. Eg. in the following, the last `true` is unreachable\n         // in the second branch of the first or-pattern, but not otherwise. Therefore we don't want\n@@ -737,62 +738,7 @@ impl<'tcx> Usefulness<'tcx> {\n         // ```\n \n         // Is `None` when no branch was useful. Will often be `Some(Spanset::new())` because the\n-        // sets are only non-empty in the diagnostic path.\n-        let mut unreachables: Option<SpanSet> = None;\n-        // In case of or-patterns we don't want to intersect subpatterns that come from the first\n-        // column. Invariant: contains a list of disjoint spans.\n-        let mut unreachables_this_column = Vec::new();\n-\n-        for (u, branch_span) in usefulnesses {\n-            match u {\n-                Useful(spans) if spans.is_empty() => {\n-                    // Hot path: `spans` is only non-empty in the diagnostic path.\n-                    unreachables = Some(SpanSet::new());\n-                }\n-                Useful(spans) => {\n-                    for span in spans.iter() {\n-                        if branch_span.contains(span) {\n-                            unreachables_this_column.push(span)\n-                        }\n-                    }\n-                    if let Some(set) = &mut unreachables {\n-                        if !set.is_empty() {\n-                            set.intersection_mut(&spans);\n-                        }\n-                    } else {\n-                        unreachables = Some(spans);\n-                    }\n-                }\n-                NotUseful => unreachables_this_column.push(branch_span),\n-                UsefulWithWitness(_) => {\n-                    bug!(\n-                        \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n-                    )\n-                }\n-            }\n-        }\n-\n-        if let Some(mut unreachables) = unreachables {\n-            for span in unreachables_this_column {\n-                // `unreachables` contained no spans from the first column, and\n-                // `unreachables_this_column` contains only disjoint spans. Therefore it is valid\n-                // to call `push_nonintersecting`.\n-                unreachables.push_nonintersecting(span);\n-            }\n-            Useful(unreachables)\n-        } else {\n-            NotUseful\n-        }\n-    }\n-\n-    /// When trying several branches and each returns a `Usefulness`, we need to combine the\n-    /// results together.\n-    fn merge_split_constructors(usefulnesses: impl Iterator<Item = Self>) -> Self {\n-        // If we have detected some unreachable sub-branches, we only want to keep them when they\n-        // were unreachable in _all_ branches. So we take a big intersection.\n-\n-        // Is `None` when no branch was useful. Will often be `Some(Spanset::new())` because the\n-        // sets are only non-empty in the diagnostic path.\n+        // sets are only non-empty in the presence of or-patterns.\n         let mut unreachables: Option<SpanSet> = None;\n         // Witnesses of usefulness, if any.\n         let mut witnesses = Vec::new();\n@@ -831,6 +777,30 @@ impl<'tcx> Usefulness<'tcx> {\n         }\n     }\n \n+    /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n+    /// usefulness mergeable with those from the other branches.\n+    fn unsplit_or_pat(self, this_span: Span, or_pat_spans: &[Span]) -> Self {\n+        match self {\n+            Useful(mut spans) => {\n+                // We register the spans of the other branches of this or-pattern as being\n+                // unreachable from this one. This ensures that intersecting together the sets of\n+                // spans returns what we want.\n+                // Until we optimize `SpanSet` however, intersecting this entails a number of\n+                // comparisons quadratic in the number of branches.\n+                for &span in or_pat_spans {\n+                    if span != this_span {\n+                        spans.push_nonintersecting(span);\n+                    }\n+                }\n+                Useful(spans)\n+            }\n+            x => x,\n+        }\n+    }\n+\n+    /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n+    /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n+    /// with the results of specializing with the other constructors.\n     fn apply_constructor<'p>(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n@@ -1003,21 +973,23 @@ fn is_useful<'p, 'tcx>(\n \n     // If the first pattern is an or-pattern, expand it.\n     let ret = if let Some(vs) = v.expand_or_pat() {\n+        let subspans: Vec<_> = vs.iter().map(|v| v.head().span).collect();\n         // We expand the or pattern, trying each of its branches in turn and keeping careful track\n         // of possible unreachable sub-branches.\n         let mut matrix = matrix.clone();\n         let usefulnesses = vs.into_iter().map(|v| {\n-            let span = v.head().span;\n-            let u = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+            let v_span = v.head().span;\n+            let usefulness =\n+                is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n                 // We push the already-seen patterns into the matrix in order to detect redundant\n                 // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n-            (u, span)\n+            usefulness.unsplit_or_pat(v_span, &subspans)\n         });\n-        Usefulness::merge_or_patterns(usefulnesses)\n+        Usefulness::merge(usefulnesses)\n     } else {\n         // We split the head constructor of `v`.\n         let ctors = v.head_ctor(cx).split(pcx, Some(hir_id));\n@@ -1032,7 +1004,7 @@ fn is_useful<'p, 'tcx>(\n                 is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns)\n         });\n-        Usefulness::merge_split_constructors(usefulnesses)\n+        Usefulness::merge(usefulnesses)\n     };\n     debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n     ret"}]}