{"sha": "aa0a51a7f56c4c343b296492ffaa2bc296c0b224", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMGE1MWE3ZjU2YzRjMzQzYjI5NjQ5MmZmYWEyYmMyOTZjMGIyMjQ=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-13T23:03:28Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-15T16:26:52Z"}, "message": "Converted over benchmarks.", "tree": {"sha": "f1349075711b61a2e28d1e95052c5f45d860e9d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1349075711b61a2e28d1e95052c5f45d860e9d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa0a51a7f56c4c343b296492ffaa2bc296c0b224", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa0a51a7f56c4c343b296492ffaa2bc296c0b224", "html_url": "https://github.com/rust-lang/rust/commit/aa0a51a7f56c4c343b296492ffaa2bc296c0b224", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa0a51a7f56c4c343b296492ffaa2bc296c0b224/comments", "author": null, "committer": null, "parents": [{"sha": "be7325073acb63ed76861de387c6035d714c26db", "url": "https://api.github.com/repos/rust-lang/rust/commits/be7325073acb63ed76861de387c6035d714c26db", "html_url": "https://github.com/rust-lang/rust/commit/be7325073acb63ed76861de387c6035d714c26db"}], "stats": {"total": 141, "additions": 59, "deletions": 82}, "files": [{"sha": "16ae17f1ee59689f2ef04e7b62bada86c3b84e94", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aa0a51a7f56c4c343b296492ffaa2bc296c0b224/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0a51a7f56c4c343b296492ffaa2bc296c0b224/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=aa0a51a7f56c4c343b296492ffaa2bc296c0b224", "patch": "@@ -20,28 +20,31 @@ import std::io;\n import std::getopts;\n import std::task;\n import std::u64;\n-\n-fn recv[T](p: &port[T]) -> T { let x: T; p |> x; ret x; }\n+import std::comm;\n+import std::comm::_port;\n+import std::comm::mk_port;\n+import std::comm::_chan;\n+import std::comm::send;\n \n fn fib(n: int) -> int {\n-    fn pfib(c: chan[int], n: int) {\n+    fn pfib(c: _chan[int], n: int) {\n         if n == 0 {\n-            c <| 0;\n+            send(c, 0);\n         } else if (n <= 2) {\n-            c <| 1;\n+            send(c, 1);\n         } else {\n-            let p = port();\n+            let p = mk_port[int]();\n \n-            let t1 = spawn pfib(chan(p), n - 1);\n-            let t2 = spawn pfib(chan(p), n - 2);\n+            let t1 = task::_spawn(bind pfib(p.mk_chan(), n - 1));\n+            let t2 = task::_spawn(bind pfib(p.mk_chan(), n - 2));\n \n-            c <| recv(p) + recv(p);\n+            send(c, p.recv() + p.recv());\n         }\n     }\n \n-    let p = port();\n-    let t = spawn pfib(chan(p), n);\n-    ret recv(p);\n+    let p = mk_port();\n+    let t = task::_spawn(bind pfib(p.mk_chan(), n));\n+    ret p.recv();\n }\n \n type config = {stress: bool};\n@@ -69,11 +72,11 @@ fn stress_task(id: int) {\n }\n \n fn stress(num_tasks: int) {\n-    let tasks = ~[];\n+    let tasks = [];\n     for each i: int  in range(0, num_tasks) {\n-        tasks += ~[spawn stress_task(i)];\n+        tasks += [task::_spawn(bind stress_task(i))];\n     }\n-    for each i: int  in range(0, num_tasks) { task::join(tasks.(i)); }\n+    for t in tasks { task::join_id(t); }\n }\n \n fn main(argv: vec[str]) {"}, {"sha": "bb0455e0d21f00691fc5b38d65cb776d3ceba726", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa0a51a7f56c4c343b296492ffaa2bc296c0b224/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0a51a7f56c4c343b296492ffaa2bc296c0b224/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=aa0a51a7f56c4c343b296492ffaa2bc296c0b224", "patch": "@@ -7,7 +7,7 @@ import std::str;\n fn f(n: uint) {\n     let i = 0u;\n     while i < n {\n-        task::join(spawn g());\n+        task::join_id(task::_spawn(bind g()));\n         i += 1u;\n     }\n }\n@@ -24,7 +24,7 @@ fn main(args: vec[str]) {\n     };\n     let i = 0u;\n     while i < n {\n-        spawn f(n);\n+        task::_spawn(bind f(n));\n         i += 1u;\n     }\n }\n\\ No newline at end of file"}, {"sha": "6948d34dc2a69d0ebaf35c6b715ff0e37aa6e923", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 39, "deletions": 65, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/aa0a51a7f56c4c343b296492ffaa2bc296c0b224/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0a51a7f56c4c343b296492ffaa2bc296c0b224/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=aa0a51a7f56c4c343b296492ffaa2bc296c0b224", "patch": "@@ -22,38 +22,34 @@ import std::time;\n import std::u64;\n \n import std::task;\n-import clone = std::task::clone_chan;\n+import std::task::task_id;\n+import std::comm;\n+import std::comm::_chan;\n+import std::comm::_port;\n+import std::comm::mk_port;\n+import std::comm::send;\n \n fn map(filename: str, emit: map_reduce::putter) {\n-    // log_err \"mapping \" + filename;\n     let f = io::file_reader(filename);\n \n \n     while true {\n         alt read_word(f) { some(w) { emit(w, 1); } none. { break; } }\n     }\n-    // log_err \"done mapping \" + filename;\n }\n \n fn reduce(word: str, get: map_reduce::getter) {\n-    // log_err \"reducing \" + word;\n     let count = 0;\n \n \n     while true {\n         alt get() {\n           some(_) {\n-            // log_err \"received word \" + word;\n             count += 1;\n           }\n           none. { break }\n         }\n     }\n-\n-    // auto out = io::stdout();\n-    // out.write_line(#fmt(\"%s: %d\", word, count));\n-\n-    // log_err \"reduce \" + word + \" done.\";\n }\n \n mod map_reduce {\n@@ -72,80 +68,66 @@ mod map_reduce {\n     type reducer = fn(str, getter) ;\n \n     tag ctrl_proto {\n-        find_reducer([u8], chan[chan[reduce_proto]]);\n+        find_reducer([u8], _chan[_chan[reduce_proto]]);\n         mapper_done;\n     }\n \n     tag reduce_proto { emit_val(int); done; ref; release; }\n \n-    fn start_mappers(ctrl: chan[ctrl_proto], inputs: &[str]) -> [task] {\n-        let tasks = ~[];\n-        // log_err \"starting mappers\";\n+    fn start_mappers(ctrl: _chan[ctrl_proto], inputs: &[str]) -> [task_id] {\n+        let tasks = [];\n         for i: str  in inputs {\n-            // log_err \"starting mapper for \" + i;\n-            tasks += ~[spawn map_task(ctrl, i)];\n+            tasks += ~[task::_spawn(bind map_task(ctrl, i))];\n         }\n-        // log_err \"done starting mappers\";\n         ret tasks;\n     }\n \n-    fn map_task(ctrl: chan[ctrl_proto], input: str) {\n+    fn map_task(ctrl: _chan[ctrl_proto], input: str) {\n         // log_err \"map_task \" + input;\n         let intermediates = map::new_str_hash();\n \n-        fn emit(im: &map::hashmap[str, chan[reduce_proto]],\n-                ctrl: chan[ctrl_proto], key: str, val: int) {\n-            // log_err \"emitting \" + key;\n+        fn emit(im: &map::hashmap[str, _chan[reduce_proto]],\n+                ctrl: _chan[ctrl_proto], key: str, val: int) {\n             let c;\n             alt im.find(key) {\n               some(_c) {\n \n-                // log_err \"reusing saved channel for \" + key;\n                 c = _c\n               }\n               none. {\n-                // log_err \"fetching new channel for \" + key;\n-                let p = port[chan[reduce_proto]]();\n+                let p = mk_port[_chan[reduce_proto]]();\n                 let keyi = str::bytes(key);\n-                ctrl <| find_reducer(keyi, chan(p));\n-                p |> c;\n-                im.insert(key, clone(c));\n-                c <| ref;\n+                send(ctrl, find_reducer(keyi, p.mk_chan()));\n+                c = p.recv();\n+                im.insert(key, c);\n+                send(c, ref);\n               }\n             }\n-            c <| emit_val(val);\n+            send(c, emit_val(val));\n         }\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        for each kv: @{key: str, val: chan[reduce_proto]}  in\n+        for each kv: @{key: str, val: _chan[reduce_proto]}  in\n                  intermediates.items() {\n-            // log_err \"sending done to reducer for \" + kv._0;\n-            kv.val <| release;\n+            send(kv.val, release);\n         }\n \n-        ctrl <| mapper_done;\n-\n-        // log_err \"~map_task \" + input;\n+        send(ctrl, mapper_done);\n     }\n \n-    fn reduce_task(key: str, out: chan[chan[reduce_proto]]) {\n-        // log_err \"reduce_task \" + key;\n-        let p = port();\n+    fn reduce_task(key: str, out: _chan[_chan[reduce_proto]]) {\n+        let p = mk_port();\n \n-        out <| chan(p);\n+        send(out, p.mk_chan());\n \n         let ref_count = 0;\n         let is_done = false;\n \n-        fn get(p: &port[reduce_proto], ref_count: &mutable int,\n+        fn get(p: &_port[reduce_proto], ref_count: &mutable int,\n                is_done: &mutable bool) -> option[int] {\n             while !is_done || ref_count > 0 {\n-                let m;\n-                p |> m;\n-\n-\n-                alt m {\n+                alt p.recv() {\n                   emit_val(v) {\n                     // log_err #fmt(\"received %d\", v);\n                     ret some(v);\n@@ -162,28 +144,24 @@ mod map_reduce {\n         }\n \n         reduce(key, bind get(p, ref_count, is_done));\n-        // log_err \"~reduce_task \" + key;\n     }\n \n     fn map_reduce(inputs: &[str]) {\n-        let ctrl = port[ctrl_proto]();\n+        let ctrl = mk_port[ctrl_proto]();\n \n-        // This task becomes the master control task. It spawns others\n+        // This task becomes the master control task. It task::_spawns\n         // to do the rest.\n \n-        let reducers: map::hashmap[str, chan[reduce_proto]];\n+        let reducers: map::hashmap[str, _chan[reduce_proto]];\n \n         reducers = map::new_str_hash();\n \n-        let tasks = start_mappers(chan(ctrl), inputs);\n+        let tasks = start_mappers(ctrl.mk_chan(), inputs);\n \n         let num_mappers = ivec::len(inputs) as int;\n \n         while num_mappers > 0 {\n-            let m;\n-            ctrl |> m;\n-\n-            alt m {\n+            alt ctrl.recv() {\n               mapper_done. {\n                 // log_err \"received mapper terminated.\";\n                 num_mappers -= 1;\n@@ -199,27 +177,23 @@ mod map_reduce {\n                   }\n                   none. {\n                     // log_err \"creating new reducer for \" + k;\n-                    let p = port();\n-                    tasks += ~[spawn reduce_task(k, chan(p))];\n-                    p |> c;\n+                    let p = mk_port();\n+                    tasks += [task::_spawn(bind reduce_task(k, p.mk_chan()))];\n+                    c = p.recv();\n                     reducers.insert(k, c);\n                   }\n                 }\n-                cc <| clone(c);\n+                send(cc, c);\n               }\n             }\n         }\n \n-        for each kv: @{key: str, val: chan[reduce_proto]}  in reducers.items()\n+        for each kv: @{key: str, val: _chan[reduce_proto]} in reducers.items()\n                  {\n-            // log_err \"sending done to reducer for \" + kv._0;\n-            kv.val <| done;\n+            send(kv.val, done);\n         }\n \n-\n-        // log_err #fmt(\"joining %u tasks\", ivec::len(tasks));\n-        for t: task  in tasks { task::join(t); }\n-        // log_err \"control task done.\";\n+        for t in tasks { task::join_id(t); }\n     }\n }\n "}]}