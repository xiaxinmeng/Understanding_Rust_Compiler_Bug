{"sha": "3dbdb3a3646931cb11db90d65971da8b16d819e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYmRiM2EzNjQ2OTMxY2IxMWRiOTBkNjU5NzFkYThiMTZkODE5ZTQ=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-15T02:31:52Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-22T00:24:20Z"}, "message": "Methodize TypeNames", "tree": {"sha": "0ed8b96af3c16a56cbbbb27ab477c61ca5193d87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ed8b96af3c16a56cbbbb27ab477c61ca5193d87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dbdb3a3646931cb11db90d65971da8b16d819e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbdb3a3646931cb11db90d65971da8b16d819e4", "html_url": "https://github.com/rust-lang/rust/commit/3dbdb3a3646931cb11db90d65971da8b16d819e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dbdb3a3646931cb11db90d65971da8b16d819e4/comments", "author": null, "committer": null, "parents": [{"sha": "544f6159f730467e768143b974729bcc340c7dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/544f6159f730467e768143b974729bcc340c7dad", "html_url": "https://github.com/rust-lang/rust/commit/544f6159f730467e768143b974729bcc340c7dad"}], "stats": {"total": 176, "additions": 69, "deletions": 107}, "files": [{"sha": "771cc8e6fea2ae43934c4a64ec6a85a2b0bb5787", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 64, "deletions": 104, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/3dbdb3a3646931cb11db90d65971da8b16d819e4/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbdb3a3646931cb11db90d65971da8b16d819e4/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=3dbdb3a3646931cb11db90d65971da8b16d819e4", "patch": "@@ -2121,121 +2121,81 @@ pub fn ConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    type_names: @mut HashMap<TypeRef, @str>,\n-    named_types: @mut HashMap<@str, TypeRef>\n+    type_names: HashMap<TypeRef, @str>,\n+    named_types: HashMap<@str, TypeRef>\n }\n \n-pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n-    assert!(tn.type_names.insert(t, s));\n-    assert!(tn.named_types.insert(s, t));\n-}\n-\n-pub fn type_has_name(tn: @TypeNames, t: TypeRef) -> Option<@str> {\n-    return tn.type_names.find(&t).map_consume(|x| *x);\n-}\n-\n-pub fn name_has_type(tn: @TypeNames, s: @str) -> Option<TypeRef> {\n-    return tn.named_types.find(&s).map_consume(|x| *x);\n-}\n-\n-pub fn mk_type_names() -> @TypeNames {\n-    @TypeNames {\n-        type_names: @mut HashMap::new(),\n-        named_types: @mut HashMap::new()\n+impl TypeNames {\n+    pub fn new() -> TypeNames {\n+        TypeNames {\n+            type_names: HashMap::new(),\n+            named_types: HashMap::new()\n+        }\n     }\n-}\n-\n-pub fn type_to_str(names: @TypeNames, ty: TypeRef) -> @str {\n-    return type_to_str_inner(names, [], ty);\n-}\n \n-pub fn type_to_str_inner(names: @TypeNames, outer0: &[TypeRef], ty: TypeRef)\n-                      -> @str {\n-    unsafe {\n-        match type_has_name(names, ty) {\n-          option::Some(n) => return n,\n-          _ => {}\n-        }\n+    pub fn associate_type(&mut self, s: @str, t: TypeRef) {\n+        assert!(self.type_names.insert(t, s));\n+        assert!(self.named_types.insert(s, t));\n+    }\n \n-        let outer = vec::append_one(outer0.to_owned(), ty);\n+    pub fn find_name(&self, ty: &TypeRef) -> Option<@str> {\n+        self.type_names.find_copy(ty)\n+    }\n \n-        let kind = llvm::LLVMGetTypeKind(ty);\n+    pub fn find_type(&self, s: &str) -> Option<TypeRef> {\n+        self.named_types.find_equiv(s).map_consume(|x| *x)\n+    }\n \n-        fn tys_str(names: @TypeNames, outer: &[TypeRef],\n-                   tys: ~[TypeRef]) -> @str {\n-            let mut s = ~\"\";\n-            let mut first: bool = true;\n-            for tys.each |t| {\n-                if first { first = false; } else { s += \", \"; }\n-                s += type_to_str_inner(names, outer, *t);\n-            }\n-            // [Note at-str] FIXME #2543: Could rewrite this without the copy,\n-            // but need better @str support.\n-            return s.to_managed();\n+    pub fn type_to_str(&self, ty: TypeRef) -> ~str {\n+        match self.find_name(&ty) {\n+            option::Some(name) => return name.to_owned(),\n+            None => ()\n         }\n \n-        match kind {\n-          Void => return @\"Void\",\n-          Half => return @\"Half\",\n-          Float => return @\"Float\",\n-          Double => return @\"Double\",\n-          X86_FP80 => return @\"X86_FP80\",\n-          FP128 => return @\"FP128\",\n-          PPC_FP128 => return @\"PPC_FP128\",\n-          Label => return @\"Label\",\n-          Integer => {\n-            // See [Note at-str]\n-            return fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty)\n-                        as int).to_managed();\n-          }\n-          Function => {\n-            let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n-            let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n-            let args = vec::from_elem(n_args, 0 as TypeRef);\n-            llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n-            // See [Note at-str]\n-            return fmt!(\"fn(%s) -> %s\",\n-                        tys_str(names, outer, args),\n-                        type_to_str_inner(names, outer, out_ty)).to_managed();\n-          }\n-          Struct => {\n-            let elts = struct_tys(ty);\n-            // See [Note at-str]\n-            return fmt!(\"{%s}\", tys_str(names, outer, elts)).to_managed();\n-          }\n-          Array => {\n-            let el_ty = llvm::LLVMGetElementType(ty);\n-            // See [Note at-str]\n-            return fmt!(\"[%s@ x %u\", type_to_str_inner(names, outer, el_ty),\n-                llvm::LLVMGetArrayLength(ty) as uint).to_managed();\n-          }\n-          Pointer => {\n-            let mut i = 0;\n-            for outer0.each |tout| {\n-                i += 1;\n-                if *tout as int == ty as int {\n-                    let n = outer0.len() - i;\n-                    // See [Note at-str]\n-                    return fmt!(\"*\\\\%d\", n as int).to_managed();\n+        unsafe {\n+            let kind = llvm::LLVMGetTypeKind(ty);\n+\n+            match kind {\n+                Void => ~\"Void\",\n+                Half => ~\"Half\",\n+                Double => ~\"Double\",\n+                X86_FP80 => ~\"X86_FP80\",\n+                FP128 => ~\"FP128\",\n+                PPC_FP128 => ~\"PPC_FP128\",\n+                Label => ~\"Label\",\n+                Vector => ~\"Vector\",\n+                Metadata => ~\"Metadata\",\n+                X86_MMX => ~\"X86_MMAX\",\n+                Integer => {\n+                    fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty) as int)\n                 }\n-            }\n-            let addrstr = {\n-                let addrspace = llvm::LLVMGetPointerAddressSpace(ty) as uint;\n-                if addrspace == 0 {\n-                    ~\"\"\n-                } else {\n-                    fmt!(\"addrspace(%u)\", addrspace)\n+                Function => {\n+                    let out_ty = llvm::LLVMGetReturnType(ty);\n+                    let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n+                    let args = vec::from_elem(n_args, 0 as TypeRef);\n+                    llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n+\n+                    let args = args.map(|&ty| self.type_to_str(ty)).connect(\", \");\n+                    let out_ty = self.type_to_str(out_ty);\n+                    fmt!(\"fn(%s) -> %s\", args, out_ty)\n                 }\n-            };\n-            // See [Note at-str]\n-            return fmt!(\"%s*%s\", addrstr, type_to_str_inner(names,\n-                        outer,\n-                        llvm::LLVMGetElementType(ty))).to_managed();\n-          }\n-          Vector => return @\"Vector\",\n-          Metadata => return @\"Metadata\",\n-          X86_MMX => return @\"X86_MMAX\",\n-          _ => fail!()\n+                Struct => {\n+                    let tys = struct_tys(ty);\n+                    let tys = tys.map(|ty| self.type_to_str(ty)).connect(\", \");\n+                    fmt!(\"{%s}\", tys)\n+                }\n+                Array => {\n+                    let el_ty = llvm::LLVMGetElementType(ty);\n+                    let el_ty = self.type_to_str(el_ty);\n+                    let len = llvm::LLVMGetArrayLength(ty) as uint;\n+                    fmt!(\"[%s x %u]\", el_ty, len)\n+                }\n+                Pointer => {\n+                    let el_ty = llvm::LLVMGetElementType(ty);\n+                    let el_ty = self.type_to_str(el_ty);\n+                    fmt!(\"*%s\", el_ty)\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "8391ff95599b31adda22ea5cef34392f7708a7c9", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dbdb3a3646931cb11db90d65971da8b16d819e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbdb3a3646931cb11db90d65971da8b16d819e4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=3dbdb3a3646931cb11db90d65971da8b16d819e4", "patch": "@@ -46,7 +46,7 @@ pub struct CrateContext {\n      llmod: ModuleRef,\n      llcx: ContextRef,\n      td: TargetData,\n-     tn: @TypeNames,\n+     tn: TypeNames,\n      externs: ExternMap,\n      intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: HashMap<ast::node_id, ValueRef>,\n@@ -136,16 +136,18 @@ impl CrateContext {\n             str::as_c_str(data_layout, |buf| llvm::LLVMSetDataLayout(llmod, buf));\n             str::as_c_str(targ_triple, |buf| llvm::LLVMSetTarget(llmod, buf));\n             let targ_cfg = sess.targ_cfg;\n+\n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n-            let tn = mk_type_names();\n+            let tn = TypeNames::new();\n+\n             let mut intrinsics = base::declare_intrinsics(llmod);\n             if sess.opts.extra_debuginfo {\n                 base::declare_dbg_intrinsics(llmod, &mut intrinsics);\n             }\n             let int_type = T_int(targ_cfg);\n             let float_type = T_float(targ_cfg);\n             let tydesc_type = T_tydesc(targ_cfg);\n-            lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n+            tn.associate_type(@\"tydesc\", tydesc_type);\n             let crate_map = decl_crate_map(sess, link_meta, llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n                 Some(debuginfo::DebugContext::new(llmod, name.to_owned()))"}]}