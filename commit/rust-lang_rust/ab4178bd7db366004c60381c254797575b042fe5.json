{"sha": "ab4178bd7db366004c60381c254797575b042fe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNDE3OGJkN2RiMzY2MDA0YzYwMzgxYzI1NDc5NzU3NWIwNDJmZTU=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-04-07T15:49:02Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-04-07T15:49:47Z"}, "message": "wf: refactor `compute_trait_ref`", "tree": {"sha": "082437e236ae57f153fdd828568dcc7fb62a36c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/082437e236ae57f153fdd828568dcc7fb62a36c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab4178bd7db366004c60381c254797575b042fe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab4178bd7db366004c60381c254797575b042fe5", "html_url": "https://github.com/rust-lang/rust/commit/ab4178bd7db366004c60381c254797575b042fe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab4178bd7db366004c60381c254797575b042fe5/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "html_url": "https://github.com/rust-lang/rust/commit/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0"}], "stats": {"total": 306, "additions": 151, "deletions": 155}, "files": [{"sha": "d506ddab909e752b5aa2d2a7ee71ac2be2ae5e7e", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 151, "deletions": 155, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/ab4178bd7db366004c60381c254797575b042fe5/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4178bd7db366004c60381c254797575b042fe5/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=ab4178bd7db366004c60381c254797575b042fe5", "patch": "@@ -134,6 +134,152 @@ enum Elaborate {\n     None,\n }\n \n+fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: &ty::TraitRef<'tcx>,\n+    item: Option<&hir::Item<'tcx>>,\n+    cause: &mut traits::ObligationCause<'tcx>,\n+    pred: &ty::Predicate<'_>,\n+    mut trait_assoc_items: impl Iterator<Item = ty::AssocItem>,\n+) {\n+    let trait_item =\n+        tcx.hir().as_local_hir_id(trait_ref.def_id).and_then(|trait_id| tcx.hir().find(trait_id));\n+    let (trait_name, trait_generics) = match trait_item {\n+        Some(hir::Node::Item(hir::Item {\n+            ident,\n+            kind: hir::ItemKind::Trait(.., generics, _, _),\n+            ..\n+        }))\n+        | Some(hir::Node::Item(hir::Item {\n+            ident,\n+            kind: hir::ItemKind::TraitAlias(generics, _),\n+            ..\n+        })) => (Some(ident), Some(generics)),\n+        _ => (None, None),\n+    };\n+\n+    let item_span = item.map(|i| tcx.sess.source_map().guess_head_span(i.span));\n+    match pred {\n+        ty::Predicate::Projection(proj) => {\n+            // The obligation comes not from the current `impl` nor the `trait` being\n+            // implemented, but rather from a \"second order\" obligation, like in\n+            // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`:\n+            //\n+            //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+            //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+            //      |\n+            //   LL |     type Ok;\n+            //      |          -- associated type defined here\n+            //   ...\n+            //   LL | impl Bar for Foo {\n+            //      | ---------------- in this `impl` item\n+            //   LL |     type Ok = ();\n+            //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n+            //      |\n+            //      = note: expected type `u32`\n+            //                 found type `()`\n+            //\n+            // FIXME: we would want to point a span to all places that contributed to this\n+            // obligation. In the case above, it should be closer to:\n+            //\n+            //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+            //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+            //      |\n+            //   LL |     type Ok;\n+            //      |          -- associated type defined here\n+            //   LL |     type Sibling: Bar2<Ok=Self::Ok>;\n+            //      |     -------------------------------- obligation set here\n+            //   ...\n+            //   LL | impl Bar for Foo {\n+            //      | ---------------- in this `impl` item\n+            //   LL |     type Ok = ();\n+            //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n+            //   ...\n+            //   LL | impl Bar2 for Foo2 {\n+            //      | ---------------- in this `impl` item\n+            //   LL |     type Ok = u32;\n+            //      |     -------------- obligation set here\n+            //      |\n+            //      = note: expected type `u32`\n+            //                 found type `()`\n+            if let Some(hir::ItemKind::Impl { items, .. }) = item.map(|i| &i.kind) {\n+                let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n+                if let Some(impl_item) =\n+                    items.iter().find(|item| item.ident == trait_assoc_item.ident)\n+                {\n+                    cause.span = impl_item.span;\n+                    cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                        impl_span: item_span,\n+                        original: trait_assoc_item.ident.span,\n+                        bounds: vec![],\n+                    }));\n+                }\n+            }\n+        }\n+        ty::Predicate::Trait(proj, _) => {\n+            // An associated item obligation born out of the `trait` failed to be met.\n+            // Point at the `impl` that failed the obligation, the associated item that\n+            // needed to meet the obligation, and the definition of that associated item,\n+            // which should hold the obligation in most cases. An example can be seen in\n+            // `src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs`:\n+            //\n+            //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n+            //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+            //      |\n+            //   LL |     type Assoc: Bar;\n+            //      |          ----- associated type defined here\n+            //   ...\n+            //   LL | impl Foo for () {\n+            //      | --------------- in this `impl` item\n+            //   LL |     type Assoc = bool;\n+            //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+            //\n+            // If the obligation comes from the where clause in the `trait`, we point at it:\n+            //\n+            //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n+            //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+            //      |\n+            //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n+            //      |                 -------------------------- restricted in this bound\n+            //   LL |     type Assoc;\n+            //      |          ----- associated type defined here\n+            //   ...\n+            //   LL | impl Foo for () {\n+            //      | --------------- in this `impl` item\n+            //   LL |     type Assoc = bool;\n+            //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+            if let (\n+                ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n+                Some(hir::ItemKind::Impl { items, .. }),\n+            ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind))\n+            {\n+                if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n+                    .find(|i| i.def_id == *item_def_id)\n+                    .and_then(|trait_assoc_item| {\n+                        items\n+                            .iter()\n+                            .find(|i| i.ident == trait_assoc_item.ident)\n+                            .map(|impl_item| (impl_item, trait_assoc_item))\n+                    })\n+                {\n+                    let bounds = trait_generics\n+                        .map(|generics| {\n+                            get_generic_bound_spans(&generics, trait_name, trait_assoc_item.ident)\n+                        })\n+                        .unwrap_or_else(Vec::new);\n+                    cause.span = impl_item.span;\n+                    cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                        impl_span: item_span,\n+                        original: trait_assoc_item.ident.span,\n+                        bounds,\n+                    }));\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n@@ -163,170 +309,20 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n \n-        let item = &self.item;\n-        let extend_cause_with_original_assoc_item_obligation =\n-            |cause: &mut traits::ObligationCause<'_>,\n-             pred: &ty::Predicate<'_>,\n-             trait_assoc_items: &[ty::AssocItem]| {\n-                let trait_item = tcx\n-                    .hir()\n-                    .as_local_hir_id(trait_ref.def_id)\n-                    .and_then(|trait_id| tcx.hir().find(trait_id));\n-                let (trait_name, trait_generics) = match trait_item {\n-                    Some(hir::Node::Item(hir::Item {\n-                        ident,\n-                        kind: hir::ItemKind::Trait(.., generics, _, _),\n-                        ..\n-                    }))\n-                    | Some(hir::Node::Item(hir::Item {\n-                        ident,\n-                        kind: hir::ItemKind::TraitAlias(generics, _),\n-                        ..\n-                    })) => (Some(ident), Some(generics)),\n-                    _ => (None, None),\n-                };\n-\n-                let item_span = item.map(|i| tcx.sess.source_map().guess_head_span(i.span));\n-                match pred {\n-                    ty::Predicate::Projection(proj) => {\n-                        // The obligation comes not from the current `impl` nor the `trait` being\n-                        // implemented, but rather from a \"second order\" obligation, like in\n-                        // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`:\n-                        //\n-                        //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n-                        //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n-                        //      |\n-                        //   LL |     type Ok;\n-                        //      |          -- associated type defined here\n-                        //   ...\n-                        //   LL | impl Bar for Foo {\n-                        //      | ---------------- in this `impl` item\n-                        //   LL |     type Ok = ();\n-                        //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n-                        //      |\n-                        //      = note: expected type `u32`\n-                        //                 found type `()`\n-                        //\n-                        // FIXME: we would want to point a span to all places that contributed to this\n-                        // obligation. In the case above, it should be closer to:\n-                        //\n-                        //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n-                        //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n-                        //      |\n-                        //   LL |     type Ok;\n-                        //      |          -- associated type defined here\n-                        //   LL |     type Sibling: Bar2<Ok=Self::Ok>;\n-                        //      |     -------------------------------- obligation set here\n-                        //   ...\n-                        //   LL | impl Bar for Foo {\n-                        //      | ---------------- in this `impl` item\n-                        //   LL |     type Ok = ();\n-                        //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n-                        //   ...\n-                        //   LL | impl Bar2 for Foo2 {\n-                        //      | ---------------- in this `impl` item\n-                        //   LL |     type Ok = u32;\n-                        //      |     -------------- obligation set here\n-                        //      |\n-                        //      = note: expected type `u32`\n-                        //                 found type `()`\n-                        if let Some(hir::ItemKind::Impl { items, .. }) = item.map(|i| &i.kind) {\n-                            let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n-                            if let Some(impl_item) =\n-                                items.iter().find(|item| item.ident == trait_assoc_item.ident)\n-                            {\n-                                cause.span = impl_item.span;\n-                                cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n-                                    impl_span: item_span,\n-                                    original: trait_assoc_item.ident.span,\n-                                    bounds: vec![],\n-                                }));\n-                            }\n-                        }\n-                    }\n-                    ty::Predicate::Trait(proj, _) => {\n-                        // An associated item obligation born out of the `trait` failed to be met.\n-                        // Point at the `impl` that failed the obligation, the associated item that\n-                        // needed to meet the obligation, and the definition of that associated item,\n-                        // which should hold the obligation in most cases. An example can be seen in\n-                        // `src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs`:\n-                        //\n-                        //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n-                        //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n-                        //      |\n-                        //   LL |     type Assoc: Bar;\n-                        //      |          ----- associated type defined here\n-                        //   ...\n-                        //   LL | impl Foo for () {\n-                        //      | --------------- in this `impl` item\n-                        //   LL |     type Assoc = bool;\n-                        //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n-                        //\n-                        // If the obligation comes from the where clause in the `trait`, we point at it:\n-                        //\n-                        //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n-                        //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n-                        //      |\n-                        //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n-                        //      |                 -------------------------- restricted in this bound\n-                        //   LL |     type Assoc;\n-                        //      |          ----- associated type defined here\n-                        //   ...\n-                        //   LL | impl Foo for () {\n-                        //      | --------------- in this `impl` item\n-                        //   LL |     type Assoc = bool;\n-                        //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n-                        if let (\n-                            ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n-                            Some(hir::ItemKind::Impl { items, .. }),\n-                        ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind))\n-                        {\n-                            if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n-                                .iter()\n-                                .find(|i| i.def_id == *item_def_id)\n-                                .and_then(|trait_assoc_item| {\n-                                    items\n-                                        .iter()\n-                                        .find(|i| i.ident == trait_assoc_item.ident)\n-                                        .map(|impl_item| (impl_item, trait_assoc_item))\n-                                })\n-                            {\n-                                let bounds = trait_generics\n-                                    .map(|generics| {\n-                                        get_generic_bound_spans(\n-                                            &generics,\n-                                            trait_name,\n-                                            trait_assoc_item.ident,\n-                                        )\n-                                    })\n-                                    .unwrap_or_else(Vec::new);\n-                                cause.span = impl_item.span;\n-                                cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n-                                    impl_span: item_span,\n-                                    original: trait_assoc_item.ident.span,\n-                                    bounds,\n-                                }));\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            };\n+        let item = self.item;\n \n         if let Elaborate::All = elaborate {\n-            // FIXME: Make `extend_cause_with_original_assoc_item_obligation` take an iterator\n-            // instead of a slice.\n-            let trait_assoc_items: Vec<_> =\n-                tcx.associated_items(trait_ref.def_id).in_definition_order().copied().collect();\n-\n             let predicates = obligations.iter().map(|obligation| obligation.predicate).collect();\n             let implied_obligations = traits::elaborate_predicates(tcx, predicates);\n             let implied_obligations = implied_obligations.map(|pred| {\n                 let mut cause = cause.clone();\n                 extend_cause_with_original_assoc_item_obligation(\n+                    tcx,\n+                    trait_ref,\n+                    item,\n                     &mut cause,\n                     &pred,\n-                    &*trait_assoc_items,\n+                    tcx.associated_items(trait_ref.def_id).in_definition_order().copied(),\n                 );\n                 traits::Obligation::new(cause, param_env, pred)\n             });"}]}